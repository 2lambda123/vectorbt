<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.indicators.basic API documentation</title>
<meta name="description" content="Indicators built with `vectorbt.indicators.factory.IndicatorFactory` …" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:rgba(0,0,0,.2);border:none;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3A4D6B}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.indicators.basic</code></h1>
</header>
<section id="section-intro">
<p>Indicators built with <code><a title="vectorbt.indicators.factory.IndicatorFactory" href="factory.html#vectorbt.indicators.factory.IndicatorFactory">IndicatorFactory</a></code>.</p>
<pre><code class="python-repl">&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from datetime import datetime, timedelta
&gt;&gt;&gt; import itertools
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; import yfinance as yf

&gt;&gt;&gt; ticker = yf.Ticker(&quot;BTC-USD&quot;)
&gt;&gt;&gt; price = ticker.history(start=datetime(2019, 3, 1), end=datetime(2019, 9, 1))
&gt;&gt;&gt; price = price[['Open', 'High', 'Low', 'Close', 'Volume']]
&gt;&gt;&gt; print(price)
                Open      High       Low     Close       Volume
Date
2019-02-28   3848.26   3906.06   3845.82   3854.79   8399767798
2019-03-01   3853.76   3907.80   3851.69   3859.58   7661247975
2019-03-02   3855.32   3874.61   3832.13   3864.42   7578786075
...              ...       ...       ...       ...          ...
2019-08-29   9756.79   9756.79   9421.63   9510.20  17045878500
2019-08-30   9514.84   9656.12   9428.30   9598.17  13595263986
2019-08-31   9597.54   9673.22   9531.80   9630.66  11454806419

[185 rows x 5 columns]

&gt;&gt;&gt; price['Close'].vbt.plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/Indicators_price.png"></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Indicators built with `vectorbt.indicators.factory.IndicatorFactory`.

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from datetime import datetime, timedelta
&gt;&gt;&gt; import itertools
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; import yfinance as yf

&gt;&gt;&gt; ticker = yf.Ticker(&#34;BTC-USD&#34;)
&gt;&gt;&gt; price = ticker.history(start=datetime(2019, 3, 1), end=datetime(2019, 9, 1))
&gt;&gt;&gt; price = price[[&#39;Open&#39;, &#39;High&#39;, &#39;Low&#39;, &#39;Close&#39;, &#39;Volume&#39;]]
&gt;&gt;&gt; print(price)
                Open      High       Low     Close       Volume
Date
2019-02-28   3848.26   3906.06   3845.82   3854.79   8399767798
2019-03-01   3853.76   3907.80   3851.69   3859.58   7661247975
2019-03-02   3855.32   3874.61   3832.13   3864.42   7578786075
...              ...       ...       ...       ...          ...
2019-08-29   9756.79   9756.79   9421.63   9510.20  17045878500
2019-08-30   9514.84   9656.12   9428.30   9598.17  13595263986
2019-08-31   9597.54   9673.22   9531.80   9630.66  11454806419

[185 rows x 5 columns]

&gt;&gt;&gt; price[&#39;Close&#39;].vbt.plot()
```
![](/vectorbt/docs/img/Indicators_price.png)&#34;&#34;&#34;

import numpy as np
import plotly.graph_objects as go

from vectorbt import defaults
from vectorbt.utils.config import merge_kwargs
from vectorbt.utils.docs import fix_class_for_docs
from vectorbt.generic import nb as generic_nb
from vectorbt.indicators.factory import IndicatorFactory
from vectorbt.indicators import nb

# ############# MA ############# #


MA = IndicatorFactory(
    class_name=&#39;MA&#39;,
    module_name=__name__,
    short_name=&#39;ma&#39;,
    input_names=[&#39;close&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    param_defaults={&#39;ewm&#39;: False},
    output_names=[&#39;ma&#39;]
).from_apply_func(nb.ma_apply_nb, caching_func=nb.ma_caching_nb)


class MA(MA):
    &#34;&#34;&#34;A moving average (MA) is a widely used indicator in technical analysis that helps smooth out 
    price action by filtering out the “noise” from random short-term price fluctuations. 

    See [Moving Average (MA)](https://www.investopedia.com/terms/m/movingaverage.asp).

    Use `MA.run` or `MA.run_combs` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             close_trace_kwargs={},
             ma_trace_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `MA.ma` against `MA.close`.

        Args:
            close_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MA.close`.
            ma_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MA.ma`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            ma[(10, False)].plot()
            ```

            ![](/vectorbt/docs/img/MA.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        close_trace_kwargs = merge_kwargs(dict(
            name=f&#39;Close ({self.short_name})&#39;
        ), close_trace_kwargs)
        ma_trace_kwargs = merge_kwargs(dict(
            name=f&#39;MA ({self.short_name})&#39;
        ), ma_trace_kwargs)

        fig = self.close.vbt.plot(trace_kwargs=close_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.ma.vbt.plot(trace_kwargs=ma_trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_docs(MA)

# ############# MSTD ############# #


MSTD = IndicatorFactory(
    class_name=&#39;MSTD&#39;,
    module_name=__name__,
    short_name=&#39;mstd&#39;,
    input_names=[&#39;close&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    param_defaults={&#39;ewm&#39;: False},
    output_names=[&#39;mstd&#39;]
).from_apply_func(nb.mstd_apply_nb, caching_func=nb.mstd_caching_nb)


class MSTD(MSTD):
    &#34;&#34;&#34;Standard deviation is an indicator that measures the size of an assets recent price moves
    in order to predict how volatile the price may be in the future.

    Use `MSTD.run` or `MSTD.run_combs` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             mstd_trace_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `MSTD.mstd`.

        Args:
            mstd_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MSTD.mstd`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            mstd[(10, False)].plot()
            ```

            ![](/vectorbt/docs/img/MSTD.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        mstd_trace_kwargs = merge_kwargs(dict(
            name=f&#39;MSTD ({self.short_name})&#39;
        ), mstd_trace_kwargs)

        fig = self.mstd.vbt.plot(trace_kwargs=mstd_trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_docs(MSTD)

# ############# BollingerBands ############# #


BollingerBands = IndicatorFactory(
    class_name=&#39;BollingerBands&#39;,
    module_name=__name__,
    short_name=&#39;bb&#39;,
    input_names=[&#39;close&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;, &#39;alpha&#39;],
    param_defaults={&#39;window&#39;: 20, &#39;ewm&#39;: False, &#39;alpha&#39;: 2},
    output_names=[&#39;middle&#39;, &#39;upper&#39;, &#39;lower&#39;],
    custom_output_funcs=dict(
        percent_b=lambda self: self.wrapper.wrap(
            (self.close.values - self.lower.values) / (self.upper.values - self.lower.values)),
        bandwidth=lambda self: self.wrapper.wrap(
            (self.upper.values - self.lower.values) / self.middle.values)
    )
).from_apply_func(nb.bb_apply_nb, caching_func=nb.bb_caching_nb)


class BollingerBands(BollingerBands):
    &#34;&#34;&#34;A Bollinger Band® is a technical analysis tool defined by a set of lines plotted two standard
    deviations (positively and negatively) away from a simple moving average (SMA) of the security&#39;s
    price, but can be adjusted to user preferences.

    See [Bollinger Band®](https://www.investopedia.com/terms/b/bollingerbands.asp).

    Use `BollingerBands.run` or `BollingerBands.run_combs` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             close_trace_kwargs={},
             middle_trace_kwargs={},
             upper_trace_kwargs={},
             lower_trace_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `BollingerBands.middle`, `BollingerBands.upper` and `BollingerBands.lower` against
        `BollingerBands.close`.

        Args:
            close_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BollingerBands.close`.
            middle_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BollingerBands.middle`.
            upper_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BollingerBands.upper`.
            lower_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BollingerBands.lower`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            bb[(10, False, 2)].plot()
            ```

            ![](/vectorbt/docs/img/BollingerBands.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        lower_trace_kwargs = merge_kwargs(dict(
            name=f&#39;Lower Band ({self.short_name})&#39;,
            line=dict(color=&#39;silver&#39;)
        ), lower_trace_kwargs)
        upper_trace_kwargs = merge_kwargs(dict(
            name=f&#39;Upper Band ({self.short_name})&#39;,
            line=dict(color=&#39;silver&#39;),
            fill=&#39;tonexty&#39;,
            fillcolor=&#39;rgba(128, 128, 128, 0.25)&#39;
        ), upper_trace_kwargs)  # default kwargs
        middle_trace_kwargs = merge_kwargs(dict(
            name=f&#39;Middle Band ({self.short_name})&#39;,
            line=dict(color=defaults.layout[&#39;colorway&#39;][1])
        ), middle_trace_kwargs)
        close_trace_kwargs = merge_kwargs(dict(
            name=f&#39;Close ({self.short_name})&#39;,
            line=dict(color=defaults.layout[&#39;colorway&#39;][0])
        ), close_trace_kwargs)

        fig = self.lower.vbt.plot(trace_kwargs=lower_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.upper.vbt.plot(trace_kwargs=upper_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.middle.vbt.plot(trace_kwargs=middle_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.close.vbt.plot(trace_kwargs=close_trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_docs(BollingerBands)

# ############# RSI ############# #


RSI = IndicatorFactory(
    class_name=&#39;RSI&#39;,
    module_name=__name__,
    short_name=&#39;rsi&#39;,
    input_names=[&#39;close&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    param_defaults={&#39;window&#39;: 14, &#39;ewm&#39;: False},
    output_names=[&#39;rsi&#39;]
).from_apply_func(nb.rsi_apply_nb, caching_func=nb.rsi_caching_nb)


class RSI(RSI):
    &#34;&#34;&#34;The relative strength index (RSI) is a momentum indicator that measures the magnitude of
    recent price changes to evaluate overbought or oversold conditions in the price of a stock
    or other asset. The RSI is displayed as an oscillator (a line graph that moves between two
    extremes) and can have a reading from 0 to 100.

    See [Relative Strength Index (RSI)](https://www.investopedia.com/terms/r/rsi.asp).

    Use `RSI.run` or `RSI.run_combs` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             levels=(30, 70),
             rsi_trace_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `RSI.rsi`.

        Args:
            trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `RSI.rsi`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            rsi[(10, False)].plot()
            ```

            ![](/vectorbt/docs/img/RSI.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        rsi_trace_kwargs = merge_kwargs(dict(
            name=f&#39;RSI ({self.short_name})&#39;
        ), rsi_trace_kwargs)

        layout_kwargs = merge_kwargs(dict(yaxis=dict(range=[-5, 105])), layout_kwargs)
        fig = self.rsi.vbt.plot(trace_kwargs=rsi_trace_kwargs, fig=fig, **layout_kwargs)

        # Fill void between levels
        fig.add_shape(
            type=&#34;rect&#34;,
            xref=&#34;x&#34;,
            yref=&#34;y&#34;,
            x0=self.rsi.index[0],
            y0=levels[0],
            x1=self.rsi.index[-1],
            y1=levels[1],
            fillcolor=&#34;purple&#34;,
            opacity=0.15,
            layer=&#34;below&#34;,
            line_width=0,
        )

        return fig


fix_class_for_docs(RSI)

# ############# Stochastic ############# #


Stochastic = IndicatorFactory(
    class_name=&#39;Stochastic&#39;,
    module_name=__name__,
    short_name=&#39;stoch&#39;,
    input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
    param_names=[&#39;k_window&#39;, &#39;d_window&#39;, &#39;d_ewm&#39;],
    param_defaults={&#39;k_window&#39;: 14, &#39;d_window&#39;: 3, &#39;d_ewm&#39;: False},
    output_names=[&#39;percent_k&#39;, &#39;percent_d&#39;]
).from_apply_func(nb.stoch_apply_nb, caching_func=nb.stoch_caching_nb)


class Stochastic(Stochastic):
    &#34;&#34;&#34;A stochastic oscillator is a momentum indicator comparing a particular closing price of a security
    to a range of its prices over a certain period of time. It is used to generate overbought and oversold
    trading signals, utilizing a 0-100 bounded range of values.

    See [Stochastic Oscillator](https://www.investopedia.com/terms/s/stochasticoscillator.asp).

    Use `Stochastic.run` or `Stochastic.run_combs` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             levels=(30, 70),
             percent_k_trace_kwargs={},
             percent_d_trace_kwargs={},
             shape_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `Stochastic.percent_k` and `Stochastic.percent_d`.

        Args:
            percent_k_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `Stochastic.percent_k`.
            percent_d_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `Stochastic.percent_d`.
            shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zone between levels.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            stoch[(10, 2, False)].plot(levels=(20, 80))
            ```

            ![](/vectorbt/docs/img/Stochastic.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        percent_k_trace_kwargs = merge_kwargs(dict(
            name=f&#39;%K ({self.short_name})&#39;
        ), percent_k_trace_kwargs)
        percent_d_trace_kwargs = merge_kwargs(dict(
            name=f&#39;%D ({self.short_name})&#39;
        ), percent_d_trace_kwargs)

        layout_kwargs = merge_kwargs(dict(yaxis=dict(range=[-5, 105])), layout_kwargs)
        fig = self.percent_k.vbt.plot(trace_kwargs=percent_k_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.percent_d.vbt.plot(trace_kwargs=percent_d_trace_kwargs, fig=fig, **layout_kwargs)

        # Plot levels
        # Fill void between levels
        shape_kwargs = merge_kwargs(dict(
            type=&#34;rect&#34;,
            xref=&#34;x&#34;,
            yref=&#34;y&#34;,
            x0=self.percent_k.index[0],
            y0=levels[0],
            x1=self.percent_k.index[-1],
            y1=levels[1],
            fillcolor=&#34;purple&#34;,
            opacity=0.15,
            layer=&#34;below&#34;,
            line_width=0,
        ), shape_kwargs)
        fig.add_shape(**shape_kwargs)

        return fig


fix_class_for_docs(Stochastic)

# ############# MACD ############# #


MACD = IndicatorFactory(
    class_name=&#39;MACD&#39;,
    module_name=__name__,
    short_name=&#39;macd&#39;,
    input_names=[&#39;close&#39;],
    param_names=[&#39;fast_window&#39;, &#39;slow_window&#39;, &#39;signal_window&#39;, &#39;macd_ewm&#39;, &#39;signal_ewm&#39;],
    param_defaults={&#39;fast_window&#39;: 26, &#39;slow_window&#39;: 12, &#39;signal_window&#39;: 9, &#39;macd_ewm&#39;: True, &#39;signal_ewm&#39;: True},
    output_names=[&#39;macd&#39;, &#39;signal&#39;],
    custom_output_funcs=dict(
        hist=lambda self: self.wrapper.wrap(self.macd.values - self.signal.values),
    )
).from_apply_func(nb.macd_apply_nb, caching_func=nb.macd_caching_nb)


class MACD(MACD):
    &#34;&#34;&#34;Moving Average Convergence Divergence (MACD) is a trend-following momentum indicator that
    shows the relationship between two moving averages of a security’s price.

    See [Moving Average Convergence Divergence – MACD](https://www.investopedia.com/terms/m/macd.asp).

    Use `MACD.run` or `MACD.run_combs` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             macd_trace_kwargs={},
             signal_trace_kwargs={},
             hist_trace_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `MACD.macd`, `MACD.signal` and `MACD.hist`.

        Args:
            macd_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MACD.macd`.
            signal_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MACD.signal`.
            hist_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Bar` for `MACD.hist`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            macd[(10, 20, 30, False, True)].plot()
            ```

            ![](/vectorbt/docs/img/MACD.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        macd_trace_kwargs = merge_kwargs(dict(
            name=f&#39;MACD ({self.short_name})&#39;
        ), macd_trace_kwargs)
        signal_trace_kwargs = merge_kwargs(dict(
            name=f&#39;Signal ({self.short_name})&#39;
        ), signal_trace_kwargs)
        hist_trace_kwargs = merge_kwargs(dict(
            name=f&#39;Histogram ({self.short_name})&#39;,
            showlegend=False
        ), hist_trace_kwargs)

        layout_kwargs = merge_kwargs(dict(bargap=0), layout_kwargs)
        fig = self.macd.vbt.plot(trace_kwargs=macd_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.signal.vbt.plot(trace_kwargs=signal_trace_kwargs, fig=fig, **layout_kwargs)

        # Plot hist
        hist = self.hist.values
        hist_diff = generic_nb.diff_1d_nb(hist)
        marker_colors = np.full(hist.shape, &#39;silver&#39;, dtype=np.object)
        marker_colors[(hist &gt; 0) &amp; (hist_diff &gt; 0)] = &#39;green&#39;
        marker_colors[(hist &gt; 0) &amp; (hist_diff &lt;= 0)] = &#39;lightgreen&#39;
        marker_colors[(hist &lt; 0) &amp; (hist_diff &lt; 0)] = &#39;red&#39;
        marker_colors[(hist &lt; 0) &amp; (hist_diff &gt;= 0)] = &#39;lightcoral&#39;

        hist_bar = go.Bar(
            x=self.hist.index,
            y=self.hist.values,
            marker_color=marker_colors,
            marker_line_width=0
        )
        hist_bar.update(**hist_trace_kwargs)
        fig.add_trace(hist_bar)

        return fig


fix_class_for_docs(MACD)

# ############# ATR ############# #


ATR = IndicatorFactory(
    class_name=&#39;ATR&#39;,
    module_name=__name__,
    short_name=&#39;atr&#39;,
    input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    param_defaults={&#39;ewm&#39;: True},
    output_names=[&#39;tr&#39;, &#39;atr&#39;]
).from_apply_func(nb.atr_apply_nb, caching_func=nb.atr_caching_nb)


class ATR(ATR):
    &#34;&#34;&#34;The average true range (ATR) is a technical analysis indicator that measures market volatility
    by decomposing the entire range of an asset price for that period.

    See [Average True Range - ATR](https://www.investopedia.com/terms/a/atr.asp).

    Use `ATR.run` or `ATR.run_combs` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             tr_trace_kwargs={},
             atr_trace_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `ATR.tr` and `ATR.atr`.

        Args:
            tr_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `ATR.tr`.
            atr_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `ATR.atr`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            atr[(10, False)].plot()
            ```

            ![](/vectorbt/docs/img/ATR.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        tr_trace_kwargs = merge_kwargs(dict(
            name=f&#39;TR ({self.short_name})&#39;
        ), tr_trace_kwargs)
        atr_trace_kwargs = merge_kwargs(dict(
            name=f&#39;ATR ({self.short_name})&#39;
        ), atr_trace_kwargs)

        fig = self.tr.vbt.plot(trace_kwargs=tr_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.atr.vbt.plot(trace_kwargs=atr_trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_docs(ATR)

# ############# OBV ############# #


OBV = IndicatorFactory(
    class_name=&#39;OBV&#39;,
    module_name=__name__,
    short_name=&#39;obv&#39;,
    input_names=[&#39;close&#39;, &#39;volume&#39;],
    param_names=[],
    output_names=[&#39;obv&#39;],
).from_custom_func(nb.obv_custom_func_nb)


class OBV(OBV):
    &#34;&#34;&#34;On-balance volume (OBV) is a technical trading momentum indicator that uses volume flow to predict
    changes in stock price.

    See [On-Balance Volume (OBV)](https://www.investopedia.com/terms/o/onbalancevolume.asp).

    Use `OBV.run` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             obv_trace_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `OBV.obv`.

        Args:
            obv_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `OBV.obv`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            obv.plot()
            ```

            ![](/vectorbt/docs/img/OBV.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        obv_trace_kwargs = merge_kwargs(dict(
            name=f&#39;OBV ({self.short_name})&#39;
        ), obv_trace_kwargs)

        fig = self.obv.vbt.plot(trace_kwargs=obv_trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_docs(OBV)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.indicators.basic.ATR"><code class="flex name class">
<span>class <span class="ident parent-fname">ATR</span></span>
<span>(</span><span>input_list, input_mapper, output_list, param_list, mapper_list, short_name)</span>
</code></dt>
<dd>
<div class="desc"><p>The average true range (ATR) is a technical analysis indicator that measures market volatility
by decomposing the entire range of an asset price for that period.</p>
<p>See <a href="https://www.investopedia.com/terms/a/atr.asp">Average True Range - ATR</a>.</p>
<p>Use <code><a title="vectorbt.indicators.basic.ATR.run" href="#vectorbt.indicators.basic.ATR.run">run()</a></code> or <code><a title="vectorbt.indicators.basic.ATR.run_combs" href="#vectorbt.indicators.basic.ATR.run_combs">run_combs()</a></code> to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ATR(ATR):
    &#34;&#34;&#34;The average true range (ATR) is a technical analysis indicator that measures market volatility
    by decomposing the entire range of an asset price for that period.

    See [Average True Range - ATR](https://www.investopedia.com/terms/a/atr.asp).

    Use `ATR.run` or `ATR.run_combs` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             tr_trace_kwargs={},
             atr_trace_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `ATR.tr` and `ATR.atr`.

        Args:
            tr_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `ATR.tr`.
            atr_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `ATR.atr`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            atr[(10, False)].plot()
            ```

            ![](/vectorbt/docs/img/ATR.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        tr_trace_kwargs = merge_kwargs(dict(
            name=f&#39;TR ({self.short_name})&#39;
        ), tr_trace_kwargs)
        atr_trace_kwargs = merge_kwargs(dict(
            name=f&#39;ATR ({self.short_name})&#39;
        ), atr_trace_kwargs)

        fig = self.tr.vbt.plot(trace_kwargs=tr_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.atr.vbt.plot(trace_kwargs=atr_trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.ATR.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>high, low, close, window, ewm=True, *args, short_name='atr', hide_params=[], hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the ATR indicator using input time series <code>high</code>, <code>low</code> and <code>close</code>, and parameters <code>window</code> and <code>ewm</code>, to
produce output time series <code>tr</code> and <code>atr</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to <code>False</code> to show column levels of parameters with the default value passed.
Keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>high, low, close, window, ewm=True, *args, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple ATR indicators using function <code>comb_func</code>.
Run each indicator using input time series <code>high</code>, <code>low</code> and <code>close</code>, and parameters <code>window</code> and <code>ewm</code>, to produce output time series <code>tr</code> and <code>atr</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to <code>True</code> to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).
Keyword arguments are passed to <code><a title="vectorbt.indicators.basic.ATR.run" href="#vectorbt.indicators.basic.ATR.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.ATR.atr"><code class="name">var <span class="ident fname">atr</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return getattr(self, &#39;_&#39; + output_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.ewm_loc"><code class="name">var <span class="ident fname">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>ewm</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.high"><code class="name">var <span class="ident fname">high</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.low"><code class="name">var <span class="ident fname">low</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Short name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.tr"><code class="name">var <span class="ident fname">tr</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return getattr(self, &#39;_&#39; + output_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.tuple_loc"><code class="name">var <span class="ident fname">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>tuple</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.window_loc"><code class="name">var <span class="ident fname">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>window</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.ATR.atr_above"><code class="name flex">
<span>def <span class="ident fname">atr_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>atr</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>atr</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.atr_below"><code class="name flex">
<span>def <span class="ident fname">atr_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>atr</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>atr</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.atr_equal"><code class="name flex">
<span>def <span class="ident fname">atr_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>atr</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>atr</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.high_above"><code class="name flex">
<span>def <span class="ident fname">high_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>high</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>high</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.high_below"><code class="name flex">
<span>def <span class="ident fname">high_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>high</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>high</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.high_equal"><code class="name flex">
<span>def <span class="ident fname">high_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>high</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>high</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.low_above"><code class="name flex">
<span>def <span class="ident fname">low_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>low</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>low</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.low_below"><code class="name flex">
<span>def <span class="ident fname">low_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>low</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>low</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.low_equal"><code class="name flex">
<span>def <span class="ident fname">low_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>low</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>low</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, tr_trace_kwargs={}, atr_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.ATR.tr" href="#vectorbt.indicators.basic.ATR.tr">ATR.tr</a></code> and <code><a title="vectorbt.indicators.basic.ATR.atr" href="#vectorbt.indicators.basic.ATR.atr">ATR.atr</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tr_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.ATR.tr" href="#vectorbt.indicators.basic.ATR.tr">ATR.tr</a></code>.</dd>
<dt><strong><code>atr_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.ATR.atr" href="#vectorbt.indicators.basic.ATR.atr">ATR.atr</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="py">atr[(10, False)].plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/ATR.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         tr_trace_kwargs={},
         atr_trace_kwargs={},
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `ATR.tr` and `ATR.atr`.

    Args:
        tr_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `ATR.tr`.
        atr_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `ATR.atr`.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Example:
        ```py
        atr[(10, False)].plot()
        ```

        ![](/vectorbt/docs/img/ATR.png)&#34;&#34;&#34;
    if self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;You must select a column first&#34;)

    tr_trace_kwargs = merge_kwargs(dict(
        name=f&#39;TR ({self.short_name})&#39;
    ), tr_trace_kwargs)
    atr_trace_kwargs = merge_kwargs(dict(
        name=f&#39;ATR ({self.short_name})&#39;
    ), atr_trace_kwargs)

    fig = self.tr.vbt.plot(trace_kwargs=tr_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.atr.vbt.plot(trace_kwargs=atr_trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.tr_above"><code class="name flex">
<span>def <span class="ident fname">tr_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>tr</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>tr</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.tr_below"><code class="name flex">
<span>def <span class="ident fname">tr_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>tr</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>tr</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.tr_equal"><code class="name flex">
<span>def <span class="ident fname">tr_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>tr</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>tr</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.indexing.PandasIndexer.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands"><code class="flex name class">
<span>class <span class="ident parent-fname">BollingerBands</span></span>
<span>(</span><span>input_list, input_mapper, output_list, param_list, mapper_list, short_name)</span>
</code></dt>
<dd>
<div class="desc"><p>A Bollinger Band® is a technical analysis tool defined by a set of lines plotted two standard
deviations (positively and negatively) away from a simple moving average (SMA) of the security's
price, but can be adjusted to user preferences.</p>
<p>See <a href="https://www.investopedia.com/terms/b/bollingerbands.asp">Bollinger Band®</a>.</p>
<p>Use <code><a title="vectorbt.indicators.basic.BollingerBands.run" href="#vectorbt.indicators.basic.BollingerBands.run">run()</a></code> or <code><a title="vectorbt.indicators.basic.BollingerBands.run_combs" href="#vectorbt.indicators.basic.BollingerBands.run_combs">run_combs()</a></code> to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BollingerBands(BollingerBands):
    &#34;&#34;&#34;A Bollinger Band® is a technical analysis tool defined by a set of lines plotted two standard
    deviations (positively and negatively) away from a simple moving average (SMA) of the security&#39;s
    price, but can be adjusted to user preferences.

    See [Bollinger Band®](https://www.investopedia.com/terms/b/bollingerbands.asp).

    Use `BollingerBands.run` or `BollingerBands.run_combs` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             close_trace_kwargs={},
             middle_trace_kwargs={},
             upper_trace_kwargs={},
             lower_trace_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `BollingerBands.middle`, `BollingerBands.upper` and `BollingerBands.lower` against
        `BollingerBands.close`.

        Args:
            close_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BollingerBands.close`.
            middle_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BollingerBands.middle`.
            upper_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BollingerBands.upper`.
            lower_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BollingerBands.lower`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            bb[(10, False, 2)].plot()
            ```

            ![](/vectorbt/docs/img/BollingerBands.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        lower_trace_kwargs = merge_kwargs(dict(
            name=f&#39;Lower Band ({self.short_name})&#39;,
            line=dict(color=&#39;silver&#39;)
        ), lower_trace_kwargs)
        upper_trace_kwargs = merge_kwargs(dict(
            name=f&#39;Upper Band ({self.short_name})&#39;,
            line=dict(color=&#39;silver&#39;),
            fill=&#39;tonexty&#39;,
            fillcolor=&#39;rgba(128, 128, 128, 0.25)&#39;
        ), upper_trace_kwargs)  # default kwargs
        middle_trace_kwargs = merge_kwargs(dict(
            name=f&#39;Middle Band ({self.short_name})&#39;,
            line=dict(color=defaults.layout[&#39;colorway&#39;][1])
        ), middle_trace_kwargs)
        close_trace_kwargs = merge_kwargs(dict(
            name=f&#39;Close ({self.short_name})&#39;,
            line=dict(color=defaults.layout[&#39;colorway&#39;][0])
        ), close_trace_kwargs)

        fig = self.lower.vbt.plot(trace_kwargs=lower_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.upper.vbt.plot(trace_kwargs=upper_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.middle.vbt.plot(trace_kwargs=middle_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.close.vbt.plot(trace_kwargs=close_trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.BollingerBands.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>close, window=20, ewm=False, alpha=2, *args, short_name='bb', hide_params=[], hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the BollingerBands indicator using input time series <code>close</code>, and parameters <code>window</code>, <code>ewm</code> and <code>alpha</code>, to
produce output time series <code>middle</code>, <code>upper</code> and <code>lower</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to <code>False</code> to show column levels of parameters with the default value passed.
Keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>close, window=20, ewm=False, alpha=2, *args, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple BollingerBands indicators using function <code>comb_func</code>.
Run each indicator using input time series <code>close</code>, and parameters <code>window</code>, <code>ewm</code> and <code>alpha</code>, to produce output time series <code>middle</code>, <code>upper</code> and <code>lower</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to <code>True</code> to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).
Keyword arguments are passed to <code><a title="vectorbt.indicators.basic.BollingerBands.run" href="#vectorbt.indicators.basic.BollingerBands.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.BollingerBands.alpha_loc"><code class="name">var <span class="ident fname">alpha_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>alpha</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.bandwidth"><code class="name">var <span class="ident fname">bandwidth</span></code></dt>
<dd>
<div class="desc"><p>Custom property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.ewm_loc"><code class="name">var <span class="ident fname">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>ewm</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.lower"><code class="name">var <span class="ident fname">lower</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return getattr(self, &#39;_&#39; + output_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.middle"><code class="name">var <span class="ident fname">middle</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return getattr(self, &#39;_&#39; + output_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.percent_b"><code class="name">var <span class="ident fname">percent_b</span></code></dt>
<dd>
<div class="desc"><p>Custom property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Short name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.tuple_loc"><code class="name">var <span class="ident fname">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>tuple</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.upper"><code class="name">var <span class="ident fname">upper</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return getattr(self, &#39;_&#39; + output_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.window_loc"><code class="name">var <span class="ident fname">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>window</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.BollingerBands.bandwidth_above"><code class="name flex">
<span>def <span class="ident fname">bandwidth_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>bandwidth</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>bandwidth</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.bandwidth_below"><code class="name flex">
<span>def <span class="ident fname">bandwidth_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>bandwidth</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>bandwidth</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.bandwidth_equal"><code class="name flex">
<span>def <span class="ident fname">bandwidth_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>bandwidth</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>bandwidth</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.lower_above"><code class="name flex">
<span>def <span class="ident fname">lower_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>lower</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>lower</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.lower_below"><code class="name flex">
<span>def <span class="ident fname">lower_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>lower</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>lower</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.lower_equal"><code class="name flex">
<span>def <span class="ident fname">lower_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>lower</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>lower</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.middle_above"><code class="name flex">
<span>def <span class="ident fname">middle_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>middle</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>middle</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.middle_below"><code class="name flex">
<span>def <span class="ident fname">middle_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>middle</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>middle</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.middle_equal"><code class="name flex">
<span>def <span class="ident fname">middle_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>middle</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>middle</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.percent_b_above"><code class="name flex">
<span>def <span class="ident fname">percent_b_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>percent_b</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>percent_b</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.percent_b_below"><code class="name flex">
<span>def <span class="ident fname">percent_b_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>percent_b</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>percent_b</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.percent_b_equal"><code class="name flex">
<span>def <span class="ident fname">percent_b_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>percent_b</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>percent_b</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, close_trace_kwargs={}, middle_trace_kwargs={}, upper_trace_kwargs={}, lower_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.BollingerBands.middle" href="#vectorbt.indicators.basic.BollingerBands.middle">BollingerBands.middle</a></code>, <code><a title="vectorbt.indicators.basic.BollingerBands.upper" href="#vectorbt.indicators.basic.BollingerBands.upper">BollingerBands.upper</a></code> and <code><a title="vectorbt.indicators.basic.BollingerBands.lower" href="#vectorbt.indicators.basic.BollingerBands.lower">BollingerBands.lower</a></code> against
<code><a title="vectorbt.indicators.basic.BollingerBands.close" href="#vectorbt.indicators.basic.BollingerBands.close">BollingerBands.close</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>close_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.BollingerBands.close" href="#vectorbt.indicators.basic.BollingerBands.close">BollingerBands.close</a></code>.</dd>
<dt><strong><code>middle_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.BollingerBands.middle" href="#vectorbt.indicators.basic.BollingerBands.middle">BollingerBands.middle</a></code>.</dd>
<dt><strong><code>upper_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.BollingerBands.upper" href="#vectorbt.indicators.basic.BollingerBands.upper">BollingerBands.upper</a></code>.</dd>
<dt><strong><code>lower_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.BollingerBands.lower" href="#vectorbt.indicators.basic.BollingerBands.lower">BollingerBands.lower</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="py">bb[(10, False, 2)].plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/BollingerBands.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         close_trace_kwargs={},
         middle_trace_kwargs={},
         upper_trace_kwargs={},
         lower_trace_kwargs={},
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `BollingerBands.middle`, `BollingerBands.upper` and `BollingerBands.lower` against
    `BollingerBands.close`.

    Args:
        close_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BollingerBands.close`.
        middle_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BollingerBands.middle`.
        upper_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BollingerBands.upper`.
        lower_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BollingerBands.lower`.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Example:
        ```py
        bb[(10, False, 2)].plot()
        ```

        ![](/vectorbt/docs/img/BollingerBands.png)&#34;&#34;&#34;
    if self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;You must select a column first&#34;)

    lower_trace_kwargs = merge_kwargs(dict(
        name=f&#39;Lower Band ({self.short_name})&#39;,
        line=dict(color=&#39;silver&#39;)
    ), lower_trace_kwargs)
    upper_trace_kwargs = merge_kwargs(dict(
        name=f&#39;Upper Band ({self.short_name})&#39;,
        line=dict(color=&#39;silver&#39;),
        fill=&#39;tonexty&#39;,
        fillcolor=&#39;rgba(128, 128, 128, 0.25)&#39;
    ), upper_trace_kwargs)  # default kwargs
    middle_trace_kwargs = merge_kwargs(dict(
        name=f&#39;Middle Band ({self.short_name})&#39;,
        line=dict(color=defaults.layout[&#39;colorway&#39;][1])
    ), middle_trace_kwargs)
    close_trace_kwargs = merge_kwargs(dict(
        name=f&#39;Close ({self.short_name})&#39;,
        line=dict(color=defaults.layout[&#39;colorway&#39;][0])
    ), close_trace_kwargs)

    fig = self.lower.vbt.plot(trace_kwargs=lower_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.upper.vbt.plot(trace_kwargs=upper_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.middle.vbt.plot(trace_kwargs=middle_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.close.vbt.plot(trace_kwargs=close_trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.upper_above"><code class="name flex">
<span>def <span class="ident fname">upper_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>upper</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>upper</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.upper_below"><code class="name flex">
<span>def <span class="ident fname">upper_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>upper</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>upper</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BollingerBands.upper_equal"><code class="name flex">
<span>def <span class="ident fname">upper_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>upper</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>upper</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.indexing.PandasIndexer.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.indicators.basic.MA"><code class="flex name class">
<span>class <span class="ident parent-fname">MA</span></span>
<span>(</span><span>input_list, input_mapper, output_list, param_list, mapper_list, short_name)</span>
</code></dt>
<dd>
<div class="desc"><p>A moving average (MA) is a widely used indicator in technical analysis that helps smooth out
price action by filtering out the “noise” from random short-term price fluctuations. </p>
<p>See <a href="https://www.investopedia.com/terms/m/movingaverage.asp">Moving Average (MA)</a>.</p>
<p>Use <code><a title="vectorbt.indicators.basic.MA.run" href="#vectorbt.indicators.basic.MA.run">run()</a></code> or <code><a title="vectorbt.indicators.basic.MA.run_combs" href="#vectorbt.indicators.basic.MA.run_combs">run_combs()</a></code> to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MA(MA):
    &#34;&#34;&#34;A moving average (MA) is a widely used indicator in technical analysis that helps smooth out 
    price action by filtering out the “noise” from random short-term price fluctuations. 

    See [Moving Average (MA)](https://www.investopedia.com/terms/m/movingaverage.asp).

    Use `MA.run` or `MA.run_combs` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             close_trace_kwargs={},
             ma_trace_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `MA.ma` against `MA.close`.

        Args:
            close_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MA.close`.
            ma_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MA.ma`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            ma[(10, False)].plot()
            ```

            ![](/vectorbt/docs/img/MA.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        close_trace_kwargs = merge_kwargs(dict(
            name=f&#39;Close ({self.short_name})&#39;
        ), close_trace_kwargs)
        ma_trace_kwargs = merge_kwargs(dict(
            name=f&#39;MA ({self.short_name})&#39;
        ), ma_trace_kwargs)

        fig = self.close.vbt.plot(trace_kwargs=close_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.ma.vbt.plot(trace_kwargs=ma_trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.MA.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>close, window, ewm=False, *args, short_name='ma', hide_params=[], hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the MA indicator using input time series <code>close</code>, and parameters <code>window</code> and <code>ewm</code>, to
produce output time series <code>ma</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to <code>False</code> to show column levels of parameters with the default value passed.
Keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>close, window, ewm=False, *args, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple MA indicators using function <code>comb_func</code>.
Run each indicator using input time series <code>close</code>, and parameters <code>window</code> and <code>ewm</code>, to produce output time series <code>ma</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to <code>True</code> to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).
Keyword arguments are passed to <code><a title="vectorbt.indicators.basic.MA.run" href="#vectorbt.indicators.basic.MA.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.MA.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.ewm_loc"><code class="name">var <span class="ident fname">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>ewm</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.ma"><code class="name">var <span class="ident fname">ma</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return getattr(self, &#39;_&#39; + output_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Short name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.tuple_loc"><code class="name">var <span class="ident fname">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>tuple</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.window_loc"><code class="name">var <span class="ident fname">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>window</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.MA.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.ma_above"><code class="name flex">
<span>def <span class="ident fname">ma_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>ma</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>ma</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.ma_below"><code class="name flex">
<span>def <span class="ident fname">ma_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>ma</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>ma</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.ma_equal"><code class="name flex">
<span>def <span class="ident fname">ma_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>ma</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>ma</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, close_trace_kwargs={}, ma_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.MA.ma" href="#vectorbt.indicators.basic.MA.ma">MA.ma</a></code> against <code><a title="vectorbt.indicators.basic.MA.close" href="#vectorbt.indicators.basic.MA.close">MA.close</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>close_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.MA.close" href="#vectorbt.indicators.basic.MA.close">MA.close</a></code>.</dd>
<dt><strong><code>ma_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.MA.ma" href="#vectorbt.indicators.basic.MA.ma">MA.ma</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="py">ma[(10, False)].plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/MA.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         close_trace_kwargs={},
         ma_trace_kwargs={},
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `MA.ma` against `MA.close`.

    Args:
        close_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MA.close`.
        ma_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MA.ma`.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Example:
        ```py
        ma[(10, False)].plot()
        ```

        ![](/vectorbt/docs/img/MA.png)&#34;&#34;&#34;
    if self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;You must select a column first&#34;)

    close_trace_kwargs = merge_kwargs(dict(
        name=f&#39;Close ({self.short_name})&#39;
    ), close_trace_kwargs)
    ma_trace_kwargs = merge_kwargs(dict(
        name=f&#39;MA ({self.short_name})&#39;
    ), ma_trace_kwargs)

    fig = self.close.vbt.plot(trace_kwargs=close_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.ma.vbt.plot(trace_kwargs=ma_trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.indexing.PandasIndexer.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.indicators.basic.MACD"><code class="flex name class">
<span>class <span class="ident parent-fname">MACD</span></span>
<span>(</span><span>input_list, input_mapper, output_list, param_list, mapper_list, short_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Moving Average Convergence Divergence (MACD) is a trend-following momentum indicator that
shows the relationship between two moving averages of a security’s price.</p>
<p>See <a href="https://www.investopedia.com/terms/m/macd.asp">Moving Average Convergence Divergence – MACD</a>.</p>
<p>Use <code><a title="vectorbt.indicators.basic.MACD.run" href="#vectorbt.indicators.basic.MACD.run">run()</a></code> or <code><a title="vectorbt.indicators.basic.MACD.run_combs" href="#vectorbt.indicators.basic.MACD.run_combs">run_combs()</a></code> to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MACD(MACD):
    &#34;&#34;&#34;Moving Average Convergence Divergence (MACD) is a trend-following momentum indicator that
    shows the relationship between two moving averages of a security’s price.

    See [Moving Average Convergence Divergence – MACD](https://www.investopedia.com/terms/m/macd.asp).

    Use `MACD.run` or `MACD.run_combs` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             macd_trace_kwargs={},
             signal_trace_kwargs={},
             hist_trace_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `MACD.macd`, `MACD.signal` and `MACD.hist`.

        Args:
            macd_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MACD.macd`.
            signal_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MACD.signal`.
            hist_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Bar` for `MACD.hist`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            macd[(10, 20, 30, False, True)].plot()
            ```

            ![](/vectorbt/docs/img/MACD.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        macd_trace_kwargs = merge_kwargs(dict(
            name=f&#39;MACD ({self.short_name})&#39;
        ), macd_trace_kwargs)
        signal_trace_kwargs = merge_kwargs(dict(
            name=f&#39;Signal ({self.short_name})&#39;
        ), signal_trace_kwargs)
        hist_trace_kwargs = merge_kwargs(dict(
            name=f&#39;Histogram ({self.short_name})&#39;,
            showlegend=False
        ), hist_trace_kwargs)

        layout_kwargs = merge_kwargs(dict(bargap=0), layout_kwargs)
        fig = self.macd.vbt.plot(trace_kwargs=macd_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.signal.vbt.plot(trace_kwargs=signal_trace_kwargs, fig=fig, **layout_kwargs)

        # Plot hist
        hist = self.hist.values
        hist_diff = generic_nb.diff_1d_nb(hist)
        marker_colors = np.full(hist.shape, &#39;silver&#39;, dtype=np.object)
        marker_colors[(hist &gt; 0) &amp; (hist_diff &gt; 0)] = &#39;green&#39;
        marker_colors[(hist &gt; 0) &amp; (hist_diff &lt;= 0)] = &#39;lightgreen&#39;
        marker_colors[(hist &lt; 0) &amp; (hist_diff &lt; 0)] = &#39;red&#39;
        marker_colors[(hist &lt; 0) &amp; (hist_diff &gt;= 0)] = &#39;lightcoral&#39;

        hist_bar = go.Bar(
            x=self.hist.index,
            y=self.hist.values,
            marker_color=marker_colors,
            marker_line_width=0
        )
        hist_bar.update(**hist_trace_kwargs)
        fig.add_trace(hist_bar)

        return fig</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.MACD.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>close, fast_window=26, slow_window=12, signal_window=9, macd_ewm=True, signal_ewm=True, *args, short_name='macd', hide_params=[], hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the MACD indicator using input time series <code>close</code>, and parameters <code>fast_window</code>, <code>slow_window</code>, <code>signal_window</code>, <code>macd_ewm</code> and <code>signal_ewm</code>, to
produce output time series <code>macd</code> and <code>signal</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to <code>False</code> to show column levels of parameters with the default value passed.
Keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>close, fast_window=26, slow_window=12, signal_window=9, macd_ewm=True, signal_ewm=True, *args, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple MACD indicators using function <code>comb_func</code>.
Run each indicator using input time series <code>close</code>, and parameters <code>fast_window</code>, <code>slow_window</code>, <code>signal_window</code>, <code>macd_ewm</code> and <code>signal_ewm</code>, to produce output time series <code>macd</code> and <code>signal</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to <code>True</code> to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).
Keyword arguments are passed to <code><a title="vectorbt.indicators.basic.MACD.run" href="#vectorbt.indicators.basic.MACD.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.MACD.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.fast_window_loc"><code class="name">var <span class="ident fname">fast_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>fast_window</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.hist"><code class="name">var <span class="ident fname">hist</span></code></dt>
<dd>
<div class="desc"><p>Custom property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.macd"><code class="name">var <span class="ident fname">macd</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return getattr(self, &#39;_&#39; + output_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.macd_ewm_loc"><code class="name">var <span class="ident fname">macd_ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>macd_ewm</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Short name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.signal"><code class="name">var <span class="ident fname">signal</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return getattr(self, &#39;_&#39; + output_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.signal_ewm_loc"><code class="name">var <span class="ident fname">signal_ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>signal_ewm</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.signal_window_loc"><code class="name">var <span class="ident fname">signal_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>signal_window</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.slow_window_loc"><code class="name">var <span class="ident fname">slow_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>slow_window</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.tuple_loc"><code class="name">var <span class="ident fname">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>tuple</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.MACD.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.hist_above"><code class="name flex">
<span>def <span class="ident fname">hist_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>hist</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>hist</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.hist_below"><code class="name flex">
<span>def <span class="ident fname">hist_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>hist</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>hist</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.hist_equal"><code class="name flex">
<span>def <span class="ident fname">hist_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>hist</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>hist</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.macd_above"><code class="name flex">
<span>def <span class="ident fname">macd_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>macd</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>macd</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.macd_below"><code class="name flex">
<span>def <span class="ident fname">macd_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>macd</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>macd</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.macd_equal"><code class="name flex">
<span>def <span class="ident fname">macd_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>macd</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>macd</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, macd_trace_kwargs={}, signal_trace_kwargs={}, hist_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.MACD.macd" href="#vectorbt.indicators.basic.MACD.macd">MACD.macd</a></code>, <code><a title="vectorbt.indicators.basic.MACD.signal" href="#vectorbt.indicators.basic.MACD.signal">MACD.signal</a></code> and <code><a title="vectorbt.indicators.basic.MACD.hist" href="#vectorbt.indicators.basic.MACD.hist">MACD.hist</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>macd_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.MACD.macd" href="#vectorbt.indicators.basic.MACD.macd">MACD.macd</a></code>.</dd>
<dt><strong><code>signal_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.MACD.signal" href="#vectorbt.indicators.basic.MACD.signal">MACD.signal</a></code>.</dd>
<dt><strong><code>hist_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Bar</code> for <code><a title="vectorbt.indicators.basic.MACD.hist" href="#vectorbt.indicators.basic.MACD.hist">MACD.hist</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="py">macd[(10, 20, 30, False, True)].plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/MACD.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         macd_trace_kwargs={},
         signal_trace_kwargs={},
         hist_trace_kwargs={},
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `MACD.macd`, `MACD.signal` and `MACD.hist`.

    Args:
        macd_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MACD.macd`.
        signal_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MACD.signal`.
        hist_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Bar` for `MACD.hist`.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Example:
        ```py
        macd[(10, 20, 30, False, True)].plot()
        ```

        ![](/vectorbt/docs/img/MACD.png)&#34;&#34;&#34;
    if self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;You must select a column first&#34;)

    macd_trace_kwargs = merge_kwargs(dict(
        name=f&#39;MACD ({self.short_name})&#39;
    ), macd_trace_kwargs)
    signal_trace_kwargs = merge_kwargs(dict(
        name=f&#39;Signal ({self.short_name})&#39;
    ), signal_trace_kwargs)
    hist_trace_kwargs = merge_kwargs(dict(
        name=f&#39;Histogram ({self.short_name})&#39;,
        showlegend=False
    ), hist_trace_kwargs)

    layout_kwargs = merge_kwargs(dict(bargap=0), layout_kwargs)
    fig = self.macd.vbt.plot(trace_kwargs=macd_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.signal.vbt.plot(trace_kwargs=signal_trace_kwargs, fig=fig, **layout_kwargs)

    # Plot hist
    hist = self.hist.values
    hist_diff = generic_nb.diff_1d_nb(hist)
    marker_colors = np.full(hist.shape, &#39;silver&#39;, dtype=np.object)
    marker_colors[(hist &gt; 0) &amp; (hist_diff &gt; 0)] = &#39;green&#39;
    marker_colors[(hist &gt; 0) &amp; (hist_diff &lt;= 0)] = &#39;lightgreen&#39;
    marker_colors[(hist &lt; 0) &amp; (hist_diff &lt; 0)] = &#39;red&#39;
    marker_colors[(hist &lt; 0) &amp; (hist_diff &gt;= 0)] = &#39;lightcoral&#39;

    hist_bar = go.Bar(
        x=self.hist.index,
        y=self.hist.values,
        marker_color=marker_colors,
        marker_line_width=0
    )
    hist_bar.update(**hist_trace_kwargs)
    fig.add_trace(hist_bar)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.signal_above"><code class="name flex">
<span>def <span class="ident fname">signal_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>signal</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>signal</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.signal_below"><code class="name flex">
<span>def <span class="ident fname">signal_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>signal</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>signal</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.signal_equal"><code class="name flex">
<span>def <span class="ident fname">signal_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>signal</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>signal</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.indexing.PandasIndexer.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.indicators.basic.MSTD"><code class="flex name class">
<span>class <span class="ident parent-fname">MSTD</span></span>
<span>(</span><span>input_list, input_mapper, output_list, param_list, mapper_list, short_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Standard deviation is an indicator that measures the size of an assets recent price moves
in order to predict how volatile the price may be in the future.</p>
<p>Use <code><a title="vectorbt.indicators.basic.MSTD.run" href="#vectorbt.indicators.basic.MSTD.run">run()</a></code> or <code><a title="vectorbt.indicators.basic.MSTD.run_combs" href="#vectorbt.indicators.basic.MSTD.run_combs">run_combs()</a></code> to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MSTD(MSTD):
    &#34;&#34;&#34;Standard deviation is an indicator that measures the size of an assets recent price moves
    in order to predict how volatile the price may be in the future.

    Use `MSTD.run` or `MSTD.run_combs` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             mstd_trace_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `MSTD.mstd`.

        Args:
            mstd_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MSTD.mstd`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            mstd[(10, False)].plot()
            ```

            ![](/vectorbt/docs/img/MSTD.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        mstd_trace_kwargs = merge_kwargs(dict(
            name=f&#39;MSTD ({self.short_name})&#39;
        ), mstd_trace_kwargs)

        fig = self.mstd.vbt.plot(trace_kwargs=mstd_trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.MSTD.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>close, window, ewm=False, *args, short_name='mstd', hide_params=[], hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the MSTD indicator using input time series <code>close</code>, and parameters <code>window</code> and <code>ewm</code>, to
produce output time series <code>mstd</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to <code>False</code> to show column levels of parameters with the default value passed.
Keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>close, window, ewm=False, *args, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple MSTD indicators using function <code>comb_func</code>.
Run each indicator using input time series <code>close</code>, and parameters <code>window</code> and <code>ewm</code>, to produce output time series <code>mstd</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to <code>True</code> to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).
Keyword arguments are passed to <code><a title="vectorbt.indicators.basic.MSTD.run" href="#vectorbt.indicators.basic.MSTD.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.MSTD.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.ewm_loc"><code class="name">var <span class="ident fname">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>ewm</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.mstd"><code class="name">var <span class="ident fname">mstd</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return getattr(self, &#39;_&#39; + output_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Short name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.tuple_loc"><code class="name">var <span class="ident fname">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>tuple</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.window_loc"><code class="name">var <span class="ident fname">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>window</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.MSTD.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.mstd_above"><code class="name flex">
<span>def <span class="ident fname">mstd_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>mstd</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>mstd</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.mstd_below"><code class="name flex">
<span>def <span class="ident fname">mstd_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>mstd</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>mstd</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.mstd_equal"><code class="name flex">
<span>def <span class="ident fname">mstd_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>mstd</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>mstd</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, mstd_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.MSTD.mstd" href="#vectorbt.indicators.basic.MSTD.mstd">MSTD.mstd</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mstd_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.MSTD.mstd" href="#vectorbt.indicators.basic.MSTD.mstd">MSTD.mstd</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="py">mstd[(10, False)].plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/MSTD.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         mstd_trace_kwargs={},
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `MSTD.mstd`.

    Args:
        mstd_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MSTD.mstd`.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Example:
        ```py
        mstd[(10, False)].plot()
        ```

        ![](/vectorbt/docs/img/MSTD.png)&#34;&#34;&#34;
    if self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;You must select a column first&#34;)

    mstd_trace_kwargs = merge_kwargs(dict(
        name=f&#39;MSTD ({self.short_name})&#39;
    ), mstd_trace_kwargs)

    fig = self.mstd.vbt.plot(trace_kwargs=mstd_trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.indexing.PandasIndexer.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.indicators.basic.OBV"><code class="flex name class">
<span>class <span class="ident parent-fname">OBV</span></span>
<span>(</span><span>input_list, input_mapper, output_list, param_list, mapper_list, short_name)</span>
</code></dt>
<dd>
<div class="desc"><p>On-balance volume (OBV) is a technical trading momentum indicator that uses volume flow to predict
changes in stock price.</p>
<p>See <a href="https://www.investopedia.com/terms/o/onbalancevolume.asp">On-Balance Volume (OBV)</a>.</p>
<p>Use <code><a title="vectorbt.indicators.basic.OBV.run" href="#vectorbt.indicators.basic.OBV.run">run()</a></code> to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OBV(OBV):
    &#34;&#34;&#34;On-balance volume (OBV) is a technical trading momentum indicator that uses volume flow to predict
    changes in stock price.

    See [On-Balance Volume (OBV)](https://www.investopedia.com/terms/o/onbalancevolume.asp).

    Use `OBV.run` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             obv_trace_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `OBV.obv`.

        Args:
            obv_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `OBV.obv`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            obv.plot()
            ```

            ![](/vectorbt/docs/img/OBV.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        obv_trace_kwargs = merge_kwargs(dict(
            name=f&#39;OBV ({self.short_name})&#39;
        ), obv_trace_kwargs)

        fig = self.obv.vbt.plot(trace_kwargs=obv_trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.OBV.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>close, volume, *args, short_name='obv', hide_params=[], hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the OBV indicator using input time series <code>close</code> and <code>volume</code>, and no parameters, to
produce output time series <code>obv</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to <code>False</code> to show column levels of parameters with the default value passed.
Keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.OBV.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.obv"><code class="name">var <span class="ident fname">obv</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return getattr(self, &#39;_&#39; + output_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Short name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.volume"><code class="name">var <span class="ident fname">volume</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.OBV.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.obv_above"><code class="name flex">
<span>def <span class="ident fname">obv_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>obv</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>obv</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.obv_below"><code class="name flex">
<span>def <span class="ident fname">obv_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>obv</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>obv</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.obv_equal"><code class="name flex">
<span>def <span class="ident fname">obv_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>obv</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>obv</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, obv_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.OBV.obv" href="#vectorbt.indicators.basic.OBV.obv">OBV.obv</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obv_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.OBV.obv" href="#vectorbt.indicators.basic.OBV.obv">OBV.obv</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="py">obv.plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/OBV.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         obv_trace_kwargs={},
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `OBV.obv`.

    Args:
        obv_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `OBV.obv`.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Example:
        ```py
        obv.plot()
        ```

        ![](/vectorbt/docs/img/OBV.png)&#34;&#34;&#34;
    if self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;You must select a column first&#34;)

    obv_trace_kwargs = merge_kwargs(dict(
        name=f&#39;OBV ({self.short_name})&#39;
    ), obv_trace_kwargs)

    fig = self.obv.vbt.plot(trace_kwargs=obv_trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.volume_above"><code class="name flex">
<span>def <span class="ident fname">volume_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>volume</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>volume</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.volume_below"><code class="name flex">
<span>def <span class="ident fname">volume_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>volume</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>volume</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.volume_equal"><code class="name flex">
<span>def <span class="ident fname">volume_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>volume</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>volume</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.indexing.PandasIndexer.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.indicators.basic.RSI"><code class="flex name class">
<span>class <span class="ident parent-fname">RSI</span></span>
<span>(</span><span>input_list, input_mapper, output_list, param_list, mapper_list, short_name)</span>
</code></dt>
<dd>
<div class="desc"><p>The relative strength index (RSI) is a momentum indicator that measures the magnitude of
recent price changes to evaluate overbought or oversold conditions in the price of a stock
or other asset. The RSI is displayed as an oscillator (a line graph that moves between two
extremes) and can have a reading from 0 to 100.</p>
<p>See <a href="https://www.investopedia.com/terms/r/rsi.asp">Relative Strength Index (RSI)</a>.</p>
<p>Use <code><a title="vectorbt.indicators.basic.RSI.run" href="#vectorbt.indicators.basic.RSI.run">run()</a></code> or <code><a title="vectorbt.indicators.basic.RSI.run_combs" href="#vectorbt.indicators.basic.RSI.run_combs">run_combs()</a></code> to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RSI(RSI):
    &#34;&#34;&#34;The relative strength index (RSI) is a momentum indicator that measures the magnitude of
    recent price changes to evaluate overbought or oversold conditions in the price of a stock
    or other asset. The RSI is displayed as an oscillator (a line graph that moves between two
    extremes) and can have a reading from 0 to 100.

    See [Relative Strength Index (RSI)](https://www.investopedia.com/terms/r/rsi.asp).

    Use `RSI.run` or `RSI.run_combs` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             levels=(30, 70),
             rsi_trace_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `RSI.rsi`.

        Args:
            trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `RSI.rsi`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            rsi[(10, False)].plot()
            ```

            ![](/vectorbt/docs/img/RSI.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        rsi_trace_kwargs = merge_kwargs(dict(
            name=f&#39;RSI ({self.short_name})&#39;
        ), rsi_trace_kwargs)

        layout_kwargs = merge_kwargs(dict(yaxis=dict(range=[-5, 105])), layout_kwargs)
        fig = self.rsi.vbt.plot(trace_kwargs=rsi_trace_kwargs, fig=fig, **layout_kwargs)

        # Fill void between levels
        fig.add_shape(
            type=&#34;rect&#34;,
            xref=&#34;x&#34;,
            yref=&#34;y&#34;,
            x0=self.rsi.index[0],
            y0=levels[0],
            x1=self.rsi.index[-1],
            y1=levels[1],
            fillcolor=&#34;purple&#34;,
            opacity=0.15,
            layer=&#34;below&#34;,
            line_width=0,
        )

        return fig</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.RSI.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>close, window=14, ewm=False, *args, short_name='rsi', hide_params=[], hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the RSI indicator using input time series <code>close</code>, and parameters <code>window</code> and <code>ewm</code>, to
produce output time series <code>rsi</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to <code>False</code> to show column levels of parameters with the default value passed.
Keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>close, window=14, ewm=False, *args, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple RSI indicators using function <code>comb_func</code>.
Run each indicator using input time series <code>close</code>, and parameters <code>window</code> and <code>ewm</code>, to produce output time series <code>rsi</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to <code>True</code> to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).
Keyword arguments are passed to <code><a title="vectorbt.indicators.basic.RSI.run" href="#vectorbt.indicators.basic.RSI.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.RSI.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.ewm_loc"><code class="name">var <span class="ident fname">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>ewm</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.rsi"><code class="name">var <span class="ident fname">rsi</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return getattr(self, &#39;_&#39; + output_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Short name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.tuple_loc"><code class="name">var <span class="ident fname">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>tuple</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.window_loc"><code class="name">var <span class="ident fname">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>window</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.RSI.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, levels=(30, 70), rsi_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.RSI.rsi" href="#vectorbt.indicators.basic.RSI.rsi">RSI.rsi</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.RSI.rsi" href="#vectorbt.indicators.basic.RSI.rsi">RSI.rsi</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="py">rsi[(10, False)].plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/RSI.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         levels=(30, 70),
         rsi_trace_kwargs={},
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `RSI.rsi`.

    Args:
        trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `RSI.rsi`.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Example:
        ```py
        rsi[(10, False)].plot()
        ```

        ![](/vectorbt/docs/img/RSI.png)&#34;&#34;&#34;
    if self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;You must select a column first&#34;)

    rsi_trace_kwargs = merge_kwargs(dict(
        name=f&#39;RSI ({self.short_name})&#39;
    ), rsi_trace_kwargs)

    layout_kwargs = merge_kwargs(dict(yaxis=dict(range=[-5, 105])), layout_kwargs)
    fig = self.rsi.vbt.plot(trace_kwargs=rsi_trace_kwargs, fig=fig, **layout_kwargs)

    # Fill void between levels
    fig.add_shape(
        type=&#34;rect&#34;,
        xref=&#34;x&#34;,
        yref=&#34;y&#34;,
        x0=self.rsi.index[0],
        y0=levels[0],
        x1=self.rsi.index[-1],
        y1=levels[1],
        fillcolor=&#34;purple&#34;,
        opacity=0.15,
        layer=&#34;below&#34;,
        line_width=0,
    )

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.rsi_above"><code class="name flex">
<span>def <span class="ident fname">rsi_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>rsi</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>rsi</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.rsi_below"><code class="name flex">
<span>def <span class="ident fname">rsi_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>rsi</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>rsi</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.rsi_equal"><code class="name flex">
<span>def <span class="ident fname">rsi_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>rsi</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>rsi</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.indexing.PandasIndexer.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic"><code class="flex name class">
<span>class <span class="ident parent-fname">Stochastic</span></span>
<span>(</span><span>input_list, input_mapper, output_list, param_list, mapper_list, short_name)</span>
</code></dt>
<dd>
<div class="desc"><p>A stochastic oscillator is a momentum indicator comparing a particular closing price of a security
to a range of its prices over a certain period of time. It is used to generate overbought and oversold
trading signals, utilizing a 0-100 bounded range of values.</p>
<p>See <a href="https://www.investopedia.com/terms/s/stochasticoscillator.asp">Stochastic Oscillator</a>.</p>
<p>Use <code><a title="vectorbt.indicators.basic.Stochastic.run" href="#vectorbt.indicators.basic.Stochastic.run">run()</a></code> or <code><a title="vectorbt.indicators.basic.Stochastic.run_combs" href="#vectorbt.indicators.basic.Stochastic.run_combs">run_combs()</a></code> to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stochastic(Stochastic):
    &#34;&#34;&#34;A stochastic oscillator is a momentum indicator comparing a particular closing price of a security
    to a range of its prices over a certain period of time. It is used to generate overbought and oversold
    trading signals, utilizing a 0-100 bounded range of values.

    See [Stochastic Oscillator](https://www.investopedia.com/terms/s/stochasticoscillator.asp).

    Use `Stochastic.run` or `Stochastic.run_combs` to run the indicator.&#34;&#34;&#34;

    def plot(self,
             levels=(30, 70),
             percent_k_trace_kwargs={},
             percent_d_trace_kwargs={},
             shape_kwargs={},
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `Stochastic.percent_k` and `Stochastic.percent_d`.

        Args:
            percent_k_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `Stochastic.percent_k`.
            percent_d_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `Stochastic.percent_d`.
            shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zone between levels.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            stoch[(10, 2, False)].plot(levels=(20, 80))
            ```

            ![](/vectorbt/docs/img/Stochastic.png)&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;You must select a column first&#34;)

        percent_k_trace_kwargs = merge_kwargs(dict(
            name=f&#39;%K ({self.short_name})&#39;
        ), percent_k_trace_kwargs)
        percent_d_trace_kwargs = merge_kwargs(dict(
            name=f&#39;%D ({self.short_name})&#39;
        ), percent_d_trace_kwargs)

        layout_kwargs = merge_kwargs(dict(yaxis=dict(range=[-5, 105])), layout_kwargs)
        fig = self.percent_k.vbt.plot(trace_kwargs=percent_k_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.percent_d.vbt.plot(trace_kwargs=percent_d_trace_kwargs, fig=fig, **layout_kwargs)

        # Plot levels
        # Fill void between levels
        shape_kwargs = merge_kwargs(dict(
            type=&#34;rect&#34;,
            xref=&#34;x&#34;,
            yref=&#34;y&#34;,
            x0=self.percent_k.index[0],
            y0=levels[0],
            x1=self.percent_k.index[-1],
            y1=levels[1],
            fillcolor=&#34;purple&#34;,
            opacity=0.15,
            layer=&#34;below&#34;,
            line_width=0,
        ), shape_kwargs)
        fig.add_shape(**shape_kwargs)

        return fig</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.Stochastic.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>high, low, close, k_window=14, d_window=3, d_ewm=False, *args, short_name='stoch', hide_params=[], hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the Stochastic indicator using input time series <code>high</code>, <code>low</code> and <code>close</code>, and parameters <code>k_window</code>, <code>d_window</code> and <code>d_ewm</code>, to
produce output time series <code>percent_k</code> and <code>percent_d</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to <code>False</code> to show column levels of parameters with the default value passed.
Keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>high, low, close, k_window=14, d_window=3, d_ewm=False, *args, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple Stochastic indicators using function <code>comb_func</code>.
Run each indicator using input time series <code>high</code>, <code>low</code> and <code>close</code>, and parameters <code>k_window</code>, <code>d_window</code> and <code>d_ewm</code>, to produce output time series <code>percent_k</code> and <code>percent_d</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to <code>True</code> to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).
Keyword arguments are passed to <code><a title="vectorbt.indicators.basic.Stochastic.run" href="#vectorbt.indicators.basic.Stochastic.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;An indicator factory for building new indicators with ease.

Each indicator is basically a pipeline that

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by this indicatory factory.

On top of this pipeline, it also does the following:

* Generates a new Python class
* Creates an `__init__` method where it stores all inputs, outputs, and other artifacts
* Creates a `run` method that runs the main pipeline using `run_pipeline`
* Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Adds user-defined properties
* Adds common comparison methods for all inputs, outputs and properties, e.g., crossover

Consider the following smaller price DataFrame `price_sm`:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; print(price)
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; print(ma_df)
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `IndicatorFactory.run` method (as we did above) or
the `IndicatorFactory.run_combs` method.

### run method

The main method to run an indicator is `IndicatorFactory.run` that accepts 1) input time
series, 2) parameters (either positional arguments or keyword arguments if you specified
`param_defaults`), and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd.output)
custom_p1      1
custom_p2      2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to `True` to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
```

The output of the `IndicatorFactory.run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `IndicatorFactory.run_combs` method takes the same inputs as the method above, but computes
all combinations of passed parameters and returns multiple instances that can be compared with
each other. For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; print(myma1.ma)
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; print(myma2.ma)
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; print(myma1.ma_above(myma2.ma, crossed=True))
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; print(myma.ma_above([1.5, 2.5], multiple=True))
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; print(myma[(2, &#39;b&#39;)])
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import PandasIndexer, ParamIndexerFactory, indexing_on_mapper
from vectorbt.base.array_wrapper import ArrayWrapper


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = list(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.Stochastic.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.d_ewm_loc"><code class="name">var <span class="ident fname">d_ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>d_ewm</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.d_window_loc"><code class="name">var <span class="ident fname">d_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>d_window</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.high"><code class="name">var <span class="ident fname">high</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.k_window_loc"><code class="name">var <span class="ident fname">k_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>k_window</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.low"><code class="name">var <span class="ident fname">low</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.percent_d"><code class="name">var <span class="ident fname">percent_d</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return getattr(self, &#39;_&#39; + output_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.percent_k"><code class="name">var <span class="ident fname">percent_k</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return getattr(self, &#39;_&#39; + output_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Short name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.tuple_loc"><code class="name">var <span class="ident fname">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>tuple</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.Stochastic.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.high_above"><code class="name flex">
<span>def <span class="ident fname">high_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>high</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>high</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.high_below"><code class="name flex">
<span>def <span class="ident fname">high_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>high</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>high</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.high_equal"><code class="name flex">
<span>def <span class="ident fname">high_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>high</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>high</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.low_above"><code class="name flex">
<span>def <span class="ident fname">low_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>low</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>low</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.low_below"><code class="name flex">
<span>def <span class="ident fname">low_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>low</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>low</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.low_equal"><code class="name flex">
<span>def <span class="ident fname">low_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>low</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>low</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.percent_d_above"><code class="name flex">
<span>def <span class="ident fname">percent_d_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>percent_d</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>percent_d</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.percent_d_below"><code class="name flex">
<span>def <span class="ident fname">percent_d_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>percent_d</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>percent_d</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.percent_d_equal"><code class="name flex">
<span>def <span class="ident fname">percent_d_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>percent_d</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>percent_d</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.percent_k_above"><code class="name flex">
<span>def <span class="ident fname">percent_k_above</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>percent_k</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>percent_k</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.percent_k_below"><code class="name flex">
<span>def <span class="ident fname">percent_k_below</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>percent_k</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>percent_k</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.percent_k_equal"><code class="name flex">
<span>def <span class="ident fname">percent_k_equal</span></span>(<span>self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> for each element where <code>percent_k</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to <code>True</code> to return the first <code>True</code> after crossover. Specify <code>wait</code> to return
<code>True</code> only when <code>percent_k</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossed=False, wait=0, level_name=None, after_false=True, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if level_name is None:
        if attr == self.short_name:
            level_name = f&#39;{self.short_name}_{func_name}&#39;
        else:
            level_name = f&#39;{self.short_name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, level_name=level_name, **kwargs)
    if crossed:
        return result.vbt.signals.nst(wait + 1, after_false=after_false)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.Stochastic.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, levels=(30, 70), percent_k_trace_kwargs={}, percent_d_trace_kwargs={}, shape_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.Stochastic.percent_k" href="#vectorbt.indicators.basic.Stochastic.percent_k">Stochastic.percent_k</a></code> and <code><a title="vectorbt.indicators.basic.Stochastic.percent_d" href="#vectorbt.indicators.basic.Stochastic.percent_d">Stochastic.percent_d</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>percent_k_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.Stochastic.percent_k" href="#vectorbt.indicators.basic.Stochastic.percent_k">Stochastic.percent_k</a></code>.</dd>
<dt><strong><code>percent_d_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.Stochastic.percent_d" href="#vectorbt.indicators.basic.Stochastic.percent_d">Stochastic.percent_d</a></code>.</dd>
<dt><strong><code>shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zone between levels.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="py">stoch[(10, 2, False)].plot(levels=(20, 80))
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/Stochastic.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         levels=(30, 70),
         percent_k_trace_kwargs={},
         percent_d_trace_kwargs={},
         shape_kwargs={},
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `Stochastic.percent_k` and `Stochastic.percent_d`.

    Args:
        percent_k_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `Stochastic.percent_k`.
        percent_d_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `Stochastic.percent_d`.
        shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zone between levels.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Example:
        ```py
        stoch[(10, 2, False)].plot(levels=(20, 80))
        ```

        ![](/vectorbt/docs/img/Stochastic.png)&#34;&#34;&#34;
    if self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;You must select a column first&#34;)

    percent_k_trace_kwargs = merge_kwargs(dict(
        name=f&#39;%K ({self.short_name})&#39;
    ), percent_k_trace_kwargs)
    percent_d_trace_kwargs = merge_kwargs(dict(
        name=f&#39;%D ({self.short_name})&#39;
    ), percent_d_trace_kwargs)

    layout_kwargs = merge_kwargs(dict(yaxis=dict(range=[-5, 105])), layout_kwargs)
    fig = self.percent_k.vbt.plot(trace_kwargs=percent_k_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.percent_d.vbt.plot(trace_kwargs=percent_d_trace_kwargs, fig=fig, **layout_kwargs)

    # Plot levels
    # Fill void between levels
    shape_kwargs = merge_kwargs(dict(
        type=&#34;rect&#34;,
        xref=&#34;x&#34;,
        yref=&#34;y&#34;,
        x0=self.percent_k.index[0],
        y0=levels[0],
        x1=self.percent_k.index[-1],
        y1=levels[1],
        fillcolor=&#34;purple&#34;,
        opacity=0.15,
        layer=&#34;below&#34;,
        line_width=0,
    ), shape_kwargs)
    fig.add_shape(**shape_kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.indexing.PandasIndexer.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAACXBIWXMAACcQAAAnEAGUaVEZAAAGuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDggNzkuMTY0MDM2LCAyMDE5LzA4LzEzLTAxOjA2OjU3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjEuMCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjAtMDYtMjVUMjM6MzU6MTMrMDI6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjAtMDYtMjZUMTQ6MTA6MzgrMDI6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIwLTA2LTI2VDE0OjEwOjM4KzAyOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNzE0MGFiYi05Mjk1LTQ3MDYtYTNhZi1lMDg2OTFkOTk3NjQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NzZmN2Y4NjAtMThmMi00ZDgxLTg5NjUtNDU5ZjY1NDY2ZGZlIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NzZmN2Y4NjAtMThmMi00ZDgxLTg5NjUtNDU5ZjY1NDY2ZGZlIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjc2ZjdmODYwLTE4ZjItNGQ4MS04OTY1LTQ1OWY2NTQ2NmRmZSIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNVQyMzozNToxMyswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2NjI2MGIzLTY0ZmUtNGJiYy1iMTNiLWZkMDU3NDI3NjIyNCIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNlQxMzoyMTo1NSswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjA3MTQwYWJiLTkyOTUtNDcwNi1hM2FmLWUwODY5MWQ5OTc2NCIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNlQxNDoxMDozOCswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Qc/+aQAAAa5JREFUeJzt3cFJA0EYgFEjgj3FGmIjsQexByuxB4vy5kHwELJhCRPekP3eMYdl4Ms/y84Gstsfjg9xHvUCtq4AWAGwAmAFwAqAFQArAFYArABYAbACYAXACoAVACsAVgCsAFgBsAJgBcAKgBUAexp1oe+vz7Ofv7y+dZ0LmgCsAFgBsAJgBcAKgBUAKwBWAKwAWAGwAmAFwAqAFQAb9j5glFHn7KPcej1NAFYAzG9BP+/n3/ld9vwx1051tSYA8xPwZ/03+rqJmVYTgBUAm2UL+re0w6i7br8LunMFwAqAFQArAFYArADYdM8Bd3PKtlITgBUAm2ULurMzzvWaAMxPwNbuuieaAKwAmN+CTtz6/H02TQBWAKwAWAGwAmAFwAqAFQArAFYArABYAbACYAXACoANex8w23n9bOtZ0gRgBcAKgBUAKwBWAKwA2HT/HzDKbOtZ0gRgBcAKgBUAKwBWAKwAWAGwAmAFwAqAFQArAFYArADYbn846jVsWhOAFQArAFYArABYAbACYAXACoAVACsAVgCsAFgBsAJgBcAKgBUAKwBWAKwAWAGwAmC/7uUrwcQVST8AAAAASUVORK5CYII="/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.indicators" href="index.html">vectorbt.indicators</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.indicators.basic.ATR" href="#vectorbt.indicators.basic.ATR">ATR</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.ATR.atr" href="#vectorbt.indicators.basic.ATR.atr">atr</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.atr_above" href="#vectorbt.indicators.basic.ATR.atr_above">atr_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.atr_below" href="#vectorbt.indicators.basic.ATR.atr_below">atr_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.atr_equal" href="#vectorbt.indicators.basic.ATR.atr_equal">atr_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.close" href="#vectorbt.indicators.basic.ATR.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.close_above" href="#vectorbt.indicators.basic.ATR.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.close_below" href="#vectorbt.indicators.basic.ATR.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.close_equal" href="#vectorbt.indicators.basic.ATR.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.ewm_loc" href="#vectorbt.indicators.basic.ATR.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.high" href="#vectorbt.indicators.basic.ATR.high">high</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.high_above" href="#vectorbt.indicators.basic.ATR.high_above">high_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.high_below" href="#vectorbt.indicators.basic.ATR.high_below">high_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.high_equal" href="#vectorbt.indicators.basic.ATR.high_equal">high_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.low" href="#vectorbt.indicators.basic.ATR.low">low</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.low_above" href="#vectorbt.indicators.basic.ATR.low_above">low_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.low_below" href="#vectorbt.indicators.basic.ATR.low_below">low_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.low_equal" href="#vectorbt.indicators.basic.ATR.low_equal">low_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.plot" href="#vectorbt.indicators.basic.ATR.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.run" href="#vectorbt.indicators.basic.ATR.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.run_combs" href="#vectorbt.indicators.basic.ATR.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.short_name" href="#vectorbt.indicators.basic.ATR.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.tr" href="#vectorbt.indicators.basic.ATR.tr">tr</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.tr_above" href="#vectorbt.indicators.basic.ATR.tr_above">tr_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.tr_below" href="#vectorbt.indicators.basic.ATR.tr_below">tr_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.tr_equal" href="#vectorbt.indicators.basic.ATR.tr_equal">tr_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.tuple_loc" href="#vectorbt.indicators.basic.ATR.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.window_loc" href="#vectorbt.indicators.basic.ATR.window_loc">window_loc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.basic.BollingerBands" href="#vectorbt.indicators.basic.BollingerBands">BollingerBands</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.BollingerBands.alpha_loc" href="#vectorbt.indicators.basic.BollingerBands.alpha_loc">alpha_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.bandwidth" href="#vectorbt.indicators.basic.BollingerBands.bandwidth">bandwidth</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.bandwidth_above" href="#vectorbt.indicators.basic.BollingerBands.bandwidth_above">bandwidth_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.bandwidth_below" href="#vectorbt.indicators.basic.BollingerBands.bandwidth_below">bandwidth_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.bandwidth_equal" href="#vectorbt.indicators.basic.BollingerBands.bandwidth_equal">bandwidth_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.close" href="#vectorbt.indicators.basic.BollingerBands.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.close_above" href="#vectorbt.indicators.basic.BollingerBands.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.close_below" href="#vectorbt.indicators.basic.BollingerBands.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.close_equal" href="#vectorbt.indicators.basic.BollingerBands.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.ewm_loc" href="#vectorbt.indicators.basic.BollingerBands.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.lower" href="#vectorbt.indicators.basic.BollingerBands.lower">lower</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.lower_above" href="#vectorbt.indicators.basic.BollingerBands.lower_above">lower_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.lower_below" href="#vectorbt.indicators.basic.BollingerBands.lower_below">lower_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.lower_equal" href="#vectorbt.indicators.basic.BollingerBands.lower_equal">lower_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.middle" href="#vectorbt.indicators.basic.BollingerBands.middle">middle</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.middle_above" href="#vectorbt.indicators.basic.BollingerBands.middle_above">middle_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.middle_below" href="#vectorbt.indicators.basic.BollingerBands.middle_below">middle_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.middle_equal" href="#vectorbt.indicators.basic.BollingerBands.middle_equal">middle_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.percent_b" href="#vectorbt.indicators.basic.BollingerBands.percent_b">percent_b</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.percent_b_above" href="#vectorbt.indicators.basic.BollingerBands.percent_b_above">percent_b_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.percent_b_below" href="#vectorbt.indicators.basic.BollingerBands.percent_b_below">percent_b_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.percent_b_equal" href="#vectorbt.indicators.basic.BollingerBands.percent_b_equal">percent_b_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.plot" href="#vectorbt.indicators.basic.BollingerBands.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.run" href="#vectorbt.indicators.basic.BollingerBands.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.run_combs" href="#vectorbt.indicators.basic.BollingerBands.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.short_name" href="#vectorbt.indicators.basic.BollingerBands.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.tuple_loc" href="#vectorbt.indicators.basic.BollingerBands.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.upper" href="#vectorbt.indicators.basic.BollingerBands.upper">upper</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.upper_above" href="#vectorbt.indicators.basic.BollingerBands.upper_above">upper_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.upper_below" href="#vectorbt.indicators.basic.BollingerBands.upper_below">upper_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.upper_equal" href="#vectorbt.indicators.basic.BollingerBands.upper_equal">upper_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BollingerBands.window_loc" href="#vectorbt.indicators.basic.BollingerBands.window_loc">window_loc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.basic.MA" href="#vectorbt.indicators.basic.MA">MA</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.MA.close" href="#vectorbt.indicators.basic.MA.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.close_above" href="#vectorbt.indicators.basic.MA.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.close_below" href="#vectorbt.indicators.basic.MA.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.close_equal" href="#vectorbt.indicators.basic.MA.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.ewm_loc" href="#vectorbt.indicators.basic.MA.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.ma" href="#vectorbt.indicators.basic.MA.ma">ma</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.ma_above" href="#vectorbt.indicators.basic.MA.ma_above">ma_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.ma_below" href="#vectorbt.indicators.basic.MA.ma_below">ma_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.ma_equal" href="#vectorbt.indicators.basic.MA.ma_equal">ma_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.plot" href="#vectorbt.indicators.basic.MA.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.run" href="#vectorbt.indicators.basic.MA.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.run_combs" href="#vectorbt.indicators.basic.MA.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.short_name" href="#vectorbt.indicators.basic.MA.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.tuple_loc" href="#vectorbt.indicators.basic.MA.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.window_loc" href="#vectorbt.indicators.basic.MA.window_loc">window_loc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.basic.MACD" href="#vectorbt.indicators.basic.MACD">MACD</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.MACD.close" href="#vectorbt.indicators.basic.MACD.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.close_above" href="#vectorbt.indicators.basic.MACD.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.close_below" href="#vectorbt.indicators.basic.MACD.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.close_equal" href="#vectorbt.indicators.basic.MACD.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.fast_window_loc" href="#vectorbt.indicators.basic.MACD.fast_window_loc">fast_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.hist" href="#vectorbt.indicators.basic.MACD.hist">hist</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.hist_above" href="#vectorbt.indicators.basic.MACD.hist_above">hist_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.hist_below" href="#vectorbt.indicators.basic.MACD.hist_below">hist_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.hist_equal" href="#vectorbt.indicators.basic.MACD.hist_equal">hist_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.macd" href="#vectorbt.indicators.basic.MACD.macd">macd</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.macd_above" href="#vectorbt.indicators.basic.MACD.macd_above">macd_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.macd_below" href="#vectorbt.indicators.basic.MACD.macd_below">macd_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.macd_equal" href="#vectorbt.indicators.basic.MACD.macd_equal">macd_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.macd_ewm_loc" href="#vectorbt.indicators.basic.MACD.macd_ewm_loc">macd_ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.plot" href="#vectorbt.indicators.basic.MACD.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.run" href="#vectorbt.indicators.basic.MACD.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.run_combs" href="#vectorbt.indicators.basic.MACD.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.short_name" href="#vectorbt.indicators.basic.MACD.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.signal" href="#vectorbt.indicators.basic.MACD.signal">signal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.signal_above" href="#vectorbt.indicators.basic.MACD.signal_above">signal_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.signal_below" href="#vectorbt.indicators.basic.MACD.signal_below">signal_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.signal_equal" href="#vectorbt.indicators.basic.MACD.signal_equal">signal_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.signal_ewm_loc" href="#vectorbt.indicators.basic.MACD.signal_ewm_loc">signal_ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.signal_window_loc" href="#vectorbt.indicators.basic.MACD.signal_window_loc">signal_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.slow_window_loc" href="#vectorbt.indicators.basic.MACD.slow_window_loc">slow_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.tuple_loc" href="#vectorbt.indicators.basic.MACD.tuple_loc">tuple_loc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.basic.MSTD" href="#vectorbt.indicators.basic.MSTD">MSTD</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.MSTD.close" href="#vectorbt.indicators.basic.MSTD.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.close_above" href="#vectorbt.indicators.basic.MSTD.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.close_below" href="#vectorbt.indicators.basic.MSTD.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.close_equal" href="#vectorbt.indicators.basic.MSTD.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.ewm_loc" href="#vectorbt.indicators.basic.MSTD.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.mstd" href="#vectorbt.indicators.basic.MSTD.mstd">mstd</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.mstd_above" href="#vectorbt.indicators.basic.MSTD.mstd_above">mstd_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.mstd_below" href="#vectorbt.indicators.basic.MSTD.mstd_below">mstd_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.mstd_equal" href="#vectorbt.indicators.basic.MSTD.mstd_equal">mstd_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.plot" href="#vectorbt.indicators.basic.MSTD.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.run" href="#vectorbt.indicators.basic.MSTD.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.run_combs" href="#vectorbt.indicators.basic.MSTD.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.short_name" href="#vectorbt.indicators.basic.MSTD.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.tuple_loc" href="#vectorbt.indicators.basic.MSTD.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.window_loc" href="#vectorbt.indicators.basic.MSTD.window_loc">window_loc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.basic.OBV" href="#vectorbt.indicators.basic.OBV">OBV</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.OBV.close" href="#vectorbt.indicators.basic.OBV.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.close_above" href="#vectorbt.indicators.basic.OBV.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.close_below" href="#vectorbt.indicators.basic.OBV.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.close_equal" href="#vectorbt.indicators.basic.OBV.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.obv" href="#vectorbt.indicators.basic.OBV.obv">obv</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.obv_above" href="#vectorbt.indicators.basic.OBV.obv_above">obv_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.obv_below" href="#vectorbt.indicators.basic.OBV.obv_below">obv_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.obv_equal" href="#vectorbt.indicators.basic.OBV.obv_equal">obv_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.plot" href="#vectorbt.indicators.basic.OBV.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.run" href="#vectorbt.indicators.basic.OBV.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.short_name" href="#vectorbt.indicators.basic.OBV.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.volume" href="#vectorbt.indicators.basic.OBV.volume">volume</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.volume_above" href="#vectorbt.indicators.basic.OBV.volume_above">volume_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.volume_below" href="#vectorbt.indicators.basic.OBV.volume_below">volume_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.volume_equal" href="#vectorbt.indicators.basic.OBV.volume_equal">volume_equal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.basic.RSI" href="#vectorbt.indicators.basic.RSI">RSI</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.RSI.close" href="#vectorbt.indicators.basic.RSI.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.close_above" href="#vectorbt.indicators.basic.RSI.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.close_below" href="#vectorbt.indicators.basic.RSI.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.close_equal" href="#vectorbt.indicators.basic.RSI.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.ewm_loc" href="#vectorbt.indicators.basic.RSI.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.plot" href="#vectorbt.indicators.basic.RSI.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.rsi" href="#vectorbt.indicators.basic.RSI.rsi">rsi</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.rsi_above" href="#vectorbt.indicators.basic.RSI.rsi_above">rsi_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.rsi_below" href="#vectorbt.indicators.basic.RSI.rsi_below">rsi_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.rsi_equal" href="#vectorbt.indicators.basic.RSI.rsi_equal">rsi_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.run" href="#vectorbt.indicators.basic.RSI.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.run_combs" href="#vectorbt.indicators.basic.RSI.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.short_name" href="#vectorbt.indicators.basic.RSI.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.tuple_loc" href="#vectorbt.indicators.basic.RSI.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.window_loc" href="#vectorbt.indicators.basic.RSI.window_loc">window_loc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.basic.Stochastic" href="#vectorbt.indicators.basic.Stochastic">Stochastic</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.Stochastic.close" href="#vectorbt.indicators.basic.Stochastic.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.close_above" href="#vectorbt.indicators.basic.Stochastic.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.close_below" href="#vectorbt.indicators.basic.Stochastic.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.close_equal" href="#vectorbt.indicators.basic.Stochastic.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.d_ewm_loc" href="#vectorbt.indicators.basic.Stochastic.d_ewm_loc">d_ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.d_window_loc" href="#vectorbt.indicators.basic.Stochastic.d_window_loc">d_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.high" href="#vectorbt.indicators.basic.Stochastic.high">high</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.high_above" href="#vectorbt.indicators.basic.Stochastic.high_above">high_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.high_below" href="#vectorbt.indicators.basic.Stochastic.high_below">high_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.high_equal" href="#vectorbt.indicators.basic.Stochastic.high_equal">high_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.k_window_loc" href="#vectorbt.indicators.basic.Stochastic.k_window_loc">k_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.low" href="#vectorbt.indicators.basic.Stochastic.low">low</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.low_above" href="#vectorbt.indicators.basic.Stochastic.low_above">low_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.low_below" href="#vectorbt.indicators.basic.Stochastic.low_below">low_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.low_equal" href="#vectorbt.indicators.basic.Stochastic.low_equal">low_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.percent_d" href="#vectorbt.indicators.basic.Stochastic.percent_d">percent_d</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.percent_d_above" href="#vectorbt.indicators.basic.Stochastic.percent_d_above">percent_d_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.percent_d_below" href="#vectorbt.indicators.basic.Stochastic.percent_d_below">percent_d_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.percent_d_equal" href="#vectorbt.indicators.basic.Stochastic.percent_d_equal">percent_d_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.percent_k" href="#vectorbt.indicators.basic.Stochastic.percent_k">percent_k</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.percent_k_above" href="#vectorbt.indicators.basic.Stochastic.percent_k_above">percent_k_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.percent_k_below" href="#vectorbt.indicators.basic.Stochastic.percent_k_below">percent_k_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.percent_k_equal" href="#vectorbt.indicators.basic.Stochastic.percent_k_equal">percent_k_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.plot" href="#vectorbt.indicators.basic.Stochastic.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.run" href="#vectorbt.indicators.basic.Stochastic.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.run_combs" href="#vectorbt.indicators.basic.Stochastic.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.short_name" href="#vectorbt.indicators.basic.Stochastic.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.Stochastic.tuple_loc" href="#vectorbt.indicators.basic.Stochastic.tuple_loc">tuple_loc</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>