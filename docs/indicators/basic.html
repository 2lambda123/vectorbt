<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.indicators.basic API documentation</title>
<meta name="description" content="Indicators built with `vectorbt.indicators.factory.IndicatorFactory` …" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3B4556}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="mask-icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.indicators.basic</code></h1>
</header>
<section id="section-intro">
<p>Indicators built with <code><a title="vectorbt.indicators.factory.IndicatorFactory" href="factory.html#vectorbt.indicators.factory.IndicatorFactory">IndicatorFactory</a></code>.</p>
<p>You can access all the indicators either by <code>vbt.*</code> or <code>vbt.indicators.*</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; # vectorbt.indicators.basic.MA
&gt;&gt;&gt; vbt.MA.run(pd.Series([1, 2, 3]), [2, 3]).ma
ma_window     2     3
ma_ewm    False False
0           NaN   NaN
1           1.5   NaN
2           2.5   2.0
</code></pre>
<p>The advantage of these indicators over TA-Lib's is that they work primarily on 2-dimensional arrays
and utilize caching, which makes them faster for matrices with huge number of columns. They also
have plotting methods.</p>
<p>Run for the examples below:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; start = datetime(2019, 3, 1)
&gt;&gt;&gt; end = datetime(2019, 9, 1)
&gt;&gt;&gt; cols = ['Open', 'High', 'Low', 'Close', 'Volume']
&gt;&gt;&gt; ohlcv = vbt.YFData.download(&quot;BTC-USD&quot;, start=start, end=end).get(cols)
&gt;&gt;&gt; ohlcv
                    Open          High          Low        Close       Volume
Date
2019-03-01   3853.757080   3907.795410  3851.692383  3859.583740   7661247975
2019-03-02   3855.318115   3874.607422  3832.127930  3864.415039   7578786076
2019-03-03   3862.266113   3875.483643  3836.905762  3847.175781   7253558152
...                  ...           ...          ...          ...          ...
2019-08-30   9514.844727   9656.124023  9428.302734  9598.173828  13595263986
2019-08-31   9597.539062   9673.220703  9531.799805  9630.664062  11454806419
2019-09-01   9630.592773   9796.755859  9582.944336  9757.970703  11445355859

[185 rows x 5 columns]

&gt;&gt;&gt; ohlcv.vbt.ohlcv.plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/basic_price.png"></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Indicators built with `vectorbt.indicators.factory.IndicatorFactory`.

You can access all the indicators either by `vbt.*` or `vbt.indicators.*`.

```python-repl
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; # vectorbt.indicators.basic.MA
&gt;&gt;&gt; vbt.MA.run(pd.Series([1, 2, 3]), [2, 3]).ma
ma_window     2     3
ma_ewm    False False
0           NaN   NaN
1           1.5   NaN
2           2.5   2.0
```

The advantage of these indicators over TA-Lib&#39;s is that they work primarily on 2-dimensional arrays
and utilize caching, which makes them faster for matrices with huge number of columns. They also
have plotting methods.

Run for the examples below:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; start = datetime(2019, 3, 1)
&gt;&gt;&gt; end = datetime(2019, 9, 1)
&gt;&gt;&gt; cols = [&#39;Open&#39;, &#39;High&#39;, &#39;Low&#39;, &#39;Close&#39;, &#39;Volume&#39;]
&gt;&gt;&gt; ohlcv = vbt.YFData.download(&#34;BTC-USD&#34;, start=start, end=end).get(cols)
&gt;&gt;&gt; ohlcv
                    Open          High          Low        Close       Volume
Date
2019-03-01   3853.757080   3907.795410  3851.692383  3859.583740   7661247975
2019-03-02   3855.318115   3874.607422  3832.127930  3864.415039   7578786076
2019-03-03   3862.266113   3875.483643  3836.905762  3847.175781   7253558152
...                  ...           ...          ...          ...          ...
2019-08-30   9514.844727   9656.124023  9428.302734  9598.173828  13595263986
2019-08-31   9597.539062   9673.220703  9531.799805  9630.664062  11454806419
2019-09-01   9630.592773   9796.755859  9582.944336  9757.970703  11445355859

[185 rows x 5 columns]

&gt;&gt;&gt; ohlcv.vbt.ohlcv.plot()
```
![](/vectorbt/docs/img/basic_price.png)&#34;&#34;&#34;

import numpy as np
import plotly.graph_objects as go

from vectorbt.utils.config import merge_dicts
from vectorbt.utils.widgets import FigureWidget
from vectorbt.generic import nb as generic_nb
from vectorbt.indicators.factory import IndicatorFactory
from vectorbt.indicators import nb

# ############# MA ############# #


MA = IndicatorFactory(
    class_name=&#39;MA&#39;,
    module_name=__name__,
    short_name=&#39;ma&#39;,
    input_names=[&#39;close&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;ma&#39;]
).from_apply_func(
    nb.ma_apply_nb,
    cache_func=nb.ma_cache_nb,
    kwargs_to_args=[&#39;adjust&#39;],
    ewm=False,
    adjust=False
)


class _MA(MA):
    &#34;&#34;&#34;Moving Average (MA).

    A moving average is a widely used indicator in technical analysis that helps smooth out
    price action by filtering out the “noise” from random short-term price fluctuations. 

    See [Moving Average (MA)](https://www.investopedia.com/terms/m/movingaverage.asp).&#34;&#34;&#34;

    def plot(self,
             column=None,
             plot_close=True,
             close_trace_kwargs=None,
             ma_trace_kwargs=None,
             add_trace_kwargs=None,
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `MA.ma` against `MA.close`.

        Args:
            column (str): Name of the column to plot.
            plot_close (bool): Whether to plot `MA.close`.
            close_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MA.close`.
            ma_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MA.ma`.
            add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.

        ## Example

        ```python-repl
        &gt;&gt;&gt; vbt.MA.run(ohlcv[&#39;Close&#39;], 10).plot()
        ```

        ![](/vectorbt/docs/img/MA.png)
        &#34;&#34;&#34;
        from vectorbt.settings import color_schema

        self_col = self.select_series(column=column)

        if fig is None:
            fig = FigureWidget()
        fig.update_layout(**layout_kwargs)

        if close_trace_kwargs is None:
            close_trace_kwargs = {}
        if ma_trace_kwargs is None:
            ma_trace_kwargs = {}
        close_trace_kwargs = merge_dicts(dict(
            name=&#39;Close&#39;,
            line_color=color_schema[&#39;blue&#39;]
        ), close_trace_kwargs)
        ma_trace_kwargs = merge_dicts(dict(
            name=&#39;MA&#39;
        ), ma_trace_kwargs)

        if plot_close:
            fig = self_col.close.vbt.plot(
                trace_kwargs=close_trace_kwargs,
                add_trace_kwargs=add_trace_kwargs, fig=fig)
        fig = self_col.ma.vbt.plot(
            trace_kwargs=ma_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)

        return fig


setattr(MA, &#39;__doc__&#39;, _MA.__doc__)
setattr(MA, &#39;plot&#39;, _MA.plot)

# ############# MSTD ############# #


MSTD = IndicatorFactory(
    class_name=&#39;MSTD&#39;,
    module_name=__name__,
    short_name=&#39;mstd&#39;,
    input_names=[&#39;close&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;mstd&#39;]
).from_apply_func(
    nb.mstd_apply_nb,
    cache_func=nb.mstd_cache_nb,
    kwargs_to_args=[&#39;adjust&#39;, &#39;ddof&#39;],
    ewm=False,
    adjust=False,
    ddof=0
)


class _MSTD(MSTD):
    &#34;&#34;&#34;Moving Standard Deviation (MSTD).

    Standard deviation is an indicator that measures the size of an assets recent price moves
    in order to predict how volatile the price may be in the future.&#34;&#34;&#34;

    def plot(self,
             column=None,
             mstd_trace_kwargs=None,
             add_trace_kwargs=None,
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `MSTD.mstd`.

        Args:
            column (str): Name of the column to plot.
            mstd_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MSTD.mstd`.
            add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.

        ## Example

        ```python-repl
        &gt;&gt;&gt; vbt.MSTD.run(ohlcv[&#39;Close&#39;], 10).plot()
        ```

        ![](/vectorbt/docs/img/MSTD.png)
        &#34;&#34;&#34;
        self_col = self.select_series(column=column)

        if fig is None:
            fig = FigureWidget()
        fig.update_layout(**layout_kwargs)

        if mstd_trace_kwargs is None:
            mstd_trace_kwargs = {}
        mstd_trace_kwargs = merge_dicts(dict(
            name=&#39;MSTD&#39;
        ), mstd_trace_kwargs)

        fig = self_col.mstd.vbt.plot(
            trace_kwargs=mstd_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)

        return fig


setattr(MSTD, &#39;__doc__&#39;, _MSTD.__doc__)
setattr(MSTD, &#39;plot&#39;, _MSTD.plot)

# ############# BBANDS ############# #


BBANDS = IndicatorFactory(
    class_name=&#39;BBANDS&#39;,
    module_name=__name__,
    short_name=&#39;bb&#39;,
    input_names=[&#39;close&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;, &#39;alpha&#39;],
    output_names=[&#39;middle&#39;, &#39;upper&#39;, &#39;lower&#39;],
    custom_output_props=dict(
        percent_b=lambda self: self.wrapper.wrap(
            (self.close.values - self.lower.values) / (self.upper.values - self.lower.values)),
        bandwidth=lambda self: self.wrapper.wrap(
            (self.upper.values - self.lower.values) / self.middle.values)
    )
).from_apply_func(
    nb.bb_apply_nb,
    cache_func=nb.bb_cache_nb,
    kwargs_to_args=[&#39;adjust&#39;, &#39;ddof&#39;],
    window=20,
    ewm=False,
    alpha=2,
    adjust=False,
    ddof=0
)


class _BBANDS(BBANDS):
    &#34;&#34;&#34;Bollinger Bands (BBANDS).

    A Bollinger Band® is a technical analysis tool defined by a set of lines plotted two standard
    deviations (positively and negatively) away from a simple moving average (SMA) of the security&#39;s
    price, but can be adjusted to user preferences.

    See [Bollinger Band®](https://www.investopedia.com/terms/b/bollingerbands.asp).&#34;&#34;&#34;

    def plot(self,
             column=None,
             plot_close=True,
             close_trace_kwargs=None,
             middle_trace_kwargs=None,
             upper_trace_kwargs=None,
             lower_trace_kwargs=None,
             add_trace_kwargs=None,
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `BBANDS.middle`, `BBANDS.upper` and `BBANDS.lower` against
        `BBANDS.close`.

        Args:
            column (str): Name of the column to plot.
            plot_close (bool): Whether to plot `MA.close`.
            close_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BBANDS.close`.
            middle_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BBANDS.middle`.
            upper_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BBANDS.upper`.
            lower_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BBANDS.lower`.
            add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.

        ## Example

        ```python-repl
        &gt;&gt;&gt; vbt.BBANDS.run(ohlcv[&#39;Close&#39;]).plot()
        ```

        ![](/vectorbt/docs/img/BBANDS.png)
        &#34;&#34;&#34;
        from vectorbt.settings import color_schema

        self_col = self.select_series(column=column)

        if fig is None:
            fig = FigureWidget()
        fig.update_layout(**layout_kwargs)

        if close_trace_kwargs is None:
            close_trace_kwargs = {}
        if middle_trace_kwargs is None:
            middle_trace_kwargs = {}
        if upper_trace_kwargs is None:
            upper_trace_kwargs = {}
        if lower_trace_kwargs is None:
            lower_trace_kwargs = {}
        lower_trace_kwargs = merge_dicts(dict(
            name=&#39;Lower Band&#39;,
            line_color=color_schema[&#39;gray&#39;],
        ), lower_trace_kwargs)
        upper_trace_kwargs = merge_dicts(dict(
            name=&#39;Upper Band&#39;,
            line_color=color_schema[&#39;gray&#39;],
            fill=&#39;tonexty&#39;,
            fillcolor=&#39;rgba(128, 128, 128, 0.2)&#39;
        ), upper_trace_kwargs)  # default kwargs
        middle_trace_kwargs = merge_dicts(dict(
            name=&#39;Middle Band&#39;
        ), middle_trace_kwargs)
        close_trace_kwargs = merge_dicts(dict(
            name=&#39;Close&#39;,
            line=dict(color=color_schema[&#39;blue&#39;])
        ), close_trace_kwargs)

        fig = self_col.lower.vbt.plot(
            trace_kwargs=lower_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)
        fig = self_col.upper.vbt.plot(
            trace_kwargs=upper_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)
        fig = self_col.middle.vbt.plot(
            trace_kwargs=middle_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)
        if plot_close:
            fig = self_col.close.vbt.plot(
                trace_kwargs=close_trace_kwargs,
                add_trace_kwargs=add_trace_kwargs, fig=fig)

        return fig


setattr(BBANDS, &#39;__doc__&#39;, _BBANDS.__doc__)
setattr(BBANDS, &#39;plot&#39;, _BBANDS.plot)

# ############# RSI ############# #


RSI = IndicatorFactory(
    class_name=&#39;RSI&#39;,
    module_name=__name__,
    short_name=&#39;rsi&#39;,
    input_names=[&#39;close&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;rsi&#39;]
).from_apply_func(
    nb.rsi_apply_nb,
    cache_func=nb.rsi_cache_nb,
    kwargs_to_args=[&#39;adjust&#39;],
    window=14,
    ewm=False,
    adjust=False
)


class _RSI(RSI):
    &#34;&#34;&#34;Relative Strength Index (RSI).

    Compares the magnitude of recent gains and losses over a specified time
    period to measure speed and change of price movements of a security. It is
    primarily used to attempt to identify overbought or oversold conditions in
    the trading of an asset.

    See [Relative Strength Index (RSI)](https://www.investopedia.com/terms/r/rsi.asp).&#34;&#34;&#34;

    def plot(self,
             column=None,
             levels=(30, 70),
             rsi_trace_kwargs=None,
             add_trace_kwargs=None,
             xref=&#39;x&#39;, yref=&#39;y&#39;,
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `RSI.rsi`.

        Args:
            column (str): Name of the column to plot.
            levels (tuple): Two extremes: bottom and top.
            rsi_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `RSI.rsi`.
            add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.

        ## Example

        ```python-repl
        &gt;&gt;&gt; vbt.RSI.run(ohlcv[&#39;Close&#39;]).plot()
        ```

        ![](/vectorbt/docs/img/RSI.png)
        &#34;&#34;&#34;
        self_col = self.select_series(column=column)

        if fig is None:
            fig = FigureWidget()
        default_layout = dict()
        default_layout[&#39;yaxis&#39; + yref[1:]] = dict(range=[-5, 105])
        fig.update_layout(**default_layout)
        fig.update_layout(**layout_kwargs)

        if rsi_trace_kwargs is None:
            rsi_trace_kwargs = {}
        rsi_trace_kwargs = merge_dicts(dict(
            name=&#39;RSI&#39;
        ), rsi_trace_kwargs)

        fig = self_col.rsi.vbt.plot(
            trace_kwargs=rsi_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)

        # Fill void between levels
        fig.add_shape(
            type=&#34;rect&#34;,
            xref=xref,
            yref=yref,
            x0=self_col.rsi.index[0],
            y0=levels[0],
            x1=self_col.rsi.index[-1],
            y1=levels[1],
            fillcolor=&#34;purple&#34;,
            opacity=0.2,
            layer=&#34;below&#34;,
            line_width=0,
        )

        return fig


setattr(RSI, &#39;__doc__&#39;, _RSI.__doc__)
setattr(RSI, &#39;plot&#39;, _RSI.plot)

# ############# STOCH ############# #


STOCH = IndicatorFactory(
    class_name=&#39;STOCH&#39;,
    module_name=__name__,
    short_name=&#39;stoch&#39;,
    input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
    param_names=[&#39;k_window&#39;, &#39;d_window&#39;, &#39;d_ewm&#39;],
    output_names=[&#39;percent_k&#39;, &#39;percent_d&#39;]
).from_apply_func(
    nb.stoch_apply_nb,
    cache_func=nb.stoch_cache_nb,
    kwargs_to_args=[&#39;adjust&#39;],
    k_window=14,
    d_window=3,
    d_ewm=False,
    adjust=False
)


class _STOCH(STOCH):
    &#34;&#34;&#34;Stochastic Oscillator (STOCH).

    A stochastic oscillator is a momentum indicator comparing a particular closing price
    of a security to a range of its prices over a certain period of time. It is used to
    generate overbought and oversold trading signals, utilizing a 0-100 bounded range of values.

    See [Stochastic Oscillator](https://www.investopedia.com/terms/s/stochasticoscillator.asp).&#34;&#34;&#34;

    def plot(self,
             column=None,
             levels=(30, 70),
             percent_k_trace_kwargs=None,
             percent_d_trace_kwargs=None,
             shape_kwargs=None,
             add_trace_kwargs=None,
             xref=&#39;x&#39;, yref=&#39;y&#39;,
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `STOCH.percent_k` and `STOCH.percent_d`.

        Args:
            column (str): Name of the column to plot.
            levels (tuple): Two extremes: bottom and top.
            percent_k_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `STOCH.percent_k`.
            percent_d_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `STOCH.percent_d`.
            shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zone between levels.
            add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.

        ## Example

        ```python-repl
        &gt;&gt;&gt; vbt.STOCH.run(ohlcv[&#39;High&#39;], ohlcv[&#39;Low&#39;], ohlcv[&#39;Close&#39;]).plot()
        ```

        ![](/vectorbt/docs/img/STOCH.png)
        &#34;&#34;&#34;
        self_col = self.select_series(column=column)

        if fig is None:
            fig = FigureWidget()
        default_layout = dict()
        default_layout[&#39;yaxis&#39; + yref[1:]] = dict(range=[-5, 105])
        fig.update_layout(**default_layout)
        fig.update_layout(**layout_kwargs)

        if percent_k_trace_kwargs is None:
            percent_k_trace_kwargs = {}
        if percent_d_trace_kwargs is None:
            percent_d_trace_kwargs = {}
        if shape_kwargs is None:
            shape_kwargs = {}
        percent_k_trace_kwargs = merge_dicts(dict(
            name=&#39;%K&#39;
        ), percent_k_trace_kwargs)
        percent_d_trace_kwargs = merge_dicts(dict(
            name=&#39;%D&#39;
        ), percent_d_trace_kwargs)

        fig = self_col.percent_k.vbt.plot(
            trace_kwargs=percent_k_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)
        fig = self_col.percent_d.vbt.plot(
            trace_kwargs=percent_d_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)

        # Plot levels
        # Fill void between levels
        shape_kwargs = merge_dicts(dict(
            type=&#34;rect&#34;,
            xref=xref,
            yref=yref,
            x0=self_col.percent_k.index[0],
            y0=levels[0],
            x1=self_col.percent_k.index[-1],
            y1=levels[1],
            fillcolor=&#34;purple&#34;,
            opacity=0.2,
            layer=&#34;below&#34;,
            line_width=0,
        ), shape_kwargs)
        fig.add_shape(**shape_kwargs)

        return fig


setattr(STOCH, &#39;__doc__&#39;, _STOCH.__doc__)
setattr(STOCH, &#39;plot&#39;, _STOCH.plot)

# ############# MACD ############# #


MACD = IndicatorFactory(
    class_name=&#39;MACD&#39;,
    module_name=__name__,
    short_name=&#39;macd&#39;,
    input_names=[&#39;close&#39;],
    param_names=[&#39;fast_window&#39;, &#39;slow_window&#39;, &#39;signal_window&#39;, &#39;macd_ewm&#39;, &#39;signal_ewm&#39;],
    output_names=[&#39;macd&#39;, &#39;signal&#39;],
    custom_output_props=dict(
        hist=lambda self: self.wrapper.wrap(self.macd.values - self.signal.values),
    )
).from_apply_func(
    nb.macd_apply_nb,
    cache_func=nb.macd_cache_nb,
    kwargs_to_args=[&#39;adjust&#39;],
    fast_window=12,
    slow_window=26,
    signal_window=9,
    macd_ewm=False,
    signal_ewm=False,
    adjust=False
)


class _MACD(MACD):
    &#34;&#34;&#34;Moving Average Convergence Divergence (MACD).

    Is a trend-following momentum indicator that shows the relationship between
    two moving averages of prices.

    See [Moving Average Convergence Divergence – MACD](https://www.investopedia.com/terms/m/macd.asp).&#34;&#34;&#34;

    def plot(self,
             column=None,
             macd_trace_kwargs=None,
             signal_trace_kwargs=None,
             hist_trace_kwargs=None,
             add_trace_kwargs=None,
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `MACD.macd`, `MACD.signal` and `MACD.hist`.

        Args:
            column (str): Name of the column to plot.
            macd_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MACD.macd`.
            signal_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MACD.signal`.
            hist_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Bar` for `MACD.hist`.
            add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.

        ## Example

        ```python-repl
        &gt;&gt;&gt; vbt.MACD.run(ohlcv[&#39;Close&#39;]).plot()
        ```

        ![](/vectorbt/docs/img/MACD.png)&#34;&#34;&#34;
        self_col = self.select_series(column=column)

        if fig is None:
            fig = FigureWidget()
            fig.update_layout(bargap=0)
        fig.update_layout(**layout_kwargs)

        if macd_trace_kwargs is None:
            macd_trace_kwargs = {}
        if signal_trace_kwargs is None:
            signal_trace_kwargs = {}
        if hist_trace_kwargs is None:
            hist_trace_kwargs = {}
        macd_trace_kwargs = merge_dicts(dict(
            name=&#39;MACD&#39;
        ), macd_trace_kwargs)
        signal_trace_kwargs = merge_dicts(dict(
            name=&#39;Signal&#39;
        ), signal_trace_kwargs)
        hist_trace_kwargs = merge_dicts(dict(name=&#39;Histogram&#39;), hist_trace_kwargs)

        fig = self_col.macd.vbt.plot(
            trace_kwargs=macd_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)
        fig = self_col.signal.vbt.plot(
            trace_kwargs=signal_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)

        # Plot hist
        hist = self_col.hist.values
        hist_diff = generic_nb.diff_1d_nb(hist)
        marker_colors = np.full(hist.shape, &#39;silver&#39;, dtype=np.object)
        marker_colors[(hist &gt; 0) &amp; (hist_diff &gt; 0)] = &#39;green&#39;
        marker_colors[(hist &gt; 0) &amp; (hist_diff &lt;= 0)] = &#39;lightgreen&#39;
        marker_colors[(hist &lt; 0) &amp; (hist_diff &lt; 0)] = &#39;red&#39;
        marker_colors[(hist &lt; 0) &amp; (hist_diff &gt;= 0)] = &#39;lightcoral&#39;

        hist_bar = go.Bar(
            x=self_col.hist.index,
            y=self_col.hist.values,
            marker_color=marker_colors,
            marker_line_width=0
        )
        hist_bar.update(**hist_trace_kwargs)
        if add_trace_kwargs is None:
            add_trace_kwargs = {}
        fig.add_trace(hist_bar, **add_trace_kwargs)

        return fig


setattr(MACD, &#39;__doc__&#39;, _MACD.__doc__)
setattr(MACD, &#39;plot&#39;, _MACD.plot)

# ############# ATR ############# #


ATR = IndicatorFactory(
    class_name=&#39;ATR&#39;,
    module_name=__name__,
    short_name=&#39;atr&#39;,
    input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;tr&#39;, &#39;atr&#39;]
).from_apply_func(
    nb.atr_apply_nb,
    cache_func=nb.atr_cache_nb,
    kwargs_to_args=[&#39;adjust&#39;],
    window=14,
    ewm=True,
    adjust=False
)


class _ATR(ATR):
    &#34;&#34;&#34;Average True Range (ATR).

    The indicator provide an indication of the degree of price volatility.
    Strong moves, in either direction, are often accompanied by large ranges,
    or large True Ranges.

    See [Average True Range - ATR](https://www.investopedia.com/terms/a/atr.asp).

    !!! note
        Uses Simple MA and Exponential MA as compared to Wilder.
    &#34;&#34;&#34;

    def plot(self,
             column=None,
             tr_trace_kwargs=None,
             atr_trace_kwargs=None,
             add_trace_kwargs=None,
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `ATR.tr` and `ATR.atr`.

        Args:
            column (str): Name of the column to plot.
            tr_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `ATR.tr`.
            atr_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `ATR.atr`.
            add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.

        ## Example

        ```python-repl
        &gt;&gt;&gt; vbt.ATR.run(ohlcv[&#39;High&#39;], ohlcv[&#39;Low&#39;], ohlcv[&#39;Close&#39;], 10).plot()
        ```

        ![](/vectorbt/docs/img/ATR.png)
        &#34;&#34;&#34;
        self_col = self.select_series(column=column)

        if fig is None:
            fig = FigureWidget()
        fig.update_layout(**layout_kwargs)

        if tr_trace_kwargs is None:
            tr_trace_kwargs = {}
        if atr_trace_kwargs is None:
            atr_trace_kwargs = {}
        tr_trace_kwargs = merge_dicts(dict(
            name=&#39;TR&#39;
        ), tr_trace_kwargs)
        atr_trace_kwargs = merge_dicts(dict(
            name=&#39;ATR&#39;
        ), atr_trace_kwargs)

        fig = self_col.tr.vbt.plot(
            trace_kwargs=tr_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)
        fig = self_col.atr.vbt.plot(
            trace_kwargs=atr_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)

        return fig


setattr(ATR, &#39;__doc__&#39;, _ATR.__doc__)
setattr(ATR, &#39;plot&#39;, _ATR.plot)

# ############# OBV ############# #


OBV = IndicatorFactory(
    class_name=&#39;OBV&#39;,
    module_name=__name__,
    short_name=&#39;obv&#39;,
    input_names=[&#39;close&#39;, &#39;volume&#39;],
    param_names=[],
    output_names=[&#39;obv&#39;],
).from_custom_func(nb.obv_custom_nb)


class _OBV(OBV):
    &#34;&#34;&#34;On-balance volume (OBV).

    It relates price and volume in the stock market. OBV is based on a cumulative total volume.

    See [On-Balance Volume (OBV)](https://www.investopedia.com/terms/o/onbalancevolume.asp).&#34;&#34;&#34;

    def plot(self,
             column=None,
             obv_trace_kwargs=None,
             add_trace_kwargs=None,
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot `OBV.obv`.

        Args:
            column (str): Name of the column to plot.
            obv_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `OBV.obv`.
            add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.

        ## Example

        ```py
        &gt;&gt;&gt; vbt.OBV.run(ohlcv[&#39;Close&#39;], ohlcv[&#39;Volume&#39;]).plot()
        ```

        ![](/vectorbt/docs/img/OBV.png)
        &#34;&#34;&#34;
        self_col = self.select_series(column=column)

        if fig is None:
            fig = FigureWidget()
        fig.update_layout(**layout_kwargs)

        if obv_trace_kwargs is None:
            obv_trace_kwargs = {}
        obv_trace_kwargs = merge_dicts(dict(
            name=&#39;OBV&#39;
        ), obv_trace_kwargs)

        fig = self_col.obv.vbt.plot(
            trace_kwargs=obv_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)

        return fig


setattr(OBV, &#39;__doc__&#39;, _OBV.__doc__)
setattr(OBV, &#39;plot&#39;, _OBV.plot)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.indicators.basic.ATR"><code class="flex name class">
<span>class <span class="ident parent-fname">ATR</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Average True Range (ATR).</p>
<p>The indicator provide an indication of the degree of price volatility.
Strong moves, in either direction, are often accompanied by large ranges,
or large True Ranges.</p>
<p>See <a href="https://www.investopedia.com/terms/a/atr.asp">Average True Range - ATR</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Uses Simple MA and Exponential MA as compared to Wilder.</p>
</div></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.indicators.basic.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.indicators.basic._ATR</li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.ATR.in_output_names"><code class="name">var <span class="ident fname">in_output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.ATR.input_names"><code class="name">var <span class="ident fname">input_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.ATR.output_flags"><code class="name">var <span class="ident fname">output_flags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.ATR.output_names"><code class="name">var <span class="ident fname">output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.ATR.param_names"><code class="name">var <span class="ident fname">param_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.ATR.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>high, low, close, window=14, ewm=True, short_name='atr', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.indicators.basic.ATR" href="#vectorbt.indicators.basic.ATR">ATR</a></code> indicator.</p>
<ul>
<li>Inputs: <code>high</code>, <code>low</code>, <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code></li>
<li>Outputs: <code>tr</code>, <code>atr</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>high, low, close, window=14, ewm=True, r=2, param_product=False, comb_func=itertools.combinations, speedup=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.indicators.basic.ATR" href="#vectorbt.indicators.basic.ATR">ATR</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>high</code>, <code>low</code>, <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code></li>
<li>Outputs: <code>tr</code>, <code>atr</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>speedup</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.basic.ATR.run" href="#vectorbt.indicators.basic.ATR.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.ATR.atr"><code class="name">var <span class="ident fname">atr</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, _output_name=output_name):
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.ewm_array"><code class="name">var <span class="ident fname">ewm_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>ewm</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.high"><code class="name">var <span class="ident fname">high</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.low"><code class="name">var <span class="ident fname">low</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.tr"><code class="name">var <span class="ident fname">tr</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, _output_name=output_name):
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.window_array"><code class="name">var <span class="ident fname">window_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>window</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.ATR.apply_func"><code class="name flex">
<span>def <span class="ident fname">apply_func</span></span>(<span>high, low, close, window, ewm, adjust, tr, cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function for <code><a title="vectorbt.indicators.basic.ATR" href="#vectorbt.indicators.basic.ATR">ATR</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def atr_apply_nb(high, low, close, window, ewm, adjust, tr, cache_dict):
    &#34;&#34;&#34;Apply function for `vectorbt.indicators.basic.ATR`.&#34;&#34;&#34;
    h = hash((window, ewm))
    return tr, cache_dict[h]</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.atr_above"><code class="name flex">
<span>def <span class="ident fname">atr_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>atr</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>atr</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.atr_below"><code class="name flex">
<span>def <span class="ident fname">atr_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>atr</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>atr</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.atr_equal"><code class="name flex">
<span>def <span class="ident fname">atr_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>atr</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>atr</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.custom_func"><code class="name flex">
<span>def <span class="ident fname">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list, in_output_list, param_list, *args, input_shape=None,
                col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs):
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.high_above"><code class="name flex">
<span>def <span class="ident fname">high_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.high_below"><code class="name flex">
<span>def <span class="ident fname">high_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.high_equal"><code class="name flex">
<span>def <span class="ident fname">high_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.low_above"><code class="name flex">
<span>def <span class="ident fname">low_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.low_below"><code class="name flex">
<span>def <span class="ident fname">low_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.low_equal"><code class="name flex">
<span>def <span class="ident fname">low_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, column=None, tr_trace_kwargs=None, atr_trace_kwargs=None, add_trace_kwargs=None, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.ATR.tr" href="#vectorbt.indicators.basic.ATR.tr">ATR.tr</a></code> and <code><a title="vectorbt.indicators.basic.ATR.atr" href="#vectorbt.indicators.basic.ATR.atr">ATR.atr</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column to plot.</dd>
<dt><strong><code>tr_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.ATR.tr" href="#vectorbt.indicators.basic.ATR.tr">ATR.tr</a></code>.</dd>
<dt><strong><code>atr_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.ATR.atr" href="#vectorbt.indicators.basic.ATR.atr">ATR.atr</a></code>.</dd>
<dt><strong><code>add_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>add_trace</code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.ATR.run(ohlcv['High'], ohlcv['Low'], ohlcv['Close'], 10).plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/ATR.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         column=None,
         tr_trace_kwargs=None,
         atr_trace_kwargs=None,
         add_trace_kwargs=None,
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `ATR.tr` and `ATR.atr`.

    Args:
        column (str): Name of the column to plot.
        tr_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `ATR.tr`.
        atr_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `ATR.atr`.
        add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.

    ## Example

    ```python-repl
    &gt;&gt;&gt; vbt.ATR.run(ohlcv[&#39;High&#39;], ohlcv[&#39;Low&#39;], ohlcv[&#39;Close&#39;], 10).plot()
    ```

    ![](/vectorbt/docs/img/ATR.png)
    &#34;&#34;&#34;
    self_col = self.select_series(column=column)

    if fig is None:
        fig = FigureWidget()
    fig.update_layout(**layout_kwargs)

    if tr_trace_kwargs is None:
        tr_trace_kwargs = {}
    if atr_trace_kwargs is None:
        atr_trace_kwargs = {}
    tr_trace_kwargs = merge_dicts(dict(
        name=&#39;TR&#39;
    ), tr_trace_kwargs)
    atr_trace_kwargs = merge_dicts(dict(
        name=&#39;ATR&#39;
    ), atr_trace_kwargs)

    fig = self_col.tr.vbt.plot(
        trace_kwargs=tr_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs, fig=fig)
    fig = self_col.atr.vbt.plot(
        trace_kwargs=atr_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs, fig=fig)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.tr_above"><code class="name flex">
<span>def <span class="ident fname">tr_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>tr</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>tr</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.tr_below"><code class="name flex">
<span>def <span class="ident fname">tr_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>tr</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>tr</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.ATR.tr_equal"><code class="name flex">
<span>def <span class="ident fname">tr_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>tr</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>tr</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS"><code class="flex name class">
<span>class <span class="ident parent-fname">BBANDS</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Bollinger Bands (BBANDS).</p>
<p>A Bollinger Band® is a technical analysis tool defined by a set of lines plotted two standard
deviations (positively and negatively) away from a simple moving average (SMA) of the security's
price, but can be adjusted to user preferences.</p>
<p>See <a href="https://www.investopedia.com/terms/b/bollingerbands.asp">Bollinger Band®</a>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.indicators.basic.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.indicators.basic._BBANDS</li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.BBANDS.in_output_names"><code class="name">var <span class="ident fname">in_output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.input_names"><code class="name">var <span class="ident fname">input_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.output_flags"><code class="name">var <span class="ident fname">output_flags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.output_names"><code class="name">var <span class="ident fname">output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.param_names"><code class="name">var <span class="ident fname">param_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.BBANDS.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>close, window=20, ewm=False, alpha=2, short_name='bb', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.indicators.basic.BBANDS" href="#vectorbt.indicators.basic.BBANDS">BBANDS</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code>, <code>alpha</code></li>
<li>Outputs: <code>middle</code>, <code>upper</code>, <code>lower</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>close, window=20, ewm=False, alpha=2, r=2, param_product=False, comb_func=itertools.combinations, speedup=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.indicators.basic.BBANDS" href="#vectorbt.indicators.basic.BBANDS">BBANDS</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code>, <code>alpha</code></li>
<li>Outputs: <code>middle</code>, <code>upper</code>, <code>lower</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>speedup</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.basic.BBANDS.run" href="#vectorbt.indicators.basic.BBANDS.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.BBANDS.alpha_array"><code class="name">var <span class="ident fname">alpha_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>alpha</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.bandwidth"><code class="name">var <span class="ident fname">bandwidth</span></code></dt>
<dd>
<div class="desc"><p>Custom property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.ewm_array"><code class="name">var <span class="ident fname">ewm_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>ewm</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.lower"><code class="name">var <span class="ident fname">lower</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, _output_name=output_name):
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.middle"><code class="name">var <span class="ident fname">middle</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, _output_name=output_name):
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.percent_b"><code class="name">var <span class="ident fname">percent_b</span></code></dt>
<dd>
<div class="desc"><p>Custom property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.upper"><code class="name">var <span class="ident fname">upper</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, _output_name=output_name):
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.window_array"><code class="name">var <span class="ident fname">window_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>window</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.BBANDS.apply_func"><code class="name flex">
<span>def <span class="ident fname">apply_func</span></span>(<span>close, window, ewm, alpha, adjust, ddof, ma_cache_dict, mstd_cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function for <code><a title="vectorbt.indicators.basic.BBANDS" href="#vectorbt.indicators.basic.BBANDS">BBANDS</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def bb_apply_nb(close, window, ewm, alpha, adjust, ddof, ma_cache_dict, mstd_cache_dict):
    &#34;&#34;&#34;Apply function for `vectorbt.indicators.basic.BBANDS`.&#34;&#34;&#34;
    # Calculate lower, middle and upper bands
    h = hash((window, ewm))
    ma = np.copy(ma_cache_dict[h])
    mstd = np.copy(mstd_cache_dict[h])
    # # (MA + Kσ), MA, (MA - Kσ)
    return ma, ma + alpha * mstd, ma - alpha * mstd</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.bandwidth_above"><code class="name flex">
<span>def <span class="ident fname">bandwidth_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>bandwidth</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>bandwidth</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.bandwidth_below"><code class="name flex">
<span>def <span class="ident fname">bandwidth_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>bandwidth</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>bandwidth</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.bandwidth_equal"><code class="name flex">
<span>def <span class="ident fname">bandwidth_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>bandwidth</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>bandwidth</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.custom_func"><code class="name flex">
<span>def <span class="ident fname">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list, in_output_list, param_list, *args, input_shape=None,
                col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs):
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.lower_above"><code class="name flex">
<span>def <span class="ident fname">lower_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>lower</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>lower</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.lower_below"><code class="name flex">
<span>def <span class="ident fname">lower_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>lower</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>lower</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.lower_equal"><code class="name flex">
<span>def <span class="ident fname">lower_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>lower</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>lower</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.middle_above"><code class="name flex">
<span>def <span class="ident fname">middle_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>middle</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>middle</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.middle_below"><code class="name flex">
<span>def <span class="ident fname">middle_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>middle</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>middle</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.middle_equal"><code class="name flex">
<span>def <span class="ident fname">middle_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>middle</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>middle</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.percent_b_above"><code class="name flex">
<span>def <span class="ident fname">percent_b_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>percent_b</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_b</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.percent_b_below"><code class="name flex">
<span>def <span class="ident fname">percent_b_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>percent_b</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_b</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.percent_b_equal"><code class="name flex">
<span>def <span class="ident fname">percent_b_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>percent_b</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_b</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, column=None, plot_close=True, close_trace_kwargs=None, middle_trace_kwargs=None, upper_trace_kwargs=None, lower_trace_kwargs=None, add_trace_kwargs=None, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.BBANDS.middle" href="#vectorbt.indicators.basic.BBANDS.middle">BBANDS.middle</a></code>, <code><a title="vectorbt.indicators.basic.BBANDS.upper" href="#vectorbt.indicators.basic.BBANDS.upper">BBANDS.upper</a></code> and <code><a title="vectorbt.indicators.basic.BBANDS.lower" href="#vectorbt.indicators.basic.BBANDS.lower">BBANDS.lower</a></code> against
<code><a title="vectorbt.indicators.basic.BBANDS.close" href="#vectorbt.indicators.basic.BBANDS.close">BBANDS.close</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column to plot.</dd>
<dt><strong><code>plot_close</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to plot <code><a title="vectorbt.indicators.basic.MA.close" href="#vectorbt.indicators.basic.MA.close">MA.close</a></code>.</dd>
<dt><strong><code>close_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.BBANDS.close" href="#vectorbt.indicators.basic.BBANDS.close">BBANDS.close</a></code>.</dd>
<dt><strong><code>middle_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.BBANDS.middle" href="#vectorbt.indicators.basic.BBANDS.middle">BBANDS.middle</a></code>.</dd>
<dt><strong><code>upper_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.BBANDS.upper" href="#vectorbt.indicators.basic.BBANDS.upper">BBANDS.upper</a></code>.</dd>
<dt><strong><code>lower_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.BBANDS.lower" href="#vectorbt.indicators.basic.BBANDS.lower">BBANDS.lower</a></code>.</dd>
<dt><strong><code>add_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>add_trace</code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.BBANDS.run(ohlcv['Close']).plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/BBANDS.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         column=None,
         plot_close=True,
         close_trace_kwargs=None,
         middle_trace_kwargs=None,
         upper_trace_kwargs=None,
         lower_trace_kwargs=None,
         add_trace_kwargs=None,
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `BBANDS.middle`, `BBANDS.upper` and `BBANDS.lower` against
    `BBANDS.close`.

    Args:
        column (str): Name of the column to plot.
        plot_close (bool): Whether to plot `MA.close`.
        close_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BBANDS.close`.
        middle_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BBANDS.middle`.
        upper_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BBANDS.upper`.
        lower_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `BBANDS.lower`.
        add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.

    ## Example

    ```python-repl
    &gt;&gt;&gt; vbt.BBANDS.run(ohlcv[&#39;Close&#39;]).plot()
    ```

    ![](/vectorbt/docs/img/BBANDS.png)
    &#34;&#34;&#34;
    from vectorbt.settings import color_schema

    self_col = self.select_series(column=column)

    if fig is None:
        fig = FigureWidget()
    fig.update_layout(**layout_kwargs)

    if close_trace_kwargs is None:
        close_trace_kwargs = {}
    if middle_trace_kwargs is None:
        middle_trace_kwargs = {}
    if upper_trace_kwargs is None:
        upper_trace_kwargs = {}
    if lower_trace_kwargs is None:
        lower_trace_kwargs = {}
    lower_trace_kwargs = merge_dicts(dict(
        name=&#39;Lower Band&#39;,
        line_color=color_schema[&#39;gray&#39;],
    ), lower_trace_kwargs)
    upper_trace_kwargs = merge_dicts(dict(
        name=&#39;Upper Band&#39;,
        line_color=color_schema[&#39;gray&#39;],
        fill=&#39;tonexty&#39;,
        fillcolor=&#39;rgba(128, 128, 128, 0.2)&#39;
    ), upper_trace_kwargs)  # default kwargs
    middle_trace_kwargs = merge_dicts(dict(
        name=&#39;Middle Band&#39;
    ), middle_trace_kwargs)
    close_trace_kwargs = merge_dicts(dict(
        name=&#39;Close&#39;,
        line=dict(color=color_schema[&#39;blue&#39;])
    ), close_trace_kwargs)

    fig = self_col.lower.vbt.plot(
        trace_kwargs=lower_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs, fig=fig)
    fig = self_col.upper.vbt.plot(
        trace_kwargs=upper_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs, fig=fig)
    fig = self_col.middle.vbt.plot(
        trace_kwargs=middle_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs, fig=fig)
    if plot_close:
        fig = self_col.close.vbt.plot(
            trace_kwargs=close_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.upper_above"><code class="name flex">
<span>def <span class="ident fname">upper_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>upper</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>upper</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.upper_below"><code class="name flex">
<span>def <span class="ident fname">upper_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>upper</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>upper</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.BBANDS.upper_equal"><code class="name flex">
<span>def <span class="ident fname">upper_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>upper</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>upper</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.indicators.basic.MA"><code class="flex name class">
<span>class <span class="ident parent-fname">MA</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Moving Average (MA).</p>
<p>A moving average is a widely used indicator in technical analysis that helps smooth out
price action by filtering out the “noise” from random short-term price fluctuations. </p>
<p>See <a href="https://www.investopedia.com/terms/m/movingaverage.asp">Moving Average (MA)</a>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.indicators.basic.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.indicators.basic._MA</li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.MA.in_output_names"><code class="name">var <span class="ident fname">in_output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.MA.input_names"><code class="name">var <span class="ident fname">input_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.MA.output_flags"><code class="name">var <span class="ident fname">output_flags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.MA.output_names"><code class="name">var <span class="ident fname">output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.MA.param_names"><code class="name">var <span class="ident fname">param_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.MA.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>close, window, ewm=False, short_name='ma', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.indicators.basic.MA" href="#vectorbt.indicators.basic.MA">MA</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code></li>
<li>Outputs: <code>ma</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>close, window, ewm=False, r=2, param_product=False, comb_func=itertools.combinations, speedup=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.indicators.basic.MA" href="#vectorbt.indicators.basic.MA">MA</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code></li>
<li>Outputs: <code>ma</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>speedup</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.basic.MA.run" href="#vectorbt.indicators.basic.MA.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.MA.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.ewm_array"><code class="name">var <span class="ident fname">ewm_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>ewm</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.ma"><code class="name">var <span class="ident fname">ma</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, _output_name=output_name):
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.window_array"><code class="name">var <span class="ident fname">window_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>window</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.MA.apply_func"><code class="name flex">
<span>def <span class="ident fname">apply_func</span></span>(<span>close, window, ewm, adjust, cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function for <code><a title="vectorbt.indicators.basic.MA" href="#vectorbt.indicators.basic.MA">MA</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def ma_apply_nb(close, window, ewm, adjust, cache_dict):
    &#34;&#34;&#34;Apply function for `vectorbt.indicators.basic.MA`.&#34;&#34;&#34;
    h = hash((window, ewm))
    return cache_dict[h]</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.custom_func"><code class="name flex">
<span>def <span class="ident fname">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list, in_output_list, param_list, *args, input_shape=None,
                col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs):
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.ma_above"><code class="name flex">
<span>def <span class="ident fname">ma_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ma</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.ma_below"><code class="name flex">
<span>def <span class="ident fname">ma_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ma</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.ma_equal"><code class="name flex">
<span>def <span class="ident fname">ma_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ma</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MA.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, column=None, plot_close=True, close_trace_kwargs=None, ma_trace_kwargs=None, add_trace_kwargs=None, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.MA.ma" href="#vectorbt.indicators.basic.MA.ma">MA.ma</a></code> against <code><a title="vectorbt.indicators.basic.MA.close" href="#vectorbt.indicators.basic.MA.close">MA.close</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column to plot.</dd>
<dt><strong><code>plot_close</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to plot <code><a title="vectorbt.indicators.basic.MA.close" href="#vectorbt.indicators.basic.MA.close">MA.close</a></code>.</dd>
<dt><strong><code>close_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.MA.close" href="#vectorbt.indicators.basic.MA.close">MA.close</a></code>.</dd>
<dt><strong><code>ma_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.MA.ma" href="#vectorbt.indicators.basic.MA.ma">MA.ma</a></code>.</dd>
<dt><strong><code>add_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>add_trace</code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.MA.run(ohlcv['Close'], 10).plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/MA.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         column=None,
         plot_close=True,
         close_trace_kwargs=None,
         ma_trace_kwargs=None,
         add_trace_kwargs=None,
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `MA.ma` against `MA.close`.

    Args:
        column (str): Name of the column to plot.
        plot_close (bool): Whether to plot `MA.close`.
        close_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MA.close`.
        ma_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MA.ma`.
        add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.

    ## Example

    ```python-repl
    &gt;&gt;&gt; vbt.MA.run(ohlcv[&#39;Close&#39;], 10).plot()
    ```

    ![](/vectorbt/docs/img/MA.png)
    &#34;&#34;&#34;
    from vectorbt.settings import color_schema

    self_col = self.select_series(column=column)

    if fig is None:
        fig = FigureWidget()
    fig.update_layout(**layout_kwargs)

    if close_trace_kwargs is None:
        close_trace_kwargs = {}
    if ma_trace_kwargs is None:
        ma_trace_kwargs = {}
    close_trace_kwargs = merge_dicts(dict(
        name=&#39;Close&#39;,
        line_color=color_schema[&#39;blue&#39;]
    ), close_trace_kwargs)
    ma_trace_kwargs = merge_dicts(dict(
        name=&#39;MA&#39;
    ), ma_trace_kwargs)

    if plot_close:
        fig = self_col.close.vbt.plot(
            trace_kwargs=close_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs, fig=fig)
    fig = self_col.ma.vbt.plot(
        trace_kwargs=ma_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs, fig=fig)

    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.indicators.basic.MACD"><code class="flex name class">
<span>class <span class="ident parent-fname">MACD</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Moving Average Convergence Divergence (MACD).</p>
<p>Is a trend-following momentum indicator that shows the relationship between
two moving averages of prices.</p>
<p>See <a href="https://www.investopedia.com/terms/m/macd.asp">Moving Average Convergence Divergence – MACD</a>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.indicators.basic.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.indicators.basic._MACD</li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.MACD.in_output_names"><code class="name">var <span class="ident fname">in_output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.MACD.input_names"><code class="name">var <span class="ident fname">input_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.MACD.output_flags"><code class="name">var <span class="ident fname">output_flags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.MACD.output_names"><code class="name">var <span class="ident fname">output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.MACD.param_names"><code class="name">var <span class="ident fname">param_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.MACD.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>close, fast_window=12, slow_window=26, signal_window=9, macd_ewm=False, signal_ewm=False, short_name='macd', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.indicators.basic.MACD" href="#vectorbt.indicators.basic.MACD">MACD</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>fast_window</code>, <code>slow_window</code>, <code>signal_window</code>, <code>macd_ewm</code>, <code>signal_ewm</code></li>
<li>Outputs: <code>macd</code>, <code>signal</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>close, fast_window=12, slow_window=26, signal_window=9, macd_ewm=False, signal_ewm=False, r=2, param_product=False, comb_func=itertools.combinations, speedup=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.indicators.basic.MACD" href="#vectorbt.indicators.basic.MACD">MACD</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>fast_window</code>, <code>slow_window</code>, <code>signal_window</code>, <code>macd_ewm</code>, <code>signal_ewm</code></li>
<li>Outputs: <code>macd</code>, <code>signal</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>speedup</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.basic.MACD.run" href="#vectorbt.indicators.basic.MACD.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.MACD.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.fast_window_array"><code class="name">var <span class="ident fname">fast_window_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>fast_window</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.hist"><code class="name">var <span class="ident fname">hist</span></code></dt>
<dd>
<div class="desc"><p>Custom property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.macd"><code class="name">var <span class="ident fname">macd</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, _output_name=output_name):
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.macd_ewm_array"><code class="name">var <span class="ident fname">macd_ewm_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>macd_ewm</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.signal"><code class="name">var <span class="ident fname">signal</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, _output_name=output_name):
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.signal_ewm_array"><code class="name">var <span class="ident fname">signal_ewm_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>signal_ewm</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.signal_window_array"><code class="name">var <span class="ident fname">signal_window_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>signal_window</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.slow_window_array"><code class="name">var <span class="ident fname">slow_window_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>slow_window</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.MACD.apply_func"><code class="name flex">
<span>def <span class="ident fname">apply_func</span></span>(<span>close, fast_window, slow_window, signal_window, macd_ewm, signal_ewm, adjust, cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function for <code><a title="vectorbt.indicators.basic.MACD" href="#vectorbt.indicators.basic.MACD">MACD</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def macd_apply_nb(close, fast_window, slow_window, signal_window, macd_ewm, signal_ewm, adjust, cache_dict):
    &#34;&#34;&#34;Apply function for `vectorbt.indicators.basic.MACD`.&#34;&#34;&#34;
    fast_h = hash((fast_window, macd_ewm))
    slow_h = hash((slow_window, macd_ewm))
    fast_ma = cache_dict[fast_h]
    slow_ma = cache_dict[slow_h]
    macd_ts = fast_ma - slow_ma
    signal_ts = ma_nb(macd_ts, signal_window, signal_ewm, adjust=adjust)
    return macd_ts, signal_ts</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.custom_func"><code class="name flex">
<span>def <span class="ident fname">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list, in_output_list, param_list, *args, input_shape=None,
                col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs):
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.hist_above"><code class="name flex">
<span>def <span class="ident fname">hist_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hist</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hist</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.hist_below"><code class="name flex">
<span>def <span class="ident fname">hist_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hist</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hist</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.hist_equal"><code class="name flex">
<span>def <span class="ident fname">hist_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hist</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hist</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.macd_above"><code class="name flex">
<span>def <span class="ident fname">macd_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>macd</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>macd</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.macd_below"><code class="name flex">
<span>def <span class="ident fname">macd_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>macd</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>macd</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.macd_equal"><code class="name flex">
<span>def <span class="ident fname">macd_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>macd</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>macd</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, column=None, macd_trace_kwargs=None, signal_trace_kwargs=None, hist_trace_kwargs=None, add_trace_kwargs=None, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.MACD.macd" href="#vectorbt.indicators.basic.MACD.macd">MACD.macd</a></code>, <code><a title="vectorbt.indicators.basic.MACD.signal" href="#vectorbt.indicators.basic.MACD.signal">MACD.signal</a></code> and <code><a title="vectorbt.indicators.basic.MACD.hist" href="#vectorbt.indicators.basic.MACD.hist">MACD.hist</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column to plot.</dd>
<dt><strong><code>macd_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.MACD.macd" href="#vectorbt.indicators.basic.MACD.macd">MACD.macd</a></code>.</dd>
<dt><strong><code>signal_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.MACD.signal" href="#vectorbt.indicators.basic.MACD.signal">MACD.signal</a></code>.</dd>
<dt><strong><code>hist_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Bar</code> for <code><a title="vectorbt.indicators.basic.MACD.hist" href="#vectorbt.indicators.basic.MACD.hist">MACD.hist</a></code>.</dd>
<dt><strong><code>add_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>add_trace</code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.MACD.run(ohlcv['Close']).plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/MACD.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         column=None,
         macd_trace_kwargs=None,
         signal_trace_kwargs=None,
         hist_trace_kwargs=None,
         add_trace_kwargs=None,
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `MACD.macd`, `MACD.signal` and `MACD.hist`.

    Args:
        column (str): Name of the column to plot.
        macd_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MACD.macd`.
        signal_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MACD.signal`.
        hist_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Bar` for `MACD.hist`.
        add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.

    ## Example

    ```python-repl
    &gt;&gt;&gt; vbt.MACD.run(ohlcv[&#39;Close&#39;]).plot()
    ```

    ![](/vectorbt/docs/img/MACD.png)&#34;&#34;&#34;
    self_col = self.select_series(column=column)

    if fig is None:
        fig = FigureWidget()
        fig.update_layout(bargap=0)
    fig.update_layout(**layout_kwargs)

    if macd_trace_kwargs is None:
        macd_trace_kwargs = {}
    if signal_trace_kwargs is None:
        signal_trace_kwargs = {}
    if hist_trace_kwargs is None:
        hist_trace_kwargs = {}
    macd_trace_kwargs = merge_dicts(dict(
        name=&#39;MACD&#39;
    ), macd_trace_kwargs)
    signal_trace_kwargs = merge_dicts(dict(
        name=&#39;Signal&#39;
    ), signal_trace_kwargs)
    hist_trace_kwargs = merge_dicts(dict(name=&#39;Histogram&#39;), hist_trace_kwargs)

    fig = self_col.macd.vbt.plot(
        trace_kwargs=macd_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs, fig=fig)
    fig = self_col.signal.vbt.plot(
        trace_kwargs=signal_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs, fig=fig)

    # Plot hist
    hist = self_col.hist.values
    hist_diff = generic_nb.diff_1d_nb(hist)
    marker_colors = np.full(hist.shape, &#39;silver&#39;, dtype=np.object)
    marker_colors[(hist &gt; 0) &amp; (hist_diff &gt; 0)] = &#39;green&#39;
    marker_colors[(hist &gt; 0) &amp; (hist_diff &lt;= 0)] = &#39;lightgreen&#39;
    marker_colors[(hist &lt; 0) &amp; (hist_diff &lt; 0)] = &#39;red&#39;
    marker_colors[(hist &lt; 0) &amp; (hist_diff &gt;= 0)] = &#39;lightcoral&#39;

    hist_bar = go.Bar(
        x=self_col.hist.index,
        y=self_col.hist.values,
        marker_color=marker_colors,
        marker_line_width=0
    )
    hist_bar.update(**hist_trace_kwargs)
    if add_trace_kwargs is None:
        add_trace_kwargs = {}
    fig.add_trace(hist_bar, **add_trace_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.signal_above"><code class="name flex">
<span>def <span class="ident fname">signal_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>signal</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>signal</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.signal_below"><code class="name flex">
<span>def <span class="ident fname">signal_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>signal</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>signal</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MACD.signal_equal"><code class="name flex">
<span>def <span class="ident fname">signal_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>signal</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>signal</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.indicators.basic.MSTD"><code class="flex name class">
<span>class <span class="ident parent-fname">MSTD</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Moving Standard Deviation (MSTD).</p>
<p>Standard deviation is an indicator that measures the size of an assets recent price moves
in order to predict how volatile the price may be in the future.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.indicators.basic.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.indicators.basic._MSTD</li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.MSTD.in_output_names"><code class="name">var <span class="ident fname">in_output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.input_names"><code class="name">var <span class="ident fname">input_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.output_flags"><code class="name">var <span class="ident fname">output_flags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.output_names"><code class="name">var <span class="ident fname">output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.param_names"><code class="name">var <span class="ident fname">param_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.MSTD.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>close, window, ewm=False, short_name='mstd', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.indicators.basic.MSTD" href="#vectorbt.indicators.basic.MSTD">MSTD</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code></li>
<li>Outputs: <code>mstd</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>close, window, ewm=False, r=2, param_product=False, comb_func=itertools.combinations, speedup=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.indicators.basic.MSTD" href="#vectorbt.indicators.basic.MSTD">MSTD</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code></li>
<li>Outputs: <code>mstd</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>speedup</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.basic.MSTD.run" href="#vectorbt.indicators.basic.MSTD.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.MSTD.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.ewm_array"><code class="name">var <span class="ident fname">ewm_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>ewm</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.mstd"><code class="name">var <span class="ident fname">mstd</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, _output_name=output_name):
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.window_array"><code class="name">var <span class="ident fname">window_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>window</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.MSTD.apply_func"><code class="name flex">
<span>def <span class="ident fname">apply_func</span></span>(<span>close, window, ewm, adjust, ddof, cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function for <code><a title="vectorbt.indicators.basic.MSTD" href="#vectorbt.indicators.basic.MSTD">MSTD</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def mstd_apply_nb(close, window, ewm, adjust, ddof, cache_dict):
    &#34;&#34;&#34;Apply function for `vectorbt.indicators.basic.MSTD`.&#34;&#34;&#34;
    h = hash((window, ewm))
    return cache_dict[h]</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.custom_func"><code class="name flex">
<span>def <span class="ident fname">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list, in_output_list, param_list, *args, input_shape=None,
                col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs):
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.mstd_above"><code class="name flex">
<span>def <span class="ident fname">mstd_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>mstd</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>mstd</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.mstd_below"><code class="name flex">
<span>def <span class="ident fname">mstd_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>mstd</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>mstd</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.mstd_equal"><code class="name flex">
<span>def <span class="ident fname">mstd_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>mstd</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>mstd</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.MSTD.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, column=None, mstd_trace_kwargs=None, add_trace_kwargs=None, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.MSTD.mstd" href="#vectorbt.indicators.basic.MSTD.mstd">MSTD.mstd</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column to plot.</dd>
<dt><strong><code>mstd_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.MSTD.mstd" href="#vectorbt.indicators.basic.MSTD.mstd">MSTD.mstd</a></code>.</dd>
<dt><strong><code>add_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>add_trace</code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.MSTD.run(ohlcv['Close'], 10).plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/MSTD.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         column=None,
         mstd_trace_kwargs=None,
         add_trace_kwargs=None,
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `MSTD.mstd`.

    Args:
        column (str): Name of the column to plot.
        mstd_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `MSTD.mstd`.
        add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.

    ## Example

    ```python-repl
    &gt;&gt;&gt; vbt.MSTD.run(ohlcv[&#39;Close&#39;], 10).plot()
    ```

    ![](/vectorbt/docs/img/MSTD.png)
    &#34;&#34;&#34;
    self_col = self.select_series(column=column)

    if fig is None:
        fig = FigureWidget()
    fig.update_layout(**layout_kwargs)

    if mstd_trace_kwargs is None:
        mstd_trace_kwargs = {}
    mstd_trace_kwargs = merge_dicts(dict(
        name=&#39;MSTD&#39;
    ), mstd_trace_kwargs)

    fig = self_col.mstd.vbt.plot(
        trace_kwargs=mstd_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs, fig=fig)

    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.indicators.basic.OBV"><code class="flex name class">
<span>class <span class="ident parent-fname">OBV</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>On-balance volume (OBV).</p>
<p>It relates price and volume in the stock market. OBV is based on a cumulative total volume.</p>
<p>See <a href="https://www.investopedia.com/terms/o/onbalancevolume.asp">On-Balance Volume (OBV)</a>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.indicators.basic.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.indicators.basic._OBV</li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.OBV.in_output_names"><code class="name">var <span class="ident fname">in_output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.OBV.input_names"><code class="name">var <span class="ident fname">input_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.OBV.output_flags"><code class="name">var <span class="ident fname">output_flags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.OBV.output_names"><code class="name">var <span class="ident fname">output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.OBV.param_names"><code class="name">var <span class="ident fname">param_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.OBV.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>close, volume, short_name='obv', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.indicators.basic.OBV" href="#vectorbt.indicators.basic.OBV">OBV</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code>, <code>volume</code></li>
<li>Outputs: <code>obv</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.OBV.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.obv"><code class="name">var <span class="ident fname">obv</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, _output_name=output_name):
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.volume"><code class="name">var <span class="ident fname">volume</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.OBV.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.custom_func"><code class="name flex">
<span>def <span class="ident fname">custom_func</span></span>(<span>close, volume_ts)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom calculation function for <code><a title="vectorbt.indicators.basic.OBV" href="#vectorbt.indicators.basic.OBV">OBV</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def obv_custom_nb(close, volume_ts):
    &#34;&#34;&#34;Custom calculation function for `vectorbt.indicators.basic.OBV`.&#34;&#34;&#34;
    obv = generic_nb.set_by_mask_mult_nb(volume_ts, close &lt; generic_nb.fshift_nb(close, 1), -volume_ts)
    obv = generic_nb.cumsum_nb(obv)
    return obv</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.obv_above"><code class="name flex">
<span>def <span class="ident fname">obv_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>obv</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>obv</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.obv_below"><code class="name flex">
<span>def <span class="ident fname">obv_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>obv</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>obv</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.obv_equal"><code class="name flex">
<span>def <span class="ident fname">obv_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>obv</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>obv</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, column=None, obv_trace_kwargs=None, add_trace_kwargs=None, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.OBV.obv" href="#vectorbt.indicators.basic.OBV.obv">OBV.obv</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column to plot.</dd>
<dt><strong><code>obv_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.OBV.obv" href="#vectorbt.indicators.basic.OBV.obv">OBV.obv</a></code>.</dd>
<dt><strong><code>add_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>add_trace</code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-py">&gt;&gt;&gt; vbt.OBV.run(ohlcv['Close'], ohlcv['Volume']).plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/OBV.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         column=None,
         obv_trace_kwargs=None,
         add_trace_kwargs=None,
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `OBV.obv`.

    Args:
        column (str): Name of the column to plot.
        obv_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `OBV.obv`.
        add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.

    ## Example

    ```py
    &gt;&gt;&gt; vbt.OBV.run(ohlcv[&#39;Close&#39;], ohlcv[&#39;Volume&#39;]).plot()
    ```

    ![](/vectorbt/docs/img/OBV.png)
    &#34;&#34;&#34;
    self_col = self.select_series(column=column)

    if fig is None:
        fig = FigureWidget()
    fig.update_layout(**layout_kwargs)

    if obv_trace_kwargs is None:
        obv_trace_kwargs = {}
    obv_trace_kwargs = merge_dicts(dict(
        name=&#39;OBV&#39;
    ), obv_trace_kwargs)

    fig = self_col.obv.vbt.plot(
        trace_kwargs=obv_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs, fig=fig)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.volume_above"><code class="name flex">
<span>def <span class="ident fname">volume_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>volume</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>volume</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.volume_below"><code class="name flex">
<span>def <span class="ident fname">volume_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>volume</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>volume</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.OBV.volume_equal"><code class="name flex">
<span>def <span class="ident fname">volume_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>volume</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>volume</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.indicators.basic.RSI"><code class="flex name class">
<span>class <span class="ident parent-fname">RSI</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Relative Strength Index (RSI).</p>
<p>Compares the magnitude of recent gains and losses over a specified time
period to measure speed and change of price movements of a security. It is
primarily used to attempt to identify overbought or oversold conditions in
the trading of an asset.</p>
<p>See <a href="https://www.investopedia.com/terms/r/rsi.asp">Relative Strength Index (RSI)</a>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.indicators.basic.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.indicators.basic._RSI</li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.RSI.in_output_names"><code class="name">var <span class="ident fname">in_output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.RSI.input_names"><code class="name">var <span class="ident fname">input_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.RSI.output_flags"><code class="name">var <span class="ident fname">output_flags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.RSI.output_names"><code class="name">var <span class="ident fname">output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.RSI.param_names"><code class="name">var <span class="ident fname">param_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.RSI.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>close, window=14, ewm=False, short_name='rsi', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.indicators.basic.RSI" href="#vectorbt.indicators.basic.RSI">RSI</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code></li>
<li>Outputs: <code>rsi</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>close, window=14, ewm=False, r=2, param_product=False, comb_func=itertools.combinations, speedup=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.indicators.basic.RSI" href="#vectorbt.indicators.basic.RSI">RSI</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code></li>
<li>Outputs: <code>rsi</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>speedup</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.basic.RSI.run" href="#vectorbt.indicators.basic.RSI.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.RSI.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.ewm_array"><code class="name">var <span class="ident fname">ewm_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>ewm</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.rsi"><code class="name">var <span class="ident fname">rsi</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, _output_name=output_name):
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.window_array"><code class="name">var <span class="ident fname">window_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>window</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.RSI.apply_func"><code class="name flex">
<span>def <span class="ident fname">apply_func</span></span>(<span>close, window, ewm, adjust, cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function for <code><a title="vectorbt.indicators.basic.RSI" href="#vectorbt.indicators.basic.RSI">RSI</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def rsi_apply_nb(close, window, ewm, adjust, cache_dict):
    &#34;&#34;&#34;Apply function for `vectorbt.indicators.basic.RSI`.&#34;&#34;&#34;
    h = hash((window, ewm))
    roll_up, roll_down = cache_dict[h]
    rs = roll_up / roll_down
    return 100 - 100 / (1 + rs)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.custom_func"><code class="name flex">
<span>def <span class="ident fname">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list, in_output_list, param_list, *args, input_shape=None,
                col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs):
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, column=None, levels=(30, 70), rsi_trace_kwargs=None, add_trace_kwargs=None, xref='x', yref='y', fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.RSI.rsi" href="#vectorbt.indicators.basic.RSI.rsi">RSI.rsi</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column to plot.</dd>
<dt><strong><code>levels</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Two extremes: bottom and top.</dd>
<dt><strong><code>rsi_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.RSI.rsi" href="#vectorbt.indicators.basic.RSI.rsi">RSI.rsi</a></code>.</dd>
<dt><strong><code>add_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>add_trace</code>.</dd>
<dt><strong><code>xref</code></strong> :&ensp;<code>str</code></dt>
<dd>X coordinate axis.</dd>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.RSI.run(ohlcv['Close']).plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/RSI.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         column=None,
         levels=(30, 70),
         rsi_trace_kwargs=None,
         add_trace_kwargs=None,
         xref=&#39;x&#39;, yref=&#39;y&#39;,
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `RSI.rsi`.

    Args:
        column (str): Name of the column to plot.
        levels (tuple): Two extremes: bottom and top.
        rsi_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `RSI.rsi`.
        add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
        xref (str): X coordinate axis.
        yref (str): Y coordinate axis.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.

    ## Example

    ```python-repl
    &gt;&gt;&gt; vbt.RSI.run(ohlcv[&#39;Close&#39;]).plot()
    ```

    ![](/vectorbt/docs/img/RSI.png)
    &#34;&#34;&#34;
    self_col = self.select_series(column=column)

    if fig is None:
        fig = FigureWidget()
    default_layout = dict()
    default_layout[&#39;yaxis&#39; + yref[1:]] = dict(range=[-5, 105])
    fig.update_layout(**default_layout)
    fig.update_layout(**layout_kwargs)

    if rsi_trace_kwargs is None:
        rsi_trace_kwargs = {}
    rsi_trace_kwargs = merge_dicts(dict(
        name=&#39;RSI&#39;
    ), rsi_trace_kwargs)

    fig = self_col.rsi.vbt.plot(
        trace_kwargs=rsi_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs, fig=fig)

    # Fill void between levels
    fig.add_shape(
        type=&#34;rect&#34;,
        xref=xref,
        yref=yref,
        x0=self_col.rsi.index[0],
        y0=levels[0],
        x1=self_col.rsi.index[-1],
        y1=levels[1],
        fillcolor=&#34;purple&#34;,
        opacity=0.2,
        layer=&#34;below&#34;,
        line_width=0,
    )

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.rsi_above"><code class="name flex">
<span>def <span class="ident fname">rsi_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>rsi</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>rsi</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.rsi_below"><code class="name flex">
<span>def <span class="ident fname">rsi_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>rsi</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>rsi</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.RSI.rsi_equal"><code class="name flex">
<span>def <span class="ident fname">rsi_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>rsi</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>rsi</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.indicators.basic.STOCH"><code class="flex name class">
<span>class <span class="ident parent-fname">STOCH</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Stochastic Oscillator (STOCH).</p>
<p>A stochastic oscillator is a momentum indicator comparing a particular closing price
of a security to a range of its prices over a certain period of time. It is used to
generate overbought and oversold trading signals, utilizing a 0-100 bounded range of values.</p>
<p>See <a href="https://www.investopedia.com/terms/s/stochasticoscillator.asp">Stochastic Oscillator</a>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.indicators.basic.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.indicators.basic._STOCH</li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.STOCH.in_output_names"><code class="name">var <span class="ident fname">in_output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.input_names"><code class="name">var <span class="ident fname">input_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.output_flags"><code class="name">var <span class="ident fname">output_flags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.output_names"><code class="name">var <span class="ident fname">output_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.param_names"><code class="name">var <span class="ident fname">param_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.STOCH.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>high, low, close, k_window=14, d_window=3, d_ewm=False, short_name='stoch', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.indicators.basic.STOCH" href="#vectorbt.indicators.basic.STOCH">STOCH</a></code> indicator.</p>
<ul>
<li>Inputs: <code>high</code>, <code>low</code>, <code>close</code></li>
<li>Parameters: <code>k_window</code>, <code>d_window</code>, <code>d_ewm</code></li>
<li>Outputs: <code>percent_k</code>, <code>percent_d</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>high, low, close, k_window=14, d_window=3, d_ewm=False, r=2, param_product=False, comb_func=itertools.combinations, speedup=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.indicators.basic.STOCH" href="#vectorbt.indicators.basic.STOCH">STOCH</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>high</code>, <code>low</code>, <code>close</code></li>
<li>Parameters: <code>k_window</code>, <code>d_window</code>, <code>d_ewm</code></li>
<li>Outputs: <code>percent_k</code>, <code>percent_d</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>speedup</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.basic.STOCH.run" href="#vectorbt.indicators.basic.STOCH.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `speedup` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without speedup:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), speedup=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `speedup` is disabled by default.

Enable `speedup` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `speedup` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `speedup` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.png)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def params_to_list(params, is_tuple, is_array_like):
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    check_against = tuple(check_against)
    if isinstance(params, check_against):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.basic.STOCH.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.d_ewm_array"><code class="name">var <span class="ident fname">d_ewm_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>d_ewm</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.d_window_array"><code class="name">var <span class="ident fname">d_window_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>d_window</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.high"><code class="name">var <span class="ident fname">high</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.k_window_array"><code class="name">var <span class="ident fname">k_window_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>k_window</code> combinations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.low"><code class="name">var <span class="ident fname">low</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.percent_d"><code class="name">var <span class="ident fname">percent_d</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, _output_name=output_name):
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.percent_k"><code class="name">var <span class="ident fname">percent_k</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, _output_name=output_name):
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.indicators.basic.STOCH.apply_func"><code class="name flex">
<span>def <span class="ident fname">apply_func</span></span>(<span>high, low, close, k_window, d_window, d_ewm, adjust, cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function for <code><a title="vectorbt.indicators.basic.STOCH" href="#vectorbt.indicators.basic.STOCH">STOCH</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def stoch_apply_nb(high, low, close, k_window, d_window, d_ewm, adjust, cache_dict):
    &#34;&#34;&#34;Apply function for `vectorbt.indicators.basic.STOCH`.&#34;&#34;&#34;
    h = hash(k_window)
    roll_min, roll_max = cache_dict[h]
    percent_k = 100 * (close - roll_min) / (roll_max - roll_min)
    percent_d = ma_nb(percent_k, d_window, d_ewm, adjust=adjust)
    return percent_k, percent_d</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.custom_func"><code class="name flex">
<span>def <span class="ident fname">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list, in_output_list, param_list, *args, input_shape=None,
                col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs):
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.high_above"><code class="name flex">
<span>def <span class="ident fname">high_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.high_below"><code class="name flex">
<span>def <span class="ident fname">high_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.high_equal"><code class="name flex">
<span>def <span class="ident fname">high_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.low_above"><code class="name flex">
<span>def <span class="ident fname">low_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.low_below"><code class="name flex">
<span>def <span class="ident fname">low_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.low_equal"><code class="name flex">
<span>def <span class="ident fname">low_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.percent_d_above"><code class="name flex">
<span>def <span class="ident fname">percent_d_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>percent_d</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_d</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.percent_d_below"><code class="name flex">
<span>def <span class="ident fname">percent_d_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>percent_d</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_d</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.percent_d_equal"><code class="name flex">
<span>def <span class="ident fname">percent_d_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>percent_d</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_d</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.percent_k_above"><code class="name flex">
<span>def <span class="ident fname">percent_k_above</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>percent_k</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_k</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.percent_k_below"><code class="name flex">
<span>def <span class="ident fname">percent_k_below</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>percent_k</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_k</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.percent_k_equal"><code class="name flex">
<span>def <span class="ident fname">percent_k_equal</span></span>(<span>_self, other, crossover=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>percent_k</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_k</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossover=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.basic.STOCH.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, column=None, levels=(30, 70), percent_k_trace_kwargs=None, percent_d_trace_kwargs=None, shape_kwargs=None, add_trace_kwargs=None, xref='x', yref='y', fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.basic.STOCH.percent_k" href="#vectorbt.indicators.basic.STOCH.percent_k">STOCH.percent_k</a></code> and <code><a title="vectorbt.indicators.basic.STOCH.percent_d" href="#vectorbt.indicators.basic.STOCH.percent_d">STOCH.percent_d</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column to plot.</dd>
<dt><strong><code>levels</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Two extremes: bottom and top.</dd>
<dt><strong><code>percent_k_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.STOCH.percent_k" href="#vectorbt.indicators.basic.STOCH.percent_k">STOCH.percent_k</a></code>.</dd>
<dt><strong><code>percent_d_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.indicators.basic.STOCH.percent_d" href="#vectorbt.indicators.basic.STOCH.percent_d">STOCH.percent_d</a></code>.</dd>
<dt><strong><code>shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zone between levels.</dd>
<dt><strong><code>add_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>add_trace</code>.</dd>
<dt><strong><code>xref</code></strong> :&ensp;<code>str</code></dt>
<dd>X coordinate axis.</dd>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.STOCH.run(ohlcv['High'], ohlcv['Low'], ohlcv['Close']).plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/STOCH.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         column=None,
         levels=(30, 70),
         percent_k_trace_kwargs=None,
         percent_d_trace_kwargs=None,
         shape_kwargs=None,
         add_trace_kwargs=None,
         xref=&#39;x&#39;, yref=&#39;y&#39;,
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot `STOCH.percent_k` and `STOCH.percent_d`.

    Args:
        column (str): Name of the column to plot.
        levels (tuple): Two extremes: bottom and top.
        percent_k_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `STOCH.percent_k`.
        percent_d_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `STOCH.percent_d`.
        shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zone between levels.
        add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
        xref (str): X coordinate axis.
        yref (str): Y coordinate axis.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.

    ## Example

    ```python-repl
    &gt;&gt;&gt; vbt.STOCH.run(ohlcv[&#39;High&#39;], ohlcv[&#39;Low&#39;], ohlcv[&#39;Close&#39;]).plot()
    ```

    ![](/vectorbt/docs/img/STOCH.png)
    &#34;&#34;&#34;
    self_col = self.select_series(column=column)

    if fig is None:
        fig = FigureWidget()
    default_layout = dict()
    default_layout[&#39;yaxis&#39; + yref[1:]] = dict(range=[-5, 105])
    fig.update_layout(**default_layout)
    fig.update_layout(**layout_kwargs)

    if percent_k_trace_kwargs is None:
        percent_k_trace_kwargs = {}
    if percent_d_trace_kwargs is None:
        percent_d_trace_kwargs = {}
    if shape_kwargs is None:
        shape_kwargs = {}
    percent_k_trace_kwargs = merge_dicts(dict(
        name=&#39;%K&#39;
    ), percent_k_trace_kwargs)
    percent_d_trace_kwargs = merge_dicts(dict(
        name=&#39;%D&#39;
    ), percent_d_trace_kwargs)

    fig = self_col.percent_k.vbt.plot(
        trace_kwargs=percent_k_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs, fig=fig)
    fig = self_col.percent_d.vbt.plot(
        trace_kwargs=percent_d_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs, fig=fig)

    # Plot levels
    # Fill void between levels
    shape_kwargs = merge_dicts(dict(
        type=&#34;rect&#34;,
        xref=xref,
        yref=yref,
        x0=self_col.percent_k.index[0],
        y0=levels[0],
        x1=self_col.percent_k.index[-1],
        y1=levels[1],
        fillcolor=&#34;purple&#34;,
        opacity=0.2,
        layer=&#34;below&#34;,
        line_width=0,
    ), shape_kwargs)
    fig.add_shape(**shape_kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABmtJREFUeNrsnD1vFEkQhtve+fIuax9gDDIHQubDSMiQOEByjERGxg+4iL9DRI6A4IhAAkLIIeV0BwEICQJbwpbshRXegDbmkAW2p96erp7qpiqxg9mveWuq3nqme8aWrlw3Gu3FuJ4CFUAF0FABVAANFUAF0FABVAANFUAF0FABVAANFUAF0FABko/M7WULqysLq8v046uryLsfM2aKeuyHlerhs2PQl79x8e33/yaMOQm80H6Q/Tj68Z2s6GQ5iwCXl99fe/eK+j2Om/5Z5N2XjJmmHvvi5R/3n/ShL//X2Zff/ztvzDz1VeuD7ObtI8YM6B/U7RdcJWhufY1+8NiE1Ov/BJb+WHEf79Smfwo9YP0TdhEvHv0/dWzx6QIvvPPoT+iDiomelCY8fgh8wTRw7H9vDwRI/6fPp6Hqb9M/LypGAaAODAvAGfMHN7b+TGEyo+mfl1S1fjsbOlmMvjUx4CU2922rB3re2FhedgUJgDXhKezNnyOnxsbsgaHJMfd56+9TWPWvulYDRgEgC7RtQ5GrlzcbZntDcxpp8oPMNgBstiqQbuHwG3qjzXhLUN+WINB9Wg2A/Ckq24FjRhHgFYC6oPlLGxLcZyMBjn4eYJfkGcYeAKUnt/vM8hJKf0cBZoYDE2csnltjdZ+2/cJDUtSeEkpPtL6h7pOC3jw14U2gCWMWyMZh5BwtYwLMn9rgc5/04SuoDRVF4iZ7Iyb3SWcPSZUglMTNHhnS2y/U3lHzE04AGAQhLgj1oHQBoPqzxR6c0t9RAF4SxzkJ92klyPZeqL07mJ9EShAaxCYMuU8IvbUgANaEwR+Ckjii+4Tarx2+6OjNgwC8JK7LmAqLF9a8p3+T9usoQNQkjuI+oXu/KHoT3wM4SRylAcDus2p6zcICoCQOK0GcJI4yhUHus5MV450stAAoiZMzCdcOAaj7LJtV/+htKEriagWA2q/NfQf05qMJIyQOnsI4Sdz+UxjqPptX/xA2VNaClH2bMGR+nNFbUiUIJXEe609eeetsvALAHZiNxNWmP91QfUNv7Qkwt77K5UENI4nbvwFA6Q8t+9FJuN4CWfcJXUxN0JvsHsBJ4o7P7CnAA5A9eEx/WADeBSmcJK7fHe3lPiH/U/gYvtwFmBl+itQy7dWEA6M32SWIeU2cB/dZ+ucqmAC9zS/Q8XJI3K43AyD36bbsx7MAcxvY3Ri5u8Nc3CfLj4l1EoZI3K4NwFYwehGzpT/Ly8gEkEPidp3CsPT3bX4cBVj4uMIoQMApDLr16BG9pVOCIBL36xR29zFkfirGOsH31nJI3K9T2IOn1PRvuOzHtwuKk8T91IShRz74RW+N54Ak1qRA8CcrKtYvI6YHcJK4nVOYrV30bRcc7MFdgHhJnED36SJApCRuZwOA3OfWsh/m9JdUgthI3M4pDHKfJX/6YwJESuJ2TmF098mE3hoJECmJ+zGFQZt+WYev6CdhCET/mMLo7ZeVPQQSgJXEOSxIgTb9FkGqPyxApCRuO+jLnpvsuPtdShAUdgqDNv36WvTZsgCsJO7FP9jWMPqtR2701swFRUjithsAvf023HHHPAdESOLsFAa5z5DtV1IPAC/6f9+Qx+DuiJ7+AdCbuwCiSBz9dpi9AgD3Gbb9YgJESuIw9NbJ5ArAG2AHRjcnUaIMXv0xAUSROPhBWbVnwdOOO0YBElsTJ6H6xzoJw49JrD0FAdFbIAHkkDhSA6ravFqpAkRN4mrYQxGDAKkG97KfdgSAOzDSAlESV1N/ym67GUB2QawkrqWT4H3HHecckOJzmoqWhi9hPQAcgOgkbv9weNB2awLIely6p0dEtDh8wQLEuzt1zy4VatlPgjbUC4krKimohCQAL4mbBgVoTOL4dtxxCZAYiZNgfmItQc1JXLvoLYQAMAiaBI5tTuKCLfr0KQAviQtoRsIv+0nQBTVjDxOtswd2ASSTuLwSZw9oLigJEtfKsh9Pc0ASJE6U+xTTA0KRuDA77lgESIPElSLTnyRAAiRODnqL3oa6kThpwxcmAErisEGMn8RJYw+wACiJk7YmpZBa/eMrQQ4kzs69cshzCAHgMZiZxLW+7KfeNNYesVz17p2+QK8/xWvk84fAJGwbAOompaG3XVJ26cp1o6E9QAXQUAFUAA0VQAXQUAFUAA0VQAXQUAFUAA0VQAXQUAFUAA2++CrAAE3lth2zPPJAAAAAAElFTkSuQmCC"/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.indicators" href="index.html">vectorbt.indicators</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.indicators.basic.ATR" href="#vectorbt.indicators.basic.ATR">ATR</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.ATR.apply_func" href="#vectorbt.indicators.basic.ATR.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.atr" href="#vectorbt.indicators.basic.ATR.atr">atr</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.atr_above" href="#vectorbt.indicators.basic.ATR.atr_above">atr_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.atr_below" href="#vectorbt.indicators.basic.ATR.atr_below">atr_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.atr_equal" href="#vectorbt.indicators.basic.ATR.atr_equal">atr_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.close" href="#vectorbt.indicators.basic.ATR.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.close_above" href="#vectorbt.indicators.basic.ATR.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.close_below" href="#vectorbt.indicators.basic.ATR.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.close_equal" href="#vectorbt.indicators.basic.ATR.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.custom_func" href="#vectorbt.indicators.basic.ATR.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.ewm_array" href="#vectorbt.indicators.basic.ATR.ewm_array">ewm_array</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.high" href="#vectorbt.indicators.basic.ATR.high">high</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.high_above" href="#vectorbt.indicators.basic.ATR.high_above">high_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.high_below" href="#vectorbt.indicators.basic.ATR.high_below">high_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.high_equal" href="#vectorbt.indicators.basic.ATR.high_equal">high_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.in_output_names" href="#vectorbt.indicators.basic.ATR.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.input_names" href="#vectorbt.indicators.basic.ATR.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.level_names" href="#vectorbt.indicators.basic.ATR.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.low" href="#vectorbt.indicators.basic.ATR.low">low</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.low_above" href="#vectorbt.indicators.basic.ATR.low_above">low_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.low_below" href="#vectorbt.indicators.basic.ATR.low_below">low_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.low_equal" href="#vectorbt.indicators.basic.ATR.low_equal">low_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.output_flags" href="#vectorbt.indicators.basic.ATR.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.output_names" href="#vectorbt.indicators.basic.ATR.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.param_names" href="#vectorbt.indicators.basic.ATR.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.plot" href="#vectorbt.indicators.basic.ATR.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.run" href="#vectorbt.indicators.basic.ATR.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.run_combs" href="#vectorbt.indicators.basic.ATR.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.short_name" href="#vectorbt.indicators.basic.ATR.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.tr" href="#vectorbt.indicators.basic.ATR.tr">tr</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.tr_above" href="#vectorbt.indicators.basic.ATR.tr_above">tr_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.tr_below" href="#vectorbt.indicators.basic.ATR.tr_below">tr_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.tr_equal" href="#vectorbt.indicators.basic.ATR.tr_equal">tr_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.ATR.window_array" href="#vectorbt.indicators.basic.ATR.window_array">window_array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.basic.BBANDS" href="#vectorbt.indicators.basic.BBANDS">BBANDS</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.BBANDS.alpha_array" href="#vectorbt.indicators.basic.BBANDS.alpha_array">alpha_array</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.apply_func" href="#vectorbt.indicators.basic.BBANDS.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.bandwidth" href="#vectorbt.indicators.basic.BBANDS.bandwidth">bandwidth</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.bandwidth_above" href="#vectorbt.indicators.basic.BBANDS.bandwidth_above">bandwidth_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.bandwidth_below" href="#vectorbt.indicators.basic.BBANDS.bandwidth_below">bandwidth_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.bandwidth_equal" href="#vectorbt.indicators.basic.BBANDS.bandwidth_equal">bandwidth_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.close" href="#vectorbt.indicators.basic.BBANDS.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.close_above" href="#vectorbt.indicators.basic.BBANDS.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.close_below" href="#vectorbt.indicators.basic.BBANDS.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.close_equal" href="#vectorbt.indicators.basic.BBANDS.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.custom_func" href="#vectorbt.indicators.basic.BBANDS.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.ewm_array" href="#vectorbt.indicators.basic.BBANDS.ewm_array">ewm_array</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.in_output_names" href="#vectorbt.indicators.basic.BBANDS.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.input_names" href="#vectorbt.indicators.basic.BBANDS.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.level_names" href="#vectorbt.indicators.basic.BBANDS.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.lower" href="#vectorbt.indicators.basic.BBANDS.lower">lower</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.lower_above" href="#vectorbt.indicators.basic.BBANDS.lower_above">lower_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.lower_below" href="#vectorbt.indicators.basic.BBANDS.lower_below">lower_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.lower_equal" href="#vectorbt.indicators.basic.BBANDS.lower_equal">lower_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.middle" href="#vectorbt.indicators.basic.BBANDS.middle">middle</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.middle_above" href="#vectorbt.indicators.basic.BBANDS.middle_above">middle_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.middle_below" href="#vectorbt.indicators.basic.BBANDS.middle_below">middle_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.middle_equal" href="#vectorbt.indicators.basic.BBANDS.middle_equal">middle_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.output_flags" href="#vectorbt.indicators.basic.BBANDS.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.output_names" href="#vectorbt.indicators.basic.BBANDS.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.param_names" href="#vectorbt.indicators.basic.BBANDS.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.percent_b" href="#vectorbt.indicators.basic.BBANDS.percent_b">percent_b</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.percent_b_above" href="#vectorbt.indicators.basic.BBANDS.percent_b_above">percent_b_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.percent_b_below" href="#vectorbt.indicators.basic.BBANDS.percent_b_below">percent_b_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.percent_b_equal" href="#vectorbt.indicators.basic.BBANDS.percent_b_equal">percent_b_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.plot" href="#vectorbt.indicators.basic.BBANDS.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.run" href="#vectorbt.indicators.basic.BBANDS.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.run_combs" href="#vectorbt.indicators.basic.BBANDS.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.short_name" href="#vectorbt.indicators.basic.BBANDS.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.upper" href="#vectorbt.indicators.basic.BBANDS.upper">upper</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.upper_above" href="#vectorbt.indicators.basic.BBANDS.upper_above">upper_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.upper_below" href="#vectorbt.indicators.basic.BBANDS.upper_below">upper_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.upper_equal" href="#vectorbt.indicators.basic.BBANDS.upper_equal">upper_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.BBANDS.window_array" href="#vectorbt.indicators.basic.BBANDS.window_array">window_array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.basic.MA" href="#vectorbt.indicators.basic.MA">MA</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.MA.apply_func" href="#vectorbt.indicators.basic.MA.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.close" href="#vectorbt.indicators.basic.MA.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.close_above" href="#vectorbt.indicators.basic.MA.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.close_below" href="#vectorbt.indicators.basic.MA.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.close_equal" href="#vectorbt.indicators.basic.MA.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.custom_func" href="#vectorbt.indicators.basic.MA.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.ewm_array" href="#vectorbt.indicators.basic.MA.ewm_array">ewm_array</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.in_output_names" href="#vectorbt.indicators.basic.MA.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.input_names" href="#vectorbt.indicators.basic.MA.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.level_names" href="#vectorbt.indicators.basic.MA.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.ma" href="#vectorbt.indicators.basic.MA.ma">ma</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.ma_above" href="#vectorbt.indicators.basic.MA.ma_above">ma_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.ma_below" href="#vectorbt.indicators.basic.MA.ma_below">ma_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.ma_equal" href="#vectorbt.indicators.basic.MA.ma_equal">ma_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.output_flags" href="#vectorbt.indicators.basic.MA.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.output_names" href="#vectorbt.indicators.basic.MA.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.param_names" href="#vectorbt.indicators.basic.MA.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.plot" href="#vectorbt.indicators.basic.MA.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.run" href="#vectorbt.indicators.basic.MA.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.run_combs" href="#vectorbt.indicators.basic.MA.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.short_name" href="#vectorbt.indicators.basic.MA.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MA.window_array" href="#vectorbt.indicators.basic.MA.window_array">window_array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.basic.MACD" href="#vectorbt.indicators.basic.MACD">MACD</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.MACD.apply_func" href="#vectorbt.indicators.basic.MACD.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.close" href="#vectorbt.indicators.basic.MACD.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.close_above" href="#vectorbt.indicators.basic.MACD.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.close_below" href="#vectorbt.indicators.basic.MACD.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.close_equal" href="#vectorbt.indicators.basic.MACD.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.custom_func" href="#vectorbt.indicators.basic.MACD.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.fast_window_array" href="#vectorbt.indicators.basic.MACD.fast_window_array">fast_window_array</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.hist" href="#vectorbt.indicators.basic.MACD.hist">hist</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.hist_above" href="#vectorbt.indicators.basic.MACD.hist_above">hist_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.hist_below" href="#vectorbt.indicators.basic.MACD.hist_below">hist_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.hist_equal" href="#vectorbt.indicators.basic.MACD.hist_equal">hist_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.in_output_names" href="#vectorbt.indicators.basic.MACD.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.input_names" href="#vectorbt.indicators.basic.MACD.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.level_names" href="#vectorbt.indicators.basic.MACD.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.macd" href="#vectorbt.indicators.basic.MACD.macd">macd</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.macd_above" href="#vectorbt.indicators.basic.MACD.macd_above">macd_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.macd_below" href="#vectorbt.indicators.basic.MACD.macd_below">macd_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.macd_equal" href="#vectorbt.indicators.basic.MACD.macd_equal">macd_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.macd_ewm_array" href="#vectorbt.indicators.basic.MACD.macd_ewm_array">macd_ewm_array</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.output_flags" href="#vectorbt.indicators.basic.MACD.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.output_names" href="#vectorbt.indicators.basic.MACD.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.param_names" href="#vectorbt.indicators.basic.MACD.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.plot" href="#vectorbt.indicators.basic.MACD.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.run" href="#vectorbt.indicators.basic.MACD.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.run_combs" href="#vectorbt.indicators.basic.MACD.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.short_name" href="#vectorbt.indicators.basic.MACD.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.signal" href="#vectorbt.indicators.basic.MACD.signal">signal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.signal_above" href="#vectorbt.indicators.basic.MACD.signal_above">signal_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.signal_below" href="#vectorbt.indicators.basic.MACD.signal_below">signal_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.signal_equal" href="#vectorbt.indicators.basic.MACD.signal_equal">signal_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.signal_ewm_array" href="#vectorbt.indicators.basic.MACD.signal_ewm_array">signal_ewm_array</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.signal_window_array" href="#vectorbt.indicators.basic.MACD.signal_window_array">signal_window_array</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MACD.slow_window_array" href="#vectorbt.indicators.basic.MACD.slow_window_array">slow_window_array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.basic.MSTD" href="#vectorbt.indicators.basic.MSTD">MSTD</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.MSTD.apply_func" href="#vectorbt.indicators.basic.MSTD.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.close" href="#vectorbt.indicators.basic.MSTD.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.close_above" href="#vectorbt.indicators.basic.MSTD.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.close_below" href="#vectorbt.indicators.basic.MSTD.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.close_equal" href="#vectorbt.indicators.basic.MSTD.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.custom_func" href="#vectorbt.indicators.basic.MSTD.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.ewm_array" href="#vectorbt.indicators.basic.MSTD.ewm_array">ewm_array</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.in_output_names" href="#vectorbt.indicators.basic.MSTD.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.input_names" href="#vectorbt.indicators.basic.MSTD.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.level_names" href="#vectorbt.indicators.basic.MSTD.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.mstd" href="#vectorbt.indicators.basic.MSTD.mstd">mstd</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.mstd_above" href="#vectorbt.indicators.basic.MSTD.mstd_above">mstd_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.mstd_below" href="#vectorbt.indicators.basic.MSTD.mstd_below">mstd_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.mstd_equal" href="#vectorbt.indicators.basic.MSTD.mstd_equal">mstd_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.output_flags" href="#vectorbt.indicators.basic.MSTD.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.output_names" href="#vectorbt.indicators.basic.MSTD.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.param_names" href="#vectorbt.indicators.basic.MSTD.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.plot" href="#vectorbt.indicators.basic.MSTD.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.run" href="#vectorbt.indicators.basic.MSTD.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.run_combs" href="#vectorbt.indicators.basic.MSTD.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.short_name" href="#vectorbt.indicators.basic.MSTD.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.MSTD.window_array" href="#vectorbt.indicators.basic.MSTD.window_array">window_array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.basic.OBV" href="#vectorbt.indicators.basic.OBV">OBV</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.OBV.close" href="#vectorbt.indicators.basic.OBV.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.close_above" href="#vectorbt.indicators.basic.OBV.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.close_below" href="#vectorbt.indicators.basic.OBV.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.close_equal" href="#vectorbt.indicators.basic.OBV.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.custom_func" href="#vectorbt.indicators.basic.OBV.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.in_output_names" href="#vectorbt.indicators.basic.OBV.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.input_names" href="#vectorbt.indicators.basic.OBV.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.level_names" href="#vectorbt.indicators.basic.OBV.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.obv" href="#vectorbt.indicators.basic.OBV.obv">obv</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.obv_above" href="#vectorbt.indicators.basic.OBV.obv_above">obv_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.obv_below" href="#vectorbt.indicators.basic.OBV.obv_below">obv_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.obv_equal" href="#vectorbt.indicators.basic.OBV.obv_equal">obv_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.output_flags" href="#vectorbt.indicators.basic.OBV.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.output_names" href="#vectorbt.indicators.basic.OBV.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.param_names" href="#vectorbt.indicators.basic.OBV.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.plot" href="#vectorbt.indicators.basic.OBV.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.run" href="#vectorbt.indicators.basic.OBV.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.short_name" href="#vectorbt.indicators.basic.OBV.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.volume" href="#vectorbt.indicators.basic.OBV.volume">volume</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.volume_above" href="#vectorbt.indicators.basic.OBV.volume_above">volume_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.volume_below" href="#vectorbt.indicators.basic.OBV.volume_below">volume_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.OBV.volume_equal" href="#vectorbt.indicators.basic.OBV.volume_equal">volume_equal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.basic.RSI" href="#vectorbt.indicators.basic.RSI">RSI</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.RSI.apply_func" href="#vectorbt.indicators.basic.RSI.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.close" href="#vectorbt.indicators.basic.RSI.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.close_above" href="#vectorbt.indicators.basic.RSI.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.close_below" href="#vectorbt.indicators.basic.RSI.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.close_equal" href="#vectorbt.indicators.basic.RSI.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.custom_func" href="#vectorbt.indicators.basic.RSI.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.ewm_array" href="#vectorbt.indicators.basic.RSI.ewm_array">ewm_array</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.in_output_names" href="#vectorbt.indicators.basic.RSI.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.input_names" href="#vectorbt.indicators.basic.RSI.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.level_names" href="#vectorbt.indicators.basic.RSI.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.output_flags" href="#vectorbt.indicators.basic.RSI.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.output_names" href="#vectorbt.indicators.basic.RSI.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.param_names" href="#vectorbt.indicators.basic.RSI.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.plot" href="#vectorbt.indicators.basic.RSI.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.rsi" href="#vectorbt.indicators.basic.RSI.rsi">rsi</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.rsi_above" href="#vectorbt.indicators.basic.RSI.rsi_above">rsi_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.rsi_below" href="#vectorbt.indicators.basic.RSI.rsi_below">rsi_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.rsi_equal" href="#vectorbt.indicators.basic.RSI.rsi_equal">rsi_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.run" href="#vectorbt.indicators.basic.RSI.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.run_combs" href="#vectorbt.indicators.basic.RSI.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.short_name" href="#vectorbt.indicators.basic.RSI.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.basic.RSI.window_array" href="#vectorbt.indicators.basic.RSI.window_array">window_array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.basic.STOCH" href="#vectorbt.indicators.basic.STOCH">STOCH</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.basic.STOCH.apply_func" href="#vectorbt.indicators.basic.STOCH.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.close" href="#vectorbt.indicators.basic.STOCH.close">close</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.close_above" href="#vectorbt.indicators.basic.STOCH.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.close_below" href="#vectorbt.indicators.basic.STOCH.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.close_equal" href="#vectorbt.indicators.basic.STOCH.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.custom_func" href="#vectorbt.indicators.basic.STOCH.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.d_ewm_array" href="#vectorbt.indicators.basic.STOCH.d_ewm_array">d_ewm_array</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.d_window_array" href="#vectorbt.indicators.basic.STOCH.d_window_array">d_window_array</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.high" href="#vectorbt.indicators.basic.STOCH.high">high</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.high_above" href="#vectorbt.indicators.basic.STOCH.high_above">high_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.high_below" href="#vectorbt.indicators.basic.STOCH.high_below">high_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.high_equal" href="#vectorbt.indicators.basic.STOCH.high_equal">high_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.in_output_names" href="#vectorbt.indicators.basic.STOCH.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.input_names" href="#vectorbt.indicators.basic.STOCH.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.k_window_array" href="#vectorbt.indicators.basic.STOCH.k_window_array">k_window_array</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.level_names" href="#vectorbt.indicators.basic.STOCH.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.low" href="#vectorbt.indicators.basic.STOCH.low">low</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.low_above" href="#vectorbt.indicators.basic.STOCH.low_above">low_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.low_below" href="#vectorbt.indicators.basic.STOCH.low_below">low_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.low_equal" href="#vectorbt.indicators.basic.STOCH.low_equal">low_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.output_flags" href="#vectorbt.indicators.basic.STOCH.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.output_names" href="#vectorbt.indicators.basic.STOCH.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.param_names" href="#vectorbt.indicators.basic.STOCH.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.percent_d" href="#vectorbt.indicators.basic.STOCH.percent_d">percent_d</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.percent_d_above" href="#vectorbt.indicators.basic.STOCH.percent_d_above">percent_d_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.percent_d_below" href="#vectorbt.indicators.basic.STOCH.percent_d_below">percent_d_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.percent_d_equal" href="#vectorbt.indicators.basic.STOCH.percent_d_equal">percent_d_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.percent_k" href="#vectorbt.indicators.basic.STOCH.percent_k">percent_k</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.percent_k_above" href="#vectorbt.indicators.basic.STOCH.percent_k_above">percent_k_above</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.percent_k_below" href="#vectorbt.indicators.basic.STOCH.percent_k_below">percent_k_below</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.percent_k_equal" href="#vectorbt.indicators.basic.STOCH.percent_k_equal">percent_k_equal</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.plot" href="#vectorbt.indicators.basic.STOCH.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.run" href="#vectorbt.indicators.basic.STOCH.run">run</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.run_combs" href="#vectorbt.indicators.basic.STOCH.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.indicators.basic.STOCH.short_name" href="#vectorbt.indicators.basic.STOCH.short_name">short_name</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>