<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.indicators.ma API documentation</title>
<meta name="description" content="A moving average (MA) is a widely used indicator in technical analysis that helps smooth out
price action by filtering out the “noise” from random …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.indicators.ma</code></h1>
</header>
<section id="section-intro">
<p>A moving average (MA) is a widely used indicator in technical analysis that helps smooth out
price action by filtering out the “noise” from random short-term price fluctuations. </p>
<p>See <a href="https://www.investopedia.com/terms/m/movingaverage.asp">Moving Average (MA)</a>.</p>
<p>Use <code><a title="vectorbt.indicators.ma.MA.from_params" href="#vectorbt.indicators.ma.MA.from_params">MA.from_params()</a></code> or <code><a title="vectorbt.indicators.ma.MA.from_combinations" href="#vectorbt.indicators.ma.MA.from_combinations">MA.from_combinations()</a></code> methods to run the indicator.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A moving average (MA) is a widely used indicator in technical analysis that helps smooth out 
price action by filtering out the “noise” from random short-term price fluctuations. 

See [Moving Average (MA)](https://www.investopedia.com/terms/m/movingaverage.asp).

Use `MA.from_params` or `MA.from_combinations` methods to run the indicator.&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.types import UniTuple, f8, i8, b1, DictType
import itertools

from vectorbt import timeseries, indicators
from vectorbt.utils import checks, common, reshape_fns


@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], b1[:]), cache=True)
def ma_caching_nb(ts, windows, ewms):
    &#34;&#34;&#34;Numba-compiled caching function for `MA`.&#34;&#34;&#34;
    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                ma = timeseries.nb.ewm_mean_nb(ts, windows[i])
            else:
                ma = timeseries.nb.rolling_mean_nb(ts, windows[i])
            cache_dict[(windows[i], int(ewms[i]))] = ma
    return cache_dict


@njit(f8[:, :](f8[:, :], i8, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def ma_apply_func_nb(ts, window, ewm, cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `MA`.&#34;&#34;&#34;
    return cache_dict[(window, int(ewm))]


MA = indicators.factory.IndicatorFactory(
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;ma&#39;],
    name=&#39;ma&#39;
).from_apply_func(ma_apply_func_nb, caching_func=ma_caching_nb)


class MA(MA):
    @classmethod
    def from_params(cls, ts, window, ewm=False, **kwargs):
        &#34;&#34;&#34;Calculate moving average `MA.ma` from time series `ts` and parameters `window` and `ewm`.

        Args:
            ts (pandas_like): Time series (such as price).
            window (int or array_like): Size of the moving window. Can be one or more values.
            ewm (bool or array_like): If True, uses exponential moving average, otherwise 
                simple moving average. Can be one or more values. Defaults to False.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            MA
        Examples:
            ```python-repl
            &gt;&gt;&gt; ma = vbt.MA.from_params(price[&#39;Close&#39;], [10, 20], ewm=[False, True])

            &gt;&gt;&gt; print(ma.ma)
            ma_window          10            20
            ma_ewm          False          True
            Date                               
            2019-02-28        NaN           NaN
            2019-03-01        NaN           NaN
            2019-03-02        NaN           NaN
            ...               ...           ...
            2019-08-29  10155.972  10330.457140
            2019-08-30  10039.466  10260.715507
            2019-08-31   9988.727  10200.710220

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        return super().from_params(ts, window, ewm, **kwargs)

    @classmethod
    def from_combinations(cls, ts, windows, r, ewm=False, names=None, **kwargs):
        &#34;&#34;&#34;Create multiple `MA` combinations according to `itertools.combinations`.

        Args:
            ts (pandas_like): Time series (such as price).
            windows (array_like of int): Size of the moving window. Must be multiple.
            r (int): The number of `MA` instances to combine.
            ewm (bool or array_like of bool): If True, uses exponential moving average, otherwise 
                uses simple moving average. Can be one or more values. Defaults to False.
            names (list of str, optional): A list of names for each `MA` instance.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            tuple of MA
        Examples:
            ```python-repl
            &gt;&gt;&gt; fast_ma, slow_ma = vbt.MA.from_combinations(price[&#39;Close&#39;], 
            ...     [10, 20, 30], 2, ewm=[False, False, True], names=[&#39;fast&#39;, &#39;slow&#39;])

            &gt;&gt;&gt; print(fast_ma.ma)
            fast_window         10         10          20
            fast_ewm         False      False       False
            Date                                         
            2019-02-28         NaN        NaN         NaN
            2019-03-01         NaN        NaN         NaN
            2019-03-02         NaN        NaN         NaN
            ...                ...        ...         ...
            2019-08-29   10155.972  10155.972  10447.3480
            2019-08-30   10039.466  10039.466  10359.5555
            2019-08-31    9988.727   9988.727  10264.9095

            [185 rows x 3 columns]

            &gt;&gt;&gt; print(slow_ma.ma)
            slow_window          20            30            30
            slow_ewm          False          True          True
            Date                                               
            2019-02-28          NaN           NaN           NaN
            2019-03-01          NaN           NaN           NaN
            2019-03-02          NaN           NaN           NaN
            ...                 ...           ...           ...
            2019-08-29   10447.3480  10423.585970  10423.585970
            2019-08-30   10359.5555  10370.333077  10370.333077
            2019-08-31   10264.9095  10322.612024  10322.612024

            [185 rows x 3 columns]

            ```

            The naive way without caching is the follows:
            ```py
            window_combs = itertools.combinations([10, 20, 30], 2)
            ewm_combs = itertools.combinations([False, False, True], 2)
            fast_windows, slow_windows = np.asarray(list(window_combs)).transpose()
            fast_ewms, slow_ewms = np.asarray(list(ewm_combs)).transpose()

            fast_ma = vbt.MA.from_params(price[&#39;Close&#39;], 
            ...     fast_windows, fast_ewms, name=&#39;fast&#39;)
            slow_ma = vbt.MA.from_params(price[&#39;Close&#39;], 
            ...     slow_windows, slow_ewms, name=&#39;slow&#39;)
            ```

            Having this, you can now compare these `MA` instances:
            ```python-repl
            &gt;&gt;&gt; entry_signals = fast_ma.ma_above(slow_ma, crossover=True)
            &gt;&gt;&gt; exit_signals = fast_ma.ma_below(slow_ma, crossover=True)

            &gt;&gt;&gt; print(entry_signals)
            fast_window     10     10     20
            fast_ewm     False  False  False
            slow_window     20     30     30
            slow_ewm     False  True    True
            Date                            
            2019-02-28   False  False  False
            2019-03-01   False  False  False
            2019-03-02   False  False  False
            ...            ...    ...    ...
            2019-08-29   False  False  False
            2019-08-30   False  False  False
            2019-08-31   False  False  False

            [185 rows x 3 columns]
            ```

            Notice how `MA.ma_above` method created a new column hierarchy for you. You can now use
            it for indexing as follows:

            ```py
            fig = price[&#39;Close&#39;].vbt.timeseries.plot(name=&#39;Price&#39;)
            fig = entry_signals[(10, False, 20, False)]\\
                .vbt.signals.plot_markers(price[&#39;Close&#39;], signal_type=&#39;entry&#39;, fig=fig)
            fig = exit_signals[(10, False, 20, False)]\\
                .vbt.signals.plot_markers(price[&#39;Close&#39;], signal_type=&#39;exit&#39;, fig=fig)

            fig.show()
            ```
            ![](img/MA_from_combinations.png)
        &#34;&#34;&#34;

        if names is None:
            names = [&#39;ma&#39; + str(i+1) for i in range(r)]
        windows, ewm = reshape_fns.broadcast(windows, ewm, writeable=True)
        cache_dict = cls.from_params(ts, windows, ewm=ewm, return_cache=True, **kwargs)
        param_lists = zip(*itertools.combinations(zip(windows, ewm), r))
        mas = []
        for i, param_list in enumerate(param_lists):
            i_windows, i_ewm = zip(*param_list)
            mas.append(cls.from_params(ts, i_windows, ewm=i_ewm, cache=cache_dict, name=names[i], **kwargs))
        return tuple(mas)

    def plot(self,
             ts_trace_kwargs={},
             ma_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `MA.ma` against `MA.ts`.

        Args:
            ts_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MA.ts`.
            ma_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MA.ma`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.FigureWidget
        Examples:
            ```py
            ma[(10, False)].plot()
            ```

            ![](img/MA.png)&#34;&#34;&#34;
        checks.assert_type(self.ts, pd.Series)
        checks.assert_type(self.ma, pd.Series)

        ts_trace_kwargs = {**dict(
            name=f&#39;Price ({self.name})&#39;
        ), **ts_trace_kwargs}
        ma_trace_kwargs = {**dict(
            name=f&#39;MA ({self.name})&#39;
        ), **ma_trace_kwargs}

        fig = self.ts.vbt.timeseries.plot(trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.ma.vbt.timeseries.plot(trace_kwargs=ma_trace_kwargs, fig=fig, **layout_kwargs)

        return fig


common.fix_class_for_pdoc(MA)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.indicators.ma.ma_apply_func_nb"><code class="name flex">
<span>def <span class="ident">ma_apply_func_nb</span></span>(<span>ts, window, ewm, cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled apply function for <code><a title="vectorbt.indicators.ma.MA" href="#vectorbt.indicators.ma.MA">MA</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(f8[:, :](f8[:, :], i8, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def ma_apply_func_nb(ts, window, ewm, cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `MA`.&#34;&#34;&#34;
    return cache_dict[(window, int(ewm))]</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.ma_caching_nb"><code class="name flex">
<span>def <span class="ident">ma_caching_nb</span></span>(<span>ts, windows, ewms)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled caching function for <code><a title="vectorbt.indicators.ma.MA" href="#vectorbt.indicators.ma.MA">MA</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], b1[:]), cache=True)
def ma_caching_nb(ts, windows, ewms):
    &#34;&#34;&#34;Numba-compiled caching function for `MA`.&#34;&#34;&#34;
    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                ma = timeseries.nb.ewm_mean_nb(ts, windows[i])
            else:
                ma = timeseries.nb.rolling_mean_nb(ts, windows[i])
            cache_dict[(windows[i], int(ewms[i]))] = ma
    return cache_dict</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.indicators.ma.MA"><code class="flex name class">
<span>class <span class="ident">MA</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MA(MA):
    @classmethod
    def from_params(cls, ts, window, ewm=False, **kwargs):
        &#34;&#34;&#34;Calculate moving average `MA.ma` from time series `ts` and parameters `window` and `ewm`.

        Args:
            ts (pandas_like): Time series (such as price).
            window (int or array_like): Size of the moving window. Can be one or more values.
            ewm (bool or array_like): If True, uses exponential moving average, otherwise 
                simple moving average. Can be one or more values. Defaults to False.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            MA
        Examples:
            ```python-repl
            &gt;&gt;&gt; ma = vbt.MA.from_params(price[&#39;Close&#39;], [10, 20], ewm=[False, True])

            &gt;&gt;&gt; print(ma.ma)
            ma_window          10            20
            ma_ewm          False          True
            Date                               
            2019-02-28        NaN           NaN
            2019-03-01        NaN           NaN
            2019-03-02        NaN           NaN
            ...               ...           ...
            2019-08-29  10155.972  10330.457140
            2019-08-30  10039.466  10260.715507
            2019-08-31   9988.727  10200.710220

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        return super().from_params(ts, window, ewm, **kwargs)

    @classmethod
    def from_combinations(cls, ts, windows, r, ewm=False, names=None, **kwargs):
        &#34;&#34;&#34;Create multiple `MA` combinations according to `itertools.combinations`.

        Args:
            ts (pandas_like): Time series (such as price).
            windows (array_like of int): Size of the moving window. Must be multiple.
            r (int): The number of `MA` instances to combine.
            ewm (bool or array_like of bool): If True, uses exponential moving average, otherwise 
                uses simple moving average. Can be one or more values. Defaults to False.
            names (list of str, optional): A list of names for each `MA` instance.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            tuple of MA
        Examples:
            ```python-repl
            &gt;&gt;&gt; fast_ma, slow_ma = vbt.MA.from_combinations(price[&#39;Close&#39;], 
            ...     [10, 20, 30], 2, ewm=[False, False, True], names=[&#39;fast&#39;, &#39;slow&#39;])

            &gt;&gt;&gt; print(fast_ma.ma)
            fast_window         10         10          20
            fast_ewm         False      False       False
            Date                                         
            2019-02-28         NaN        NaN         NaN
            2019-03-01         NaN        NaN         NaN
            2019-03-02         NaN        NaN         NaN
            ...                ...        ...         ...
            2019-08-29   10155.972  10155.972  10447.3480
            2019-08-30   10039.466  10039.466  10359.5555
            2019-08-31    9988.727   9988.727  10264.9095

            [185 rows x 3 columns]

            &gt;&gt;&gt; print(slow_ma.ma)
            slow_window          20            30            30
            slow_ewm          False          True          True
            Date                                               
            2019-02-28          NaN           NaN           NaN
            2019-03-01          NaN           NaN           NaN
            2019-03-02          NaN           NaN           NaN
            ...                 ...           ...           ...
            2019-08-29   10447.3480  10423.585970  10423.585970
            2019-08-30   10359.5555  10370.333077  10370.333077
            2019-08-31   10264.9095  10322.612024  10322.612024

            [185 rows x 3 columns]

            ```

            The naive way without caching is the follows:
            ```py
            window_combs = itertools.combinations([10, 20, 30], 2)
            ewm_combs = itertools.combinations([False, False, True], 2)
            fast_windows, slow_windows = np.asarray(list(window_combs)).transpose()
            fast_ewms, slow_ewms = np.asarray(list(ewm_combs)).transpose()

            fast_ma = vbt.MA.from_params(price[&#39;Close&#39;], 
            ...     fast_windows, fast_ewms, name=&#39;fast&#39;)
            slow_ma = vbt.MA.from_params(price[&#39;Close&#39;], 
            ...     slow_windows, slow_ewms, name=&#39;slow&#39;)
            ```

            Having this, you can now compare these `MA` instances:
            ```python-repl
            &gt;&gt;&gt; entry_signals = fast_ma.ma_above(slow_ma, crossover=True)
            &gt;&gt;&gt; exit_signals = fast_ma.ma_below(slow_ma, crossover=True)

            &gt;&gt;&gt; print(entry_signals)
            fast_window     10     10     20
            fast_ewm     False  False  False
            slow_window     20     30     30
            slow_ewm     False  True    True
            Date                            
            2019-02-28   False  False  False
            2019-03-01   False  False  False
            2019-03-02   False  False  False
            ...            ...    ...    ...
            2019-08-29   False  False  False
            2019-08-30   False  False  False
            2019-08-31   False  False  False

            [185 rows x 3 columns]
            ```

            Notice how `MA.ma_above` method created a new column hierarchy for you. You can now use
            it for indexing as follows:

            ```py
            fig = price[&#39;Close&#39;].vbt.timeseries.plot(name=&#39;Price&#39;)
            fig = entry_signals[(10, False, 20, False)]\\
                .vbt.signals.plot_markers(price[&#39;Close&#39;], signal_type=&#39;entry&#39;, fig=fig)
            fig = exit_signals[(10, False, 20, False)]\\
                .vbt.signals.plot_markers(price[&#39;Close&#39;], signal_type=&#39;exit&#39;, fig=fig)

            fig.show()
            ```
            ![](img/MA_from_combinations.png)
        &#34;&#34;&#34;

        if names is None:
            names = [&#39;ma&#39; + str(i+1) for i in range(r)]
        windows, ewm = reshape_fns.broadcast(windows, ewm, writeable=True)
        cache_dict = cls.from_params(ts, windows, ewm=ewm, return_cache=True, **kwargs)
        param_lists = zip(*itertools.combinations(zip(windows, ewm), r))
        mas = []
        for i, param_list in enumerate(param_lists):
            i_windows, i_ewm = zip(*param_list)
            mas.append(cls.from_params(ts, i_windows, ewm=i_ewm, cache=cache_dict, name=names[i], **kwargs))
        return tuple(mas)

    def plot(self,
             ts_trace_kwargs={},
             ma_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `MA.ma` against `MA.ts`.

        Args:
            ts_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MA.ts`.
            ma_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MA.ma`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.FigureWidget
        Examples:
            ```py
            ma[(10, False)].plot()
            ```

            ![](img/MA.png)&#34;&#34;&#34;
        checks.assert_type(self.ts, pd.Series)
        checks.assert_type(self.ma, pd.Series)

        ts_trace_kwargs = {**dict(
            name=f&#39;Price ({self.name})&#39;
        ), **ts_trace_kwargs}
        ma_trace_kwargs = {**dict(
            name=f&#39;MA ({self.name})&#39;
        ), **ma_trace_kwargs}

        fig = self.ts.vbt.timeseries.plot(trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.ma.vbt.timeseries.plot(trace_kwargs=ma_trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.factory.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.ma.MA.from_combinations"><code class="name flex">
<span>def <span class="ident">from_combinations</span></span>(<span>ts, windows, r, ewm=False, names=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create multiple <code><a title="vectorbt.indicators.ma.MA" href="#vectorbt.indicators.ma.MA">MA</a></code> combinations according to <code>itertools.combinations</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Time series (such as price).</dd>
<dt><strong><code>windows</code></strong> :&ensp;<code>array_like</code> of <code>int</code></dt>
<dd>Size of the moving window. Must be multiple.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of <code><a title="vectorbt.indicators.ma.MA" href="#vectorbt.indicators.ma.MA">MA</a></code> instances to combine.</dd>
<dt><strong><code>ewm</code></strong> :&ensp;<code>bool</code> or <code>array_like</code> of <code>bool</code></dt>
<dd>If True, uses exponential moving average, otherwise
uses simple moving average. Can be one or more values. Defaults to False.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>A list of names for each <code><a title="vectorbt.indicators.ma.MA" href="#vectorbt.indicators.ma.MA">MA</a></code> instance.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.indicators.factory.from_params_pipeline" href="factory.html#vectorbt.indicators.factory.from_params_pipeline">from_params_pipeline()</a>.</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code><a title="vectorbt.indicators.ma.MA" href="#vectorbt.indicators.ma.MA">MA</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; fast_ma, slow_ma = vbt.MA.from_combinations(price['Close'], 
...     [10, 20, 30], 2, ewm=[False, False, True], names=['fast', 'slow'])

&gt;&gt;&gt; print(fast_ma.ma)
fast_window         10         10          20
fast_ewm         False      False       False
Date                                         
2019-02-28         NaN        NaN         NaN
2019-03-01         NaN        NaN         NaN
2019-03-02         NaN        NaN         NaN
...                ...        ...         ...
2019-08-29   10155.972  10155.972  10447.3480
2019-08-30   10039.466  10039.466  10359.5555
2019-08-31    9988.727   9988.727  10264.9095

[185 rows x 3 columns]

&gt;&gt;&gt; print(slow_ma.ma)
slow_window          20            30            30
slow_ewm          False          True          True
Date                                               
2019-02-28          NaN           NaN           NaN
2019-03-01          NaN           NaN           NaN
2019-03-02          NaN           NaN           NaN
...                 ...           ...           ...
2019-08-29   10447.3480  10423.585970  10423.585970
2019-08-30   10359.5555  10370.333077  10370.333077
2019-08-31   10264.9095  10322.612024  10322.612024

[185 rows x 3 columns]

</code></pre>
<p>The naive way without caching is the follows:</p>
<pre><code class="py">window_combs = itertools.combinations([10, 20, 30], 2)
ewm_combs = itertools.combinations([False, False, True], 2)
fast_windows, slow_windows = np.asarray(list(window_combs)).transpose()
fast_ewms, slow_ewms = np.asarray(list(ewm_combs)).transpose()

fast_ma = vbt.MA.from_params(price['Close'], 
...     fast_windows, fast_ewms, name='fast')
slow_ma = vbt.MA.from_params(price['Close'], 
...     slow_windows, slow_ewms, name='slow')
</code></pre>
<p>Having this, you can now compare these <code><a title="vectorbt.indicators.ma.MA" href="#vectorbt.indicators.ma.MA">MA</a></code> instances:</p>
<pre><code class="python-repl">&gt;&gt;&gt; entry_signals = fast_ma.ma_above(slow_ma, crossover=True)
&gt;&gt;&gt; exit_signals = fast_ma.ma_below(slow_ma, crossover=True)

&gt;&gt;&gt; print(entry_signals)
fast_window     10     10     20
fast_ewm     False  False  False
slow_window     20     30     30
slow_ewm     False  True    True
Date                            
2019-02-28   False  False  False
2019-03-01   False  False  False
2019-03-02   False  False  False
...            ...    ...    ...
2019-08-29   False  False  False
2019-08-30   False  False  False
2019-08-31   False  False  False

[185 rows x 3 columns]
</code></pre>
<p>Notice how <code><a title="vectorbt.indicators.ma.MA.ma_above" href="#vectorbt.indicators.ma.MA.ma_above">CustomIndicator.ma_above()</a></code> method created a new column hierarchy for you. You can now use
it for indexing as follows:</p>
<pre><code class="py">fig = price['Close'].vbt.timeseries.plot(name='Price')
fig = entry_signals[(10, False, 20, False)]\
    .vbt.signals.plot_markers(price['Close'], signal_type='entry', fig=fig)
fig = exit_signals[(10, False, 20, False)]\
    .vbt.signals.plot_markers(price['Close'], signal_type='exit', fig=fig)

fig.show()
</code></pre>
<p><img alt="" src="img/MA_from_combinations.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_combinations(cls, ts, windows, r, ewm=False, names=None, **kwargs):
    &#34;&#34;&#34;Create multiple `MA` combinations according to `itertools.combinations`.

    Args:
        ts (pandas_like): Time series (such as price).
        windows (array_like of int): Size of the moving window. Must be multiple.
        r (int): The number of `MA` instances to combine.
        ewm (bool or array_like of bool): If True, uses exponential moving average, otherwise 
            uses simple moving average. Can be one or more values. Defaults to False.
        names (list of str, optional): A list of names for each `MA` instance.
        **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
    Returns:
        tuple of MA
    Examples:
        ```python-repl
        &gt;&gt;&gt; fast_ma, slow_ma = vbt.MA.from_combinations(price[&#39;Close&#39;], 
        ...     [10, 20, 30], 2, ewm=[False, False, True], names=[&#39;fast&#39;, &#39;slow&#39;])

        &gt;&gt;&gt; print(fast_ma.ma)
        fast_window         10         10          20
        fast_ewm         False      False       False
        Date                                         
        2019-02-28         NaN        NaN         NaN
        2019-03-01         NaN        NaN         NaN
        2019-03-02         NaN        NaN         NaN
        ...                ...        ...         ...
        2019-08-29   10155.972  10155.972  10447.3480
        2019-08-30   10039.466  10039.466  10359.5555
        2019-08-31    9988.727   9988.727  10264.9095

        [185 rows x 3 columns]

        &gt;&gt;&gt; print(slow_ma.ma)
        slow_window          20            30            30
        slow_ewm          False          True          True
        Date                                               
        2019-02-28          NaN           NaN           NaN
        2019-03-01          NaN           NaN           NaN
        2019-03-02          NaN           NaN           NaN
        ...                 ...           ...           ...
        2019-08-29   10447.3480  10423.585970  10423.585970
        2019-08-30   10359.5555  10370.333077  10370.333077
        2019-08-31   10264.9095  10322.612024  10322.612024

        [185 rows x 3 columns]

        ```

        The naive way without caching is the follows:
        ```py
        window_combs = itertools.combinations([10, 20, 30], 2)
        ewm_combs = itertools.combinations([False, False, True], 2)
        fast_windows, slow_windows = np.asarray(list(window_combs)).transpose()
        fast_ewms, slow_ewms = np.asarray(list(ewm_combs)).transpose()

        fast_ma = vbt.MA.from_params(price[&#39;Close&#39;], 
        ...     fast_windows, fast_ewms, name=&#39;fast&#39;)
        slow_ma = vbt.MA.from_params(price[&#39;Close&#39;], 
        ...     slow_windows, slow_ewms, name=&#39;slow&#39;)
        ```

        Having this, you can now compare these `MA` instances:
        ```python-repl
        &gt;&gt;&gt; entry_signals = fast_ma.ma_above(slow_ma, crossover=True)
        &gt;&gt;&gt; exit_signals = fast_ma.ma_below(slow_ma, crossover=True)

        &gt;&gt;&gt; print(entry_signals)
        fast_window     10     10     20
        fast_ewm     False  False  False
        slow_window     20     30     30
        slow_ewm     False  True    True
        Date                            
        2019-02-28   False  False  False
        2019-03-01   False  False  False
        2019-03-02   False  False  False
        ...            ...    ...    ...
        2019-08-29   False  False  False
        2019-08-30   False  False  False
        2019-08-31   False  False  False

        [185 rows x 3 columns]
        ```

        Notice how `MA.ma_above` method created a new column hierarchy for you. You can now use
        it for indexing as follows:

        ```py
        fig = price[&#39;Close&#39;].vbt.timeseries.plot(name=&#39;Price&#39;)
        fig = entry_signals[(10, False, 20, False)]\\
            .vbt.signals.plot_markers(price[&#39;Close&#39;], signal_type=&#39;entry&#39;, fig=fig)
        fig = exit_signals[(10, False, 20, False)]\\
            .vbt.signals.plot_markers(price[&#39;Close&#39;], signal_type=&#39;exit&#39;, fig=fig)

        fig.show()
        ```
        ![](img/MA_from_combinations.png)
    &#34;&#34;&#34;

    if names is None:
        names = [&#39;ma&#39; + str(i+1) for i in range(r)]
    windows, ewm = reshape_fns.broadcast(windows, ewm, writeable=True)
    cache_dict = cls.from_params(ts, windows, ewm=ewm, return_cache=True, **kwargs)
    param_lists = zip(*itertools.combinations(zip(windows, ewm), r))
    mas = []
    for i, param_list in enumerate(param_lists):
        i_windows, i_ewm = zip(*param_list)
        mas.append(cls.from_params(ts, i_windows, ewm=i_ewm, cache=cache_dict, name=names[i], **kwargs))
    return tuple(mas)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, window, ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate moving average <code><a title="vectorbt.indicators.ma.MA.ma" href="#vectorbt.indicators.ma.MA.ma">MA.ma</a></code> from time series <code>ts</code> and parameters <code>window</code> and <code>ewm</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Time series (such as price).</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Size of the moving window. Can be one or more values.</dd>
<dt><strong><code>ewm</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>If True, uses exponential moving average, otherwise
simple moving average. Can be one or more values. Defaults to False.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.indicators.factory.from_params_pipeline" href="factory.html#vectorbt.indicators.factory.from_params_pipeline">from_params_pipeline()</a>.</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.indicators.ma.MA" href="#vectorbt.indicators.ma.MA">MA</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; ma = vbt.MA.from_params(price['Close'], [10, 20], ewm=[False, True])

&gt;&gt;&gt; print(ma.ma)
ma_window          10            20
ma_ewm          False          True
Date                               
2019-02-28        NaN           NaN
2019-03-01        NaN           NaN
2019-03-02        NaN           NaN
...               ...           ...
2019-08-29  10155.972  10330.457140
2019-08-30  10039.466  10260.715507
2019-08-31   9988.727  10200.710220

[185 rows x 2 columns]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, window, ewm=False, **kwargs):
    &#34;&#34;&#34;Calculate moving average `MA.ma` from time series `ts` and parameters `window` and `ewm`.

    Args:
        ts (pandas_like): Time series (such as price).
        window (int or array_like): Size of the moving window. Can be one or more values.
        ewm (bool or array_like): If True, uses exponential moving average, otherwise 
            simple moving average. Can be one or more values. Defaults to False.
        **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
    Returns:
        MA
    Examples:
        ```python-repl
        &gt;&gt;&gt; ma = vbt.MA.from_params(price[&#39;Close&#39;], [10, 20], ewm=[False, True])

        &gt;&gt;&gt; print(ma.ma)
        ma_window          10            20
        ma_ewm          False          True
        Date                               
        2019-02-28        NaN           NaN
        2019-03-01        NaN           NaN
        2019-03-02        NaN           NaN
        ...               ...           ...
        2019-08-29  10155.972  10330.457140
        2019-08-30  10039.466  10260.715507
        2019-08-31   9988.727  10200.710220

        [185 rows x 2 columns]
        ```
    &#34;&#34;&#34;
    return super().from_params(ts, window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.ma.MA.ewm_loc"><code class="name">var <span class="ident">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.ma"><code class="name">var <span class="ident">ma</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.ts"><code class="name">var <span class="ident">ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.tuple_loc"><code class="name">var <span class="ident">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter tuple using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.window_loc"><code class="name">var <span class="ident">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.ma.MA.ma_above"><code class="name flex">
<span>def <span class="ident">ma_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ma</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.ma_below"><code class="name flex">
<span>def <span class="ident">ma_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ma</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.ma_equal"><code class="name flex">
<span>def <span class="ident">ma_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ma</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, ts_trace_kwargs={}, ma_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.ma.MA.ma" href="#vectorbt.indicators.ma.MA.ma">MA.ma</a></code> against <code><a title="vectorbt.indicators.ma.MA.ts" href="#vectorbt.indicators.ma.MA.ts">MA.ts</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of <code><a title="vectorbt.indicators.ma.MA.ts" href="#vectorbt.indicators.ma.MA.ts">MA.ts</a></code>.</dd>
<dt><strong><code>ma_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of <code><a title="vectorbt.indicators.ma.MA.ma" href="#vectorbt.indicators.ma.MA.ma">MA.ma</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code>, optional</dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.widgets.FigureWidget" href="../widgets.html#vectorbt.widgets.FigureWidget">FigureWidget</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="py">ma[(10, False)].plot()
</code></pre>
<p><img alt="" src="img/MA.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         ts_trace_kwargs={},
         ma_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    &#34;&#34;&#34;Plot `MA.ma` against `MA.ts`.

    Args:
        ts_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MA.ts`.
        ma_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MA.ma`.
        fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Returns:
        vectorbt.widgets.FigureWidget
    Examples:
        ```py
        ma[(10, False)].plot()
        ```

        ![](img/MA.png)&#34;&#34;&#34;
    checks.assert_type(self.ts, pd.Series)
    checks.assert_type(self.ma, pd.Series)

    ts_trace_kwargs = {**dict(
        name=f&#39;Price ({self.name})&#39;
    ), **ts_trace_kwargs}
    ma_trace_kwargs = {**dict(
        name=f&#39;MA ({self.name})&#39;
    ), **ma_trace_kwargs}

    fig = self.ts.vbt.timeseries.plot(trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.ma.vbt.timeseries.plot(trace_kwargs=ma_trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.ts_above"><code class="name flex">
<span>def <span class="ident">ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.ts_below"><code class="name flex">
<span>def <span class="ident">ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.ts_equal"><code class="name flex">
<span>def <span class="ident">ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.ma.MA.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.indicators" href="index.html">vectorbt.indicators</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.indicators.ma.ma_apply_func_nb" href="#vectorbt.indicators.ma.ma_apply_func_nb">ma_apply_func_nb</a></code></li>
<li><code><a title="vectorbt.indicators.ma.ma_caching_nb" href="#vectorbt.indicators.ma.ma_caching_nb">ma_caching_nb</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.indicators.ma.MA" href="#vectorbt.indicators.ma.MA">MA</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.ma.MA.ewm_loc" href="#vectorbt.indicators.ma.MA.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.from_combinations" href="#vectorbt.indicators.ma.MA.from_combinations">from_combinations</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.from_params" href="#vectorbt.indicators.ma.MA.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.iloc" href="#vectorbt.indicators.ma.MA.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.loc" href="#vectorbt.indicators.ma.MA.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.ma" href="#vectorbt.indicators.ma.MA.ma">ma</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.ma_above" href="#vectorbt.indicators.ma.MA.ma_above">ma_above</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.ma_below" href="#vectorbt.indicators.ma.MA.ma_below">ma_below</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.ma_equal" href="#vectorbt.indicators.ma.MA.ma_equal">ma_equal</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.name" href="#vectorbt.indicators.ma.MA.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.plot" href="#vectorbt.indicators.ma.MA.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.ts" href="#vectorbt.indicators.ma.MA.ts">ts</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.ts_above" href="#vectorbt.indicators.ma.MA.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.ts_below" href="#vectorbt.indicators.ma.MA.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.ts_equal" href="#vectorbt.indicators.ma.MA.ts_equal">ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.tuple_loc" href="#vectorbt.indicators.ma.MA.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.window_loc" href="#vectorbt.indicators.ma.MA.window_loc">window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.ma.MA.xs" href="#vectorbt.indicators.ma.MA.xs">xs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>