<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.indicators.indicators API documentation</title>
<meta name="description" content="A collection of custom indicators built with `vectorbt.indicators.factory.IndicatorFactory` …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.indicators.indicators</code></h1>
</header>
<section id="section-intro">
<p>A collection of custom indicators built with <code><a title="vectorbt.indicators.factory.IndicatorFactory" href="factory.html#vectorbt.indicators.factory.IndicatorFactory">IndicatorFactory</a></code>.</p>
<p>Before running the examples, import the following libraries:</p>
<pre><code class="py">import numpy as np
import pandas as pd
from datetime import datetime, timedelta
import itertools
from numba import njit
import yfinance as yf

import vectorbt as vbt

ticker = yf.Ticker(&quot;BTC-USD&quot;)
price = ticker.history(start=datetime(2019, 3, 1), end=datetime(2019, 9, 1))

price['Close'].vbt.timeseries.plot()
</code></pre>
<p><img alt="" src="img/Indicators_price.png"></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A collection of custom indicators built with `vectorbt.indicators.factory.IndicatorFactory`.

Before running the examples, import the following libraries:
```py
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
import itertools
from numba import njit
import yfinance as yf

import vectorbt as vbt

ticker = yf.Ticker(&#34;BTC-USD&#34;)
price = ticker.history(start=datetime(2019, 3, 1), end=datetime(2019, 9, 1))

price[&#39;Close&#39;].vbt.timeseries.plot()
```
![](img/Indicators_price.png)&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.types import UniTuple, f8, i8, b1, DictType, Tuple
import itertools

from vectorbt import timeseries, indicators, defaults
from vectorbt.utils import checks, reshape_fns
from vectorbt.utils.common import fix_class_for_pdoc

# ############# MA ############# #


@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], b1[:]), cache=True)
def ma_caching_nb(ts, windows, ewms):
    &#34;&#34;&#34;Numba-compiled caching function for `MA`.&#34;&#34;&#34;
    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                ma = timeseries.nb.ewm_mean_nb(ts, windows[i])
            else:
                ma = timeseries.nb.rolling_mean_nb(ts, windows[i])
            cache_dict[(windows[i], int(ewms[i]))] = ma
    return cache_dict


@njit(f8[:, :](f8[:, :], i8, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def ma_apply_func_nb(ts, window, ewm, cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `MA`.&#34;&#34;&#34;
    return cache_dict[(window, int(ewm))]


MA = indicators.factory.IndicatorFactory(
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;ma&#39;],
    name=&#39;ma&#39;
).from_apply_func(ma_apply_func_nb, caching_func=ma_caching_nb)


class MA(MA):
    &#34;&#34;&#34;A moving average (MA) is a widely used indicator in technical analysis that helps smooth out 
    price action by filtering out the “noise” from random short-term price fluctuations. 

    See [Moving Average (MA)](https://www.investopedia.com/terms/m/movingaverage.asp).

    Use `MA.from_params` or `MA.from_combinations` methods to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, ts, window, ewm=False, **kwargs):
        &#34;&#34;&#34;Calculate moving average `MA.ma` from time series `ts` and parameters `window` and `ewm`.

        Args:
            ts (pandas_like): Time series (such as price).
            window (int or array_like): Size of the moving window. Can be one or more values.
            ewm (bool or array_like): If True, uses exponential moving average, otherwise 
                simple moving average. Can be one or more values. Defaults to False.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            MA
        Examples:
            ```python-repl
            &gt;&gt;&gt; ma = vbt.MA.from_params(price[&#39;Close&#39;], [10, 20], ewm=[False, True])

            &gt;&gt;&gt; print(ma.ma)
            ma_window          10            20
            ma_ewm          False          True
            Date                               
            2019-02-28        NaN           NaN
            2019-03-01        NaN           NaN
            2019-03-02        NaN           NaN
            ...               ...           ...
            2019-08-29  10155.972  10330.457140
            2019-08-30  10039.466  10260.715507
            2019-08-31   9988.727  10200.710220

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        return super().from_params(ts, window, ewm, **kwargs)

    @classmethod
    def from_combinations(cls, ts, windows, r, ewm=False, names=None, **kwargs):
        &#34;&#34;&#34;Create multiple `MA` combinations according to `itertools.combinations`.

        Args:
            ts (pandas_like): Time series (such as price).
            windows (array_like of int): Size of the moving window. Must be multiple.
            r (int): The number of `MA` instances to combine.
            ewm (bool or array_like of bool): If True, uses exponential moving average, otherwise 
                uses simple moving average. Can be one or more values. Defaults to False.
            names (list of str, optional): A list of names for each `MA` instance.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            tuple of MA
        Examples:
            ```python-repl
            &gt;&gt;&gt; fast_ma, slow_ma = vbt.MA.from_combinations(price[&#39;Close&#39;], 
            ...     [10, 20, 30], 2, ewm=[False, False, True], names=[&#39;fast&#39;, &#39;slow&#39;])

            &gt;&gt;&gt; print(fast_ma.ma)
            fast_window         10         10          20
            fast_ewm         False      False       False
            Date                                         
            2019-02-28         NaN        NaN         NaN
            2019-03-01         NaN        NaN         NaN
            2019-03-02         NaN        NaN         NaN
            ...                ...        ...         ...
            2019-08-29   10155.972  10155.972  10447.3480
            2019-08-30   10039.466  10039.466  10359.5555
            2019-08-31    9988.727   9988.727  10264.9095

            [185 rows x 3 columns]

            &gt;&gt;&gt; print(slow_ma.ma)
            slow_window          20            30            30
            slow_ewm          False          True          True
            Date                                               
            2019-02-28          NaN           NaN           NaN
            2019-03-01          NaN           NaN           NaN
            2019-03-02          NaN           NaN           NaN
            ...                 ...           ...           ...
            2019-08-29   10447.3480  10423.585970  10423.585970
            2019-08-30   10359.5555  10370.333077  10370.333077
            2019-08-31   10264.9095  10322.612024  10322.612024

            [185 rows x 3 columns]

            ```

            The naive way without caching is the follows:
            ```py
            window_combs = itertools.combinations([10, 20, 30], 2)
            ewm_combs = itertools.combinations([False, False, True], 2)
            fast_windows, slow_windows = np.asarray(list(window_combs)).transpose()
            fast_ewms, slow_ewms = np.asarray(list(ewm_combs)).transpose()

            fast_ma = vbt.MA.from_params(price[&#39;Close&#39;], 
            ...     fast_windows, fast_ewms, name=&#39;fast&#39;)
            slow_ma = vbt.MA.from_params(price[&#39;Close&#39;], 
            ...     slow_windows, slow_ewms, name=&#39;slow&#39;)
            ```

            Having this, you can now compare these `MA` instances:
            ```python-repl
            &gt;&gt;&gt; entry_signals = fast_ma.ma_above(slow_ma, crossover=True)
            &gt;&gt;&gt; exit_signals = fast_ma.ma_below(slow_ma, crossover=True)

            &gt;&gt;&gt; print(entry_signals)
            fast_window     10     10     20
            fast_ewm     False  False  False
            slow_window     20     30     30
            slow_ewm     False  True    True
            Date                            
            2019-02-28   False  False  False
            2019-03-01   False  False  False
            2019-03-02   False  False  False
            ...            ...    ...    ...
            2019-08-29   False  False  False
            2019-08-30   False  False  False
            2019-08-31   False  False  False

            [185 rows x 3 columns]
            ```

            Notice how `MA.ma_above` method created a new column hierarchy for you. You can now use
            it for indexing as follows:

            ```py
            fig = price[&#39;Close&#39;].vbt.timeseries.plot(name=&#39;Price&#39;)
            fig = entry_signals[(10, False, 20, False)]\\
                .vbt.signals.plot_markers(price[&#39;Close&#39;], signal_type=&#39;entry&#39;, fig=fig)
            fig = exit_signals[(10, False, 20, False)]\\
                .vbt.signals.plot_markers(price[&#39;Close&#39;], signal_type=&#39;exit&#39;, fig=fig)

            fig.show()
            ```
            ![](img/MA_from_combinations.png)
        &#34;&#34;&#34;

        if names is None:
            names = [&#39;ma&#39; + str(i+1) for i in range(r)]
        windows, ewm = reshape_fns.broadcast(windows, ewm, writeable=True)
        cache_dict = cls.from_params(ts, windows, ewm=ewm, return_cache=True, **kwargs)
        param_lists = zip(*itertools.combinations(zip(windows, ewm), r))
        mas = []
        for i, param_list in enumerate(param_lists):
            i_windows, i_ewm = zip(*param_list)
            mas.append(cls.from_params(ts, i_windows, ewm=i_ewm, cache=cache_dict, name=names[i], **kwargs))
        return tuple(mas)

    def plot(self,
             ts_trace_kwargs={},
             ma_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `MA.ma` against `MA.ts`.

        Args:
            ts_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MA.ts`.
            ma_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MA.ma`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            ma[(10, False)].plot()
            ```

            ![](img/MA.png)&#34;&#34;&#34;
        checks.assert_type(self.ts, pd.Series)
        checks.assert_type(self.ma, pd.Series)

        ts_trace_kwargs = {**dict(
            name=f&#39;Price ({self.name})&#39;
        ), **ts_trace_kwargs}
        ma_trace_kwargs = {**dict(
            name=f&#39;MA ({self.name})&#39;
        ), **ma_trace_kwargs}

        fig = self.ts.vbt.timeseries.plot(trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.ma.vbt.timeseries.plot(trace_kwargs=ma_trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_pdoc(MA)

# ############# MSTD ############# #


@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], b1[:]), cache=True)
def mstd_caching_nb(ts, windows, ewms):
    &#34;&#34;&#34;Numba-compiled caching function for `MSTD`.&#34;&#34;&#34;
    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                mstd = timeseries.nb.ewm_std_nb(ts, windows[i])
            else:
                mstd = timeseries.nb.rolling_std_nb(ts, windows[i])
            cache_dict[(windows[i], int(ewms[i]))] = mstd
    return cache_dict


@njit(f8[:, :](f8[:, :], i8, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def mstd_apply_func_nb(ts, window, ewm, cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `MSTD`.&#34;&#34;&#34;
    return cache_dict[(window, int(ewm))]


MSTD = indicators.factory.IndicatorFactory(
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;mstd&#39;],
    name=&#39;mstd&#39;
).from_apply_func(mstd_apply_func_nb, caching_func=mstd_caching_nb)


class MSTD(MSTD):
    &#34;&#34;&#34;Standard deviation is an indicator that measures the size of an assets recent price moves 
    in order to predict how volatile the price may be in the future.

    Use `MSTD.from_params` method to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, ts, window, ewm=False, **kwargs):
        &#34;&#34;&#34;Calculate moving standard deviation `MSTD.mstd` from time series `ts` and 
        parameters `window` and `ewm`.

        Args:
            ts (pandas_like): Time series (such as price).
            window (int or array_like): Size of the moving window. Can be one or more values.
            ewm (bool or array_like): If True, uses exponential moving standard deviation, 
                otherwise uses simple moving standard deviation. Can be one or more values. 
                Defaults to False.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            MSTD
        Examples:
            ```python-repl
            &gt;&gt;&gt; mstd = vbt.MSTD.from_params(price[&#39;Close&#39;], [10, 20], ewm=[False, True])

            &gt;&gt;&gt; print(mstd.mstd)
            mstd_window          10          20
            mstd_ewm          False        True
            Date                               
            2019-02-28          NaN         NaN
            2019-03-01          NaN         NaN
            2019-03-02          NaN         NaN
            ...                 ...         ...
            2019-08-29   342.996528  603.191266
            2019-08-30   310.101037  614.676546
            2019-08-31   332.853480  614.695088

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        return super().from_params(ts, window, ewm, **kwargs)

    def plot(self,
             mstd_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `MSTD.mstd`.

        Args:
            mstd_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MSTD.mstd`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            mstd[(10, False)].plot()
            ```

            ![](img/MSTD.png)&#34;&#34;&#34;
        checks.assert_type(self.mstd, pd.Series)

        mstd_trace_kwargs = {**dict(
            name=f&#39;MSTD ({self.name})&#39;
        ), **mstd_trace_kwargs}

        fig = self.mstd.vbt.timeseries.plot(trace_kwargs=mstd_trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_pdoc(MSTD)

# ############# BollingerBands ############# #


@njit(UniTuple(DictType(UniTuple(i8, 2), f8[:, :]), 2)(f8[:, :], i8[:], b1[:], f8[:]), cache=True)
def bb_caching_nb(ts, windows, ewms, alphas):
    &#34;&#34;&#34;Numba-compiled caching function for `BollingerBands`.&#34;&#34;&#34;
    ma_cache_dict = ma_caching_nb(ts, windows, ewms)
    mstd_cache_dict = mstd_caching_nb(ts, windows, ewms)
    return ma_cache_dict, mstd_cache_dict


@njit(UniTuple(f8[:, :], 3)(f8[:, :], i8, b1, f8, DictType(UniTuple(i8, 2), f8[:, :]), DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def bb_apply_func_nb(ts, window, ewm, alpha, ma_cache_dict, mstd_cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `BollingerBands`.&#34;&#34;&#34;
    # Calculate lower, middle and upper bands
    ma = np.copy(ma_cache_dict[(window, int(ewm))])
    mstd = np.copy(mstd_cache_dict[(window, int(ewm))])
    # # (MA + Kσ), MA, (MA - Kσ)
    return ma, ma + alpha * mstd, ma - alpha * mstd


BollingerBands = indicators.factory.IndicatorFactory(
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;, &#39;alpha&#39;],
    output_names=[&#39;ma&#39;, &#39;upper_band&#39;, &#39;lower_band&#39;],
    name=&#39;bb&#39;,
    custom_properties=dict(
        percent_b=lambda self: self.ts.vbt.wrap_array(
            (self.ts.values - self.lower_band.values) / (self.upper_band.values - self.lower_band.values)),
        bandwidth=lambda self: self.ts.vbt.wrap_array(
            (self.upper_band.values - self.lower_band.values) / self.ma.values)
    )
).from_apply_func(bb_apply_func_nb, caching_func=bb_caching_nb)


class BollingerBands(BollingerBands):
    &#34;&#34;&#34;A Bollinger Band® is a technical analysis tool defined by a set of lines plotted two standard 
    deviations (positively and negatively) away from a simple moving average (SMA) of the security&#39;s 
    price, but can be adjusted to user preferences.

    See [Bollinger Band®](https://www.investopedia.com/terms/b/bollingerbands.asp).

    Use `BollingerBands.from_params` method to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, ts, window=20, ewm=False, alpha=2, **kwargs):
        &#34;&#34;&#34;Calculate moving average `BollingerBands.ma`, upper Bollinger Band `BollingerBands.upper_band`,
        lower Bollinger Band `BollingerBands.lower_band`, %b `BollingerBands.percent_b` and 
        bandwidth `BollingerBands.bandwidth` from time series `ts` and parameters `window`, `ewm` and `alpha`.

        Args:
            ts (pandas_like): Time series (such as price).
            window (int or array_like): Size of the moving window. Can be one or more values.
                Defaults to 20.
            ewm (bool or array_like): If True, uses exponential moving average and standard deviation, 
                otherwise uses simple moving average and standard deviation. Can be one or more values. 
                Defaults to False.
            alpha (int, float or array_like): Number of standard deviations. Can be one or more values. Defaults to 2.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            BollingerBands
        Examples:
            ```python-repl
            &gt;&gt;&gt; bb = vbt.BollingerBands.from_params(price[&#39;Close&#39;], 
            ...     window=[10, 20], alpha=[2, 3], ewm=[False, True])

            &gt;&gt;&gt; print(bb.ma)
            bb_window          10            20
            bb_ewm          False          True
            bb_alpha          2.0           3.0
            Date                               
            2019-02-28        NaN           NaN
            2019-03-01        NaN           NaN
            2019-03-02        NaN           NaN
            ...               ...           ...
            2019-08-29  10155.972  10330.457140
            2019-08-30  10039.466  10260.715507
            2019-08-31   9988.727  10200.710220

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(bb.upper_band)
            bb_window             10            20
            bb_ewm             False          True
            bb_alpha             2.0           3.0
            Date                                  
            2019-02-28           NaN           NaN
            2019-03-01           NaN           NaN
            2019-03-02           NaN           NaN
            ...                  ...           ...
            2019-08-29  10841.965056  12140.030938
            2019-08-30  10659.668073  12104.745144
            2019-08-31  10654.433961  12044.795485

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(bb.lower_band)
            bb_window            10           20
            bb_ewm            False         True
            bb_alpha            2.0          3.0
            Date                                
            2019-02-28          NaN          NaN
            2019-03-01          NaN          NaN
            2019-03-02          NaN          NaN
            ...                 ...          ...
            2019-08-29  9469.978944  8520.883342
            2019-08-30  9419.263927  8416.685869
            2019-08-31  9323.020039  8356.624955

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(bb.percent_b)
            bb_window         10        20
            bb_ewm         False      True
            bb_alpha         2.0       3.0
            Date                          
            2019-02-28       NaN       NaN
            2019-03-01       NaN       NaN
            2019-03-02       NaN       NaN
            ...              ...       ...
            2019-08-29  0.029316  0.273356
            2019-08-30  0.144232  0.320354
            2019-08-31  0.231063  0.345438

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(bb.bandwidth)
            bb_window         10        20
            bb_ewm         False      True
            bb_alpha         2.0       3.0
            Date                          
            2019-02-28       NaN       NaN
            2019-03-01       NaN       NaN
            2019-03-02       NaN       NaN
            2019-03-03       NaN       NaN
            2019-03-04       NaN       NaN
            ...              ...       ...
            2019-08-27  0.107370  0.313212
            2019-08-28  0.130902  0.325698
            2019-08-29  0.135092  0.350338
            2019-08-30  0.123553  0.359435
            2019-08-31  0.133292  0.361560

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        alpha = np.asarray(alpha).astype(np.float64)
        return super().from_params(ts, window, ewm, alpha, **kwargs)

    def plot(self,
             ts_trace_kwargs={},
             ma_trace_kwargs={},
             upper_band_trace_kwargs={},
             lower_band_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `BollingerBands.ma`, `BollingerBands.upper_band` and `BollingerBands.lower_band` against 
        `BollingerBands.ts`.

        Args:
            ts_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `BollingerBands.ts`.
            ma_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `BollingerBands.ma`.
            upper_band_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `BollingerBands.upper_band`.
            lower_band_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `BollingerBands.lower_band`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            bb[(10, False, 2)].plot()
            ```

            ![](img/BollingerBands.png)&#34;&#34;&#34;
        checks.assert_type(self.ts, pd.Series)
        checks.assert_type(self.ma, pd.Series)
        checks.assert_type(self.upper_band, pd.Series)
        checks.assert_type(self.lower_band, pd.Series)

        lower_band_trace_kwargs = {**dict(
            name=f&#39;Lower Band ({self.name})&#39;,
            line=dict(color=&#39;grey&#39;, width=0),
            showlegend=False
        ), **lower_band_trace_kwargs}
        upper_band_trace_kwargs = {**dict(
            name=f&#39;Upper Band ({self.name})&#39;,
            line=dict(color=&#39;grey&#39;, width=0),
            fill=&#39;tonexty&#39;,
            fillcolor=&#39;rgba(128, 128, 128, 0.25)&#39;,
            showlegend=False
        ), **upper_band_trace_kwargs}  # default kwargs
        ma_trace_kwargs = {**dict(
            name=f&#39;MA ({self.name})&#39;,
            line=dict(color=defaults.layout[&#39;colorway&#39;][1])
        ), **ma_trace_kwargs}
        ts_trace_kwargs = {**dict(
            name=f&#39;Price ({self.name})&#39;,
            line=dict(color=defaults.layout[&#39;colorway&#39;][0])
        ), **ts_trace_kwargs}

        fig = self.lower_band.vbt.timeseries.plot(trace_kwargs=lower_band_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.upper_band.vbt.timeseries.plot(trace_kwargs=upper_band_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.ma.vbt.timeseries.plot(trace_kwargs=ma_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.ts.vbt.timeseries.plot(trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_pdoc(BollingerBands)

# ############# RSI ############# #


@njit(DictType(UniTuple(i8, 2), UniTuple(f8[:, :], 2))(f8[:, :], i8[:], b1[:]), cache=True)
def rsi_caching_nb(ts, windows, ewms):
    &#34;&#34;&#34;Numba-compiled caching function for `RSI`.&#34;&#34;&#34;
    delta = timeseries.nb.diff_nb(ts)[1:, :]  # otherwise ewma will be all NaN
    up, down = delta.copy(), delta.copy()
    up = timeseries.nb.set_by_mask_nb(up, up &lt; 0, 0)
    down = np.abs(timeseries.nb.set_by_mask_nb(down, down &gt; 0, 0))
    # Cache
    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                roll_up = timeseries.nb.ewm_mean_nb(up, windows[i])
                roll_down = timeseries.nb.ewm_mean_nb(down, windows[i])
            else:
                roll_up = timeseries.nb.rolling_mean_nb(up, windows[i])
                roll_down = timeseries.nb.rolling_mean_nb(down, windows[i])
            roll_up = timeseries.nb.prepend_nb(roll_up, 1, np.nan)  # bring to old shape
            roll_down = timeseries.nb.prepend_nb(roll_down, 1, np.nan)
            cache_dict[(windows[i], int(ewms[i]))] = roll_up, roll_down
    return cache_dict


@njit(f8[:, :](f8[:, :], i8, b1, DictType(UniTuple(i8, 2), UniTuple(f8[:, :], 2))), cache=True)
def rsi_apply_func_nb(ts, window, ewm, cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `RSI`.&#34;&#34;&#34;
    roll_up, roll_down = cache_dict[(window, int(ewm))]
    return 100 - 100 / (1 + roll_up / roll_down)


RSI = indicators.factory.IndicatorFactory(
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;rsi&#39;],
    name=&#39;rsi&#39;
).from_apply_func(rsi_apply_func_nb, caching_func=rsi_caching_nb)


class RSI(RSI):
    &#34;&#34;&#34;The relative strength index (RSI) is a momentum indicator that measures the magnitude of 
    recent price changes to evaluate overbought or oversold conditions in the price of a stock 
    or other asset. The RSI is displayed as an oscillator (a line graph that moves between two 
    extremes) and can have a reading from 0 to 100.

    See [Relative Strength Index (RSI)](https://www.investopedia.com/terms/r/rsi.asp).

    Use `RSI.from_params` methods to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, ts, window=14, ewm=False, **kwargs):
        &#34;&#34;&#34;Calculate relative strength index `RSI.rsi` from time series `ts` and parameters `window` and `ewm`.

        Args:
            ts (pandas_like): Time series (such as price).
            window (int or array_like): Size of the moving window. Can be one or more values. Defaults to 14.
            ewm (bool or array_like): If True, uses exponential moving average, otherwise 
                simple moving average. Can be one or more values. Defaults to False.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            RSI
        Examples:
            ```python-repl
            &gt;&gt;&gt; rsi = vbt.RSI.from_params(price[&#39;Close&#39;], [10, 20], ewm=[False, True])

            &gt;&gt;&gt; print(rsi.rsi)
            rsi_window         10         20
            rsi_ewm         False       True
            Date                            
            2019-02-28        NaN        NaN
            2019-03-01        NaN        NaN
            2019-03-02        NaN        NaN
            ...               ...        ...
            2019-08-29  21.004434  34.001218
            2019-08-30  25.310248  36.190915
            2019-08-31  35.640258  37.043562

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        return super().from_params(ts, window, ewm, **kwargs)

    def plot(self,
             levels=(30, 70),
             rsi_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `RSI.rsi`.

        Args:
            trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `RSI.rsi`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            rsi[(10, False)].plot()
            ```

            ![](img/RSI.png)&#34;&#34;&#34;
        checks.assert_type(self.rsi, pd.Series)

        rsi_trace_kwargs = {**dict(
            name=f&#39;RSI ({self.name})&#39;
        ), **rsi_trace_kwargs}

        layout_kwargs = {**dict(yaxis=dict(range=[-5, 105])), **layout_kwargs}
        fig = self.rsi.vbt.timeseries.plot(trace_kwargs=rsi_trace_kwargs, fig=fig, **layout_kwargs)

        # Fill void between levels
        fig.add_shape(
            type=&#34;rect&#34;,
            xref=&#34;x&#34;,
            yref=&#34;y&#34;,
            x0=self.rsi.index[0],
            y0=levels[0],
            x1=self.rsi.index[-1],
            y1=levels[1],
            fillcolor=&#34;purple&#34;,
            opacity=0.1,
            layer=&#34;below&#34;,
            line_width=0,
        )

        return fig


fix_class_for_pdoc(RSI)

# ############# Stochastic ############# #


@njit(DictType(i8, UniTuple(f8[:, :], 2))(f8[:, :], f8[:, :], f8[:, :], i8[:], i8[:], b1[:]), cache=True)
def stoch_caching_nb(close_ts, high_ts, low_ts, k_windows, d_windows, d_ewms):
    &#34;&#34;&#34;Numba-compiled caching function for `Stochastic`.&#34;&#34;&#34;
    cache_dict = dict()
    for i in range(k_windows.shape[0]):
        if k_windows[i] not in cache_dict:
            roll_min = timeseries.nb.rolling_min_nb(low_ts, k_windows[i])
            roll_max = timeseries.nb.rolling_max_nb(high_ts, k_windows[i])
            cache_dict[k_windows[i]] = roll_min, roll_max
    return cache_dict


@njit(UniTuple(f8[:, :], 2)(f8[:, :], f8[:, :], f8[:, :], i8, i8, b1, DictType(i8, UniTuple(f8[:, :], 2))), cache=True)
def stoch_apply_func_nb(close_ts, high_ts, low_ts, k_window, d_window, d_ewm, cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `Stochastic`.&#34;&#34;&#34;
    roll_min, roll_max = cache_dict[k_window]
    percent_k = 100 * (close_ts - roll_min) / (roll_max - roll_min)
    if d_ewm:
        percent_d = timeseries.nb.ewm_mean_nb(percent_k, d_window)
    else:
        percent_d = timeseries.nb.rolling_mean_nb(percent_k, d_window)
    percent_d[:k_window+d_window-2, :] = np.nan  # min_periods
    return percent_k, percent_d


Stochastic = indicators.factory.IndicatorFactory(
    ts_names=[&#39;close_ts&#39;, &#39;high_ts&#39;, &#39;low_ts&#39;],
    param_names=[&#39;k_window&#39;, &#39;d_window&#39;, &#39;d_ewm&#39;],
    output_names=[&#39;percent_k&#39;, &#39;percent_d&#39;],
    name=&#39;stoch&#39;
).from_apply_func(stoch_apply_func_nb, caching_func=stoch_caching_nb)


class Stochastic(Stochastic):
    &#34;&#34;&#34;A stochastic oscillator is a momentum indicator comparing a particular closing price of a security 
    to a range of its prices over a certain period of time. It is used to generate overbought and oversold 
    trading signals, utilizing a 0-100 bounded range of values.

    See [Stochastic Oscillator](https://www.investopedia.com/terms/s/stochasticoscillator.asp).

    Use `Stochastic.from_params` methods to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, close_ts, high_ts=None, low_ts=None, k_window=14, d_window=3, d_ewm=False, **kwargs):
        &#34;&#34;&#34;Calculate %K `Stochastic.percent_k` and %D `Stochastic.percent_d` from time series `close_ts`, 
        `high_ts`, and `low_ts`, and parameters `k_window`, `d_window` and `d_ewm`.

        Args:
            close_ts (pandas_like): The last closing price.
            high_ts (pandas_like, optional): The highest price. If None, uses `close_ts`.
            low_ts (pandas_like, optional): The lowest price. If None, uses `close_ts`.
            k_window (int or array_like): Size of the moving window for %K. Can be one or more values. 
                Defaults to 14.
            d_window (int or array_like): Size of the moving window for %D. Can be one or more values. 
                Defaults to 3.
            d_ewm (bool or array_like): If True, uses exponential moving average for %D, otherwise 
                simple moving average. Can be one or more values. Defaults to False.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            Stochastic
        Examples:
            ```python-repl
            &gt;&gt;&gt; stoch = vbt.Stochastic.from_params(price[&#39;Close&#39;],
            ...     high_ts=price[&#39;High&#39;], low_ts=price[&#39;Low&#39;],
            ...     k_window=[10, 20], d_window=[2, 3], d_ewm=[False, True])

            &gt;&gt;&gt; print(stoch.percent_k)
            stoch_k_window         10         20
            stoch_d_window          2          3
            stoch_d_ewm         False       True
            Date                                
            2019-02-28            NaN        NaN
            2019-03-01            NaN        NaN
            2019-03-02            NaN        NaN
            ...                   ...        ...
            2019-08-29       5.806308   3.551280
            2019-08-30      12.819694   8.380488
            2019-08-31      19.164757   9.922813

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(stoch.percent_d)
            stoch_k_window         10         20
            stoch_d_window          2          3
            stoch_d_ewm         False       True
            Date                                
            2019-02-28            NaN        NaN
            2019-03-01            NaN        NaN
            2019-03-02            NaN        NaN
            ...                   ...        ...
            2019-08-29       4.437639   8.498544
            2019-08-30       9.313001   8.439516
            2019-08-31      15.992225   9.181164

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        if high_ts is None:
            high_ts = close_ts
        if low_ts is None:
            low_ts = close_ts
        return super().from_params(close_ts, high_ts, low_ts, k_window, d_window, d_ewm, **kwargs)

    def plot(self,
             levels=(30, 70),
             percent_k_trace_kwargs={},
             percent_d_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `Stochastic.percent_k` and `Stochastic.percent_d`.

        Args:
            percent_k_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `Stochastic.percent_k`.
            percent_d_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `Stochastic.percent_d`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            stoch[(10, 2, False)].plot(levels=(20, 80))
            ```

            ![](img/Stochastic.png)&#34;&#34;&#34;
        checks.assert_type(self.percent_k, pd.Series)
        checks.assert_type(self.percent_d, pd.Series)

        percent_k_trace_kwargs = {**dict(
            name=f&#39;%K ({self.name})&#39;
        ), **percent_k_trace_kwargs}
        percent_d_trace_kwargs = {**dict(
            name=f&#39;%D ({self.name})&#39;
        ), **percent_d_trace_kwargs}

        layout_kwargs = {**dict(yaxis=dict(range=[-5, 105])), **layout_kwargs}
        fig = self.percent_k.vbt.timeseries.plot(trace_kwargs=percent_k_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.percent_d.vbt.timeseries.plot(trace_kwargs=percent_d_trace_kwargs, fig=fig, **layout_kwargs)

        # Plot levels
        # Fill void between levels
        fig.add_shape(
            type=&#34;rect&#34;,
            xref=&#34;x&#34;,
            yref=&#34;y&#34;,
            x0=self.percent_k.index[0],
            y0=levels[0],
            x1=self.percent_k.index[-1],
            y1=levels[1],
            fillcolor=&#34;purple&#34;,
            opacity=0.1,
            layer=&#34;below&#34;,
            line_width=0,
        )

        return fig


fix_class_for_pdoc(Stochastic)

# ############# MACD ############# #


@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], i8[:], i8[:], b1[:], b1[:]), cache=True)
def macd_caching_nb(ts, fast_windows, slow_windows, signal_windows, macd_ewms, signal_ewms):
    &#34;&#34;&#34;Numba-compiled caching function for `MACD`.&#34;&#34;&#34;
    return ma_caching_nb(ts, np.concatenate((fast_windows, slow_windows)), np.concatenate((macd_ewms, macd_ewms)))


@njit(UniTuple(f8[:, :], 4)(f8[:, :], i8, i8, i8, b1, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def macd_apply_func_nb(ts, fast_window, slow_window, signal_window, macd_ewm, signal_ewm, cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `MACD`.&#34;&#34;&#34;
    fast_ma = cache_dict[(fast_window, int(macd_ewm))]
    slow_ma = cache_dict[(slow_window, int(macd_ewm))]
    macd_ts = fast_ma - slow_ma
    if signal_ewm:
        signal_ts = timeseries.nb.ewm_mean_nb(macd_ts, signal_window)
    else:
        signal_ts = timeseries.nb.rolling_mean_nb(macd_ts, signal_window)
    signal_ts[:max(fast_window, slow_window)+signal_window-2, :] = np.nan  # min_periodd
    return np.copy(fast_ma), np.copy(slow_ma), macd_ts, signal_ts


MACD = indicators.factory.IndicatorFactory(
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;fast_window&#39;, &#39;slow_window&#39;, &#39;signal_window&#39;, &#39;macd_ewm&#39;, &#39;signal_ewm&#39;],
    output_names=[&#39;fast_ma&#39;, &#39;slow_ma&#39;, &#39;macd&#39;, &#39;signal&#39;],
    name=&#39;macd&#39;,
    custom_properties=dict(
        histogram=lambda self: self.ts.vbt.wrap_array(self.macd.values - self.signal.values),
    )
).from_apply_func(macd_apply_func_nb, caching_func=macd_caching_nb)


class MACD(MACD):
    &#34;&#34;&#34;Moving Average Convergence Divergence (MACD) is a trend-following momentum indicator that 
    shows the relationship between two moving averages of a security’s price.

    See [Moving Average Convergence Divergence – MACD](https://www.investopedia.com/terms/m/macd.asp).

    Use `MACD.from_params` methods to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, ts, fast_window=26, slow_window=12, signal_window=9, macd_ewm=True, signal_ewm=True, **kwargs):
        &#34;&#34;&#34;Calculate fast moving average `MACD.fast_ma`, slow moving average `MACD.slow_ma`, MACD `MACD.macd`, 
        signal `MACD.signal` and histogram `MACD.histogram` from time series `ts` and parameters `fast_window`, 
        `slow_window`, `signal_window`, `macd_ewm` and `signal_ewm`.

        Args:
            ts (pandas_like): Time series (such as price).
            fast_window (int or array_like): Size of the fast moving window for MACD. Can be one or more values.
                Defaults to 26.
            slow_window (int or array_like): Size of the slow moving window for MACD. Can be one or more values.
                Defaults to 12.
            signal_window (int or array_like): Size of the moving window for signal. Can be one or more values.
                Defaults to 9.
            macd_ewm (bool or array_like): If True, uses exponential moving average for MACD, otherwise uses 
                simple moving average. Can be one or more values. Defaults to True.
            signal_ewm (bool or array_like): If True, uses exponential moving average for signal, otherwise uses 
                simple moving average. Can be one or more values. Defaults to True.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            MACD
        Examples:
            ```python-repl
            &gt;&gt;&gt; macd = vbt.MACD.from_params(price[&#39;Close&#39;], 
            ...     fast_window=[10, 20], slow_window=[20, 30], signal_window=[30, 40], 
            ...     macd_ewm=[False, True], signal_ewm=[True, False])

            &gt;&gt;&gt; print(macd.fast_ma)
            macd_fast_window           10            20
            macd_slow_window           20            30
            macd_signal_window         30            40
            macd_macd_ewm           False          True
            macd_signal_ewm          True         False
            Date                                       
            2019-02-28                NaN           NaN
            2019-03-01                NaN           NaN
            2019-03-02                NaN           NaN
            ...                       ...           ...
            2019-08-29          10155.972  10330.457140
            2019-08-30          10039.466  10260.715507
            2019-08-31           9988.727  10200.710220

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(macd.slow_ma)
            macd_fast_window            10            20
            macd_slow_window            20            30
            macd_signal_window          30            40
            macd_macd_ewm            False          True
            macd_signal_ewm           True         False
            Date                                        
            2019-02-28                 NaN           NaN
            2019-03-01                 NaN           NaN
            2019-03-02                 NaN           NaN
            ...                        ...           ...
            2019-08-29          10447.3480  10423.585970
            2019-08-30          10359.5555  10370.333077
            2019-08-31          10264.9095  10322.612024

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(macd.macd)
            macd_fast_window          10          20
            macd_slow_window          20          30
            macd_signal_window        30          40
            macd_macd_ewm          False        True
            macd_signal_ewm         True       False
            Date                                    
            2019-02-28               NaN         NaN
            2019-03-01               NaN         NaN
            2019-03-02               NaN         NaN
            ...                      ...         ...
            2019-08-29         -291.3760  -93.128830
            2019-08-30         -320.0895 -109.617570
            2019-08-31         -276.1825 -121.901804

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(macd.signal)
            macd_fast_window            10         20
            macd_slow_window            20         30
            macd_signal_window          30         40
            macd_macd_ewm            False       True
            macd_signal_ewm           True      False
            Date                                     
            2019-02-28                 NaN        NaN
            2019-03-01                 NaN        NaN
            2019-03-02                 NaN        NaN
            ...                        ...        ...
            2019-08-29         -104.032603  28.622033
            2019-08-30         -117.971990  22.424149
            2019-08-31         -128.179278  16.493338

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(macd.histogram)
            macd_fast_window            10          20
            macd_slow_window            20          30
            macd_signal_window          30          40
            macd_macd_ewm            False        True
            macd_signal_ewm           True       False
            Date                                      
            2019-02-28                 NaN         NaN
            2019-03-01                 NaN         NaN
            2019-03-02                 NaN         NaN
            ...                        ...         ...
            2019-08-29         -187.343397 -121.750863
            2019-08-30         -202.117510 -132.041719
            2019-08-31         -148.003222 -138.395142

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        return super().from_params(ts, fast_window, slow_window, signal_window, macd_ewm, signal_ewm, **kwargs)

    def plot(self,
             macd_trace_kwargs={},
             signal_trace_kwargs={},
             histogram_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `MACD.macd`, `MACD.signal` and `MACD.histogram`.

        Args:
            macd_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `MACD.macd`.
            signal_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `MACD.signal`.
            histogram_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Bar`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Bar.html) of 
                `MACD.histogram`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            macd[(10, 20, 30, False, True)].plot()
            ```

            ![](img/MACD.png)&#34;&#34;&#34;
        checks.assert_type(self.macd, pd.Series)
        checks.assert_type(self.signal, pd.Series)
        checks.assert_type(self.histogram, pd.Series)

        macd_trace_kwargs = {**dict(
            name=f&#39;MACD ({self.name})&#39;
        ), **macd_trace_kwargs}
        signal_trace_kwargs = {**dict(
            name=f&#39;Signal ({self.name})&#39;
        ), **signal_trace_kwargs}
        histogram_trace_kwargs = {**dict(
            name=f&#39;Histogram ({self.name})&#39;,
            showlegend=False
        ), **histogram_trace_kwargs}

        layout_kwargs = {**dict(bargap=0), **layout_kwargs}
        fig = self.macd.vbt.timeseries.plot(trace_kwargs=macd_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.signal.vbt.timeseries.plot(trace_kwargs=signal_trace_kwargs, fig=fig, **layout_kwargs)

        # Plot histogram
        hist = self.histogram.values
        hist_diff = timeseries.nb.diff_1d_nb(hist)
        marker_colors = np.full(hist.shape, np.nan, dtype=np.object)
        marker_colors[(hist &gt; 0) &amp; (hist_diff &gt; 0)] = &#39;green&#39;
        marker_colors[(hist &gt; 0) &amp; (hist_diff &lt;= 0)] = &#39;lightgreen&#39;
        marker_colors[hist == 0] = &#39;lightgrey&#39;
        marker_colors[(hist &lt; 0) &amp; (hist_diff &lt; 0)] = &#39;red&#39;
        marker_colors[(hist &lt; 0) &amp; (hist_diff &gt;= 0)] = &#39;lightcoral&#39;

        histogram_bar = go.Bar(
            x=self.histogram.index,
            y=self.histogram.values,
            marker_color=marker_colors,
            marker_line_width=0
        )
        histogram_bar.update(**histogram_trace_kwargs)
        fig.add_trace(histogram_bar)

        return fig


fix_class_for_pdoc(MACD)

# ############# ATR ############# #


@njit(Tuple((f8[:, :], DictType(UniTuple(i8, 2), f8[:, :])))(f8[:, :], f8[:, :], f8[:, :], i8[:], b1[:]), cache=True)
def atr_caching_nb(close_ts, high_ts, low_ts, windows, ewms):
    &#34;&#34;&#34;Numba-compiled caching function for `ATR`.&#34;&#34;&#34;
    # Calculate TR here instead of re-calculating it for each param in atr_apply_func_nb
    tr0 = high_ts - low_ts
    tr1 = np.abs(high_ts - timeseries.nb.fshift_nb(close_ts, 1))
    tr2 = np.abs(low_ts - timeseries.nb.fshift_nb(close_ts, 1))
    tr = timeseries.nb.nanmax_cube_nb(np.stack((tr0, tr1, tr2)))

    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                atr = timeseries.nb.ewm_mean_nb(tr, windows[i])
            else:
                atr = timeseries.nb.rolling_mean_nb(tr, windows[i])
            cache_dict[(windows[i], int(ewms[i]))] = atr
    return tr, cache_dict


@njit(UniTuple(f8[:, :], 2)(f8[:, :], f8[:, :], f8[:, :], i8, b1, f8[:, :], DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def atr_apply_func_nb(close_ts, high_ts, low_ts, window, ewm, tr, cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `ATR`.&#34;&#34;&#34;
    return tr, cache_dict[(window, int(ewm))]


ATR = indicators.factory.IndicatorFactory(
    ts_names=[&#39;close_ts&#39;, &#39;high_ts&#39;, &#39;low_ts&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;tr&#39;, &#39;atr&#39;],
    name=&#39;atr&#39;
).from_apply_func(atr_apply_func_nb, caching_func=atr_caching_nb)


class ATR(ATR):
    &#34;&#34;&#34;The average true range (ATR) is a technical analysis indicator that measures market volatility 
    by decomposing the entire range of an asset price for that period.

    See [Average True Range - ATR](https://www.investopedia.com/terms/a/atr.asp).

    Use `ATR.from_params` method to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, close_ts, high_ts, low_ts, window, ewm=True, **kwargs):
        &#34;&#34;&#34;Calculate true range `ATR.tr` and average true range `ATR.atr` from time series `close_ts`, 
        `high_ts`, and `low_ts`, and parameters `window` and `ewm`.

        Args:
            close_ts (pandas_like): The last closing price.
            high_ts (pandas_like, optional): The highest price. If None, uses `close_ts`.
            low_ts (pandas_like, optional): The lowest price. If None, uses `close_ts`.
            window (int or array_like): Size of the moving window. Can be one or more values. 
                Defaults to 14.
            ewm (bool or array_like): If True, uses exponential moving average, otherwise 
                simple moving average. Can be one or more values. Defaults to True.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            ATR
        Examples:
            ```python-repl
            &gt;&gt;&gt; atr = vbt.ATR.from_params(price[&#39;Close&#39;], 
            ...     price[&#39;High&#39;], price[&#39;Low&#39;], [20, 30], [False, True])

            &gt;&gt;&gt; print(atr.tr)
            atr_window      20      30
            atr_ewm      False    True
            Date                      
            2019-02-28   60.24   60.24
            2019-03-01   56.11   56.11
            2019-03-02   42.48   42.48
            ...            ...     ...
            2019-08-29  335.16  335.16
            2019-08-30  227.82  227.82
            2019-08-31  141.42  141.42

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(atr.atr)
            atr_window        20          30
            atr_ewm        False        True
            Date                            
            2019-02-28       NaN         NaN
            2019-03-01       NaN         NaN
            2019-03-02       NaN         NaN
            ...              ...         ...
            2019-08-29  476.9385  491.469062
            2019-08-30  458.7415  474.459365
            2019-08-31  452.0480  452.972860

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        return super().from_params(close_ts, high_ts, low_ts, window, ewm, **kwargs)

    def plot(self,
             tr_trace_kwargs={},
             atr_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `ATR.tr` and `ATR.atr`.

        Args:
            tr_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for `ATR.tr`.
            atr_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for `ATR.atr`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            atr[(10, False)].plot()
            ```

            ![](img/ATR.png)&#34;&#34;&#34;
        checks.assert_type(self.tr, pd.Series)
        checks.assert_type(self.atr, pd.Series)

        tr_trace_kwargs = {**dict(
            name=f&#39;TR ({self.name})&#39;
        ), **tr_trace_kwargs}
        atr_trace_kwargs = {**dict(
            name=f&#39;ATR ({self.name})&#39;
        ), **atr_trace_kwargs}

        fig = self.tr.vbt.timeseries.plot(trace_kwargs=tr_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.atr.vbt.timeseries.plot(trace_kwargs=atr_trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_pdoc(ATR)

# ############# OBV ############# #


@njit(f8[:, :](f8[:, :], f8[:, :]))
def obv_custom_func_nb(close_ts, volume_ts):
    &#34;&#34;&#34;Numba-compiled custom calculation function for `OBV`.&#34;&#34;&#34;
    obv = np.full_like(close_ts, np.nan)
    for col in range(close_ts.shape[1]):
        cumsum = 0
        for i in range(1, close_ts.shape[0]):
            if np.isnan(close_ts[i, col]) or np.isnan(close_ts[i-1, col]) or np.isnan(volume_ts[i, col]):
                continue
            if close_ts[i, col] &gt; close_ts[i-1, col]:
                cumsum += volume_ts[i, col]
            elif close_ts[i, col] &lt; close_ts[i-1, col]:
                cumsum += -volume_ts[i, col]
            obv[i, col] = cumsum
    return obv


def obv_custom_func(close_ts, volume_ts):
    &#34;&#34;&#34;Custom calculation function for `OBV`.&#34;&#34;&#34;
    return obv_custom_func_nb(close_ts.vbt.to_2d_array(), volume_ts.vbt.to_2d_array())


OBV = indicators.factory.IndicatorFactory(
    ts_names=[&#39;close_ts&#39;, &#39;volume_ts&#39;],
    param_names=[],
    output_names=[&#39;obv&#39;],
    name=&#39;obv&#39;
).from_custom_func(obv_custom_func)


class OBV(OBV):
    &#34;&#34;&#34;On-balance volume (OBV) is a technical trading momentum indicator that uses volume flow to predict 
    changes in stock price.

    See [On-Balance Volume (OBV)](https://www.investopedia.com/terms/o/onbalancevolume.asp).

    Use `OBV.from_params` methods to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, close_ts, volume_ts):
        &#34;&#34;&#34;Calculate on-balance volume `OBV.obv` from time series `close_ts` and `volume_ts`, and no parameters.

        Args:
            close_ts (pandas_like): The last closing price.
            volume_ts (pandas_like): The volume.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            OBV
        Examples:
            ```python-repl
            &gt;&gt;&gt; obv = vbt.OBV.from_params(price[&#39;Close&#39;], price[&#39;Volume&#39;])

            &gt;&gt;&gt; print(obv.obv)
            Date
            2019-02-28             NaN
            2019-03-01    7.661248e+09
            2019-03-02    1.524003e+10
            2019-03-03    7.986476e+09
            2019-03-04   -1.042700e+09
                                   ...     
            2019-08-27    5.613088e+11
            2019-08-28    5.437050e+11
            2019-08-29    5.266592e+11
            2019-08-30    5.402544e+11
            2019-08-31    5.517092e+11
            Name: (Close, Volume), Length: 185, dtype: float64
            ```
        &#34;&#34;&#34;
        return super().from_params(close_ts, volume_ts)

    def plot(self,
             obv_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `OBV.obv`.

        Args:
            obv_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `OBV.obv`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            obv.plot()
            ```

            ![](img/OBV.png)&#34;&#34;&#34;
        checks.assert_type(self.obv, pd.Series)

        obv_trace_kwargs = {**dict(
            name=f&#39;OBV ({self.name})&#39;
        ), **obv_trace_kwargs}

        fig = self.obv.vbt.timeseries.plot(trace_kwargs=obv_trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_pdoc(OBV)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.indicators.indicators.atr_apply_func_nb"><code class="name flex">
<span>def <span class="ident">atr_apply_func_nb</span></span>(<span>close_ts, high_ts, low_ts, window, ewm, tr, cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled apply function for <code><a title="vectorbt.indicators.indicators.ATR" href="#vectorbt.indicators.indicators.ATR">ATR</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(UniTuple(f8[:, :], 2)(f8[:, :], f8[:, :], f8[:, :], i8, b1, f8[:, :], DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def atr_apply_func_nb(close_ts, high_ts, low_ts, window, ewm, tr, cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `ATR`.&#34;&#34;&#34;
    return tr, cache_dict[(window, int(ewm))]</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.atr_caching_nb"><code class="name flex">
<span>def <span class="ident">atr_caching_nb</span></span>(<span>close_ts, high_ts, low_ts, windows, ewms)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled caching function for <code><a title="vectorbt.indicators.indicators.ATR" href="#vectorbt.indicators.indicators.ATR">ATR</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(Tuple((f8[:, :], DictType(UniTuple(i8, 2), f8[:, :])))(f8[:, :], f8[:, :], f8[:, :], i8[:], b1[:]), cache=True)
def atr_caching_nb(close_ts, high_ts, low_ts, windows, ewms):
    &#34;&#34;&#34;Numba-compiled caching function for `ATR`.&#34;&#34;&#34;
    # Calculate TR here instead of re-calculating it for each param in atr_apply_func_nb
    tr0 = high_ts - low_ts
    tr1 = np.abs(high_ts - timeseries.nb.fshift_nb(close_ts, 1))
    tr2 = np.abs(low_ts - timeseries.nb.fshift_nb(close_ts, 1))
    tr = timeseries.nb.nanmax_cube_nb(np.stack((tr0, tr1, tr2)))

    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                atr = timeseries.nb.ewm_mean_nb(tr, windows[i])
            else:
                atr = timeseries.nb.rolling_mean_nb(tr, windows[i])
            cache_dict[(windows[i], int(ewms[i]))] = atr
    return tr, cache_dict</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.bb_apply_func_nb"><code class="name flex">
<span>def <span class="ident">bb_apply_func_nb</span></span>(<span>ts, window, ewm, alpha, ma_cache_dict, mstd_cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled apply function for <code><a title="vectorbt.indicators.indicators.BollingerBands" href="#vectorbt.indicators.indicators.BollingerBands">BollingerBands</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(UniTuple(f8[:, :], 3)(f8[:, :], i8, b1, f8, DictType(UniTuple(i8, 2), f8[:, :]), DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def bb_apply_func_nb(ts, window, ewm, alpha, ma_cache_dict, mstd_cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `BollingerBands`.&#34;&#34;&#34;
    # Calculate lower, middle and upper bands
    ma = np.copy(ma_cache_dict[(window, int(ewm))])
    mstd = np.copy(mstd_cache_dict[(window, int(ewm))])
    # # (MA + Kσ), MA, (MA - Kσ)
    return ma, ma + alpha * mstd, ma - alpha * mstd</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.bb_caching_nb"><code class="name flex">
<span>def <span class="ident">bb_caching_nb</span></span>(<span>ts, windows, ewms, alphas)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled caching function for <code><a title="vectorbt.indicators.indicators.BollingerBands" href="#vectorbt.indicators.indicators.BollingerBands">BollingerBands</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(UniTuple(DictType(UniTuple(i8, 2), f8[:, :]), 2)(f8[:, :], i8[:], b1[:], f8[:]), cache=True)
def bb_caching_nb(ts, windows, ewms, alphas):
    &#34;&#34;&#34;Numba-compiled caching function for `BollingerBands`.&#34;&#34;&#34;
    ma_cache_dict = ma_caching_nb(ts, windows, ewms)
    mstd_cache_dict = mstd_caching_nb(ts, windows, ewms)
    return ma_cache_dict, mstd_cache_dict</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ma_apply_func_nb"><code class="name flex">
<span>def <span class="ident">ma_apply_func_nb</span></span>(<span>ts, window, ewm, cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled apply function for <code><a title="vectorbt.indicators.indicators.MA" href="#vectorbt.indicators.indicators.MA">MA</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(f8[:, :](f8[:, :], i8, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def ma_apply_func_nb(ts, window, ewm, cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `MA`.&#34;&#34;&#34;
    return cache_dict[(window, int(ewm))]</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ma_caching_nb"><code class="name flex">
<span>def <span class="ident">ma_caching_nb</span></span>(<span>ts, windows, ewms)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled caching function for <code><a title="vectorbt.indicators.indicators.MA" href="#vectorbt.indicators.indicators.MA">MA</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], b1[:]), cache=True)
def ma_caching_nb(ts, windows, ewms):
    &#34;&#34;&#34;Numba-compiled caching function for `MA`.&#34;&#34;&#34;
    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                ma = timeseries.nb.ewm_mean_nb(ts, windows[i])
            else:
                ma = timeseries.nb.rolling_mean_nb(ts, windows[i])
            cache_dict[(windows[i], int(ewms[i]))] = ma
    return cache_dict</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.macd_apply_func_nb"><code class="name flex">
<span>def <span class="ident">macd_apply_func_nb</span></span>(<span>ts, fast_window, slow_window, signal_window, macd_ewm, signal_ewm, cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled apply function for <code><a title="vectorbt.indicators.indicators.MACD" href="#vectorbt.indicators.indicators.MACD">MACD</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(UniTuple(f8[:, :], 4)(f8[:, :], i8, i8, i8, b1, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def macd_apply_func_nb(ts, fast_window, slow_window, signal_window, macd_ewm, signal_ewm, cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `MACD`.&#34;&#34;&#34;
    fast_ma = cache_dict[(fast_window, int(macd_ewm))]
    slow_ma = cache_dict[(slow_window, int(macd_ewm))]
    macd_ts = fast_ma - slow_ma
    if signal_ewm:
        signal_ts = timeseries.nb.ewm_mean_nb(macd_ts, signal_window)
    else:
        signal_ts = timeseries.nb.rolling_mean_nb(macd_ts, signal_window)
    signal_ts[:max(fast_window, slow_window)+signal_window-2, :] = np.nan  # min_periodd
    return np.copy(fast_ma), np.copy(slow_ma), macd_ts, signal_ts</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.macd_caching_nb"><code class="name flex">
<span>def <span class="ident">macd_caching_nb</span></span>(<span>ts, fast_windows, slow_windows, signal_windows, macd_ewms, signal_ewms)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled caching function for <code><a title="vectorbt.indicators.indicators.MACD" href="#vectorbt.indicators.indicators.MACD">MACD</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], i8[:], i8[:], b1[:], b1[:]), cache=True)
def macd_caching_nb(ts, fast_windows, slow_windows, signal_windows, macd_ewms, signal_ewms):
    &#34;&#34;&#34;Numba-compiled caching function for `MACD`.&#34;&#34;&#34;
    return ma_caching_nb(ts, np.concatenate((fast_windows, slow_windows)), np.concatenate((macd_ewms, macd_ewms)))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.mstd_apply_func_nb"><code class="name flex">
<span>def <span class="ident">mstd_apply_func_nb</span></span>(<span>ts, window, ewm, cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled apply function for <code><a title="vectorbt.indicators.indicators.MSTD" href="#vectorbt.indicators.indicators.MSTD">MSTD</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(f8[:, :](f8[:, :], i8, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def mstd_apply_func_nb(ts, window, ewm, cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `MSTD`.&#34;&#34;&#34;
    return cache_dict[(window, int(ewm))]</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.mstd_caching_nb"><code class="name flex">
<span>def <span class="ident">mstd_caching_nb</span></span>(<span>ts, windows, ewms)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled caching function for <code><a title="vectorbt.indicators.indicators.MSTD" href="#vectorbt.indicators.indicators.MSTD">MSTD</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], b1[:]), cache=True)
def mstd_caching_nb(ts, windows, ewms):
    &#34;&#34;&#34;Numba-compiled caching function for `MSTD`.&#34;&#34;&#34;
    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                mstd = timeseries.nb.ewm_std_nb(ts, windows[i])
            else:
                mstd = timeseries.nb.rolling_std_nb(ts, windows[i])
            cache_dict[(windows[i], int(ewms[i]))] = mstd
    return cache_dict</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.obv_custom_func"><code class="name flex">
<span>def <span class="ident">obv_custom_func</span></span>(<span>close_ts, volume_ts)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom calculation function for <code><a title="vectorbt.indicators.indicators.OBV" href="#vectorbt.indicators.indicators.OBV">OBV</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def obv_custom_func(close_ts, volume_ts):
    &#34;&#34;&#34;Custom calculation function for `OBV`.&#34;&#34;&#34;
    return obv_custom_func_nb(close_ts.vbt.to_2d_array(), volume_ts.vbt.to_2d_array())</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.obv_custom_func_nb"><code class="name flex">
<span>def <span class="ident">obv_custom_func_nb</span></span>(<span>close_ts, volume_ts)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled custom calculation function for <code><a title="vectorbt.indicators.indicators.OBV" href="#vectorbt.indicators.indicators.OBV">OBV</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(f8[:, :](f8[:, :], f8[:, :]))
def obv_custom_func_nb(close_ts, volume_ts):
    &#34;&#34;&#34;Numba-compiled custom calculation function for `OBV`.&#34;&#34;&#34;
    obv = np.full_like(close_ts, np.nan)
    for col in range(close_ts.shape[1]):
        cumsum = 0
        for i in range(1, close_ts.shape[0]):
            if np.isnan(close_ts[i, col]) or np.isnan(close_ts[i-1, col]) or np.isnan(volume_ts[i, col]):
                continue
            if close_ts[i, col] &gt; close_ts[i-1, col]:
                cumsum += volume_ts[i, col]
            elif close_ts[i, col] &lt; close_ts[i-1, col]:
                cumsum += -volume_ts[i, col]
            obv[i, col] = cumsum
    return obv</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.rsi_apply_func_nb"><code class="name flex">
<span>def <span class="ident">rsi_apply_func_nb</span></span>(<span>ts, window, ewm, cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled apply function for <code><a title="vectorbt.indicators.indicators.RSI" href="#vectorbt.indicators.indicators.RSI">RSI</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(f8[:, :](f8[:, :], i8, b1, DictType(UniTuple(i8, 2), UniTuple(f8[:, :], 2))), cache=True)
def rsi_apply_func_nb(ts, window, ewm, cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `RSI`.&#34;&#34;&#34;
    roll_up, roll_down = cache_dict[(window, int(ewm))]
    return 100 - 100 / (1 + roll_up / roll_down)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.rsi_caching_nb"><code class="name flex">
<span>def <span class="ident">rsi_caching_nb</span></span>(<span>ts, windows, ewms)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled caching function for <code><a title="vectorbt.indicators.indicators.RSI" href="#vectorbt.indicators.indicators.RSI">RSI</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(DictType(UniTuple(i8, 2), UniTuple(f8[:, :], 2))(f8[:, :], i8[:], b1[:]), cache=True)
def rsi_caching_nb(ts, windows, ewms):
    &#34;&#34;&#34;Numba-compiled caching function for `RSI`.&#34;&#34;&#34;
    delta = timeseries.nb.diff_nb(ts)[1:, :]  # otherwise ewma will be all NaN
    up, down = delta.copy(), delta.copy()
    up = timeseries.nb.set_by_mask_nb(up, up &lt; 0, 0)
    down = np.abs(timeseries.nb.set_by_mask_nb(down, down &gt; 0, 0))
    # Cache
    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                roll_up = timeseries.nb.ewm_mean_nb(up, windows[i])
                roll_down = timeseries.nb.ewm_mean_nb(down, windows[i])
            else:
                roll_up = timeseries.nb.rolling_mean_nb(up, windows[i])
                roll_down = timeseries.nb.rolling_mean_nb(down, windows[i])
            roll_up = timeseries.nb.prepend_nb(roll_up, 1, np.nan)  # bring to old shape
            roll_down = timeseries.nb.prepend_nb(roll_down, 1, np.nan)
            cache_dict[(windows[i], int(ewms[i]))] = roll_up, roll_down
    return cache_dict</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.stoch_apply_func_nb"><code class="name flex">
<span>def <span class="ident">stoch_apply_func_nb</span></span>(<span>close_ts, high_ts, low_ts, k_window, d_window, d_ewm, cache_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled apply function for <code><a title="vectorbt.indicators.indicators.Stochastic" href="#vectorbt.indicators.indicators.Stochastic">Stochastic</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(UniTuple(f8[:, :], 2)(f8[:, :], f8[:, :], f8[:, :], i8, i8, b1, DictType(i8, UniTuple(f8[:, :], 2))), cache=True)
def stoch_apply_func_nb(close_ts, high_ts, low_ts, k_window, d_window, d_ewm, cache_dict):
    &#34;&#34;&#34;Numba-compiled apply function for `Stochastic`.&#34;&#34;&#34;
    roll_min, roll_max = cache_dict[k_window]
    percent_k = 100 * (close_ts - roll_min) / (roll_max - roll_min)
    if d_ewm:
        percent_d = timeseries.nb.ewm_mean_nb(percent_k, d_window)
    else:
        percent_d = timeseries.nb.rolling_mean_nb(percent_k, d_window)
    percent_d[:k_window+d_window-2, :] = np.nan  # min_periods
    return percent_k, percent_d</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.stoch_caching_nb"><code class="name flex">
<span>def <span class="ident">stoch_caching_nb</span></span>(<span>close_ts, high_ts, low_ts, k_windows, d_windows, d_ewms)</span>
</code></dt>
<dd>
<div class="desc"><p>Numba-compiled caching function for <code><a title="vectorbt.indicators.indicators.Stochastic" href="#vectorbt.indicators.indicators.Stochastic">Stochastic</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(DictType(i8, UniTuple(f8[:, :], 2))(f8[:, :], f8[:, :], f8[:, :], i8[:], i8[:], b1[:]), cache=True)
def stoch_caching_nb(close_ts, high_ts, low_ts, k_windows, d_windows, d_ewms):
    &#34;&#34;&#34;Numba-compiled caching function for `Stochastic`.&#34;&#34;&#34;
    cache_dict = dict()
    for i in range(k_windows.shape[0]):
        if k_windows[i] not in cache_dict:
            roll_min = timeseries.nb.rolling_min_nb(low_ts, k_windows[i])
            roll_max = timeseries.nb.rolling_max_nb(high_ts, k_windows[i])
            cache_dict[k_windows[i]] = roll_min, roll_max
    return cache_dict</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.indicators.indicators.ATR"><code class="flex name class">
<span>class <span class="ident">ATR</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The average true range (ATR) is a technical analysis indicator that measures market volatility
by decomposing the entire range of an asset price for that period.</p>
<p>See <a href="https://www.investopedia.com/terms/a/atr.asp">Average True Range - ATR</a>.</p>
<p>Use <code><a title="vectorbt.indicators.indicators.ATR.from_params" href="#vectorbt.indicators.indicators.ATR.from_params">ATR.from_params()</a></code> method to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ATR(ATR):
    &#34;&#34;&#34;The average true range (ATR) is a technical analysis indicator that measures market volatility 
    by decomposing the entire range of an asset price for that period.

    See [Average True Range - ATR](https://www.investopedia.com/terms/a/atr.asp).

    Use `ATR.from_params` method to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, close_ts, high_ts, low_ts, window, ewm=True, **kwargs):
        &#34;&#34;&#34;Calculate true range `ATR.tr` and average true range `ATR.atr` from time series `close_ts`, 
        `high_ts`, and `low_ts`, and parameters `window` and `ewm`.

        Args:
            close_ts (pandas_like): The last closing price.
            high_ts (pandas_like, optional): The highest price. If None, uses `close_ts`.
            low_ts (pandas_like, optional): The lowest price. If None, uses `close_ts`.
            window (int or array_like): Size of the moving window. Can be one or more values. 
                Defaults to 14.
            ewm (bool or array_like): If True, uses exponential moving average, otherwise 
                simple moving average. Can be one or more values. Defaults to True.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            ATR
        Examples:
            ```python-repl
            &gt;&gt;&gt; atr = vbt.ATR.from_params(price[&#39;Close&#39;], 
            ...     price[&#39;High&#39;], price[&#39;Low&#39;], [20, 30], [False, True])

            &gt;&gt;&gt; print(atr.tr)
            atr_window      20      30
            atr_ewm      False    True
            Date                      
            2019-02-28   60.24   60.24
            2019-03-01   56.11   56.11
            2019-03-02   42.48   42.48
            ...            ...     ...
            2019-08-29  335.16  335.16
            2019-08-30  227.82  227.82
            2019-08-31  141.42  141.42

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(atr.atr)
            atr_window        20          30
            atr_ewm        False        True
            Date                            
            2019-02-28       NaN         NaN
            2019-03-01       NaN         NaN
            2019-03-02       NaN         NaN
            ...              ...         ...
            2019-08-29  476.9385  491.469062
            2019-08-30  458.7415  474.459365
            2019-08-31  452.0480  452.972860

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        return super().from_params(close_ts, high_ts, low_ts, window, ewm, **kwargs)

    def plot(self,
             tr_trace_kwargs={},
             atr_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `ATR.tr` and `ATR.atr`.

        Args:
            tr_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for `ATR.tr`.
            atr_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for `ATR.atr`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            atr[(10, False)].plot()
            ```

            ![](img/ATR.png)&#34;&#34;&#34;
        checks.assert_type(self.tr, pd.Series)
        checks.assert_type(self.atr, pd.Series)

        tr_trace_kwargs = {**dict(
            name=f&#39;TR ({self.name})&#39;
        ), **tr_trace_kwargs}
        atr_trace_kwargs = {**dict(
            name=f&#39;ATR ({self.name})&#39;
        ), **atr_trace_kwargs}

        fig = self.tr.vbt.timeseries.plot(trace_kwargs=tr_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.atr.vbt.timeseries.plot(trace_kwargs=atr_trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.factory.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.ATR.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>close_ts, high_ts, low_ts, window, ewm=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate true range <code><a title="vectorbt.indicators.indicators.ATR.tr" href="#vectorbt.indicators.indicators.ATR.tr">ATR.tr</a></code> and average true range <code><a title="vectorbt.indicators.indicators.ATR.atr" href="#vectorbt.indicators.indicators.ATR.atr">ATR.atr</a></code> from time series <code>close_ts</code>,
<code>high_ts</code>, and <code>low_ts</code>, and parameters <code>window</code> and <code>ewm</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>close_ts</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>The last closing price.</dd>
<dt><strong><code>high_ts</code></strong> :&ensp;<code>pandas_like</code>, optional</dt>
<dd>The highest price. If None, uses <code>close_ts</code>.</dd>
<dt><strong><code>low_ts</code></strong> :&ensp;<code>pandas_like</code>, optional</dt>
<dd>The lowest price. If None, uses <code>close_ts</code>.</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Size of the moving window. Can be one or more values.
Defaults to 14.</dd>
<dt><strong><code>ewm</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>If True, uses exponential moving average, otherwise
simple moving average. Can be one or more values. Defaults to True.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.indicators.factory.from_params_pipeline" href="factory.html#vectorbt.indicators.factory.from_params_pipeline">from_params_pipeline()</a>.</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.indicators.indicators.ATR" href="#vectorbt.indicators.indicators.ATR">ATR</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; atr = vbt.ATR.from_params(price['Close'], 
...     price['High'], price['Low'], [20, 30], [False, True])

&gt;&gt;&gt; print(atr.tr)
atr_window      20      30
atr_ewm      False    True
Date                      
2019-02-28   60.24   60.24
2019-03-01   56.11   56.11
2019-03-02   42.48   42.48
...            ...     ...
2019-08-29  335.16  335.16
2019-08-30  227.82  227.82
2019-08-31  141.42  141.42

[185 rows x 2 columns]

&gt;&gt;&gt; print(atr.atr)
atr_window        20          30
atr_ewm        False        True
Date                            
2019-02-28       NaN         NaN
2019-03-01       NaN         NaN
2019-03-02       NaN         NaN
...              ...         ...
2019-08-29  476.9385  491.469062
2019-08-30  458.7415  474.459365
2019-08-31  452.0480  452.972860

[185 rows x 2 columns]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, close_ts, high_ts, low_ts, window, ewm=True, **kwargs):
    &#34;&#34;&#34;Calculate true range `ATR.tr` and average true range `ATR.atr` from time series `close_ts`, 
    `high_ts`, and `low_ts`, and parameters `window` and `ewm`.

    Args:
        close_ts (pandas_like): The last closing price.
        high_ts (pandas_like, optional): The highest price. If None, uses `close_ts`.
        low_ts (pandas_like, optional): The lowest price. If None, uses `close_ts`.
        window (int or array_like): Size of the moving window. Can be one or more values. 
            Defaults to 14.
        ewm (bool or array_like): If True, uses exponential moving average, otherwise 
            simple moving average. Can be one or more values. Defaults to True.
        **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
    Returns:
        ATR
    Examples:
        ```python-repl
        &gt;&gt;&gt; atr = vbt.ATR.from_params(price[&#39;Close&#39;], 
        ...     price[&#39;High&#39;], price[&#39;Low&#39;], [20, 30], [False, True])

        &gt;&gt;&gt; print(atr.tr)
        atr_window      20      30
        atr_ewm      False    True
        Date                      
        2019-02-28   60.24   60.24
        2019-03-01   56.11   56.11
        2019-03-02   42.48   42.48
        ...            ...     ...
        2019-08-29  335.16  335.16
        2019-08-30  227.82  227.82
        2019-08-31  141.42  141.42

        [185 rows x 2 columns]

        &gt;&gt;&gt; print(atr.atr)
        atr_window        20          30
        atr_ewm        False        True
        Date                            
        2019-02-28       NaN         NaN
        2019-03-01       NaN         NaN
        2019-03-02       NaN         NaN
        ...              ...         ...
        2019-08-29  476.9385  491.469062
        2019-08-30  458.7415  474.459365
        2019-08-31  452.0480  452.972860

        [185 rows x 2 columns]
        ```
    &#34;&#34;&#34;
    return super().from_params(close_ts, high_ts, low_ts, window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.indicators.ATR.atr"><code class="name">var <span class="ident">atr</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.close_ts"><code class="name">var <span class="ident">close_ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.ewm_loc"><code class="name">var <span class="ident">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.high_ts"><code class="name">var <span class="ident">high_ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.low_ts"><code class="name">var <span class="ident">low_ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.tr"><code class="name">var <span class="ident">tr</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.tuple_loc"><code class="name">var <span class="ident">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter tuple using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.window_loc"><code class="name">var <span class="ident">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.ATR.atr_above"><code class="name flex">
<span>def <span class="ident">atr_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>atr</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>atr</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.atr_below"><code class="name flex">
<span>def <span class="ident">atr_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>atr</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>atr</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.atr_equal"><code class="name flex">
<span>def <span class="ident">atr_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>atr</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>atr</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.close_ts_above"><code class="name flex">
<span>def <span class="ident">close_ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.close_ts_below"><code class="name flex">
<span>def <span class="ident">close_ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.close_ts_equal"><code class="name flex">
<span>def <span class="ident">close_ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.high_ts_above"><code class="name flex">
<span>def <span class="ident">high_ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>high_ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high_ts</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.high_ts_below"><code class="name flex">
<span>def <span class="ident">high_ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>high_ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high_ts</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.high_ts_equal"><code class="name flex">
<span>def <span class="ident">high_ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>high_ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high_ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.low_ts_above"><code class="name flex">
<span>def <span class="ident">low_ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>low_ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low_ts</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.low_ts_below"><code class="name flex">
<span>def <span class="ident">low_ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>low_ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low_ts</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.low_ts_equal"><code class="name flex">
<span>def <span class="ident">low_ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>low_ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low_ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, tr_trace_kwargs={}, atr_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.indicators.ATR.tr" href="#vectorbt.indicators.indicators.ATR.tr">ATR.tr</a></code> and <code><a title="vectorbt.indicators.indicators.ATR.atr" href="#vectorbt.indicators.indicators.ATR.atr">ATR.atr</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tr_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> for <code><a title="vectorbt.indicators.indicators.ATR.tr" href="#vectorbt.indicators.indicators.ATR.tr">ATR.tr</a></code>.</dd>
<dt><strong><code>atr_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> for <code><a title="vectorbt.indicators.indicators.ATR.atr" href="#vectorbt.indicators.indicators.ATR.atr">ATR.atr</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code>, optional</dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.widgets.common.FigureWidget" href="../widgets/common.html#vectorbt.widgets.common.FigureWidget">FigureWidget</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="py">atr[(10, False)].plot()
</code></pre>
<p><img alt="" src="img/ATR.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         tr_trace_kwargs={},
         atr_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    &#34;&#34;&#34;Plot `ATR.tr` and `ATR.atr`.

    Args:
        tr_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for `ATR.tr`.
        atr_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for `ATR.atr`.
        fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Returns:
        vectorbt.widgets.common.FigureWidget
    Examples:
        ```py
        atr[(10, False)].plot()
        ```

        ![](img/ATR.png)&#34;&#34;&#34;
    checks.assert_type(self.tr, pd.Series)
    checks.assert_type(self.atr, pd.Series)

    tr_trace_kwargs = {**dict(
        name=f&#39;TR ({self.name})&#39;
    ), **tr_trace_kwargs}
    atr_trace_kwargs = {**dict(
        name=f&#39;ATR ({self.name})&#39;
    ), **atr_trace_kwargs}

    fig = self.tr.vbt.timeseries.plot(trace_kwargs=tr_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.atr.vbt.timeseries.plot(trace_kwargs=atr_trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.tr_above"><code class="name flex">
<span>def <span class="ident">tr_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>tr</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>tr</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.tr_below"><code class="name flex">
<span>def <span class="ident">tr_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>tr</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>tr</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.tr_equal"><code class="name flex">
<span>def <span class="ident">tr_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>tr</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>tr</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.ATR.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands"><code class="flex name class">
<span>class <span class="ident">BollingerBands</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A Bollinger Band® is a technical analysis tool defined by a set of lines plotted two standard
deviations (positively and negatively) away from a simple moving average (SMA) of the security's
price, but can be adjusted to user preferences.</p>
<p>See <a href="https://www.investopedia.com/terms/b/bollingerbands.asp">Bollinger Band®</a>.</p>
<p>Use <code><a title="vectorbt.indicators.indicators.BollingerBands.from_params" href="#vectorbt.indicators.indicators.BollingerBands.from_params">BollingerBands.from_params()</a></code> method to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BollingerBands(BollingerBands):
    &#34;&#34;&#34;A Bollinger Band® is a technical analysis tool defined by a set of lines plotted two standard 
    deviations (positively and negatively) away from a simple moving average (SMA) of the security&#39;s 
    price, but can be adjusted to user preferences.

    See [Bollinger Band®](https://www.investopedia.com/terms/b/bollingerbands.asp).

    Use `BollingerBands.from_params` method to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, ts, window=20, ewm=False, alpha=2, **kwargs):
        &#34;&#34;&#34;Calculate moving average `BollingerBands.ma`, upper Bollinger Band `BollingerBands.upper_band`,
        lower Bollinger Band `BollingerBands.lower_band`, %b `BollingerBands.percent_b` and 
        bandwidth `BollingerBands.bandwidth` from time series `ts` and parameters `window`, `ewm` and `alpha`.

        Args:
            ts (pandas_like): Time series (such as price).
            window (int or array_like): Size of the moving window. Can be one or more values.
                Defaults to 20.
            ewm (bool or array_like): If True, uses exponential moving average and standard deviation, 
                otherwise uses simple moving average and standard deviation. Can be one or more values. 
                Defaults to False.
            alpha (int, float or array_like): Number of standard deviations. Can be one or more values. Defaults to 2.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            BollingerBands
        Examples:
            ```python-repl
            &gt;&gt;&gt; bb = vbt.BollingerBands.from_params(price[&#39;Close&#39;], 
            ...     window=[10, 20], alpha=[2, 3], ewm=[False, True])

            &gt;&gt;&gt; print(bb.ma)
            bb_window          10            20
            bb_ewm          False          True
            bb_alpha          2.0           3.0
            Date                               
            2019-02-28        NaN           NaN
            2019-03-01        NaN           NaN
            2019-03-02        NaN           NaN
            ...               ...           ...
            2019-08-29  10155.972  10330.457140
            2019-08-30  10039.466  10260.715507
            2019-08-31   9988.727  10200.710220

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(bb.upper_band)
            bb_window             10            20
            bb_ewm             False          True
            bb_alpha             2.0           3.0
            Date                                  
            2019-02-28           NaN           NaN
            2019-03-01           NaN           NaN
            2019-03-02           NaN           NaN
            ...                  ...           ...
            2019-08-29  10841.965056  12140.030938
            2019-08-30  10659.668073  12104.745144
            2019-08-31  10654.433961  12044.795485

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(bb.lower_band)
            bb_window            10           20
            bb_ewm            False         True
            bb_alpha            2.0          3.0
            Date                                
            2019-02-28          NaN          NaN
            2019-03-01          NaN          NaN
            2019-03-02          NaN          NaN
            ...                 ...          ...
            2019-08-29  9469.978944  8520.883342
            2019-08-30  9419.263927  8416.685869
            2019-08-31  9323.020039  8356.624955

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(bb.percent_b)
            bb_window         10        20
            bb_ewm         False      True
            bb_alpha         2.0       3.0
            Date                          
            2019-02-28       NaN       NaN
            2019-03-01       NaN       NaN
            2019-03-02       NaN       NaN
            ...              ...       ...
            2019-08-29  0.029316  0.273356
            2019-08-30  0.144232  0.320354
            2019-08-31  0.231063  0.345438

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(bb.bandwidth)
            bb_window         10        20
            bb_ewm         False      True
            bb_alpha         2.0       3.0
            Date                          
            2019-02-28       NaN       NaN
            2019-03-01       NaN       NaN
            2019-03-02       NaN       NaN
            2019-03-03       NaN       NaN
            2019-03-04       NaN       NaN
            ...              ...       ...
            2019-08-27  0.107370  0.313212
            2019-08-28  0.130902  0.325698
            2019-08-29  0.135092  0.350338
            2019-08-30  0.123553  0.359435
            2019-08-31  0.133292  0.361560

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        alpha = np.asarray(alpha).astype(np.float64)
        return super().from_params(ts, window, ewm, alpha, **kwargs)

    def plot(self,
             ts_trace_kwargs={},
             ma_trace_kwargs={},
             upper_band_trace_kwargs={},
             lower_band_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `BollingerBands.ma`, `BollingerBands.upper_band` and `BollingerBands.lower_band` against 
        `BollingerBands.ts`.

        Args:
            ts_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `BollingerBands.ts`.
            ma_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `BollingerBands.ma`.
            upper_band_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `BollingerBands.upper_band`.
            lower_band_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `BollingerBands.lower_band`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            bb[(10, False, 2)].plot()
            ```

            ![](img/BollingerBands.png)&#34;&#34;&#34;
        checks.assert_type(self.ts, pd.Series)
        checks.assert_type(self.ma, pd.Series)
        checks.assert_type(self.upper_band, pd.Series)
        checks.assert_type(self.lower_band, pd.Series)

        lower_band_trace_kwargs = {**dict(
            name=f&#39;Lower Band ({self.name})&#39;,
            line=dict(color=&#39;grey&#39;, width=0),
            showlegend=False
        ), **lower_band_trace_kwargs}
        upper_band_trace_kwargs = {**dict(
            name=f&#39;Upper Band ({self.name})&#39;,
            line=dict(color=&#39;grey&#39;, width=0),
            fill=&#39;tonexty&#39;,
            fillcolor=&#39;rgba(128, 128, 128, 0.25)&#39;,
            showlegend=False
        ), **upper_band_trace_kwargs}  # default kwargs
        ma_trace_kwargs = {**dict(
            name=f&#39;MA ({self.name})&#39;,
            line=dict(color=defaults.layout[&#39;colorway&#39;][1])
        ), **ma_trace_kwargs}
        ts_trace_kwargs = {**dict(
            name=f&#39;Price ({self.name})&#39;,
            line=dict(color=defaults.layout[&#39;colorway&#39;][0])
        ), **ts_trace_kwargs}

        fig = self.lower_band.vbt.timeseries.plot(trace_kwargs=lower_band_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.upper_band.vbt.timeseries.plot(trace_kwargs=upper_band_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.ma.vbt.timeseries.plot(trace_kwargs=ma_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.ts.vbt.timeseries.plot(trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.factory.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.BollingerBands.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, window=20, ewm=False, alpha=2, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate moving average <code><a title="vectorbt.indicators.indicators.BollingerBands.ma" href="#vectorbt.indicators.indicators.BollingerBands.ma">BollingerBands.ma</a></code>, upper Bollinger Band <code><a title="vectorbt.indicators.indicators.BollingerBands.upper_band" href="#vectorbt.indicators.indicators.BollingerBands.upper_band">BollingerBands.upper_band</a></code>,
lower Bollinger Band <code><a title="vectorbt.indicators.indicators.BollingerBands.lower_band" href="#vectorbt.indicators.indicators.BollingerBands.lower_band">BollingerBands.lower_band</a></code>, %b <code><a title="vectorbt.indicators.indicators.BollingerBands.percent_b" href="#vectorbt.indicators.indicators.BollingerBands.percent_b">BollingerBands.percent_b</a></code> and
bandwidth <code><a title="vectorbt.indicators.indicators.BollingerBands.bandwidth" href="#vectorbt.indicators.indicators.BollingerBands.bandwidth">BollingerBands.bandwidth</a></code> from time series <code>ts</code> and parameters <code>window</code>, <code>ewm</code> and <code>alpha</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Time series (such as price).</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Size of the moving window. Can be one or more values.
Defaults to 20.</dd>
<dt><strong><code>ewm</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>If True, uses exponential moving average and standard deviation,
otherwise uses simple moving average and standard deviation. Can be one or more values.
Defaults to False.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>int, float</code> or <code>array_like</code></dt>
<dd>Number of standard deviations. Can be one or more values. Defaults to 2.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.indicators.factory.from_params_pipeline" href="factory.html#vectorbt.indicators.factory.from_params_pipeline">from_params_pipeline()</a>.</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.indicators.indicators.BollingerBands" href="#vectorbt.indicators.indicators.BollingerBands">BollingerBands</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; bb = vbt.BollingerBands.from_params(price['Close'], 
...     window=[10, 20], alpha=[2, 3], ewm=[False, True])

&gt;&gt;&gt; print(bb.ma)
bb_window          10            20
bb_ewm          False          True
bb_alpha          2.0           3.0
Date                               
2019-02-28        NaN           NaN
2019-03-01        NaN           NaN
2019-03-02        NaN           NaN
...               ...           ...
2019-08-29  10155.972  10330.457140
2019-08-30  10039.466  10260.715507
2019-08-31   9988.727  10200.710220

[185 rows x 2 columns]

&gt;&gt;&gt; print(bb.upper_band)
bb_window             10            20
bb_ewm             False          True
bb_alpha             2.0           3.0
Date                                  
2019-02-28           NaN           NaN
2019-03-01           NaN           NaN
2019-03-02           NaN           NaN
...                  ...           ...
2019-08-29  10841.965056  12140.030938
2019-08-30  10659.668073  12104.745144
2019-08-31  10654.433961  12044.795485

[185 rows x 2 columns]

&gt;&gt;&gt; print(bb.lower_band)
bb_window            10           20
bb_ewm            False         True
bb_alpha            2.0          3.0
Date                                
2019-02-28          NaN          NaN
2019-03-01          NaN          NaN
2019-03-02          NaN          NaN
...                 ...          ...
2019-08-29  9469.978944  8520.883342
2019-08-30  9419.263927  8416.685869
2019-08-31  9323.020039  8356.624955

[185 rows x 2 columns]

&gt;&gt;&gt; print(bb.percent_b)
bb_window         10        20
bb_ewm         False      True
bb_alpha         2.0       3.0
Date                          
2019-02-28       NaN       NaN
2019-03-01       NaN       NaN
2019-03-02       NaN       NaN
...              ...       ...
2019-08-29  0.029316  0.273356
2019-08-30  0.144232  0.320354
2019-08-31  0.231063  0.345438

[185 rows x 2 columns]

&gt;&gt;&gt; print(bb.bandwidth)
bb_window         10        20
bb_ewm         False      True
bb_alpha         2.0       3.0
Date                          
2019-02-28       NaN       NaN
2019-03-01       NaN       NaN
2019-03-02       NaN       NaN
2019-03-03       NaN       NaN
2019-03-04       NaN       NaN
...              ...       ...
2019-08-27  0.107370  0.313212
2019-08-28  0.130902  0.325698
2019-08-29  0.135092  0.350338
2019-08-30  0.123553  0.359435
2019-08-31  0.133292  0.361560

[185 rows x 2 columns]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, window=20, ewm=False, alpha=2, **kwargs):
    &#34;&#34;&#34;Calculate moving average `BollingerBands.ma`, upper Bollinger Band `BollingerBands.upper_band`,
    lower Bollinger Band `BollingerBands.lower_band`, %b `BollingerBands.percent_b` and 
    bandwidth `BollingerBands.bandwidth` from time series `ts` and parameters `window`, `ewm` and `alpha`.

    Args:
        ts (pandas_like): Time series (such as price).
        window (int or array_like): Size of the moving window. Can be one or more values.
            Defaults to 20.
        ewm (bool or array_like): If True, uses exponential moving average and standard deviation, 
            otherwise uses simple moving average and standard deviation. Can be one or more values. 
            Defaults to False.
        alpha (int, float or array_like): Number of standard deviations. Can be one or more values. Defaults to 2.
        **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
    Returns:
        BollingerBands
    Examples:
        ```python-repl
        &gt;&gt;&gt; bb = vbt.BollingerBands.from_params(price[&#39;Close&#39;], 
        ...     window=[10, 20], alpha=[2, 3], ewm=[False, True])

        &gt;&gt;&gt; print(bb.ma)
        bb_window          10            20
        bb_ewm          False          True
        bb_alpha          2.0           3.0
        Date                               
        2019-02-28        NaN           NaN
        2019-03-01        NaN           NaN
        2019-03-02        NaN           NaN
        ...               ...           ...
        2019-08-29  10155.972  10330.457140
        2019-08-30  10039.466  10260.715507
        2019-08-31   9988.727  10200.710220

        [185 rows x 2 columns]

        &gt;&gt;&gt; print(bb.upper_band)
        bb_window             10            20
        bb_ewm             False          True
        bb_alpha             2.0           3.0
        Date                                  
        2019-02-28           NaN           NaN
        2019-03-01           NaN           NaN
        2019-03-02           NaN           NaN
        ...                  ...           ...
        2019-08-29  10841.965056  12140.030938
        2019-08-30  10659.668073  12104.745144
        2019-08-31  10654.433961  12044.795485

        [185 rows x 2 columns]

        &gt;&gt;&gt; print(bb.lower_band)
        bb_window            10           20
        bb_ewm            False         True
        bb_alpha            2.0          3.0
        Date                                
        2019-02-28          NaN          NaN
        2019-03-01          NaN          NaN
        2019-03-02          NaN          NaN
        ...                 ...          ...
        2019-08-29  9469.978944  8520.883342
        2019-08-30  9419.263927  8416.685869
        2019-08-31  9323.020039  8356.624955

        [185 rows x 2 columns]

        &gt;&gt;&gt; print(bb.percent_b)
        bb_window         10        20
        bb_ewm         False      True
        bb_alpha         2.0       3.0
        Date                          
        2019-02-28       NaN       NaN
        2019-03-01       NaN       NaN
        2019-03-02       NaN       NaN
        ...              ...       ...
        2019-08-29  0.029316  0.273356
        2019-08-30  0.144232  0.320354
        2019-08-31  0.231063  0.345438

        [185 rows x 2 columns]

        &gt;&gt;&gt; print(bb.bandwidth)
        bb_window         10        20
        bb_ewm         False      True
        bb_alpha         2.0       3.0
        Date                          
        2019-02-28       NaN       NaN
        2019-03-01       NaN       NaN
        2019-03-02       NaN       NaN
        2019-03-03       NaN       NaN
        2019-03-04       NaN       NaN
        ...              ...       ...
        2019-08-27  0.107370  0.313212
        2019-08-28  0.130902  0.325698
        2019-08-29  0.135092  0.350338
        2019-08-30  0.123553  0.359435
        2019-08-31  0.133292  0.361560

        [185 rows x 2 columns]
        ```
    &#34;&#34;&#34;
    alpha = np.asarray(alpha).astype(np.float64)
    return super().from_params(ts, window, ewm, alpha, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.indicators.BollingerBands.alpha_loc"><code class="name">var <span class="ident">alpha_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter alpha using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.bandwidth"><code class="name">var <span class="ident">bandwidth</span></code></dt>
<dd>
<div class="desc"><p>Custom property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">bandwidth=lambda self: self.ts.vbt.wrap_array(
    (self.upper_band.values - self.lower_band.values) / self.ma.values)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.ewm_loc"><code class="name">var <span class="ident">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.lower_band"><code class="name">var <span class="ident">lower_band</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.ma"><code class="name">var <span class="ident">ma</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.percent_b"><code class="name">var <span class="ident">percent_b</span></code></dt>
<dd>
<div class="desc"><p>Custom property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">percent_b=lambda self: self.ts.vbt.wrap_array(
    (self.ts.values - self.lower_band.values) / (self.upper_band.values - self.lower_band.values)),</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.ts"><code class="name">var <span class="ident">ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.tuple_loc"><code class="name">var <span class="ident">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter tuple using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.upper_band"><code class="name">var <span class="ident">upper_band</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.window_loc"><code class="name">var <span class="ident">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.BollingerBands.bandwidth_above"><code class="name flex">
<span>def <span class="ident">bandwidth_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>bandwidth</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>bandwidth</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.bandwidth_below"><code class="name flex">
<span>def <span class="ident">bandwidth_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>bandwidth</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>bandwidth</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.bandwidth_equal"><code class="name flex">
<span>def <span class="ident">bandwidth_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>bandwidth</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>bandwidth</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.lower_band_above"><code class="name flex">
<span>def <span class="ident">lower_band_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>lower_band</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>lower_band</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.lower_band_below"><code class="name flex">
<span>def <span class="ident">lower_band_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>lower_band</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>lower_band</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.lower_band_equal"><code class="name flex">
<span>def <span class="ident">lower_band_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>lower_band</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>lower_band</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.ma_above"><code class="name flex">
<span>def <span class="ident">ma_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ma</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.ma_below"><code class="name flex">
<span>def <span class="ident">ma_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ma</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.ma_equal"><code class="name flex">
<span>def <span class="ident">ma_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ma</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.percent_b_above"><code class="name flex">
<span>def <span class="ident">percent_b_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_b</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_b</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.percent_b_below"><code class="name flex">
<span>def <span class="ident">percent_b_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_b</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_b</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.percent_b_equal"><code class="name flex">
<span>def <span class="ident">percent_b_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_b</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_b</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, ts_trace_kwargs={}, ma_trace_kwargs={}, upper_band_trace_kwargs={}, lower_band_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.indicators.BollingerBands.ma" href="#vectorbt.indicators.indicators.BollingerBands.ma">BollingerBands.ma</a></code>, <code><a title="vectorbt.indicators.indicators.BollingerBands.upper_band" href="#vectorbt.indicators.indicators.BollingerBands.upper_band">BollingerBands.upper_band</a></code> and <code><a title="vectorbt.indicators.indicators.BollingerBands.lower_band" href="#vectorbt.indicators.indicators.BollingerBands.lower_band">BollingerBands.lower_band</a></code> against
<code><a title="vectorbt.indicators.indicators.BollingerBands.ts" href="#vectorbt.indicators.indicators.BollingerBands.ts">BollingerBands.ts</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of
<code><a title="vectorbt.indicators.indicators.BollingerBands.ts" href="#vectorbt.indicators.indicators.BollingerBands.ts">BollingerBands.ts</a></code>.</dd>
<dt><strong><code>ma_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of
<code><a title="vectorbt.indicators.indicators.BollingerBands.ma" href="#vectorbt.indicators.indicators.BollingerBands.ma">BollingerBands.ma</a></code>.</dd>
<dt><strong><code>upper_band_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of
<code><a title="vectorbt.indicators.indicators.BollingerBands.upper_band" href="#vectorbt.indicators.indicators.BollingerBands.upper_band">BollingerBands.upper_band</a></code>.</dd>
<dt><strong><code>lower_band_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of
<code><a title="vectorbt.indicators.indicators.BollingerBands.lower_band" href="#vectorbt.indicators.indicators.BollingerBands.lower_band">BollingerBands.lower_band</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code>, optional</dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.widgets.common.FigureWidget" href="../widgets/common.html#vectorbt.widgets.common.FigureWidget">FigureWidget</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="py">bb[(10, False, 2)].plot()
</code></pre>
<p><img alt="" src="img/BollingerBands.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         ts_trace_kwargs={},
         ma_trace_kwargs={},
         upper_band_trace_kwargs={},
         lower_band_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    &#34;&#34;&#34;Plot `BollingerBands.ma`, `BollingerBands.upper_band` and `BollingerBands.lower_band` against 
    `BollingerBands.ts`.

    Args:
        ts_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
            `BollingerBands.ts`.
        ma_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
            `BollingerBands.ma`.
        upper_band_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
            `BollingerBands.upper_band`.
        lower_band_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
            `BollingerBands.lower_band`.
        fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Returns:
        vectorbt.widgets.common.FigureWidget
    Examples:
        ```py
        bb[(10, False, 2)].plot()
        ```

        ![](img/BollingerBands.png)&#34;&#34;&#34;
    checks.assert_type(self.ts, pd.Series)
    checks.assert_type(self.ma, pd.Series)
    checks.assert_type(self.upper_band, pd.Series)
    checks.assert_type(self.lower_band, pd.Series)

    lower_band_trace_kwargs = {**dict(
        name=f&#39;Lower Band ({self.name})&#39;,
        line=dict(color=&#39;grey&#39;, width=0),
        showlegend=False
    ), **lower_band_trace_kwargs}
    upper_band_trace_kwargs = {**dict(
        name=f&#39;Upper Band ({self.name})&#39;,
        line=dict(color=&#39;grey&#39;, width=0),
        fill=&#39;tonexty&#39;,
        fillcolor=&#39;rgba(128, 128, 128, 0.25)&#39;,
        showlegend=False
    ), **upper_band_trace_kwargs}  # default kwargs
    ma_trace_kwargs = {**dict(
        name=f&#39;MA ({self.name})&#39;,
        line=dict(color=defaults.layout[&#39;colorway&#39;][1])
    ), **ma_trace_kwargs}
    ts_trace_kwargs = {**dict(
        name=f&#39;Price ({self.name})&#39;,
        line=dict(color=defaults.layout[&#39;colorway&#39;][0])
    ), **ts_trace_kwargs}

    fig = self.lower_band.vbt.timeseries.plot(trace_kwargs=lower_band_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.upper_band.vbt.timeseries.plot(trace_kwargs=upper_band_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.ma.vbt.timeseries.plot(trace_kwargs=ma_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.ts.vbt.timeseries.plot(trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.ts_above"><code class="name flex">
<span>def <span class="ident">ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.ts_below"><code class="name flex">
<span>def <span class="ident">ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.ts_equal"><code class="name flex">
<span>def <span class="ident">ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.upper_band_above"><code class="name flex">
<span>def <span class="ident">upper_band_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>upper_band</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>upper_band</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.upper_band_below"><code class="name flex">
<span>def <span class="ident">upper_band_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>upper_band</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>upper_band</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.upper_band_equal"><code class="name flex">
<span>def <span class="ident">upper_band_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>upper_band</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>upper_band</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.BollingerBands.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.indicators.MA"><code class="flex name class">
<span>class <span class="ident">MA</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A moving average (MA) is a widely used indicator in technical analysis that helps smooth out
price action by filtering out the “noise” from random short-term price fluctuations. </p>
<p>See <a href="https://www.investopedia.com/terms/m/movingaverage.asp">Moving Average (MA)</a>.</p>
<p>Use <code><a title="vectorbt.indicators.indicators.MA.from_params" href="#vectorbt.indicators.indicators.MA.from_params">MA.from_params()</a></code> or <code><a title="vectorbt.indicators.indicators.MA.from_combinations" href="#vectorbt.indicators.indicators.MA.from_combinations">MA.from_combinations()</a></code> methods to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MA(MA):
    &#34;&#34;&#34;A moving average (MA) is a widely used indicator in technical analysis that helps smooth out 
    price action by filtering out the “noise” from random short-term price fluctuations. 

    See [Moving Average (MA)](https://www.investopedia.com/terms/m/movingaverage.asp).

    Use `MA.from_params` or `MA.from_combinations` methods to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, ts, window, ewm=False, **kwargs):
        &#34;&#34;&#34;Calculate moving average `MA.ma` from time series `ts` and parameters `window` and `ewm`.

        Args:
            ts (pandas_like): Time series (such as price).
            window (int or array_like): Size of the moving window. Can be one or more values.
            ewm (bool or array_like): If True, uses exponential moving average, otherwise 
                simple moving average. Can be one or more values. Defaults to False.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            MA
        Examples:
            ```python-repl
            &gt;&gt;&gt; ma = vbt.MA.from_params(price[&#39;Close&#39;], [10, 20], ewm=[False, True])

            &gt;&gt;&gt; print(ma.ma)
            ma_window          10            20
            ma_ewm          False          True
            Date                               
            2019-02-28        NaN           NaN
            2019-03-01        NaN           NaN
            2019-03-02        NaN           NaN
            ...               ...           ...
            2019-08-29  10155.972  10330.457140
            2019-08-30  10039.466  10260.715507
            2019-08-31   9988.727  10200.710220

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        return super().from_params(ts, window, ewm, **kwargs)

    @classmethod
    def from_combinations(cls, ts, windows, r, ewm=False, names=None, **kwargs):
        &#34;&#34;&#34;Create multiple `MA` combinations according to `itertools.combinations`.

        Args:
            ts (pandas_like): Time series (such as price).
            windows (array_like of int): Size of the moving window. Must be multiple.
            r (int): The number of `MA` instances to combine.
            ewm (bool or array_like of bool): If True, uses exponential moving average, otherwise 
                uses simple moving average. Can be one or more values. Defaults to False.
            names (list of str, optional): A list of names for each `MA` instance.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            tuple of MA
        Examples:
            ```python-repl
            &gt;&gt;&gt; fast_ma, slow_ma = vbt.MA.from_combinations(price[&#39;Close&#39;], 
            ...     [10, 20, 30], 2, ewm=[False, False, True], names=[&#39;fast&#39;, &#39;slow&#39;])

            &gt;&gt;&gt; print(fast_ma.ma)
            fast_window         10         10          20
            fast_ewm         False      False       False
            Date                                         
            2019-02-28         NaN        NaN         NaN
            2019-03-01         NaN        NaN         NaN
            2019-03-02         NaN        NaN         NaN
            ...                ...        ...         ...
            2019-08-29   10155.972  10155.972  10447.3480
            2019-08-30   10039.466  10039.466  10359.5555
            2019-08-31    9988.727   9988.727  10264.9095

            [185 rows x 3 columns]

            &gt;&gt;&gt; print(slow_ma.ma)
            slow_window          20            30            30
            slow_ewm          False          True          True
            Date                                               
            2019-02-28          NaN           NaN           NaN
            2019-03-01          NaN           NaN           NaN
            2019-03-02          NaN           NaN           NaN
            ...                 ...           ...           ...
            2019-08-29   10447.3480  10423.585970  10423.585970
            2019-08-30   10359.5555  10370.333077  10370.333077
            2019-08-31   10264.9095  10322.612024  10322.612024

            [185 rows x 3 columns]

            ```

            The naive way without caching is the follows:
            ```py
            window_combs = itertools.combinations([10, 20, 30], 2)
            ewm_combs = itertools.combinations([False, False, True], 2)
            fast_windows, slow_windows = np.asarray(list(window_combs)).transpose()
            fast_ewms, slow_ewms = np.asarray(list(ewm_combs)).transpose()

            fast_ma = vbt.MA.from_params(price[&#39;Close&#39;], 
            ...     fast_windows, fast_ewms, name=&#39;fast&#39;)
            slow_ma = vbt.MA.from_params(price[&#39;Close&#39;], 
            ...     slow_windows, slow_ewms, name=&#39;slow&#39;)
            ```

            Having this, you can now compare these `MA` instances:
            ```python-repl
            &gt;&gt;&gt; entry_signals = fast_ma.ma_above(slow_ma, crossover=True)
            &gt;&gt;&gt; exit_signals = fast_ma.ma_below(slow_ma, crossover=True)

            &gt;&gt;&gt; print(entry_signals)
            fast_window     10     10     20
            fast_ewm     False  False  False
            slow_window     20     30     30
            slow_ewm     False  True    True
            Date                            
            2019-02-28   False  False  False
            2019-03-01   False  False  False
            2019-03-02   False  False  False
            ...            ...    ...    ...
            2019-08-29   False  False  False
            2019-08-30   False  False  False
            2019-08-31   False  False  False

            [185 rows x 3 columns]
            ```

            Notice how `MA.ma_above` method created a new column hierarchy for you. You can now use
            it for indexing as follows:

            ```py
            fig = price[&#39;Close&#39;].vbt.timeseries.plot(name=&#39;Price&#39;)
            fig = entry_signals[(10, False, 20, False)]\\
                .vbt.signals.plot_markers(price[&#39;Close&#39;], signal_type=&#39;entry&#39;, fig=fig)
            fig = exit_signals[(10, False, 20, False)]\\
                .vbt.signals.plot_markers(price[&#39;Close&#39;], signal_type=&#39;exit&#39;, fig=fig)

            fig.show()
            ```
            ![](img/MA_from_combinations.png)
        &#34;&#34;&#34;

        if names is None:
            names = [&#39;ma&#39; + str(i+1) for i in range(r)]
        windows, ewm = reshape_fns.broadcast(windows, ewm, writeable=True)
        cache_dict = cls.from_params(ts, windows, ewm=ewm, return_cache=True, **kwargs)
        param_lists = zip(*itertools.combinations(zip(windows, ewm), r))
        mas = []
        for i, param_list in enumerate(param_lists):
            i_windows, i_ewm = zip(*param_list)
            mas.append(cls.from_params(ts, i_windows, ewm=i_ewm, cache=cache_dict, name=names[i], **kwargs))
        return tuple(mas)

    def plot(self,
             ts_trace_kwargs={},
             ma_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `MA.ma` against `MA.ts`.

        Args:
            ts_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MA.ts`.
            ma_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MA.ma`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            ma[(10, False)].plot()
            ```

            ![](img/MA.png)&#34;&#34;&#34;
        checks.assert_type(self.ts, pd.Series)
        checks.assert_type(self.ma, pd.Series)

        ts_trace_kwargs = {**dict(
            name=f&#39;Price ({self.name})&#39;
        ), **ts_trace_kwargs}
        ma_trace_kwargs = {**dict(
            name=f&#39;MA ({self.name})&#39;
        ), **ma_trace_kwargs}

        fig = self.ts.vbt.timeseries.plot(trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.ma.vbt.timeseries.plot(trace_kwargs=ma_trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.factory.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.MA.from_combinations"><code class="name flex">
<span>def <span class="ident">from_combinations</span></span>(<span>ts, windows, r, ewm=False, names=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create multiple <code><a title="vectorbt.indicators.indicators.MA" href="#vectorbt.indicators.indicators.MA">MA</a></code> combinations according to <code>itertools.combinations</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Time series (such as price).</dd>
<dt><strong><code>windows</code></strong> :&ensp;<code>array_like</code> of <code>int</code></dt>
<dd>Size of the moving window. Must be multiple.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of <code><a title="vectorbt.indicators.indicators.MA" href="#vectorbt.indicators.indicators.MA">MA</a></code> instances to combine.</dd>
<dt><strong><code>ewm</code></strong> :&ensp;<code>bool</code> or <code>array_like</code> of <code>bool</code></dt>
<dd>If True, uses exponential moving average, otherwise
uses simple moving average. Can be one or more values. Defaults to False.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>A list of names for each <code><a title="vectorbt.indicators.indicators.MA" href="#vectorbt.indicators.indicators.MA">MA</a></code> instance.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.indicators.factory.from_params_pipeline" href="factory.html#vectorbt.indicators.factory.from_params_pipeline">from_params_pipeline()</a>.</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code><a title="vectorbt.indicators.indicators.MA" href="#vectorbt.indicators.indicators.MA">MA</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; fast_ma, slow_ma = vbt.MA.from_combinations(price['Close'], 
...     [10, 20, 30], 2, ewm=[False, False, True], names=['fast', 'slow'])

&gt;&gt;&gt; print(fast_ma.ma)
fast_window         10         10          20
fast_ewm         False      False       False
Date                                         
2019-02-28         NaN        NaN         NaN
2019-03-01         NaN        NaN         NaN
2019-03-02         NaN        NaN         NaN
...                ...        ...         ...
2019-08-29   10155.972  10155.972  10447.3480
2019-08-30   10039.466  10039.466  10359.5555
2019-08-31    9988.727   9988.727  10264.9095

[185 rows x 3 columns]

&gt;&gt;&gt; print(slow_ma.ma)
slow_window          20            30            30
slow_ewm          False          True          True
Date                                               
2019-02-28          NaN           NaN           NaN
2019-03-01          NaN           NaN           NaN
2019-03-02          NaN           NaN           NaN
...                 ...           ...           ...
2019-08-29   10447.3480  10423.585970  10423.585970
2019-08-30   10359.5555  10370.333077  10370.333077
2019-08-31   10264.9095  10322.612024  10322.612024

[185 rows x 3 columns]

</code></pre>
<p>The naive way without caching is the follows:</p>
<pre><code class="py">window_combs = itertools.combinations([10, 20, 30], 2)
ewm_combs = itertools.combinations([False, False, True], 2)
fast_windows, slow_windows = np.asarray(list(window_combs)).transpose()
fast_ewms, slow_ewms = np.asarray(list(ewm_combs)).transpose()

fast_ma = vbt.MA.from_params(price['Close'], 
...     fast_windows, fast_ewms, name='fast')
slow_ma = vbt.MA.from_params(price['Close'], 
...     slow_windows, slow_ewms, name='slow')
</code></pre>
<p>Having this, you can now compare these <code><a title="vectorbt.indicators.indicators.MA" href="#vectorbt.indicators.indicators.MA">MA</a></code> instances:</p>
<pre><code class="python-repl">&gt;&gt;&gt; entry_signals = fast_ma.ma_above(slow_ma, crossover=True)
&gt;&gt;&gt; exit_signals = fast_ma.ma_below(slow_ma, crossover=True)

&gt;&gt;&gt; print(entry_signals)
fast_window     10     10     20
fast_ewm     False  False  False
slow_window     20     30     30
slow_ewm     False  True    True
Date                            
2019-02-28   False  False  False
2019-03-01   False  False  False
2019-03-02   False  False  False
...            ...    ...    ...
2019-08-29   False  False  False
2019-08-30   False  False  False
2019-08-31   False  False  False

[185 rows x 3 columns]
</code></pre>
<p>Notice how <code><a title="vectorbt.indicators.indicators.MA.ma_above" href="#vectorbt.indicators.indicators.MA.ma_above">CustomIndicator.ma_above()</a></code> method created a new column hierarchy for you. You can now use
it for indexing as follows:</p>
<pre><code class="py">fig = price['Close'].vbt.timeseries.plot(name='Price')
fig = entry_signals[(10, False, 20, False)]\
    .vbt.signals.plot_markers(price['Close'], signal_type='entry', fig=fig)
fig = exit_signals[(10, False, 20, False)]\
    .vbt.signals.plot_markers(price['Close'], signal_type='exit', fig=fig)

fig.show()
</code></pre>
<p><img alt="" src="img/MA_from_combinations.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_combinations(cls, ts, windows, r, ewm=False, names=None, **kwargs):
    &#34;&#34;&#34;Create multiple `MA` combinations according to `itertools.combinations`.

    Args:
        ts (pandas_like): Time series (such as price).
        windows (array_like of int): Size of the moving window. Must be multiple.
        r (int): The number of `MA` instances to combine.
        ewm (bool or array_like of bool): If True, uses exponential moving average, otherwise 
            uses simple moving average. Can be one or more values. Defaults to False.
        names (list of str, optional): A list of names for each `MA` instance.
        **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
    Returns:
        tuple of MA
    Examples:
        ```python-repl
        &gt;&gt;&gt; fast_ma, slow_ma = vbt.MA.from_combinations(price[&#39;Close&#39;], 
        ...     [10, 20, 30], 2, ewm=[False, False, True], names=[&#39;fast&#39;, &#39;slow&#39;])

        &gt;&gt;&gt; print(fast_ma.ma)
        fast_window         10         10          20
        fast_ewm         False      False       False
        Date                                         
        2019-02-28         NaN        NaN         NaN
        2019-03-01         NaN        NaN         NaN
        2019-03-02         NaN        NaN         NaN
        ...                ...        ...         ...
        2019-08-29   10155.972  10155.972  10447.3480
        2019-08-30   10039.466  10039.466  10359.5555
        2019-08-31    9988.727   9988.727  10264.9095

        [185 rows x 3 columns]

        &gt;&gt;&gt; print(slow_ma.ma)
        slow_window          20            30            30
        slow_ewm          False          True          True
        Date                                               
        2019-02-28          NaN           NaN           NaN
        2019-03-01          NaN           NaN           NaN
        2019-03-02          NaN           NaN           NaN
        ...                 ...           ...           ...
        2019-08-29   10447.3480  10423.585970  10423.585970
        2019-08-30   10359.5555  10370.333077  10370.333077
        2019-08-31   10264.9095  10322.612024  10322.612024

        [185 rows x 3 columns]

        ```

        The naive way without caching is the follows:
        ```py
        window_combs = itertools.combinations([10, 20, 30], 2)
        ewm_combs = itertools.combinations([False, False, True], 2)
        fast_windows, slow_windows = np.asarray(list(window_combs)).transpose()
        fast_ewms, slow_ewms = np.asarray(list(ewm_combs)).transpose()

        fast_ma = vbt.MA.from_params(price[&#39;Close&#39;], 
        ...     fast_windows, fast_ewms, name=&#39;fast&#39;)
        slow_ma = vbt.MA.from_params(price[&#39;Close&#39;], 
        ...     slow_windows, slow_ewms, name=&#39;slow&#39;)
        ```

        Having this, you can now compare these `MA` instances:
        ```python-repl
        &gt;&gt;&gt; entry_signals = fast_ma.ma_above(slow_ma, crossover=True)
        &gt;&gt;&gt; exit_signals = fast_ma.ma_below(slow_ma, crossover=True)

        &gt;&gt;&gt; print(entry_signals)
        fast_window     10     10     20
        fast_ewm     False  False  False
        slow_window     20     30     30
        slow_ewm     False  True    True
        Date                            
        2019-02-28   False  False  False
        2019-03-01   False  False  False
        2019-03-02   False  False  False
        ...            ...    ...    ...
        2019-08-29   False  False  False
        2019-08-30   False  False  False
        2019-08-31   False  False  False

        [185 rows x 3 columns]
        ```

        Notice how `MA.ma_above` method created a new column hierarchy for you. You can now use
        it for indexing as follows:

        ```py
        fig = price[&#39;Close&#39;].vbt.timeseries.plot(name=&#39;Price&#39;)
        fig = entry_signals[(10, False, 20, False)]\\
            .vbt.signals.plot_markers(price[&#39;Close&#39;], signal_type=&#39;entry&#39;, fig=fig)
        fig = exit_signals[(10, False, 20, False)]\\
            .vbt.signals.plot_markers(price[&#39;Close&#39;], signal_type=&#39;exit&#39;, fig=fig)

        fig.show()
        ```
        ![](img/MA_from_combinations.png)
    &#34;&#34;&#34;

    if names is None:
        names = [&#39;ma&#39; + str(i+1) for i in range(r)]
    windows, ewm = reshape_fns.broadcast(windows, ewm, writeable=True)
    cache_dict = cls.from_params(ts, windows, ewm=ewm, return_cache=True, **kwargs)
    param_lists = zip(*itertools.combinations(zip(windows, ewm), r))
    mas = []
    for i, param_list in enumerate(param_lists):
        i_windows, i_ewm = zip(*param_list)
        mas.append(cls.from_params(ts, i_windows, ewm=i_ewm, cache=cache_dict, name=names[i], **kwargs))
    return tuple(mas)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, window, ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate moving average <code><a title="vectorbt.indicators.indicators.MA.ma" href="#vectorbt.indicators.indicators.MA.ma">MA.ma</a></code> from time series <code>ts</code> and parameters <code>window</code> and <code>ewm</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Time series (such as price).</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Size of the moving window. Can be one or more values.</dd>
<dt><strong><code>ewm</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>If True, uses exponential moving average, otherwise
simple moving average. Can be one or more values. Defaults to False.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.indicators.factory.from_params_pipeline" href="factory.html#vectorbt.indicators.factory.from_params_pipeline">from_params_pipeline()</a>.</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.indicators.indicators.MA" href="#vectorbt.indicators.indicators.MA">MA</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; ma = vbt.MA.from_params(price['Close'], [10, 20], ewm=[False, True])

&gt;&gt;&gt; print(ma.ma)
ma_window          10            20
ma_ewm          False          True
Date                               
2019-02-28        NaN           NaN
2019-03-01        NaN           NaN
2019-03-02        NaN           NaN
...               ...           ...
2019-08-29  10155.972  10330.457140
2019-08-30  10039.466  10260.715507
2019-08-31   9988.727  10200.710220

[185 rows x 2 columns]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, window, ewm=False, **kwargs):
    &#34;&#34;&#34;Calculate moving average `MA.ma` from time series `ts` and parameters `window` and `ewm`.

    Args:
        ts (pandas_like): Time series (such as price).
        window (int or array_like): Size of the moving window. Can be one or more values.
        ewm (bool or array_like): If True, uses exponential moving average, otherwise 
            simple moving average. Can be one or more values. Defaults to False.
        **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
    Returns:
        MA
    Examples:
        ```python-repl
        &gt;&gt;&gt; ma = vbt.MA.from_params(price[&#39;Close&#39;], [10, 20], ewm=[False, True])

        &gt;&gt;&gt; print(ma.ma)
        ma_window          10            20
        ma_ewm          False          True
        Date                               
        2019-02-28        NaN           NaN
        2019-03-01        NaN           NaN
        2019-03-02        NaN           NaN
        ...               ...           ...
        2019-08-29  10155.972  10330.457140
        2019-08-30  10039.466  10260.715507
        2019-08-31   9988.727  10200.710220

        [185 rows x 2 columns]
        ```
    &#34;&#34;&#34;
    return super().from_params(ts, window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.indicators.MA.ewm_loc"><code class="name">var <span class="ident">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.ma"><code class="name">var <span class="ident">ma</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.ts"><code class="name">var <span class="ident">ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.tuple_loc"><code class="name">var <span class="ident">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter tuple using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.window_loc"><code class="name">var <span class="ident">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.MA.ma_above"><code class="name flex">
<span>def <span class="ident">ma_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ma</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.ma_below"><code class="name flex">
<span>def <span class="ident">ma_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ma</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.ma_equal"><code class="name flex">
<span>def <span class="ident">ma_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ma</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, ts_trace_kwargs={}, ma_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.indicators.MA.ma" href="#vectorbt.indicators.indicators.MA.ma">MA.ma</a></code> against <code><a title="vectorbt.indicators.indicators.MA.ts" href="#vectorbt.indicators.indicators.MA.ts">MA.ts</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of <code><a title="vectorbt.indicators.indicators.MA.ts" href="#vectorbt.indicators.indicators.MA.ts">MA.ts</a></code>.</dd>
<dt><strong><code>ma_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of <code><a title="vectorbt.indicators.indicators.MA.ma" href="#vectorbt.indicators.indicators.MA.ma">MA.ma</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code>, optional</dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.widgets.common.FigureWidget" href="../widgets/common.html#vectorbt.widgets.common.FigureWidget">FigureWidget</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="py">ma[(10, False)].plot()
</code></pre>
<p><img alt="" src="img/MA.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         ts_trace_kwargs={},
         ma_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    &#34;&#34;&#34;Plot `MA.ma` against `MA.ts`.

    Args:
        ts_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MA.ts`.
        ma_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MA.ma`.
        fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Returns:
        vectorbt.widgets.common.FigureWidget
    Examples:
        ```py
        ma[(10, False)].plot()
        ```

        ![](img/MA.png)&#34;&#34;&#34;
    checks.assert_type(self.ts, pd.Series)
    checks.assert_type(self.ma, pd.Series)

    ts_trace_kwargs = {**dict(
        name=f&#39;Price ({self.name})&#39;
    ), **ts_trace_kwargs}
    ma_trace_kwargs = {**dict(
        name=f&#39;MA ({self.name})&#39;
    ), **ma_trace_kwargs}

    fig = self.ts.vbt.timeseries.plot(trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.ma.vbt.timeseries.plot(trace_kwargs=ma_trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.ts_above"><code class="name flex">
<span>def <span class="ident">ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.ts_below"><code class="name flex">
<span>def <span class="ident">ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.ts_equal"><code class="name flex">
<span>def <span class="ident">ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MA.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.indicators.MACD"><code class="flex name class">
<span>class <span class="ident">MACD</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Moving Average Convergence Divergence (MACD) is a trend-following momentum indicator that
shows the relationship between two moving averages of a security’s price.</p>
<p>See <a href="https://www.investopedia.com/terms/m/macd.asp">Moving Average Convergence Divergence – MACD</a>.</p>
<p>Use <code><a title="vectorbt.indicators.indicators.MACD.from_params" href="#vectorbt.indicators.indicators.MACD.from_params">MACD.from_params()</a></code> methods to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MACD(MACD):
    &#34;&#34;&#34;Moving Average Convergence Divergence (MACD) is a trend-following momentum indicator that 
    shows the relationship between two moving averages of a security’s price.

    See [Moving Average Convergence Divergence – MACD](https://www.investopedia.com/terms/m/macd.asp).

    Use `MACD.from_params` methods to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, ts, fast_window=26, slow_window=12, signal_window=9, macd_ewm=True, signal_ewm=True, **kwargs):
        &#34;&#34;&#34;Calculate fast moving average `MACD.fast_ma`, slow moving average `MACD.slow_ma`, MACD `MACD.macd`, 
        signal `MACD.signal` and histogram `MACD.histogram` from time series `ts` and parameters `fast_window`, 
        `slow_window`, `signal_window`, `macd_ewm` and `signal_ewm`.

        Args:
            ts (pandas_like): Time series (such as price).
            fast_window (int or array_like): Size of the fast moving window for MACD. Can be one or more values.
                Defaults to 26.
            slow_window (int or array_like): Size of the slow moving window for MACD. Can be one or more values.
                Defaults to 12.
            signal_window (int or array_like): Size of the moving window for signal. Can be one or more values.
                Defaults to 9.
            macd_ewm (bool or array_like): If True, uses exponential moving average for MACD, otherwise uses 
                simple moving average. Can be one or more values. Defaults to True.
            signal_ewm (bool or array_like): If True, uses exponential moving average for signal, otherwise uses 
                simple moving average. Can be one or more values. Defaults to True.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            MACD
        Examples:
            ```python-repl
            &gt;&gt;&gt; macd = vbt.MACD.from_params(price[&#39;Close&#39;], 
            ...     fast_window=[10, 20], slow_window=[20, 30], signal_window=[30, 40], 
            ...     macd_ewm=[False, True], signal_ewm=[True, False])

            &gt;&gt;&gt; print(macd.fast_ma)
            macd_fast_window           10            20
            macd_slow_window           20            30
            macd_signal_window         30            40
            macd_macd_ewm           False          True
            macd_signal_ewm          True         False
            Date                                       
            2019-02-28                NaN           NaN
            2019-03-01                NaN           NaN
            2019-03-02                NaN           NaN
            ...                       ...           ...
            2019-08-29          10155.972  10330.457140
            2019-08-30          10039.466  10260.715507
            2019-08-31           9988.727  10200.710220

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(macd.slow_ma)
            macd_fast_window            10            20
            macd_slow_window            20            30
            macd_signal_window          30            40
            macd_macd_ewm            False          True
            macd_signal_ewm           True         False
            Date                                        
            2019-02-28                 NaN           NaN
            2019-03-01                 NaN           NaN
            2019-03-02                 NaN           NaN
            ...                        ...           ...
            2019-08-29          10447.3480  10423.585970
            2019-08-30          10359.5555  10370.333077
            2019-08-31          10264.9095  10322.612024

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(macd.macd)
            macd_fast_window          10          20
            macd_slow_window          20          30
            macd_signal_window        30          40
            macd_macd_ewm          False        True
            macd_signal_ewm         True       False
            Date                                    
            2019-02-28               NaN         NaN
            2019-03-01               NaN         NaN
            2019-03-02               NaN         NaN
            ...                      ...         ...
            2019-08-29         -291.3760  -93.128830
            2019-08-30         -320.0895 -109.617570
            2019-08-31         -276.1825 -121.901804

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(macd.signal)
            macd_fast_window            10         20
            macd_slow_window            20         30
            macd_signal_window          30         40
            macd_macd_ewm            False       True
            macd_signal_ewm           True      False
            Date                                     
            2019-02-28                 NaN        NaN
            2019-03-01                 NaN        NaN
            2019-03-02                 NaN        NaN
            ...                        ...        ...
            2019-08-29         -104.032603  28.622033
            2019-08-30         -117.971990  22.424149
            2019-08-31         -128.179278  16.493338

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(macd.histogram)
            macd_fast_window            10          20
            macd_slow_window            20          30
            macd_signal_window          30          40
            macd_macd_ewm            False        True
            macd_signal_ewm           True       False
            Date                                      
            2019-02-28                 NaN         NaN
            2019-03-01                 NaN         NaN
            2019-03-02                 NaN         NaN
            ...                        ...         ...
            2019-08-29         -187.343397 -121.750863
            2019-08-30         -202.117510 -132.041719
            2019-08-31         -148.003222 -138.395142

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        return super().from_params(ts, fast_window, slow_window, signal_window, macd_ewm, signal_ewm, **kwargs)

    def plot(self,
             macd_trace_kwargs={},
             signal_trace_kwargs={},
             histogram_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `MACD.macd`, `MACD.signal` and `MACD.histogram`.

        Args:
            macd_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `MACD.macd`.
            signal_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `MACD.signal`.
            histogram_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Bar`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Bar.html) of 
                `MACD.histogram`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            macd[(10, 20, 30, False, True)].plot()
            ```

            ![](img/MACD.png)&#34;&#34;&#34;
        checks.assert_type(self.macd, pd.Series)
        checks.assert_type(self.signal, pd.Series)
        checks.assert_type(self.histogram, pd.Series)

        macd_trace_kwargs = {**dict(
            name=f&#39;MACD ({self.name})&#39;
        ), **macd_trace_kwargs}
        signal_trace_kwargs = {**dict(
            name=f&#39;Signal ({self.name})&#39;
        ), **signal_trace_kwargs}
        histogram_trace_kwargs = {**dict(
            name=f&#39;Histogram ({self.name})&#39;,
            showlegend=False
        ), **histogram_trace_kwargs}

        layout_kwargs = {**dict(bargap=0), **layout_kwargs}
        fig = self.macd.vbt.timeseries.plot(trace_kwargs=macd_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.signal.vbt.timeseries.plot(trace_kwargs=signal_trace_kwargs, fig=fig, **layout_kwargs)

        # Plot histogram
        hist = self.histogram.values
        hist_diff = timeseries.nb.diff_1d_nb(hist)
        marker_colors = np.full(hist.shape, np.nan, dtype=np.object)
        marker_colors[(hist &gt; 0) &amp; (hist_diff &gt; 0)] = &#39;green&#39;
        marker_colors[(hist &gt; 0) &amp; (hist_diff &lt;= 0)] = &#39;lightgreen&#39;
        marker_colors[hist == 0] = &#39;lightgrey&#39;
        marker_colors[(hist &lt; 0) &amp; (hist_diff &lt; 0)] = &#39;red&#39;
        marker_colors[(hist &lt; 0) &amp; (hist_diff &gt;= 0)] = &#39;lightcoral&#39;

        histogram_bar = go.Bar(
            x=self.histogram.index,
            y=self.histogram.values,
            marker_color=marker_colors,
            marker_line_width=0
        )
        histogram_bar.update(**histogram_trace_kwargs)
        fig.add_trace(histogram_bar)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.factory.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.MACD.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, fast_window=26, slow_window=12, signal_window=9, macd_ewm=True, signal_ewm=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate fast moving average <code><a title="vectorbt.indicators.indicators.MACD.fast_ma" href="#vectorbt.indicators.indicators.MACD.fast_ma">MACD.fast_ma</a></code>, slow moving average <code><a title="vectorbt.indicators.indicators.MACD.slow_ma" href="#vectorbt.indicators.indicators.MACD.slow_ma">MACD.slow_ma</a></code>, MACD <code><a title="vectorbt.indicators.indicators.MACD.macd" href="#vectorbt.indicators.indicators.MACD.macd">MACD.macd</a></code>,
signal <code><a title="vectorbt.indicators.indicators.MACD.signal" href="#vectorbt.indicators.indicators.MACD.signal">MACD.signal</a></code> and histogram <code><a title="vectorbt.indicators.indicators.MACD.histogram" href="#vectorbt.indicators.indicators.MACD.histogram">MACD.histogram</a></code> from time series <code>ts</code> and parameters <code>fast_window</code>,
<code>slow_window</code>, <code>signal_window</code>, <code>macd_ewm</code> and <code>signal_ewm</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Time series (such as price).</dd>
<dt><strong><code>fast_window</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Size of the fast moving window for MACD. Can be one or more values.
Defaults to 26.</dd>
<dt><strong><code>slow_window</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Size of the slow moving window for MACD. Can be one or more values.
Defaults to 12.</dd>
<dt><strong><code>signal_window</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Size of the moving window for signal. Can be one or more values.
Defaults to 9.</dd>
<dt><strong><code>macd_ewm</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>If True, uses exponential moving average for MACD, otherwise uses
simple moving average. Can be one or more values. Defaults to True.</dd>
<dt><strong><code>signal_ewm</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>If True, uses exponential moving average for signal, otherwise uses
simple moving average. Can be one or more values. Defaults to True.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.indicators.factory.from_params_pipeline" href="factory.html#vectorbt.indicators.factory.from_params_pipeline">from_params_pipeline()</a>.</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.indicators.indicators.MACD" href="#vectorbt.indicators.indicators.MACD">MACD</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; macd = vbt.MACD.from_params(price['Close'], 
...     fast_window=[10, 20], slow_window=[20, 30], signal_window=[30, 40], 
...     macd_ewm=[False, True], signal_ewm=[True, False])

&gt;&gt;&gt; print(macd.fast_ma)
macd_fast_window           10            20
macd_slow_window           20            30
macd_signal_window         30            40
macd_macd_ewm           False          True
macd_signal_ewm          True         False
Date                                       
2019-02-28                NaN           NaN
2019-03-01                NaN           NaN
2019-03-02                NaN           NaN
...                       ...           ...
2019-08-29          10155.972  10330.457140
2019-08-30          10039.466  10260.715507
2019-08-31           9988.727  10200.710220

[185 rows x 2 columns]

&gt;&gt;&gt; print(macd.slow_ma)
macd_fast_window            10            20
macd_slow_window            20            30
macd_signal_window          30            40
macd_macd_ewm            False          True
macd_signal_ewm           True         False
Date                                        
2019-02-28                 NaN           NaN
2019-03-01                 NaN           NaN
2019-03-02                 NaN           NaN
...                        ...           ...
2019-08-29          10447.3480  10423.585970
2019-08-30          10359.5555  10370.333077
2019-08-31          10264.9095  10322.612024

[185 rows x 2 columns]

&gt;&gt;&gt; print(macd.macd)
macd_fast_window          10          20
macd_slow_window          20          30
macd_signal_window        30          40
macd_macd_ewm          False        True
macd_signal_ewm         True       False
Date                                    
2019-02-28               NaN         NaN
2019-03-01               NaN         NaN
2019-03-02               NaN         NaN
...                      ...         ...
2019-08-29         -291.3760  -93.128830
2019-08-30         -320.0895 -109.617570
2019-08-31         -276.1825 -121.901804

[185 rows x 2 columns]

&gt;&gt;&gt; print(macd.signal)
macd_fast_window            10         20
macd_slow_window            20         30
macd_signal_window          30         40
macd_macd_ewm            False       True
macd_signal_ewm           True      False
Date                                     
2019-02-28                 NaN        NaN
2019-03-01                 NaN        NaN
2019-03-02                 NaN        NaN
...                        ...        ...
2019-08-29         -104.032603  28.622033
2019-08-30         -117.971990  22.424149
2019-08-31         -128.179278  16.493338

[185 rows x 2 columns]

&gt;&gt;&gt; print(macd.histogram)
macd_fast_window            10          20
macd_slow_window            20          30
macd_signal_window          30          40
macd_macd_ewm            False        True
macd_signal_ewm           True       False
Date                                      
2019-02-28                 NaN         NaN
2019-03-01                 NaN         NaN
2019-03-02                 NaN         NaN
...                        ...         ...
2019-08-29         -187.343397 -121.750863
2019-08-30         -202.117510 -132.041719
2019-08-31         -148.003222 -138.395142

[185 rows x 2 columns]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, fast_window=26, slow_window=12, signal_window=9, macd_ewm=True, signal_ewm=True, **kwargs):
    &#34;&#34;&#34;Calculate fast moving average `MACD.fast_ma`, slow moving average `MACD.slow_ma`, MACD `MACD.macd`, 
    signal `MACD.signal` and histogram `MACD.histogram` from time series `ts` and parameters `fast_window`, 
    `slow_window`, `signal_window`, `macd_ewm` and `signal_ewm`.

    Args:
        ts (pandas_like): Time series (such as price).
        fast_window (int or array_like): Size of the fast moving window for MACD. Can be one or more values.
            Defaults to 26.
        slow_window (int or array_like): Size of the slow moving window for MACD. Can be one or more values.
            Defaults to 12.
        signal_window (int or array_like): Size of the moving window for signal. Can be one or more values.
            Defaults to 9.
        macd_ewm (bool or array_like): If True, uses exponential moving average for MACD, otherwise uses 
            simple moving average. Can be one or more values. Defaults to True.
        signal_ewm (bool or array_like): If True, uses exponential moving average for signal, otherwise uses 
            simple moving average. Can be one or more values. Defaults to True.
        **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
    Returns:
        MACD
    Examples:
        ```python-repl
        &gt;&gt;&gt; macd = vbt.MACD.from_params(price[&#39;Close&#39;], 
        ...     fast_window=[10, 20], slow_window=[20, 30], signal_window=[30, 40], 
        ...     macd_ewm=[False, True], signal_ewm=[True, False])

        &gt;&gt;&gt; print(macd.fast_ma)
        macd_fast_window           10            20
        macd_slow_window           20            30
        macd_signal_window         30            40
        macd_macd_ewm           False          True
        macd_signal_ewm          True         False
        Date                                       
        2019-02-28                NaN           NaN
        2019-03-01                NaN           NaN
        2019-03-02                NaN           NaN
        ...                       ...           ...
        2019-08-29          10155.972  10330.457140
        2019-08-30          10039.466  10260.715507
        2019-08-31           9988.727  10200.710220

        [185 rows x 2 columns]

        &gt;&gt;&gt; print(macd.slow_ma)
        macd_fast_window            10            20
        macd_slow_window            20            30
        macd_signal_window          30            40
        macd_macd_ewm            False          True
        macd_signal_ewm           True         False
        Date                                        
        2019-02-28                 NaN           NaN
        2019-03-01                 NaN           NaN
        2019-03-02                 NaN           NaN
        ...                        ...           ...
        2019-08-29          10447.3480  10423.585970
        2019-08-30          10359.5555  10370.333077
        2019-08-31          10264.9095  10322.612024

        [185 rows x 2 columns]

        &gt;&gt;&gt; print(macd.macd)
        macd_fast_window          10          20
        macd_slow_window          20          30
        macd_signal_window        30          40
        macd_macd_ewm          False        True
        macd_signal_ewm         True       False
        Date                                    
        2019-02-28               NaN         NaN
        2019-03-01               NaN         NaN
        2019-03-02               NaN         NaN
        ...                      ...         ...
        2019-08-29         -291.3760  -93.128830
        2019-08-30         -320.0895 -109.617570
        2019-08-31         -276.1825 -121.901804

        [185 rows x 2 columns]

        &gt;&gt;&gt; print(macd.signal)
        macd_fast_window            10         20
        macd_slow_window            20         30
        macd_signal_window          30         40
        macd_macd_ewm            False       True
        macd_signal_ewm           True      False
        Date                                     
        2019-02-28                 NaN        NaN
        2019-03-01                 NaN        NaN
        2019-03-02                 NaN        NaN
        ...                        ...        ...
        2019-08-29         -104.032603  28.622033
        2019-08-30         -117.971990  22.424149
        2019-08-31         -128.179278  16.493338

        [185 rows x 2 columns]

        &gt;&gt;&gt; print(macd.histogram)
        macd_fast_window            10          20
        macd_slow_window            20          30
        macd_signal_window          30          40
        macd_macd_ewm            False        True
        macd_signal_ewm           True       False
        Date                                      
        2019-02-28                 NaN         NaN
        2019-03-01                 NaN         NaN
        2019-03-02                 NaN         NaN
        ...                        ...         ...
        2019-08-29         -187.343397 -121.750863
        2019-08-30         -202.117510 -132.041719
        2019-08-31         -148.003222 -138.395142

        [185 rows x 2 columns]
        ```
    &#34;&#34;&#34;
    return super().from_params(ts, fast_window, slow_window, signal_window, macd_ewm, signal_ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.indicators.MACD.fast_ma"><code class="name">var <span class="ident">fast_ma</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.fast_window_loc"><code class="name">var <span class="ident">fast_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter fast_window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.histogram"><code class="name">var <span class="ident">histogram</span></code></dt>
<dd>
<div class="desc"><p>Custom property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">histogram=lambda self: self.ts.vbt.wrap_array(self.macd.values - self.signal.values),</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.macd"><code class="name">var <span class="ident">macd</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.macd_ewm_loc"><code class="name">var <span class="ident">macd_ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter macd_ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.signal"><code class="name">var <span class="ident">signal</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.signal_ewm_loc"><code class="name">var <span class="ident">signal_ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter signal_ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.signal_window_loc"><code class="name">var <span class="ident">signal_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter signal_window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.slow_ma"><code class="name">var <span class="ident">slow_ma</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.slow_window_loc"><code class="name">var <span class="ident">slow_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter slow_window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.ts"><code class="name">var <span class="ident">ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.tuple_loc"><code class="name">var <span class="ident">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter tuple using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.MACD.fast_ma_above"><code class="name flex">
<span>def <span class="ident">fast_ma_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>fast_ma</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>fast_ma</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.fast_ma_below"><code class="name flex">
<span>def <span class="ident">fast_ma_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>fast_ma</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>fast_ma</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.fast_ma_equal"><code class="name flex">
<span>def <span class="ident">fast_ma_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>fast_ma</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>fast_ma</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.histogram_above"><code class="name flex">
<span>def <span class="ident">histogram_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>histogram</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>histogram</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.histogram_below"><code class="name flex">
<span>def <span class="ident">histogram_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>histogram</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>histogram</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.histogram_equal"><code class="name flex">
<span>def <span class="ident">histogram_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>histogram</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>histogram</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.macd_above"><code class="name flex">
<span>def <span class="ident">macd_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>macd</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>macd</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.macd_below"><code class="name flex">
<span>def <span class="ident">macd_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>macd</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>macd</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.macd_equal"><code class="name flex">
<span>def <span class="ident">macd_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>macd</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>macd</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, macd_trace_kwargs={}, signal_trace_kwargs={}, histogram_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.indicators.MACD.macd" href="#vectorbt.indicators.indicators.MACD.macd">MACD.macd</a></code>, <code><a title="vectorbt.indicators.indicators.MACD.signal" href="#vectorbt.indicators.indicators.MACD.signal">MACD.signal</a></code> and <code><a title="vectorbt.indicators.indicators.MACD.histogram" href="#vectorbt.indicators.indicators.MACD.histogram">MACD.histogram</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>macd_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of
<code><a title="vectorbt.indicators.indicators.MACD.macd" href="#vectorbt.indicators.indicators.MACD.macd">MACD.macd</a></code>.</dd>
<dt><strong><code>signal_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of
<code><a title="vectorbt.indicators.indicators.MACD.signal" href="#vectorbt.indicators.indicators.MACD.signal">MACD.signal</a></code>.</dd>
<dt><strong><code>histogram_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Bar.html"><code>plotly.graph_objects.Bar</code></a> of
<code><a title="vectorbt.indicators.indicators.MACD.histogram" href="#vectorbt.indicators.indicators.MACD.histogram">MACD.histogram</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code>, optional</dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.widgets.common.FigureWidget" href="../widgets/common.html#vectorbt.widgets.common.FigureWidget">FigureWidget</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="py">macd[(10, 20, 30, False, True)].plot()
</code></pre>
<p><img alt="" src="img/MACD.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         macd_trace_kwargs={},
         signal_trace_kwargs={},
         histogram_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    &#34;&#34;&#34;Plot `MACD.macd`, `MACD.signal` and `MACD.histogram`.

    Args:
        macd_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
            `MACD.macd`.
        signal_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
            `MACD.signal`.
        histogram_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Bar`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Bar.html) of 
            `MACD.histogram`.
        fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Returns:
        vectorbt.widgets.common.FigureWidget
    Examples:
        ```py
        macd[(10, 20, 30, False, True)].plot()
        ```

        ![](img/MACD.png)&#34;&#34;&#34;
    checks.assert_type(self.macd, pd.Series)
    checks.assert_type(self.signal, pd.Series)
    checks.assert_type(self.histogram, pd.Series)

    macd_trace_kwargs = {**dict(
        name=f&#39;MACD ({self.name})&#39;
    ), **macd_trace_kwargs}
    signal_trace_kwargs = {**dict(
        name=f&#39;Signal ({self.name})&#39;
    ), **signal_trace_kwargs}
    histogram_trace_kwargs = {**dict(
        name=f&#39;Histogram ({self.name})&#39;,
        showlegend=False
    ), **histogram_trace_kwargs}

    layout_kwargs = {**dict(bargap=0), **layout_kwargs}
    fig = self.macd.vbt.timeseries.plot(trace_kwargs=macd_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.signal.vbt.timeseries.plot(trace_kwargs=signal_trace_kwargs, fig=fig, **layout_kwargs)

    # Plot histogram
    hist = self.histogram.values
    hist_diff = timeseries.nb.diff_1d_nb(hist)
    marker_colors = np.full(hist.shape, np.nan, dtype=np.object)
    marker_colors[(hist &gt; 0) &amp; (hist_diff &gt; 0)] = &#39;green&#39;
    marker_colors[(hist &gt; 0) &amp; (hist_diff &lt;= 0)] = &#39;lightgreen&#39;
    marker_colors[hist == 0] = &#39;lightgrey&#39;
    marker_colors[(hist &lt; 0) &amp; (hist_diff &lt; 0)] = &#39;red&#39;
    marker_colors[(hist &lt; 0) &amp; (hist_diff &gt;= 0)] = &#39;lightcoral&#39;

    histogram_bar = go.Bar(
        x=self.histogram.index,
        y=self.histogram.values,
        marker_color=marker_colors,
        marker_line_width=0
    )
    histogram_bar.update(**histogram_trace_kwargs)
    fig.add_trace(histogram_bar)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.signal_above"><code class="name flex">
<span>def <span class="ident">signal_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>signal</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>signal</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.signal_below"><code class="name flex">
<span>def <span class="ident">signal_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>signal</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>signal</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.signal_equal"><code class="name flex">
<span>def <span class="ident">signal_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>signal</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>signal</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.slow_ma_above"><code class="name flex">
<span>def <span class="ident">slow_ma_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>slow_ma</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>slow_ma</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.slow_ma_below"><code class="name flex">
<span>def <span class="ident">slow_ma_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>slow_ma</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>slow_ma</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.slow_ma_equal"><code class="name flex">
<span>def <span class="ident">slow_ma_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>slow_ma</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>slow_ma</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.ts_above"><code class="name flex">
<span>def <span class="ident">ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.ts_below"><code class="name flex">
<span>def <span class="ident">ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.ts_equal"><code class="name flex">
<span>def <span class="ident">ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MACD.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD"><code class="flex name class">
<span>class <span class="ident">MSTD</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Standard deviation is an indicator that measures the size of an assets recent price moves
in order to predict how volatile the price may be in the future.</p>
<p>Use <code><a title="vectorbt.indicators.indicators.MSTD.from_params" href="#vectorbt.indicators.indicators.MSTD.from_params">MSTD.from_params()</a></code> method to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MSTD(MSTD):
    &#34;&#34;&#34;Standard deviation is an indicator that measures the size of an assets recent price moves 
    in order to predict how volatile the price may be in the future.

    Use `MSTD.from_params` method to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, ts, window, ewm=False, **kwargs):
        &#34;&#34;&#34;Calculate moving standard deviation `MSTD.mstd` from time series `ts` and 
        parameters `window` and `ewm`.

        Args:
            ts (pandas_like): Time series (such as price).
            window (int or array_like): Size of the moving window. Can be one or more values.
            ewm (bool or array_like): If True, uses exponential moving standard deviation, 
                otherwise uses simple moving standard deviation. Can be one or more values. 
                Defaults to False.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            MSTD
        Examples:
            ```python-repl
            &gt;&gt;&gt; mstd = vbt.MSTD.from_params(price[&#39;Close&#39;], [10, 20], ewm=[False, True])

            &gt;&gt;&gt; print(mstd.mstd)
            mstd_window          10          20
            mstd_ewm          False        True
            Date                               
            2019-02-28          NaN         NaN
            2019-03-01          NaN         NaN
            2019-03-02          NaN         NaN
            ...                 ...         ...
            2019-08-29   342.996528  603.191266
            2019-08-30   310.101037  614.676546
            2019-08-31   332.853480  614.695088

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        return super().from_params(ts, window, ewm, **kwargs)

    def plot(self,
             mstd_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `MSTD.mstd`.

        Args:
            mstd_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MSTD.mstd`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            mstd[(10, False)].plot()
            ```

            ![](img/MSTD.png)&#34;&#34;&#34;
        checks.assert_type(self.mstd, pd.Series)

        mstd_trace_kwargs = {**dict(
            name=f&#39;MSTD ({self.name})&#39;
        ), **mstd_trace_kwargs}

        fig = self.mstd.vbt.timeseries.plot(trace_kwargs=mstd_trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.factory.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.MSTD.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, window, ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate moving standard deviation <code><a title="vectorbt.indicators.indicators.MSTD.mstd" href="#vectorbt.indicators.indicators.MSTD.mstd">MSTD.mstd</a></code> from time series <code>ts</code> and
parameters <code>window</code> and <code>ewm</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Time series (such as price).</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Size of the moving window. Can be one or more values.</dd>
<dt><strong><code>ewm</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>If True, uses exponential moving standard deviation,
otherwise uses simple moving standard deviation. Can be one or more values.
Defaults to False.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.indicators.factory.from_params_pipeline" href="factory.html#vectorbt.indicators.factory.from_params_pipeline">from_params_pipeline()</a>.</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.indicators.indicators.MSTD" href="#vectorbt.indicators.indicators.MSTD">MSTD</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; mstd = vbt.MSTD.from_params(price['Close'], [10, 20], ewm=[False, True])

&gt;&gt;&gt; print(mstd.mstd)
mstd_window          10          20
mstd_ewm          False        True
Date                               
2019-02-28          NaN         NaN
2019-03-01          NaN         NaN
2019-03-02          NaN         NaN
...                 ...         ...
2019-08-29   342.996528  603.191266
2019-08-30   310.101037  614.676546
2019-08-31   332.853480  614.695088

[185 rows x 2 columns]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, window, ewm=False, **kwargs):
    &#34;&#34;&#34;Calculate moving standard deviation `MSTD.mstd` from time series `ts` and 
    parameters `window` and `ewm`.

    Args:
        ts (pandas_like): Time series (such as price).
        window (int or array_like): Size of the moving window. Can be one or more values.
        ewm (bool or array_like): If True, uses exponential moving standard deviation, 
            otherwise uses simple moving standard deviation. Can be one or more values. 
            Defaults to False.
        **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
    Returns:
        MSTD
    Examples:
        ```python-repl
        &gt;&gt;&gt; mstd = vbt.MSTD.from_params(price[&#39;Close&#39;], [10, 20], ewm=[False, True])

        &gt;&gt;&gt; print(mstd.mstd)
        mstd_window          10          20
        mstd_ewm          False        True
        Date                               
        2019-02-28          NaN         NaN
        2019-03-01          NaN         NaN
        2019-03-02          NaN         NaN
        ...                 ...         ...
        2019-08-29   342.996528  603.191266
        2019-08-30   310.101037  614.676546
        2019-08-31   332.853480  614.695088

        [185 rows x 2 columns]
        ```
    &#34;&#34;&#34;
    return super().from_params(ts, window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.indicators.MSTD.ewm_loc"><code class="name">var <span class="ident">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD.mstd"><code class="name">var <span class="ident">mstd</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD.ts"><code class="name">var <span class="ident">ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD.tuple_loc"><code class="name">var <span class="ident">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter tuple using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD.window_loc"><code class="name">var <span class="ident">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.MSTD.mstd_above"><code class="name flex">
<span>def <span class="ident">mstd_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>mstd</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>mstd</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD.mstd_below"><code class="name flex">
<span>def <span class="ident">mstd_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>mstd</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>mstd</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD.mstd_equal"><code class="name flex">
<span>def <span class="ident">mstd_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>mstd</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>mstd</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, mstd_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.indicators.MSTD.mstd" href="#vectorbt.indicators.indicators.MSTD.mstd">MSTD.mstd</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mstd_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of <code><a title="vectorbt.indicators.indicators.MSTD.mstd" href="#vectorbt.indicators.indicators.MSTD.mstd">MSTD.mstd</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code>, optional</dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.widgets.common.FigureWidget" href="../widgets/common.html#vectorbt.widgets.common.FigureWidget">FigureWidget</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="py">mstd[(10, False)].plot()
</code></pre>
<p><img alt="" src="img/MSTD.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         mstd_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    &#34;&#34;&#34;Plot `MSTD.mstd`.

    Args:
        mstd_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `MSTD.mstd`.
        fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Returns:
        vectorbt.widgets.common.FigureWidget
    Examples:
        ```py
        mstd[(10, False)].plot()
        ```

        ![](img/MSTD.png)&#34;&#34;&#34;
    checks.assert_type(self.mstd, pd.Series)

    mstd_trace_kwargs = {**dict(
        name=f&#39;MSTD ({self.name})&#39;
    ), **mstd_trace_kwargs}

    fig = self.mstd.vbt.timeseries.plot(trace_kwargs=mstd_trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD.ts_above"><code class="name flex">
<span>def <span class="ident">ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD.ts_below"><code class="name flex">
<span>def <span class="ident">ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD.ts_equal"><code class="name flex">
<span>def <span class="ident">ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.MSTD.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.indicators.OBV"><code class="flex name class">
<span>class <span class="ident">OBV</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>On-balance volume (OBV) is a technical trading momentum indicator that uses volume flow to predict
changes in stock price.</p>
<p>See <a href="https://www.investopedia.com/terms/o/onbalancevolume.asp">On-Balance Volume (OBV)</a>.</p>
<p>Use <code><a title="vectorbt.indicators.indicators.OBV.from_params" href="#vectorbt.indicators.indicators.OBV.from_params">OBV.from_params()</a></code> methods to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OBV(OBV):
    &#34;&#34;&#34;On-balance volume (OBV) is a technical trading momentum indicator that uses volume flow to predict 
    changes in stock price.

    See [On-Balance Volume (OBV)](https://www.investopedia.com/terms/o/onbalancevolume.asp).

    Use `OBV.from_params` methods to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, close_ts, volume_ts):
        &#34;&#34;&#34;Calculate on-balance volume `OBV.obv` from time series `close_ts` and `volume_ts`, and no parameters.

        Args:
            close_ts (pandas_like): The last closing price.
            volume_ts (pandas_like): The volume.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            OBV
        Examples:
            ```python-repl
            &gt;&gt;&gt; obv = vbt.OBV.from_params(price[&#39;Close&#39;], price[&#39;Volume&#39;])

            &gt;&gt;&gt; print(obv.obv)
            Date
            2019-02-28             NaN
            2019-03-01    7.661248e+09
            2019-03-02    1.524003e+10
            2019-03-03    7.986476e+09
            2019-03-04   -1.042700e+09
                                   ...     
            2019-08-27    5.613088e+11
            2019-08-28    5.437050e+11
            2019-08-29    5.266592e+11
            2019-08-30    5.402544e+11
            2019-08-31    5.517092e+11
            Name: (Close, Volume), Length: 185, dtype: float64
            ```
        &#34;&#34;&#34;
        return super().from_params(close_ts, volume_ts)

    def plot(self,
             obv_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `OBV.obv`.

        Args:
            obv_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `OBV.obv`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            obv.plot()
            ```

            ![](img/OBV.png)&#34;&#34;&#34;
        checks.assert_type(self.obv, pd.Series)

        obv_trace_kwargs = {**dict(
            name=f&#39;OBV ({self.name})&#39;
        ), **obv_trace_kwargs}

        fig = self.obv.vbt.timeseries.plot(trace_kwargs=obv_trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.factory.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.OBV.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>close_ts, volume_ts)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate on-balance volume <code><a title="vectorbt.indicators.indicators.OBV.obv" href="#vectorbt.indicators.indicators.OBV.obv">OBV.obv</a></code> from time series <code>close_ts</code> and <code>volume_ts</code>, and no parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>close_ts</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>The last closing price.</dd>
<dt><strong><code>volume_ts</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>The volume.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.indicators.factory.from_params_pipeline" href="factory.html#vectorbt.indicators.factory.from_params_pipeline">from_params_pipeline()</a>.</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.indicators.indicators.OBV" href="#vectorbt.indicators.indicators.OBV">OBV</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; obv = vbt.OBV.from_params(price['Close'], price['Volume'])

&gt;&gt;&gt; print(obv.obv)
Date
2019-02-28             NaN
2019-03-01    7.661248e+09
2019-03-02    1.524003e+10
2019-03-03    7.986476e+09
2019-03-04   -1.042700e+09
                       ...     
2019-08-27    5.613088e+11
2019-08-28    5.437050e+11
2019-08-29    5.266592e+11
2019-08-30    5.402544e+11
2019-08-31    5.517092e+11
Name: (Close, Volume), Length: 185, dtype: float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, close_ts, volume_ts):
    &#34;&#34;&#34;Calculate on-balance volume `OBV.obv` from time series `close_ts` and `volume_ts`, and no parameters.

    Args:
        close_ts (pandas_like): The last closing price.
        volume_ts (pandas_like): The volume.
        **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
    Returns:
        OBV
    Examples:
        ```python-repl
        &gt;&gt;&gt; obv = vbt.OBV.from_params(price[&#39;Close&#39;], price[&#39;Volume&#39;])

        &gt;&gt;&gt; print(obv.obv)
        Date
        2019-02-28             NaN
        2019-03-01    7.661248e+09
        2019-03-02    1.524003e+10
        2019-03-03    7.986476e+09
        2019-03-04   -1.042700e+09
                               ...     
        2019-08-27    5.613088e+11
        2019-08-28    5.437050e+11
        2019-08-29    5.266592e+11
        2019-08-30    5.402544e+11
        2019-08-31    5.517092e+11
        Name: (Close, Volume), Length: 185, dtype: float64
        ```
    &#34;&#34;&#34;
    return super().from_params(close_ts, volume_ts)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.indicators.OBV.close_ts"><code class="name">var <span class="ident">close_ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.obv"><code class="name">var <span class="ident">obv</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.volume_ts"><code class="name">var <span class="ident">volume_ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.OBV.close_ts_above"><code class="name flex">
<span>def <span class="ident">close_ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.close_ts_below"><code class="name flex">
<span>def <span class="ident">close_ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.close_ts_equal"><code class="name flex">
<span>def <span class="ident">close_ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.obv_above"><code class="name flex">
<span>def <span class="ident">obv_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>obv</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>obv</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.obv_below"><code class="name flex">
<span>def <span class="ident">obv_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>obv</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>obv</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.obv_equal"><code class="name flex">
<span>def <span class="ident">obv_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>obv</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>obv</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, obv_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.indicators.OBV.obv" href="#vectorbt.indicators.indicators.OBV.obv">OBV.obv</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obv_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of <code><a title="vectorbt.indicators.indicators.OBV.obv" href="#vectorbt.indicators.indicators.OBV.obv">OBV.obv</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code>, optional</dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.widgets.common.FigureWidget" href="../widgets/common.html#vectorbt.widgets.common.FigureWidget">FigureWidget</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="py">obv.plot()
</code></pre>
<p><img alt="" src="img/OBV.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         obv_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    &#34;&#34;&#34;Plot `OBV.obv`.

    Args:
        obv_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `OBV.obv`.
        fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Returns:
        vectorbt.widgets.common.FigureWidget
    Examples:
        ```py
        obv.plot()
        ```

        ![](img/OBV.png)&#34;&#34;&#34;
    checks.assert_type(self.obv, pd.Series)

    obv_trace_kwargs = {**dict(
        name=f&#39;OBV ({self.name})&#39;
    ), **obv_trace_kwargs}

    fig = self.obv.vbt.timeseries.plot(trace_kwargs=obv_trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.volume_ts_above"><code class="name flex">
<span>def <span class="ident">volume_ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>volume_ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>volume_ts</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.volume_ts_below"><code class="name flex">
<span>def <span class="ident">volume_ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>volume_ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>volume_ts</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.volume_ts_equal"><code class="name flex">
<span>def <span class="ident">volume_ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>volume_ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>volume_ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.OBV.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.indicators.RSI"><code class="flex name class">
<span>class <span class="ident">RSI</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The relative strength index (RSI) is a momentum indicator that measures the magnitude of
recent price changes to evaluate overbought or oversold conditions in the price of a stock
or other asset. The RSI is displayed as an oscillator (a line graph that moves between two
extremes) and can have a reading from 0 to 100.</p>
<p>See <a href="https://www.investopedia.com/terms/r/rsi.asp">Relative Strength Index (RSI)</a>.</p>
<p>Use <code><a title="vectorbt.indicators.indicators.RSI.from_params" href="#vectorbt.indicators.indicators.RSI.from_params">RSI.from_params()</a></code> methods to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RSI(RSI):
    &#34;&#34;&#34;The relative strength index (RSI) is a momentum indicator that measures the magnitude of 
    recent price changes to evaluate overbought or oversold conditions in the price of a stock 
    or other asset. The RSI is displayed as an oscillator (a line graph that moves between two 
    extremes) and can have a reading from 0 to 100.

    See [Relative Strength Index (RSI)](https://www.investopedia.com/terms/r/rsi.asp).

    Use `RSI.from_params` methods to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, ts, window=14, ewm=False, **kwargs):
        &#34;&#34;&#34;Calculate relative strength index `RSI.rsi` from time series `ts` and parameters `window` and `ewm`.

        Args:
            ts (pandas_like): Time series (such as price).
            window (int or array_like): Size of the moving window. Can be one or more values. Defaults to 14.
            ewm (bool or array_like): If True, uses exponential moving average, otherwise 
                simple moving average. Can be one or more values. Defaults to False.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            RSI
        Examples:
            ```python-repl
            &gt;&gt;&gt; rsi = vbt.RSI.from_params(price[&#39;Close&#39;], [10, 20], ewm=[False, True])

            &gt;&gt;&gt; print(rsi.rsi)
            rsi_window         10         20
            rsi_ewm         False       True
            Date                            
            2019-02-28        NaN        NaN
            2019-03-01        NaN        NaN
            2019-03-02        NaN        NaN
            ...               ...        ...
            2019-08-29  21.004434  34.001218
            2019-08-30  25.310248  36.190915
            2019-08-31  35.640258  37.043562

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        return super().from_params(ts, window, ewm, **kwargs)

    def plot(self,
             levels=(30, 70),
             rsi_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `RSI.rsi`.

        Args:
            trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `RSI.rsi`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            rsi[(10, False)].plot()
            ```

            ![](img/RSI.png)&#34;&#34;&#34;
        checks.assert_type(self.rsi, pd.Series)

        rsi_trace_kwargs = {**dict(
            name=f&#39;RSI ({self.name})&#39;
        ), **rsi_trace_kwargs}

        layout_kwargs = {**dict(yaxis=dict(range=[-5, 105])), **layout_kwargs}
        fig = self.rsi.vbt.timeseries.plot(trace_kwargs=rsi_trace_kwargs, fig=fig, **layout_kwargs)

        # Fill void between levels
        fig.add_shape(
            type=&#34;rect&#34;,
            xref=&#34;x&#34;,
            yref=&#34;y&#34;,
            x0=self.rsi.index[0],
            y0=levels[0],
            x1=self.rsi.index[-1],
            y1=levels[1],
            fillcolor=&#34;purple&#34;,
            opacity=0.1,
            layer=&#34;below&#34;,
            line_width=0,
        )

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.factory.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.RSI.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, window=14, ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate relative strength index <code><a title="vectorbt.indicators.indicators.RSI.rsi" href="#vectorbt.indicators.indicators.RSI.rsi">RSI.rsi</a></code> from time series <code>ts</code> and parameters <code>window</code> and <code>ewm</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Time series (such as price).</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Size of the moving window. Can be one or more values. Defaults to 14.</dd>
<dt><strong><code>ewm</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>If True, uses exponential moving average, otherwise
simple moving average. Can be one or more values. Defaults to False.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.indicators.factory.from_params_pipeline" href="factory.html#vectorbt.indicators.factory.from_params_pipeline">from_params_pipeline()</a>.</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.indicators.indicators.RSI" href="#vectorbt.indicators.indicators.RSI">RSI</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; rsi = vbt.RSI.from_params(price['Close'], [10, 20], ewm=[False, True])

&gt;&gt;&gt; print(rsi.rsi)
rsi_window         10         20
rsi_ewm         False       True
Date                            
2019-02-28        NaN        NaN
2019-03-01        NaN        NaN
2019-03-02        NaN        NaN
...               ...        ...
2019-08-29  21.004434  34.001218
2019-08-30  25.310248  36.190915
2019-08-31  35.640258  37.043562

[185 rows x 2 columns]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, window=14, ewm=False, **kwargs):
    &#34;&#34;&#34;Calculate relative strength index `RSI.rsi` from time series `ts` and parameters `window` and `ewm`.

    Args:
        ts (pandas_like): Time series (such as price).
        window (int or array_like): Size of the moving window. Can be one or more values. Defaults to 14.
        ewm (bool or array_like): If True, uses exponential moving average, otherwise 
            simple moving average. Can be one or more values. Defaults to False.
        **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
    Returns:
        RSI
    Examples:
        ```python-repl
        &gt;&gt;&gt; rsi = vbt.RSI.from_params(price[&#39;Close&#39;], [10, 20], ewm=[False, True])

        &gt;&gt;&gt; print(rsi.rsi)
        rsi_window         10         20
        rsi_ewm         False       True
        Date                            
        2019-02-28        NaN        NaN
        2019-03-01        NaN        NaN
        2019-03-02        NaN        NaN
        ...               ...        ...
        2019-08-29  21.004434  34.001218
        2019-08-30  25.310248  36.190915
        2019-08-31  35.640258  37.043562

        [185 rows x 2 columns]
        ```
    &#34;&#34;&#34;
    return super().from_params(ts, window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.indicators.RSI.ewm_loc"><code class="name">var <span class="ident">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.RSI.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.RSI.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.RSI.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.RSI.rsi"><code class="name">var <span class="ident">rsi</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.RSI.ts"><code class="name">var <span class="ident">ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.RSI.tuple_loc"><code class="name">var <span class="ident">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter tuple using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.RSI.window_loc"><code class="name">var <span class="ident">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.RSI.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, levels=(30, 70), rsi_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.indicators.RSI.rsi" href="#vectorbt.indicators.indicators.RSI.rsi">RSI.rsi</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of <code><a title="vectorbt.indicators.indicators.RSI.rsi" href="#vectorbt.indicators.indicators.RSI.rsi">RSI.rsi</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code>, optional</dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.widgets.common.FigureWidget" href="../widgets/common.html#vectorbt.widgets.common.FigureWidget">FigureWidget</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="py">rsi[(10, False)].plot()
</code></pre>
<p><img alt="" src="img/RSI.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         levels=(30, 70),
         rsi_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    &#34;&#34;&#34;Plot `RSI.rsi`.

    Args:
        trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of `RSI.rsi`.
        fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Returns:
        vectorbt.widgets.common.FigureWidget
    Examples:
        ```py
        rsi[(10, False)].plot()
        ```

        ![](img/RSI.png)&#34;&#34;&#34;
    checks.assert_type(self.rsi, pd.Series)

    rsi_trace_kwargs = {**dict(
        name=f&#39;RSI ({self.name})&#39;
    ), **rsi_trace_kwargs}

    layout_kwargs = {**dict(yaxis=dict(range=[-5, 105])), **layout_kwargs}
    fig = self.rsi.vbt.timeseries.plot(trace_kwargs=rsi_trace_kwargs, fig=fig, **layout_kwargs)

    # Fill void between levels
    fig.add_shape(
        type=&#34;rect&#34;,
        xref=&#34;x&#34;,
        yref=&#34;y&#34;,
        x0=self.rsi.index[0],
        y0=levels[0],
        x1=self.rsi.index[-1],
        y1=levels[1],
        fillcolor=&#34;purple&#34;,
        opacity=0.1,
        layer=&#34;below&#34;,
        line_width=0,
    )

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.RSI.rsi_above"><code class="name flex">
<span>def <span class="ident">rsi_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>rsi</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>rsi</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.RSI.rsi_below"><code class="name flex">
<span>def <span class="ident">rsi_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>rsi</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>rsi</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.RSI.rsi_equal"><code class="name flex">
<span>def <span class="ident">rsi_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>rsi</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>rsi</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.RSI.ts_above"><code class="name flex">
<span>def <span class="ident">ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.RSI.ts_below"><code class="name flex">
<span>def <span class="ident">ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.RSI.ts_equal"><code class="name flex">
<span>def <span class="ident">ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.RSI.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic"><code class="flex name class">
<span>class <span class="ident">Stochastic</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A stochastic oscillator is a momentum indicator comparing a particular closing price of a security
to a range of its prices over a certain period of time. It is used to generate overbought and oversold
trading signals, utilizing a 0-100 bounded range of values.</p>
<p>See <a href="https://www.investopedia.com/terms/s/stochasticoscillator.asp">Stochastic Oscillator</a>.</p>
<p>Use <code><a title="vectorbt.indicators.indicators.Stochastic.from_params" href="#vectorbt.indicators.indicators.Stochastic.from_params">Stochastic.from_params()</a></code> methods to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stochastic(Stochastic):
    &#34;&#34;&#34;A stochastic oscillator is a momentum indicator comparing a particular closing price of a security 
    to a range of its prices over a certain period of time. It is used to generate overbought and oversold 
    trading signals, utilizing a 0-100 bounded range of values.

    See [Stochastic Oscillator](https://www.investopedia.com/terms/s/stochasticoscillator.asp).

    Use `Stochastic.from_params` methods to run the indicator.&#34;&#34;&#34;
    @classmethod
    def from_params(cls, close_ts, high_ts=None, low_ts=None, k_window=14, d_window=3, d_ewm=False, **kwargs):
        &#34;&#34;&#34;Calculate %K `Stochastic.percent_k` and %D `Stochastic.percent_d` from time series `close_ts`, 
        `high_ts`, and `low_ts`, and parameters `k_window`, `d_window` and `d_ewm`.

        Args:
            close_ts (pandas_like): The last closing price.
            high_ts (pandas_like, optional): The highest price. If None, uses `close_ts`.
            low_ts (pandas_like, optional): The lowest price. If None, uses `close_ts`.
            k_window (int or array_like): Size of the moving window for %K. Can be one or more values. 
                Defaults to 14.
            d_window (int or array_like): Size of the moving window for %D. Can be one or more values. 
                Defaults to 3.
            d_ewm (bool or array_like): If True, uses exponential moving average for %D, otherwise 
                simple moving average. Can be one or more values. Defaults to False.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
        Returns:
            Stochastic
        Examples:
            ```python-repl
            &gt;&gt;&gt; stoch = vbt.Stochastic.from_params(price[&#39;Close&#39;],
            ...     high_ts=price[&#39;High&#39;], low_ts=price[&#39;Low&#39;],
            ...     k_window=[10, 20], d_window=[2, 3], d_ewm=[False, True])

            &gt;&gt;&gt; print(stoch.percent_k)
            stoch_k_window         10         20
            stoch_d_window          2          3
            stoch_d_ewm         False       True
            Date                                
            2019-02-28            NaN        NaN
            2019-03-01            NaN        NaN
            2019-03-02            NaN        NaN
            ...                   ...        ...
            2019-08-29       5.806308   3.551280
            2019-08-30      12.819694   8.380488
            2019-08-31      19.164757   9.922813

            [185 rows x 2 columns]

            &gt;&gt;&gt; print(stoch.percent_d)
            stoch_k_window         10         20
            stoch_d_window          2          3
            stoch_d_ewm         False       True
            Date                                
            2019-02-28            NaN        NaN
            2019-03-01            NaN        NaN
            2019-03-02            NaN        NaN
            ...                   ...        ...
            2019-08-29       4.437639   8.498544
            2019-08-30       9.313001   8.439516
            2019-08-31      15.992225   9.181164

            [185 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        if high_ts is None:
            high_ts = close_ts
        if low_ts is None:
            low_ts = close_ts
        return super().from_params(close_ts, high_ts, low_ts, k_window, d_window, d_ewm, **kwargs)

    def plot(self,
             levels=(30, 70),
             percent_k_trace_kwargs={},
             percent_d_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot `Stochastic.percent_k` and `Stochastic.percent_d`.

        Args:
            percent_k_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `Stochastic.percent_k`.
            percent_d_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
                `Stochastic.percent_d`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Returns:
            vectorbt.widgets.common.FigureWidget
        Examples:
            ```py
            stoch[(10, 2, False)].plot(levels=(20, 80))
            ```

            ![](img/Stochastic.png)&#34;&#34;&#34;
        checks.assert_type(self.percent_k, pd.Series)
        checks.assert_type(self.percent_d, pd.Series)

        percent_k_trace_kwargs = {**dict(
            name=f&#39;%K ({self.name})&#39;
        ), **percent_k_trace_kwargs}
        percent_d_trace_kwargs = {**dict(
            name=f&#39;%D ({self.name})&#39;
        ), **percent_d_trace_kwargs}

        layout_kwargs = {**dict(yaxis=dict(range=[-5, 105])), **layout_kwargs}
        fig = self.percent_k.vbt.timeseries.plot(trace_kwargs=percent_k_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.percent_d.vbt.timeseries.plot(trace_kwargs=percent_d_trace_kwargs, fig=fig, **layout_kwargs)

        # Plot levels
        # Fill void between levels
        fig.add_shape(
            type=&#34;rect&#34;,
            xref=&#34;x&#34;,
            yref=&#34;y&#34;,
            x0=self.percent_k.index[0],
            y0=levels[0],
            x1=self.percent_k.index[-1],
            y1=levels[1],
            fillcolor=&#34;purple&#34;,
            opacity=0.1,
            layer=&#34;below&#34;,
            line_width=0,
        )

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.factory.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.Stochastic.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>close_ts, high_ts=None, low_ts=None, k_window=14, d_window=3, d_ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate %K <code><a title="vectorbt.indicators.indicators.Stochastic.percent_k" href="#vectorbt.indicators.indicators.Stochastic.percent_k">Stochastic.percent_k</a></code> and %D <code><a title="vectorbt.indicators.indicators.Stochastic.percent_d" href="#vectorbt.indicators.indicators.Stochastic.percent_d">Stochastic.percent_d</a></code> from time series <code>close_ts</code>,
<code>high_ts</code>, and <code>low_ts</code>, and parameters <code>k_window</code>, <code>d_window</code> and <code>d_ewm</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>close_ts</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>The last closing price.</dd>
<dt><strong><code>high_ts</code></strong> :&ensp;<code>pandas_like</code>, optional</dt>
<dd>The highest price. If None, uses <code>close_ts</code>.</dd>
<dt><strong><code>low_ts</code></strong> :&ensp;<code>pandas_like</code>, optional</dt>
<dd>The lowest price. If None, uses <code>close_ts</code>.</dd>
<dt><strong><code>k_window</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Size of the moving window for %K. Can be one or more values.
Defaults to 14.</dd>
<dt><strong><code>d_window</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Size of the moving window for %D. Can be one or more values.
Defaults to 3.</dd>
<dt><strong><code>d_ewm</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>If True, uses exponential moving average for %D, otherwise
simple moving average. Can be one or more values. Defaults to False.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.indicators.factory.from_params_pipeline" href="factory.html#vectorbt.indicators.factory.from_params_pipeline">from_params_pipeline()</a>.</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.indicators.indicators.Stochastic" href="#vectorbt.indicators.indicators.Stochastic">Stochastic</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; stoch = vbt.Stochastic.from_params(price['Close'],
...     high_ts=price['High'], low_ts=price['Low'],
...     k_window=[10, 20], d_window=[2, 3], d_ewm=[False, True])

&gt;&gt;&gt; print(stoch.percent_k)
stoch_k_window         10         20
stoch_d_window          2          3
stoch_d_ewm         False       True
Date                                
2019-02-28            NaN        NaN
2019-03-01            NaN        NaN
2019-03-02            NaN        NaN
...                   ...        ...
2019-08-29       5.806308   3.551280
2019-08-30      12.819694   8.380488
2019-08-31      19.164757   9.922813

[185 rows x 2 columns]

&gt;&gt;&gt; print(stoch.percent_d)
stoch_k_window         10         20
stoch_d_window          2          3
stoch_d_ewm         False       True
Date                                
2019-02-28            NaN        NaN
2019-03-01            NaN        NaN
2019-03-02            NaN        NaN
...                   ...        ...
2019-08-29       4.437639   8.498544
2019-08-30       9.313001   8.439516
2019-08-31      15.992225   9.181164

[185 rows x 2 columns]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, close_ts, high_ts=None, low_ts=None, k_window=14, d_window=3, d_ewm=False, **kwargs):
    &#34;&#34;&#34;Calculate %K `Stochastic.percent_k` and %D `Stochastic.percent_d` from time series `close_ts`, 
    `high_ts`, and `low_ts`, and parameters `k_window`, `d_window` and `d_ewm`.

    Args:
        close_ts (pandas_like): The last closing price.
        high_ts (pandas_like, optional): The highest price. If None, uses `close_ts`.
        low_ts (pandas_like, optional): The lowest price. If None, uses `close_ts`.
        k_window (int or array_like): Size of the moving window for %K. Can be one or more values. 
            Defaults to 14.
        d_window (int or array_like): Size of the moving window for %D. Can be one or more values. 
            Defaults to 3.
        d_ewm (bool or array_like): If True, uses exponential moving average for %D, otherwise 
            simple moving average. Can be one or more values. Defaults to False.
        **kwargs: Keyword arguments passed to `vectorbt.indicators.factory.from_params_pipeline.`
    Returns:
        Stochastic
    Examples:
        ```python-repl
        &gt;&gt;&gt; stoch = vbt.Stochastic.from_params(price[&#39;Close&#39;],
        ...     high_ts=price[&#39;High&#39;], low_ts=price[&#39;Low&#39;],
        ...     k_window=[10, 20], d_window=[2, 3], d_ewm=[False, True])

        &gt;&gt;&gt; print(stoch.percent_k)
        stoch_k_window         10         20
        stoch_d_window          2          3
        stoch_d_ewm         False       True
        Date                                
        2019-02-28            NaN        NaN
        2019-03-01            NaN        NaN
        2019-03-02            NaN        NaN
        ...                   ...        ...
        2019-08-29       5.806308   3.551280
        2019-08-30      12.819694   8.380488
        2019-08-31      19.164757   9.922813

        [185 rows x 2 columns]

        &gt;&gt;&gt; print(stoch.percent_d)
        stoch_k_window         10         20
        stoch_d_window          2          3
        stoch_d_ewm         False       True
        Date                                
        2019-02-28            NaN        NaN
        2019-03-01            NaN        NaN
        2019-03-02            NaN        NaN
        ...                   ...        ...
        2019-08-29       4.437639   8.498544
        2019-08-30       9.313001   8.439516
        2019-08-31      15.992225   9.181164

        [185 rows x 2 columns]
        ```
    &#34;&#34;&#34;
    if high_ts is None:
        high_ts = close_ts
    if low_ts is None:
        low_ts = close_ts
    return super().from_params(close_ts, high_ts, low_ts, k_window, d_window, d_ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.indicators.Stochastic.close_ts"><code class="name">var <span class="ident">close_ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.d_ewm_loc"><code class="name">var <span class="ident">d_ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter d_ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.d_window_loc"><code class="name">var <span class="ident">d_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter d_window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.high_ts"><code class="name">var <span class="ident">high_ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.k_window_loc"><code class="name">var <span class="ident">k_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter k_window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.low_ts"><code class="name">var <span class="ident">low_ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.percent_d"><code class="name">var <span class="ident">percent_d</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.percent_k"><code class="name">var <span class="ident">percent_k</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.tuple_loc"><code class="name">var <span class="ident">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter tuple using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.indicators.Stochastic.close_ts_above"><code class="name flex">
<span>def <span class="ident">close_ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.close_ts_below"><code class="name flex">
<span>def <span class="ident">close_ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.close_ts_equal"><code class="name flex">
<span>def <span class="ident">close_ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.high_ts_above"><code class="name flex">
<span>def <span class="ident">high_ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>high_ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high_ts</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.high_ts_below"><code class="name flex">
<span>def <span class="ident">high_ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>high_ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high_ts</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.high_ts_equal"><code class="name flex">
<span>def <span class="ident">high_ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>high_ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high_ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.low_ts_above"><code class="name flex">
<span>def <span class="ident">low_ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>low_ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low_ts</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.low_ts_below"><code class="name flex">
<span>def <span class="ident">low_ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>low_ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low_ts</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.low_ts_equal"><code class="name flex">
<span>def <span class="ident">low_ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>low_ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low_ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.percent_d_above"><code class="name flex">
<span>def <span class="ident">percent_d_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_d</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_d</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.percent_d_below"><code class="name flex">
<span>def <span class="ident">percent_d_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_d</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_d</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.percent_d_equal"><code class="name flex">
<span>def <span class="ident">percent_d_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_d</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_d</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.percent_k_above"><code class="name flex">
<span>def <span class="ident">percent_k_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_k</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_k</code> is above for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.percent_k_below"><code class="name flex">
<span>def <span class="ident">percent_k_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_k</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_k</code> is below for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.percent_k_equal"><code class="name flex">
<span>def <span class="ident">percent_k_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_k</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_k</code> is equal for a number of time steps in a row after crossover.</p>
<p>For more details, see <code><a title="vectorbt.indicators.factory.compare" href="factory.html#vectorbt.indicators.factory.compare">compare()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = compare(getattr(self, attr), other, compare_func, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, levels=(30, 70), percent_k_trace_kwargs={}, percent_d_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.indicators.indicators.Stochastic.percent_k" href="#vectorbt.indicators.indicators.Stochastic.percent_k">Stochastic.percent_k</a></code> and <code><a title="vectorbt.indicators.indicators.Stochastic.percent_d" href="#vectorbt.indicators.indicators.Stochastic.percent_d">Stochastic.percent_d</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>percent_k_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of
<code><a title="vectorbt.indicators.indicators.Stochastic.percent_k" href="#vectorbt.indicators.indicators.Stochastic.percent_k">Stochastic.percent_k</a></code>.</dd>
<dt><strong><code>percent_d_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> of
<code><a title="vectorbt.indicators.indicators.Stochastic.percent_d" href="#vectorbt.indicators.indicators.Stochastic.percent_d">Stochastic.percent_d</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code>, optional</dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="vectorbt.widgets.common.FigureWidget" href="../widgets/common.html#vectorbt.widgets.common.FigureWidget">FigureWidget</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="py">stoch[(10, 2, False)].plot(levels=(20, 80))
</code></pre>
<p><img alt="" src="img/Stochastic.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         levels=(30, 70),
         percent_k_trace_kwargs={},
         percent_d_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    &#34;&#34;&#34;Plot `Stochastic.percent_k` and `Stochastic.percent_d`.

    Args:
        percent_k_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
            `Stochastic.percent_k`.
        percent_d_trace_kwargs (dict, optional): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) of 
            `Stochastic.percent_d`.
        fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Returns:
        vectorbt.widgets.common.FigureWidget
    Examples:
        ```py
        stoch[(10, 2, False)].plot(levels=(20, 80))
        ```

        ![](img/Stochastic.png)&#34;&#34;&#34;
    checks.assert_type(self.percent_k, pd.Series)
    checks.assert_type(self.percent_d, pd.Series)

    percent_k_trace_kwargs = {**dict(
        name=f&#39;%K ({self.name})&#39;
    ), **percent_k_trace_kwargs}
    percent_d_trace_kwargs = {**dict(
        name=f&#39;%D ({self.name})&#39;
    ), **percent_d_trace_kwargs}

    layout_kwargs = {**dict(yaxis=dict(range=[-5, 105])), **layout_kwargs}
    fig = self.percent_k.vbt.timeseries.plot(trace_kwargs=percent_k_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.percent_d.vbt.timeseries.plot(trace_kwargs=percent_d_trace_kwargs, fig=fig, **layout_kwargs)

    # Plot levels
    # Fill void between levels
    fig.add_shape(
        type=&#34;rect&#34;,
        xref=&#34;x&#34;,
        yref=&#34;y&#34;,
        x0=self.percent_k.index[0],
        y0=levels[0],
        x1=self.percent_k.index[-1],
        y1=levels[1],
        fillcolor=&#34;purple&#34;,
        opacity=0.1,
        layer=&#34;below&#34;,
        line_width=0,
    )

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.indicators.Stochastic.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.indicators" href="index.html">vectorbt.indicators</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.indicators.atr_apply_func_nb" href="#vectorbt.indicators.indicators.atr_apply_func_nb">atr_apply_func_nb</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.atr_caching_nb" href="#vectorbt.indicators.indicators.atr_caching_nb">atr_caching_nb</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.bb_apply_func_nb" href="#vectorbt.indicators.indicators.bb_apply_func_nb">bb_apply_func_nb</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.bb_caching_nb" href="#vectorbt.indicators.indicators.bb_caching_nb">bb_caching_nb</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ma_apply_func_nb" href="#vectorbt.indicators.indicators.ma_apply_func_nb">ma_apply_func_nb</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ma_caching_nb" href="#vectorbt.indicators.indicators.ma_caching_nb">ma_caching_nb</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.macd_apply_func_nb" href="#vectorbt.indicators.indicators.macd_apply_func_nb">macd_apply_func_nb</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.macd_caching_nb" href="#vectorbt.indicators.indicators.macd_caching_nb">macd_caching_nb</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.mstd_apply_func_nb" href="#vectorbt.indicators.indicators.mstd_apply_func_nb">mstd_apply_func_nb</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.mstd_caching_nb" href="#vectorbt.indicators.indicators.mstd_caching_nb">mstd_caching_nb</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.obv_custom_func" href="#vectorbt.indicators.indicators.obv_custom_func">obv_custom_func</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.obv_custom_func_nb" href="#vectorbt.indicators.indicators.obv_custom_func_nb">obv_custom_func_nb</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.rsi_apply_func_nb" href="#vectorbt.indicators.indicators.rsi_apply_func_nb">rsi_apply_func_nb</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.rsi_caching_nb" href="#vectorbt.indicators.indicators.rsi_caching_nb">rsi_caching_nb</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.stoch_apply_func_nb" href="#vectorbt.indicators.indicators.stoch_apply_func_nb">stoch_apply_func_nb</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.stoch_caching_nb" href="#vectorbt.indicators.indicators.stoch_caching_nb">stoch_caching_nb</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.indicators.indicators.ATR" href="#vectorbt.indicators.indicators.ATR">ATR</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.indicators.ATR.atr" href="#vectorbt.indicators.indicators.ATR.atr">atr</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.atr_above" href="#vectorbt.indicators.indicators.ATR.atr_above">atr_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.atr_below" href="#vectorbt.indicators.indicators.ATR.atr_below">atr_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.atr_equal" href="#vectorbt.indicators.indicators.ATR.atr_equal">atr_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.close_ts" href="#vectorbt.indicators.indicators.ATR.close_ts">close_ts</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.close_ts_above" href="#vectorbt.indicators.indicators.ATR.close_ts_above">close_ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.close_ts_below" href="#vectorbt.indicators.indicators.ATR.close_ts_below">close_ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.close_ts_equal" href="#vectorbt.indicators.indicators.ATR.close_ts_equal">close_ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.ewm_loc" href="#vectorbt.indicators.indicators.ATR.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.from_params" href="#vectorbt.indicators.indicators.ATR.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.high_ts" href="#vectorbt.indicators.indicators.ATR.high_ts">high_ts</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.high_ts_above" href="#vectorbt.indicators.indicators.ATR.high_ts_above">high_ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.high_ts_below" href="#vectorbt.indicators.indicators.ATR.high_ts_below">high_ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.high_ts_equal" href="#vectorbt.indicators.indicators.ATR.high_ts_equal">high_ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.iloc" href="#vectorbt.indicators.indicators.ATR.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.loc" href="#vectorbt.indicators.indicators.ATR.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.low_ts" href="#vectorbt.indicators.indicators.ATR.low_ts">low_ts</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.low_ts_above" href="#vectorbt.indicators.indicators.ATR.low_ts_above">low_ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.low_ts_below" href="#vectorbt.indicators.indicators.ATR.low_ts_below">low_ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.low_ts_equal" href="#vectorbt.indicators.indicators.ATR.low_ts_equal">low_ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.name" href="#vectorbt.indicators.indicators.ATR.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.plot" href="#vectorbt.indicators.indicators.ATR.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.tr" href="#vectorbt.indicators.indicators.ATR.tr">tr</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.tr_above" href="#vectorbt.indicators.indicators.ATR.tr_above">tr_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.tr_below" href="#vectorbt.indicators.indicators.ATR.tr_below">tr_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.tr_equal" href="#vectorbt.indicators.indicators.ATR.tr_equal">tr_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.tuple_loc" href="#vectorbt.indicators.indicators.ATR.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.window_loc" href="#vectorbt.indicators.indicators.ATR.window_loc">window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.ATR.xs" href="#vectorbt.indicators.indicators.ATR.xs">xs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.indicators.BollingerBands" href="#vectorbt.indicators.indicators.BollingerBands">BollingerBands</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.alpha_loc" href="#vectorbt.indicators.indicators.BollingerBands.alpha_loc">alpha_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.bandwidth" href="#vectorbt.indicators.indicators.BollingerBands.bandwidth">bandwidth</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.bandwidth_above" href="#vectorbt.indicators.indicators.BollingerBands.bandwidth_above">bandwidth_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.bandwidth_below" href="#vectorbt.indicators.indicators.BollingerBands.bandwidth_below">bandwidth_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.bandwidth_equal" href="#vectorbt.indicators.indicators.BollingerBands.bandwidth_equal">bandwidth_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.ewm_loc" href="#vectorbt.indicators.indicators.BollingerBands.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.from_params" href="#vectorbt.indicators.indicators.BollingerBands.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.iloc" href="#vectorbt.indicators.indicators.BollingerBands.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.loc" href="#vectorbt.indicators.indicators.BollingerBands.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.lower_band" href="#vectorbt.indicators.indicators.BollingerBands.lower_band">lower_band</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.lower_band_above" href="#vectorbt.indicators.indicators.BollingerBands.lower_band_above">lower_band_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.lower_band_below" href="#vectorbt.indicators.indicators.BollingerBands.lower_band_below">lower_band_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.lower_band_equal" href="#vectorbt.indicators.indicators.BollingerBands.lower_band_equal">lower_band_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.ma" href="#vectorbt.indicators.indicators.BollingerBands.ma">ma</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.ma_above" href="#vectorbt.indicators.indicators.BollingerBands.ma_above">ma_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.ma_below" href="#vectorbt.indicators.indicators.BollingerBands.ma_below">ma_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.ma_equal" href="#vectorbt.indicators.indicators.BollingerBands.ma_equal">ma_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.name" href="#vectorbt.indicators.indicators.BollingerBands.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.percent_b" href="#vectorbt.indicators.indicators.BollingerBands.percent_b">percent_b</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.percent_b_above" href="#vectorbt.indicators.indicators.BollingerBands.percent_b_above">percent_b_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.percent_b_below" href="#vectorbt.indicators.indicators.BollingerBands.percent_b_below">percent_b_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.percent_b_equal" href="#vectorbt.indicators.indicators.BollingerBands.percent_b_equal">percent_b_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.plot" href="#vectorbt.indicators.indicators.BollingerBands.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.ts" href="#vectorbt.indicators.indicators.BollingerBands.ts">ts</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.ts_above" href="#vectorbt.indicators.indicators.BollingerBands.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.ts_below" href="#vectorbt.indicators.indicators.BollingerBands.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.ts_equal" href="#vectorbt.indicators.indicators.BollingerBands.ts_equal">ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.tuple_loc" href="#vectorbt.indicators.indicators.BollingerBands.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.upper_band" href="#vectorbt.indicators.indicators.BollingerBands.upper_band">upper_band</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.upper_band_above" href="#vectorbt.indicators.indicators.BollingerBands.upper_band_above">upper_band_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.upper_band_below" href="#vectorbt.indicators.indicators.BollingerBands.upper_band_below">upper_band_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.upper_band_equal" href="#vectorbt.indicators.indicators.BollingerBands.upper_band_equal">upper_band_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.window_loc" href="#vectorbt.indicators.indicators.BollingerBands.window_loc">window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.BollingerBands.xs" href="#vectorbt.indicators.indicators.BollingerBands.xs">xs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.indicators.MA" href="#vectorbt.indicators.indicators.MA">MA</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.indicators.MA.ewm_loc" href="#vectorbt.indicators.indicators.MA.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.from_combinations" href="#vectorbt.indicators.indicators.MA.from_combinations">from_combinations</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.from_params" href="#vectorbt.indicators.indicators.MA.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.iloc" href="#vectorbt.indicators.indicators.MA.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.loc" href="#vectorbt.indicators.indicators.MA.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.ma" href="#vectorbt.indicators.indicators.MA.ma">ma</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.ma_above" href="#vectorbt.indicators.indicators.MA.ma_above">ma_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.ma_below" href="#vectorbt.indicators.indicators.MA.ma_below">ma_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.ma_equal" href="#vectorbt.indicators.indicators.MA.ma_equal">ma_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.name" href="#vectorbt.indicators.indicators.MA.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.plot" href="#vectorbt.indicators.indicators.MA.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.ts" href="#vectorbt.indicators.indicators.MA.ts">ts</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.ts_above" href="#vectorbt.indicators.indicators.MA.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.ts_below" href="#vectorbt.indicators.indicators.MA.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.ts_equal" href="#vectorbt.indicators.indicators.MA.ts_equal">ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.tuple_loc" href="#vectorbt.indicators.indicators.MA.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.window_loc" href="#vectorbt.indicators.indicators.MA.window_loc">window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MA.xs" href="#vectorbt.indicators.indicators.MA.xs">xs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.indicators.MACD" href="#vectorbt.indicators.indicators.MACD">MACD</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.indicators.MACD.fast_ma" href="#vectorbt.indicators.indicators.MACD.fast_ma">fast_ma</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.fast_ma_above" href="#vectorbt.indicators.indicators.MACD.fast_ma_above">fast_ma_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.fast_ma_below" href="#vectorbt.indicators.indicators.MACD.fast_ma_below">fast_ma_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.fast_ma_equal" href="#vectorbt.indicators.indicators.MACD.fast_ma_equal">fast_ma_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.fast_window_loc" href="#vectorbt.indicators.indicators.MACD.fast_window_loc">fast_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.from_params" href="#vectorbt.indicators.indicators.MACD.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.histogram" href="#vectorbt.indicators.indicators.MACD.histogram">histogram</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.histogram_above" href="#vectorbt.indicators.indicators.MACD.histogram_above">histogram_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.histogram_below" href="#vectorbt.indicators.indicators.MACD.histogram_below">histogram_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.histogram_equal" href="#vectorbt.indicators.indicators.MACD.histogram_equal">histogram_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.iloc" href="#vectorbt.indicators.indicators.MACD.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.loc" href="#vectorbt.indicators.indicators.MACD.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.macd" href="#vectorbt.indicators.indicators.MACD.macd">macd</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.macd_above" href="#vectorbt.indicators.indicators.MACD.macd_above">macd_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.macd_below" href="#vectorbt.indicators.indicators.MACD.macd_below">macd_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.macd_equal" href="#vectorbt.indicators.indicators.MACD.macd_equal">macd_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.macd_ewm_loc" href="#vectorbt.indicators.indicators.MACD.macd_ewm_loc">macd_ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.name" href="#vectorbt.indicators.indicators.MACD.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.plot" href="#vectorbt.indicators.indicators.MACD.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.signal" href="#vectorbt.indicators.indicators.MACD.signal">signal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.signal_above" href="#vectorbt.indicators.indicators.MACD.signal_above">signal_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.signal_below" href="#vectorbt.indicators.indicators.MACD.signal_below">signal_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.signal_equal" href="#vectorbt.indicators.indicators.MACD.signal_equal">signal_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.signal_ewm_loc" href="#vectorbt.indicators.indicators.MACD.signal_ewm_loc">signal_ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.signal_window_loc" href="#vectorbt.indicators.indicators.MACD.signal_window_loc">signal_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.slow_ma" href="#vectorbt.indicators.indicators.MACD.slow_ma">slow_ma</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.slow_ma_above" href="#vectorbt.indicators.indicators.MACD.slow_ma_above">slow_ma_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.slow_ma_below" href="#vectorbt.indicators.indicators.MACD.slow_ma_below">slow_ma_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.slow_ma_equal" href="#vectorbt.indicators.indicators.MACD.slow_ma_equal">slow_ma_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.slow_window_loc" href="#vectorbt.indicators.indicators.MACD.slow_window_loc">slow_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.ts" href="#vectorbt.indicators.indicators.MACD.ts">ts</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.ts_above" href="#vectorbt.indicators.indicators.MACD.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.ts_below" href="#vectorbt.indicators.indicators.MACD.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.ts_equal" href="#vectorbt.indicators.indicators.MACD.ts_equal">ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.tuple_loc" href="#vectorbt.indicators.indicators.MACD.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MACD.xs" href="#vectorbt.indicators.indicators.MACD.xs">xs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.indicators.MSTD" href="#vectorbt.indicators.indicators.MSTD">MSTD</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.indicators.MSTD.ewm_loc" href="#vectorbt.indicators.indicators.MSTD.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.from_params" href="#vectorbt.indicators.indicators.MSTD.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.iloc" href="#vectorbt.indicators.indicators.MSTD.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.loc" href="#vectorbt.indicators.indicators.MSTD.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.mstd" href="#vectorbt.indicators.indicators.MSTD.mstd">mstd</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.mstd_above" href="#vectorbt.indicators.indicators.MSTD.mstd_above">mstd_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.mstd_below" href="#vectorbt.indicators.indicators.MSTD.mstd_below">mstd_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.mstd_equal" href="#vectorbt.indicators.indicators.MSTD.mstd_equal">mstd_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.name" href="#vectorbt.indicators.indicators.MSTD.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.plot" href="#vectorbt.indicators.indicators.MSTD.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.ts" href="#vectorbt.indicators.indicators.MSTD.ts">ts</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.ts_above" href="#vectorbt.indicators.indicators.MSTD.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.ts_below" href="#vectorbt.indicators.indicators.MSTD.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.ts_equal" href="#vectorbt.indicators.indicators.MSTD.ts_equal">ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.tuple_loc" href="#vectorbt.indicators.indicators.MSTD.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.window_loc" href="#vectorbt.indicators.indicators.MSTD.window_loc">window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.MSTD.xs" href="#vectorbt.indicators.indicators.MSTD.xs">xs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.indicators.OBV" href="#vectorbt.indicators.indicators.OBV">OBV</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.indicators.OBV.close_ts" href="#vectorbt.indicators.indicators.OBV.close_ts">close_ts</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.close_ts_above" href="#vectorbt.indicators.indicators.OBV.close_ts_above">close_ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.close_ts_below" href="#vectorbt.indicators.indicators.OBV.close_ts_below">close_ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.close_ts_equal" href="#vectorbt.indicators.indicators.OBV.close_ts_equal">close_ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.from_params" href="#vectorbt.indicators.indicators.OBV.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.iloc" href="#vectorbt.indicators.indicators.OBV.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.loc" href="#vectorbt.indicators.indicators.OBV.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.name" href="#vectorbt.indicators.indicators.OBV.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.obv" href="#vectorbt.indicators.indicators.OBV.obv">obv</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.obv_above" href="#vectorbt.indicators.indicators.OBV.obv_above">obv_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.obv_below" href="#vectorbt.indicators.indicators.OBV.obv_below">obv_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.obv_equal" href="#vectorbt.indicators.indicators.OBV.obv_equal">obv_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.plot" href="#vectorbt.indicators.indicators.OBV.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.volume_ts" href="#vectorbt.indicators.indicators.OBV.volume_ts">volume_ts</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.volume_ts_above" href="#vectorbt.indicators.indicators.OBV.volume_ts_above">volume_ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.volume_ts_below" href="#vectorbt.indicators.indicators.OBV.volume_ts_below">volume_ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.volume_ts_equal" href="#vectorbt.indicators.indicators.OBV.volume_ts_equal">volume_ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.OBV.xs" href="#vectorbt.indicators.indicators.OBV.xs">xs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.indicators.RSI" href="#vectorbt.indicators.indicators.RSI">RSI</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.indicators.RSI.ewm_loc" href="#vectorbt.indicators.indicators.RSI.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.from_params" href="#vectorbt.indicators.indicators.RSI.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.iloc" href="#vectorbt.indicators.indicators.RSI.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.loc" href="#vectorbt.indicators.indicators.RSI.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.name" href="#vectorbt.indicators.indicators.RSI.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.plot" href="#vectorbt.indicators.indicators.RSI.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.rsi" href="#vectorbt.indicators.indicators.RSI.rsi">rsi</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.rsi_above" href="#vectorbt.indicators.indicators.RSI.rsi_above">rsi_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.rsi_below" href="#vectorbt.indicators.indicators.RSI.rsi_below">rsi_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.rsi_equal" href="#vectorbt.indicators.indicators.RSI.rsi_equal">rsi_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.ts" href="#vectorbt.indicators.indicators.RSI.ts">ts</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.ts_above" href="#vectorbt.indicators.indicators.RSI.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.ts_below" href="#vectorbt.indicators.indicators.RSI.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.ts_equal" href="#vectorbt.indicators.indicators.RSI.ts_equal">ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.tuple_loc" href="#vectorbt.indicators.indicators.RSI.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.window_loc" href="#vectorbt.indicators.indicators.RSI.window_loc">window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.RSI.xs" href="#vectorbt.indicators.indicators.RSI.xs">xs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.indicators.Stochastic" href="#vectorbt.indicators.indicators.Stochastic">Stochastic</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.indicators.Stochastic.close_ts" href="#vectorbt.indicators.indicators.Stochastic.close_ts">close_ts</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.close_ts_above" href="#vectorbt.indicators.indicators.Stochastic.close_ts_above">close_ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.close_ts_below" href="#vectorbt.indicators.indicators.Stochastic.close_ts_below">close_ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.close_ts_equal" href="#vectorbt.indicators.indicators.Stochastic.close_ts_equal">close_ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.d_ewm_loc" href="#vectorbt.indicators.indicators.Stochastic.d_ewm_loc">d_ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.d_window_loc" href="#vectorbt.indicators.indicators.Stochastic.d_window_loc">d_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.from_params" href="#vectorbt.indicators.indicators.Stochastic.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.high_ts" href="#vectorbt.indicators.indicators.Stochastic.high_ts">high_ts</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.high_ts_above" href="#vectorbt.indicators.indicators.Stochastic.high_ts_above">high_ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.high_ts_below" href="#vectorbt.indicators.indicators.Stochastic.high_ts_below">high_ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.high_ts_equal" href="#vectorbt.indicators.indicators.Stochastic.high_ts_equal">high_ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.iloc" href="#vectorbt.indicators.indicators.Stochastic.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.k_window_loc" href="#vectorbt.indicators.indicators.Stochastic.k_window_loc">k_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.loc" href="#vectorbt.indicators.indicators.Stochastic.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.low_ts" href="#vectorbt.indicators.indicators.Stochastic.low_ts">low_ts</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.low_ts_above" href="#vectorbt.indicators.indicators.Stochastic.low_ts_above">low_ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.low_ts_below" href="#vectorbt.indicators.indicators.Stochastic.low_ts_below">low_ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.low_ts_equal" href="#vectorbt.indicators.indicators.Stochastic.low_ts_equal">low_ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.name" href="#vectorbt.indicators.indicators.Stochastic.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.percent_d" href="#vectorbt.indicators.indicators.Stochastic.percent_d">percent_d</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.percent_d_above" href="#vectorbt.indicators.indicators.Stochastic.percent_d_above">percent_d_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.percent_d_below" href="#vectorbt.indicators.indicators.Stochastic.percent_d_below">percent_d_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.percent_d_equal" href="#vectorbt.indicators.indicators.Stochastic.percent_d_equal">percent_d_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.percent_k" href="#vectorbt.indicators.indicators.Stochastic.percent_k">percent_k</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.percent_k_above" href="#vectorbt.indicators.indicators.Stochastic.percent_k_above">percent_k_above</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.percent_k_below" href="#vectorbt.indicators.indicators.Stochastic.percent_k_below">percent_k_below</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.percent_k_equal" href="#vectorbt.indicators.indicators.Stochastic.percent_k_equal">percent_k_equal</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.plot" href="#vectorbt.indicators.indicators.Stochastic.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.tuple_loc" href="#vectorbt.indicators.indicators.Stochastic.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.indicators.Stochastic.xs" href="#vectorbt.indicators.indicators.Stochastic.xs">xs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>