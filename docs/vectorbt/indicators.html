<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.indicators API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.indicators</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import numpy as np
from numba import njit
from numba.types import UniTuple, f8, i8, b1, DictType, ListType, Array
from numba.typed import List, Dict
from copy import copy
import plotly.graph_objects as go
import itertools

from vectorbt.utils import *
from vectorbt.accessors import *
from vectorbt.timeseries import rolling_mean_nb, rolling_std_nb, ewm_mean_nb, \
    ewm_std_nb, diff_nb, set_by_mask_nb, prepend_nb, rolling_min_nb, rolling_max_nb

__all__ = [&#39;IndicatorFactory&#39;, &#39;MA&#39;, &#39;DMAC&#39;, &#39;MSTD&#39;, &#39;BollingerBands&#39;, &#39;RSI&#39;, &#39;Stochastic&#39;, &#39;MACD&#39;, &#39;OBV&#39;]

# ############# Indicator factory ############# #


def build_column_hierarchy(param_list, level_names, ts_columns):
    check_same_shape(param_list, level_names, along_axis=0)
    param_indices = [index_from_values(param_list[i], name=level_names[i]) for i in range(len(param_list))]
    param_columns = None
    for param_index in param_indices:
        if param_columns is None:
            param_columns = param_index
        else:
            param_columns = stack_indices(param_columns, param_index)
    if param_columns is not None:
        return combine_indices(param_columns, ts_columns)
    return ts_columns


def build_mapper(params, ts, new_columns, level_name):
    params_mapper = np.repeat(params, len(to_2d(ts).columns))
    params_mapper = pd.Series(params_mapper, index=new_columns, name=level_name)
    return params_mapper


def build_tuple_mapper(mappers_list, new_columns, level_names):
    tuple_mapper = list(zip(*list(map(lambda x: x.values, mappers_list))))
    tuple_mapper = pd.Series(tuple_mapper, index=new_columns, name=level_names)
    return tuple_mapper


def wrap_output(output, ts, new_columns):
    return ts.vbt.wrap_array(output, columns=new_columns)


def broadcast_ts(ts, params_len, new_columns):
    if is_series(ts) or len(new_columns) &gt; ts.shape[1]:
        return ts.vbt.wrap_array(tile(ts.values, params_len, along_axis=1), columns=new_columns)
    else:
        return ts.vbt.wrap_array(ts, columns=new_columns)


def from_params_pipeline(ts_list, param_list, level_names, output_names, custom_func, *args, pass_lists=False,
                         param_product=False, broadcast_kwargs={}, **kwargs):
    &#34;&#34;&#34;A pipeline to calculate an indicator based on its parameters.

    Does the following:
        - Takes one or multiple time series objects (ts_list) and broadcasts them,
        - Takes one or multiple parameter arrays (param_list) and broadcasts them,
        - Performs calculation (custom_func) to build indicator arrays (output_list),
        - Creates new column hierarchy based on parameters and level names,
        - Broadcasts time series objects to match the shape of the output objects,
        - Builds mappers that will link parameters to columns.&#34;&#34;&#34;
    # Check time series objects
    check_type(ts_list[0], (pd.Series, pd.DataFrame))
    for i in range(1, len(ts_list)):
        ts_list[i].vbt.timeseries.validate()
    if len(ts_list) &gt; 1:
        # Broadcast time series
        ts_list = broadcast(*ts_list, **broadcast_kwargs, writeable=True)
    # Check level names
    check_type(level_names, (list, tuple))
    check_same_len(param_list, level_names)
    for ts in ts_list:
        # Every time series object should be free of the specified level names in its columns
        for level_name in level_names:
            check_level_not_exists(ts, level_name)
    # Convert params to 1-dim arrays
    param_list = list(map(to_1d, param_list))
    if len(param_list) &gt; 1:
        if param_product:
            # Make Cartesian product out of all params
            param_list = list(map(to_1d, param_list))
            param_list = list(zip(*list(itertools.product(*param_list))))
            param_list = list(map(np.asarray, param_list))
        else:
            # Broadcast such that each array has the same length
            param_list = broadcast(*param_list, writeable=True)
    # Perform main calculation
    if pass_lists:
        output_list = custom_func(ts_list, param_list, *args, **kwargs)
    else:
        output_list = custom_func(*ts_list, *param_list, *args, **kwargs)
    if not isinstance(output_list, (tuple, list, List)):
        output_list = (output_list,)
    # Other outputs should be returned without post-processing (for example cache_dict)
    if len(output_list) &gt; len(output_names):
        other_list = output_list[len(output_names):]
    else:
        other_list = ()
    # Process only those outputs that are in the output_names
    output_list = output_list[:len(output_names)]
    if len(param_list) &gt; 0:
        # Build new column levels on top of time series levels
        new_columns = build_column_hierarchy(param_list, level_names, to_2d(ts_list[0]).columns)
        # Wrap into new pandas objects both time series and output objects
        new_ts_list = list(map(lambda x: broadcast_ts(x, param_list[0].shape[0], new_columns), ts_list))
        # Build mappers to easily map between parameters and columns
        mapper_list = [build_mapper(x, ts_list[0], new_columns, level_names[i]) for i, x in enumerate(param_list)]
    else:
        # Some indicators don&#39;t have any params
        new_columns = to_2d(ts_list[0]).columns
        new_ts_list = ts_list
        mapper_list = []
    output_list = list(map(lambda x: wrap_output(x, ts_list[0], new_columns), output_list))
    if len(mapper_list) &gt; 1:
        # Tuple object is a mapper that accepts tuples of parameters
        tuple_mapper = build_tuple_mapper(mapper_list, new_columns, tuple(level_names))
        mapper_list.append(tuple_mapper)
    return new_ts_list, output_list, mapper_list, other_list


def perform_init_checks(ts_list, output_list, mapper_list):
    for ts in ts_list:
        check_type(ts, (pd.Series, pd.DataFrame))
        ts.vbt.timeseries.validate()
    for i in range(1, len(ts_list) + len(output_list)):
        check_same_meta((ts_list + output_list)[i-1], (ts_list + output_list)[i])
    for mapper in mapper_list:
        check_type(mapper, pd.Series)
        check_same_index(to_2d(ts_list[0]).iloc[0, :], mapper)


def is_equal(obj, other, multiple=False, name=&#39;is_equal&#39;, **kwargs):
    if multiple:
        as_columns = index_from_values(other, name=name)
        return obj.vbt.combine_with_multiple(other, combine_func=np.equal, as_columns=as_columns, concat=True, **kwargs)
    return obj.vbt.combine_with(other, combine_func=np.equal, **kwargs)


def is_above(obj, other, multiple=False, name=&#39;is_above&#39;, **kwargs):
    if multiple:
        as_columns = index_from_values(other, name=name)
        return obj.vbt.combine_with_multiple(other, combine_func=np.greater, as_columns=as_columns, concat=True, **kwargs)
    return obj.vbt.combine_with(other, combine_func=np.greater, **kwargs)


def is_below(obj, other, multiple=False, name=&#39;is_below&#39;, **kwargs):
    if multiple:
        as_columns = index_from_values(other, name=name)
        return obj.vbt.combine_with_multiple(other, combine_func=np.less, as_columns=as_columns, concat=True, **kwargs)
    return obj.vbt.combine_with(other, combine_func=np.less, **kwargs)


class BaseIndicator():
    def __init__(self, name):
        self.name = name

    @classmethod
    def from_params(cls, *args, **kwargs):
        raise NotImplementedError

    def plot(self, *args, **kwargs):
        raise NotImplementedError


class IndicatorFactory():
    &#34;&#34;&#34;Build a stand-alone indicator class based on parameters.

    Does the following:
        - Creates an __init__ method where it stores all artifacts,
        - Creates a from_params method that runs the main indicator pipeline and is called by the user,
        - Adds pandas indexing, i.e., you can use iloc, loc, [] and other on the class itself,
        - Adds parameter indexing, i.e., use *your_param*_loc on the class to slice using parameters,
        - Adds user-defined properties,
        - Adds common comparison methods for all inputs, outputs and properties, e.g., crossovers.&#34;&#34;&#34;

    @classmethod
    def from_custom_func(self,
                         custom_func,
                         ts_names=[&#39;ts&#39;],
                         param_names=[&#39;param&#39;],
                         output_names=[&#39;output&#39;],
                         short_name=&#39;custom&#39;,
                         custom_properties={},
                         comparison_params={},
                         pass_lists=False):
        &#34;&#34;&#34;Custom function can be anything that takes time series, params and other arguments, and returns outputs.&#34;&#34;&#34;

        # Build class
        class CustomIndicator(BaseIndicator):
            def __init__(self, *args):
                ts_list = args[:len(ts_names)]
                output_list = args[len(ts_names):len(ts_names)+len(output_names)]
                mapper_list = args[len(ts_names)+len(output_names):-1]
                perform_init_checks(ts_list, output_list, mapper_list)

                for i, ts_name in enumerate(ts_names):
                    setattr(self, ts_name, ts_list[i])
                for i, output_name in enumerate(output_names):
                    setattr(self, output_name, output_list[i])
                for i, param_name in enumerate(param_names):
                    setattr(self, param_name + &#39;_mapper&#39;, mapper_list[i])
                if len(param_names) &gt; 1:
                    setattr(self, &#39;tuple_mapper&#39;, mapper_list[-1])
                super().__init__(args[-1])

            @classmethod
            def from_params(cls, *args, name=short_name.lower(), **kwargs):
                level_names = tuple([name + &#39;_&#39; + param_name for param_name in param_names])
                ts_list = args[:len(ts_names)]
                param_list = args[len(ts_names):len(ts_names)+len(param_names)]
                new_args = args[len(ts_names)+len(param_names):]
                new_ts_list, output_list, mapper_list, other_list = from_params_pipeline(
                    ts_list, param_list, level_names, output_names,
                    custom_func, *new_args, pass_lists=pass_lists, **kwargs)
                obj = cls(*new_ts_list, *output_list, *mapper_list, name)
                if len(other_list) &gt; 0:
                    return (obj,) + other_list
                return obj

        # Add indexing methods
        def indexing_func(obj, loc_pandas_func):
            ts = []
            for ts_name in ts_names:
                ts.append(loc_pandas_func(getattr(obj, ts_name)))
            outputs = []
            for output_name in output_names:
                ts.append(loc_pandas_func(getattr(obj, output_name)))
            mappers = []
            for param_name in param_names:
                mappers.append(loc_mapper(getattr(obj, param_name + &#39;_mapper&#39;),
                                          getattr(obj, ts_names[0]), loc_pandas_func))
            if len(param_names) &gt; 1:
                mappers.append(loc_mapper(obj.tuple_mapper, getattr(obj, ts_names[0]), loc_pandas_func))

            return obj.__class__(*ts, *outputs, *mappers, obj.name)

        CustomIndicator = add_indexing(indexing_func)(CustomIndicator)
        for i, param_name in enumerate(param_names):
            CustomIndicator = add_param_indexing(param_name, indexing_func)(CustomIndicator)
        if len(param_names) &gt; 1:
            CustomIndicator = add_param_indexing(&#39;tuple&#39;, indexing_func)(CustomIndicator)

        # Add user-defined properties
        for property_name, property_func in custom_properties.items():
            @cached_property
            def custom_property(self, property_func=property_func):
                return property_func(self)
            setattr(CustomIndicator, property_name, custom_property)

        # Add comparison methods for all inputs, outputs, and user-defined properties
        comparison_attrs = set(ts_names + output_names + list(custom_properties.keys()))
        for attr in comparison_attrs:
            allow_with_class = False
            include_attr_name = True
            if attr in comparison_params:
                allow_with_class = comparison_params[attr].get(&#39;allow_with_class&#39;, allow_with_class)
                include_attr_name = comparison_params[attr].get(&#39;include_attr_name&#39;, include_attr_name)

            def create_comparison_method(func_name,
                                         comparison_func,
                                         attr=attr,
                                         allow_with_class=allow_with_class,
                                         include_attr_name=include_attr_name):
                def comparison_method(self, other, name=None, **kwargs):
                    if allow_with_class:
                        if isinstance(other, self.__class__):
                            other = getattr(other, attr)
                    if name is None:
                        if include_attr_name:
                            name = self.name + f&#39;_{attr}_&#39; + func_name
                        else:
                            name = self.name + &#39;_&#39; + func_name
                    return comparison_func(getattr(self, attr), other, name=name, **kwargs)
                return comparison_method

            def create_crossover_method(attr=attr,
                                        allow_with_class=allow_with_class,
                                        include_attr_name=include_attr_name):
                def crossover_method(self, other, wait=0, name=None, **kwargs):
                    above_method = getattr(self, f&#39;{attr}_above&#39;)
                    below_method = getattr(self, f&#39;{attr}_below&#39;)
                    if name is None:
                        if include_attr_name:
                            name = self.name + f&#39;_{attr}_crossover&#39;
                        else:
                            name = self.name + &#39;_crossover&#39;
                    # entry signal is first time this is about other
                    above_signals = above_method(other, name=name, **kwargs)\
                        .vbt.signals.nst(wait+1, after_false=True)
                    # exit signal is first time this is below other
                    below_signals = below_method(other, name=name, **kwargs)\
                        .vbt.signals.nst(wait+1, after_false=True)
                    return above_signals, below_signals
                return crossover_method

            setattr(CustomIndicator, f&#39;{attr}_above&#39;, create_comparison_method(&#39;above&#39;, is_above))
            setattr(CustomIndicator, f&#39;{attr}_below&#39;, create_comparison_method(&#39;below&#39;, is_below))
            setattr(CustomIndicator, f&#39;{attr}_equal&#39;, create_comparison_method(&#39;equal&#39;, is_equal))
            setattr(CustomIndicator, f&#39;{attr}_crossover&#39;, create_crossover_method())

        return CustomIndicator

    @classmethod
    def from_apply_func(cls, apply_func, caching_func=None, output_names=[&#39;output&#39;], **kwargs):
        &#34;&#34;&#34;Apply function is performed on each parameter individually.

        Apply functions are simpler to write since parameter selection and concating is done for you.

        But it has some limitations:
            - If your apply function isn&#39;t numba compiled, concating is also not numba compiled.
            - You can work with one parameter selection at a time, and can&#39;t view all parameters.

        You can also use a caching function to preprocess data beforehand.
        The outputs of the caching function will flow as additional arguments to the apply function.&#34;&#34;&#34;
        num_outputs = len(output_names)

        if is_numba_func(apply_func):
            apply_and_concat_func = apply_and_concat_multiple_nb if num_outputs &gt; 1 else apply_and_concat_one_nb

            @njit
            def select_params_func_nb(i, apply_func, ts_list, param_tuples, *args):
                # Select the next tuple of parameters
                return apply_func(*ts_list, *param_tuples[i], *args)

            def custom_func(ts_list, param_list, *args):
                # avoid deprecation warnings
                typed_ts_list = tuple(map(lambda x: x.vbt.to_2d_array(), ts_list))
                typed_param_tuples = List()
                for param_tuple in list(zip(*param_list)):
                    typed_param_tuples.append(param_tuple)

                # User-defined preprocessing function (useful for caching)
                if caching_func is not None:
                    more_args = caching_func(*typed_ts_list, *param_list, *args)
                    if not isinstance(more_args, (tuple, list, List)):
                        more_args = (more_args,)
                else:
                    more_args = ()

                return apply_and_concat_func(
                    param_list[0].shape[0],
                    select_params_func_nb,
                    apply_func,
                    typed_ts_list,
                    typed_param_tuples,
                    *args,
                    *more_args)
        else:
            apply_and_concat_func = apply_and_concat_multiple if num_outputs &gt; 1 else apply_and_concat_one

            def select_params_func(i, apply_func, ts_list, param_list, *args, **kwargs):
                    # Select the next tuple of parameters
                param_is = list(map(lambda x: x[i], param_list))
                return apply_func(*ts_list, *param_is, *args, **kwargs)

            def custom_func(ts_list, param_list, *args, **kwargs):
                # User-defined preprocessing function (useful for caching)
                if caching_func is not None:
                    more_args = caching_func(*ts_list, *param_list, *args)
                    if not isinstance(more_args, (tuple, list)):
                        more_args = (more_args,)
                else:
                    more_args = ()

                return apply_and_concat_func(
                    param_list[0].shape[0],
                    select_params_func,
                    apply_func,
                    ts_list,
                    param_list,
                    *args,
                    *more_args,
                    **kwargs)

        return cls.from_custom_func(custom_func, output_names=output_names, pass_lists=True, **kwargs)

# ############# MA ############# #


@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], b1[:]), cache=True)
def ma_caching_nb(ts, windows, ewms):
    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                ma = ewm_mean_nb(ts, windows[i])
            else:
                ma = rolling_mean_nb(ts, windows[i])
            cache_dict[(windows[i], int(ewms[i]))] = ma
    return cache_dict


@njit(f8[:, :](f8[:, :], i8, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def ma_apply_func_nb(ts, window, ewm, cache_dict):
    return cache_dict[(window, int(ewm))]


FactoryMA = IndicatorFactory.from_apply_func(
    ma_apply_func_nb,
    caching_func=ma_caching_nb,
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;ma&#39;],
    short_name=&#39;ma&#39;,
    comparison_params=dict(
        ma=dict(
            allow_with_class=True,
            include_attr_name=False
        )
    )
)


class MA(FactoryMA):
    @classmethod
    def from_params(cls, ts, window, ewm=False, **kwargs):
        return super().from_params(ts, window, ewm, **kwargs)

    def plot(self,
             ts_name=None,
             ma_name=None,
             ts_trace_kwargs={},
             ma_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.ts, pd.Series)
        check_type(self.ma, pd.Series)

        if ts_name is None:
            ts_name = f&#39;Price ({self.name})&#39;
        if ma_name is None:
            ma_name = f&#39;MA ({self.name})&#39;

        fig = self.ts.vbt.timeseries.plot(name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.ma.vbt.timeseries.plot(name=ma_name, trace_kwargs=ma_trace_kwargs, fig=fig)

        return fig

# ############# DMAC ############# #


@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], b1[:], i8[:], b1[:]), cache=True)
def dmac_caching_nb(ts, fast_windows, fast_ewms, slow_windows, slow_ewms):
    return ma_caching_nb(ts, np.concatenate((fast_windows, slow_windows)), np.concatenate((fast_ewms, slow_ewms)))


@njit(UniTuple(f8[:, :], 2)(f8[:, :], i8, b1, i8, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def dmac_apply_func_nb(ts, fast_window, fast_ewm, slow_window, slow_ewm, cache_dict):
    return cache_dict[(fast_window, int(fast_ewm))], cache_dict[(slow_window, int(slow_ewm))]


FactoryDMAC = IndicatorFactory.from_apply_func(
    dmac_apply_func_nb,
    caching_func=dmac_caching_nb,
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;fast_window&#39;, &#39;fast_ewm&#39;, &#39;slow_window&#39;, &#39;slow_ewm&#39;],
    output_names=[&#39;fast_ma&#39;, &#39;slow_ma&#39;],
    short_name=&#39;dmac&#39;,
    comparison_params=dict(
        fast_ma=dict(
            include_attr_name=False
        ),
        slow_ma=dict(
            include_attr_name=False
        )
    )
)


class DMAC(FactoryDMAC):
    @classmethod
    def from_params(cls, ts, fast_window, slow_window, fast_ewm=False, slow_ewm=False, **kwargs):
        return super().from_params(ts, fast_window, fast_ewm, slow_window, slow_ewm, **kwargs)

    @classmethod
    def from_combinations(cls, ts, windows, ewm=False, **kwargs):
        windows, ewm = broadcast(windows, ewm, writeable=True)
        param_lists = tuple(zip(*itertools.combinations(zip(windows, ewm), 2)))
        fast_windows, fast_ewms = zip(*param_lists[0])
        slow_windows, slow_ewms = zip(*param_lists[1])
        return cls.from_params(ts, fast_windows, slow_windows, fast_ewm=fast_ewms, slow_ewm=slow_ewms, **kwargs)

    def crossover(self, **kwargs):
        return self.fast_ma_crossover(self.slow_ma, **kwargs)

    def plot(self,
             crossover_kwargs={},
             ts_name=None,
             fast_ma_name=None,
             slow_ma_name=None,
             ts_trace_kwargs={},
             fast_ma_trace_kwargs={},
             slow_ma_trace_kwargs={},
             entry_trace_kwargs={},
             exit_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.ts, pd.Series)
        check_type(self.fast_ma, pd.Series)
        check_type(self.slow_ma, pd.Series)

        if ts_name is None:
            ts_name = f&#39;Price ({self.name})&#39;
        if fast_ma_name is None:
            fast_ma_name = f&#39;Fast MA ({self.name})&#39;
        if slow_ma_name is None:
            slow_ma_name = f&#39;Slow MA ({self.name})&#39;

        fig = self.ts.vbt.timeseries.plot(name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.fast_ma.vbt.timeseries.plot(name=fast_ma_name, trace_kwargs=fast_ma_trace_kwargs, fig=fig)
        fig = self.slow_ma.vbt.timeseries.plot(name=slow_ma_name, trace_kwargs=slow_ma_trace_kwargs, fig=fig)

        # Plot markets
        entries, exits = self.crossover(**crossover_kwargs)
        entry_scatter = go.Scatter(
            x=self.ts.index[entries],
            y=self.ts[entries],
            mode=&#39;markers&#39;,
            marker=dict(
                symbol=&#39;triangle-up&#39;,
                color=&#39;limegreen&#39;,
                size=10
            ),
            name=&#39;Entry&#39;
        )
        entry_scatter.update(**entry_trace_kwargs)
        fig.add_trace(entry_scatter)
        exit_scatter = go.Scatter(
            x=self.ts.index[exits],
            y=self.ts[exits],
            mode=&#39;markers&#39;,
            marker=dict(
                symbol=&#39;triangle-down&#39;,
                color=&#39;orangered&#39;,
                size=10
            ),
            name=&#39;Exit&#39;
        )
        exit_scatter.update(**exit_trace_kwargs)
        fig.add_trace(exit_scatter)

        return fig

# ############# MSTD ############# #


@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], b1[:]), cache=True)
def mstd_caching_nb(ts, windows, ewms):
    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                mstd = ewm_std_nb(ts, windows[i])
            else:
                mstd = rolling_std_nb(ts, windows[i])
            cache_dict[(windows[i], int(ewms[i]))] = mstd
    return cache_dict


@njit(f8[:, :](f8[:, :], i8, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def mstd_apply_func_nb(ts, window, ewm, cache_dict):
    return cache_dict[(window, int(ewm))]


FactoryMSTD = IndicatorFactory.from_apply_func(
    mstd_apply_func_nb,
    caching_func=mstd_caching_nb,
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;mstd&#39;],
    short_name=&#39;mstd&#39;,
    comparison_params=dict(
        mstd=dict(
            allow_with_class=True,
            include_attr_name=False
        )
    )
)


class MSTD(FactoryMSTD):
    @classmethod
    def from_params(cls, ts, window, ewm=False, **kwargs):
        return super().from_params(ts, window, ewm, **kwargs)

    def plot(self,
             name=None,
             trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.mstd, pd.Series)

        if name is None:
            name = f&#39;MSTD ({self.name})&#39;

        fig = self.mstd.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

        return fig

# ############# BollingerBands ############# #


@njit(UniTuple(DictType(UniTuple(i8, 2), f8[:, :]), 2)(f8[:, :], i8[:], b1[:], f8[:]), cache=True)
def bb_caching_nb(ts, windows, ewms, alphas):
    ma_cache_dict = ma_caching_nb(ts, windows, ewms)
    mstd_cache_dict = mstd_caching_nb(ts, windows, ewms)
    return ma_cache_dict, mstd_cache_dict


@njit(UniTuple(f8[:, :], 3)(f8[:, :], i8, b1, f8, DictType(UniTuple(i8, 2), f8[:, :]), DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def bb_apply_func_nb(ts, window, ewm, alpha, ma_cache_dict, mstd_cache_dict):
    # Calculate lower, middle and upper bands
    ma = np.copy(ma_cache_dict[(window, int(ewm))])
    mstd = np.copy(mstd_cache_dict[(window, int(ewm))])
    # # (MA + Kσ), MA, (MA - Kσ)
    return ma + alpha * mstd, ma, ma - alpha * mstd


FactoryBollingerBands = IndicatorFactory.from_apply_func(
    bb_apply_func_nb,
    caching_func=bb_caching_nb,
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;, &#39;alpha&#39;],
    output_names=[&#39;upper_band&#39;, &#39;middle_band&#39;, &#39;lower_band&#39;],
    short_name=&#39;bb&#39;,
    custom_properties=dict(
        percent_b=lambda self: (self.ts - self.lower_band) / (self.upper_band - self.lower_band),
        bandwidth=lambda self: (self.upper_band - self.lower_band) / self.middle_band
    )
)


class BollingerBands(FactoryBollingerBands):
    @classmethod
    def from_params(cls, ts, window=20, ewm=False, alpha=2, **kwargs):
        alpha = np.asarray(alpha).astype(np.float64)
        return super().from_params(ts, window, ewm, alpha, **kwargs)

    def plot(self,
             plot_ts=True,
             ts_name=None,
             upper_band_name=None,
             middle_band_name=None,
             lower_band_name=None,
             ts_trace_kwargs={},
             upper_band_trace_kwargs={},
             middle_band_trace_kwargs={},
             lower_band_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.ts, pd.Series)
        check_type(self.upper_band, pd.Series)
        check_type(self.middle_band, pd.Series)
        check_type(self.lower_band, pd.Series)

        if ts_name is None:
            ts_name = f&#39;Price ({self.name})&#39;
        if upper_band_name is None:
            upper_band_name = f&#39;Upper Band ({self.name})&#39;
        if middle_band_name is None:
            middle_band_name = f&#39;Middle Band ({self.name})&#39;
        if lower_band_name is None:
            lower_band_name = f&#39;Lower Band ({self.name})&#39;

        upper_band_trace_kwargs = {**dict(line=dict(color=&#39;grey&#39;)), **upper_band_trace_kwargs}  # default kwargs
        lower_band_trace_kwargs = {**dict(line=dict(color=&#39;grey&#39;)), **lower_band_trace_kwargs}

        if plot_ts:
            fig = self.ts.vbt.timeseries.plot(name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.upper_band.vbt.timeseries.plot(
            name=upper_band_name, trace_kwargs=upper_band_trace_kwargs, fig=fig)
        fig = self.middle_band.vbt.timeseries.plot(
            name=middle_band_name, trace_kwargs=middle_band_trace_kwargs, fig=fig)
        fig = self.lower_band.vbt.timeseries.plot(
            name=lower_band_name, trace_kwargs=lower_band_trace_kwargs, fig=fig)

        return fig


# ############# RSI ############# #

@njit(DictType(UniTuple(i8, 2), UniTuple(f8[:, :], 2))(f8[:, :], i8[:], b1[:]), cache=True)
def rsi_caching_nb(ts, windows, ewms):
    delta = diff_nb(ts)[1:, :]  # otherwise ewma will be all NaN
    up, down = delta.copy(), delta.copy()
    up = set_by_mask_nb(up, up &lt; 0, 0)
    down = np.abs(set_by_mask_nb(down, down &gt; 0, 0))
    # Cache
    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                roll_up = ewm_mean_nb(up, windows[i])
                roll_down = ewm_mean_nb(down, windows[i])
            else:
                roll_up = rolling_mean_nb(up, windows[i])
                roll_down = rolling_mean_nb(down, windows[i])
            roll_up = prepend_nb(roll_up, 1, np.nan)  # bring to old shape
            roll_down = prepend_nb(roll_down, 1, np.nan)
            cache_dict[(windows[i], int(ewms[i]))] = roll_up, roll_down
    return cache_dict


@njit(f8[:, :](f8[:, :], i8, b1, DictType(UniTuple(i8, 2), UniTuple(f8[:, :], 2))), cache=True)
def rsi_apply_func_nb(ts, window, ewm, cache_dict):
    roll_up, roll_down = cache_dict[(window, int(ewm))]
    return 100 - 100 / (1 + roll_up / roll_down)


FactoryRSI = IndicatorFactory.from_apply_func(
    rsi_apply_func_nb,
    caching_func=rsi_caching_nb,
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;rsi&#39;],
    short_name=&#39;rsi&#39;,
    comparison_params=dict(
        rsi=dict(
            allow_with_class=True,
            include_attr_name=False
        )
    )
)


class RSI(FactoryRSI):
    @classmethod
    def from_params(cls, ts, window=14, ewm=False, **kwargs):
        return super().from_params(ts, window, ewm, **kwargs)

    def plot(self,
             name=None,
             trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.rsi, pd.Series)

        if name is None:
            name = f&#39;RSI ({self.name})&#39;

        fig = self.rsi.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

        return fig


# ############# Stochastic ############# #


@njit(DictType(i8, UniTuple(f8[:, :], 2))(f8[:, :], f8[:, :], f8[:, :], i8[:], i8[:], b1[:]), cache=True)
def stoch_caching_nb(close_ts, high_ts, low_ts, k_windows, d_windows, ewms):
    cache_dict = dict()
    for i in range(k_windows.shape[0]):
        if k_windows[i] not in cache_dict:
            roll_min = rolling_min_nb(low_ts, k_windows[i])
            roll_max = rolling_max_nb(high_ts, k_windows[i])
            cache_dict[k_windows[i]] = roll_min, roll_max
    return cache_dict


@njit(UniTuple(f8[:, :], 2)(f8[:, :], f8[:, :], f8[:, :], i8, i8, b1, DictType(i8, UniTuple(f8[:, :], 2))), cache=True)
def stoch_apply_func_nb(close_ts, high_ts, low_ts, k_window, d_window, ewm, cache_dict):
    roll_min, roll_max = cache_dict[k_window]
    percent_k = 100 * (close_ts - roll_min) / (roll_max - roll_min)
    if ewm:
        percent_d = ewm_mean_nb(percent_k, d_window)
    else:
        percent_d = rolling_mean_nb(percent_k, d_window)
    percent_d[:k_window+d_window-2, :] = np.nan  # min_periods for ewm
    return percent_k, percent_d


FactoryStochastic = IndicatorFactory.from_apply_func(
    stoch_apply_func_nb,
    caching_func=stoch_caching_nb,
    ts_names=[&#39;close_ts&#39;, &#39;high_ts&#39;, &#39;low_ts&#39;],
    param_names=[&#39;k_window&#39;, &#39;d_window&#39;, &#39;ewm&#39;],
    output_names=[&#39;percent_k&#39;, &#39;percent_d&#39;],
    short_name=&#39;stoch&#39;
)


class Stochastic(FactoryStochastic):
    @classmethod
    def from_params(cls, close_ts, high_ts=None, low_ts=None, k_window=14, d_window=3, ewm=False, **kwargs):
        if high_ts is None:
            high_ts = close_ts
        if low_ts is None:
            low_ts = close_ts
        return super().from_params(close_ts, high_ts, low_ts, k_window, d_window, ewm, **kwargs)

    def crossover_signals(self, wait=0, **kwargs):
        pk_above_signals = self.is_percent_k_above(
            self.percent_d, **kwargs).vbt.signals.nst(wait+1, after_false=True)
        pk_below_signals = self.is_percent_k_below(
            self.percent_d, **kwargs).vbt.signals.nst(wait+1, after_false=True)
        return pk_above_signals, pk_below_signals

    def plot(self,
             percent_k_name=None,
             percent_d_name=None,
             percent_k_trace_kwargs={},
             percent_d_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.percent_k, pd.Series)
        check_type(self.percent_d, pd.Series)

        if percent_k_name is None:
            percent_k_name = f&#39;%K ({self.name})&#39;
        if percent_d_name is None:
            percent_d_name = f&#39;%D ({self.name})&#39;

        fig = self.percent_k.vbt.timeseries.plot(
            name=percent_k_name, trace_kwargs=percent_k_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.percent_d.vbt.timeseries.plot(name=percent_d_name, trace_kwargs=percent_d_trace_kwargs, fig=fig)

        return fig


# ############# MACD ############# #

@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], i8[:], i8[:], b1[:]), cache=True)
def macd_caching_nb(ts, fast_windows, slow_windows, signal_windows, ewms):
    return ma_caching_nb(ts, np.concatenate((fast_windows, slow_windows)), np.concatenate((ewms, ewms)))


@njit(UniTuple(f8[:, :], 4)(f8[:, :], i8, i8, i8, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def macd_apply_func_nb(ts, fast_window, slow_window, signal_window, ewm, cache_dict):
    fast_ma = cache_dict[(fast_window, int(ewm))]
    slow_ma = cache_dict[(slow_window, int(ewm))]
    macd_ts = fast_ma - slow_ma
    if ewm:
        signal_ts = ewm_mean_nb(macd_ts, signal_window)
    else:
        signal_ts = rolling_mean_nb(macd_ts, signal_window)
    signal_ts[:max(fast_window, slow_window)+signal_window-2, :] = np.nan  # min_periods for ewm
    return np.copy(fast_ma), np.copy(slow_ma), macd_ts, signal_ts


FactoryMACD = IndicatorFactory.from_apply_func(
    macd_apply_func_nb,
    caching_func=macd_caching_nb,
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;fast_window&#39;, &#39;slow_window&#39;, &#39;signal_window&#39;, &#39;ewm&#39;],
    output_names=[&#39;fast_ma&#39;, &#39;slow_ma&#39;, &#39;macd&#39;, &#39;signal&#39;],
    short_name=&#39;macd&#39;,
    custom_properties=dict(
        histogram=lambda self: self.macd - self.signal,
    )
)


class MACD(FactoryMACD):
    @classmethod
    def from_params(cls, ts, fast_window=26, slow_window=12, signal_window=9, ewm=True, **kwargs):
        return super().from_params(ts, fast_window, slow_window, signal_window, ewm, **kwargs)

    def plot(self,
             macd_name=None,
             signal_name=None,
             macd_trace_kwargs={},
             signal_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.macd, pd.Series)
        check_type(self.signal, pd.Series)

        if macd_name is None:
            macd_name = f&#39;MACD ({self.name})&#39;
        if signal_name is None:
            signal_name = f&#39;Signal ({self.name})&#39;

        fig = self.macd.vbt.timeseries.plot(
            name=macd_name, trace_kwargs=macd_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.signal.vbt.timeseries.plot(name=signal_name, trace_kwargs=signal_trace_kwargs, fig=fig)

        return fig


# ############# OBV ############# #

@njit(f8[:, :](f8[:, :], f8[:, :]))
def obv_custom_func_nb(close_ts, volume_ts):
    obv = np.full_like(close_ts, np.nan)
    for col in range(close_ts.shape[1]):
        cumsum = 0
        for i in range(1, close_ts.shape[0]):
            if np.isnan(close_ts[i, col]) or np.isnan(close_ts[i-1, col]) or np.isnan(volume_ts[i, col]):
                continue
            if close_ts[i, col] &gt; close_ts[i-1, col]:
                cumsum += volume_ts[i, col]
            elif close_ts[i, col] &lt; close_ts[i-1, col]:
                cumsum += -volume_ts[i, col]
            obv[i, col] = cumsum
    return obv


def obv_custom_func(close_ts, volume_ts):
    return obv_custom_func_nb(close_ts.vbt.to_2d_array(), volume_ts.vbt.to_2d_array())


FactoryOBV = IndicatorFactory.from_custom_func(
    obv_custom_func,
    ts_names=[&#39;close_ts&#39;, &#39;volume_ts&#39;],
    param_names=[],
    output_names=[&#39;obv&#39;],
    short_name=&#39;obv&#39;
)


class OBV(FactoryOBV):
    @classmethod
    def from_params(cls, close_ts, volume_ts):
        return super().from_params(close_ts, volume_ts)

    def plot(self,
             name=None,
             trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.obv, pd.Series)

        if name is None:
            name = f&#39;OBV ({self.name})&#39;

        fig = self.obv.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.indicators.BollingerBands"><code class="flex name class">
<span>class <span class="ident">BollingerBands</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BollingerBands(FactoryBollingerBands):
    @classmethod
    def from_params(cls, ts, window=20, ewm=False, alpha=2, **kwargs):
        alpha = np.asarray(alpha).astype(np.float64)
        return super().from_params(ts, window, ewm, alpha, **kwargs)

    def plot(self,
             plot_ts=True,
             ts_name=None,
             upper_band_name=None,
             middle_band_name=None,
             lower_band_name=None,
             ts_trace_kwargs={},
             upper_band_trace_kwargs={},
             middle_band_trace_kwargs={},
             lower_band_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.ts, pd.Series)
        check_type(self.upper_band, pd.Series)
        check_type(self.middle_band, pd.Series)
        check_type(self.lower_band, pd.Series)

        if ts_name is None:
            ts_name = f&#39;Price ({self.name})&#39;
        if upper_band_name is None:
            upper_band_name = f&#39;Upper Band ({self.name})&#39;
        if middle_band_name is None:
            middle_band_name = f&#39;Middle Band ({self.name})&#39;
        if lower_band_name is None:
            lower_band_name = f&#39;Lower Band ({self.name})&#39;

        upper_band_trace_kwargs = {**dict(line=dict(color=&#39;grey&#39;)), **upper_band_trace_kwargs}  # default kwargs
        lower_band_trace_kwargs = {**dict(line=dict(color=&#39;grey&#39;)), **lower_band_trace_kwargs}

        if plot_ts:
            fig = self.ts.vbt.timeseries.plot(name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.upper_band.vbt.timeseries.plot(
            name=upper_band_name, trace_kwargs=upper_band_trace_kwargs, fig=fig)
        fig = self.middle_band.vbt.timeseries.plot(
            name=middle_band_name, trace_kwargs=middle_band_trace_kwargs, fig=fig)
        fig = self.lower_band.vbt.timeseries.plot(
            name=lower_band_name, trace_kwargs=lower_band_trace_kwargs, fig=fig)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.IndicatorFactory.from_custom_func.<locals>.CustomIndicator</li>
<li>vectorbt.indicators.BaseIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.BollingerBands.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, window=20, ewm=False, alpha=2, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, window=20, ewm=False, alpha=2, **kwargs):
    alpha = np.asarray(alpha).astype(np.float64)
    return super().from_params(ts, window, ewm, alpha, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.BollingerBands.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, plot_ts=True, ts_name=None, upper_band_name=None, middle_band_name=None, lower_band_name=None, ts_trace_kwargs={}, upper_band_trace_kwargs={}, middle_band_trace_kwargs={}, lower_band_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         plot_ts=True,
         ts_name=None,
         upper_band_name=None,
         middle_band_name=None,
         lower_band_name=None,
         ts_trace_kwargs={},
         upper_band_trace_kwargs={},
         middle_band_trace_kwargs={},
         lower_band_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    check_type(self.ts, pd.Series)
    check_type(self.upper_band, pd.Series)
    check_type(self.middle_band, pd.Series)
    check_type(self.lower_band, pd.Series)

    if ts_name is None:
        ts_name = f&#39;Price ({self.name})&#39;
    if upper_band_name is None:
        upper_band_name = f&#39;Upper Band ({self.name})&#39;
    if middle_band_name is None:
        middle_band_name = f&#39;Middle Band ({self.name})&#39;
    if lower_band_name is None:
        lower_band_name = f&#39;Lower Band ({self.name})&#39;

    upper_band_trace_kwargs = {**dict(line=dict(color=&#39;grey&#39;)), **upper_band_trace_kwargs}  # default kwargs
    lower_band_trace_kwargs = {**dict(line=dict(color=&#39;grey&#39;)), **lower_band_trace_kwargs}

    if plot_ts:
        fig = self.ts.vbt.timeseries.plot(name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.upper_band.vbt.timeseries.plot(
        name=upper_band_name, trace_kwargs=upper_band_trace_kwargs, fig=fig)
    fig = self.middle_band.vbt.timeseries.plot(
        name=middle_band_name, trace_kwargs=middle_band_trace_kwargs, fig=fig)
    fig = self.lower_band.vbt.timeseries.plot(
        name=lower_band_name, trace_kwargs=lower_band_trace_kwargs, fig=fig)

    return fig</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.DMAC"><code class="flex name class">
<span>class <span class="ident">DMAC</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DMAC(FactoryDMAC):
    @classmethod
    def from_params(cls, ts, fast_window, slow_window, fast_ewm=False, slow_ewm=False, **kwargs):
        return super().from_params(ts, fast_window, fast_ewm, slow_window, slow_ewm, **kwargs)

    @classmethod
    def from_combinations(cls, ts, windows, ewm=False, **kwargs):
        windows, ewm = broadcast(windows, ewm, writeable=True)
        param_lists = tuple(zip(*itertools.combinations(zip(windows, ewm), 2)))
        fast_windows, fast_ewms = zip(*param_lists[0])
        slow_windows, slow_ewms = zip(*param_lists[1])
        return cls.from_params(ts, fast_windows, slow_windows, fast_ewm=fast_ewms, slow_ewm=slow_ewms, **kwargs)

    def crossover(self, **kwargs):
        return self.fast_ma_crossover(self.slow_ma, **kwargs)

    def plot(self,
             crossover_kwargs={},
             ts_name=None,
             fast_ma_name=None,
             slow_ma_name=None,
             ts_trace_kwargs={},
             fast_ma_trace_kwargs={},
             slow_ma_trace_kwargs={},
             entry_trace_kwargs={},
             exit_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.ts, pd.Series)
        check_type(self.fast_ma, pd.Series)
        check_type(self.slow_ma, pd.Series)

        if ts_name is None:
            ts_name = f&#39;Price ({self.name})&#39;
        if fast_ma_name is None:
            fast_ma_name = f&#39;Fast MA ({self.name})&#39;
        if slow_ma_name is None:
            slow_ma_name = f&#39;Slow MA ({self.name})&#39;

        fig = self.ts.vbt.timeseries.plot(name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.fast_ma.vbt.timeseries.plot(name=fast_ma_name, trace_kwargs=fast_ma_trace_kwargs, fig=fig)
        fig = self.slow_ma.vbt.timeseries.plot(name=slow_ma_name, trace_kwargs=slow_ma_trace_kwargs, fig=fig)

        # Plot markets
        entries, exits = self.crossover(**crossover_kwargs)
        entry_scatter = go.Scatter(
            x=self.ts.index[entries],
            y=self.ts[entries],
            mode=&#39;markers&#39;,
            marker=dict(
                symbol=&#39;triangle-up&#39;,
                color=&#39;limegreen&#39;,
                size=10
            ),
            name=&#39;Entry&#39;
        )
        entry_scatter.update(**entry_trace_kwargs)
        fig.add_trace(entry_scatter)
        exit_scatter = go.Scatter(
            x=self.ts.index[exits],
            y=self.ts[exits],
            mode=&#39;markers&#39;,
            marker=dict(
                symbol=&#39;triangle-down&#39;,
                color=&#39;orangered&#39;,
                size=10
            ),
            name=&#39;Exit&#39;
        )
        exit_scatter.update(**exit_trace_kwargs)
        fig.add_trace(exit_scatter)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.IndicatorFactory.from_custom_func.<locals>.CustomIndicator</li>
<li>vectorbt.indicators.BaseIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.DMAC.from_combinations"><code class="name flex">
<span>def <span class="ident">from_combinations</span></span>(<span>ts, windows, ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_combinations(cls, ts, windows, ewm=False, **kwargs):
    windows, ewm = broadcast(windows, ewm, writeable=True)
    param_lists = tuple(zip(*itertools.combinations(zip(windows, ewm), 2)))
    fast_windows, fast_ewms = zip(*param_lists[0])
    slow_windows, slow_ewms = zip(*param_lists[1])
    return cls.from_params(ts, fast_windows, slow_windows, fast_ewm=fast_ewms, slow_ewm=slow_ewms, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.DMAC.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, fast_window, slow_window, fast_ewm=False, slow_ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, fast_window, slow_window, fast_ewm=False, slow_ewm=False, **kwargs):
    return super().from_params(ts, fast_window, fast_ewm, slow_window, slow_ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.DMAC.crossover"><code class="name flex">
<span>def <span class="ident">crossover</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crossover(self, **kwargs):
    return self.fast_ma_crossover(self.slow_ma, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.DMAC.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, crossover_kwargs={}, ts_name=None, fast_ma_name=None, slow_ma_name=None, ts_trace_kwargs={}, fast_ma_trace_kwargs={}, slow_ma_trace_kwargs={}, entry_trace_kwargs={}, exit_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         crossover_kwargs={},
         ts_name=None,
         fast_ma_name=None,
         slow_ma_name=None,
         ts_trace_kwargs={},
         fast_ma_trace_kwargs={},
         slow_ma_trace_kwargs={},
         entry_trace_kwargs={},
         exit_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    check_type(self.ts, pd.Series)
    check_type(self.fast_ma, pd.Series)
    check_type(self.slow_ma, pd.Series)

    if ts_name is None:
        ts_name = f&#39;Price ({self.name})&#39;
    if fast_ma_name is None:
        fast_ma_name = f&#39;Fast MA ({self.name})&#39;
    if slow_ma_name is None:
        slow_ma_name = f&#39;Slow MA ({self.name})&#39;

    fig = self.ts.vbt.timeseries.plot(name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.fast_ma.vbt.timeseries.plot(name=fast_ma_name, trace_kwargs=fast_ma_trace_kwargs, fig=fig)
    fig = self.slow_ma.vbt.timeseries.plot(name=slow_ma_name, trace_kwargs=slow_ma_trace_kwargs, fig=fig)

    # Plot markets
    entries, exits = self.crossover(**crossover_kwargs)
    entry_scatter = go.Scatter(
        x=self.ts.index[entries],
        y=self.ts[entries],
        mode=&#39;markers&#39;,
        marker=dict(
            symbol=&#39;triangle-up&#39;,
            color=&#39;limegreen&#39;,
            size=10
        ),
        name=&#39;Entry&#39;
    )
    entry_scatter.update(**entry_trace_kwargs)
    fig.add_trace(entry_scatter)
    exit_scatter = go.Scatter(
        x=self.ts.index[exits],
        y=self.ts[exits],
        mode=&#39;markers&#39;,
        marker=dict(
            symbol=&#39;triangle-down&#39;,
            color=&#39;orangered&#39;,
            size=10
        ),
        name=&#39;Exit&#39;
    )
    exit_scatter.update(**exit_trace_kwargs)
    fig.add_trace(exit_scatter)

    return fig</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.IndicatorFactory"><code class="flex name class">
<span>class <span class="ident">IndicatorFactory</span></span>
</code></dt>
<dd>
<div class="desc"><p>Build a stand-alone indicator class based on parameters.</p>
<p>Does the following:
- Creates an <strong>init</strong> method where it stores all artifacts,
- Creates a from_params method that runs the main indicator pipeline and is called by the user,
- Adds pandas indexing, i.e., you can use iloc, loc, [] and other on the class itself,
- Adds parameter indexing, i.e., use <em>your_param</em>_loc on the class to slice using parameters,
- Adds user-defined properties,
- Adds common comparison methods for all inputs, outputs and properties, e.g., crossovers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndicatorFactory():
    &#34;&#34;&#34;Build a stand-alone indicator class based on parameters.

    Does the following:
        - Creates an __init__ method where it stores all artifacts,
        - Creates a from_params method that runs the main indicator pipeline and is called by the user,
        - Adds pandas indexing, i.e., you can use iloc, loc, [] and other on the class itself,
        - Adds parameter indexing, i.e., use *your_param*_loc on the class to slice using parameters,
        - Adds user-defined properties,
        - Adds common comparison methods for all inputs, outputs and properties, e.g., crossovers.&#34;&#34;&#34;

    @classmethod
    def from_custom_func(self,
                         custom_func,
                         ts_names=[&#39;ts&#39;],
                         param_names=[&#39;param&#39;],
                         output_names=[&#39;output&#39;],
                         short_name=&#39;custom&#39;,
                         custom_properties={},
                         comparison_params={},
                         pass_lists=False):
        &#34;&#34;&#34;Custom function can be anything that takes time series, params and other arguments, and returns outputs.&#34;&#34;&#34;

        # Build class
        class CustomIndicator(BaseIndicator):
            def __init__(self, *args):
                ts_list = args[:len(ts_names)]
                output_list = args[len(ts_names):len(ts_names)+len(output_names)]
                mapper_list = args[len(ts_names)+len(output_names):-1]
                perform_init_checks(ts_list, output_list, mapper_list)

                for i, ts_name in enumerate(ts_names):
                    setattr(self, ts_name, ts_list[i])
                for i, output_name in enumerate(output_names):
                    setattr(self, output_name, output_list[i])
                for i, param_name in enumerate(param_names):
                    setattr(self, param_name + &#39;_mapper&#39;, mapper_list[i])
                if len(param_names) &gt; 1:
                    setattr(self, &#39;tuple_mapper&#39;, mapper_list[-1])
                super().__init__(args[-1])

            @classmethod
            def from_params(cls, *args, name=short_name.lower(), **kwargs):
                level_names = tuple([name + &#39;_&#39; + param_name for param_name in param_names])
                ts_list = args[:len(ts_names)]
                param_list = args[len(ts_names):len(ts_names)+len(param_names)]
                new_args = args[len(ts_names)+len(param_names):]
                new_ts_list, output_list, mapper_list, other_list = from_params_pipeline(
                    ts_list, param_list, level_names, output_names,
                    custom_func, *new_args, pass_lists=pass_lists, **kwargs)
                obj = cls(*new_ts_list, *output_list, *mapper_list, name)
                if len(other_list) &gt; 0:
                    return (obj,) + other_list
                return obj

        # Add indexing methods
        def indexing_func(obj, loc_pandas_func):
            ts = []
            for ts_name in ts_names:
                ts.append(loc_pandas_func(getattr(obj, ts_name)))
            outputs = []
            for output_name in output_names:
                ts.append(loc_pandas_func(getattr(obj, output_name)))
            mappers = []
            for param_name in param_names:
                mappers.append(loc_mapper(getattr(obj, param_name + &#39;_mapper&#39;),
                                          getattr(obj, ts_names[0]), loc_pandas_func))
            if len(param_names) &gt; 1:
                mappers.append(loc_mapper(obj.tuple_mapper, getattr(obj, ts_names[0]), loc_pandas_func))

            return obj.__class__(*ts, *outputs, *mappers, obj.name)

        CustomIndicator = add_indexing(indexing_func)(CustomIndicator)
        for i, param_name in enumerate(param_names):
            CustomIndicator = add_param_indexing(param_name, indexing_func)(CustomIndicator)
        if len(param_names) &gt; 1:
            CustomIndicator = add_param_indexing(&#39;tuple&#39;, indexing_func)(CustomIndicator)

        # Add user-defined properties
        for property_name, property_func in custom_properties.items():
            @cached_property
            def custom_property(self, property_func=property_func):
                return property_func(self)
            setattr(CustomIndicator, property_name, custom_property)

        # Add comparison methods for all inputs, outputs, and user-defined properties
        comparison_attrs = set(ts_names + output_names + list(custom_properties.keys()))
        for attr in comparison_attrs:
            allow_with_class = False
            include_attr_name = True
            if attr in comparison_params:
                allow_with_class = comparison_params[attr].get(&#39;allow_with_class&#39;, allow_with_class)
                include_attr_name = comparison_params[attr].get(&#39;include_attr_name&#39;, include_attr_name)

            def create_comparison_method(func_name,
                                         comparison_func,
                                         attr=attr,
                                         allow_with_class=allow_with_class,
                                         include_attr_name=include_attr_name):
                def comparison_method(self, other, name=None, **kwargs):
                    if allow_with_class:
                        if isinstance(other, self.__class__):
                            other = getattr(other, attr)
                    if name is None:
                        if include_attr_name:
                            name = self.name + f&#39;_{attr}_&#39; + func_name
                        else:
                            name = self.name + &#39;_&#39; + func_name
                    return comparison_func(getattr(self, attr), other, name=name, **kwargs)
                return comparison_method

            def create_crossover_method(attr=attr,
                                        allow_with_class=allow_with_class,
                                        include_attr_name=include_attr_name):
                def crossover_method(self, other, wait=0, name=None, **kwargs):
                    above_method = getattr(self, f&#39;{attr}_above&#39;)
                    below_method = getattr(self, f&#39;{attr}_below&#39;)
                    if name is None:
                        if include_attr_name:
                            name = self.name + f&#39;_{attr}_crossover&#39;
                        else:
                            name = self.name + &#39;_crossover&#39;
                    # entry signal is first time this is about other
                    above_signals = above_method(other, name=name, **kwargs)\
                        .vbt.signals.nst(wait+1, after_false=True)
                    # exit signal is first time this is below other
                    below_signals = below_method(other, name=name, **kwargs)\
                        .vbt.signals.nst(wait+1, after_false=True)
                    return above_signals, below_signals
                return crossover_method

            setattr(CustomIndicator, f&#39;{attr}_above&#39;, create_comparison_method(&#39;above&#39;, is_above))
            setattr(CustomIndicator, f&#39;{attr}_below&#39;, create_comparison_method(&#39;below&#39;, is_below))
            setattr(CustomIndicator, f&#39;{attr}_equal&#39;, create_comparison_method(&#39;equal&#39;, is_equal))
            setattr(CustomIndicator, f&#39;{attr}_crossover&#39;, create_crossover_method())

        return CustomIndicator

    @classmethod
    def from_apply_func(cls, apply_func, caching_func=None, output_names=[&#39;output&#39;], **kwargs):
        &#34;&#34;&#34;Apply function is performed on each parameter individually.

        Apply functions are simpler to write since parameter selection and concating is done for you.

        But it has some limitations:
            - If your apply function isn&#39;t numba compiled, concating is also not numba compiled.
            - You can work with one parameter selection at a time, and can&#39;t view all parameters.

        You can also use a caching function to preprocess data beforehand.
        The outputs of the caching function will flow as additional arguments to the apply function.&#34;&#34;&#34;
        num_outputs = len(output_names)

        if is_numba_func(apply_func):
            apply_and_concat_func = apply_and_concat_multiple_nb if num_outputs &gt; 1 else apply_and_concat_one_nb

            @njit
            def select_params_func_nb(i, apply_func, ts_list, param_tuples, *args):
                # Select the next tuple of parameters
                return apply_func(*ts_list, *param_tuples[i], *args)

            def custom_func(ts_list, param_list, *args):
                # avoid deprecation warnings
                typed_ts_list = tuple(map(lambda x: x.vbt.to_2d_array(), ts_list))
                typed_param_tuples = List()
                for param_tuple in list(zip(*param_list)):
                    typed_param_tuples.append(param_tuple)

                # User-defined preprocessing function (useful for caching)
                if caching_func is not None:
                    more_args = caching_func(*typed_ts_list, *param_list, *args)
                    if not isinstance(more_args, (tuple, list, List)):
                        more_args = (more_args,)
                else:
                    more_args = ()

                return apply_and_concat_func(
                    param_list[0].shape[0],
                    select_params_func_nb,
                    apply_func,
                    typed_ts_list,
                    typed_param_tuples,
                    *args,
                    *more_args)
        else:
            apply_and_concat_func = apply_and_concat_multiple if num_outputs &gt; 1 else apply_and_concat_one

            def select_params_func(i, apply_func, ts_list, param_list, *args, **kwargs):
                    # Select the next tuple of parameters
                param_is = list(map(lambda x: x[i], param_list))
                return apply_func(*ts_list, *param_is, *args, **kwargs)

            def custom_func(ts_list, param_list, *args, **kwargs):
                # User-defined preprocessing function (useful for caching)
                if caching_func is not None:
                    more_args = caching_func(*ts_list, *param_list, *args)
                    if not isinstance(more_args, (tuple, list)):
                        more_args = (more_args,)
                else:
                    more_args = ()

                return apply_and_concat_func(
                    param_list[0].shape[0],
                    select_params_func,
                    apply_func,
                    ts_list,
                    param_list,
                    *args,
                    *more_args,
                    **kwargs)

        return cls.from_custom_func(custom_func, output_names=output_names, pass_lists=True, **kwargs)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.IndicatorFactory.from_apply_func"><code class="name flex">
<span>def <span class="ident">from_apply_func</span></span>(<span>apply_func, caching_func=None, output_names=['output'], **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function is performed on each parameter individually.</p>
<p>Apply functions are simpler to write since parameter selection and concating is done for you.</p>
<p>But it has some limitations:
- If your apply function isn't numba compiled, concating is also not numba compiled.
- You can work with one parameter selection at a time, and can't view all parameters.</p>
<p>You can also use a caching function to preprocess data beforehand.
The outputs of the caching function will flow as additional arguments to the apply function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_apply_func(cls, apply_func, caching_func=None, output_names=[&#39;output&#39;], **kwargs):
    &#34;&#34;&#34;Apply function is performed on each parameter individually.

    Apply functions are simpler to write since parameter selection and concating is done for you.

    But it has some limitations:
        - If your apply function isn&#39;t numba compiled, concating is also not numba compiled.
        - You can work with one parameter selection at a time, and can&#39;t view all parameters.

    You can also use a caching function to preprocess data beforehand.
    The outputs of the caching function will flow as additional arguments to the apply function.&#34;&#34;&#34;
    num_outputs = len(output_names)

    if is_numba_func(apply_func):
        apply_and_concat_func = apply_and_concat_multiple_nb if num_outputs &gt; 1 else apply_and_concat_one_nb

        @njit
        def select_params_func_nb(i, apply_func, ts_list, param_tuples, *args):
            # Select the next tuple of parameters
            return apply_func(*ts_list, *param_tuples[i], *args)

        def custom_func(ts_list, param_list, *args):
            # avoid deprecation warnings
            typed_ts_list = tuple(map(lambda x: x.vbt.to_2d_array(), ts_list))
            typed_param_tuples = List()
            for param_tuple in list(zip(*param_list)):
                typed_param_tuples.append(param_tuple)

            # User-defined preprocessing function (useful for caching)
            if caching_func is not None:
                more_args = caching_func(*typed_ts_list, *param_list, *args)
                if not isinstance(more_args, (tuple, list, List)):
                    more_args = (more_args,)
            else:
                more_args = ()

            return apply_and_concat_func(
                param_list[0].shape[0],
                select_params_func_nb,
                apply_func,
                typed_ts_list,
                typed_param_tuples,
                *args,
                *more_args)
    else:
        apply_and_concat_func = apply_and_concat_multiple if num_outputs &gt; 1 else apply_and_concat_one

        def select_params_func(i, apply_func, ts_list, param_list, *args, **kwargs):
                # Select the next tuple of parameters
            param_is = list(map(lambda x: x[i], param_list))
            return apply_func(*ts_list, *param_is, *args, **kwargs)

        def custom_func(ts_list, param_list, *args, **kwargs):
            # User-defined preprocessing function (useful for caching)
            if caching_func is not None:
                more_args = caching_func(*ts_list, *param_list, *args)
                if not isinstance(more_args, (tuple, list)):
                    more_args = (more_args,)
            else:
                more_args = ()

            return apply_and_concat_func(
                param_list[0].shape[0],
                select_params_func,
                apply_func,
                ts_list,
                param_list,
                *args,
                *more_args,
                **kwargs)

    return cls.from_custom_func(custom_func, output_names=output_names, pass_lists=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.IndicatorFactory.from_custom_func"><code class="name flex">
<span>def <span class="ident">from_custom_func</span></span>(<span>custom_func, ts_names=['ts'], param_names=['param'], output_names=['output'], short_name='custom', custom_properties={}, comparison_params={}, pass_lists=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom function can be anything that takes time series, params and other arguments, and returns outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_custom_func(self,
                     custom_func,
                     ts_names=[&#39;ts&#39;],
                     param_names=[&#39;param&#39;],
                     output_names=[&#39;output&#39;],
                     short_name=&#39;custom&#39;,
                     custom_properties={},
                     comparison_params={},
                     pass_lists=False):
    &#34;&#34;&#34;Custom function can be anything that takes time series, params and other arguments, and returns outputs.&#34;&#34;&#34;

    # Build class
    class CustomIndicator(BaseIndicator):
        def __init__(self, *args):
            ts_list = args[:len(ts_names)]
            output_list = args[len(ts_names):len(ts_names)+len(output_names)]
            mapper_list = args[len(ts_names)+len(output_names):-1]
            perform_init_checks(ts_list, output_list, mapper_list)

            for i, ts_name in enumerate(ts_names):
                setattr(self, ts_name, ts_list[i])
            for i, output_name in enumerate(output_names):
                setattr(self, output_name, output_list[i])
            for i, param_name in enumerate(param_names):
                setattr(self, param_name + &#39;_mapper&#39;, mapper_list[i])
            if len(param_names) &gt; 1:
                setattr(self, &#39;tuple_mapper&#39;, mapper_list[-1])
            super().__init__(args[-1])

        @classmethod
        def from_params(cls, *args, name=short_name.lower(), **kwargs):
            level_names = tuple([name + &#39;_&#39; + param_name for param_name in param_names])
            ts_list = args[:len(ts_names)]
            param_list = args[len(ts_names):len(ts_names)+len(param_names)]
            new_args = args[len(ts_names)+len(param_names):]
            new_ts_list, output_list, mapper_list, other_list = from_params_pipeline(
                ts_list, param_list, level_names, output_names,
                custom_func, *new_args, pass_lists=pass_lists, **kwargs)
            obj = cls(*new_ts_list, *output_list, *mapper_list, name)
            if len(other_list) &gt; 0:
                return (obj,) + other_list
            return obj

    # Add indexing methods
    def indexing_func(obj, loc_pandas_func):
        ts = []
        for ts_name in ts_names:
            ts.append(loc_pandas_func(getattr(obj, ts_name)))
        outputs = []
        for output_name in output_names:
            ts.append(loc_pandas_func(getattr(obj, output_name)))
        mappers = []
        for param_name in param_names:
            mappers.append(loc_mapper(getattr(obj, param_name + &#39;_mapper&#39;),
                                      getattr(obj, ts_names[0]), loc_pandas_func))
        if len(param_names) &gt; 1:
            mappers.append(loc_mapper(obj.tuple_mapper, getattr(obj, ts_names[0]), loc_pandas_func))

        return obj.__class__(*ts, *outputs, *mappers, obj.name)

    CustomIndicator = add_indexing(indexing_func)(CustomIndicator)
    for i, param_name in enumerate(param_names):
        CustomIndicator = add_param_indexing(param_name, indexing_func)(CustomIndicator)
    if len(param_names) &gt; 1:
        CustomIndicator = add_param_indexing(&#39;tuple&#39;, indexing_func)(CustomIndicator)

    # Add user-defined properties
    for property_name, property_func in custom_properties.items():
        @cached_property
        def custom_property(self, property_func=property_func):
            return property_func(self)
        setattr(CustomIndicator, property_name, custom_property)

    # Add comparison methods for all inputs, outputs, and user-defined properties
    comparison_attrs = set(ts_names + output_names + list(custom_properties.keys()))
    for attr in comparison_attrs:
        allow_with_class = False
        include_attr_name = True
        if attr in comparison_params:
            allow_with_class = comparison_params[attr].get(&#39;allow_with_class&#39;, allow_with_class)
            include_attr_name = comparison_params[attr].get(&#39;include_attr_name&#39;, include_attr_name)

        def create_comparison_method(func_name,
                                     comparison_func,
                                     attr=attr,
                                     allow_with_class=allow_with_class,
                                     include_attr_name=include_attr_name):
            def comparison_method(self, other, name=None, **kwargs):
                if allow_with_class:
                    if isinstance(other, self.__class__):
                        other = getattr(other, attr)
                if name is None:
                    if include_attr_name:
                        name = self.name + f&#39;_{attr}_&#39; + func_name
                    else:
                        name = self.name + &#39;_&#39; + func_name
                return comparison_func(getattr(self, attr), other, name=name, **kwargs)
            return comparison_method

        def create_crossover_method(attr=attr,
                                    allow_with_class=allow_with_class,
                                    include_attr_name=include_attr_name):
            def crossover_method(self, other, wait=0, name=None, **kwargs):
                above_method = getattr(self, f&#39;{attr}_above&#39;)
                below_method = getattr(self, f&#39;{attr}_below&#39;)
                if name is None:
                    if include_attr_name:
                        name = self.name + f&#39;_{attr}_crossover&#39;
                    else:
                        name = self.name + &#39;_crossover&#39;
                # entry signal is first time this is about other
                above_signals = above_method(other, name=name, **kwargs)\
                    .vbt.signals.nst(wait+1, after_false=True)
                # exit signal is first time this is below other
                below_signals = below_method(other, name=name, **kwargs)\
                    .vbt.signals.nst(wait+1, after_false=True)
                return above_signals, below_signals
            return crossover_method

        setattr(CustomIndicator, f&#39;{attr}_above&#39;, create_comparison_method(&#39;above&#39;, is_above))
        setattr(CustomIndicator, f&#39;{attr}_below&#39;, create_comparison_method(&#39;below&#39;, is_below))
        setattr(CustomIndicator, f&#39;{attr}_equal&#39;, create_comparison_method(&#39;equal&#39;, is_equal))
        setattr(CustomIndicator, f&#39;{attr}_crossover&#39;, create_crossover_method())

    return CustomIndicator</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.MA"><code class="flex name class">
<span>class <span class="ident">MA</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MA(FactoryMA):
    @classmethod
    def from_params(cls, ts, window, ewm=False, **kwargs):
        return super().from_params(ts, window, ewm, **kwargs)

    def plot(self,
             ts_name=None,
             ma_name=None,
             ts_trace_kwargs={},
             ma_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.ts, pd.Series)
        check_type(self.ma, pd.Series)

        if ts_name is None:
            ts_name = f&#39;Price ({self.name})&#39;
        if ma_name is None:
            ma_name = f&#39;MA ({self.name})&#39;

        fig = self.ts.vbt.timeseries.plot(name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.ma.vbt.timeseries.plot(name=ma_name, trace_kwargs=ma_trace_kwargs, fig=fig)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.IndicatorFactory.from_custom_func.<locals>.CustomIndicator</li>
<li>vectorbt.indicators.BaseIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.MA.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, window, ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, window, ewm=False, **kwargs):
    return super().from_params(ts, window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.MA.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, ts_name=None, ma_name=None, ts_trace_kwargs={}, ma_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         ts_name=None,
         ma_name=None,
         ts_trace_kwargs={},
         ma_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    check_type(self.ts, pd.Series)
    check_type(self.ma, pd.Series)

    if ts_name is None:
        ts_name = f&#39;Price ({self.name})&#39;
    if ma_name is None:
        ma_name = f&#39;MA ({self.name})&#39;

    fig = self.ts.vbt.timeseries.plot(name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.ma.vbt.timeseries.plot(name=ma_name, trace_kwargs=ma_trace_kwargs, fig=fig)

    return fig</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.MACD"><code class="flex name class">
<span>class <span class="ident">MACD</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MACD(FactoryMACD):
    @classmethod
    def from_params(cls, ts, fast_window=26, slow_window=12, signal_window=9, ewm=True, **kwargs):
        return super().from_params(ts, fast_window, slow_window, signal_window, ewm, **kwargs)

    def plot(self,
             macd_name=None,
             signal_name=None,
             macd_trace_kwargs={},
             signal_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.macd, pd.Series)
        check_type(self.signal, pd.Series)

        if macd_name is None:
            macd_name = f&#39;MACD ({self.name})&#39;
        if signal_name is None:
            signal_name = f&#39;Signal ({self.name})&#39;

        fig = self.macd.vbt.timeseries.plot(
            name=macd_name, trace_kwargs=macd_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.signal.vbt.timeseries.plot(name=signal_name, trace_kwargs=signal_trace_kwargs, fig=fig)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.IndicatorFactory.from_custom_func.<locals>.CustomIndicator</li>
<li>vectorbt.indicators.BaseIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.MACD.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, fast_window=26, slow_window=12, signal_window=9, ewm=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, fast_window=26, slow_window=12, signal_window=9, ewm=True, **kwargs):
    return super().from_params(ts, fast_window, slow_window, signal_window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.MACD.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, macd_name=None, signal_name=None, macd_trace_kwargs={}, signal_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         macd_name=None,
         signal_name=None,
         macd_trace_kwargs={},
         signal_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    check_type(self.macd, pd.Series)
    check_type(self.signal, pd.Series)

    if macd_name is None:
        macd_name = f&#39;MACD ({self.name})&#39;
    if signal_name is None:
        signal_name = f&#39;Signal ({self.name})&#39;

    fig = self.macd.vbt.timeseries.plot(
        name=macd_name, trace_kwargs=macd_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.signal.vbt.timeseries.plot(name=signal_name, trace_kwargs=signal_trace_kwargs, fig=fig)

    return fig</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.MSTD"><code class="flex name class">
<span>class <span class="ident">MSTD</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MSTD(FactoryMSTD):
    @classmethod
    def from_params(cls, ts, window, ewm=False, **kwargs):
        return super().from_params(ts, window, ewm, **kwargs)

    def plot(self,
             name=None,
             trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.mstd, pd.Series)

        if name is None:
            name = f&#39;MSTD ({self.name})&#39;

        fig = self.mstd.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.IndicatorFactory.from_custom_func.<locals>.CustomIndicator</li>
<li>vectorbt.indicators.BaseIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.MSTD.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, window, ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, window, ewm=False, **kwargs):
    return super().from_params(ts, window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.MSTD.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, name=None, trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         name=None,
         trace_kwargs={},
         fig=None,
         **layout_kwargs):
    check_type(self.mstd, pd.Series)

    if name is None:
        name = f&#39;MSTD ({self.name})&#39;

    fig = self.mstd.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.OBV"><code class="flex name class">
<span>class <span class="ident">OBV</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OBV(FactoryOBV):
    @classmethod
    def from_params(cls, close_ts, volume_ts):
        return super().from_params(close_ts, volume_ts)

    def plot(self,
             name=None,
             trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.obv, pd.Series)

        if name is None:
            name = f&#39;OBV ({self.name})&#39;

        fig = self.obv.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.IndicatorFactory.from_custom_func.<locals>.CustomIndicator</li>
<li>vectorbt.indicators.BaseIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.OBV.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>close_ts, volume_ts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, close_ts, volume_ts):
    return super().from_params(close_ts, volume_ts)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.OBV.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, name=None, trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         name=None,
         trace_kwargs={},
         fig=None,
         **layout_kwargs):
    check_type(self.obv, pd.Series)

    if name is None:
        name = f&#39;OBV ({self.name})&#39;

    fig = self.obv.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.RSI"><code class="flex name class">
<span>class <span class="ident">RSI</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RSI(FactoryRSI):
    @classmethod
    def from_params(cls, ts, window=14, ewm=False, **kwargs):
        return super().from_params(ts, window, ewm, **kwargs)

    def plot(self,
             name=None,
             trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.rsi, pd.Series)

        if name is None:
            name = f&#39;RSI ({self.name})&#39;

        fig = self.rsi.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.IndicatorFactory.from_custom_func.<locals>.CustomIndicator</li>
<li>vectorbt.indicators.BaseIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.RSI.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, window=14, ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, window=14, ewm=False, **kwargs):
    return super().from_params(ts, window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.RSI.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, name=None, trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         name=None,
         trace_kwargs={},
         fig=None,
         **layout_kwargs):
    check_type(self.rsi, pd.Series)

    if name is None:
        name = f&#39;RSI ({self.name})&#39;

    fig = self.rsi.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.Stochastic"><code class="flex name class">
<span>class <span class="ident">Stochastic</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stochastic(FactoryStochastic):
    @classmethod
    def from_params(cls, close_ts, high_ts=None, low_ts=None, k_window=14, d_window=3, ewm=False, **kwargs):
        if high_ts is None:
            high_ts = close_ts
        if low_ts is None:
            low_ts = close_ts
        return super().from_params(close_ts, high_ts, low_ts, k_window, d_window, ewm, **kwargs)

    def crossover_signals(self, wait=0, **kwargs):
        pk_above_signals = self.is_percent_k_above(
            self.percent_d, **kwargs).vbt.signals.nst(wait+1, after_false=True)
        pk_below_signals = self.is_percent_k_below(
            self.percent_d, **kwargs).vbt.signals.nst(wait+1, after_false=True)
        return pk_above_signals, pk_below_signals

    def plot(self,
             percent_k_name=None,
             percent_d_name=None,
             percent_k_trace_kwargs={},
             percent_d_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.percent_k, pd.Series)
        check_type(self.percent_d, pd.Series)

        if percent_k_name is None:
            percent_k_name = f&#39;%K ({self.name})&#39;
        if percent_d_name is None:
            percent_d_name = f&#39;%D ({self.name})&#39;

        fig = self.percent_k.vbt.timeseries.plot(
            name=percent_k_name, trace_kwargs=percent_k_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.percent_d.vbt.timeseries.plot(name=percent_d_name, trace_kwargs=percent_d_trace_kwargs, fig=fig)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.IndicatorFactory.from_custom_func.<locals>.CustomIndicator</li>
<li>vectorbt.indicators.BaseIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.Stochastic.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>close_ts, high_ts=None, low_ts=None, k_window=14, d_window=3, ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, close_ts, high_ts=None, low_ts=None, k_window=14, d_window=3, ewm=False, **kwargs):
    if high_ts is None:
        high_ts = close_ts
    if low_ts is None:
        low_ts = close_ts
    return super().from_params(close_ts, high_ts, low_ts, k_window, d_window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.Stochastic.crossover_signals"><code class="name flex">
<span>def <span class="ident">crossover_signals</span></span>(<span>self, wait=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crossover_signals(self, wait=0, **kwargs):
    pk_above_signals = self.is_percent_k_above(
        self.percent_d, **kwargs).vbt.signals.nst(wait+1, after_false=True)
    pk_below_signals = self.is_percent_k_below(
        self.percent_d, **kwargs).vbt.signals.nst(wait+1, after_false=True)
    return pk_above_signals, pk_below_signals</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, percent_k_name=None, percent_d_name=None, percent_k_trace_kwargs={}, percent_d_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         percent_k_name=None,
         percent_d_name=None,
         percent_k_trace_kwargs={},
         percent_d_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    check_type(self.percent_k, pd.Series)
    check_type(self.percent_d, pd.Series)

    if percent_k_name is None:
        percent_k_name = f&#39;%K ({self.name})&#39;
    if percent_d_name is None:
        percent_d_name = f&#39;%D ({self.name})&#39;

    fig = self.percent_k.vbt.timeseries.plot(
        name=percent_k_name, trace_kwargs=percent_k_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.percent_d.vbt.timeseries.plot(name=percent_d_name, trace_kwargs=percent_d_trace_kwargs, fig=fig)

    return fig</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt" href="index.html">vectorbt</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.indicators.BollingerBands" href="#vectorbt.indicators.BollingerBands">BollingerBands</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.indicators.BollingerBands.from_params" href="#vectorbt.indicators.BollingerBands.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.plot" href="#vectorbt.indicators.BollingerBands.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.DMAC" href="#vectorbt.indicators.DMAC">DMAC</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.indicators.DMAC.crossover" href="#vectorbt.indicators.DMAC.crossover">crossover</a></code></li>
<li><code><a title="vectorbt.indicators.DMAC.from_combinations" href="#vectorbt.indicators.DMAC.from_combinations">from_combinations</a></code></li>
<li><code><a title="vectorbt.indicators.DMAC.from_params" href="#vectorbt.indicators.DMAC.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.DMAC.plot" href="#vectorbt.indicators.DMAC.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.IndicatorFactory" href="#vectorbt.indicators.IndicatorFactory">IndicatorFactory</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.indicators.IndicatorFactory.from_apply_func" href="#vectorbt.indicators.IndicatorFactory.from_apply_func">from_apply_func</a></code></li>
<li><code><a title="vectorbt.indicators.IndicatorFactory.from_custom_func" href="#vectorbt.indicators.IndicatorFactory.from_custom_func">from_custom_func</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.MA" href="#vectorbt.indicators.MA">MA</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.indicators.MA.from_params" href="#vectorbt.indicators.MA.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.MA.plot" href="#vectorbt.indicators.MA.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.MACD" href="#vectorbt.indicators.MACD">MACD</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.indicators.MACD.from_params" href="#vectorbt.indicators.MACD.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.plot" href="#vectorbt.indicators.MACD.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.MSTD" href="#vectorbt.indicators.MSTD">MSTD</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.indicators.MSTD.from_params" href="#vectorbt.indicators.MSTD.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.plot" href="#vectorbt.indicators.MSTD.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.OBV" href="#vectorbt.indicators.OBV">OBV</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.indicators.OBV.from_params" href="#vectorbt.indicators.OBV.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.plot" href="#vectorbt.indicators.OBV.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.RSI" href="#vectorbt.indicators.RSI">RSI</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.indicators.RSI.from_params" href="#vectorbt.indicators.RSI.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.plot" href="#vectorbt.indicators.RSI.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.Stochastic" href="#vectorbt.indicators.Stochastic">Stochastic</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.indicators.Stochastic.crossover_signals" href="#vectorbt.indicators.Stochastic.crossover_signals">crossover_signals</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.from_params" href="#vectorbt.indicators.Stochastic.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.plot" href="#vectorbt.indicators.Stochastic.plot">plot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>