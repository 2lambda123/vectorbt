<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.utils.decorators API documentation</title>
<meta name="description" content="Class and function decorators." />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3B4556}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="mask-icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.utils.decorators</code></h1>
</header>
<section id="section-intro">
<p>Class and function decorators.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Class and function decorators.&#34;&#34;&#34;

from functools import wraps, lru_cache, RLock
import inspect

from vectorbt.utils import checks


class class_or_instancemethod(classmethod):
    &#34;&#34;&#34;Function decorator that binds `self` to a class if the function is called as class method,
    otherwise to an instance.&#34;&#34;&#34;

    def __get__(self, instance, type_):
        descr_get = super().__get__ if instance is None else self.__func__.__get__
        return descr_get(instance, type_)


class classproperty(object):
    &#34;&#34;&#34;Property that can be called on a class.&#34;&#34;&#34;

    def __init__(self, f):
        self.f = f

    def __get__(self, obj, owner):
        return self.f(owner)


class custom_property():
    &#34;&#34;&#34;Custom extensible, read-only property.

    Can be called both as
    ```plaintext
    @custom_property
    def user_function...
    ```
    and
    ```plaintext
    @custom_property(**kwargs)
    def user_function...
    ```

    !!! note
        `custom_property` instances belong to classes, not class instances. Thus changing the property,
        for example, by disabling caching, will do the same for each instance of the class where
        the property has been defined.&#34;&#34;&#34;

    def __new__(cls, *args, **kwargs):
        if len(args) == 0:
            return lambda func: cls(func, **kwargs)
        elif len(args) == 1:
            return super().__new__(cls)
        else:
            raise ValueError(&#34;Either function or keyword arguments must be passed&#34;)

    def __init__(self, func, **kwargs):
        self.func = func
        self.name = func.__name__
        self.kwargs = kwargs
        self.__doc__ = getattr(func, &#39;__doc__&#39;)

    def __get__(self, instance, owner=None):
        if instance is None:
            return self
        return self.func(instance)

    def __set__(self, obj, value):
        raise AttributeError(&#34;can&#39;t set attribute&#34;)


def is_caching_enabled(name, instance, func=None, **kwargs):
    &#34;&#34;&#34;Check whether caching is enabled for a cacheable property/function.

    Each condition has its own rank. A narrower condition has a lower (better) rank than a broader
    condition. If the same condition was met in both whitelist and blacklist, whitelist wins.

    List of conditions ranked:

    ```plaintext
    1) is function in whitelist/blacklist? (properties are not supported)
    2) is (instance, function name) in whitelist/blacklist?
    3) is function name in whitelist/blacklist?
    4) is instance in whitelist/blacklist?
    5) is (class, function name) in whitelist/blacklist?
    6) is class in whitelist/blacklist?
    7) is &#34;class_name.function_name&#34; in whitelist/blacklist?
    8) is class name in whitelist/blacklist?
    9) is subset of kwargs in whitelist/blacklist?
    10) is caching disabled globally?

    All names are case-sensitive.
    ```&#34;&#34;&#34;
    from vectorbt import settings

    white_rank = 100
    if len(settings.caching[&#39;whitelist&#39;]) &gt; 0:
        for obj in settings.caching[&#39;whitelist&#39;]:
            if func is not None and inspect.ismethod(obj) and func == obj:
                white_rank = 0
                break
            if isinstance(obj, tuple) and len(obj) == 2 and isinstance(obj[1], str):
                if instance is obj[0] and name == obj[1]:
                    white_rank = 1
                    break
            if isinstance(obj, str) and name == obj:
                white_rank = 2
                break
            if instance is obj:
                white_rank = 3
                break
            if hasattr(instance, &#39;__class__&#39;):
                cls = instance.__class__
                if isinstance(obj, tuple) and len(obj) == 2 and isinstance(obj[1], str):
                    if inspect.isclass(cls) and cls == obj[0] and name == obj[1]:
                        white_rank = 4
                        break
                if inspect.isclass(cls) and cls == obj:
                    white_rank = 5
                    break
                if isinstance(obj, str) and (cls.__name__ + &#39;.&#39; + name) == obj:
                    white_rank = 6
                    break
                if isinstance(obj, str) and cls.__name__ == obj:
                    white_rank = 7
                    break
            if isinstance(obj, dict) and obj.items() &lt;= kwargs.items():
                white_rank = 8
                break

    black_rank = 100
    if len(settings.caching[&#39;blacklist&#39;]) &gt; 0:
        for obj in settings.caching[&#39;blacklist&#39;]:
            if func is not None and inspect.ismethod(obj) and func == obj:
                black_rank = 0
                break
            if isinstance(obj, tuple) and len(obj) == 2 and isinstance(obj[1], str):
                if instance is obj[0] and name == obj[1]:
                    black_rank = 1
                    break
            if isinstance(obj, str) and name == obj:
                black_rank = 2
                break
            if instance is obj:
                black_rank = 3
                break
            if hasattr(instance, &#39;__class__&#39;):
                cls = instance.__class__
                if isinstance(obj, tuple) and len(obj) == 2 and isinstance(obj[1], str):
                    if inspect.isclass(cls) and cls == obj[0] and name == obj[1]:
                        black_rank = 4
                        break
                if inspect.isclass(cls) and cls == obj:
                    black_rank = 5
                    break
                if isinstance(obj, str) and (cls.__name__ + &#39;.&#39; + name) == obj:
                    black_rank = 6
                    break
                if isinstance(obj, str) and cls.__name__ == obj:
                    black_rank = 7
                    break
            if isinstance(obj, dict) and obj.items() &lt;= kwargs.items():
                black_rank = 8
                break

    if white_rank == black_rank == 100:  # none of the conditions met
        return settings.caching[&#39;enabled&#39;]  # global caching decides
    return white_rank &lt;= black_rank  # white wins if equal


_NOT_FOUND = object()


class cached_property(custom_property):
    &#34;&#34;&#34;Extends `custom_property` with caching.

    Similar to `functools.cached_property`, but without replacing the original attribute
    to be able to re-compute whenever needed.

    Disables caching if `is_caching_enabled` yields False.

    Cache can be cleared by calling `clear_cache` with instance as argument.

    !!! note:
        Assumes that the instance (provided as `self`) won&#39;t change. If calculation depends
        upon object attributes that can be changed, it won&#39;t notice the change.&#34;&#34;&#34;

    def __init__(self, func, **kwargs):
        super().__init__(func, **kwargs)
        self.lock = RLock()

    def clear_cache(self, instance):
        &#34;&#34;&#34;Clear the cache for this property belonging to `instance`.&#34;&#34;&#34;
        if hasattr(instance, self.attrname):
            delattr(instance, self.attrname)

    @property
    def attrname(self):
        &#34;&#34;&#34;Get name of cached attribute.&#34;&#34;&#34;
        return &#39;__cached_&#39; + self.name

    def __set_name__(self, owner, name):
        self.name = name

    def __get__(self, instance, owner=None):
        if instance is None:
            return self
        if not is_caching_enabled(self.name, instance, **self.kwargs):
            return super().__get__(instance, owner=owner)
        cache = instance.__dict__
        val = cache.get(self.attrname, _NOT_FOUND)
        if val is _NOT_FOUND:
            with self.lock:
                # check if another thread filled cache while we awaited lock
                val = cache.get(self.attrname, _NOT_FOUND)
                if val is _NOT_FOUND:
                    val = self.func(instance)
                    cache[self.attrname] = val
        return val


def custom_method(*args, **kwargs):
    &#34;&#34;&#34;Custom extensible method.

    Stores `**kwargs` as attributes of the wrapper function.

    Can be called both as
    ```python-repl
    &gt;&gt;&gt; @cached_method
    ... def user_function(): pass
    ```
    and
    ```python-repl
    &gt;&gt;&gt; @cached_method(maxsize=128, typed=False, **kwargs)
    ... def user_function(): pass
    ```
    &#34;&#34;&#34;

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)

        wrapper.func = func
        wrapper.kwargs = kwargs

        return wrapper

    if len(args) == 0:
        return decorator
    elif len(args) == 1:
        return decorator(args[0])
    else:
        raise ValueError(&#34;Either function or keyword arguments must be passed&#34;)


def cached_method(*args, maxsize=128, typed=False, **kwargs):
    &#34;&#34;&#34;Extends `custom_method` with caching.

    Internally uses `functools.lru_cache`.

    Disables caching if `is_caching_enabled` yields False or a non-hashable object
    as argument has been passed.

    See notes on `cached_property`.&#34;&#34;&#34;

    def decorator(func):
        @wraps(func)
        def wrapper(instance, *args, **kwargs):
            def partial_func(*args, **kwargs):
                # Ignores non-hashable instances
                return func(instance, *args, **kwargs)

            _func = None
            if hasattr(instance, wrapper.name):
                _func = getattr(instance, wrapper.name)
            if not is_caching_enabled(wrapper.name, instance, func=_func, **wrapper.kwargs):
                return func(instance, *args, **kwargs)
            cache = instance.__dict__
            cached_func = cache.get(wrapper.attrname, _NOT_FOUND)
            if cached_func is _NOT_FOUND:
                with wrapper.lock:
                    # check if another thread filled cache while we awaited lock
                    cached_func = cache.get(wrapper.attrname, _NOT_FOUND)
                    if cached_func is _NOT_FOUND:
                        cached_func = lru_cache(maxsize=wrapper.maxsize, typed=wrapper.typed)(partial_func)
                        cache[wrapper.attrname] = cached_func  # store function instead of output

            # Check if object can be hashed
            hashable = True
            for arg in args:
                if not checks.is_hashable(arg):
                    hashable = False
                    break
            for k, v in kwargs.items():
                if not checks.is_hashable(v):
                    hashable = False
                    break
            if not hashable:
                # If not, do not invoke lru_cache
                return func(instance, *args, **kwargs)
            return cached_func(*args, **kwargs)

        wrapper.func = func
        wrapper.maxsize = maxsize
        wrapper.typed = typed
        wrapper.name = func.__name__
        wrapper.attrname = &#39;__cached_&#39; + func.__name__
        wrapper.lock = RLock()
        wrapper.kwargs = kwargs

        def clear_cache(instance):
            &#34;&#34;&#34;Clear the cache for this method belonging to `instance`.&#34;&#34;&#34;
            if hasattr(instance, wrapper.attrname):
                delattr(instance, wrapper.attrname)

        setattr(wrapper, &#39;clear_cache&#39;, clear_cache)

        return wrapper

    if len(args) == 0:
        return decorator
    elif len(args) == 1:
        return decorator(args[0])
    else:
        raise ValueError(&#34;Either function or keyword arguments must be passed&#34;)


def traverse_attr_kwargs(cls, key=None, value=None):
    &#34;&#34;&#34;Traverse `cls` and its children for properties/methods with `kwargs`,
    and optionally a specific `key` and `value`.

    Class attributes acting as children should have a key `child_cls`.

    Returns a nested dict of attributes.&#34;&#34;&#34;
    checks.assert_type(cls, type)

    if value is not None and not isinstance(value, tuple):
        value = (value,)
    attrs = {}
    for attr in dir(cls):
        prop = getattr(cls, attr)
        if hasattr(prop, &#39;kwargs&#39;):
            kwargs = getattr(prop, &#39;kwargs&#39;)
            if key is None:
                attrs[attr] = kwargs
            else:
                if key in kwargs:
                    if value is None:
                        attrs[attr] = kwargs
                    else:
                        _value = kwargs[key]
                        if _value in value:
                            attrs[attr] = kwargs
            if &#39;child_cls&#39; in kwargs:
                child_cls = kwargs[&#39;child_cls&#39;]
                checks.assert_type(child_cls, type)
                attrs[attr] = kwargs
                attrs[attr][&#39;child_attrs&#39;] = traverse_attr_kwargs(child_cls, key, value)
    return attrs</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.utils.decorators.cached_method"><code class="name flex">
<span>def <span class="ident fname">cached_method</span></span>(<span>*args, maxsize=128, typed=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code><a title="vectorbt.utils.decorators.custom_method" href="#vectorbt.utils.decorators.custom_method">custom_method()</a></code> with caching.</p>
<p>Internally uses <code>functools.lru_cache</code>.</p>
<p>Disables caching if <code><a title="vectorbt.utils.decorators.is_caching_enabled" href="#vectorbt.utils.decorators.is_caching_enabled">is_caching_enabled()</a></code> yields False or a non-hashable object
as argument has been passed.</p>
<p>See notes on <code><a title="vectorbt.utils.decorators.cached_property" href="#vectorbt.utils.decorators.cached_property">cached_property</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cached_method(*args, maxsize=128, typed=False, **kwargs):
    &#34;&#34;&#34;Extends `custom_method` with caching.

    Internally uses `functools.lru_cache`.

    Disables caching if `is_caching_enabled` yields False or a non-hashable object
    as argument has been passed.

    See notes on `cached_property`.&#34;&#34;&#34;

    def decorator(func):
        @wraps(func)
        def wrapper(instance, *args, **kwargs):
            def partial_func(*args, **kwargs):
                # Ignores non-hashable instances
                return func(instance, *args, **kwargs)

            _func = None
            if hasattr(instance, wrapper.name):
                _func = getattr(instance, wrapper.name)
            if not is_caching_enabled(wrapper.name, instance, func=_func, **wrapper.kwargs):
                return func(instance, *args, **kwargs)
            cache = instance.__dict__
            cached_func = cache.get(wrapper.attrname, _NOT_FOUND)
            if cached_func is _NOT_FOUND:
                with wrapper.lock:
                    # check if another thread filled cache while we awaited lock
                    cached_func = cache.get(wrapper.attrname, _NOT_FOUND)
                    if cached_func is _NOT_FOUND:
                        cached_func = lru_cache(maxsize=wrapper.maxsize, typed=wrapper.typed)(partial_func)
                        cache[wrapper.attrname] = cached_func  # store function instead of output

            # Check if object can be hashed
            hashable = True
            for arg in args:
                if not checks.is_hashable(arg):
                    hashable = False
                    break
            for k, v in kwargs.items():
                if not checks.is_hashable(v):
                    hashable = False
                    break
            if not hashable:
                # If not, do not invoke lru_cache
                return func(instance, *args, **kwargs)
            return cached_func(*args, **kwargs)

        wrapper.func = func
        wrapper.maxsize = maxsize
        wrapper.typed = typed
        wrapper.name = func.__name__
        wrapper.attrname = &#39;__cached_&#39; + func.__name__
        wrapper.lock = RLock()
        wrapper.kwargs = kwargs

        def clear_cache(instance):
            &#34;&#34;&#34;Clear the cache for this method belonging to `instance`.&#34;&#34;&#34;
            if hasattr(instance, wrapper.attrname):
                delattr(instance, wrapper.attrname)

        setattr(wrapper, &#39;clear_cache&#39;, clear_cache)

        return wrapper

    if len(args) == 0:
        return decorator
    elif len(args) == 1:
        return decorator(args[0])
    else:
        raise ValueError(&#34;Either function or keyword arguments must be passed&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.decorators.custom_method"><code class="name flex">
<span>def <span class="ident fname">custom_method</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom extensible method.</p>
<p>Stores <code>**kwargs</code> as attributes of the wrapper function.</p>
<p>Can be called both as</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @cached_method
... def user_function(): pass
</code></pre>
<p>and</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @cached_method(maxsize=128, typed=False, **kwargs)
... def user_function(): pass
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_method(*args, **kwargs):
    &#34;&#34;&#34;Custom extensible method.

    Stores `**kwargs` as attributes of the wrapper function.

    Can be called both as
    ```python-repl
    &gt;&gt;&gt; @cached_method
    ... def user_function(): pass
    ```
    and
    ```python-repl
    &gt;&gt;&gt; @cached_method(maxsize=128, typed=False, **kwargs)
    ... def user_function(): pass
    ```
    &#34;&#34;&#34;

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)

        wrapper.func = func
        wrapper.kwargs = kwargs

        return wrapper

    if len(args) == 0:
        return decorator
    elif len(args) == 1:
        return decorator(args[0])
    else:
        raise ValueError(&#34;Either function or keyword arguments must be passed&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.decorators.is_caching_enabled"><code class="name flex">
<span>def <span class="ident fname">is_caching_enabled</span></span>(<span>name, instance, func=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether caching is enabled for a cacheable property/function.</p>
<p>Each condition has its own rank. A narrower condition has a lower (better) rank than a broader
condition. If the same condition was met in both whitelist and blacklist, whitelist wins.</p>
<p>List of conditions ranked:</p>
<pre><code class="language-plaintext">1) is function in whitelist/blacklist? (properties are not supported)
2) is (instance, function name) in whitelist/blacklist?
3) is function name in whitelist/blacklist?
4) is instance in whitelist/blacklist?
5) is (class, function name) in whitelist/blacklist?
6) is class in whitelist/blacklist?
7) is &quot;class_name.function_name&quot; in whitelist/blacklist?
8) is class name in whitelist/blacklist?
9) is subset of kwargs in whitelist/blacklist?
10) is caching disabled globally?

All names are case-sensitive.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_caching_enabled(name, instance, func=None, **kwargs):
    &#34;&#34;&#34;Check whether caching is enabled for a cacheable property/function.

    Each condition has its own rank. A narrower condition has a lower (better) rank than a broader
    condition. If the same condition was met in both whitelist and blacklist, whitelist wins.

    List of conditions ranked:

    ```plaintext
    1) is function in whitelist/blacklist? (properties are not supported)
    2) is (instance, function name) in whitelist/blacklist?
    3) is function name in whitelist/blacklist?
    4) is instance in whitelist/blacklist?
    5) is (class, function name) in whitelist/blacklist?
    6) is class in whitelist/blacklist?
    7) is &#34;class_name.function_name&#34; in whitelist/blacklist?
    8) is class name in whitelist/blacklist?
    9) is subset of kwargs in whitelist/blacklist?
    10) is caching disabled globally?

    All names are case-sensitive.
    ```&#34;&#34;&#34;
    from vectorbt import settings

    white_rank = 100
    if len(settings.caching[&#39;whitelist&#39;]) &gt; 0:
        for obj in settings.caching[&#39;whitelist&#39;]:
            if func is not None and inspect.ismethod(obj) and func == obj:
                white_rank = 0
                break
            if isinstance(obj, tuple) and len(obj) == 2 and isinstance(obj[1], str):
                if instance is obj[0] and name == obj[1]:
                    white_rank = 1
                    break
            if isinstance(obj, str) and name == obj:
                white_rank = 2
                break
            if instance is obj:
                white_rank = 3
                break
            if hasattr(instance, &#39;__class__&#39;):
                cls = instance.__class__
                if isinstance(obj, tuple) and len(obj) == 2 and isinstance(obj[1], str):
                    if inspect.isclass(cls) and cls == obj[0] and name == obj[1]:
                        white_rank = 4
                        break
                if inspect.isclass(cls) and cls == obj:
                    white_rank = 5
                    break
                if isinstance(obj, str) and (cls.__name__ + &#39;.&#39; + name) == obj:
                    white_rank = 6
                    break
                if isinstance(obj, str) and cls.__name__ == obj:
                    white_rank = 7
                    break
            if isinstance(obj, dict) and obj.items() &lt;= kwargs.items():
                white_rank = 8
                break

    black_rank = 100
    if len(settings.caching[&#39;blacklist&#39;]) &gt; 0:
        for obj in settings.caching[&#39;blacklist&#39;]:
            if func is not None and inspect.ismethod(obj) and func == obj:
                black_rank = 0
                break
            if isinstance(obj, tuple) and len(obj) == 2 and isinstance(obj[1], str):
                if instance is obj[0] and name == obj[1]:
                    black_rank = 1
                    break
            if isinstance(obj, str) and name == obj:
                black_rank = 2
                break
            if instance is obj:
                black_rank = 3
                break
            if hasattr(instance, &#39;__class__&#39;):
                cls = instance.__class__
                if isinstance(obj, tuple) and len(obj) == 2 and isinstance(obj[1], str):
                    if inspect.isclass(cls) and cls == obj[0] and name == obj[1]:
                        black_rank = 4
                        break
                if inspect.isclass(cls) and cls == obj:
                    black_rank = 5
                    break
                if isinstance(obj, str) and (cls.__name__ + &#39;.&#39; + name) == obj:
                    black_rank = 6
                    break
                if isinstance(obj, str) and cls.__name__ == obj:
                    black_rank = 7
                    break
            if isinstance(obj, dict) and obj.items() &lt;= kwargs.items():
                black_rank = 8
                break

    if white_rank == black_rank == 100:  # none of the conditions met
        return settings.caching[&#39;enabled&#39;]  # global caching decides
    return white_rank &lt;= black_rank  # white wins if equal</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.decorators.traverse_attr_kwargs"><code class="name flex">
<span>def <span class="ident fname">traverse_attr_kwargs</span></span>(<span>cls, key=None, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Traverse <code>cls</code> and its children for properties/methods with <code>kwargs</code>,
and optionally a specific <code>key</code> and <code>value</code>.</p>
<p>Class attributes acting as children should have a key <code>child_cls</code>.</p>
<p>Returns a nested dict of attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def traverse_attr_kwargs(cls, key=None, value=None):
    &#34;&#34;&#34;Traverse `cls` and its children for properties/methods with `kwargs`,
    and optionally a specific `key` and `value`.

    Class attributes acting as children should have a key `child_cls`.

    Returns a nested dict of attributes.&#34;&#34;&#34;
    checks.assert_type(cls, type)

    if value is not None and not isinstance(value, tuple):
        value = (value,)
    attrs = {}
    for attr in dir(cls):
        prop = getattr(cls, attr)
        if hasattr(prop, &#39;kwargs&#39;):
            kwargs = getattr(prop, &#39;kwargs&#39;)
            if key is None:
                attrs[attr] = kwargs
            else:
                if key in kwargs:
                    if value is None:
                        attrs[attr] = kwargs
                    else:
                        _value = kwargs[key]
                        if _value in value:
                            attrs[attr] = kwargs
            if &#39;child_cls&#39; in kwargs:
                child_cls = kwargs[&#39;child_cls&#39;]
                checks.assert_type(child_cls, type)
                attrs[attr] = kwargs
                attrs[attr][&#39;child_attrs&#39;] = traverse_attr_kwargs(child_cls, key, value)
    return attrs</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.utils.decorators.cached_property"><code class="flex name class">
<span>class <span class="ident parent-fname">cached_property</span></span>
<span>(</span><span>func, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code><a title="vectorbt.utils.decorators.custom_property" href="#vectorbt.utils.decorators.custom_property">custom_property</a></code> with caching.</p>
<p>Similar to <code>functools.cached_property</code>, but without replacing the original attribute
to be able to re-compute whenever needed.</p>
<p>Disables caching if <code><a title="vectorbt.utils.decorators.is_caching_enabled" href="#vectorbt.utils.decorators.is_caching_enabled">is_caching_enabled()</a></code> yields False.</p>
<p>Cache can be cleared by calling <code>clear_cache</code> with instance as argument.</p>
<p>!!! note:
Assumes that the instance (provided as <code>self</code>) won't change. If calculation depends
upon object attributes that can be changed, it won't notice the change.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class cached_property(custom_property):
    &#34;&#34;&#34;Extends `custom_property` with caching.

    Similar to `functools.cached_property`, but without replacing the original attribute
    to be able to re-compute whenever needed.

    Disables caching if `is_caching_enabled` yields False.

    Cache can be cleared by calling `clear_cache` with instance as argument.

    !!! note:
        Assumes that the instance (provided as `self`) won&#39;t change. If calculation depends
        upon object attributes that can be changed, it won&#39;t notice the change.&#34;&#34;&#34;

    def __init__(self, func, **kwargs):
        super().__init__(func, **kwargs)
        self.lock = RLock()

    def clear_cache(self, instance):
        &#34;&#34;&#34;Clear the cache for this property belonging to `instance`.&#34;&#34;&#34;
        if hasattr(instance, self.attrname):
            delattr(instance, self.attrname)

    @property
    def attrname(self):
        &#34;&#34;&#34;Get name of cached attribute.&#34;&#34;&#34;
        return &#39;__cached_&#39; + self.name

    def __set_name__(self, owner, name):
        self.name = name

    def __get__(self, instance, owner=None):
        if instance is None:
            return self
        if not is_caching_enabled(self.name, instance, **self.kwargs):
            return super().__get__(instance, owner=owner)
        cache = instance.__dict__
        val = cache.get(self.attrname, _NOT_FOUND)
        if val is _NOT_FOUND:
            with self.lock:
                # check if another thread filled cache while we awaited lock
                val = cache.get(self.attrname, _NOT_FOUND)
                if val is _NOT_FOUND:
                    val = self.func(instance)
                    cache[self.attrname] = val
        return val</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.decorators.custom_property" href="#vectorbt.utils.decorators.custom_property">custom_property</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.utils.decorators.cached_property.attrname"><code class="name">var <span class="ident fname">attrname</span></code></dt>
<dd>
<div class="desc"><p>Get name of cached attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def attrname(self):
    &#34;&#34;&#34;Get name of cached attribute.&#34;&#34;&#34;
    return &#39;__cached_&#39; + self.name</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.utils.decorators.cached_property.clear_cache"><code class="name flex">
<span>def <span class="ident fname">clear_cache</span></span>(<span>self, instance)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear the cache for this property belonging to <code>instance</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self, instance):
    &#34;&#34;&#34;Clear the cache for this property belonging to `instance`.&#34;&#34;&#34;
    if hasattr(instance, self.attrname):
        delattr(instance, self.attrname)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.utils.decorators.class_or_instancemethod"><code class="flex name class">
<span>class <span class="ident parent-fname">class_or_instancemethod</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function decorator that binds <code>self</code> to a class if the function is called as class method,
otherwise to an instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class class_or_instancemethod(classmethod):
    &#34;&#34;&#34;Function decorator that binds `self` to a class if the function is called as class method,
    otherwise to an instance.&#34;&#34;&#34;

    def __get__(self, instance, type_):
        descr_get = super().__get__ if instance is None else self.__func__.__get__
        return descr_get(instance, type_)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>builtins.classmethod</li>
</ul>
</dd>
<dt id="vectorbt.utils.decorators.classproperty"><code class="flex name class">
<span>class <span class="ident parent-fname">classproperty</span></span>
<span>(</span><span>f)</span>
</code></dt>
<dd>
<div class="desc"><p>Property that can be called on a class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class classproperty(object):
    &#34;&#34;&#34;Property that can be called on a class.&#34;&#34;&#34;

    def __init__(self, f):
        self.f = f

    def __get__(self, obj, owner):
        return self.f(owner)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.decorators.custom_property"><code class="flex name class">
<span>class <span class="ident parent-fname">custom_property</span></span>
<span>(</span><span>func, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom extensible, read-only property.</p>
<p>Can be called both as</p>
<pre><code class="language-plaintext">@custom_property
def user_function...
</code></pre>
<p>and</p>
<pre><code class="language-plaintext">@custom_property(**kwargs)
def user_function...
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code><a title="vectorbt.utils.decorators.custom_property" href="#vectorbt.utils.decorators.custom_property">custom_property</a></code> instances belong to classes, not class instances. Thus changing the property,
for example, by disabling caching, will do the same for each instance of the class where
the property has been defined.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class custom_property():
    &#34;&#34;&#34;Custom extensible, read-only property.

    Can be called both as
    ```plaintext
    @custom_property
    def user_function...
    ```
    and
    ```plaintext
    @custom_property(**kwargs)
    def user_function...
    ```

    !!! note
        `custom_property` instances belong to classes, not class instances. Thus changing the property,
        for example, by disabling caching, will do the same for each instance of the class where
        the property has been defined.&#34;&#34;&#34;

    def __new__(cls, *args, **kwargs):
        if len(args) == 0:
            return lambda func: cls(func, **kwargs)
        elif len(args) == 1:
            return super().__new__(cls)
        else:
            raise ValueError(&#34;Either function or keyword arguments must be passed&#34;)

    def __init__(self, func, **kwargs):
        self.func = func
        self.name = func.__name__
        self.kwargs = kwargs
        self.__doc__ = getattr(func, &#39;__doc__&#39;)

    def __get__(self, instance, owner=None):
        if instance is None:
            return self
        return self.func(instance)

    def __set__(self, obj, value):
        raise AttributeError(&#34;can&#39;t set attribute&#34;)</code></pre>
</details>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.decorators.cached_property" href="#vectorbt.utils.decorators.cached_property">cached_property</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAACXBIWXMAACcQAAAnEAGUaVEZAAAGuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDggNzkuMTY0MDM2LCAyMDE5LzA4LzEzLTAxOjA2OjU3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjEuMCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjAtMDYtMjVUMjM6MzU6MTMrMDI6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjAtMDYtMjZUMTQ6MTA6MzgrMDI6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIwLTA2LTI2VDE0OjEwOjM4KzAyOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNzE0MGFiYi05Mjk1LTQ3MDYtYTNhZi1lMDg2OTFkOTk3NjQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NzZmN2Y4NjAtMThmMi00ZDgxLTg5NjUtNDU5ZjY1NDY2ZGZlIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NzZmN2Y4NjAtMThmMi00ZDgxLTg5NjUtNDU5ZjY1NDY2ZGZlIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjc2ZjdmODYwLTE4ZjItNGQ4MS04OTY1LTQ1OWY2NTQ2NmRmZSIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNVQyMzozNToxMyswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2NjI2MGIzLTY0ZmUtNGJiYy1iMTNiLWZkMDU3NDI3NjIyNCIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNlQxMzoyMTo1NSswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjA3MTQwYWJiLTkyOTUtNDcwNi1hM2FmLWUwODY5MWQ5OTc2NCIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNlQxNDoxMDozOCswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Qc/+aQAAAa5JREFUeJzt3cFJA0EYgFEjgj3FGmIjsQexByuxB4vy5kHwELJhCRPekP3eMYdl4Ms/y84Gstsfjg9xHvUCtq4AWAGwAmAFwAqAFQArAFYArABYAbACYAXACoAVACsAVgCsAFgBsAJgBcAKgBUAexp1oe+vz7Ofv7y+dZ0LmgCsAFgBsAJgBcAKgBUAKwBWAKwAWAGwAmAFwAqAFQAb9j5glFHn7KPcej1NAFYAzG9BP+/n3/ld9vwx1051tSYA8xPwZ/03+rqJmVYTgBUAm2UL+re0w6i7br8LunMFwAqAFQArAFYArADYdM8Bd3PKtlITgBUAm2ULurMzzvWaAMxPwNbuuieaAKwAmN+CTtz6/H02TQBWAKwAWAGwAmAFwAqAFQArAFYArABYAbACYAXACoANex8w23n9bOtZ0gRgBcAKgBUAKwBWAKwA2HT/HzDKbOtZ0gRgBcAKgBUAKwBWAKwAWAGwAmAFwAqAFQArAFYArADYbn846jVsWhOAFQArAFYArABYAbACYAXACoAVACsAVgCsAFgBsAJgBcAKgBUAKwBWAKwAWAGwAmC/7uUrwcQVST8AAAAASUVORK5CYII="/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.utils" href="index.html">vectorbt.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.utils.decorators.cached_method" href="#vectorbt.utils.decorators.cached_method">cached_method</a></code></li>
<li><code><a title="vectorbt.utils.decorators.custom_method" href="#vectorbt.utils.decorators.custom_method">custom_method</a></code></li>
<li><code><a title="vectorbt.utils.decorators.is_caching_enabled" href="#vectorbt.utils.decorators.is_caching_enabled">is_caching_enabled</a></code></li>
<li><code><a title="vectorbt.utils.decorators.traverse_attr_kwargs" href="#vectorbt.utils.decorators.traverse_attr_kwargs">traverse_attr_kwargs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.utils.decorators.cached_property" href="#vectorbt.utils.decorators.cached_property">cached_property</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.decorators.cached_property.attrname" href="#vectorbt.utils.decorators.cached_property.attrname">attrname</a></code></li>
<li><code><a title="vectorbt.utils.decorators.cached_property.clear_cache" href="#vectorbt.utils.decorators.cached_property.clear_cache">clear_cache</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.decorators.class_or_instancemethod" href="#vectorbt.utils.decorators.class_or_instancemethod">class_or_instancemethod</a></code></h4>
</li>
<li>
<h4><code><a title="vectorbt.utils.decorators.classproperty" href="#vectorbt.utils.decorators.classproperty">classproperty</a></code></h4>
</li>
<li>
<h4><code><a title="vectorbt.utils.decorators.custom_property" href="#vectorbt.utils.decorators.custom_property">custom_property</a></code></h4>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>