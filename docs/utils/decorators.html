<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.utils.decorators API documentation</title>
<meta name="description" content="Class and function decorators." />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#e82}.flex{display:flex !important}body{line-height:1.5em}.version{font-weight:normal;font-style:italic;font-size:.75em;color:#56b6c2}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-weight:400;font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:100px;max-height:100px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.utils.decorators</code></h1>
</header>
<section id="section-intro">
<p>Class and function decorators.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Class and function decorators.&#34;&#34;&#34;

from functools import wraps, lru_cache
from threading import RLock
import inspect

from vectorbt import _typing as tp
from vectorbt.utils import checks


class class_or_instancemethod(classmethod):
    &#34;&#34;&#34;Function decorator that binds `self` to a class if the function is called as class method,
    otherwise to an instance.&#34;&#34;&#34;

    def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
        descr_get = super().__get__ if instance is None else self.__func__.__get__
        return descr_get(instance, owner)


class classproperty(object):
    &#34;&#34;&#34;Property that can be called on a class.&#34;&#34;&#34;

    def __init__(self, func: tp.Callable) -&gt; None:
        self.func = func
        self.__doc__ = getattr(func, &#39;__doc__&#39;)

    def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
        return self.func(owner)


custom_propertyT = tp.TypeVar(&#34;custom_propertyT&#34;, bound=&#34;custom_property&#34;)


class custom_property:
    &#34;&#34;&#34;Custom property that stores function and flags as attributes.

    Can be called both as
    ```python-repl
    &gt;&gt;&gt; @custom_property
    ... def user_function(self): pass
    ```
    and
    ```plaintext
    &gt;&gt;&gt; @custom_property(a=0, b=0)  # flags
    ... def user_function(self): pass
    ```

    !!! note
        `custom_property` instances belong to classes, not class instances. Thus changing the property,
        for example, by disabling caching, will do the same for each instance of the class where
        the property has been defined.&#34;&#34;&#34;

    def __new__(cls: tp.Type[custom_propertyT], *args, **flags) -&gt; tp.Union[tp.Callable, custom_propertyT]:
        if len(args) == 0:
            return lambda func: cls(func, **flags)
        elif len(args) == 1:
            return super().__new__(cls)
        raise ValueError(&#34;Either function or keyword arguments must be passed&#34;)

    def __init__(self, func: tp.Callable, **flags) -&gt; None:
        self.func = func
        self.name = func.__name__
        self.flags = flags
        self.__doc__ = getattr(func, &#39;__doc__&#39;)

    def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
        if instance is None:
            return self
        return self.func(instance)

    def __set__(self, instance: tp.Any, value: tp.Any) -&gt; None:
        raise AttributeError(&#34;can&#39;t set attribute&#34;)

    def __call__(self, *args, **kwargs) -&gt; tp.Any:
        pass


class CacheCondition(tp.NamedTuple):
    &#34;&#34;&#34;Caching condition for the use in `should_cache`.&#34;&#34;&#34;

    instance: tp.Optional[object] = None
    &#34;&#34;&#34;Class instance the method/property is bound to.&#34;&#34;&#34;

    func: tp.Optional[tp.Union[tp.Callable, &#34;cached_property&#34;, str]] = None
    &#34;&#34;&#34;Method/property or its name (case-sensitive).&#34;&#34;&#34;

    cls: tp.Optional[tp.Union[type, str]] = None
    &#34;&#34;&#34;Class of the instance or its name (case-sensitive).&#34;&#34;&#34;

    base_cls: tp.Optional[tp.Union[type, str]] = None
    &#34;&#34;&#34;Base class of the class or its name (case-sensitive).&#34;&#34;&#34;

    flags: tp.Optional[dict] = None
    &#34;&#34;&#34;Flags to check for in method/property&#39;s flags.&#34;&#34;&#34;

    rank: tp.Optional[int] = None
    &#34;&#34;&#34;Rank to override the default rank.&#34;&#34;&#34;


def should_cache(func_name: str, instance: tp.Any, func: tp.Optional[tp.Callable] = None, **flags) -&gt; bool:
    &#34;&#34;&#34;Check whether to cache the method/property based on a range of conditions defined under
    `caching` in `vectorbt._settings.settings`.

    Each condition has its own rank. A narrower condition has a lower (better) rank than a broader condition.
    All supplied keys are checked, and if any condition fails, it&#39;s assigned to the highest (worst) rank.

    Here&#39;s the condition ranking:

    0) `instance` and `func`
    1) `instance` and `flags`
    2) `instance`
    3) `cls` and `func`
    4) `cls` and `flags`
    5) `cls`
    6) `base_cls` and `func`
    7) `base_cls` and `flags`
    8) `base_cls`
    9) `func` and `flags`
    10) `func`
    11) `flags`
    
    This function goes through all conditions of type `CacheCondition` in `whitelist` and `blacklist`
    and finds the one with the lowest (best) rank. If the search yields the same rank for both lists,
    global caching flag `enabled` decides.

    ## Example

    Let&#39;s evaluate various caching conditions:

    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; class A:
    ...     @cached_property(my_flag=True)
    ...     def f(self):
    ...         return None

    &gt;&gt;&gt; class B(A):
    ...     @cached_property(my_flag=False)
    ...     def f(self):
    ...         return None

    &gt;&gt;&gt; a = A()
    &gt;&gt;&gt; b = B()

    &gt;&gt;&gt; vbt.CacheCondition(instance=a, func=&#39;f&#39;)  # A.f
    &gt;&gt;&gt; vbt.CacheCondition(instance=b, func=&#39;f&#39;)  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(instance=a, flags=dict(my_flag=True))  # A.f
    &gt;&gt;&gt; vbt.CacheCondition(instance=a, flags=dict(my_flag=False))  # none
    &gt;&gt;&gt; vbt.CacheCondition(instance=b, flags=dict(my_flag=False))  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(instance=a)  # A.f
    &gt;&gt;&gt; vbt.CacheCondition(instance=b)  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(cls=A)  # A.f
    &gt;&gt;&gt; vbt.CacheCondition(cls=B)  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(base_cls=A)  # A.f and B.f
    &gt;&gt;&gt; vbt.CacheCondition(base_cls=B)  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(base_cls=A, flags=dict(my_flag=False))  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(func=A.f)  # A.f
    &gt;&gt;&gt; vbt.CacheCondition(func=B.f)  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(func=&#39;f&#39;)  # A.f and B.f
    &gt;&gt;&gt; vbt.CacheCondition(func=&#39;f&#39;, flags=dict(my_flag=False))  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(flags=dict(my_flag=True))  # A.f
    ```
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    caching_cfg = settings[&#39;caching&#39;]

    start_rank = 100

    def _get_condition_rank(cond: CacheCondition) -&gt; int:
        # Perform initial checks
        checks.assert_type(cond, CacheCondition)

        if cond.instance is not None:
            if instance is not cond.instance:
                return start_rank
        if cond.func is not None:
            if isinstance(cond.func, cached_property):  # cached_property
                if func != cond.func.func:
                    return start_rank
            elif callable(cond.func) and hasattr(func, &#39;func&#39;) and hasattr(cond.func, &#39;func&#39;):  # cached_method
                if func.func != cond.func.func:
                    return start_rank
            elif isinstance(cond.func, str):
                if func_name != cond.func:
                    return start_rank
            else:
                raise TypeError(f&#34;Caching condition {cond}: func must be either a callable or a string&#34;)
        if cond.cls is not None:
            if inspect.isclass(cond.cls):
                if type(instance) != cond.cls:
                    return start_rank
            elif isinstance(cond.cls, str):
                if type(instance).__name__ != cond.cls:
                    return start_rank
            else:
                raise TypeError(f&#34;Caching condition {cond}: cls must be either a class or a string&#34;)
        if cond.base_cls is not None:
            if inspect.isclass(cond.base_cls) or isinstance(cond.base_cls, str):
                if not checks.is_instance_of(instance, cond.base_cls):
                    return start_rank
            else:
                raise TypeError(f&#34;Caching condition {cond}: base_cls must be either a class or a string&#34;)
        if cond.flags is not None:
            if not isinstance(cond.flags, dict):
                raise TypeError(f&#34;Caching condition {cond}: flags must be a dict&#34;)
            for k, v in cond.flags.items():
                if k not in flags or flags[k] != v:
                    return start_rank
        if cond.rank is not None:
            if not isinstance(cond.rank, int):
                raise TypeError(f&#34;Caching condition {cond}: rank must be an integer&#34;)
            ranks = [cond.rank for _ in range(12)]
        else:
            ranks = list(range(12))

        # Rank instance conditions
        if cond.instance is not None and cond.func is not None:
            return ranks[0]
        if cond.instance is not None and cond.flags is not None:
            return ranks[1]
        if cond.instance is not None:
            return ranks[2]

        # Rank class conditions
        if cond.cls is not None and cond.func is not None:
            return ranks[3]
        if cond.cls is not None and cond.flags is not None:
            return ranks[4]
        if cond.cls is not None:
            return ranks[5]

        # Rank base class conditions
        if cond.base_cls is not None and cond.func is not None:
            return ranks[6]
        if cond.base_cls is not None and cond.flags is not None:
            return ranks[7]
        if cond.base_cls is not None:
            return ranks[8]

        # Rank function conditions
        if cond.func is not None and cond.flags is not None:
            return ranks[9]
        if cond.func is not None:
            return ranks[10]
        if cond.flags is not None:
            return ranks[11]

        return start_rank

    white_rank = start_rank
    if len(caching_cfg[&#39;whitelist&#39;]) &gt; 0:
        for cond in caching_cfg[&#39;whitelist&#39;]:
            white_rank = min(white_rank, _get_condition_rank(cond))

    black_rank = start_rank
    if len(caching_cfg[&#39;blacklist&#39;]) &gt; 0:
        for cond in caching_cfg[&#39;blacklist&#39;]:
            black_rank = min(black_rank, _get_condition_rank(cond))

    if white_rank == black_rank:  # none of the conditions met
        return caching_cfg[&#39;enabled&#39;]  # global caching decides
    return white_rank &lt; black_rank


_NOT_FOUND = object()


class cached_property(custom_property):
    &#34;&#34;&#34;Extends `custom_property` with caching.

    Similar to `functools.cached_property`, but without replacing the original attribute
    to be able to re-compute whenever needed.

    Disables caching if `should_cache` yields False.

    Cache can be cleared by calling `clear_cache` with instance as argument.

    !!! note:
        Assumes that the instance (provided as `self`) won&#39;t change. If calculation depends
        upon object attributes that can be changed, it won&#39;t notice the change.&#34;&#34;&#34;

    def __init__(self, func: tp.Callable, **flags) -&gt; None:
        super().__init__(func, **flags)
        self.lock = RLock()

    def clear_cache(self, instance: tp.Any) -&gt; None:
        &#34;&#34;&#34;Clear the cache for this property belonging to `instance`.&#34;&#34;&#34;
        if hasattr(instance, self.attrname):
            delattr(instance, self.attrname)

    @property
    def attrname(self) -&gt; str:
        &#34;&#34;&#34;Get name of cached attribute.&#34;&#34;&#34;
        return &#39;__cached_&#39; + self.name

    def __set_name__(self, owner: tp.Type, name: str) -&gt; None:
        self.name = name

    def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
        if instance is None:
            return self
        if not should_cache(self.name, instance, func=self.func, **self.flags):
            return super().__get__(instance, owner=owner)
        cache = instance.__dict__
        val = cache.get(self.attrname, _NOT_FOUND)
        if val is _NOT_FOUND:
            with self.lock:
                # check if another thread filled cache while we awaited lock
                val = cache.get(self.attrname, _NOT_FOUND)
                if val is _NOT_FOUND:
                    val = self.func(instance)
                    cache[self.attrname] = val
        return val

    def __call__(self, *args, **kwargs) -&gt; tp.Any:
        ...


class custom_methodT(tp.Protocol):
    func: tp.Callable
    flags: tp.Dict

    def __call__(self, *args, **kwargs) -&gt; tp.Any:
        ...


def custom_method(*args, **flags) -&gt; tp.Union[tp.Callable, custom_methodT]:
    &#34;&#34;&#34;Custom extensible method that stores function and flags as attributes.

    Can be called both as
    ```python-repl
    &gt;&gt;&gt; @cached_method
    ... def user_function(): pass
    ```
    and
    ```python-repl
    &gt;&gt;&gt; @cached_method(maxsize=128, typed=False, a=0, b=0)  # flags
    ... def user_function(): pass
    ```
    &#34;&#34;&#34;

    def decorator(func: tp.Callable) -&gt; custom_methodT:
        @wraps(func)
        def wrapper(*args, **kwargs) -&gt; tp.Any:
            return func(*args, **kwargs)

        wrapper.func = func
        wrapper.flags = flags

        return wrapper

    if len(args) == 0:
        return decorator
    elif len(args) == 1:
        return decorator(args[0])
    raise ValueError(&#34;Either function or keyword arguments must be passed&#34;)


class cached_methodT(custom_methodT):
    maxsize: int
    typed: bool
    name: str
    attrname: str
    lock: RLock
    clear_cache: tp.Callable[[object], None]

    def __call__(self, *args, **kwargs) -&gt; tp.Any:
        ...


def cached_method(*args, maxsize: int = 128, typed: bool = False,
                  **flags) -&gt; tp.Union[tp.Callable, cached_methodT]:
    &#34;&#34;&#34;Extends `custom_method` with caching.

    Internally uses `functools.lru_cache`.

    Disables caching if `should_cache` yields False or a non-hashable object
    as argument has been passed.

    See notes on `cached_property`.&#34;&#34;&#34;

    def decorator(func: tp.Callable) -&gt; cached_methodT:
        @wraps(func)
        def wrapper(instance: tp.Any, *args, **kwargs) -&gt; tp.Any:
            def partial_func(*args, **kwargs) -&gt; tp.Any:
                # Ignores non-hashable instances
                return func(instance, *args, **kwargs)

            _func = None
            if hasattr(instance, wrapper.name):
                _func = getattr(instance, wrapper.name)
            if not should_cache(wrapper.name, instance, func=_func, **wrapper.flags):
                return func(instance, *args, **kwargs)
            cache = instance.__dict__
            cached_func = cache.get(wrapper.attrname, _NOT_FOUND)
            if cached_func is _NOT_FOUND:
                with wrapper.lock:
                    # check if another thread filled cache while we awaited lock
                    cached_func = cache.get(wrapper.attrname, _NOT_FOUND)
                    if cached_func is _NOT_FOUND:
                        cached_func = lru_cache(maxsize=wrapper.maxsize, typed=wrapper.typed)(partial_func)
                        cache[wrapper.attrname] = cached_func  # store function instead of output

            # Check if object can be hashed
            hashable = True
            for arg in args:
                if not checks.is_hashable(arg):
                    hashable = False
                    break
            for k, v in kwargs.items():
                if not checks.is_hashable(v):
                    hashable = False
                    break
            if not hashable:
                # If not, do not invoke lru_cache
                return func(instance, *args, **kwargs)
            return cached_func(*args, **kwargs)

        def clear_cache(instance):
            &#34;&#34;&#34;Clear the cache for this method belonging to `instance`.&#34;&#34;&#34;
            if hasattr(instance, wrapper.attrname):
                delattr(instance, wrapper.attrname)

        wrapper.func = func
        wrapper.flags = flags
        wrapper.maxsize = maxsize
        wrapper.typed = typed
        wrapper.name = func.__name__
        wrapper.attrname = &#39;__cached_&#39; + func.__name__
        wrapper.lock = RLock()
        wrapper.clear_cache = clear_cache

        return wrapper

    if len(args) == 0:
        return decorator
    elif len(args) == 1:
        return decorator(args[0])
    raise ValueError(&#34;Either function or keyword arguments must be passed&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.utils.decorators.cached_method"><code class="name flex">
<span>def <span class="ident">cached_method</span></span>(<span>*args, maxsize=128, typed=False, **flags)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code><a title="vectorbt.utils.decorators.custom_method" href="#vectorbt.utils.decorators.custom_method">custom_method()</a></code> with caching.</p>
<p>Internally uses <code>functools.lru_cache</code>.</p>
<p>Disables caching if <code><a title="vectorbt.utils.decorators.should_cache" href="#vectorbt.utils.decorators.should_cache">should_cache()</a></code> yields False or a non-hashable object
as argument has been passed.</p>
<p>See notes on <code><a title="vectorbt.utils.decorators.cached_property" href="#vectorbt.utils.decorators.cached_property">cached_property</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cached_method(*args, maxsize: int = 128, typed: bool = False,
                  **flags) -&gt; tp.Union[tp.Callable, cached_methodT]:
    &#34;&#34;&#34;Extends `custom_method` with caching.

    Internally uses `functools.lru_cache`.

    Disables caching if `should_cache` yields False or a non-hashable object
    as argument has been passed.

    See notes on `cached_property`.&#34;&#34;&#34;

    def decorator(func: tp.Callable) -&gt; cached_methodT:
        @wraps(func)
        def wrapper(instance: tp.Any, *args, **kwargs) -&gt; tp.Any:
            def partial_func(*args, **kwargs) -&gt; tp.Any:
                # Ignores non-hashable instances
                return func(instance, *args, **kwargs)

            _func = None
            if hasattr(instance, wrapper.name):
                _func = getattr(instance, wrapper.name)
            if not should_cache(wrapper.name, instance, func=_func, **wrapper.flags):
                return func(instance, *args, **kwargs)
            cache = instance.__dict__
            cached_func = cache.get(wrapper.attrname, _NOT_FOUND)
            if cached_func is _NOT_FOUND:
                with wrapper.lock:
                    # check if another thread filled cache while we awaited lock
                    cached_func = cache.get(wrapper.attrname, _NOT_FOUND)
                    if cached_func is _NOT_FOUND:
                        cached_func = lru_cache(maxsize=wrapper.maxsize, typed=wrapper.typed)(partial_func)
                        cache[wrapper.attrname] = cached_func  # store function instead of output

            # Check if object can be hashed
            hashable = True
            for arg in args:
                if not checks.is_hashable(arg):
                    hashable = False
                    break
            for k, v in kwargs.items():
                if not checks.is_hashable(v):
                    hashable = False
                    break
            if not hashable:
                # If not, do not invoke lru_cache
                return func(instance, *args, **kwargs)
            return cached_func(*args, **kwargs)

        def clear_cache(instance):
            &#34;&#34;&#34;Clear the cache for this method belonging to `instance`.&#34;&#34;&#34;
            if hasattr(instance, wrapper.attrname):
                delattr(instance, wrapper.attrname)

        wrapper.func = func
        wrapper.flags = flags
        wrapper.maxsize = maxsize
        wrapper.typed = typed
        wrapper.name = func.__name__
        wrapper.attrname = &#39;__cached_&#39; + func.__name__
        wrapper.lock = RLock()
        wrapper.clear_cache = clear_cache

        return wrapper

    if len(args) == 0:
        return decorator
    elif len(args) == 1:
        return decorator(args[0])
    raise ValueError(&#34;Either function or keyword arguments must be passed&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.decorators.custom_method"><code class="name flex">
<span>def <span class="ident">custom_method</span></span>(<span>*args, **flags)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom extensible method that stores function and flags as attributes.</p>
<p>Can be called both as</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @cached_method
... def user_function(): pass
</code></pre>
<p>and</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @cached_method(maxsize=128, typed=False, a=0, b=0)  # flags
... def user_function(): pass
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_method(*args, **flags) -&gt; tp.Union[tp.Callable, custom_methodT]:
    &#34;&#34;&#34;Custom extensible method that stores function and flags as attributes.

    Can be called both as
    ```python-repl
    &gt;&gt;&gt; @cached_method
    ... def user_function(): pass
    ```
    and
    ```python-repl
    &gt;&gt;&gt; @cached_method(maxsize=128, typed=False, a=0, b=0)  # flags
    ... def user_function(): pass
    ```
    &#34;&#34;&#34;

    def decorator(func: tp.Callable) -&gt; custom_methodT:
        @wraps(func)
        def wrapper(*args, **kwargs) -&gt; tp.Any:
            return func(*args, **kwargs)

        wrapper.func = func
        wrapper.flags = flags

        return wrapper

    if len(args) == 0:
        return decorator
    elif len(args) == 1:
        return decorator(args[0])
    raise ValueError(&#34;Either function or keyword arguments must be passed&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.decorators.should_cache"><code class="name flex">
<span>def <span class="ident">should_cache</span></span>(<span>func_name, instance, func=None, **flags)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether to cache the method/property based on a range of conditions defined under
<code>caching</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p>
<p>Each condition has its own rank. A narrower condition has a lower (better) rank than a broader condition.
All supplied keys are checked, and if any condition fails, it's assigned to the highest (worst) rank.</p>
<p>Here's the condition ranking:</p>
<p>0) <code>instance</code> and <code>func</code>
1) <code>instance</code> and <code>flags</code>
2) <code>instance</code>
3) <code>cls</code> and <code>func</code>
4) <code>cls</code> and <code>flags</code>
5) <code>cls</code>
6) <code>base_cls</code> and <code>func</code>
7) <code>base_cls</code> and <code>flags</code>
8) <code>base_cls</code>
9) <code>func</code> and <code>flags</code>
10) <code>func</code>
11) <code>flags</code></p>
<p>This function goes through all conditions of type <code><a title="vectorbt.utils.decorators.CacheCondition" href="#vectorbt.utils.decorators.CacheCondition">CacheCondition</a></code> in <code>whitelist</code> and <code>blacklist</code>
and finds the one with the lowest (best) rank. If the search yields the same rank for both lists,
global caching flag <code>enabled</code> decides.</p>
<h2 id="example">Example</h2>
<p>Let's evaluate various caching conditions:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; class A:
...     @cached_property(my_flag=True)
...     def f(self):
...         return None

&gt;&gt;&gt; class B(A):
...     @cached_property(my_flag=False)
...     def f(self):
...         return None

&gt;&gt;&gt; a = A()
&gt;&gt;&gt; b = B()

&gt;&gt;&gt; vbt.CacheCondition(instance=a, func='f')  # A.f
&gt;&gt;&gt; vbt.CacheCondition(instance=b, func='f')  # B.f
&gt;&gt;&gt; vbt.CacheCondition(instance=a, flags=dict(my_flag=True))  # A.f
&gt;&gt;&gt; vbt.CacheCondition(instance=a, flags=dict(my_flag=False))  # none
&gt;&gt;&gt; vbt.CacheCondition(instance=b, flags=dict(my_flag=False))  # B.f
&gt;&gt;&gt; vbt.CacheCondition(instance=a)  # A.f
&gt;&gt;&gt; vbt.CacheCondition(instance=b)  # B.f
&gt;&gt;&gt; vbt.CacheCondition(cls=A)  # A.f
&gt;&gt;&gt; vbt.CacheCondition(cls=B)  # B.f
&gt;&gt;&gt; vbt.CacheCondition(base_cls=A)  # A.f and B.f
&gt;&gt;&gt; vbt.CacheCondition(base_cls=B)  # B.f
&gt;&gt;&gt; vbt.CacheCondition(base_cls=A, flags=dict(my_flag=False))  # B.f
&gt;&gt;&gt; vbt.CacheCondition(func=A.f)  # A.f
&gt;&gt;&gt; vbt.CacheCondition(func=B.f)  # B.f
&gt;&gt;&gt; vbt.CacheCondition(func='f')  # A.f and B.f
&gt;&gt;&gt; vbt.CacheCondition(func='f', flags=dict(my_flag=False))  # B.f
&gt;&gt;&gt; vbt.CacheCondition(flags=dict(my_flag=True))  # A.f
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def should_cache(func_name: str, instance: tp.Any, func: tp.Optional[tp.Callable] = None, **flags) -&gt; bool:
    &#34;&#34;&#34;Check whether to cache the method/property based on a range of conditions defined under
    `caching` in `vectorbt._settings.settings`.

    Each condition has its own rank. A narrower condition has a lower (better) rank than a broader condition.
    All supplied keys are checked, and if any condition fails, it&#39;s assigned to the highest (worst) rank.

    Here&#39;s the condition ranking:

    0) `instance` and `func`
    1) `instance` and `flags`
    2) `instance`
    3) `cls` and `func`
    4) `cls` and `flags`
    5) `cls`
    6) `base_cls` and `func`
    7) `base_cls` and `flags`
    8) `base_cls`
    9) `func` and `flags`
    10) `func`
    11) `flags`
    
    This function goes through all conditions of type `CacheCondition` in `whitelist` and `blacklist`
    and finds the one with the lowest (best) rank. If the search yields the same rank for both lists,
    global caching flag `enabled` decides.

    ## Example

    Let&#39;s evaluate various caching conditions:

    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; class A:
    ...     @cached_property(my_flag=True)
    ...     def f(self):
    ...         return None

    &gt;&gt;&gt; class B(A):
    ...     @cached_property(my_flag=False)
    ...     def f(self):
    ...         return None

    &gt;&gt;&gt; a = A()
    &gt;&gt;&gt; b = B()

    &gt;&gt;&gt; vbt.CacheCondition(instance=a, func=&#39;f&#39;)  # A.f
    &gt;&gt;&gt; vbt.CacheCondition(instance=b, func=&#39;f&#39;)  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(instance=a, flags=dict(my_flag=True))  # A.f
    &gt;&gt;&gt; vbt.CacheCondition(instance=a, flags=dict(my_flag=False))  # none
    &gt;&gt;&gt; vbt.CacheCondition(instance=b, flags=dict(my_flag=False))  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(instance=a)  # A.f
    &gt;&gt;&gt; vbt.CacheCondition(instance=b)  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(cls=A)  # A.f
    &gt;&gt;&gt; vbt.CacheCondition(cls=B)  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(base_cls=A)  # A.f and B.f
    &gt;&gt;&gt; vbt.CacheCondition(base_cls=B)  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(base_cls=A, flags=dict(my_flag=False))  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(func=A.f)  # A.f
    &gt;&gt;&gt; vbt.CacheCondition(func=B.f)  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(func=&#39;f&#39;)  # A.f and B.f
    &gt;&gt;&gt; vbt.CacheCondition(func=&#39;f&#39;, flags=dict(my_flag=False))  # B.f
    &gt;&gt;&gt; vbt.CacheCondition(flags=dict(my_flag=True))  # A.f
    ```
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    caching_cfg = settings[&#39;caching&#39;]

    start_rank = 100

    def _get_condition_rank(cond: CacheCondition) -&gt; int:
        # Perform initial checks
        checks.assert_type(cond, CacheCondition)

        if cond.instance is not None:
            if instance is not cond.instance:
                return start_rank
        if cond.func is not None:
            if isinstance(cond.func, cached_property):  # cached_property
                if func != cond.func.func:
                    return start_rank
            elif callable(cond.func) and hasattr(func, &#39;func&#39;) and hasattr(cond.func, &#39;func&#39;):  # cached_method
                if func.func != cond.func.func:
                    return start_rank
            elif isinstance(cond.func, str):
                if func_name != cond.func:
                    return start_rank
            else:
                raise TypeError(f&#34;Caching condition {cond}: func must be either a callable or a string&#34;)
        if cond.cls is not None:
            if inspect.isclass(cond.cls):
                if type(instance) != cond.cls:
                    return start_rank
            elif isinstance(cond.cls, str):
                if type(instance).__name__ != cond.cls:
                    return start_rank
            else:
                raise TypeError(f&#34;Caching condition {cond}: cls must be either a class or a string&#34;)
        if cond.base_cls is not None:
            if inspect.isclass(cond.base_cls) or isinstance(cond.base_cls, str):
                if not checks.is_instance_of(instance, cond.base_cls):
                    return start_rank
            else:
                raise TypeError(f&#34;Caching condition {cond}: base_cls must be either a class or a string&#34;)
        if cond.flags is not None:
            if not isinstance(cond.flags, dict):
                raise TypeError(f&#34;Caching condition {cond}: flags must be a dict&#34;)
            for k, v in cond.flags.items():
                if k not in flags or flags[k] != v:
                    return start_rank
        if cond.rank is not None:
            if not isinstance(cond.rank, int):
                raise TypeError(f&#34;Caching condition {cond}: rank must be an integer&#34;)
            ranks = [cond.rank for _ in range(12)]
        else:
            ranks = list(range(12))

        # Rank instance conditions
        if cond.instance is not None and cond.func is not None:
            return ranks[0]
        if cond.instance is not None and cond.flags is not None:
            return ranks[1]
        if cond.instance is not None:
            return ranks[2]

        # Rank class conditions
        if cond.cls is not None and cond.func is not None:
            return ranks[3]
        if cond.cls is not None and cond.flags is not None:
            return ranks[4]
        if cond.cls is not None:
            return ranks[5]

        # Rank base class conditions
        if cond.base_cls is not None and cond.func is not None:
            return ranks[6]
        if cond.base_cls is not None and cond.flags is not None:
            return ranks[7]
        if cond.base_cls is not None:
            return ranks[8]

        # Rank function conditions
        if cond.func is not None and cond.flags is not None:
            return ranks[9]
        if cond.func is not None:
            return ranks[10]
        if cond.flags is not None:
            return ranks[11]

        return start_rank

    white_rank = start_rank
    if len(caching_cfg[&#39;whitelist&#39;]) &gt; 0:
        for cond in caching_cfg[&#39;whitelist&#39;]:
            white_rank = min(white_rank, _get_condition_rank(cond))

    black_rank = start_rank
    if len(caching_cfg[&#39;blacklist&#39;]) &gt; 0:
        for cond in caching_cfg[&#39;blacklist&#39;]:
            black_rank = min(black_rank, _get_condition_rank(cond))

    if white_rank == black_rank:  # none of the conditions met
        return caching_cfg[&#39;enabled&#39;]  # global caching decides
    return white_rank &lt; black_rank</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.utils.decorators.CacheCondition"><code class="flex name class">
<span>class <span class="ident">CacheCondition</span></span>
<span>(</span><span>instance=None, func=None, cls=None, base_cls=None, flags=None, rank=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Caching condition for the use in <code><a title="vectorbt.utils.decorators.should_cache" href="#vectorbt.utils.decorators.should_cache">should_cache()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CacheCondition(tp.NamedTuple):
    &#34;&#34;&#34;Caching condition for the use in `should_cache`.&#34;&#34;&#34;

    instance: tp.Optional[object] = None
    &#34;&#34;&#34;Class instance the method/property is bound to.&#34;&#34;&#34;

    func: tp.Optional[tp.Union[tp.Callable, &#34;cached_property&#34;, str]] = None
    &#34;&#34;&#34;Method/property or its name (case-sensitive).&#34;&#34;&#34;

    cls: tp.Optional[tp.Union[type, str]] = None
    &#34;&#34;&#34;Class of the instance or its name (case-sensitive).&#34;&#34;&#34;

    base_cls: tp.Optional[tp.Union[type, str]] = None
    &#34;&#34;&#34;Base class of the class or its name (case-sensitive).&#34;&#34;&#34;

    flags: tp.Optional[dict] = None
    &#34;&#34;&#34;Flags to check for in method/property&#39;s flags.&#34;&#34;&#34;

    rank: tp.Optional[int] = None
    &#34;&#34;&#34;Rank to override the default rank.&#34;&#34;&#34;</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.utils.decorators.CacheCondition.base_cls"><code class="name">var <span class="ident">base_cls</span></code></dt>
<dd>
<div class="desc"><p>Base class of the class or its name (case-sensitive).</p></div>
</dd>
<dt id="vectorbt.utils.decorators.CacheCondition.cls"><code class="name">var <span class="ident">cls</span></code></dt>
<dd>
<div class="desc"><p>Class of the instance or its name (case-sensitive).</p></div>
</dd>
<dt id="vectorbt.utils.decorators.CacheCondition.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"><p>Flags to check for in method/property's flags.</p></div>
</dd>
<dt id="vectorbt.utils.decorators.CacheCondition.func"><code class="name">var <span class="ident">func</span></code></dt>
<dd>
<div class="desc"><p>Method/property or its name (case-sensitive).</p></div>
</dd>
<dt id="vectorbt.utils.decorators.CacheCondition.instance"><code class="name">var <span class="ident">instance</span></code></dt>
<dd>
<div class="desc"><p>Class instance the method/property is bound to.</p></div>
</dd>
<dt id="vectorbt.utils.decorators.CacheCondition.rank"><code class="name">var <span class="ident">rank</span></code></dt>
<dd>
<div class="desc"><p>Rank to override the default rank.</p></div>
</dd>
</dl>
</dd>
<dt id="vectorbt.utils.decorators.cached_methodT"><code class="flex name class">
<span>class <span class="ident">cached_methodT</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes. Protocol classes are defined as::</p>
<p>class Proto(Protocol):
def meth(self) -&gt; int:
&hellip;</p>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<p>class C:
def meth(self) -&gt; int:
return 0</p>
<p>def func(x: Proto) -&gt; int:
return x.meth()</p>
<p>func(C())
# Passes static type check</p>
<p>See PEP 544 for details. Protocol classes decorated with
@typing_extensions.runtime act as simple-minded runtime protocol that checks
only the presence of given attributes, ignoring their type signatures.</p>
<p>Protocol classes can be generic, they are defined as::</p>
<p>class GenProto(Protocol[T]):
def meth(self) -&gt; T:
&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class cached_methodT(custom_methodT):
    maxsize: int
    typed: bool
    name: str
    attrname: str
    lock: RLock
    clear_cache: tp.Callable[[object], None]

    def __call__(self, *args, **kwargs) -&gt; tp.Any:
        ...</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.decorators.custom_methodT" href="#vectorbt.utils.decorators.custom_methodT">custom_methodT</a></li>
<li>typing_extensions.Protocol</li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.utils.decorators.cached_methodT.attrname"><code class="name">var <span class="ident">attrname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.utils.decorators.cached_methodT.clear_cache"><code class="name">var <span class="ident">clear_cache</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.utils.decorators.cached_methodT.lock"><code class="name">var <span class="ident">lock</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.utils.decorators.cached_methodT.maxsize"><code class="name">var <span class="ident">maxsize</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.utils.decorators.cached_methodT.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.utils.decorators.cached_methodT.typed"><code class="name">var <span class="ident">typed</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="vectorbt.utils.decorators.cached_property"><code class="flex name class">
<span>class <span class="ident">cached_property</span></span>
<span>(</span><span>func, **flags)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code><a title="vectorbt.utils.decorators.custom_property" href="#vectorbt.utils.decorators.custom_property">custom_property</a></code> with caching.</p>
<p>Similar to <code>functools.cached_property</code>, but without replacing the original attribute
to be able to re-compute whenever needed.</p>
<p>Disables caching if <code><a title="vectorbt.utils.decorators.should_cache" href="#vectorbt.utils.decorators.should_cache">should_cache()</a></code> yields False.</p>
<p>Cache can be cleared by calling <code>clear_cache</code> with instance as argument.</p>
<p>!!! note:
Assumes that the instance (provided as <code>self</code>) won't change. If calculation depends
upon object attributes that can be changed, it won't notice the change.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class cached_property(custom_property):
    &#34;&#34;&#34;Extends `custom_property` with caching.

    Similar to `functools.cached_property`, but without replacing the original attribute
    to be able to re-compute whenever needed.

    Disables caching if `should_cache` yields False.

    Cache can be cleared by calling `clear_cache` with instance as argument.

    !!! note:
        Assumes that the instance (provided as `self`) won&#39;t change. If calculation depends
        upon object attributes that can be changed, it won&#39;t notice the change.&#34;&#34;&#34;

    def __init__(self, func: tp.Callable, **flags) -&gt; None:
        super().__init__(func, **flags)
        self.lock = RLock()

    def clear_cache(self, instance: tp.Any) -&gt; None:
        &#34;&#34;&#34;Clear the cache for this property belonging to `instance`.&#34;&#34;&#34;
        if hasattr(instance, self.attrname):
            delattr(instance, self.attrname)

    @property
    def attrname(self) -&gt; str:
        &#34;&#34;&#34;Get name of cached attribute.&#34;&#34;&#34;
        return &#39;__cached_&#39; + self.name

    def __set_name__(self, owner: tp.Type, name: str) -&gt; None:
        self.name = name

    def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
        if instance is None:
            return self
        if not should_cache(self.name, instance, func=self.func, **self.flags):
            return super().__get__(instance, owner=owner)
        cache = instance.__dict__
        val = cache.get(self.attrname, _NOT_FOUND)
        if val is _NOT_FOUND:
            with self.lock:
                # check if another thread filled cache while we awaited lock
                val = cache.get(self.attrname, _NOT_FOUND)
                if val is _NOT_FOUND:
                    val = self.func(instance)
                    cache[self.attrname] = val
        return val

    def __call__(self, *args, **kwargs) -&gt; tp.Any:
        ...</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.decorators.custom_property" href="#vectorbt.utils.decorators.custom_property">custom_property</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.utils.decorators.cached_property.attrname"><code class="name">var <span class="ident">attrname</span></code></dt>
<dd>
<div class="desc"><p>Get name of cached attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def attrname(self) -&gt; str:
    &#34;&#34;&#34;Get name of cached attribute.&#34;&#34;&#34;
    return &#39;__cached_&#39; + self.name</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.utils.decorators.cached_property.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self, instance)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear the cache for this property belonging to <code>instance</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self, instance: tp.Any) -&gt; None:
    &#34;&#34;&#34;Clear the cache for this property belonging to `instance`.&#34;&#34;&#34;
    if hasattr(instance, self.attrname):
        delattr(instance, self.attrname)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.utils.decorators.class_or_instancemethod"><code class="flex name class">
<span>class <span class="ident">class_or_instancemethod</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function decorator that binds <code>self</code> to a class if the function is called as class method,
otherwise to an instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class class_or_instancemethod(classmethod):
    &#34;&#34;&#34;Function decorator that binds `self` to a class if the function is called as class method,
    otherwise to an instance.&#34;&#34;&#34;

    def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
        descr_get = super().__get__ if instance is None else self.__func__.__get__
        return descr_get(instance, owner)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>builtins.classmethod</li>
</ul>
</dd>
<dt id="vectorbt.utils.decorators.classproperty"><code class="flex name class">
<span>class <span class="ident">classproperty</span></span>
<span>(</span><span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Property that can be called on a class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class classproperty(object):
    &#34;&#34;&#34;Property that can be called on a class.&#34;&#34;&#34;

    def __init__(self, func: tp.Callable) -&gt; None:
        self.func = func
        self.__doc__ = getattr(func, &#39;__doc__&#39;)

    def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
        return self.func(owner)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.decorators.custom_methodT"><code class="flex name class">
<span>class <span class="ident">custom_methodT</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes. Protocol classes are defined as::</p>
<p>class Proto(Protocol):
def meth(self) -&gt; int:
&hellip;</p>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<p>class C:
def meth(self) -&gt; int:
return 0</p>
<p>def func(x: Proto) -&gt; int:
return x.meth()</p>
<p>func(C())
# Passes static type check</p>
<p>See PEP 544 for details. Protocol classes decorated with
@typing_extensions.runtime act as simple-minded runtime protocol that checks
only the presence of given attributes, ignoring their type signatures.</p>
<p>Protocol classes can be generic, they are defined as::</p>
<p>class GenProto(Protocol[T]):
def meth(self) -&gt; T:
&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class custom_methodT(tp.Protocol):
    func: tp.Callable
    flags: tp.Dict

    def __call__(self, *args, **kwargs) -&gt; tp.Any:
        ...</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>typing_extensions.Protocol</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.decorators.cached_methodT" href="#vectorbt.utils.decorators.cached_methodT">cached_methodT</a></li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.utils.decorators.custom_methodT.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.utils.decorators.custom_methodT.func"><code class="name">var <span class="ident">func</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="vectorbt.utils.decorators.custom_property"><code class="flex name class">
<span>class <span class="ident">custom_property</span></span>
<span>(</span><span>func, **flags)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom property that stores function and flags as attributes.</p>
<p>Can be called both as</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @custom_property
... def user_function(self): pass
</code></pre>
<p>and</p>
<pre><code class="language-plaintext">&gt;&gt;&gt; @custom_property(a=0, b=0)  # flags
... def user_function(self): pass
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code><a title="vectorbt.utils.decorators.custom_property" href="#vectorbt.utils.decorators.custom_property">custom_property</a></code> instances belong to classes, not class instances. Thus changing the property,
for example, by disabling caching, will do the same for each instance of the class where
the property has been defined.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class custom_property:
    &#34;&#34;&#34;Custom property that stores function and flags as attributes.

    Can be called both as
    ```python-repl
    &gt;&gt;&gt; @custom_property
    ... def user_function(self): pass
    ```
    and
    ```plaintext
    &gt;&gt;&gt; @custom_property(a=0, b=0)  # flags
    ... def user_function(self): pass
    ```

    !!! note
        `custom_property` instances belong to classes, not class instances. Thus changing the property,
        for example, by disabling caching, will do the same for each instance of the class where
        the property has been defined.&#34;&#34;&#34;

    def __new__(cls: tp.Type[custom_propertyT], *args, **flags) -&gt; tp.Union[tp.Callable, custom_propertyT]:
        if len(args) == 0:
            return lambda func: cls(func, **flags)
        elif len(args) == 1:
            return super().__new__(cls)
        raise ValueError(&#34;Either function or keyword arguments must be passed&#34;)

    def __init__(self, func: tp.Callable, **flags) -&gt; None:
        self.func = func
        self.name = func.__name__
        self.flags = flags
        self.__doc__ = getattr(func, &#39;__doc__&#39;)

    def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
        if instance is None:
            return self
        return self.func(instance)

    def __set__(self, instance: tp.Any, value: tp.Any) -&gt; None:
        raise AttributeError(&#34;can&#39;t set attribute&#34;)

    def __call__(self, *args, **kwargs) -&gt; tp.Any:
        pass</code></pre>
</details>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.decorators.cached_property" href="#vectorbt.utils.decorators.cached_property">cached_property</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRUYwMDAwO30KCS5zdDF7ZmlsbDojRkY5MDAwO30KCS5zdDJ7ZmlsbDojRkZERjAwO30KCS5zdDN7ZmlsbDojMjgyQzM0O30KPC9zdHlsZT4KPGc+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNTUuMywzMDAuMSAyODMuMSwwIDIwOCwwIDExMC44LDAgMzUuOCwwIDEuMiw0NTAuMiA3Ni4zLDQ1MC4yIAkJCSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjIzMC40LDMwMC4xIDM1OC4xLDAgMjgzLjEsMCAxODUuOCwwIDExMC44LDAgNzYuMyw0NTAuMiAxNTEuMyw0NTAuMiAJCQkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIzMDUuNCwzMDAuMSA0MzMuMSwwIDM1OC4xLDAgMzMxLjYsNjIuMyAyNjAuOCwwIDE4NS44LDAgMTUxLjMsNDUwLjIgMjI2LjQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iNTEwLjgsMCA0MzMuMSwwIDMwNS40LDMwMC4xIDMzOC40LDAgMjYwLjgsMCAyMjYuNCw0NTAuMiAzMDQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="/>
vectorbt <span class="version">0.19.2</span></a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.utils" href="index.html">vectorbt.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.utils.decorators.cached_method" href="#vectorbt.utils.decorators.cached_method">cached_method</a></code></li>
<li><code><a title="vectorbt.utils.decorators.custom_method" href="#vectorbt.utils.decorators.custom_method">custom_method</a></code></li>
<li><code><a title="vectorbt.utils.decorators.should_cache" href="#vectorbt.utils.decorators.should_cache">should_cache</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.utils.decorators.CacheCondition" href="#vectorbt.utils.decorators.CacheCondition">CacheCondition</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.utils.decorators.CacheCondition.base_cls" href="#vectorbt.utils.decorators.CacheCondition.base_cls">base_cls</a></code></li>
<li><code><a title="vectorbt.utils.decorators.CacheCondition.cls" href="#vectorbt.utils.decorators.CacheCondition.cls">cls</a></code></li>
<li><code><a title="vectorbt.utils.decorators.CacheCondition.flags" href="#vectorbt.utils.decorators.CacheCondition.flags">flags</a></code></li>
<li><code><a title="vectorbt.utils.decorators.CacheCondition.func" href="#vectorbt.utils.decorators.CacheCondition.func">func</a></code></li>
<li><code><a title="vectorbt.utils.decorators.CacheCondition.instance" href="#vectorbt.utils.decorators.CacheCondition.instance">instance</a></code></li>
<li><code><a title="vectorbt.utils.decorators.CacheCondition.rank" href="#vectorbt.utils.decorators.CacheCondition.rank">rank</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.decorators.cached_methodT" href="#vectorbt.utils.decorators.cached_methodT">cached_methodT</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.utils.decorators.cached_methodT.attrname" href="#vectorbt.utils.decorators.cached_methodT.attrname">attrname</a></code></li>
<li><code><a title="vectorbt.utils.decorators.cached_methodT.clear_cache" href="#vectorbt.utils.decorators.cached_methodT.clear_cache">clear_cache</a></code></li>
<li><code><a title="vectorbt.utils.decorators.cached_methodT.lock" href="#vectorbt.utils.decorators.cached_methodT.lock">lock</a></code></li>
<li><code><a title="vectorbt.utils.decorators.cached_methodT.maxsize" href="#vectorbt.utils.decorators.cached_methodT.maxsize">maxsize</a></code></li>
<li><code><a title="vectorbt.utils.decorators.cached_methodT.name" href="#vectorbt.utils.decorators.cached_methodT.name">name</a></code></li>
<li><code><a title="vectorbt.utils.decorators.cached_methodT.typed" href="#vectorbt.utils.decorators.cached_methodT.typed">typed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.decorators.cached_property" href="#vectorbt.utils.decorators.cached_property">cached_property</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.decorators.cached_property.attrname" href="#vectorbt.utils.decorators.cached_property.attrname">attrname</a></code></li>
<li><code><a title="vectorbt.utils.decorators.cached_property.clear_cache" href="#vectorbt.utils.decorators.cached_property.clear_cache">clear_cache</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.decorators.class_or_instancemethod" href="#vectorbt.utils.decorators.class_or_instancemethod">class_or_instancemethod</a></code></h4>
</li>
<li>
<h4><code><a title="vectorbt.utils.decorators.classproperty" href="#vectorbt.utils.decorators.classproperty">classproperty</a></code></h4>
</li>
<li>
<h4><code><a title="vectorbt.utils.decorators.custom_methodT" href="#vectorbt.utils.decorators.custom_methodT">custom_methodT</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.decorators.custom_methodT.flags" href="#vectorbt.utils.decorators.custom_methodT.flags">flags</a></code></li>
<li><code><a title="vectorbt.utils.decorators.custom_methodT.func" href="#vectorbt.utils.decorators.custom_methodT.func">func</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.decorators.custom_property" href="#vectorbt.utils.decorators.custom_property">custom_property</a></code></h4>
</li>
</ul>
</li>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>