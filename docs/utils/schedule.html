<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.utils.schedule API documentation</title>
<meta name="description" content="Utilities for scheduling jobs." />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3B4556}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="mask-icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.utils.schedule</code></h1>
</header>
<section id="section-intro">
<p>Utilities for scheduling jobs.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Utilities for scheduling jobs.&#34;&#34;&#34;

from datetime import datetime, timedelta, time as dt_time
import time
from schedule import Scheduler, Job, CancelJob
import asyncio
import logging
import inspect

from vectorbt.utils.datetime import tzaware_to_naive_time

logger = logging.getLogger(__name__)


class CancelledError(asyncio.CancelledError):
    &#34;&#34;&#34;Thrown for the operation to be cancelled.&#34;&#34;&#34;
    pass


class AsyncJob(Job):
    async def async_run(self):
        &#34;&#34;&#34;Async `Job.run`.&#34;&#34;&#34;
        logger.info(&#39;Running job %s&#39;, self)
        ret = self.job_func()
        if inspect.isawaitable(ret):
            ret = await ret
        self.last_run = datetime.now()
        self._schedule_next_run()
        return ret


class AsyncScheduler(Scheduler):
    async def async_run_pending(self):
        &#34;&#34;&#34;Async `Scheduler.run_pending`.&#34;&#34;&#34;
        runnable_jobs = (job for job in self.jobs if job.should_run)
        await asyncio.gather(*[self._async_run_job(job) for job in runnable_jobs])

    async def async_run_all(self, delay_seconds=0):
        &#34;&#34;&#34;Async `Scheduler.run_all`.&#34;&#34;&#34;
        logger.info(&#39;Running *all* %i jobs with %is delay in-between&#39;,
                    len(self.jobs), delay_seconds)
        for job in self.jobs[:]:
            await self._async_run_job(job)
            await asyncio.sleep(delay_seconds)

    async def _async_run_job(self, job):
        &#34;&#34;&#34;Async `Scheduler.run_job`.&#34;&#34;&#34;
        ret = await job.async_run()
        if isinstance(ret, CancelJob) or ret is CancelJob:
            self.cancel_job(job)

    def every(self, interval=1):
        &#34;&#34;&#34;Schedule a new periodic job of type `AsyncJob`.&#34;&#34;&#34;
        job = AsyncJob(interval, self)
        return job


class ScheduleManager:
    &#34;&#34;&#34;Class that manages `schedule.Scheduler`.&#34;&#34;&#34;

    units = (
        &#34;second&#34;,
        &#34;seconds&#34;,
        &#34;minute&#34;,
        &#34;minutes&#34;,
        &#34;hour&#34;,
        &#34;hours&#34;,
        &#34;day&#34;,
        &#34;days&#34;,
        &#34;week&#34;,
        &#34;weeks&#34;
    )

    weekdays = (
        &#34;monday&#34;,
        &#34;tuesday&#34;,
        &#34;wednesday&#34;,
        &#34;thursday&#34;,
        &#34;friday&#34;,
        &#34;saturday&#34;,
        &#34;sunday&#34;,
    )

    def __init__(self, scheduler=None):
        if scheduler is None:
            scheduler = AsyncScheduler()
        self._scheduler = scheduler
        self._async_task = None

    @property
    def scheduler(self):
        &#34;&#34;&#34;Scheduler.&#34;&#34;&#34;
        return self._scheduler

    @property
    def async_task(self):
        &#34;&#34;&#34;Current async task.&#34;&#34;&#34;
        return self._async_task

    def every(self, *args, to=None, until=None, tags=None):
        &#34;&#34;&#34;Create a new job that runs every `interval` units of time.

        `*args` can include at most four different arguments: `interval`, `unit`, `start_day`, and `at`,
        in the strict order:

        * `interval`: integer or `datetime.timedelta`
        * `unit`: `ScheduleManager.units`
        * `start_day`: `ScheduleManager.weekdays`
        * `at`: string or `datetime.time`.

        See the package `schedule` for more details.

        ## Example

        ```python-repl
        &gt;&gt;&gt; import datetime
        &gt;&gt;&gt; import pytz
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; def job_func(message=&#34;I&#39;m working...&#34;):
        ...     print(message)

        &gt;&gt;&gt; my_manager = vbt.ScheduleManager()

        &gt;&gt;&gt; # add jobs
        &gt;&gt;&gt; my_manager.every().do(job_func, message=&#34;Hello&#34;)
        Every 1 second do job_func(message=&#39;Hello&#39;) (last run: [never], next run: 2021-03-18 19:06:47)

        &gt;&gt;&gt; my_manager.every(10, &#39;minutes&#39;).do(job_func)
        Every 10 minutes do job_func() (last run: [never], next run: 2021-03-18 19:16:46)

        &gt;&gt;&gt; my_manager.every(&#39;hour&#39;).do(job_func)
        Every 1 hour do job_func() (last run: [never], next run: 2021-03-18 20:06:46)

        &gt;&gt;&gt; my_manager.every(&#39;10:30&#39;).do(job_func)
        Every 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)

        &gt;&gt;&gt; my_manager.every(&#39;day&#39;, &#39;10:30&#39;).do(job_func)
        Every 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)

        &gt;&gt;&gt; my_manager.every(&#39;day&#39;, datetime.time(9, 30, tzinfo=pytz.utc)).do(job_func)
        Every 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)

        &gt;&gt;&gt; my_manager.every(&#39;monday&#39;).do(job_func)
        Every 1 week do job_func() (last run: [never], next run: 2021-03-22 19:06:46)

        &gt;&gt;&gt; my_manager.every(&#39;wednesday&#39;, &#39;13:15&#39;).do(job_func)
        Every 1 week at 13:15:00 do job_func() (last run: [never], next run: 2021-03-24 13:15:00)

        &gt;&gt;&gt; my_manager.every(&#39;minute&#39;, &#39;:17&#39;).do(job_func)
        Every 1 minute at 00:00:17 do job_func() (last run: [never], next run: 2021-03-18 19:07:17)

        &gt;&gt;&gt; my_manager.start()
        ```

        You can still use the chained approach as done by `schedule`:

        ```python-repl
        &gt;&gt;&gt; my_manager.every().minute.at(&#39;:17&#39;).do(job_func)
        Every 1 minute at 00:00:17 do job_func() (last run: [never], next run: 2021-03-18 19:07:17)
        ```
        &#34;&#34;&#34;
        # Parse arguments
        interval = 1
        unit = None
        start_day = None
        at = None

        def _is_arg_interval(arg):
            return isinstance(arg, (int, timedelta))

        def _is_arg_unit(arg):
            return isinstance(arg, str) and arg in self.units

        def _is_arg_start_day(arg):
            return isinstance(arg, str) and arg in self.weekdays

        def _is_arg_at(arg):
            return (isinstance(arg, str) and &#39;:&#39; in arg) or isinstance(arg, dt_time)

        expected_args = [&#39;interval&#39;, &#39;unit&#39;, &#39;start_day&#39;, &#39;at&#39;]
        for i, arg in enumerate(args):
            if &#39;interval&#39; in expected_args and _is_arg_interval(arg):
                interval = arg
                expected_args = expected_args[expected_args.index(&#39;interval&#39;) + 1:]
                continue
            if &#39;unit&#39; in expected_args and _is_arg_unit(arg):
                unit = arg
                expected_args = expected_args[expected_args.index(&#39;unit&#39;) + 1:]
                continue
            if &#39;start_day&#39; in expected_args and _is_arg_start_day(arg):
                start_day = arg
                expected_args = expected_args[expected_args.index(&#39;start_day&#39;) + 1:]
                continue
            if &#39;at&#39; in expected_args and _is_arg_at(arg):
                at = arg
                expected_args = expected_args[expected_args.index(&#39;at&#39;) + 1:]
                continue
            raise ValueError(f&#34;Arg at index {i} is unexpected&#34;)

        if at is not None:
            if unit is None and start_day is None:
                unit = &#39;days&#39;
        if unit is None and start_day is None:
            unit = &#39;seconds&#39;

        job = self.scheduler.every(interval)
        if unit is not None:
            job = getattr(job, unit)
        if start_day is not None:
            job = getattr(job, start_day)
        if at is not None:
            if isinstance(at, dt_time):
                if job.unit == &#34;days&#34; or job.start_day:
                    if at.tzinfo is not None:
                        at = tzaware_to_naive_time(at, None)
                at = at.isoformat()
                if job.unit == &#34;hours&#34;:
                    at = &#39;:&#39;.join(at.split(&#39;:&#39;)[1:])
                if job.unit == &#34;minutes&#34;:
                    at = &#39;:&#39; + at.split(&#39;:&#39;)[2]
            job = job.at(at)
        if to is not None:
            job = job.to(to)
        if until is not None:
            job = job.until(until)
        if tags is not None:
            if not isinstance(tags, tuple):
                tags = (tags,)
            job = job.tag(*tags)

        return job

    def start(self, sleep=1):
        &#34;&#34;&#34;Run pending jobs in a loop.&#34;&#34;&#34;
        logger.info(&#34;Starting schedule manager with jobs %s&#34;, str(self.scheduler.jobs))
        try:
            while True:
                self.scheduler.run_pending()
                time.sleep(sleep)
        except (KeyboardInterrupt, asyncio.CancelledError):
            logger.info(&#34;Stopping schedule manager&#34;)

    async def async_start(self, sleep=1):
        &#34;&#34;&#34;Async run pending jobs in a loop.&#34;&#34;&#34;
        logger.info(&#34;Starting schedule manager in the background with jobs %s&#34;, str(self.scheduler.jobs))
        logger.info(&#34;Jobs: %s&#34;, str(self.scheduler.jobs))
        try:
            while True:
                await self.scheduler.async_run_pending()
                await asyncio.sleep(sleep)
        except asyncio.CancelledError:
            logger.info(&#34;Stopping schedule manager&#34;)

    def done_callback(self, async_task):
        &#34;&#34;&#34;Callback run when the async task is finished.&#34;&#34;&#34;
        logger.info(async_task)

    def start_in_background(self, **kwargs):
        &#34;&#34;&#34;Run `ScheduleManager.async_start` in the background.&#34;&#34;&#34;
        async_task = asyncio.create_task(self.async_start(**kwargs))
        async_task.add_done_callback(self.done_callback)
        logger.info(async_task)
        self._async_task = async_task

    @property
    def async_task_running(self):
        &#34;&#34;&#34;Whether the async task is running.&#34;&#34;&#34;
        return self.async_task is not None and not self.async_task.done()

    def stop(self):
        &#34;&#34;&#34;Stop the async task.&#34;&#34;&#34;
        if self.async_task_running:
            self.async_task.cancel()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.utils.schedule.AsyncJob"><code class="flex name class">
<span>class <span class="ident parent-fname">AsyncJob</span></span>
<span>(</span><span>interval, scheduler=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A periodic job as used by :class:<code>Scheduler</code>.</p>
<p>:param interval: A quantity of a certain time unit
:param scheduler: The :class:<code>Scheduler &lt;Scheduler&gt;</code> instance that
this job will register itself with once it has
been fully configured in :meth:<code>Job.do()</code>.</p>
<p>Every job runs at a given fixed time interval that is defined by:</p>
<ul>
<li>a :meth:<code>time unit &lt;Job.second&gt;</code></li>
<li>a quantity of <code>time units</code> defined by <code>interval</code></li>
</ul>
<p>A job is usually created and returned by :meth:<code>Scheduler.every</code>
method, which also defines its <code>interval</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncJob(Job):
    async def async_run(self):
        &#34;&#34;&#34;Async `Job.run`.&#34;&#34;&#34;
        logger.info(&#39;Running job %s&#39;, self)
        ret = self.job_func()
        if inspect.isawaitable(ret):
            ret = await ret
        self.last_run = datetime.now()
        self._schedule_next_run()
        return ret</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>schedule.Job</li>
</ul>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.utils.schedule.AsyncJob.async_run"><code class="name flex">
<span>async def <span class="ident fname">async_run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Async <code>Job.run</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def async_run(self):
    &#34;&#34;&#34;Async `Job.run`.&#34;&#34;&#34;
    logger.info(&#39;Running job %s&#39;, self)
    ret = self.job_func()
    if inspect.isawaitable(ret):
        ret = await ret
    self.last_run = datetime.now()
    self._schedule_next_run()
    return ret</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.utils.schedule.AsyncScheduler"><code class="flex name class">
<span>class <span class="ident parent-fname">AsyncScheduler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Objects instantiated by the :class:<code>Scheduler &lt;Scheduler&gt;</code> are
factories to create jobs, keep record of scheduled jobs and
handle their execution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncScheduler(Scheduler):
    async def async_run_pending(self):
        &#34;&#34;&#34;Async `Scheduler.run_pending`.&#34;&#34;&#34;
        runnable_jobs = (job for job in self.jobs if job.should_run)
        await asyncio.gather(*[self._async_run_job(job) for job in runnable_jobs])

    async def async_run_all(self, delay_seconds=0):
        &#34;&#34;&#34;Async `Scheduler.run_all`.&#34;&#34;&#34;
        logger.info(&#39;Running *all* %i jobs with %is delay in-between&#39;,
                    len(self.jobs), delay_seconds)
        for job in self.jobs[:]:
            await self._async_run_job(job)
            await asyncio.sleep(delay_seconds)

    async def _async_run_job(self, job):
        &#34;&#34;&#34;Async `Scheduler.run_job`.&#34;&#34;&#34;
        ret = await job.async_run()
        if isinstance(ret, CancelJob) or ret is CancelJob:
            self.cancel_job(job)

    def every(self, interval=1):
        &#34;&#34;&#34;Schedule a new periodic job of type `AsyncJob`.&#34;&#34;&#34;
        job = AsyncJob(interval, self)
        return job</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>schedule.Scheduler</li>
</ul>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.utils.schedule.AsyncScheduler.async_run_all"><code class="name flex">
<span>async def <span class="ident fname">async_run_all</span></span>(<span>self, delay_seconds=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Async <code>Scheduler.run_all</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def async_run_all(self, delay_seconds=0):
    &#34;&#34;&#34;Async `Scheduler.run_all`.&#34;&#34;&#34;
    logger.info(&#39;Running *all* %i jobs with %is delay in-between&#39;,
                len(self.jobs), delay_seconds)
    for job in self.jobs[:]:
        await self._async_run_job(job)
        await asyncio.sleep(delay_seconds)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.schedule.AsyncScheduler.async_run_pending"><code class="name flex">
<span>async def <span class="ident fname">async_run_pending</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Async <code>Scheduler.run_pending</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def async_run_pending(self):
    &#34;&#34;&#34;Async `Scheduler.run_pending`.&#34;&#34;&#34;
    runnable_jobs = (job for job in self.jobs if job.should_run)
    await asyncio.gather(*[self._async_run_job(job) for job in runnable_jobs])</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.schedule.AsyncScheduler.every"><code class="name flex">
<span>def <span class="ident fname">every</span></span>(<span>self, interval=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Schedule a new periodic job of type <code><a title="vectorbt.utils.schedule.AsyncJob" href="#vectorbt.utils.schedule.AsyncJob">AsyncJob</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def every(self, interval=1):
    &#34;&#34;&#34;Schedule a new periodic job of type `AsyncJob`.&#34;&#34;&#34;
    job = AsyncJob(interval, self)
    return job</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.utils.schedule.CancelledError"><code class="flex name class">
<span>class <span class="ident parent-fname">CancelledError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Thrown for the operation to be cancelled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CancelledError(asyncio.CancelledError):
    &#34;&#34;&#34;Thrown for the operation to be cancelled.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>concurrent.futures._base.CancelledError</li>
<li>concurrent.futures._base.Error</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="vectorbt.utils.schedule.ScheduleManager"><code class="flex name class">
<span>class <span class="ident parent-fname">ScheduleManager</span></span>
<span>(</span><span>scheduler=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that manages <code>schedule.Scheduler</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScheduleManager:
    &#34;&#34;&#34;Class that manages `schedule.Scheduler`.&#34;&#34;&#34;

    units = (
        &#34;second&#34;,
        &#34;seconds&#34;,
        &#34;minute&#34;,
        &#34;minutes&#34;,
        &#34;hour&#34;,
        &#34;hours&#34;,
        &#34;day&#34;,
        &#34;days&#34;,
        &#34;week&#34;,
        &#34;weeks&#34;
    )

    weekdays = (
        &#34;monday&#34;,
        &#34;tuesday&#34;,
        &#34;wednesday&#34;,
        &#34;thursday&#34;,
        &#34;friday&#34;,
        &#34;saturday&#34;,
        &#34;sunday&#34;,
    )

    def __init__(self, scheduler=None):
        if scheduler is None:
            scheduler = AsyncScheduler()
        self._scheduler = scheduler
        self._async_task = None

    @property
    def scheduler(self):
        &#34;&#34;&#34;Scheduler.&#34;&#34;&#34;
        return self._scheduler

    @property
    def async_task(self):
        &#34;&#34;&#34;Current async task.&#34;&#34;&#34;
        return self._async_task

    def every(self, *args, to=None, until=None, tags=None):
        &#34;&#34;&#34;Create a new job that runs every `interval` units of time.

        `*args` can include at most four different arguments: `interval`, `unit`, `start_day`, and `at`,
        in the strict order:

        * `interval`: integer or `datetime.timedelta`
        * `unit`: `ScheduleManager.units`
        * `start_day`: `ScheduleManager.weekdays`
        * `at`: string or `datetime.time`.

        See the package `schedule` for more details.

        ## Example

        ```python-repl
        &gt;&gt;&gt; import datetime
        &gt;&gt;&gt; import pytz
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; def job_func(message=&#34;I&#39;m working...&#34;):
        ...     print(message)

        &gt;&gt;&gt; my_manager = vbt.ScheduleManager()

        &gt;&gt;&gt; # add jobs
        &gt;&gt;&gt; my_manager.every().do(job_func, message=&#34;Hello&#34;)
        Every 1 second do job_func(message=&#39;Hello&#39;) (last run: [never], next run: 2021-03-18 19:06:47)

        &gt;&gt;&gt; my_manager.every(10, &#39;minutes&#39;).do(job_func)
        Every 10 minutes do job_func() (last run: [never], next run: 2021-03-18 19:16:46)

        &gt;&gt;&gt; my_manager.every(&#39;hour&#39;).do(job_func)
        Every 1 hour do job_func() (last run: [never], next run: 2021-03-18 20:06:46)

        &gt;&gt;&gt; my_manager.every(&#39;10:30&#39;).do(job_func)
        Every 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)

        &gt;&gt;&gt; my_manager.every(&#39;day&#39;, &#39;10:30&#39;).do(job_func)
        Every 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)

        &gt;&gt;&gt; my_manager.every(&#39;day&#39;, datetime.time(9, 30, tzinfo=pytz.utc)).do(job_func)
        Every 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)

        &gt;&gt;&gt; my_manager.every(&#39;monday&#39;).do(job_func)
        Every 1 week do job_func() (last run: [never], next run: 2021-03-22 19:06:46)

        &gt;&gt;&gt; my_manager.every(&#39;wednesday&#39;, &#39;13:15&#39;).do(job_func)
        Every 1 week at 13:15:00 do job_func() (last run: [never], next run: 2021-03-24 13:15:00)

        &gt;&gt;&gt; my_manager.every(&#39;minute&#39;, &#39;:17&#39;).do(job_func)
        Every 1 minute at 00:00:17 do job_func() (last run: [never], next run: 2021-03-18 19:07:17)

        &gt;&gt;&gt; my_manager.start()
        ```

        You can still use the chained approach as done by `schedule`:

        ```python-repl
        &gt;&gt;&gt; my_manager.every().minute.at(&#39;:17&#39;).do(job_func)
        Every 1 minute at 00:00:17 do job_func() (last run: [never], next run: 2021-03-18 19:07:17)
        ```
        &#34;&#34;&#34;
        # Parse arguments
        interval = 1
        unit = None
        start_day = None
        at = None

        def _is_arg_interval(arg):
            return isinstance(arg, (int, timedelta))

        def _is_arg_unit(arg):
            return isinstance(arg, str) and arg in self.units

        def _is_arg_start_day(arg):
            return isinstance(arg, str) and arg in self.weekdays

        def _is_arg_at(arg):
            return (isinstance(arg, str) and &#39;:&#39; in arg) or isinstance(arg, dt_time)

        expected_args = [&#39;interval&#39;, &#39;unit&#39;, &#39;start_day&#39;, &#39;at&#39;]
        for i, arg in enumerate(args):
            if &#39;interval&#39; in expected_args and _is_arg_interval(arg):
                interval = arg
                expected_args = expected_args[expected_args.index(&#39;interval&#39;) + 1:]
                continue
            if &#39;unit&#39; in expected_args and _is_arg_unit(arg):
                unit = arg
                expected_args = expected_args[expected_args.index(&#39;unit&#39;) + 1:]
                continue
            if &#39;start_day&#39; in expected_args and _is_arg_start_day(arg):
                start_day = arg
                expected_args = expected_args[expected_args.index(&#39;start_day&#39;) + 1:]
                continue
            if &#39;at&#39; in expected_args and _is_arg_at(arg):
                at = arg
                expected_args = expected_args[expected_args.index(&#39;at&#39;) + 1:]
                continue
            raise ValueError(f&#34;Arg at index {i} is unexpected&#34;)

        if at is not None:
            if unit is None and start_day is None:
                unit = &#39;days&#39;
        if unit is None and start_day is None:
            unit = &#39;seconds&#39;

        job = self.scheduler.every(interval)
        if unit is not None:
            job = getattr(job, unit)
        if start_day is not None:
            job = getattr(job, start_day)
        if at is not None:
            if isinstance(at, dt_time):
                if job.unit == &#34;days&#34; or job.start_day:
                    if at.tzinfo is not None:
                        at = tzaware_to_naive_time(at, None)
                at = at.isoformat()
                if job.unit == &#34;hours&#34;:
                    at = &#39;:&#39;.join(at.split(&#39;:&#39;)[1:])
                if job.unit == &#34;minutes&#34;:
                    at = &#39;:&#39; + at.split(&#39;:&#39;)[2]
            job = job.at(at)
        if to is not None:
            job = job.to(to)
        if until is not None:
            job = job.until(until)
        if tags is not None:
            if not isinstance(tags, tuple):
                tags = (tags,)
            job = job.tag(*tags)

        return job

    def start(self, sleep=1):
        &#34;&#34;&#34;Run pending jobs in a loop.&#34;&#34;&#34;
        logger.info(&#34;Starting schedule manager with jobs %s&#34;, str(self.scheduler.jobs))
        try:
            while True:
                self.scheduler.run_pending()
                time.sleep(sleep)
        except (KeyboardInterrupt, asyncio.CancelledError):
            logger.info(&#34;Stopping schedule manager&#34;)

    async def async_start(self, sleep=1):
        &#34;&#34;&#34;Async run pending jobs in a loop.&#34;&#34;&#34;
        logger.info(&#34;Starting schedule manager in the background with jobs %s&#34;, str(self.scheduler.jobs))
        logger.info(&#34;Jobs: %s&#34;, str(self.scheduler.jobs))
        try:
            while True:
                await self.scheduler.async_run_pending()
                await asyncio.sleep(sleep)
        except asyncio.CancelledError:
            logger.info(&#34;Stopping schedule manager&#34;)

    def done_callback(self, async_task):
        &#34;&#34;&#34;Callback run when the async task is finished.&#34;&#34;&#34;
        logger.info(async_task)

    def start_in_background(self, **kwargs):
        &#34;&#34;&#34;Run `ScheduleManager.async_start` in the background.&#34;&#34;&#34;
        async_task = asyncio.create_task(self.async_start(**kwargs))
        async_task.add_done_callback(self.done_callback)
        logger.info(async_task)
        self._async_task = async_task

    @property
    def async_task_running(self):
        &#34;&#34;&#34;Whether the async task is running.&#34;&#34;&#34;
        return self.async_task is not None and not self.async_task.done()

    def stop(self):
        &#34;&#34;&#34;Stop the async task.&#34;&#34;&#34;
        if self.async_task_running:
            self.async_task.cancel()</code></pre>
</details>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.utils.schedule.ScheduleManager.units"><code class="name">var <span class="ident fname">units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vectorbt.utils.schedule.ScheduleManager.weekdays"><code class="name">var <span class="ident fname">weekdays</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.utils.schedule.ScheduleManager.async_task"><code class="name">var <span class="ident fname">async_task</span></code></dt>
<dd>
<div class="desc"><p>Current async task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def async_task(self):
    &#34;&#34;&#34;Current async task.&#34;&#34;&#34;
    return self._async_task</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.schedule.ScheduleManager.async_task_running"><code class="name">var <span class="ident fname">async_task_running</span></code></dt>
<dd>
<div class="desc"><p>Whether the async task is running.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def async_task_running(self):
    &#34;&#34;&#34;Whether the async task is running.&#34;&#34;&#34;
    return self.async_task is not None and not self.async_task.done()</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.schedule.ScheduleManager.scheduler"><code class="name">var <span class="ident fname">scheduler</span></code></dt>
<dd>
<div class="desc"><p>Scheduler.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scheduler(self):
    &#34;&#34;&#34;Scheduler.&#34;&#34;&#34;
    return self._scheduler</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.utils.schedule.ScheduleManager.async_start"><code class="name flex">
<span>async def <span class="ident fname">async_start</span></span>(<span>self, sleep=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Async run pending jobs in a loop.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def async_start(self, sleep=1):
    &#34;&#34;&#34;Async run pending jobs in a loop.&#34;&#34;&#34;
    logger.info(&#34;Starting schedule manager in the background with jobs %s&#34;, str(self.scheduler.jobs))
    logger.info(&#34;Jobs: %s&#34;, str(self.scheduler.jobs))
    try:
        while True:
            await self.scheduler.async_run_pending()
            await asyncio.sleep(sleep)
    except asyncio.CancelledError:
        logger.info(&#34;Stopping schedule manager&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.schedule.ScheduleManager.done_callback"><code class="name flex">
<span>def <span class="ident fname">done_callback</span></span>(<span>self, async_task)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback run when the async task is finished.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done_callback(self, async_task):
    &#34;&#34;&#34;Callback run when the async task is finished.&#34;&#34;&#34;
    logger.info(async_task)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.schedule.ScheduleManager.every"><code class="name flex">
<span>def <span class="ident fname">every</span></span>(<span>self, *args, to=None, until=None, tags=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new job that runs every <code>interval</code> units of time.</p>
<p><code>*args</code> can include at most four different arguments: <code>interval</code>, <code>unit</code>, <code>start_day</code>, and <code>at</code>,
in the strict order:</p>
<ul>
<li><code>interval</code>: integer or <code>datetime.timedelta</code></li>
<li><code>unit</code>: <code><a title="vectorbt.utils.schedule.ScheduleManager.units" href="#vectorbt.utils.schedule.ScheduleManager.units">ScheduleManager.units</a></code></li>
<li><code>start_day</code>: <code><a title="vectorbt.utils.schedule.ScheduleManager.weekdays" href="#vectorbt.utils.schedule.ScheduleManager.weekdays">ScheduleManager.weekdays</a></code></li>
<li><code>at</code>: string or <code>datetime.time</code>.</li>
</ul>
<p>See the package <code>schedule</code> for more details.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import datetime
&gt;&gt;&gt; import pytz
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; def job_func(message=&quot;I'm working...&quot;):
...     print(message)

&gt;&gt;&gt; my_manager = vbt.ScheduleManager()

&gt;&gt;&gt; # add jobs
&gt;&gt;&gt; my_manager.every().do(job_func, message=&quot;Hello&quot;)
Every 1 second do job_func(message='Hello') (last run: [never], next run: 2021-03-18 19:06:47)

&gt;&gt;&gt; my_manager.every(10, 'minutes').do(job_func)
Every 10 minutes do job_func() (last run: [never], next run: 2021-03-18 19:16:46)

&gt;&gt;&gt; my_manager.every('hour').do(job_func)
Every 1 hour do job_func() (last run: [never], next run: 2021-03-18 20:06:46)

&gt;&gt;&gt; my_manager.every('10:30').do(job_func)
Every 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)

&gt;&gt;&gt; my_manager.every('day', '10:30').do(job_func)
Every 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)

&gt;&gt;&gt; my_manager.every('day', datetime.time(9, 30, tzinfo=pytz.utc)).do(job_func)
Every 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)

&gt;&gt;&gt; my_manager.every('monday').do(job_func)
Every 1 week do job_func() (last run: [never], next run: 2021-03-22 19:06:46)

&gt;&gt;&gt; my_manager.every('wednesday', '13:15').do(job_func)
Every 1 week at 13:15:00 do job_func() (last run: [never], next run: 2021-03-24 13:15:00)

&gt;&gt;&gt; my_manager.every('minute', ':17').do(job_func)
Every 1 minute at 00:00:17 do job_func() (last run: [never], next run: 2021-03-18 19:07:17)

&gt;&gt;&gt; my_manager.start()
</code></pre>
<p>You can still use the chained approach as done by <code>schedule</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; my_manager.every().minute.at(':17').do(job_func)
Every 1 minute at 00:00:17 do job_func() (last run: [never], next run: 2021-03-18 19:07:17)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def every(self, *args, to=None, until=None, tags=None):
    &#34;&#34;&#34;Create a new job that runs every `interval` units of time.

    `*args` can include at most four different arguments: `interval`, `unit`, `start_day`, and `at`,
    in the strict order:

    * `interval`: integer or `datetime.timedelta`
    * `unit`: `ScheduleManager.units`
    * `start_day`: `ScheduleManager.weekdays`
    * `at`: string or `datetime.time`.

    See the package `schedule` for more details.

    ## Example

    ```python-repl
    &gt;&gt;&gt; import datetime
    &gt;&gt;&gt; import pytz
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; def job_func(message=&#34;I&#39;m working...&#34;):
    ...     print(message)

    &gt;&gt;&gt; my_manager = vbt.ScheduleManager()

    &gt;&gt;&gt; # add jobs
    &gt;&gt;&gt; my_manager.every().do(job_func, message=&#34;Hello&#34;)
    Every 1 second do job_func(message=&#39;Hello&#39;) (last run: [never], next run: 2021-03-18 19:06:47)

    &gt;&gt;&gt; my_manager.every(10, &#39;minutes&#39;).do(job_func)
    Every 10 minutes do job_func() (last run: [never], next run: 2021-03-18 19:16:46)

    &gt;&gt;&gt; my_manager.every(&#39;hour&#39;).do(job_func)
    Every 1 hour do job_func() (last run: [never], next run: 2021-03-18 20:06:46)

    &gt;&gt;&gt; my_manager.every(&#39;10:30&#39;).do(job_func)
    Every 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)

    &gt;&gt;&gt; my_manager.every(&#39;day&#39;, &#39;10:30&#39;).do(job_func)
    Every 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)

    &gt;&gt;&gt; my_manager.every(&#39;day&#39;, datetime.time(9, 30, tzinfo=pytz.utc)).do(job_func)
    Every 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)

    &gt;&gt;&gt; my_manager.every(&#39;monday&#39;).do(job_func)
    Every 1 week do job_func() (last run: [never], next run: 2021-03-22 19:06:46)

    &gt;&gt;&gt; my_manager.every(&#39;wednesday&#39;, &#39;13:15&#39;).do(job_func)
    Every 1 week at 13:15:00 do job_func() (last run: [never], next run: 2021-03-24 13:15:00)

    &gt;&gt;&gt; my_manager.every(&#39;minute&#39;, &#39;:17&#39;).do(job_func)
    Every 1 minute at 00:00:17 do job_func() (last run: [never], next run: 2021-03-18 19:07:17)

    &gt;&gt;&gt; my_manager.start()
    ```

    You can still use the chained approach as done by `schedule`:

    ```python-repl
    &gt;&gt;&gt; my_manager.every().minute.at(&#39;:17&#39;).do(job_func)
    Every 1 minute at 00:00:17 do job_func() (last run: [never], next run: 2021-03-18 19:07:17)
    ```
    &#34;&#34;&#34;
    # Parse arguments
    interval = 1
    unit = None
    start_day = None
    at = None

    def _is_arg_interval(arg):
        return isinstance(arg, (int, timedelta))

    def _is_arg_unit(arg):
        return isinstance(arg, str) and arg in self.units

    def _is_arg_start_day(arg):
        return isinstance(arg, str) and arg in self.weekdays

    def _is_arg_at(arg):
        return (isinstance(arg, str) and &#39;:&#39; in arg) or isinstance(arg, dt_time)

    expected_args = [&#39;interval&#39;, &#39;unit&#39;, &#39;start_day&#39;, &#39;at&#39;]
    for i, arg in enumerate(args):
        if &#39;interval&#39; in expected_args and _is_arg_interval(arg):
            interval = arg
            expected_args = expected_args[expected_args.index(&#39;interval&#39;) + 1:]
            continue
        if &#39;unit&#39; in expected_args and _is_arg_unit(arg):
            unit = arg
            expected_args = expected_args[expected_args.index(&#39;unit&#39;) + 1:]
            continue
        if &#39;start_day&#39; in expected_args and _is_arg_start_day(arg):
            start_day = arg
            expected_args = expected_args[expected_args.index(&#39;start_day&#39;) + 1:]
            continue
        if &#39;at&#39; in expected_args and _is_arg_at(arg):
            at = arg
            expected_args = expected_args[expected_args.index(&#39;at&#39;) + 1:]
            continue
        raise ValueError(f&#34;Arg at index {i} is unexpected&#34;)

    if at is not None:
        if unit is None and start_day is None:
            unit = &#39;days&#39;
    if unit is None and start_day is None:
        unit = &#39;seconds&#39;

    job = self.scheduler.every(interval)
    if unit is not None:
        job = getattr(job, unit)
    if start_day is not None:
        job = getattr(job, start_day)
    if at is not None:
        if isinstance(at, dt_time):
            if job.unit == &#34;days&#34; or job.start_day:
                if at.tzinfo is not None:
                    at = tzaware_to_naive_time(at, None)
            at = at.isoformat()
            if job.unit == &#34;hours&#34;:
                at = &#39;:&#39;.join(at.split(&#39;:&#39;)[1:])
            if job.unit == &#34;minutes&#34;:
                at = &#39;:&#39; + at.split(&#39;:&#39;)[2]
        job = job.at(at)
    if to is not None:
        job = job.to(to)
    if until is not None:
        job = job.until(until)
    if tags is not None:
        if not isinstance(tags, tuple):
            tags = (tags,)
        job = job.tag(*tags)

    return job</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.schedule.ScheduleManager.start"><code class="name flex">
<span>def <span class="ident fname">start</span></span>(<span>self, sleep=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Run pending jobs in a loop.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self, sleep=1):
    &#34;&#34;&#34;Run pending jobs in a loop.&#34;&#34;&#34;
    logger.info(&#34;Starting schedule manager with jobs %s&#34;, str(self.scheduler.jobs))
    try:
        while True:
            self.scheduler.run_pending()
            time.sleep(sleep)
    except (KeyboardInterrupt, asyncio.CancelledError):
        logger.info(&#34;Stopping schedule manager&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.schedule.ScheduleManager.start_in_background"><code class="name flex">
<span>def <span class="ident fname">start_in_background</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.utils.schedule.ScheduleManager.async_start" href="#vectorbt.utils.schedule.ScheduleManager.async_start">ScheduleManager.async_start()</a></code> in the background.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_in_background(self, **kwargs):
    &#34;&#34;&#34;Run `ScheduleManager.async_start` in the background.&#34;&#34;&#34;
    async_task = asyncio.create_task(self.async_start(**kwargs))
    async_task.add_done_callback(self.done_callback)
    logger.info(async_task)
    self._async_task = async_task</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.schedule.ScheduleManager.stop"><code class="name flex">
<span>def <span class="ident fname">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the async task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#34;&#34;&#34;Stop the async task.&#34;&#34;&#34;
    if self.async_task_running:
        self.async_task.cancel()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABmtJREFUeNrsnD1vFEkQhtve+fIuax9gDDIHQubDSMiQOEByjERGxg+4iL9DRI6A4IhAAkLIIeV0BwEICQJbwpbshRXegDbmkAW2p96erp7qpiqxg9mveWuq3nqme8aWrlw3Gu3FuJ4CFUAF0FABVAANFUAF0FABVAANFUAF0FABVAANFUAF0FABko/M7WULqysLq8v046uryLsfM2aKeuyHlerhs2PQl79x8e33/yaMOQm80H6Q/Tj68Z2s6GQ5iwCXl99fe/eK+j2Om/5Z5N2XjJmmHvvi5R/3n/ShL//X2Zff/ztvzDz1VeuD7ObtI8YM6B/U7RdcJWhufY1+8NiE1Ov/BJb+WHEf79Smfwo9YP0TdhEvHv0/dWzx6QIvvPPoT+iDiomelCY8fgh8wTRw7H9vDwRI/6fPp6Hqb9M/LypGAaAODAvAGfMHN7b+TGEyo+mfl1S1fjsbOlmMvjUx4CU2922rB3re2FhedgUJgDXhKezNnyOnxsbsgaHJMfd56+9TWPWvulYDRgEgC7RtQ5GrlzcbZntDcxpp8oPMNgBstiqQbuHwG3qjzXhLUN+WINB9Wg2A/Ckq24FjRhHgFYC6oPlLGxLcZyMBjn4eYJfkGcYeAKUnt/vM8hJKf0cBZoYDE2csnltjdZ+2/cJDUtSeEkpPtL6h7pOC3jw14U2gCWMWyMZh5BwtYwLMn9rgc5/04SuoDRVF4iZ7Iyb3SWcPSZUglMTNHhnS2y/U3lHzE04AGAQhLgj1oHQBoPqzxR6c0t9RAF4SxzkJ92klyPZeqL07mJ9EShAaxCYMuU8IvbUgANaEwR+Ckjii+4Tarx2+6OjNgwC8JK7LmAqLF9a8p3+T9usoQNQkjuI+oXu/KHoT3wM4SRylAcDus2p6zcICoCQOK0GcJI4yhUHus5MV450stAAoiZMzCdcOAaj7LJtV/+htKEriagWA2q/NfQf05qMJIyQOnsI4Sdz+UxjqPptX/xA2VNaClH2bMGR+nNFbUiUIJXEe609eeetsvALAHZiNxNWmP91QfUNv7Qkwt77K5UENI4nbvwFA6Q8t+9FJuN4CWfcJXUxN0JvsHsBJ4o7P7CnAA5A9eEx/WADeBSmcJK7fHe3lPiH/U/gYvtwFmBl+itQy7dWEA6M32SWIeU2cB/dZ+ucqmAC9zS/Q8XJI3K43AyD36bbsx7MAcxvY3Ri5u8Nc3CfLj4l1EoZI3K4NwFYwehGzpT/Ly8gEkEPidp3CsPT3bX4cBVj4uMIoQMApDLr16BG9pVOCIBL36xR29zFkfirGOsH31nJI3K9T2IOn1PRvuOzHtwuKk8T91IShRz74RW+N54Ak1qRA8CcrKtYvI6YHcJK4nVOYrV30bRcc7MFdgHhJnED36SJApCRuZwOA3OfWsh/m9JdUgthI3M4pDHKfJX/6YwJESuJ2TmF098mE3hoJECmJ+zGFQZt+WYev6CdhCET/mMLo7ZeVPQQSgJXEOSxIgTb9FkGqPyxApCRuO+jLnpvsuPtdShAUdgqDNv36WvTZsgCsJO7FP9jWMPqtR2701swFRUjithsAvf023HHHPAdESOLsFAa5z5DtV1IPAC/6f9+Qx+DuiJ7+AdCbuwCiSBz9dpi9AgD3Gbb9YgJESuIw9NbJ5ArAG2AHRjcnUaIMXv0xAUSROPhBWbVnwdOOO0YBElsTJ6H6xzoJw49JrD0FAdFbIAHkkDhSA6ravFqpAkRN4mrYQxGDAKkG97KfdgSAOzDSAlESV1N/ym67GUB2QawkrqWT4H3HHecckOJzmoqWhi9hPQAcgOgkbv9weNB2awLIely6p0dEtDh8wQLEuzt1zy4VatlPgjbUC4krKimohCQAL4mbBgVoTOL4dtxxCZAYiZNgfmItQc1JXLvoLYQAMAiaBI5tTuKCLfr0KQAviQtoRsIv+0nQBTVjDxOtswd2ASSTuLwSZw9oLigJEtfKsh9Pc0ASJE6U+xTTA0KRuDA77lgESIPElSLTnyRAAiRODnqL3oa6kThpwxcmAErisEGMn8RJYw+wACiJk7YmpZBa/eMrQQ4kzs69cshzCAHgMZiZxLW+7KfeNNYesVz17p2+QK8/xWvk84fAJGwbAOompaG3XVJ26cp1o6E9QAXQUAFUAA0VQAXQUAFUAA0VQAXQUAFUAA0VQAXQUAFUAA2++CrAAE3lth2zPPJAAAAAAElFTkSuQmCC"/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.utils" href="index.html">vectorbt.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.utils.schedule.AsyncJob" href="#vectorbt.utils.schedule.AsyncJob">AsyncJob</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.schedule.AsyncJob.async_run" href="#vectorbt.utils.schedule.AsyncJob.async_run">async_run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.schedule.AsyncScheduler" href="#vectorbt.utils.schedule.AsyncScheduler">AsyncScheduler</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.schedule.AsyncScheduler.async_run_all" href="#vectorbt.utils.schedule.AsyncScheduler.async_run_all">async_run_all</a></code></li>
<li><code><a title="vectorbt.utils.schedule.AsyncScheduler.async_run_pending" href="#vectorbt.utils.schedule.AsyncScheduler.async_run_pending">async_run_pending</a></code></li>
<li><code><a title="vectorbt.utils.schedule.AsyncScheduler.every" href="#vectorbt.utils.schedule.AsyncScheduler.every">every</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.schedule.CancelledError" href="#vectorbt.utils.schedule.CancelledError">CancelledError</a></code></h4>
</li>
<li>
<h4><code><a title="vectorbt.utils.schedule.ScheduleManager" href="#vectorbt.utils.schedule.ScheduleManager">ScheduleManager</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.utils.schedule.ScheduleManager.async_start" href="#vectorbt.utils.schedule.ScheduleManager.async_start">async_start</a></code></li>
<li><code><a title="vectorbt.utils.schedule.ScheduleManager.async_task" href="#vectorbt.utils.schedule.ScheduleManager.async_task">async_task</a></code></li>
<li><code><a title="vectorbt.utils.schedule.ScheduleManager.async_task_running" href="#vectorbt.utils.schedule.ScheduleManager.async_task_running">async_task_running</a></code></li>
<li><code><a title="vectorbt.utils.schedule.ScheduleManager.done_callback" href="#vectorbt.utils.schedule.ScheduleManager.done_callback">done_callback</a></code></li>
<li><code><a title="vectorbt.utils.schedule.ScheduleManager.every" href="#vectorbt.utils.schedule.ScheduleManager.every">every</a></code></li>
<li><code><a title="vectorbt.utils.schedule.ScheduleManager.scheduler" href="#vectorbt.utils.schedule.ScheduleManager.scheduler">scheduler</a></code></li>
<li><code><a title="vectorbt.utils.schedule.ScheduleManager.start" href="#vectorbt.utils.schedule.ScheduleManager.start">start</a></code></li>
<li><code><a title="vectorbt.utils.schedule.ScheduleManager.start_in_background" href="#vectorbt.utils.schedule.ScheduleManager.start_in_background">start_in_background</a></code></li>
<li><code><a title="vectorbt.utils.schedule.ScheduleManager.stop" href="#vectorbt.utils.schedule.ScheduleManager.stop">stop</a></code></li>
<li><code><a title="vectorbt.utils.schedule.ScheduleManager.units" href="#vectorbt.utils.schedule.ScheduleManager.units">units</a></code></li>
<li><code><a title="vectorbt.utils.schedule.ScheduleManager.weekdays" href="#vectorbt.utils.schedule.ScheduleManager.weekdays">weekdays</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>