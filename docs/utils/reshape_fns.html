<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.utils.reshape_fns API documentation</title>
<meta name="description" content="Utilities for reshaping arrays." />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{isplay:block;width:100%;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:#495057;background-color:#fff;background-clip:padding-box;border:1px solid #ced4da;border-radius:.25rem;transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out}.algolia-autocomplete{width:100%}.scrollable-index{overflow-y:scroll;height:calc(100vh - 200px)}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:visible;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://github.com/polakowo/vectorbt/blob/master/logo.png?raw=true">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.utils.reshape_fns</code></h1>
</header>
<section id="section-intro">
<p>Utilities for reshaping arrays.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Utilities for reshaping arrays.&#34;&#34;&#34;

import numpy as np
import pandas as pd

from vectorbt import defaults
from vectorbt.utils import checks, index_fns


def soft_broadcast_to_ndim(arg, ndim):
    &#34;&#34;&#34;Try to softly bring `arg` to the specified number of dimensions `ndim` (max 2).&#34;&#34;&#34;
    if not checks.is_array(arg):
        arg = np.asarray(arg)
    if ndim == 1:
        if arg.ndim == 2:
            if arg.shape[1] == 1:
                if checks.is_pandas(arg):
                    return arg.iloc[:, 0]
                return arg[:, 0]  # downgrade
    if ndim == 2:
        if arg.ndim == 1:
            if checks.is_pandas(arg):
                return arg.to_frame()
            return arg[:, None]  # upgrade
    return arg  # do nothing


class ArrayWrapper():
    &#34;&#34;&#34;Class that stores index, columns and shape metadata for wrapping NumPy arrays.&#34;&#34;&#34;
    def __init__(self, index=None, columns=None, ndim=None):
        self.index = index
        self.columns = columns
        self.ndim = ndim
        
    @classmethod
    def from_obj(cls, obj):
        &#34;&#34;&#34;Derive metadata from an object.&#34;&#34;&#34;
        index = obj.index
        if checks.is_frame(obj):
            columns = obj.columns
        else:
            columns = [obj.name]
        ndim = obj.ndim
        return cls(index=index, columns=columns, ndim=ndim)
        
    def wrap(self, arg, index=None, columns=None, ndim=None, dtype=None):
        &#34;&#34;&#34;Wrap a NumPy array using the stored metadata.&#34;&#34;&#34;
        arg = np.asarray(arg)
        if ndim is None:
            ndim = self.ndim
        if ndim is not None:
            arg = soft_broadcast_to_ndim(arg, self.ndim)
        if index is None:
            index = self.index
        if columns is None:
            columns = self.columns
        if columns is not None and len(columns) == 1:
            name = columns[0]
        else:
            name = None

        # Perform checks
        if index is not None:
            checks.assert_same_shape(arg, index, axis=(0, 0))
        if arg.ndim == 2 and columns is not None:
            checks.assert_same_shape(arg, columns, axis=(1, 0))

        if arg.ndim == 1:
            return pd.Series(arg, index=index, name=name, dtype=dtype)
        return pd.DataFrame(arg, index=index, columns=columns, dtype=dtype)


def to_1d(arg, raw=False):
    &#34;&#34;&#34;Reshape argument to one dimension. 

    If `raw` is `True`, returns NumPy array.
    If 2-dim, will collapse along axis 1 (i.e., DataFrame with one column to Series).&#34;&#34;&#34;
    if raw or not checks.is_array(arg):
        arg = np.asarray(arg)
    if arg.ndim == 2:
        if arg.shape[1] == 1:
            if checks.is_frame(arg):
                return arg.iloc[:, 0]
            return arg[:, 0]
    if arg.ndim == 1:
        return arg
    elif arg.ndim == 0:
        return arg.reshape((1,))
    raise ValueError(f&#34;Cannot reshape a {arg.ndim}-dimensional array to 1 dimension&#34;)


def to_2d(arg, raw=False, expand_axis=1):
    &#34;&#34;&#34;Reshape argument to two dimensions. 

    If `raw` is `True`, returns NumPy array.
    If 1-dim, will expand along axis 1 (i.e., Series to DataFrame with one column).&#34;&#34;&#34;
    if raw or not checks.is_array(arg):
        arg = np.asarray(arg)
    if arg.ndim == 2:
        return arg
    elif arg.ndim == 1:
        if checks.is_series(arg):
            if expand_axis == 0:
                return pd.DataFrame(arg.values[None, :], columns=arg.index)
            elif expand_axis == 1:
                return arg.to_frame()
        return np.expand_dims(arg, expand_axis)
    elif arg.ndim == 0:
        return arg.reshape((1, 1))
    raise ValueError(f&#34;Cannot reshape a {arg.ndim}-dimensional array to 2 dimensions&#34;)


def repeat(arg, n, axis=1):
    &#34;&#34;&#34;Repeat each element in `arg` `n` times along the specified axis.&#34;&#34;&#34;
    if not checks.is_array(arg):
        arg = np.asarray(arg)
    if axis == 0:
        if checks.is_pandas(arg):
            return ArrayWrapper.from_obj(arg).wrap(
                np.repeat(arg.values, n, axis=0), index=index_fns.repeat_index(arg.index, n))
        return np.repeat(arg, n, axis=0)
    elif axis == 1:
        arg = to_2d(arg)
        if checks.is_pandas(arg):
            return ArrayWrapper.from_obj(arg).wrap(
                np.repeat(arg.values, n, axis=1), columns=index_fns.repeat_index(arg.columns, n))
        return np.repeat(arg, n, axis=1)
    else:
        raise ValueError(&#34;Only axis 0 and 1 are supported&#34;)


def tile(arg, n, axis=1):
    &#34;&#34;&#34;Repeat the whole `arg` `n` times along the specified axis.&#34;&#34;&#34;
    if not checks.is_array(arg):
        arg = np.asarray(arg)
    if axis == 0:
        if arg.ndim == 1:
            if checks.is_pandas(arg):
                return ArrayWrapper.from_obj(arg).wrap(
                    np.tile(arg.values, n), index=index_fns.tile_index(arg.index, n))
            return np.tile(arg, n)
        if arg.ndim == 2:
            if checks.is_pandas(arg):
                return ArrayWrapper.from_obj(arg).wrap(
                    np.tile(arg.values, (n, 1)), index=index_fns.tile_index(arg.index, n))
            return np.tile(arg, (n, 1))
    elif axis == 1:
        arg = to_2d(arg)
        if checks.is_pandas(arg):
            return ArrayWrapper.from_obj(arg).wrap(
                    np.tile(arg.values, (1, n)), columns=index_fns.tile_index(arg.columns, n))
        return np.tile(arg, (1, n))
    else:
        raise ValueError(&#34;Only axis 0 and 1 are supported&#34;)


def broadcast_index(*args, to_shape=None, index_from=None, axis=0, ignore_single=&#39;default&#39;, drop_duplicates=&#39;default&#39;, keep=&#39;default&#39;):
    &#34;&#34;&#34;Produce a broadcasted index/columns.

    Args:
        *args (array_like): Array-like objects.
        to_shape (tuple): Target shape. Optional.
        index_from (None, int, str or array_like): Broadcasting rule for this index/these columns.

            Accepts the following values:

            * `&#39;default&#39;` - take the value from `vectorbt.defaults.broadcasting`
            * `None` - use the original index/columns of the objects in `args`
            * `int` - use the index/columns of the i-nth object in `args`
            * `&#39;strict&#39;` - ensure that all pandas objects have the same index/columns
            * `&#39;stack&#39;` - stack different indexes/columns using `vectorbt.utils.index_fns.stack_indexes`
            * everything else will be converted to `pd.Index`

        axis (int): Set to 0 for index and 1 for columns.
        ignore_single (bool): If `True`, ignores indexes/columns with one value, otherwise they will be repeated
            to match the length of the longest index/columns (can lead to pollution of levels).
        drop_duplicates (bool): See `vectorbt.utils.index_fns.drop_duplicate_levels`.
        keep (bool): See `vectorbt.utils.index_fns.drop_duplicate_levels`.

    For defaults, see `vectorbt.defaults.broadcasting`.
    &#34;&#34;&#34;

    if ignore_single == &#39;default&#39;:
        ignore_single = defaults.broadcasting[&#39;ignore_single&#39;]
    if drop_duplicates == &#39;default&#39;:
        drop_duplicates = defaults.broadcasting[&#39;drop_duplicates&#39;]
    if keep == &#39;default&#39;:
        keep = defaults.broadcasting[&#39;keep&#39;]
    index_str = &#39;columns&#39; if axis == 1 else &#39;index&#39;
    new_index = None

    if index_from is not None:
        if isinstance(index_from, int):
            # Take index/columns of the object indexed by index_from
            if axis == 1:
                new_index = to_2d(args[index_from]).columns
            else:
                new_index = args[index_from].index
        elif isinstance(index_from, str):
            if index_from in (&#39;stack&#39;, &#39;strict&#39;):
                # If pandas objects have different index/columns, stack them together
                # maxlen stores the length of the longest index
                if to_shape is None:
                    # Simulate broadcasting
                    to_shape = np.lib.stride_tricks._broadcast_shape(*args)
                if axis == 1 and len(to_shape) == 1:
                    to_shape = (to_shape[0], 1)
                maxlen = to_shape[1] if axis == 1 else to_shape[0]
                for arg in args:
                    if checks.is_pandas(arg):
                        if checks.is_series(arg):
                            arg = arg.to_frame()  # series name counts as a column
                        index = arg.columns if axis == 1 else arg.index
                        if new_index is None:
                            new_index = index
                        else:
                            if index_from == &#39;strict&#39;:
                                # If pandas objects have different index/columns, raise an exception
                                if not pd.Index.equals(index, new_index):
                                    raise ValueError(
                                        f&#34;Broadcasting {index_str} is not allowed for {index_str}_from=strict&#34;)
                            # Broadcasting index must follow the rules of a regular broadcasting operation
                            # https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html#general-broadcasting-rules
                            # 1. rule: if indexes are of the same length, they are simply stacked
                            # 2. rule: if index has one element, it gets repeated and then stacked

                            if pd.Index.equals(index, new_index):
                                continue
                            if len(index) != len(new_index):
                                if len(index) &gt; 1 and len(new_index) &gt; 1:
                                    raise ValueError(&#34;Indexes could not be broadcast together&#34;)
                                if ignore_single:
                                    # Columns of length 1 should be simply ignored
                                    if len(index) &gt; len(new_index):
                                        new_index = index
                                    continue
                                else:
                                    if len(index) &gt; len(new_index):
                                        new_index = index_fns.repeat_index(new_index, len(index))
                                    elif len(index) &lt; len(new_index):
                                        index = index_fns.repeat_index(index, len(new_index))
                            new_index = index_fns.stack_indexes(new_index, index)
                            if drop_duplicates:
                                new_index = index_fns.drop_duplicate_levels(new_index, keep=keep)
                if maxlen &gt; len(new_index):
                    if index_from == &#39;strict&#39;:
                        raise ValueError(f&#34;Broadcasting {index_str} is not allowed for {index_str}_from=strict&#34;)
                    # This happens only when some numpy object is longer than the new pandas index
                    # In this case, new pandas index (one element) should be repeated to match this length.
                    if maxlen &gt; 1 and len(new_index) &gt; 1:
                        raise ValueError(&#34;Indexes could not be broadcast together&#34;)
                    new_index = index_fns.repeat_index(new_index, maxlen)
            else:
                raise ValueError(f&#34;Invalid value {index_from} for {&#39;columns&#39; if axis == 1 else &#39;index&#39;}_from&#34;)
        else:
            new_index = index_from
    return new_index


def wrap_broadcasted(old_arg, new_arg, is_pd=False, new_index=None, new_columns=None):
    &#34;&#34;&#34;If the newly brodcasted array was originally a pandas object, make it pandas object again 
    and assign it the newly broadcasted index/columns.&#34;&#34;&#34;
    if is_pd:
        if checks.is_pandas(old_arg):
            if new_index is None:
                # Take index from original pandas object
                if old_arg.shape[0] == new_arg.shape[0]:
                    new_index = old_arg.index
                else:
                    new_index = index_fns.repeat_index(old_arg.index, new_arg.shape[0])
            if new_columns is None:
                # Take columns from original pandas object
                if new_arg.ndim == 2:
                    if checks.is_series(old_arg):
                        old_arg = old_arg.to_frame()
                    if old_arg.shape[1] == new_arg.shape[1]:
                        new_columns = old_arg.columns
                    else:
                        new_columns = index_fns.repeat_index(old_arg.columns, new_arg.shape[1])
        else:
            if new_index is None and new_columns is None:
                # Return plain numpy array if not pandas and no rules set
                return new_arg
        return ArrayWrapper(index=new_index, columns=new_columns).wrap(new_arg)
    return new_arg


def broadcast(*args, to_shape=None, to_pd=None, index_from=&#39;default&#39;, columns_from=&#39;default&#39;, writeable=False, copy_kwargs={}, **kwargs):
    &#34;&#34;&#34;Bring any array-like object in `args` to the same shape by using NumPy broadcasting.

    See [Broadcasting](https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html).

    Can broadcast pandas objects by broadcasting their index/columns with `broadcast_index`.

    Args:
        *args (array_like): Array-like objects.
        to_shape (tuple): Target shape. If set, will broadcast every element in `args` to `to_shape`.
        to_pd (bool): If `True`, converts all output arrays to pandas, otherwise returns raw NumPy 
            arrays. If `None`, converts only if there is at least one pandas object among them.
        index_from (None, int, str or array_like): Broadcasting rule for index.
        columns_from (None, int, str or array_like): Broadcasting rule for columns.
        writable (bool): If `True`, makes broadcasted arrays writable, otherwise readonly.

            !!! note
                Has effect only if broadcasting was needed for that particular array.

                Making arrays writable is possible only through copying them, which is pretty expensive.

                Numba requires arrays to be writable.

        copy_kwargs (dict): Keyword arguments passed to `np.array`. For example, to specify `order`.

            !!! note
                Has effect on every array, independent from whether broadcasting was needed or not.

        **kwargs: Keyword arguments passed to `broadcast_index`.

    For defaults, see `vectorbt.defaults.broadcasting`.

    Example:
        Without broadcasting index and columns:

        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.utils.reshape_fns import broadcast

        &gt;&gt;&gt; v = 0
        &gt;&gt;&gt; a = np.array([1, 2, 3])
        &gt;&gt;&gt; sr = pd.Series([1, 2, 3], index=pd.Index([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]), name=&#39;a&#39;)
        &gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 
        ...     index=pd.Index([&#39;x2&#39;, &#39;y2&#39;, &#39;z2&#39;]), 
        ...     columns=pd.Index([&#39;a2&#39;, &#39;b2&#39;, &#39;c2&#39;]))

        &gt;&gt;&gt; for i in broadcast(
        ...     v, a, sr, df,
        ...     index_from=None,
        ...     columns_from=None,
        ... ): print(i)
        [[0 0 0]
        [0 0 0]
        [0 0 0]]
        [[1 2 3]
        [1 2 3]
        [1 2 3]]
           a  a  a
        x  1  1  1
        y  2  2  2
        z  3  3  3
            a2  b2  c2
        x2   1   2   3
        y2   4   5   6
        z2   7   8   9
        ```

        Taking new index and columns from position:

        ```python-repl
        &gt;&gt;&gt; for i in broadcast(
        ...     v, a, sr, df,
        ...     index_from=2,
        ...     columns_from=3
        ... ): print(i)
           a2  b2  c2
        x   0   0   0
        y   0   0   0
        z   0   0   0
           a2  b2  c2
        x   1   2   3
        y   1   2   3
        z   1   2   3
           a2  b2  c2
        x   1   1   1
        y   2   2   2
        z   3   3   3
           a2  b2  c2
        x   1   2   3
        y   4   5   6
        z   7   8   9
        ```

        Broadcasting index and columns through stacking:

        ```python-repl
        &gt;&gt;&gt; for i in broadcast(
        ...     v, a, sr, df,
        ...     index_from=&#39;stack&#39;,
        ...     columns_from=&#39;stack&#39;
        ... ): print(i)
              a2  b2  c2
        x x2   0   0   0
        y y2   0   0   0
        z z2   0   0   0
              a2  b2  c2
        x x2   1   2   3
        y y2   1   2   3
        z z2   1   2   3
              a2  b2  c2
        x x2   1   1   1
        y y2   2   2   2
        z z2   3   3   3
              a2  b2  c2
        x x2   1   2   3
        y y2   4   5   6
        z z2   7   8   9
        ```

        Setting index and columns manually:

        ```python-repl
        &gt;&gt;&gt; for i in broadcast(
        ...     v, a, sr, df,
        ...     index_from=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
        ...     columns_from=[&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
        ... ): print(i)
           d  e  f
        a  0  0  0
        b  0  0  0
        c  0  0  0
           d  e  f
        a  1  2  3
        b  1  2  3
        c  1  2  3
           d  e  f
        a  1  1  1
        b  2  2  2
        c  3  3  3
           d  e  f
        a  1  2  3
        b  4  5  6
        c  7  8  9
        ```
    &#34;&#34;&#34;
    is_pd = False
    is_2d = False
    args = list(args)
    if isinstance(index_from, str) and index_from == &#39;default&#39;:
        index_from = defaults.broadcasting[&#39;index_from&#39;]
    if isinstance(columns_from, str) and columns_from == &#39;default&#39;:
        columns_from = defaults.broadcasting[&#39;columns_from&#39;]

    # Convert to np.ndarray object if not numpy or pandas
    # Also check whether we broadcast to pandas and whether work on 2-dim data
    for i in range(len(args)):
        if not checks.is_array(args[i]):
            args[i] = np.asarray(args[i])
        if args[i].ndim &gt; 1:
            is_2d = True
        if checks.is_pandas(args[i]):
            is_pd = True

    if to_pd is not None:
        is_pd = to_pd  # force either raw or pandas

    # If target shape specified, check again if we work on 2-dim data
    if to_shape is not None:
        checks.assert_type(to_shape, tuple)
        if len(to_shape) &gt; 1:
            is_2d = True

    # Convert all pd.Series objects to pd.DataFrame if we work on 2-dim data
    if is_2d:
        for i in range(len(args)):
            if checks.is_series(args[i]):
                args[i] = args[i].to_frame()

    if is_pd:
        # Decide on index and columns
        new_index = broadcast_index(*args, to_shape=to_shape, index_from=index_from, axis=0, **kwargs)
        new_columns = broadcast_index(*args, to_shape=to_shape, index_from=columns_from, axis=1, **kwargs)
    else:
        new_index, new_columns = None, None

    # Perform broadcasting
    if to_shape is None:
        new_args = np.broadcast_arrays(*args, subok=True)
    else:
        new_args = []
        for arg in args:
            new_arg = np.broadcast_to(arg, to_shape, subok=True)
            new_args.append(new_arg)

    # The problem is that broadcasting creates readonly objects and numba requires writable ones.
    # To make them writable we must copy, which is ok for small-sized arrays and not ok for large ones.
    # Thus check if broadcasting was needed in the first place, and if so, copy
    for i in range(len(new_args)):
        if new_args[i].shape == args[i].shape:
            # Broadcasting was not needed, take old array
            new_args[i] = np.array(args[i], copy=False, **copy_kwargs)
        else:
            # Broadcasting was needed, take new array
            new_args[i] = np.array(new_args[i], copy=writeable, **copy_kwargs)

    # Bring arrays to their old types (e.g. array -&gt; pandas)
    for i in range(len(new_args)):
        new_args[i] = wrap_broadcasted(args[i], new_args[i], is_pd=is_pd, new_index=new_index, new_columns=new_columns)

    if len(new_args) &gt; 1:
        return tuple(new_args)
    return new_args[0]


def broadcast_to(arg1, arg2, to_pd=None, index_from=None, columns_from=None, **kwargs):
    &#34;&#34;&#34;Broadcast `arg1` to `arg2`.

    Keyword arguments `**kwargs` are passed to `broadcast`.

    Example:
        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.utils.reshape_fns import broadcast_to

        &gt;&gt;&gt; a = np.array([1, 2, 3])
        &gt;&gt;&gt; sr = pd.Series([4, 5, 6], index=pd.Index([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]), name=&#39;a&#39;)

        &gt;&gt;&gt; print(broadcast_to(a, sr))
        x    1
        y    2
        z    3
        Name: a, dtype: int64

        &gt;&gt;&gt; print(broadcast_to(sr, a))
        array([4, 5, 6])
        ```&#34;&#34;&#34;
    if not checks.is_array(arg1):
        arg1 = np.asarray(arg1)
    if not checks.is_array(arg2):
        arg2 = np.asarray(arg2)
    if to_pd is None:
        to_pd = checks.is_pandas(arg2)
    if to_pd:
        # Take index and columns from arg2
        if index_from is None:
            index_from = arg2.index
        if columns_from is None:
            columns_from = to_2d(arg2).columns
    return broadcast(arg1, to_shape=arg2.shape, to_pd=to_pd, index_from=index_from, columns_from=columns_from, **kwargs)


def broadcast_to_array_of(arg1, arg2):
    &#34;&#34;&#34;Broadcast `arg1` to the shape `(1, *arg2.shape)`.

    Example:
        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from vectorbt.utils.reshape_fns import broadcast_to_array_of

        &gt;&gt;&gt; print(broadcast_to_array_of([0.1, 0.2], np.empty((2, 2))))
        [[[0.1 0.1]
          [0.1 0.1]]

         [[0.2 0.2]
          [0.2 0.2]]]
        ```&#34;&#34;&#34;
    arg1 = np.asarray(arg1)
    arg2 = np.asarray(arg2)
    if arg1.ndim == arg2.ndim + 1:
        if arg1.shape[1:] == arg2.shape:
            return arg1
    # From here on arg1 can be only a 1-dim array
    if arg1.ndim == 0:
        arg1 = to_1d(arg1)
    checks.assert_ndim(arg1, 1)

    if arg2.ndim == 0:
        return arg1
    for i in range(arg2.ndim):
        arg1 = np.expand_dims(arg1, axis=-1)
    return np.tile(arg1, (1, *arg2.shape))


def unstack_to_array(arg, levels=None):
    &#34;&#34;&#34;Reshape `arg` based on its multi-index into a multi-dimensional array.

    Use `levels` to specify what index levels to unstack and in which order.

    Example:
        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.utils.reshape_fns import unstack_to_array

        &gt;&gt;&gt; index = pd.MultiIndex.from_arrays(
        ...     [[1, 1, 2, 2], [3, 4, 3, 4], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]])
        &gt;&gt;&gt; sr = pd.Series([1, 2, 3, 4], index=index)

        &gt;&gt;&gt; print(unstack_to_array(sr).shape)
        (2, 2, 4)

        &gt;&gt;&gt; print(unstack_to_array(sr))
        [[[ 1. nan nan nan]
         [nan  2. nan nan]]

         [[nan nan  3. nan]
        [nan nan nan  4.]]]

        &gt;&gt;&gt; print(unstack_to_array(sr, levels=(2, 0)))
        [[ 1. nan]
         [ 2. nan]
         [nan  3.]
         [nan  4.]]
        ```&#34;&#34;&#34;
    checks.assert_type(arg, pd.Series)
    checks.assert_type(arg.index, pd.MultiIndex)

    unique_idx_list = []
    vals_idx_list = []
    if levels is None:
        levels = range(len(arg.index.levels))
    for level in levels:
        vals = index_fns.select_levels(arg.index, level).to_numpy()
        unique_vals = np.unique(vals)
        unique_idx_list.append(unique_vals)
        idx_map = dict(zip(unique_vals, range(len(unique_vals))))
        vals_idx = list(map(lambda x: idx_map[x], vals))
        vals_idx_list.append(vals_idx)

    a = np.full(list(map(len, unique_idx_list)), np.nan)
    a[tuple(zip(vals_idx_list))] = arg.values
    return a


def make_symmetric(arg):
    &#34;&#34;&#34;Make `arg` symmetric.

    The index and columns of the resulting DataFrame will be identical.

    Requires the index and columns to have the same number of levels.

    Example:
        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.utils.reshape_fns import make_symmetric

        &gt;&gt;&gt; df = pd.DataFrame([[1, 2], [3, 4]], index=[&#39;a&#39;, &#39;b&#39;], columns=[&#39;c&#39;, &#39;d&#39;])

        &gt;&gt;&gt; print(make_symmetric(df))
             a    b    c    d
        a  NaN  NaN  1.0  2.0
        b  NaN  NaN  3.0  4.0
        c  1.0  3.0  NaN  NaN
        d  2.0  4.0  NaN  NaN
        ```&#34;&#34;&#34;
    checks.assert_type(arg, (pd.Series, pd.DataFrame))
    arg = to_2d(arg)
    checks.assert_same_type(arg.index, arg.columns)
    if isinstance(arg.index, pd.MultiIndex):
        checks.assert_same_len(arg.index.names, arg.columns.names)
        names1, names2 = tuple(arg.index.names), tuple(arg.columns.names)
    else:
        names1, names2 = arg.index.name, arg.columns.name

    if names1 == names2:
        new_name = names1
    else:
        if isinstance(arg.index, pd.MultiIndex):
            new_name = tuple(zip(*[names1, names2]))
        else:
            new_name = (names1, names2)
    idx_vals = np.unique(np.concatenate((arg.index, arg.columns)))
    arg = arg.copy()
    if isinstance(arg.index, pd.MultiIndex):
        unique_index = pd.MultiIndex.from_tuples(idx_vals, names=new_name)
        arg.index.names = new_name
        arg.columns.names = new_name
    else:
        unique_index = pd.Index(idx_vals, name=new_name)
        arg.index.name = new_name
        arg.columns.name = new_name
    df_out = pd.DataFrame(index=unique_index, columns=unique_index)
    df_out.loc[:, :] = arg
    df_out[df_out.isnull()] = arg.transpose()
    return df_out


def unstack_to_df(arg, index_levels=None, column_levels=None, symmetric=False):
    &#34;&#34;&#34;Reshape `arg` based on its multi-index into a DataFrame.

    Use `index_levels` to specify what index levels will form new index, and `column_levels` 
    for new columns. Set `symmetric` to `True` to make DataFrame symmetric.

    Example:
        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.utils.reshape_fns import unstack_to_df

        &gt;&gt;&gt; index = pd.MultiIndex.from_arrays(
        ...     [[1, 1, 2, 2], [3, 4, 3, 4], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]], 
        ...     names=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])
        &gt;&gt;&gt; sr = pd.Series([1, 2, 3, 4], index=index)

        &gt;&gt;&gt; print(unstack_to_df(sr, index_levels=(0, 1), column_levels=2))
        z      a    b    c    d
        x y                    
        1 3  1.0  NaN  NaN  NaN
        1 4  NaN  2.0  NaN  NaN
        2 3  NaN  NaN  3.0  NaN
        2 4  NaN  NaN  NaN  4.0
        ```&#34;&#34;&#34;
    # Perform checks
    checks.assert_type(arg, (pd.Series, pd.DataFrame))
    if checks.is_frame(arg):
        if arg.shape[0] == 1:
            arg = arg.iloc[0, :]
        elif arg.shape[1] == 1:
            arg = arg.iloc[:, 0]
    checks.assert_type(arg.index, pd.MultiIndex)
    sr = to_1d(arg)

    if len(sr.index.levels) &gt; 2:
        checks.assert_not_none(index_levels)
        checks.assert_not_none(column_levels)
    else:
        index_levels = 0
        column_levels = 1

    # Build new index and column hierarchies
    new_index = index_fns.select_levels(arg.index, index_levels).unique()
    new_columns = index_fns.select_levels(arg.index, column_levels).unique()

    # Unstack and post-process
    unstacked = unstack_to_array(sr, levels=(index_levels, column_levels))
    df = pd.DataFrame(unstacked, index=new_index, columns=new_columns)
    if symmetric:
        return make_symmetric(df)
    return df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.utils.reshape_fns.broadcast"><code class="name flex">
<span>def <span class="ident fname">broadcast</span></span>(<span>*args, to_shape=None, to_pd=None, index_from='default', columns_from='default', writeable=False, copy_kwargs={}, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Bring any array-like object in <code>args</code> to the same shape by using NumPy broadcasting.</p>
<p>See <a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">Broadcasting</a>.</p>
<p>Can broadcast pandas objects by broadcasting their index/columns with <code><a title="vectorbt.utils.reshape_fns.broadcast_index" href="#vectorbt.utils.reshape_fns.broadcast_index">broadcast_index()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Array-like objects.</dd>
<dt><strong><code>to_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Target shape. If set, will broadcast every element in <code>args</code> to <code>to_shape</code>.</dd>
<dt><strong><code>to_pd</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, converts all output arrays to pandas, otherwise returns raw NumPy
arrays. If <code>None</code>, converts only if there is at least one pandas object among them.</dd>
<dt><strong><code>index_from</code></strong> :&ensp;<code>None, int, str</code> or <code>array_like</code></dt>
<dd>Broadcasting rule for index.</dd>
<dt><strong><code>columns_from</code></strong> :&ensp;<code>None, int, str</code> or <code>array_like</code></dt>
<dd>Broadcasting rule for columns.</dd>
<dt><strong><code>writable</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>If <code>True</code>, makes broadcasted arrays writable, otherwise readonly.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Has effect only if broadcasting was needed for that particular array.</p>
<p>Making arrays writable is possible only through copying them, which is pretty expensive.</p>
<p>Numba requires arrays to be writable.</p>
</div>
</dd>
<dt><strong><code>copy_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Keyword arguments passed to <code>np.array</code>. For example, to specify <code>order</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Has effect on every array, independent from whether broadcasting was needed or not.</p>
</div>
</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.utils.reshape_fns.broadcast_index" href="#vectorbt.utils.reshape_fns.broadcast_index">broadcast_index()</a></code>.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.defaults.broadcasting" href="../defaults.html#vectorbt.defaults.broadcasting">broadcasting</a></code>.</p>
<h2 id="example">Example</h2>
<p>Without broadcasting index and columns:</p>
<pre><code class="python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from vectorbt.utils.reshape_fns import broadcast

&gt;&gt;&gt; v = 0
&gt;&gt;&gt; a = np.array([1, 2, 3])
&gt;&gt;&gt; sr = pd.Series([1, 2, 3], index=pd.Index(['x', 'y', 'z']), name='a')
&gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 
...     index=pd.Index(['x2', 'y2', 'z2']), 
...     columns=pd.Index(['a2', 'b2', 'c2']))

&gt;&gt;&gt; for i in broadcast(
...     v, a, sr, df,
...     index_from=None,
...     columns_from=None,
... ): print(i)
[[0 0 0]
[0 0 0]
[0 0 0]]
[[1 2 3]
[1 2 3]
[1 2 3]]
   a  a  a
x  1  1  1
y  2  2  2
z  3  3  3
    a2  b2  c2
x2   1   2   3
y2   4   5   6
z2   7   8   9
</code></pre>
<p>Taking new index and columns from position:</p>
<pre><code class="python-repl">&gt;&gt;&gt; for i in broadcast(
...     v, a, sr, df,
...     index_from=2,
...     columns_from=3
... ): print(i)
   a2  b2  c2
x   0   0   0
y   0   0   0
z   0   0   0
   a2  b2  c2
x   1   2   3
y   1   2   3
z   1   2   3
   a2  b2  c2
x   1   1   1
y   2   2   2
z   3   3   3
   a2  b2  c2
x   1   2   3
y   4   5   6
z   7   8   9
</code></pre>
<p>Broadcasting index and columns through stacking:</p>
<pre><code class="python-repl">&gt;&gt;&gt; for i in broadcast(
...     v, a, sr, df,
...     index_from='stack',
...     columns_from='stack'
... ): print(i)
      a2  b2  c2
x x2   0   0   0
y y2   0   0   0
z z2   0   0   0
      a2  b2  c2
x x2   1   2   3
y y2   1   2   3
z z2   1   2   3
      a2  b2  c2
x x2   1   1   1
y y2   2   2   2
z z2   3   3   3
      a2  b2  c2
x x2   1   2   3
y y2   4   5   6
z z2   7   8   9
</code></pre>
<p>Setting index and columns manually:</p>
<pre><code class="python-repl">&gt;&gt;&gt; for i in broadcast(
...     v, a, sr, df,
...     index_from=['a', 'b', 'c'],
...     columns_from=['d', 'e', 'f']
... ): print(i)
   d  e  f
a  0  0  0
b  0  0  0
c  0  0  0
   d  e  f
a  1  2  3
b  1  2  3
c  1  2  3
   d  e  f
a  1  1  1
b  2  2  2
c  3  3  3
   d  e  f
a  1  2  3
b  4  5  6
c  7  8  9
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcast(*args, to_shape=None, to_pd=None, index_from=&#39;default&#39;, columns_from=&#39;default&#39;, writeable=False, copy_kwargs={}, **kwargs):
    &#34;&#34;&#34;Bring any array-like object in `args` to the same shape by using NumPy broadcasting.

    See [Broadcasting](https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html).

    Can broadcast pandas objects by broadcasting their index/columns with `broadcast_index`.

    Args:
        *args (array_like): Array-like objects.
        to_shape (tuple): Target shape. If set, will broadcast every element in `args` to `to_shape`.
        to_pd (bool): If `True`, converts all output arrays to pandas, otherwise returns raw NumPy 
            arrays. If `None`, converts only if there is at least one pandas object among them.
        index_from (None, int, str or array_like): Broadcasting rule for index.
        columns_from (None, int, str or array_like): Broadcasting rule for columns.
        writable (bool): If `True`, makes broadcasted arrays writable, otherwise readonly.

            !!! note
                Has effect only if broadcasting was needed for that particular array.

                Making arrays writable is possible only through copying them, which is pretty expensive.

                Numba requires arrays to be writable.

        copy_kwargs (dict): Keyword arguments passed to `np.array`. For example, to specify `order`.

            !!! note
                Has effect on every array, independent from whether broadcasting was needed or not.

        **kwargs: Keyword arguments passed to `broadcast_index`.

    For defaults, see `vectorbt.defaults.broadcasting`.

    Example:
        Without broadcasting index and columns:

        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.utils.reshape_fns import broadcast

        &gt;&gt;&gt; v = 0
        &gt;&gt;&gt; a = np.array([1, 2, 3])
        &gt;&gt;&gt; sr = pd.Series([1, 2, 3], index=pd.Index([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]), name=&#39;a&#39;)
        &gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 
        ...     index=pd.Index([&#39;x2&#39;, &#39;y2&#39;, &#39;z2&#39;]), 
        ...     columns=pd.Index([&#39;a2&#39;, &#39;b2&#39;, &#39;c2&#39;]))

        &gt;&gt;&gt; for i in broadcast(
        ...     v, a, sr, df,
        ...     index_from=None,
        ...     columns_from=None,
        ... ): print(i)
        [[0 0 0]
        [0 0 0]
        [0 0 0]]
        [[1 2 3]
        [1 2 3]
        [1 2 3]]
           a  a  a
        x  1  1  1
        y  2  2  2
        z  3  3  3
            a2  b2  c2
        x2   1   2   3
        y2   4   5   6
        z2   7   8   9
        ```

        Taking new index and columns from position:

        ```python-repl
        &gt;&gt;&gt; for i in broadcast(
        ...     v, a, sr, df,
        ...     index_from=2,
        ...     columns_from=3
        ... ): print(i)
           a2  b2  c2
        x   0   0   0
        y   0   0   0
        z   0   0   0
           a2  b2  c2
        x   1   2   3
        y   1   2   3
        z   1   2   3
           a2  b2  c2
        x   1   1   1
        y   2   2   2
        z   3   3   3
           a2  b2  c2
        x   1   2   3
        y   4   5   6
        z   7   8   9
        ```

        Broadcasting index and columns through stacking:

        ```python-repl
        &gt;&gt;&gt; for i in broadcast(
        ...     v, a, sr, df,
        ...     index_from=&#39;stack&#39;,
        ...     columns_from=&#39;stack&#39;
        ... ): print(i)
              a2  b2  c2
        x x2   0   0   0
        y y2   0   0   0
        z z2   0   0   0
              a2  b2  c2
        x x2   1   2   3
        y y2   1   2   3
        z z2   1   2   3
              a2  b2  c2
        x x2   1   1   1
        y y2   2   2   2
        z z2   3   3   3
              a2  b2  c2
        x x2   1   2   3
        y y2   4   5   6
        z z2   7   8   9
        ```

        Setting index and columns manually:

        ```python-repl
        &gt;&gt;&gt; for i in broadcast(
        ...     v, a, sr, df,
        ...     index_from=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
        ...     columns_from=[&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
        ... ): print(i)
           d  e  f
        a  0  0  0
        b  0  0  0
        c  0  0  0
           d  e  f
        a  1  2  3
        b  1  2  3
        c  1  2  3
           d  e  f
        a  1  1  1
        b  2  2  2
        c  3  3  3
           d  e  f
        a  1  2  3
        b  4  5  6
        c  7  8  9
        ```
    &#34;&#34;&#34;
    is_pd = False
    is_2d = False
    args = list(args)
    if isinstance(index_from, str) and index_from == &#39;default&#39;:
        index_from = defaults.broadcasting[&#39;index_from&#39;]
    if isinstance(columns_from, str) and columns_from == &#39;default&#39;:
        columns_from = defaults.broadcasting[&#39;columns_from&#39;]

    # Convert to np.ndarray object if not numpy or pandas
    # Also check whether we broadcast to pandas and whether work on 2-dim data
    for i in range(len(args)):
        if not checks.is_array(args[i]):
            args[i] = np.asarray(args[i])
        if args[i].ndim &gt; 1:
            is_2d = True
        if checks.is_pandas(args[i]):
            is_pd = True

    if to_pd is not None:
        is_pd = to_pd  # force either raw or pandas

    # If target shape specified, check again if we work on 2-dim data
    if to_shape is not None:
        checks.assert_type(to_shape, tuple)
        if len(to_shape) &gt; 1:
            is_2d = True

    # Convert all pd.Series objects to pd.DataFrame if we work on 2-dim data
    if is_2d:
        for i in range(len(args)):
            if checks.is_series(args[i]):
                args[i] = args[i].to_frame()

    if is_pd:
        # Decide on index and columns
        new_index = broadcast_index(*args, to_shape=to_shape, index_from=index_from, axis=0, **kwargs)
        new_columns = broadcast_index(*args, to_shape=to_shape, index_from=columns_from, axis=1, **kwargs)
    else:
        new_index, new_columns = None, None

    # Perform broadcasting
    if to_shape is None:
        new_args = np.broadcast_arrays(*args, subok=True)
    else:
        new_args = []
        for arg in args:
            new_arg = np.broadcast_to(arg, to_shape, subok=True)
            new_args.append(new_arg)

    # The problem is that broadcasting creates readonly objects and numba requires writable ones.
    # To make them writable we must copy, which is ok for small-sized arrays and not ok for large ones.
    # Thus check if broadcasting was needed in the first place, and if so, copy
    for i in range(len(new_args)):
        if new_args[i].shape == args[i].shape:
            # Broadcasting was not needed, take old array
            new_args[i] = np.array(args[i], copy=False, **copy_kwargs)
        else:
            # Broadcasting was needed, take new array
            new_args[i] = np.array(new_args[i], copy=writeable, **copy_kwargs)

    # Bring arrays to their old types (e.g. array -&gt; pandas)
    for i in range(len(new_args)):
        new_args[i] = wrap_broadcasted(args[i], new_args[i], is_pd=is_pd, new_index=new_index, new_columns=new_columns)

    if len(new_args) &gt; 1:
        return tuple(new_args)
    return new_args[0]</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.reshape_fns.broadcast_index"><code class="name flex">
<span>def <span class="ident fname">broadcast_index</span></span>(<span>*args, to_shape=None, index_from=None, axis=0, ignore_single='default', drop_duplicates='default', keep='default')</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a broadcasted index/columns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Array-like objects.</dd>
<dt><strong><code>to_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Target shape. Optional.</dd>
<dt><strong><code>index_from</code></strong> :&ensp;<code>None, int, str</code> or <code>array_like</code></dt>
<dd>
<p>Broadcasting rule for this index/these columns.</p>
<p>Accepts the following values:</p>
<ul>
<li><code>'default'</code> - take the value from <code><a title="vectorbt.defaults.broadcasting" href="../defaults.html#vectorbt.defaults.broadcasting">broadcasting</a></code></li>
<li><code>None</code> - use the original index/columns of the objects in <code>args</code></li>
<li><code>int</code> - use the index/columns of the i-nth object in <code>args</code></li>
<li><code>'strict'</code> - ensure that all pandas objects have the same index/columns</li>
<li><code>'stack'</code> - stack different indexes/columns using <code><a title="vectorbt.utils.index_fns.stack_indexes" href="index_fns.html#vectorbt.utils.index_fns.stack_indexes">stack_indexes()</a></code></li>
<li>everything else will be converted to <code>pd.Index</code></li>
</ul>
</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code></dt>
<dd>Set to 0 for index and 1 for columns.</dd>
<dt><strong><code>ignore_single</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, ignores indexes/columns with one value, otherwise they will be repeated
to match the length of the longest index/columns (can lead to pollution of levels).</dd>
<dt><strong><code>drop_duplicates</code></strong> :&ensp;<code>bool</code></dt>
<dd>See <code><a title="vectorbt.utils.index_fns.drop_duplicate_levels" href="index_fns.html#vectorbt.utils.index_fns.drop_duplicate_levels">drop_duplicate_levels()</a></code>.</dd>
<dt><strong><code>keep</code></strong> :&ensp;<code>bool</code></dt>
<dd>See <code><a title="vectorbt.utils.index_fns.drop_duplicate_levels" href="index_fns.html#vectorbt.utils.index_fns.drop_duplicate_levels">drop_duplicate_levels()</a></code>.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.defaults.broadcasting" href="../defaults.html#vectorbt.defaults.broadcasting">broadcasting</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcast_index(*args, to_shape=None, index_from=None, axis=0, ignore_single=&#39;default&#39;, drop_duplicates=&#39;default&#39;, keep=&#39;default&#39;):
    &#34;&#34;&#34;Produce a broadcasted index/columns.

    Args:
        *args (array_like): Array-like objects.
        to_shape (tuple): Target shape. Optional.
        index_from (None, int, str or array_like): Broadcasting rule for this index/these columns.

            Accepts the following values:

            * `&#39;default&#39;` - take the value from `vectorbt.defaults.broadcasting`
            * `None` - use the original index/columns of the objects in `args`
            * `int` - use the index/columns of the i-nth object in `args`
            * `&#39;strict&#39;` - ensure that all pandas objects have the same index/columns
            * `&#39;stack&#39;` - stack different indexes/columns using `vectorbt.utils.index_fns.stack_indexes`
            * everything else will be converted to `pd.Index`

        axis (int): Set to 0 for index and 1 for columns.
        ignore_single (bool): If `True`, ignores indexes/columns with one value, otherwise they will be repeated
            to match the length of the longest index/columns (can lead to pollution of levels).
        drop_duplicates (bool): See `vectorbt.utils.index_fns.drop_duplicate_levels`.
        keep (bool): See `vectorbt.utils.index_fns.drop_duplicate_levels`.

    For defaults, see `vectorbt.defaults.broadcasting`.
    &#34;&#34;&#34;

    if ignore_single == &#39;default&#39;:
        ignore_single = defaults.broadcasting[&#39;ignore_single&#39;]
    if drop_duplicates == &#39;default&#39;:
        drop_duplicates = defaults.broadcasting[&#39;drop_duplicates&#39;]
    if keep == &#39;default&#39;:
        keep = defaults.broadcasting[&#39;keep&#39;]
    index_str = &#39;columns&#39; if axis == 1 else &#39;index&#39;
    new_index = None

    if index_from is not None:
        if isinstance(index_from, int):
            # Take index/columns of the object indexed by index_from
            if axis == 1:
                new_index = to_2d(args[index_from]).columns
            else:
                new_index = args[index_from].index
        elif isinstance(index_from, str):
            if index_from in (&#39;stack&#39;, &#39;strict&#39;):
                # If pandas objects have different index/columns, stack them together
                # maxlen stores the length of the longest index
                if to_shape is None:
                    # Simulate broadcasting
                    to_shape = np.lib.stride_tricks._broadcast_shape(*args)
                if axis == 1 and len(to_shape) == 1:
                    to_shape = (to_shape[0], 1)
                maxlen = to_shape[1] if axis == 1 else to_shape[0]
                for arg in args:
                    if checks.is_pandas(arg):
                        if checks.is_series(arg):
                            arg = arg.to_frame()  # series name counts as a column
                        index = arg.columns if axis == 1 else arg.index
                        if new_index is None:
                            new_index = index
                        else:
                            if index_from == &#39;strict&#39;:
                                # If pandas objects have different index/columns, raise an exception
                                if not pd.Index.equals(index, new_index):
                                    raise ValueError(
                                        f&#34;Broadcasting {index_str} is not allowed for {index_str}_from=strict&#34;)
                            # Broadcasting index must follow the rules of a regular broadcasting operation
                            # https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html#general-broadcasting-rules
                            # 1. rule: if indexes are of the same length, they are simply stacked
                            # 2. rule: if index has one element, it gets repeated and then stacked

                            if pd.Index.equals(index, new_index):
                                continue
                            if len(index) != len(new_index):
                                if len(index) &gt; 1 and len(new_index) &gt; 1:
                                    raise ValueError(&#34;Indexes could not be broadcast together&#34;)
                                if ignore_single:
                                    # Columns of length 1 should be simply ignored
                                    if len(index) &gt; len(new_index):
                                        new_index = index
                                    continue
                                else:
                                    if len(index) &gt; len(new_index):
                                        new_index = index_fns.repeat_index(new_index, len(index))
                                    elif len(index) &lt; len(new_index):
                                        index = index_fns.repeat_index(index, len(new_index))
                            new_index = index_fns.stack_indexes(new_index, index)
                            if drop_duplicates:
                                new_index = index_fns.drop_duplicate_levels(new_index, keep=keep)
                if maxlen &gt; len(new_index):
                    if index_from == &#39;strict&#39;:
                        raise ValueError(f&#34;Broadcasting {index_str} is not allowed for {index_str}_from=strict&#34;)
                    # This happens only when some numpy object is longer than the new pandas index
                    # In this case, new pandas index (one element) should be repeated to match this length.
                    if maxlen &gt; 1 and len(new_index) &gt; 1:
                        raise ValueError(&#34;Indexes could not be broadcast together&#34;)
                    new_index = index_fns.repeat_index(new_index, maxlen)
            else:
                raise ValueError(f&#34;Invalid value {index_from} for {&#39;columns&#39; if axis == 1 else &#39;index&#39;}_from&#34;)
        else:
            new_index = index_from
    return new_index</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.reshape_fns.broadcast_to"><code class="name flex">
<span>def <span class="ident fname">broadcast_to</span></span>(<span>arg1, arg2, to_pd=None, index_from=None, columns_from=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Broadcast <code>arg1</code> to <code>arg2</code>.</p>
<p>Keyword arguments <code>**kwargs</code> are passed to <code><a title="vectorbt.utils.reshape_fns.broadcast" href="#vectorbt.utils.reshape_fns.broadcast">broadcast()</a></code>.</p>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from vectorbt.utils.reshape_fns import broadcast_to

&gt;&gt;&gt; a = np.array([1, 2, 3])
&gt;&gt;&gt; sr = pd.Series([4, 5, 6], index=pd.Index(['x', 'y', 'z']), name='a')

&gt;&gt;&gt; print(broadcast_to(a, sr))
x    1
y    2
z    3
Name: a, dtype: int64

&gt;&gt;&gt; print(broadcast_to(sr, a))
array([4, 5, 6])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcast_to(arg1, arg2, to_pd=None, index_from=None, columns_from=None, **kwargs):
    &#34;&#34;&#34;Broadcast `arg1` to `arg2`.

    Keyword arguments `**kwargs` are passed to `broadcast`.

    Example:
        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.utils.reshape_fns import broadcast_to

        &gt;&gt;&gt; a = np.array([1, 2, 3])
        &gt;&gt;&gt; sr = pd.Series([4, 5, 6], index=pd.Index([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]), name=&#39;a&#39;)

        &gt;&gt;&gt; print(broadcast_to(a, sr))
        x    1
        y    2
        z    3
        Name: a, dtype: int64

        &gt;&gt;&gt; print(broadcast_to(sr, a))
        array([4, 5, 6])
        ```&#34;&#34;&#34;
    if not checks.is_array(arg1):
        arg1 = np.asarray(arg1)
    if not checks.is_array(arg2):
        arg2 = np.asarray(arg2)
    if to_pd is None:
        to_pd = checks.is_pandas(arg2)
    if to_pd:
        # Take index and columns from arg2
        if index_from is None:
            index_from = arg2.index
        if columns_from is None:
            columns_from = to_2d(arg2).columns
    return broadcast(arg1, to_shape=arg2.shape, to_pd=to_pd, index_from=index_from, columns_from=columns_from, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.reshape_fns.broadcast_to_array_of"><code class="name flex">
<span>def <span class="ident fname">broadcast_to_array_of</span></span>(<span>arg1, arg2)</span>
</code></dt>
<dd>
<div class="desc"><p>Broadcast <code>arg1</code> to the shape <code>(1, *arg2.shape)</code>.</p>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from vectorbt.utils.reshape_fns import broadcast_to_array_of

&gt;&gt;&gt; print(broadcast_to_array_of([0.1, 0.2], np.empty((2, 2))))
[[[0.1 0.1]
  [0.1 0.1]]

 [[0.2 0.2]
  [0.2 0.2]]]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcast_to_array_of(arg1, arg2):
    &#34;&#34;&#34;Broadcast `arg1` to the shape `(1, *arg2.shape)`.

    Example:
        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from vectorbt.utils.reshape_fns import broadcast_to_array_of

        &gt;&gt;&gt; print(broadcast_to_array_of([0.1, 0.2], np.empty((2, 2))))
        [[[0.1 0.1]
          [0.1 0.1]]

         [[0.2 0.2]
          [0.2 0.2]]]
        ```&#34;&#34;&#34;
    arg1 = np.asarray(arg1)
    arg2 = np.asarray(arg2)
    if arg1.ndim == arg2.ndim + 1:
        if arg1.shape[1:] == arg2.shape:
            return arg1
    # From here on arg1 can be only a 1-dim array
    if arg1.ndim == 0:
        arg1 = to_1d(arg1)
    checks.assert_ndim(arg1, 1)

    if arg2.ndim == 0:
        return arg1
    for i in range(arg2.ndim):
        arg1 = np.expand_dims(arg1, axis=-1)
    return np.tile(arg1, (1, *arg2.shape))</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.reshape_fns.make_symmetric"><code class="name flex">
<span>def <span class="ident fname">make_symmetric</span></span>(<span>arg)</span>
</code></dt>
<dd>
<div class="desc"><p>Make <code>arg</code> symmetric.</p>
<p>The index and columns of the resulting DataFrame will be identical.</p>
<p>Requires the index and columns to have the same number of levels.</p>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from vectorbt.utils.reshape_fns import make_symmetric

&gt;&gt;&gt; df = pd.DataFrame([[1, 2], [3, 4]], index=['a', 'b'], columns=['c', 'd'])

&gt;&gt;&gt; print(make_symmetric(df))
     a    b    c    d
a  NaN  NaN  1.0  2.0
b  NaN  NaN  3.0  4.0
c  1.0  3.0  NaN  NaN
d  2.0  4.0  NaN  NaN
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_symmetric(arg):
    &#34;&#34;&#34;Make `arg` symmetric.

    The index and columns of the resulting DataFrame will be identical.

    Requires the index and columns to have the same number of levels.

    Example:
        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.utils.reshape_fns import make_symmetric

        &gt;&gt;&gt; df = pd.DataFrame([[1, 2], [3, 4]], index=[&#39;a&#39;, &#39;b&#39;], columns=[&#39;c&#39;, &#39;d&#39;])

        &gt;&gt;&gt; print(make_symmetric(df))
             a    b    c    d
        a  NaN  NaN  1.0  2.0
        b  NaN  NaN  3.0  4.0
        c  1.0  3.0  NaN  NaN
        d  2.0  4.0  NaN  NaN
        ```&#34;&#34;&#34;
    checks.assert_type(arg, (pd.Series, pd.DataFrame))
    arg = to_2d(arg)
    checks.assert_same_type(arg.index, arg.columns)
    if isinstance(arg.index, pd.MultiIndex):
        checks.assert_same_len(arg.index.names, arg.columns.names)
        names1, names2 = tuple(arg.index.names), tuple(arg.columns.names)
    else:
        names1, names2 = arg.index.name, arg.columns.name

    if names1 == names2:
        new_name = names1
    else:
        if isinstance(arg.index, pd.MultiIndex):
            new_name = tuple(zip(*[names1, names2]))
        else:
            new_name = (names1, names2)
    idx_vals = np.unique(np.concatenate((arg.index, arg.columns)))
    arg = arg.copy()
    if isinstance(arg.index, pd.MultiIndex):
        unique_index = pd.MultiIndex.from_tuples(idx_vals, names=new_name)
        arg.index.names = new_name
        arg.columns.names = new_name
    else:
        unique_index = pd.Index(idx_vals, name=new_name)
        arg.index.name = new_name
        arg.columns.name = new_name
    df_out = pd.DataFrame(index=unique_index, columns=unique_index)
    df_out.loc[:, :] = arg
    df_out[df_out.isnull()] = arg.transpose()
    return df_out</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.reshape_fns.repeat"><code class="name flex">
<span>def <span class="ident fname">repeat</span></span>(<span>arg, n, axis=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Repeat each element in <code>arg</code> <code>n</code> times along the specified axis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat(arg, n, axis=1):
    &#34;&#34;&#34;Repeat each element in `arg` `n` times along the specified axis.&#34;&#34;&#34;
    if not checks.is_array(arg):
        arg = np.asarray(arg)
    if axis == 0:
        if checks.is_pandas(arg):
            return ArrayWrapper.from_obj(arg).wrap(
                np.repeat(arg.values, n, axis=0), index=index_fns.repeat_index(arg.index, n))
        return np.repeat(arg, n, axis=0)
    elif axis == 1:
        arg = to_2d(arg)
        if checks.is_pandas(arg):
            return ArrayWrapper.from_obj(arg).wrap(
                np.repeat(arg.values, n, axis=1), columns=index_fns.repeat_index(arg.columns, n))
        return np.repeat(arg, n, axis=1)
    else:
        raise ValueError(&#34;Only axis 0 and 1 are supported&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.reshape_fns.soft_broadcast_to_ndim"><code class="name flex">
<span>def <span class="ident fname">soft_broadcast_to_ndim</span></span>(<span>arg, ndim)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to softly bring <code>arg</code> to the specified number of dimensions <code>ndim</code> (max 2).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soft_broadcast_to_ndim(arg, ndim):
    &#34;&#34;&#34;Try to softly bring `arg` to the specified number of dimensions `ndim` (max 2).&#34;&#34;&#34;
    if not checks.is_array(arg):
        arg = np.asarray(arg)
    if ndim == 1:
        if arg.ndim == 2:
            if arg.shape[1] == 1:
                if checks.is_pandas(arg):
                    return arg.iloc[:, 0]
                return arg[:, 0]  # downgrade
    if ndim == 2:
        if arg.ndim == 1:
            if checks.is_pandas(arg):
                return arg.to_frame()
            return arg[:, None]  # upgrade
    return arg  # do nothing</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.reshape_fns.tile"><code class="name flex">
<span>def <span class="ident fname">tile</span></span>(<span>arg, n, axis=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Repeat the whole <code>arg</code> <code>n</code> times along the specified axis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tile(arg, n, axis=1):
    &#34;&#34;&#34;Repeat the whole `arg` `n` times along the specified axis.&#34;&#34;&#34;
    if not checks.is_array(arg):
        arg = np.asarray(arg)
    if axis == 0:
        if arg.ndim == 1:
            if checks.is_pandas(arg):
                return ArrayWrapper.from_obj(arg).wrap(
                    np.tile(arg.values, n), index=index_fns.tile_index(arg.index, n))
            return np.tile(arg, n)
        if arg.ndim == 2:
            if checks.is_pandas(arg):
                return ArrayWrapper.from_obj(arg).wrap(
                    np.tile(arg.values, (n, 1)), index=index_fns.tile_index(arg.index, n))
            return np.tile(arg, (n, 1))
    elif axis == 1:
        arg = to_2d(arg)
        if checks.is_pandas(arg):
            return ArrayWrapper.from_obj(arg).wrap(
                    np.tile(arg.values, (1, n)), columns=index_fns.tile_index(arg.columns, n))
        return np.tile(arg, (1, n))
    else:
        raise ValueError(&#34;Only axis 0 and 1 are supported&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.reshape_fns.to_1d"><code class="name flex">
<span>def <span class="ident fname">to_1d</span></span>(<span>arg, raw=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Reshape argument to one dimension. </p>
<p>If <code>raw</code> is <code>True</code>, returns NumPy array.
If 2-dim, will collapse along axis 1 (i.e., DataFrame with one column to Series).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_1d(arg, raw=False):
    &#34;&#34;&#34;Reshape argument to one dimension. 

    If `raw` is `True`, returns NumPy array.
    If 2-dim, will collapse along axis 1 (i.e., DataFrame with one column to Series).&#34;&#34;&#34;
    if raw or not checks.is_array(arg):
        arg = np.asarray(arg)
    if arg.ndim == 2:
        if arg.shape[1] == 1:
            if checks.is_frame(arg):
                return arg.iloc[:, 0]
            return arg[:, 0]
    if arg.ndim == 1:
        return arg
    elif arg.ndim == 0:
        return arg.reshape((1,))
    raise ValueError(f&#34;Cannot reshape a {arg.ndim}-dimensional array to 1 dimension&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.reshape_fns.to_2d"><code class="name flex">
<span>def <span class="ident fname">to_2d</span></span>(<span>arg, raw=False, expand_axis=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Reshape argument to two dimensions. </p>
<p>If <code>raw</code> is <code>True</code>, returns NumPy array.
If 1-dim, will expand along axis 1 (i.e., Series to DataFrame with one column).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_2d(arg, raw=False, expand_axis=1):
    &#34;&#34;&#34;Reshape argument to two dimensions. 

    If `raw` is `True`, returns NumPy array.
    If 1-dim, will expand along axis 1 (i.e., Series to DataFrame with one column).&#34;&#34;&#34;
    if raw or not checks.is_array(arg):
        arg = np.asarray(arg)
    if arg.ndim == 2:
        return arg
    elif arg.ndim == 1:
        if checks.is_series(arg):
            if expand_axis == 0:
                return pd.DataFrame(arg.values[None, :], columns=arg.index)
            elif expand_axis == 1:
                return arg.to_frame()
        return np.expand_dims(arg, expand_axis)
    elif arg.ndim == 0:
        return arg.reshape((1, 1))
    raise ValueError(f&#34;Cannot reshape a {arg.ndim}-dimensional array to 2 dimensions&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.reshape_fns.unstack_to_array"><code class="name flex">
<span>def <span class="ident fname">unstack_to_array</span></span>(<span>arg, levels=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Reshape <code>arg</code> based on its multi-index into a multi-dimensional array.</p>
<p>Use <code>levels</code> to specify what index levels to unstack and in which order.</p>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from vectorbt.utils.reshape_fns import unstack_to_array

&gt;&gt;&gt; index = pd.MultiIndex.from_arrays(
...     [[1, 1, 2, 2], [3, 4, 3, 4], ['a', 'b', 'c', 'd']])
&gt;&gt;&gt; sr = pd.Series([1, 2, 3, 4], index=index)

&gt;&gt;&gt; print(unstack_to_array(sr).shape)
(2, 2, 4)

&gt;&gt;&gt; print(unstack_to_array(sr))
[[[ 1. nan nan nan]
 [nan  2. nan nan]]

 [[nan nan  3. nan]
[nan nan nan  4.]]]

&gt;&gt;&gt; print(unstack_to_array(sr, levels=(2, 0)))
[[ 1. nan]
 [ 2. nan]
 [nan  3.]
 [nan  4.]]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack_to_array(arg, levels=None):
    &#34;&#34;&#34;Reshape `arg` based on its multi-index into a multi-dimensional array.

    Use `levels` to specify what index levels to unstack and in which order.

    Example:
        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.utils.reshape_fns import unstack_to_array

        &gt;&gt;&gt; index = pd.MultiIndex.from_arrays(
        ...     [[1, 1, 2, 2], [3, 4, 3, 4], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]])
        &gt;&gt;&gt; sr = pd.Series([1, 2, 3, 4], index=index)

        &gt;&gt;&gt; print(unstack_to_array(sr).shape)
        (2, 2, 4)

        &gt;&gt;&gt; print(unstack_to_array(sr))
        [[[ 1. nan nan nan]
         [nan  2. nan nan]]

         [[nan nan  3. nan]
        [nan nan nan  4.]]]

        &gt;&gt;&gt; print(unstack_to_array(sr, levels=(2, 0)))
        [[ 1. nan]
         [ 2. nan]
         [nan  3.]
         [nan  4.]]
        ```&#34;&#34;&#34;
    checks.assert_type(arg, pd.Series)
    checks.assert_type(arg.index, pd.MultiIndex)

    unique_idx_list = []
    vals_idx_list = []
    if levels is None:
        levels = range(len(arg.index.levels))
    for level in levels:
        vals = index_fns.select_levels(arg.index, level).to_numpy()
        unique_vals = np.unique(vals)
        unique_idx_list.append(unique_vals)
        idx_map = dict(zip(unique_vals, range(len(unique_vals))))
        vals_idx = list(map(lambda x: idx_map[x], vals))
        vals_idx_list.append(vals_idx)

    a = np.full(list(map(len, unique_idx_list)), np.nan)
    a[tuple(zip(vals_idx_list))] = arg.values
    return a</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.reshape_fns.unstack_to_df"><code class="name flex">
<span>def <span class="ident fname">unstack_to_df</span></span>(<span>arg, index_levels=None, column_levels=None, symmetric=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Reshape <code>arg</code> based on its multi-index into a DataFrame.</p>
<p>Use <code>index_levels</code> to specify what index levels will form new index, and <code>column_levels</code>
for new columns. Set <code>symmetric</code> to <code>True</code> to make DataFrame symmetric.</p>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from vectorbt.utils.reshape_fns import unstack_to_df

&gt;&gt;&gt; index = pd.MultiIndex.from_arrays(
...     [[1, 1, 2, 2], [3, 4, 3, 4], ['a', 'b', 'c', 'd']], 
...     names=['x', 'y', 'z'])
&gt;&gt;&gt; sr = pd.Series([1, 2, 3, 4], index=index)

&gt;&gt;&gt; print(unstack_to_df(sr, index_levels=(0, 1), column_levels=2))
z      a    b    c    d
x y                    
1 3  1.0  NaN  NaN  NaN
1 4  NaN  2.0  NaN  NaN
2 3  NaN  NaN  3.0  NaN
2 4  NaN  NaN  NaN  4.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack_to_df(arg, index_levels=None, column_levels=None, symmetric=False):
    &#34;&#34;&#34;Reshape `arg` based on its multi-index into a DataFrame.

    Use `index_levels` to specify what index levels will form new index, and `column_levels` 
    for new columns. Set `symmetric` to `True` to make DataFrame symmetric.

    Example:
        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.utils.reshape_fns import unstack_to_df

        &gt;&gt;&gt; index = pd.MultiIndex.from_arrays(
        ...     [[1, 1, 2, 2], [3, 4, 3, 4], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]], 
        ...     names=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])
        &gt;&gt;&gt; sr = pd.Series([1, 2, 3, 4], index=index)

        &gt;&gt;&gt; print(unstack_to_df(sr, index_levels=(0, 1), column_levels=2))
        z      a    b    c    d
        x y                    
        1 3  1.0  NaN  NaN  NaN
        1 4  NaN  2.0  NaN  NaN
        2 3  NaN  NaN  3.0  NaN
        2 4  NaN  NaN  NaN  4.0
        ```&#34;&#34;&#34;
    # Perform checks
    checks.assert_type(arg, (pd.Series, pd.DataFrame))
    if checks.is_frame(arg):
        if arg.shape[0] == 1:
            arg = arg.iloc[0, :]
        elif arg.shape[1] == 1:
            arg = arg.iloc[:, 0]
    checks.assert_type(arg.index, pd.MultiIndex)
    sr = to_1d(arg)

    if len(sr.index.levels) &gt; 2:
        checks.assert_not_none(index_levels)
        checks.assert_not_none(column_levels)
    else:
        index_levels = 0
        column_levels = 1

    # Build new index and column hierarchies
    new_index = index_fns.select_levels(arg.index, index_levels).unique()
    new_columns = index_fns.select_levels(arg.index, column_levels).unique()

    # Unstack and post-process
    unstacked = unstack_to_array(sr, levels=(index_levels, column_levels))
    df = pd.DataFrame(unstacked, index=new_index, columns=new_columns)
    if symmetric:
        return make_symmetric(df)
    return df</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.reshape_fns.wrap_broadcasted"><code class="name flex">
<span>def <span class="ident fname">wrap_broadcasted</span></span>(<span>old_arg, new_arg, is_pd=False, new_index=None, new_columns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>If the newly brodcasted array was originally a pandas object, make it pandas object again
and assign it the newly broadcasted index/columns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_broadcasted(old_arg, new_arg, is_pd=False, new_index=None, new_columns=None):
    &#34;&#34;&#34;If the newly brodcasted array was originally a pandas object, make it pandas object again 
    and assign it the newly broadcasted index/columns.&#34;&#34;&#34;
    if is_pd:
        if checks.is_pandas(old_arg):
            if new_index is None:
                # Take index from original pandas object
                if old_arg.shape[0] == new_arg.shape[0]:
                    new_index = old_arg.index
                else:
                    new_index = index_fns.repeat_index(old_arg.index, new_arg.shape[0])
            if new_columns is None:
                # Take columns from original pandas object
                if new_arg.ndim == 2:
                    if checks.is_series(old_arg):
                        old_arg = old_arg.to_frame()
                    if old_arg.shape[1] == new_arg.shape[1]:
                        new_columns = old_arg.columns
                    else:
                        new_columns = index_fns.repeat_index(old_arg.columns, new_arg.shape[1])
        else:
            if new_index is None and new_columns is None:
                # Return plain numpy array if not pandas and no rules set
                return new_arg
        return ArrayWrapper(index=new_index, columns=new_columns).wrap(new_arg)
    return new_arg</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.utils.reshape_fns.ArrayWrapper"><code class="flex name class">
<span>class <span class="ident parent-fname">ArrayWrapper</span></span>
<span>(</span><span>index=None, columns=None, ndim=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that stores index, columns and shape metadata for wrapping NumPy arrays.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArrayWrapper():
    &#34;&#34;&#34;Class that stores index, columns and shape metadata for wrapping NumPy arrays.&#34;&#34;&#34;
    def __init__(self, index=None, columns=None, ndim=None):
        self.index = index
        self.columns = columns
        self.ndim = ndim
        
    @classmethod
    def from_obj(cls, obj):
        &#34;&#34;&#34;Derive metadata from an object.&#34;&#34;&#34;
        index = obj.index
        if checks.is_frame(obj):
            columns = obj.columns
        else:
            columns = [obj.name]
        ndim = obj.ndim
        return cls(index=index, columns=columns, ndim=ndim)
        
    def wrap(self, arg, index=None, columns=None, ndim=None, dtype=None):
        &#34;&#34;&#34;Wrap a NumPy array using the stored metadata.&#34;&#34;&#34;
        arg = np.asarray(arg)
        if ndim is None:
            ndim = self.ndim
        if ndim is not None:
            arg = soft_broadcast_to_ndim(arg, self.ndim)
        if index is None:
            index = self.index
        if columns is None:
            columns = self.columns
        if columns is not None and len(columns) == 1:
            name = columns[0]
        else:
            name = None

        # Perform checks
        if index is not None:
            checks.assert_same_shape(arg, index, axis=(0, 0))
        if arg.ndim == 2 and columns is not None:
            checks.assert_same_shape(arg, columns, axis=(1, 0))

        if arg.ndim == 1:
            return pd.Series(arg, index=index, name=name, dtype=dtype)
        return pd.DataFrame(arg, index=index, columns=columns, dtype=dtype)</code></pre>
</details>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.timeseries.common.TSArrayWrapper" href="../timeseries/common.html#vectorbt.timeseries.common.TSArrayWrapper">TSArrayWrapper</a></li>
<li><a title="vectorbt.utils.accessors.Base_Accessor" href="accessors.html#vectorbt.utils.accessors.Base_Accessor">Base_Accessor</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.utils.reshape_fns.ArrayWrapper.from_obj"><code class="name flex">
<span>def <span class="ident fname">from_obj</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Derive metadata from an object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_obj(cls, obj):
    &#34;&#34;&#34;Derive metadata from an object.&#34;&#34;&#34;
    index = obj.index
    if checks.is_frame(obj):
        columns = obj.columns
    else:
        columns = [obj.name]
    ndim = obj.ndim
    return cls(index=index, columns=columns, ndim=ndim)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.utils.reshape_fns.ArrayWrapper.wrap"><code class="name flex">
<span>def <span class="ident fname">wrap</span></span>(<span>self, arg, index=None, columns=None, ndim=None, dtype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrap a NumPy array using the stored metadata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap(self, arg, index=None, columns=None, ndim=None, dtype=None):
    &#34;&#34;&#34;Wrap a NumPy array using the stored metadata.&#34;&#34;&#34;
    arg = np.asarray(arg)
    if ndim is None:
        ndim = self.ndim
    if ndim is not None:
        arg = soft_broadcast_to_ndim(arg, self.ndim)
    if index is None:
        index = self.index
    if columns is None:
        columns = self.columns
    if columns is not None and len(columns) == 1:
        name = columns[0]
    else:
        name = None

    # Perform checks
    if index is not None:
        checks.assert_same_shape(arg, index, axis=(0, 0))
    if arg.ndim == 2 and columns is not None:
        checks.assert_same_shape(arg, columns, axis=(1, 0))

    if arg.ndim == 1:
        return pd.Series(arg, index=index, name=name, dtype=dtype)
    return pd.DataFrame(arg, index=index, columns=columns, dtype=dtype)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="https://github.com/polakowo/vectorbt/blob/master/logo.png?raw=true" alt=""> vectorbt
</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.utils" href="index.html">vectorbt.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.utils.reshape_fns.broadcast" href="#vectorbt.utils.reshape_fns.broadcast">broadcast</a></code></li>
<li><code><a title="vectorbt.utils.reshape_fns.broadcast_index" href="#vectorbt.utils.reshape_fns.broadcast_index">broadcast_index</a></code></li>
<li><code><a title="vectorbt.utils.reshape_fns.broadcast_to" href="#vectorbt.utils.reshape_fns.broadcast_to">broadcast_to</a></code></li>
<li><code><a title="vectorbt.utils.reshape_fns.broadcast_to_array_of" href="#vectorbt.utils.reshape_fns.broadcast_to_array_of">broadcast_to_array_of</a></code></li>
<li><code><a title="vectorbt.utils.reshape_fns.make_symmetric" href="#vectorbt.utils.reshape_fns.make_symmetric">make_symmetric</a></code></li>
<li><code><a title="vectorbt.utils.reshape_fns.repeat" href="#vectorbt.utils.reshape_fns.repeat">repeat</a></code></li>
<li><code><a title="vectorbt.utils.reshape_fns.soft_broadcast_to_ndim" href="#vectorbt.utils.reshape_fns.soft_broadcast_to_ndim">soft_broadcast_to_ndim</a></code></li>
<li><code><a title="vectorbt.utils.reshape_fns.tile" href="#vectorbt.utils.reshape_fns.tile">tile</a></code></li>
<li><code><a title="vectorbt.utils.reshape_fns.to_1d" href="#vectorbt.utils.reshape_fns.to_1d">to_1d</a></code></li>
<li><code><a title="vectorbt.utils.reshape_fns.to_2d" href="#vectorbt.utils.reshape_fns.to_2d">to_2d</a></code></li>
<li><code><a title="vectorbt.utils.reshape_fns.unstack_to_array" href="#vectorbt.utils.reshape_fns.unstack_to_array">unstack_to_array</a></code></li>
<li><code><a title="vectorbt.utils.reshape_fns.unstack_to_df" href="#vectorbt.utils.reshape_fns.unstack_to_df">unstack_to_df</a></code></li>
<li><code><a title="vectorbt.utils.reshape_fns.wrap_broadcasted" href="#vectorbt.utils.reshape_fns.wrap_broadcasted">wrap_broadcasted</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.utils.reshape_fns.ArrayWrapper" href="#vectorbt.utils.reshape_fns.ArrayWrapper">ArrayWrapper</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.reshape_fns.ArrayWrapper.from_obj" href="#vectorbt.utils.reshape_fns.ArrayWrapper.from_obj">from_obj</a></code></li>
<li><code><a title="vectorbt.utils.reshape_fns.ArrayWrapper.wrap" href="#vectorbt.utils.reshape_fns.ArrayWrapper.wrap">wrap</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
</body>
</html>