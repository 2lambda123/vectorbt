<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.utils.config API documentation</title>
<meta name="description" content="Utilities for configuration." />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#e82}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:100px;max-height:100px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.utils.config</code></h1>
</header>
<section id="section-intro">
<p>Utilities for configuration.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Utilities for configuration.&#34;&#34;&#34;

from copy import copy
from collections import namedtuple
import dill
import inspect
from pathlib import Path

from vectorbt import typing as tp
from vectorbt.utils import checks
from vectorbt.utils.attr import deep_getattr


def resolve_dict(dct: tp.DictLikeSequence, i: tp.Optional[int] = None) -&gt; dict:
    &#34;&#34;&#34;Select keyword arguments.&#34;&#34;&#34;
    if dct is None:
        dct = {}
    if isinstance(dct, dict):
        return dict(dct)
    if i is not None:
        _dct = dct[i]
        if _dct is None:
            _dct = {}
        return dict(_dct)
    raise ValueError(&#34;Cannot resolve dict&#34;)


def get_func_kwargs(func: tp.Callable) -&gt; dict:
    &#34;&#34;&#34;Get keyword arguments of the function.&#34;&#34;&#34;
    signature = inspect.signature(func)
    return {
        k: v.default
        for k, v in signature.parameters.items()
        if v.default is not inspect.Parameter.empty
    }


class atomic_dict(dict):
    &#34;&#34;&#34;Dict that behaves like a single value when merging.&#34;&#34;&#34;
    pass


def merge_dicts(*dicts: tp.DictLike) -&gt; dict:
    &#34;&#34;&#34;Merge dicts.&#34;&#34;&#34;
    x, y = dicts[0], dicts[1]
    if x is None:
        x = {}
    if y is None:
        y = {}
    checks.assert_type(x, dict)
    checks.assert_type(y, dict)

    if len(x) == 0:
        z = y.copy()
    elif len(y) == 0:
        z = x.copy()
    else:
        z = {}
        overlapping_keys = [k for k in x if k in y]  # order matters
        for k in overlapping_keys:
            if isinstance(x[k], dict) and isinstance(y[k], dict) and not isinstance(y[k], atomic_dict):
                z[k] = merge_dicts(x[k], y[k])
            else:
                z[k] = y[k]
        for k in [k for k in x if k not in y]:
            z[k] = x[k]
        for k in [k for k in y if k not in x]:
            z[k] = y[k]

    if len(dicts) &gt; 2:
        return merge_dicts(z, *dicts[2:])
    return z


def copy_dict(dct: tp.DictLike) -&gt; dict:
    &#34;&#34;&#34;Copy dict using shallow-deep copy hybrid.
    
    Traverses all nested dicts and copies each value using shallow copy.&#34;&#34;&#34;
    if dct is None:
        return {}
    dct_copy = type(dct)()
    for k, v in dct.items():
        if isinstance(v, dict):
            dct_copy[k] = copy_dict(v)
        else:
            dct_copy[k] = copy(v)
    return dct_copy


_RaiseKeyError = object()

DumpTuple = namedtuple(&#39;DumpTuple&#39;, (&#39;cls&#39;, &#39;dumps&#39;))


PickleableT = tp.TypeVar(&#34;PickleableT&#34;, bound=&#34;Pickleable&#34;)


class Pickleable:
    &#34;&#34;&#34;Superclass that defines abstract properties and methods for pickle-able classes.&#34;&#34;&#34;

    def dumps(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def loads(cls: tp.Type[PickleableT], dumps: bytes, **kwargs) -&gt; PickleableT:
        &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
        raise NotImplementedError

    def save(self, fname: tp.Union[str, Path], **kwargs) -&gt; None:
        &#34;&#34;&#34;Save dumps to a file.&#34;&#34;&#34;
        dumps = self.dumps(**kwargs)
        with open(fname, &#34;wb&#34;) as f:
            f.write(dumps)

    @classmethod
    def load(cls: tp.Type[PickleableT], fname: tp.Union[str, Path], **kwargs) -&gt; PickleableT:
        &#34;&#34;&#34;Load dumps from a file and create new instance.&#34;&#34;&#34;
        with open(fname, &#34;rb&#34;) as f:
            dumps = f.read()
        return cls.loads(dumps, **kwargs)


ConfigT = tp.TypeVar(&#34;ConfigT&#34;, bound=&#34;Config&#34;)


class Config(dict, Pickleable):
    &#34;&#34;&#34;Extends dict with config features.&#34;&#34;&#34;

    def __init__(self,
                 *args,
                 frozen: bool = False,
                 read_only: bool = False,
                 init_config: tp.DictLike = None,
                 **kwargs) -&gt; None:
        super().__init__(*args, **kwargs)
        self._frozen = frozen
        self._read_only = read_only
        if init_config is None and not read_only:
            init_config = copy_dict(dict(self))
        self._init_config = init_config

    @property
    def frozen(self) -&gt; bool:
        &#34;&#34;&#34;Whether this config&#39;s keys are frozen.&#34;&#34;&#34;
        return self._frozen

    @property
    def read_only(self) -&gt; bool:
        &#34;&#34;&#34;Whether this config is read-only.&#34;&#34;&#34;
        return self._read_only

    @property
    def init_config(self) -&gt; tp.DictLike:
        &#34;&#34;&#34;Initial config.&#34;&#34;&#34;
        return self._init_config

    def __setitem__(self, k: tp.Any, v: tp.Any) -&gt; None:
        if self.read_only:
            raise TypeError(&#34;Config is read-only&#34;)
        if self.frozen:
            if k not in self:
                raise KeyError(f&#34;Key &#39;{k}&#39; is not valid&#34;)
        super().__setitem__(k, v)

    def __delitem__(self, k: tp.Any) -&gt; None:
        if self.read_only:
            raise TypeError(&#34;Config is read-only&#34;)
        super().__delitem__(k)

    def pop(self, k: tp.Any, v: tp.Any = _RaiseKeyError) -&gt; tp.Any:
        &#34;&#34;&#34;Remove and return the pair by the key.&#34;&#34;&#34;
        if self.read_only:
            raise TypeError(&#34;Config is read-only&#34;)
        if v is _RaiseKeyError:
            return super().pop(k)
        return super().pop(k, v)

    def popitem(self) -&gt; tp.Tuple[tp.Any, tp.Any]:
        &#34;&#34;&#34;Remove and return some pair.&#34;&#34;&#34;
        if self.read_only:
            raise TypeError(&#34;Config is read-only&#34;)
        return super().popitem()

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Remove all items.&#34;&#34;&#34;
        if self.read_only:
            raise TypeError(&#34;Config is read-only&#34;)
        super().clear()

    def update(self, *args, force_update: bool = False, **kwargs) -&gt; None:
        &#34;&#34;&#34;Update config.&#34;&#34;&#34;
        other = dict(*args, **kwargs)
        if force_update:
            super().update(other)
            return
        if self.read_only:
            raise TypeError(&#34;Config is read-only&#34;)
        if self.frozen:
            for k in other:
                if k not in self:
                    raise KeyError(f&#34;Key &#39;{k}&#39; is not valid&#34;)
        super().update(other)

    def copy(self: ConfigT) -&gt; ConfigT:
        &#34;&#34;&#34;Copy config.&#34;&#34;&#34;
        return self.__class__(
            self,
            frozen=self.frozen,
            read_only=self.read_only,
            init_config=copy_dict(self.init_config)
        )

    def merge_with(self: ConfigT, other: dict, **kwargs) -&gt; ConfigT:
        &#34;&#34;&#34;Merge this and other dict into a new config.&#34;&#34;&#34;
        return self.__class__(merge_dicts(self, other), **kwargs)

    def reset(self) -&gt; None:
        &#34;&#34;&#34;Reset to the initial config.&#34;&#34;&#34;
        if self.read_only:
            raise TypeError(&#34;Config is read-only&#34;)
        self.update(copy_dict(self.init_config), force_update=True)

    def dumps(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
        config = dict(frozen=self.frozen, read_only=self.read_only)
        for k, v in self.items():
            if k in (&#39;frozen&#39;, &#39;readonly&#39;):
                raise ValueError(f&#34;Keyword argument repeated: {k}&#34;)
            if isinstance(v, Pickleable):
                config[k] = DumpTuple(cls=v.__class__, dumps=v.dumps(**kwargs))
            else:
                config[k] = v
        return dill.dumps(config, **kwargs)

    @classmethod
    def loads(cls: tp.Type[ConfigT], dumps: bytes, **kwargs) -&gt; ConfigT:
        &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
        config = dill.loads(dumps, **kwargs)
        for k, v in config.items():
            if isinstance(v, DumpTuple):
                config[k] = v.cls.loads(v.dumps, **kwargs)
        return cls(**config)

    def __eq__(self, other: tp.Any) -&gt; bool:
        return checks.is_deep_equal(dict(self), dict(other))


class AtomicConfig(Config, atomic_dict):
    &#34;&#34;&#34;Config that behaves like a single value when merging.&#34;&#34;&#34;
    pass


ConfiguredT = tp.TypeVar(&#34;ConfiguredT&#34;, bound=&#34;Configured&#34;)


class Configured(Pickleable):
    &#34;&#34;&#34;Class with an initialization config.

    All operations are done using config rather than the instance, which makes it easier to pickle.

    !!! warning
        If the instance has writable attributes or depends upon global defaults,
        their values won&#39;t be copied over. Make sure to pass them explicitly to
        make the saved &amp; loaded / copied instance resilient to changes in globals.&#34;&#34;&#34;

    def __init__(self, **config) -&gt; None:
        self._config = Config(config, read_only=True)

    @property
    def config(self) -&gt; Config:
        &#34;&#34;&#34;Initialization config.&#34;&#34;&#34;
        return self._config

    def copy(self: ConfiguredT, **new_config) -&gt; ConfiguredT:
        &#34;&#34;&#34;Create a new instance based on the config.

        !!! warning
            This &#34;copy&#34; operation won&#39;t return a copy of the instance but a new instance
            initialized with the same config.&#34;&#34;&#34;
        return self.__class__(**self.config.merge_with(new_config))

    def dumps(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
        return self.config.dumps(**kwargs)

    @classmethod
    def loads(cls: tp.Type[ConfiguredT], dumps: bytes, **kwargs) -&gt; ConfiguredT:
        &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
        return cls(**Config.loads(dumps, **kwargs))

    def __eq__(self, other: tp.Any) -&gt; bool:
        &#34;&#34;&#34;Objects are equal if their configs are equal.&#34;&#34;&#34;
        if type(self) != type(other):
            return False
        return self.config == other.config

    def getattr(self, attr_chain: tp.Union[str, tuple, list]) -&gt; tp.Any:
        &#34;&#34;&#34;See `vectorbt.utils.attr.deep_getattr`.&#34;&#34;&#34;
        return deep_getattr(self, attr_chain)

    def update_config(self, *args, **kwargs) -&gt; None:
        &#34;&#34;&#34;Force-update the config.&#34;&#34;&#34;
        self.config.update(*args, **kwargs, force_update=True)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.utils.config.copy_dict"><code class="name flex">
<span>def <span class="ident">copy_dict</span></span>(<span>dct)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy dict using shallow-deep copy hybrid.</p>
<p>Traverses all nested dicts and copies each value using shallow copy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_dict(dct: tp.DictLike) -&gt; dict:
    &#34;&#34;&#34;Copy dict using shallow-deep copy hybrid.
    
    Traverses all nested dicts and copies each value using shallow copy.&#34;&#34;&#34;
    if dct is None:
        return {}
    dct_copy = type(dct)()
    for k, v in dct.items():
        if isinstance(v, dict):
            dct_copy[k] = copy_dict(v)
        else:
            dct_copy[k] = copy(v)
    return dct_copy</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.get_func_kwargs"><code class="name flex">
<span>def <span class="ident">get_func_kwargs</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Get keyword arguments of the function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_func_kwargs(func: tp.Callable) -&gt; dict:
    &#34;&#34;&#34;Get keyword arguments of the function.&#34;&#34;&#34;
    signature = inspect.signature(func)
    return {
        k: v.default
        for k, v in signature.parameters.items()
        if v.default is not inspect.Parameter.empty
    }</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.merge_dicts"><code class="name flex">
<span>def <span class="ident">merge_dicts</span></span>(<span>*dicts)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge dicts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_dicts(*dicts: tp.DictLike) -&gt; dict:
    &#34;&#34;&#34;Merge dicts.&#34;&#34;&#34;
    x, y = dicts[0], dicts[1]
    if x is None:
        x = {}
    if y is None:
        y = {}
    checks.assert_type(x, dict)
    checks.assert_type(y, dict)

    if len(x) == 0:
        z = y.copy()
    elif len(y) == 0:
        z = x.copy()
    else:
        z = {}
        overlapping_keys = [k for k in x if k in y]  # order matters
        for k in overlapping_keys:
            if isinstance(x[k], dict) and isinstance(y[k], dict) and not isinstance(y[k], atomic_dict):
                z[k] = merge_dicts(x[k], y[k])
            else:
                z[k] = y[k]
        for k in [k for k in x if k not in y]:
            z[k] = x[k]
        for k in [k for k in y if k not in x]:
            z[k] = y[k]

    if len(dicts) &gt; 2:
        return merge_dicts(z, *dicts[2:])
    return z</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.resolve_dict"><code class="name flex">
<span>def <span class="ident">resolve_dict</span></span>(<span>dct, i=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Select keyword arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_dict(dct: tp.DictLikeSequence, i: tp.Optional[int] = None) -&gt; dict:
    &#34;&#34;&#34;Select keyword arguments.&#34;&#34;&#34;
    if dct is None:
        dct = {}
    if isinstance(dct, dict):
        return dict(dct)
    if i is not None:
        _dct = dct[i]
        if _dct is None:
            _dct = {}
        return dict(_dct)
    raise ValueError(&#34;Cannot resolve dict&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.utils.config.AtomicConfig"><code class="flex name class">
<span>class <span class="ident">AtomicConfig</span></span>
<span>(</span><span>*args, frozen=False, read_only=False, init_config=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Config that behaves like a single value when merging.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AtomicConfig(Config, atomic_dict):
    &#34;&#34;&#34;Config that behaves like a single value when merging.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.config.Config" href="#vectorbt.utils.config.Config">Config</a></li>
<li><a title="vectorbt.utils.config.atomic_dict" href="#vectorbt.utils.config.atomic_dict">atomic_dict</a></li>
<li>builtins.dict</li>
<li><a title="vectorbt.utils.config.Pickleable" href="#vectorbt.utils.config.Pickleable">Pickleable</a></li>
</ul>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.utils.config.Config" href="#vectorbt.utils.config.Config">Config</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.utils.config.Config.clear" href="#vectorbt.utils.config.Config.clear">clear</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.copy" href="#vectorbt.utils.config.Config.copy">copy</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.dumps" href="#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.frozen" href="#vectorbt.utils.config.Config.frozen">frozen</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.init_config" href="#vectorbt.utils.config.Config.init_config">init_config</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.load" href="#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.loads" href="#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.merge_with" href="#vectorbt.utils.config.Config.merge_with">merge_with</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.pop" href="#vectorbt.utils.config.Config.pop">pop</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.popitem" href="#vectorbt.utils.config.Config.popitem">popitem</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.read_only" href="#vectorbt.utils.config.Config.read_only">read_only</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.reset" href="#vectorbt.utils.config.Config.reset">reset</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.save" href="#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.update" href="#vectorbt.utils.config.Config.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.utils.config.Config"><code class="flex name class">
<span>class <span class="ident">Config</span></span>
<span>(</span><span>*args, frozen=False, read_only=False, init_config=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends dict with config features.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Config(dict, Pickleable):
    &#34;&#34;&#34;Extends dict with config features.&#34;&#34;&#34;

    def __init__(self,
                 *args,
                 frozen: bool = False,
                 read_only: bool = False,
                 init_config: tp.DictLike = None,
                 **kwargs) -&gt; None:
        super().__init__(*args, **kwargs)
        self._frozen = frozen
        self._read_only = read_only
        if init_config is None and not read_only:
            init_config = copy_dict(dict(self))
        self._init_config = init_config

    @property
    def frozen(self) -&gt; bool:
        &#34;&#34;&#34;Whether this config&#39;s keys are frozen.&#34;&#34;&#34;
        return self._frozen

    @property
    def read_only(self) -&gt; bool:
        &#34;&#34;&#34;Whether this config is read-only.&#34;&#34;&#34;
        return self._read_only

    @property
    def init_config(self) -&gt; tp.DictLike:
        &#34;&#34;&#34;Initial config.&#34;&#34;&#34;
        return self._init_config

    def __setitem__(self, k: tp.Any, v: tp.Any) -&gt; None:
        if self.read_only:
            raise TypeError(&#34;Config is read-only&#34;)
        if self.frozen:
            if k not in self:
                raise KeyError(f&#34;Key &#39;{k}&#39; is not valid&#34;)
        super().__setitem__(k, v)

    def __delitem__(self, k: tp.Any) -&gt; None:
        if self.read_only:
            raise TypeError(&#34;Config is read-only&#34;)
        super().__delitem__(k)

    def pop(self, k: tp.Any, v: tp.Any = _RaiseKeyError) -&gt; tp.Any:
        &#34;&#34;&#34;Remove and return the pair by the key.&#34;&#34;&#34;
        if self.read_only:
            raise TypeError(&#34;Config is read-only&#34;)
        if v is _RaiseKeyError:
            return super().pop(k)
        return super().pop(k, v)

    def popitem(self) -&gt; tp.Tuple[tp.Any, tp.Any]:
        &#34;&#34;&#34;Remove and return some pair.&#34;&#34;&#34;
        if self.read_only:
            raise TypeError(&#34;Config is read-only&#34;)
        return super().popitem()

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Remove all items.&#34;&#34;&#34;
        if self.read_only:
            raise TypeError(&#34;Config is read-only&#34;)
        super().clear()

    def update(self, *args, force_update: bool = False, **kwargs) -&gt; None:
        &#34;&#34;&#34;Update config.&#34;&#34;&#34;
        other = dict(*args, **kwargs)
        if force_update:
            super().update(other)
            return
        if self.read_only:
            raise TypeError(&#34;Config is read-only&#34;)
        if self.frozen:
            for k in other:
                if k not in self:
                    raise KeyError(f&#34;Key &#39;{k}&#39; is not valid&#34;)
        super().update(other)

    def copy(self: ConfigT) -&gt; ConfigT:
        &#34;&#34;&#34;Copy config.&#34;&#34;&#34;
        return self.__class__(
            self,
            frozen=self.frozen,
            read_only=self.read_only,
            init_config=copy_dict(self.init_config)
        )

    def merge_with(self: ConfigT, other: dict, **kwargs) -&gt; ConfigT:
        &#34;&#34;&#34;Merge this and other dict into a new config.&#34;&#34;&#34;
        return self.__class__(merge_dicts(self, other), **kwargs)

    def reset(self) -&gt; None:
        &#34;&#34;&#34;Reset to the initial config.&#34;&#34;&#34;
        if self.read_only:
            raise TypeError(&#34;Config is read-only&#34;)
        self.update(copy_dict(self.init_config), force_update=True)

    def dumps(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
        config = dict(frozen=self.frozen, read_only=self.read_only)
        for k, v in self.items():
            if k in (&#39;frozen&#39;, &#39;readonly&#39;):
                raise ValueError(f&#34;Keyword argument repeated: {k}&#34;)
            if isinstance(v, Pickleable):
                config[k] = DumpTuple(cls=v.__class__, dumps=v.dumps(**kwargs))
            else:
                config[k] = v
        return dill.dumps(config, **kwargs)

    @classmethod
    def loads(cls: tp.Type[ConfigT], dumps: bytes, **kwargs) -&gt; ConfigT:
        &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
        config = dill.loads(dumps, **kwargs)
        for k, v in config.items():
            if isinstance(v, DumpTuple):
                config[k] = v.cls.loads(v.dumps, **kwargs)
        return cls(**config)

    def __eq__(self, other: tp.Any) -&gt; bool:
        return checks.is_deep_equal(dict(self), dict(other))</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
<li><a title="vectorbt.utils.config.Pickleable" href="#vectorbt.utils.config.Pickleable">Pickleable</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.config.AtomicConfig" href="#vectorbt.utils.config.AtomicConfig">AtomicConfig</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.utils.config.Config.frozen"><code class="name">var <span class="ident">frozen</span></code></dt>
<dd>
<div class="desc"><p>Whether this config's keys are frozen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frozen(self) -&gt; bool:
    &#34;&#34;&#34;Whether this config&#39;s keys are frozen.&#34;&#34;&#34;
    return self._frozen</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.init_config"><code class="name">var <span class="ident">init_config</span></code></dt>
<dd>
<div class="desc"><p>Initial config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def init_config(self) -&gt; tp.DictLike:
    &#34;&#34;&#34;Initial config.&#34;&#34;&#34;
    return self._init_config</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.read_only"><code class="name">var <span class="ident">read_only</span></code></dt>
<dd>
<div class="desc"><p>Whether this config is read-only.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def read_only(self) -&gt; bool:
    &#34;&#34;&#34;Whether this config is read-only.&#34;&#34;&#34;
    return self._read_only</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.utils.config.Config.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all items.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Remove all items.&#34;&#34;&#34;
    if self.read_only:
        raise TypeError(&#34;Config is read-only&#34;)
    super().clear()</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self: ConfigT) -&gt; ConfigT:
    &#34;&#34;&#34;Copy config.&#34;&#34;&#34;
    return self.__class__(
        self,
        frozen=self.frozen,
        read_only=self.read_only,
        init_config=copy_dict(self.init_config)
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.merge_with"><code class="name flex">
<span>def <span class="ident">merge_with</span></span>(<span>self, other, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge this and other dict into a new config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_with(self: ConfigT, other: dict, **kwargs) -&gt; ConfigT:
    &#34;&#34;&#34;Merge this and other dict into a new config.&#34;&#34;&#34;
    return self.__class__(merge_dicts(self, other), **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, k, v=&lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove and return the pair by the key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, k: tp.Any, v: tp.Any = _RaiseKeyError) -&gt; tp.Any:
    &#34;&#34;&#34;Remove and return the pair by the key.&#34;&#34;&#34;
    if self.read_only:
        raise TypeError(&#34;Config is read-only&#34;)
    if v is _RaiseKeyError:
        return super().pop(k)
    return super().pop(k, v)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.popitem"><code class="name flex">
<span>def <span class="ident">popitem</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove and return some pair.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popitem(self) -&gt; tp.Tuple[tp.Any, tp.Any]:
    &#34;&#34;&#34;Remove and return some pair.&#34;&#34;&#34;
    if self.read_only:
        raise TypeError(&#34;Config is read-only&#34;)
    return super().popitem()</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset to the initial config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self) -&gt; None:
    &#34;&#34;&#34;Reset to the initial config.&#34;&#34;&#34;
    if self.read_only:
        raise TypeError(&#34;Config is read-only&#34;)
    self.update(copy_dict(self.init_config), force_update=True)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, *args, force_update=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, *args, force_update: bool = False, **kwargs) -&gt; None:
    &#34;&#34;&#34;Update config.&#34;&#34;&#34;
    other = dict(*args, **kwargs)
    if force_update:
        super().update(other)
        return
    if self.read_only:
        raise TypeError(&#34;Config is read-only&#34;)
    if self.frozen:
        for k in other:
            if k not in self:
                raise KeyError(f&#34;Key &#39;{k}&#39; is not valid&#34;)
    super().update(other)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.utils.config.Pickleable" href="#vectorbt.utils.config.Pickleable">Pickleable</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.utils.config.Pickleable.dumps" href="#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.load" href="#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.loads" href="#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.save" href="#vectorbt.utils.config.Pickleable.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.utils.config.Configured"><code class="flex name class">
<span>class <span class="ident">Configured</span></span>
<span>(</span><span>**config)</span>
</code></dt>
<dd>
<div class="desc"><p>Class with an initialization config.</p>
<p>All operations are done using config rather than the instance, which makes it easier to pickle.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If the instance has writable attributes or depends upon global defaults,
their values won't be copied over. Make sure to pass them explicitly to
make the saved &amp; loaded / copied instance resilient to changes in globals.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Configured(Pickleable):
    &#34;&#34;&#34;Class with an initialization config.

    All operations are done using config rather than the instance, which makes it easier to pickle.

    !!! warning
        If the instance has writable attributes or depends upon global defaults,
        their values won&#39;t be copied over. Make sure to pass them explicitly to
        make the saved &amp; loaded / copied instance resilient to changes in globals.&#34;&#34;&#34;

    def __init__(self, **config) -&gt; None:
        self._config = Config(config, read_only=True)

    @property
    def config(self) -&gt; Config:
        &#34;&#34;&#34;Initialization config.&#34;&#34;&#34;
        return self._config

    def copy(self: ConfiguredT, **new_config) -&gt; ConfiguredT:
        &#34;&#34;&#34;Create a new instance based on the config.

        !!! warning
            This &#34;copy&#34; operation won&#39;t return a copy of the instance but a new instance
            initialized with the same config.&#34;&#34;&#34;
        return self.__class__(**self.config.merge_with(new_config))

    def dumps(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
        return self.config.dumps(**kwargs)

    @classmethod
    def loads(cls: tp.Type[ConfiguredT], dumps: bytes, **kwargs) -&gt; ConfiguredT:
        &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
        return cls(**Config.loads(dumps, **kwargs))

    def __eq__(self, other: tp.Any) -&gt; bool:
        &#34;&#34;&#34;Objects are equal if their configs are equal.&#34;&#34;&#34;
        if type(self) != type(other):
            return False
        return self.config == other.config

    def getattr(self, attr_chain: tp.Union[str, tuple, list]) -&gt; tp.Any:
        &#34;&#34;&#34;See `vectorbt.utils.attr.deep_getattr`.&#34;&#34;&#34;
        return deep_getattr(self, attr_chain)

    def update_config(self, *args, **kwargs) -&gt; None:
        &#34;&#34;&#34;Force-update the config.&#34;&#34;&#34;
        self.config.update(*args, **kwargs, force_update=True)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.config.Pickleable" href="#vectorbt.utils.config.Pickleable">Pickleable</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></li>
<li><a title="vectorbt.data.updater.DataUpdater" href="../data/updater.html#vectorbt.data.updater.DataUpdater">DataUpdater</a></li>
<li><a title="vectorbt.generic.plotting.Bar" href="../generic/plotting.html#vectorbt.generic.plotting.Bar">Bar</a></li>
<li><a title="vectorbt.generic.plotting.Box" href="../generic/plotting.html#vectorbt.generic.plotting.Box">Box</a></li>
<li><a title="vectorbt.generic.plotting.Gauge" href="../generic/plotting.html#vectorbt.generic.plotting.Gauge">Gauge</a></li>
<li><a title="vectorbt.generic.plotting.Heatmap" href="../generic/plotting.html#vectorbt.generic.plotting.Heatmap">Heatmap</a></li>
<li><a title="vectorbt.generic.plotting.Histogram" href="../generic/plotting.html#vectorbt.generic.plotting.Histogram">Histogram</a></li>
<li><a title="vectorbt.generic.plotting.Scatter" href="../generic/plotting.html#vectorbt.generic.plotting.Scatter">Scatter</a></li>
<li><a title="vectorbt.generic.plotting.Volume" href="../generic/plotting.html#vectorbt.generic.plotting.Volume">Volume</a></li>
<li><a title="vectorbt.messaging.telegram.TelegramBot" href="../messaging/telegram.html#vectorbt.messaging.telegram.TelegramBot">TelegramBot</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.utils.config.Configured.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"><p>Initialization config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def config(self) -&gt; Config:
    &#34;&#34;&#34;Initialization config.&#34;&#34;&#34;
    return self._config</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.utils.config.Configured.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, **new_config)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new instance based on the config.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This "copy" operation won't return a copy of the instance but a new instance
initialized with the same config.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self: ConfiguredT, **new_config) -&gt; ConfiguredT:
    &#34;&#34;&#34;Create a new instance based on the config.

    !!! warning
        This &#34;copy&#34; operation won&#39;t return a copy of the instance but a new instance
        initialized with the same config.&#34;&#34;&#34;
    return self.__class__(**self.config.merge_with(new_config))</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Configured.getattr"><code class="name flex">
<span>def <span class="ident">getattr</span></span>(<span>self, attr_chain)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.utils.attr.deep_getattr" href="attr.html#vectorbt.utils.attr.deep_getattr">deep_getattr()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getattr(self, attr_chain: tp.Union[str, tuple, list]) -&gt; tp.Any:
    &#34;&#34;&#34;See `vectorbt.utils.attr.deep_getattr`.&#34;&#34;&#34;
    return deep_getattr(self, attr_chain)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Configured.update_config"><code class="name flex">
<span>def <span class="ident">update_config</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Force-update the config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_config(self, *args, **kwargs) -&gt; None:
    &#34;&#34;&#34;Force-update the config.&#34;&#34;&#34;
    self.config.update(*args, **kwargs, force_update=True)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.utils.config.Pickleable" href="#vectorbt.utils.config.Pickleable">Pickleable</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.utils.config.Pickleable.dumps" href="#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.load" href="#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.loads" href="#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.save" href="#vectorbt.utils.config.Pickleable.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.utils.config.DumpTuple"><code class="flex name class">
<span>class <span class="ident">DumpTuple</span></span>
<span>(</span><span>cls, dumps)</span>
</code></dt>
<dd>
<div class="desc"><p>DumpTuple(cls, dumps)</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.utils.config.DumpTuple.cls"><code class="name">var <span class="ident">cls</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="vectorbt.utils.config.DumpTuple.dumps"><code class="name">var <span class="ident">dumps</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="vectorbt.utils.config.Pickleable"><code class="flex name class">
<span>class <span class="ident">Pickleable</span></span>
</code></dt>
<dd>
<div class="desc"><p>Superclass that defines abstract properties and methods for pickle-able classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pickleable:
    &#34;&#34;&#34;Superclass that defines abstract properties and methods for pickle-able classes.&#34;&#34;&#34;

    def dumps(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def loads(cls: tp.Type[PickleableT], dumps: bytes, **kwargs) -&gt; PickleableT:
        &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
        raise NotImplementedError

    def save(self, fname: tp.Union[str, Path], **kwargs) -&gt; None:
        &#34;&#34;&#34;Save dumps to a file.&#34;&#34;&#34;
        dumps = self.dumps(**kwargs)
        with open(fname, &#34;wb&#34;) as f:
            f.write(dumps)

    @classmethod
    def load(cls: tp.Type[PickleableT], fname: tp.Union[str, Path], **kwargs) -&gt; PickleableT:
        &#34;&#34;&#34;Load dumps from a file and create new instance.&#34;&#34;&#34;
        with open(fname, &#34;rb&#34;) as f:
            dumps = f.read()
        return cls.loads(dumps, **kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.config.Config" href="#vectorbt.utils.config.Config">Config</a></li>
<li><a title="vectorbt.utils.config.Configured" href="#vectorbt.utils.config.Configured">Configured</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.utils.config.Pickleable.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>fname, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load dumps from a file and create new instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls: tp.Type[PickleableT], fname: tp.Union[str, Path], **kwargs) -&gt; PickleableT:
    &#34;&#34;&#34;Load dumps from a file and create new instance.&#34;&#34;&#34;
    with open(fname, &#34;rb&#34;) as f:
        dumps = f.read()
    return cls.loads(dumps, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Pickleable.loads"><code class="name flex">
<span>def <span class="ident">loads</span></span>(<span>dumps, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Unpickle from bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def loads(cls: tp.Type[PickleableT], dumps: bytes, **kwargs) -&gt; PickleableT:
    &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.utils.config.Pickleable.dumps"><code class="name flex">
<span>def <span class="ident">dumps</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Pickle to bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dumps(self, **kwargs) -&gt; bytes:
    &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Pickleable.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, fname, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Save dumps to a file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, fname: tp.Union[str, Path], **kwargs) -&gt; None:
    &#34;&#34;&#34;Save dumps to a file.&#34;&#34;&#34;
    dumps = self.dumps(**kwargs)
    with open(fname, &#34;wb&#34;) as f:
        f.write(dumps)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.utils.config.atomic_dict"><code class="flex name class">
<span>class <span class="ident">atomic_dict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Dict that behaves like a single value when merging.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class atomic_dict(dict):
    &#34;&#34;&#34;Dict that behaves like a single value when merging.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.config.AtomicConfig" href="#vectorbt.utils.config.AtomicConfig">AtomicConfig</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRUYwMDAwO30KCS5zdDF7ZmlsbDojRkY5MDAwO30KCS5zdDJ7ZmlsbDojRkZERjAwO30KCS5zdDN7ZmlsbDojMjgyQzM0O30KPC9zdHlsZT4KPGc+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNTUuMywzMDAuMSAyODMuMSwwIDIwOCwwIDExMC44LDAgMzUuOCwwIDEuMiw0NTAuMiA3Ni4zLDQ1MC4yIAkJCSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjIzMC40LDMwMC4xIDM1OC4xLDAgMjgzLjEsMCAxODUuOCwwIDExMC44LDAgNzYuMyw0NTAuMiAxNTEuMyw0NTAuMiAJCQkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIzMDUuNCwzMDAuMSA0MzMuMSwwIDM1OC4xLDAgMzMxLjYsNjIuMyAyNjAuOCwwIDE4NS44LDAgMTUxLjMsNDUwLjIgMjI2LjQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iNTEwLjgsMCA0MzMuMSwwIDMwNS40LDMwMC4xIDMzOC40LDAgMjYwLjgsMCAyMjYuNCw0NTAuMiAzMDQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.utils" href="index.html">vectorbt.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.utils.config.copy_dict" href="#vectorbt.utils.config.copy_dict">copy_dict</a></code></li>
<li><code><a title="vectorbt.utils.config.get_func_kwargs" href="#vectorbt.utils.config.get_func_kwargs">get_func_kwargs</a></code></li>
<li><code><a title="vectorbt.utils.config.merge_dicts" href="#vectorbt.utils.config.merge_dicts">merge_dicts</a></code></li>
<li><code><a title="vectorbt.utils.config.resolve_dict" href="#vectorbt.utils.config.resolve_dict">resolve_dict</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.utils.config.AtomicConfig" href="#vectorbt.utils.config.AtomicConfig">AtomicConfig</a></code></h4>
</li>
<li>
<h4><code><a title="vectorbt.utils.config.Config" href="#vectorbt.utils.config.Config">Config</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.utils.config.Config.clear" href="#vectorbt.utils.config.Config.clear">clear</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.copy" href="#vectorbt.utils.config.Config.copy">copy</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.frozen" href="#vectorbt.utils.config.Config.frozen">frozen</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.init_config" href="#vectorbt.utils.config.Config.init_config">init_config</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.merge_with" href="#vectorbt.utils.config.Config.merge_with">merge_with</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.pop" href="#vectorbt.utils.config.Config.pop">pop</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.popitem" href="#vectorbt.utils.config.Config.popitem">popitem</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.read_only" href="#vectorbt.utils.config.Config.read_only">read_only</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.reset" href="#vectorbt.utils.config.Config.reset">reset</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.update" href="#vectorbt.utils.config.Config.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.config.Configured" href="#vectorbt.utils.config.Configured">Configured</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.config.Configured.config" href="#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.copy" href="#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.getattr" href="#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.update_config" href="#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.config.DumpTuple" href="#vectorbt.utils.config.DumpTuple">DumpTuple</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.config.DumpTuple.cls" href="#vectorbt.utils.config.DumpTuple.cls">cls</a></code></li>
<li><code><a title="vectorbt.utils.config.DumpTuple.dumps" href="#vectorbt.utils.config.DumpTuple.dumps">dumps</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.config.Pickleable" href="#vectorbt.utils.config.Pickleable">Pickleable</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.config.Pickleable.dumps" href="#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.load" href="#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.loads" href="#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.save" href="#vectorbt.utils.config.Pickleable.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.config.atomic_dict" href="#vectorbt.utils.config.atomic_dict">atomic_dict</a></code></h4>
</li>
</ul>
</li>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>