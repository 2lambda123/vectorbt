<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.utils.config API documentation</title>
<meta name="description" content="Utilities for configuration." />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#e82}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-weight:400;font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:100px;max-height:100px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.utils.config</code></h1>
</header>
<section id="section-intro">
<p>Utilities for configuration.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Utilities for configuration.&#34;&#34;&#34;

from copy import copy, deepcopy
from collections import namedtuple
import dill
import inspect

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.attr import deep_getattr


def resolve_dict(dct: tp.DictLikeSequence, i: tp.Optional[int] = None) -&gt; dict:
    &#34;&#34;&#34;Select keyword arguments.&#34;&#34;&#34;
    if dct is None:
        dct = {}
    if isinstance(dct, dict):
        return dict(dct)
    if i is not None:
        _dct = dct[i]
        if _dct is None:
            _dct = {}
        return dict(_dct)
    raise ValueError(&#34;Cannot resolve dict&#34;)


def get_func_kwargs(func: tp.Callable) -&gt; dict:
    &#34;&#34;&#34;Get keyword arguments of the function.&#34;&#34;&#34;
    signature = inspect.signature(func)
    return {
        k: v.default
        for k, v in signature.parameters.items()
        if v.default is not inspect.Parameter.empty
    }


class atomic_dict(dict):
    &#34;&#34;&#34;Dict that behaves like a single value when merging.&#34;&#34;&#34;
    pass


InConfigLikeT = tp.Union[None, dict, &#34;ConfigT&#34;]
OutConfigLikeT = tp.Union[dict, &#34;ConfigT&#34;]


def convert_to_dict(dct: InConfigLikeT, nested: bool = True) -&gt; dict:
    &#34;&#34;&#34;Convert any dict (apart from `atomic_dict`) to `dict`.

    Set `nested` to True to convert all child dicts in recursive manner.&#34;&#34;&#34;
    if dct is None:
        dct = {}
    if isinstance(dct, atomic_dict):
        dct = atomic_dict(dct)
    else:
        dct = dict(dct)
    if not nested:
        return dct
    for k, v in dct.items():
        if isinstance(v, dict):
            dct[k] = convert_to_dict(v, nested=nested)
        else:
            dct[k] = v
    return dct


def set_dict_item(dct: dict, k: tp.Any, v: tp.Any, force: bool = False) -&gt; None:
    &#34;&#34;&#34;Set dict item.

    If the dict is of the type `Config`, also passes `force` keyword to override blocking flags.&#34;&#34;&#34;
    if isinstance(dct, Config):
        dct.__setitem__(k, v, force=force)
    else:
        dct[k] = v


def copy_dict(dct: InConfigLikeT, copy_mode: str = &#39;shallow&#39;, nested: bool = True) -&gt; OutConfigLikeT:
    &#34;&#34;&#34;Copy dict based on a copy mode.

    The following modes are supported:

    * &#39;shallow&#39;: Copies keys only.
    * &#39;hybrid&#39;: Copies keys and values using `copy.copy`.
    * &#39;deep&#39;: Copies the whole thing using `copy.deepcopy`.

    Set `nested` to True to copy all child dicts in recursive manner.&#34;&#34;&#34;
    if dct is None:
        dct = {}
    checks.assert_type(copy_mode, str)
    copy_mode = copy_mode.lower()
    if copy_mode not in [&#39;shallow&#39;, &#39;hybrid&#39;, &#39;deep&#39;]:
        raise ValueError(f&#34;Copy mode &#39;{copy_mode}&#39; not supported&#34;)

    if copy_mode == &#39;deep&#39;:
        return deepcopy(dct)
    if isinstance(dct, Config):
        return dct.copy(
            copy_mode=copy_mode,
            nested=nested
        )
    dct_copy = copy(dct)  # copy structure using shallow copy
    for k, v in dct_copy.items():
        if nested and isinstance(v, dict):
            _v = copy_dict(v, copy_mode=copy_mode, nested=nested)
        else:
            if copy_mode == &#39;hybrid&#39;:
                _v = copy(v)  # copy values using shallow copy
            else:
                _v = v
        set_dict_item(dct_copy, k, _v, force=True)
    return dct_copy


def update_dict(x: InConfigLikeT, y: InConfigLikeT, nested: bool = True, force: bool = False) -&gt; None:
    &#34;&#34;&#34;Update dict with keys and values from other dict.

    Set `nested` to True to update all child dicts in recursive manner.
    For `force`, see `set_dict_item`.

    If you want to treat any dict as a single value, wrap it with `atomic_dict`.

    !!! note
        If the child dict is not atomic, it will copy only its values, not its meta.&#34;&#34;&#34;
    if x is None:
        return
    if y is None:
        return
    checks.assert_type(x, dict)
    checks.assert_type(y, dict)

    for k, v in y.items():
        if nested \
                and k in x \
                and isinstance(x[k], dict) \
                and isinstance(v, dict) \
                and not isinstance(v, atomic_dict):
            update_dict(x[k], v, force=force)
        else:
            set_dict_item(x, k, v, force=force)


def merge_dicts(*dicts: InConfigLikeT,
                to_dict: bool = True,
                copy_mode: tp.Optional[str] = &#39;shallow&#39;,
                nested: bool = True) -&gt; OutConfigLikeT:
    &#34;&#34;&#34;Merge dicts.

    Args:
        *dicts (dict): Dicts.
        to_dict: Whether to call `convert_to_dict` on each dict prior to copying.
        copy_mode: Mode for `copy_dict` to copy each dict prior to merging.

            Pass None to not copy.
        nested: Whether to merge all child dicts in recursive manner.&#34;&#34;&#34;
    # copy only once
    if to_dict:
        dicts = tuple([convert_to_dict(dct, nested=nested) for dct in dicts])
    if copy_mode is not None:
        dicts = tuple([copy_dict(dct, copy_mode=copy_mode, nested=nested) for dct in dicts])
    x, y = dicts[0], dicts[1]
    if isinstance(x, atomic_dict) or isinstance(y, atomic_dict):
        x = y
    else:
        update_dict(x, y, nested=nested, force=True)
    if len(dicts) &gt; 2:
        return merge_dicts(
            x, *dicts[2:],
            to_dict=False,  # executed only once
            copy_mode=None,  # executed only once
            nested=nested
        )
    return x


_RaiseKeyError = object()

DumpTuple = namedtuple(&#39;DumpTuple&#39;, (&#39;cls&#39;, &#39;dumps&#39;))

PickleableT = tp.TypeVar(&#34;PickleableT&#34;, bound=&#34;Pickleable&#34;)


class Pickleable:
    &#34;&#34;&#34;Superclass that defines abstract properties and methods for pickle-able classes.&#34;&#34;&#34;

    def dumps(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def loads(cls: tp.Type[PickleableT], dumps: bytes, **kwargs) -&gt; PickleableT:
        &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
        raise NotImplementedError

    def save(self, fname: tp.FileName, **kwargs) -&gt; None:
        &#34;&#34;&#34;Save dumps to a file.&#34;&#34;&#34;
        dumps = self.dumps(**kwargs)
        with open(fname, &#34;wb&#34;) as f:
            f.write(dumps)

    @classmethod
    def load(cls: tp.Type[PickleableT], fname: tp.FileName, **kwargs) -&gt; PickleableT:
        &#34;&#34;&#34;Load dumps from a file and create new instance.&#34;&#34;&#34;
        with open(fname, &#34;rb&#34;) as f:
            dumps = f.read()
        return cls.loads(dumps, **kwargs)


PickleableDictT = tp.TypeVar(&#34;PickleableDictT&#34;, bound=&#34;PickleableDict&#34;)


class PickleableDict(Pickleable, dict):
    &#34;&#34;&#34;Dict that may contain values of type `Pickleable`.&#34;&#34;&#34;

    def dumps(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
        dct = dict()
        for k, v in self.items():
            if isinstance(v, Pickleable):
                dct[k] = DumpTuple(cls=v.__class__, dumps=v.dumps(**kwargs))
            else:
                dct[k] = v
        return dill.dumps(dct, **kwargs)

    @classmethod
    def loads(cls: tp.Type[PickleableDictT], dumps: bytes, **kwargs) -&gt; PickleableDictT:
        &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
        config = dill.loads(dumps, **kwargs)
        for k, v in config.items():
            if isinstance(v, DumpTuple):
                config[k] = v.cls.loads(v.dumps, **kwargs)
        return cls(**config)

    def load_update(self, fname: tp.FileName, **kwargs) -&gt; None:
        &#34;&#34;&#34;Load dumps from a file and update this instance.&#34;&#34;&#34;
        self.clear()
        self.update(self.load(fname, **kwargs))


ConfigT = tp.TypeVar(&#34;ConfigT&#34;, bound=&#34;Config&#34;)


class Config(PickleableDict):
    &#34;&#34;&#34;Extends dict with config features such as nested updates, frozen keys/values, and pickling.

    Args:
        dct (dict): Dict to construct this config from.
        copy_kwargs (dict): Keyword arguments passed to `copy_dict` for copying `dct` and `reset_dct`.

            Copy mode defaults to &#39;shallow&#39; if `readonly`, otherwise to &#39;hybrid&#39;.
        reset_dct (dict): Dict to fall back to in case of resetting.

            If None, copies `dct` using `reset_dct_copy_kwargs`.
        reset_dct_copy_kwargs (dict): Keyword arguments that override `copy_kwargs` for `reset_dct`.
        frozen_keys (bool): Whether to deny updates to the keys of the config.

            Defaults to False.
        readonly (bool): Whether to deny updates to the keys and values of the config.

            Defaults to False.
        nested (bool): Whether to do operations recursively on each child dict.

            Such operations include copy, update, and merge.
            Disable to treat each child dict as a single value. Defaults to True.
        convert_dicts (bool or type): Whether to convert child dicts to configs with the same configuration.

            This will trigger a waterfall reaction across all child dicts.
            Won&#39;t convert dicts that are already configs.
            Apart from boolean, you can set it to any subclass of `Config` to use it for construction.
            Requires `nested` to be True. Defaults to False.
        as_attrs (bool): Whether to enable accessing dict keys via the dot notation.

            Enables autocompletion (but only during runtime!).
            Raises error in case of naming conflicts.
            Defaults to True if `frozen` or `readonly`, otherwise False.

    Defaults can be overridden with settings under `config` in `vectorbt._settings.settings`.

    If another config is passed, its properties are copied over, but they can still be overridden
    with the arguments passed to the initializer.

    !!! note
        All arguments are applied only once during initialization.
    &#34;&#34;&#34;

    _copy_kwargs_: tp.Kwargs
    _reset_dct_: dict
    _reset_dct_copy_kwargs_: tp.Kwargs
    _frozen_keys_: bool
    _readonly_: bool
    _nested_: bool
    _convert_dicts_: tp.Union[bool, tp.Type[&#34;Config&#34;]]
    _as_attrs_: bool

    def __init__(self,
                 dct: tp.DictLike = None,
                 copy_kwargs: tp.KwargsLike = None,
                 reset_dct: tp.DictLike = None,
                 reset_dct_copy_kwargs: tp.KwargsLike = None,
                 frozen_keys: tp.Optional[bool] = None,
                 readonly: tp.Optional[bool] = None,
                 nested: tp.Optional[bool] = None,
                 convert_dicts: tp.Optional[tp.Union[bool, tp.Type[&#34;Config&#34;]]] = None,
                 as_attrs: tp.Optional[bool] = None) -&gt; None:
        try:
            from vectorbt._settings import settings
            configured_cfg = settings[&#39;config&#39;]
        except ImportError:
            configured_cfg = {}

        if dct is None:
            dct = dict()

        # Resolve params
        def _resolve_param(pname: str, p: tp.Any, default: tp.Any, merge: bool = False) -&gt; tp.Any:
            cfg_default = configured_cfg.get(pname, None)
            dct_p = getattr(dct, pname + &#39;_&#39;) if isinstance(dct, Config) else None

            if merge and isinstance(default, dict):
                return merge_dicts(default, cfg_default, dct_p, p)
            if p is not None:
                return p
            if dct_p is not None:
                return dct_p
            if cfg_default is not None:
                return cfg_default
            return default

        reset_dct = _resolve_param(&#39;reset_dct&#39;, reset_dct, None)
        frozen_keys = _resolve_param(&#39;frozen_keys&#39;, frozen_keys, False)
        readonly = _resolve_param(&#39;readonly&#39;, readonly, False)
        nested = _resolve_param(&#39;nested&#39;, nested, False)
        convert_dicts = _resolve_param(&#39;convert_dicts&#39;, convert_dicts, False)
        as_attrs = _resolve_param(&#39;as_attrs&#39;, as_attrs, frozen_keys or readonly)
        reset_dct_copy_kwargs = merge_dicts(copy_kwargs, reset_dct_copy_kwargs)
        copy_kwargs = _resolve_param(
            &#39;copy_kwargs&#39;,
            copy_kwargs,
            dict(
                copy_mode=&#39;shallow&#39; if readonly else &#39;hybrid&#39;,
                nested=nested
            ),
            merge=True
        )
        reset_dct_copy_kwargs = _resolve_param(
            &#39;reset_dct_copy_kwargs&#39;,
            reset_dct_copy_kwargs,
            dict(
                copy_mode=&#39;shallow&#39; if readonly else &#39;hybrid&#39;,
                nested=nested
            ),
            merge=True
        )

        # Copy dict
        dct = copy_dict(dict(dct), **copy_kwargs)

        # Convert child dicts
        if convert_dicts:
            if not nested:
                raise ValueError(&#34;convert_dicts requires nested to be True&#34;)
            for k, v in dct.items():
                if isinstance(v, dict) and not isinstance(v, Config):
                    if isinstance(convert_dicts, bool):
                        config_cls = self.__class__
                    elif issubclass(convert_dicts, Config):
                        config_cls = convert_dicts
                    else:
                        raise TypeError(&#34;convert_dicts must be either boolean or a subclass of Config&#34;)
                    dct[k] = config_cls(
                        v,
                        copy_kwargs=copy_kwargs,
                        reset_dct_copy_kwargs=reset_dct_copy_kwargs,
                        frozen_keys=frozen_keys,
                        readonly=readonly,
                        nested=nested,
                        convert_dicts=convert_dicts,
                        as_attrs=as_attrs
                    )

        # Copy initial config
        if reset_dct is None:
            reset_dct = dct
        reset_dct = copy_dict(dict(reset_dct), **reset_dct_copy_kwargs)

        dict.__init__(self, dct)

        # Store params in an instance variable
        checks.assert_type(copy_kwargs, dict)
        checks.assert_type(reset_dct, dict)
        checks.assert_type(reset_dct_copy_kwargs, dict)
        checks.assert_type(frozen_keys, bool)
        checks.assert_type(readonly, bool)
        checks.assert_type(nested, bool)
        checks.assert_type(convert_dicts, (bool, type))
        checks.assert_type(as_attrs, bool)

        self.__dict__[&#39;_copy_kwargs_&#39;] = copy_kwargs
        self.__dict__[&#39;_reset_dct_&#39;] = reset_dct
        self.__dict__[&#39;_reset_dct_copy_kwargs_&#39;] = reset_dct_copy_kwargs
        self.__dict__[&#39;_frozen_keys_&#39;] = frozen_keys
        self.__dict__[&#39;_readonly_&#39;] = readonly
        self.__dict__[&#39;_nested_&#39;] = nested
        self.__dict__[&#39;_convert_dicts_&#39;] = convert_dicts
        self.__dict__[&#39;_as_attrs_&#39;] = as_attrs

        # Set keys as attributes for autocomplete
        if as_attrs:
            for k, v in self.items():
                if k in self.__dir__():
                    raise ValueError(f&#34;Cannot set key &#39;{k}&#39; as attribute of the config. Disable set_attrs.&#34;)
                self.__dict__[k] = v

    @property
    def copy_kwargs_(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Parameters for copying `dct`.&#34;&#34;&#34;
        return self._copy_kwargs_

    @property
    def reset_dct_(self) -&gt; dict:
        &#34;&#34;&#34;Dict to fall back to in case of resetting.&#34;&#34;&#34;
        return self._reset_dct_

    @property
    def reset_dct_copy_kwargs_(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Parameters for copying `reset_dct`.&#34;&#34;&#34;
        return self._reset_dct_copy_kwargs_

    @property
    def frozen_keys_(self) -&gt; bool:
        &#34;&#34;&#34;Whether to deny updates to the keys and values of the config.&#34;&#34;&#34;
        return self._frozen_keys_

    @property
    def readonly_(self) -&gt; bool:
        &#34;&#34;&#34;Whether to deny any updates to the config.&#34;&#34;&#34;
        return self._readonly_

    @property
    def nested_(self) -&gt; bool:
        &#34;&#34;&#34;Whether to do operations recursively on each child dict.&#34;&#34;&#34;
        return self._nested_

    @property
    def convert_dicts_(self) -&gt; tp.Union[bool, tp.Type[&#34;Config&#34;]]:
        &#34;&#34;&#34;Whether to convert child dicts to configs with the same configuration.&#34;&#34;&#34;
        return self._convert_dicts_

    @property
    def as_attrs_(self) -&gt; bool:
        &#34;&#34;&#34;Whether to enable accessing dict keys via dot notation.&#34;&#34;&#34;
        return self._as_attrs_

    def __setattr__(self, k: str, v: tp.Any) -&gt; None:
        if self.as_attrs_:
            self.__setitem__(k, v)

    def __setitem__(self, k: str, v: tp.Any, force: bool = False) -&gt; None:
        if not force and self.readonly_:
            raise TypeError(&#34;Config is read-only&#34;)
        if not force and self.frozen_keys_:
            if k not in self:
                raise KeyError(f&#34;Config keys are frozen: key &#39;{k}&#39; not found&#34;)
        dict.__setitem__(self, k, v)
        if self.as_attrs_:
            self.__dict__[k] = v

    def __delattr__(self, k: str) -&gt; None:
        if self.as_attrs_:
            self.__delitem__(k)

    def __delitem__(self, k: str, force: bool = False) -&gt; None:
        if not force and self.readonly_:
            raise TypeError(&#34;Config is read-only&#34;)
        if not force and self.frozen_keys_:
            raise KeyError(f&#34;Config keys are frozen&#34;)
        dict.__delitem__(self, k)
        if self.as_attrs_:
            del self.__dict__[k]

    def _clear_attrs(self, prior_keys: tp.Iterable[str]) -&gt; None:
        &#34;&#34;&#34;Remove attributes of the removed keys given keys prior to the removal.&#34;&#34;&#34;
        if self.as_attrs_:
            for k in set(prior_keys).difference(self.keys()):
                del self.__dict__[k]

    def pop(self, k: str, v: tp.Any = _RaiseKeyError, force: bool = False) -&gt; tp.Any:
        &#34;&#34;&#34;Remove and return the pair by the key.&#34;&#34;&#34;
        if not force and self.readonly_:
            raise TypeError(&#34;Config is read-only&#34;)
        if not force and self.frozen_keys_:
            raise KeyError(f&#34;Config keys are frozen&#34;)
        prior_keys = list(self.keys())
        if v is _RaiseKeyError:
            result = dict.pop(self, k)
        else:
            result = dict.pop(self, k, v)
        self._clear_attrs(prior_keys)
        return result

    def popitem(self, force: bool = False) -&gt; tp.Tuple[tp.Any, tp.Any]:
        &#34;&#34;&#34;Remove and return some pair.&#34;&#34;&#34;
        if not force and self.readonly_:
            raise TypeError(&#34;Config is read-only&#34;)
        if not force and self.frozen_keys_:
            raise KeyError(f&#34;Config keys are frozen&#34;)
        prior_keys = list(self.keys())
        result = dict.popitem(self)
        self._clear_attrs(prior_keys)
        return result

    def clear(self, force: bool = False) -&gt; None:
        &#34;&#34;&#34;Remove all items.&#34;&#34;&#34;
        if not force and self.readonly_:
            raise TypeError(&#34;Config is read-only&#34;)
        if not force and self.frozen_keys_:
            raise KeyError(f&#34;Config keys are frozen&#34;)
        prior_keys = list(self.keys())
        dict.clear(self)
        self._clear_attrs(prior_keys)

    def update(self, *args, nested: tp.Optional[bool] = None, force: bool = False, **kwargs) -&gt; None:
        &#34;&#34;&#34;Update the config.

        See `update_dict`.&#34;&#34;&#34;
        other = dict(*args, **kwargs)
        if nested is None:
            nested = self.nested_
        update_dict(self, other, nested=nested, force=force)

    def __copy__(self: ConfigT) -&gt; ConfigT:
        &#34;&#34;&#34;Shallow operation, primarily used by `copy.copy`.

        Does not take into account copy parameters.&#34;&#34;&#34;
        cls = self.__class__
        self_copy = cls.__new__(cls)
        for k, v in self.__dict__.items():
            if k not in self_copy:  # otherwise copies dict keys twice
                self_copy.__dict__[k] = v
        self_copy.clear(force=True)
        self_copy.update(copy(dict(self)), nested=False, force=True)
        return self_copy

    def __deepcopy__(self: ConfigT, memo: tp.DictLike = None) -&gt; ConfigT:
        &#34;&#34;&#34;Deep operation, primarily used by `copy.deepcopy`.

        Does not take into account copy parameters.&#34;&#34;&#34;
        if memo is None:
            memo = {}
        cls = self.__class__
        self_copy = cls.__new__(cls)
        memo[id(self)] = self_copy
        for k, v in self.__dict__.items():
            if k not in self_copy:  # otherwise copies dict keys twice
                self_copy.__dict__[k] = deepcopy(v, memo)
        self_copy.clear(force=True)
        self_copy.update(deepcopy(dict(self), memo), nested=False, force=True)
        return self_copy

    def copy(self: ConfigT, reset_dct_copy_kwargs: tp.KwargsLike = None, **copy_kwargs) -&gt; ConfigT:
        &#34;&#34;&#34;Copy the instance in the same way it&#39;s done during initialization.

        `copy_kwargs` override `Config.copy_kwargs_` and `Config.reset_dct_copy_kwargs_` via merging.
        `reset_dct_copy_kwargs` override merged `Config.reset_dct_copy_kwargs_`.&#34;&#34;&#34;
        self_copy = self.__copy__()

        reset_dct_copy_kwargs = merge_dicts(self.reset_dct_copy_kwargs_, copy_kwargs, reset_dct_copy_kwargs)
        reset_dct = copy_dict(dict(self.reset_dct_), **reset_dct_copy_kwargs)
        self.__dict__[&#39;_reset_dct_&#39;] = reset_dct

        copy_kwargs = merge_dicts(self.copy_kwargs_, copy_kwargs)
        dct = copy_dict(dict(self), **copy_kwargs)
        self_copy.update(dct, nested=False, force=True)

        return self_copy

    def merge_with(self: ConfigT, other: InConfigLikeT,
                   nested: tp.Optional[bool] = None, **kwargs) -&gt; OutConfigLikeT:
        &#34;&#34;&#34;Merge with another dict into one single dict.

        See `merge_dicts`.&#34;&#34;&#34;
        if nested is None:
            nested = self.nested_
        return merge_dicts(self, other, nested=nested, **kwargs)

    def reset(self, force: bool = False, **reset_dct_copy_kwargs) -&gt; None:
        &#34;&#34;&#34;Clears the config and updates it with the initial config.

        `reset_dct_copy_kwargs` override `Config.reset_dct_copy_kwargs_`.&#34;&#34;&#34;
        if not force and self.readonly_:
            raise TypeError(&#34;Config is read-only&#34;)
        reset_dct_copy_kwargs = merge_dicts(self.reset_dct_copy_kwargs_, reset_dct_copy_kwargs)
        reset_dct = copy_dict(dict(self.reset_dct_), **reset_dct_copy_kwargs)
        self.clear(force=True)
        self.update(self.reset_dct_, nested=False, force=True)
        self.__dict__[&#39;_reset_dct_&#39;] = reset_dct

    def make_checkpoint(self, force: bool = False, **reset_dct_copy_kwargs) -&gt; None:
        &#34;&#34;&#34;Replace `reset_dct` by the current state.

        `reset_dct_copy_kwargs` override `Config.reset_dct_copy_kwargs_`.&#34;&#34;&#34;
        if not force and self.readonly_:
            raise TypeError(&#34;Config is read-only&#34;)
        reset_dct_copy_kwargs = merge_dicts(self.reset_dct_copy_kwargs_, reset_dct_copy_kwargs)
        reset_dct = copy_dict(dict(self), **reset_dct_copy_kwargs)
        self.__dict__[&#39;_reset_dct_&#39;] = reset_dct

    def dumps(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
        return dill.dumps(dict(
            dct=PickleableDict(self).dumps(**kwargs),
            copy_kwargs=self.copy_kwargs_,
            reset_dct=PickleableDict(self.reset_dct_).dumps(**kwargs),
            reset_dct_copy_kwargs=self.reset_dct_copy_kwargs_,
            frozen_keys=self.frozen_keys_,
            readonly=self.readonly_,
            nested=self.nested_,
            convert_dicts=self.convert_dicts_,
            as_attrs=self.as_attrs_
        ), **kwargs)

    @classmethod
    def loads(cls: tp.Type[ConfigT], dumps: bytes, **kwargs) -&gt; ConfigT:
        &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
        obj = dill.loads(dumps, **kwargs)
        return cls(
            dct=PickleableDict.loads(obj[&#39;dct&#39;], **kwargs),
            copy_kwargs=obj[&#39;copy_kwargs&#39;],
            reset_dct=PickleableDict.loads(obj[&#39;reset_dct&#39;], **kwargs),
            reset_dct_copy_kwargs=obj[&#39;reset_dct_copy_kwargs&#39;],
            frozen_keys=obj[&#39;frozen_keys&#39;],
            readonly=obj[&#39;readonly&#39;],
            nested=obj[&#39;nested&#39;],
            convert_dicts=obj[&#39;convert_dicts&#39;],
            as_attrs=obj[&#39;as_attrs&#39;]
        )

    def load_update(self, fname: tp.FileName, **kwargs) -&gt; None:
        &#34;&#34;&#34;Load dumps from a file and update this instance.

        !!! note
            Updates both the config properties and dictionary.&#34;&#34;&#34;
        loaded = self.load(fname, **kwargs)
        self.clear(force=True)
        self.__dict__.clear()
        self.__dict__.update(loaded.__dict__)
        self.update(loaded, nested=False, force=True)

    def __eq__(self, other: tp.Any) -&gt; bool:
        return checks.is_deep_equal(dict(self), dict(other))


class AtomicConfig(Config, atomic_dict):
    &#34;&#34;&#34;Config that behaves like a single value when merging.&#34;&#34;&#34;
    pass


ConfiguredT = tp.TypeVar(&#34;ConfiguredT&#34;, bound=&#34;Configured&#34;)


class Configured(Pickleable):
    &#34;&#34;&#34;Class with an initialization config.

    All operations are done using config rather than the instance, which makes it easier to pickle.

    Config settings are defined under `config.configured` in `vectorbt._settings.settings`.

    !!! warning
        If the instance has writable attributes or depends upon global defaults,
        their values won&#39;t be copied over. Make sure to pass them explicitly to
        make the saved &amp; loaded / copied instance resilient to changes in globals.&#34;&#34;&#34;

    def __init__(self, **config) -&gt; None:
        from vectorbt._settings import settings
        configured_cfg = settings[&#39;config&#39;][&#39;configured&#39;]

        self._config = Config(config, **configured_cfg)

    @property
    def config(self) -&gt; Config:
        &#34;&#34;&#34;Initialization config.&#34;&#34;&#34;
        return self._config

    def copy(self: ConfiguredT, **new_config) -&gt; ConfiguredT:
        &#34;&#34;&#34;Create a new instance based on the config.

        !!! warning
            This &#34;copy&#34; operation won&#39;t return a copy of the instance but a new instance
            initialized with the same config.&#34;&#34;&#34;
        return self.__class__(**self.config.merge_with(new_config))

    def dumps(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
        return self.config.dumps(**kwargs)

    @classmethod
    def loads(cls: tp.Type[ConfiguredT], dumps: bytes, **kwargs) -&gt; ConfiguredT:
        &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
        return cls(**Config.loads(dumps, **kwargs))

    def __eq__(self, other: tp.Any) -&gt; bool:
        &#34;&#34;&#34;Objects are equal if their configs are equal.&#34;&#34;&#34;
        if type(self) != type(other):
            return False
        return self.config == other.config

    def getattr(self, attr_chain: tp.Union[str, tuple, list]) -&gt; tp.Any:
        &#34;&#34;&#34;See `vectorbt.utils.attr.deep_getattr`.&#34;&#34;&#34;
        return deep_getattr(self, attr_chain)

    def update_config(self, *args, **kwargs) -&gt; None:
        &#34;&#34;&#34;Force-update the config.&#34;&#34;&#34;
        self.config.update(*args, **kwargs, force=True)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.utils.config.convert_to_dict"><code class="name flex">
<span>def <span class="ident">convert_to_dict</span></span>(<span>dct, nested=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert any dict (apart from <code><a title="vectorbt.utils.config.atomic_dict" href="#vectorbt.utils.config.atomic_dict">atomic_dict</a></code>) to <code>dict</code>.</p>
<p>Set <code>nested</code> to True to convert all child dicts in recursive manner.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_to_dict(dct: InConfigLikeT, nested: bool = True) -&gt; dict:
    &#34;&#34;&#34;Convert any dict (apart from `atomic_dict`) to `dict`.

    Set `nested` to True to convert all child dicts in recursive manner.&#34;&#34;&#34;
    if dct is None:
        dct = {}
    if isinstance(dct, atomic_dict):
        dct = atomic_dict(dct)
    else:
        dct = dict(dct)
    if not nested:
        return dct
    for k, v in dct.items():
        if isinstance(v, dict):
            dct[k] = convert_to_dict(v, nested=nested)
        else:
            dct[k] = v
    return dct</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.copy_dict"><code class="name flex">
<span>def <span class="ident">copy_dict</span></span>(<span>dct, copy_mode='shallow', nested=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy dict based on a copy mode.</p>
<p>The following modes are supported:</p>
<ul>
<li>'shallow': Copies keys only.</li>
<li>'hybrid': Copies keys and values using <code>copy.copy</code>.</li>
<li>'deep': Copies the whole thing using <code>copy.deepcopy</code>.</li>
</ul>
<p>Set <code>nested</code> to True to copy all child dicts in recursive manner.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_dict(dct: InConfigLikeT, copy_mode: str = &#39;shallow&#39;, nested: bool = True) -&gt; OutConfigLikeT:
    &#34;&#34;&#34;Copy dict based on a copy mode.

    The following modes are supported:

    * &#39;shallow&#39;: Copies keys only.
    * &#39;hybrid&#39;: Copies keys and values using `copy.copy`.
    * &#39;deep&#39;: Copies the whole thing using `copy.deepcopy`.

    Set `nested` to True to copy all child dicts in recursive manner.&#34;&#34;&#34;
    if dct is None:
        dct = {}
    checks.assert_type(copy_mode, str)
    copy_mode = copy_mode.lower()
    if copy_mode not in [&#39;shallow&#39;, &#39;hybrid&#39;, &#39;deep&#39;]:
        raise ValueError(f&#34;Copy mode &#39;{copy_mode}&#39; not supported&#34;)

    if copy_mode == &#39;deep&#39;:
        return deepcopy(dct)
    if isinstance(dct, Config):
        return dct.copy(
            copy_mode=copy_mode,
            nested=nested
        )
    dct_copy = copy(dct)  # copy structure using shallow copy
    for k, v in dct_copy.items():
        if nested and isinstance(v, dict):
            _v = copy_dict(v, copy_mode=copy_mode, nested=nested)
        else:
            if copy_mode == &#39;hybrid&#39;:
                _v = copy(v)  # copy values using shallow copy
            else:
                _v = v
        set_dict_item(dct_copy, k, _v, force=True)
    return dct_copy</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.get_func_kwargs"><code class="name flex">
<span>def <span class="ident">get_func_kwargs</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Get keyword arguments of the function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_func_kwargs(func: tp.Callable) -&gt; dict:
    &#34;&#34;&#34;Get keyword arguments of the function.&#34;&#34;&#34;
    signature = inspect.signature(func)
    return {
        k: v.default
        for k, v in signature.parameters.items()
        if v.default is not inspect.Parameter.empty
    }</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.merge_dicts"><code class="name flex">
<span>def <span class="ident">merge_dicts</span></span>(<span>*dicts, to_dict=True, copy_mode='shallow', nested=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge dicts.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*dicts</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dicts.</dd>
<dt><strong><code>to_dict</code></strong></dt>
<dd>Whether to call <code><a title="vectorbt.utils.config.convert_to_dict" href="#vectorbt.utils.config.convert_to_dict">convert_to_dict()</a></code> on each dict prior to copying.</dd>
<dt><strong><code>copy_mode</code></strong></dt>
<dd>
<p>Mode for <code><a title="vectorbt.utils.config.copy_dict" href="#vectorbt.utils.config.copy_dict">copy_dict()</a></code> to copy each dict prior to merging.</p>
<p>Pass None to not copy.</p>
</dd>
<dt><strong><code>nested</code></strong></dt>
<dd>Whether to merge all child dicts in recursive manner.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_dicts(*dicts: InConfigLikeT,
                to_dict: bool = True,
                copy_mode: tp.Optional[str] = &#39;shallow&#39;,
                nested: bool = True) -&gt; OutConfigLikeT:
    &#34;&#34;&#34;Merge dicts.

    Args:
        *dicts (dict): Dicts.
        to_dict: Whether to call `convert_to_dict` on each dict prior to copying.
        copy_mode: Mode for `copy_dict` to copy each dict prior to merging.

            Pass None to not copy.
        nested: Whether to merge all child dicts in recursive manner.&#34;&#34;&#34;
    # copy only once
    if to_dict:
        dicts = tuple([convert_to_dict(dct, nested=nested) for dct in dicts])
    if copy_mode is not None:
        dicts = tuple([copy_dict(dct, copy_mode=copy_mode, nested=nested) for dct in dicts])
    x, y = dicts[0], dicts[1]
    if isinstance(x, atomic_dict) or isinstance(y, atomic_dict):
        x = y
    else:
        update_dict(x, y, nested=nested, force=True)
    if len(dicts) &gt; 2:
        return merge_dicts(
            x, *dicts[2:],
            to_dict=False,  # executed only once
            copy_mode=None,  # executed only once
            nested=nested
        )
    return x</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.resolve_dict"><code class="name flex">
<span>def <span class="ident">resolve_dict</span></span>(<span>dct, i=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Select keyword arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_dict(dct: tp.DictLikeSequence, i: tp.Optional[int] = None) -&gt; dict:
    &#34;&#34;&#34;Select keyword arguments.&#34;&#34;&#34;
    if dct is None:
        dct = {}
    if isinstance(dct, dict):
        return dict(dct)
    if i is not None:
        _dct = dct[i]
        if _dct is None:
            _dct = {}
        return dict(_dct)
    raise ValueError(&#34;Cannot resolve dict&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.set_dict_item"><code class="name flex">
<span>def <span class="ident">set_dict_item</span></span>(<span>dct, k, v, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Set dict item.</p>
<p>If the dict is of the type <code><a title="vectorbt.utils.config.Config" href="#vectorbt.utils.config.Config">Config</a></code>, also passes <code>force</code> keyword to override blocking flags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dict_item(dct: dict, k: tp.Any, v: tp.Any, force: bool = False) -&gt; None:
    &#34;&#34;&#34;Set dict item.

    If the dict is of the type `Config`, also passes `force` keyword to override blocking flags.&#34;&#34;&#34;
    if isinstance(dct, Config):
        dct.__setitem__(k, v, force=force)
    else:
        dct[k] = v</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.update_dict"><code class="name flex">
<span>def <span class="ident">update_dict</span></span>(<span>x, y, nested=True, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Update dict with keys and values from other dict.</p>
<p>Set <code>nested</code> to True to update all child dicts in recursive manner.
For <code>force</code>, see <code><a title="vectorbt.utils.config.set_dict_item" href="#vectorbt.utils.config.set_dict_item">set_dict_item()</a></code>.</p>
<p>If you want to treat any dict as a single value, wrap it with <code><a title="vectorbt.utils.config.atomic_dict" href="#vectorbt.utils.config.atomic_dict">atomic_dict</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the child dict is not atomic, it will copy only its values, not its meta.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_dict(x: InConfigLikeT, y: InConfigLikeT, nested: bool = True, force: bool = False) -&gt; None:
    &#34;&#34;&#34;Update dict with keys and values from other dict.

    Set `nested` to True to update all child dicts in recursive manner.
    For `force`, see `set_dict_item`.

    If you want to treat any dict as a single value, wrap it with `atomic_dict`.

    !!! note
        If the child dict is not atomic, it will copy only its values, not its meta.&#34;&#34;&#34;
    if x is None:
        return
    if y is None:
        return
    checks.assert_type(x, dict)
    checks.assert_type(y, dict)

    for k, v in y.items():
        if nested \
                and k in x \
                and isinstance(x[k], dict) \
                and isinstance(v, dict) \
                and not isinstance(v, atomic_dict):
            update_dict(x[k], v, force=force)
        else:
            set_dict_item(x, k, v, force=force)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.utils.config.AtomicConfig"><code class="flex name class">
<span>class <span class="ident">AtomicConfig</span></span>
<span>(</span><span>dct=None, copy_kwargs=None, reset_dct=None, reset_dct_copy_kwargs=None, frozen_keys=None, readonly=None, nested=None, convert_dicts=None, as_attrs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Config that behaves like a single value when merging.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AtomicConfig(Config, atomic_dict):
    &#34;&#34;&#34;Config that behaves like a single value when merging.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.config.Config" href="#vectorbt.utils.config.Config">Config</a></li>
<li><a title="vectorbt.utils.config.PickleableDict" href="#vectorbt.utils.config.PickleableDict">PickleableDict</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.config.atomic_dict" href="#vectorbt.utils.config.atomic_dict">atomic_dict</a></li>
<li>builtins.dict</li>
</ul>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.utils.config.Config" href="#vectorbt.utils.config.Config">Config</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.utils.config.Config.as_attrs_" href="#vectorbt.utils.config.Config.as_attrs_">as_attrs_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.clear" href="#vectorbt.utils.config.Config.clear">clear</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.convert_dicts_" href="#vectorbt.utils.config.Config.convert_dicts_">convert_dicts_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.copy" href="#vectorbt.utils.config.Config.copy">copy</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.copy_kwargs_" href="#vectorbt.utils.config.Config.copy_kwargs_">copy_kwargs_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.dumps" href="#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.frozen_keys_" href="#vectorbt.utils.config.Config.frozen_keys_">frozen_keys_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.load" href="#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.load_update" href="#vectorbt.utils.config.Config.load_update">load_update</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.loads" href="#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.make_checkpoint" href="#vectorbt.utils.config.Config.make_checkpoint">make_checkpoint</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.merge_with" href="#vectorbt.utils.config.Config.merge_with">merge_with</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.nested_" href="#vectorbt.utils.config.Config.nested_">nested_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.pop" href="#vectorbt.utils.config.Config.pop">pop</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.popitem" href="#vectorbt.utils.config.Config.popitem">popitem</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.readonly_" href="#vectorbt.utils.config.Config.readonly_">readonly_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.reset" href="#vectorbt.utils.config.Config.reset">reset</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.reset_dct_" href="#vectorbt.utils.config.Config.reset_dct_">reset_dct_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.reset_dct_copy_kwargs_" href="#vectorbt.utils.config.Config.reset_dct_copy_kwargs_">reset_dct_copy_kwargs_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.save" href="#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.update" href="#vectorbt.utils.config.Config.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.utils.config.Config"><code class="flex name class">
<span>class <span class="ident">Config</span></span>
<span>(</span><span>dct=None, copy_kwargs=None, reset_dct=None, reset_dct_copy_kwargs=None, frozen_keys=None, readonly=None, nested=None, convert_dicts=None, as_attrs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends dict with config features such as nested updates, frozen keys/values, and pickling.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dct</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dict to construct this config from.</dd>
<dt><strong><code>copy_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Keyword arguments passed to <code><a title="vectorbt.utils.config.copy_dict" href="#vectorbt.utils.config.copy_dict">copy_dict()</a></code> for copying <code>dct</code> and <code>reset_dct</code>.</p>
<p>Copy mode defaults to 'shallow' if <code>readonly</code>, otherwise to 'hybrid'.</p>
</dd>
<dt><strong><code>reset_dct</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Dict to fall back to in case of resetting.</p>
<p>If None, copies <code>dct</code> using <code>reset_dct_copy_kwargs</code>.</p>
</dd>
<dt><strong><code>reset_dct_copy_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments that override <code>copy_kwargs</code> for <code>reset_dct</code>.</dd>
<dt><strong><code>frozen_keys</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to deny updates to the keys of the config.</p>
<p>Defaults to False.</p>
</dd>
<dt><strong><code>readonly</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to deny updates to the keys and values of the config.</p>
<p>Defaults to False.</p>
</dd>
<dt><strong><code>nested</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to do operations recursively on each child dict.</p>
<p>Such operations include copy, update, and merge.
Disable to treat each child dict as a single value. Defaults to True.</p>
</dd>
<dt><strong><code>convert_dicts</code></strong> :&ensp;<code>bool</code> or <code>type</code></dt>
<dd>
<p>Whether to convert child dicts to configs with the same configuration.</p>
<p>This will trigger a waterfall reaction across all child dicts.
Won't convert dicts that are already configs.
Apart from boolean, you can set it to any subclass of <code><a title="vectorbt.utils.config.Config" href="#vectorbt.utils.config.Config">Config</a></code> to use it for construction.
Requires <code>nested</code> to be True. Defaults to False.</p>
</dd>
<dt><strong><code>as_attrs</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to enable accessing dict keys via the dot notation.</p>
<p>Enables autocompletion (but only during runtime!).
Raises error in case of naming conflicts.
Defaults to True if <code>frozen</code> or <code>readonly</code>, otherwise False.</p>
</dd>
</dl>
<p>Defaults can be overridden with settings under <code>config</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p>
<p>If another config is passed, its properties are copied over, but they can still be overridden
with the arguments passed to the initializer.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All arguments are applied only once during initialization.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Config(PickleableDict):
    &#34;&#34;&#34;Extends dict with config features such as nested updates, frozen keys/values, and pickling.

    Args:
        dct (dict): Dict to construct this config from.
        copy_kwargs (dict): Keyword arguments passed to `copy_dict` for copying `dct` and `reset_dct`.

            Copy mode defaults to &#39;shallow&#39; if `readonly`, otherwise to &#39;hybrid&#39;.
        reset_dct (dict): Dict to fall back to in case of resetting.

            If None, copies `dct` using `reset_dct_copy_kwargs`.
        reset_dct_copy_kwargs (dict): Keyword arguments that override `copy_kwargs` for `reset_dct`.
        frozen_keys (bool): Whether to deny updates to the keys of the config.

            Defaults to False.
        readonly (bool): Whether to deny updates to the keys and values of the config.

            Defaults to False.
        nested (bool): Whether to do operations recursively on each child dict.

            Such operations include copy, update, and merge.
            Disable to treat each child dict as a single value. Defaults to True.
        convert_dicts (bool or type): Whether to convert child dicts to configs with the same configuration.

            This will trigger a waterfall reaction across all child dicts.
            Won&#39;t convert dicts that are already configs.
            Apart from boolean, you can set it to any subclass of `Config` to use it for construction.
            Requires `nested` to be True. Defaults to False.
        as_attrs (bool): Whether to enable accessing dict keys via the dot notation.

            Enables autocompletion (but only during runtime!).
            Raises error in case of naming conflicts.
            Defaults to True if `frozen` or `readonly`, otherwise False.

    Defaults can be overridden with settings under `config` in `vectorbt._settings.settings`.

    If another config is passed, its properties are copied over, but they can still be overridden
    with the arguments passed to the initializer.

    !!! note
        All arguments are applied only once during initialization.
    &#34;&#34;&#34;

    _copy_kwargs_: tp.Kwargs
    _reset_dct_: dict
    _reset_dct_copy_kwargs_: tp.Kwargs
    _frozen_keys_: bool
    _readonly_: bool
    _nested_: bool
    _convert_dicts_: tp.Union[bool, tp.Type[&#34;Config&#34;]]
    _as_attrs_: bool

    def __init__(self,
                 dct: tp.DictLike = None,
                 copy_kwargs: tp.KwargsLike = None,
                 reset_dct: tp.DictLike = None,
                 reset_dct_copy_kwargs: tp.KwargsLike = None,
                 frozen_keys: tp.Optional[bool] = None,
                 readonly: tp.Optional[bool] = None,
                 nested: tp.Optional[bool] = None,
                 convert_dicts: tp.Optional[tp.Union[bool, tp.Type[&#34;Config&#34;]]] = None,
                 as_attrs: tp.Optional[bool] = None) -&gt; None:
        try:
            from vectorbt._settings import settings
            configured_cfg = settings[&#39;config&#39;]
        except ImportError:
            configured_cfg = {}

        if dct is None:
            dct = dict()

        # Resolve params
        def _resolve_param(pname: str, p: tp.Any, default: tp.Any, merge: bool = False) -&gt; tp.Any:
            cfg_default = configured_cfg.get(pname, None)
            dct_p = getattr(dct, pname + &#39;_&#39;) if isinstance(dct, Config) else None

            if merge and isinstance(default, dict):
                return merge_dicts(default, cfg_default, dct_p, p)
            if p is not None:
                return p
            if dct_p is not None:
                return dct_p
            if cfg_default is not None:
                return cfg_default
            return default

        reset_dct = _resolve_param(&#39;reset_dct&#39;, reset_dct, None)
        frozen_keys = _resolve_param(&#39;frozen_keys&#39;, frozen_keys, False)
        readonly = _resolve_param(&#39;readonly&#39;, readonly, False)
        nested = _resolve_param(&#39;nested&#39;, nested, False)
        convert_dicts = _resolve_param(&#39;convert_dicts&#39;, convert_dicts, False)
        as_attrs = _resolve_param(&#39;as_attrs&#39;, as_attrs, frozen_keys or readonly)
        reset_dct_copy_kwargs = merge_dicts(copy_kwargs, reset_dct_copy_kwargs)
        copy_kwargs = _resolve_param(
            &#39;copy_kwargs&#39;,
            copy_kwargs,
            dict(
                copy_mode=&#39;shallow&#39; if readonly else &#39;hybrid&#39;,
                nested=nested
            ),
            merge=True
        )
        reset_dct_copy_kwargs = _resolve_param(
            &#39;reset_dct_copy_kwargs&#39;,
            reset_dct_copy_kwargs,
            dict(
                copy_mode=&#39;shallow&#39; if readonly else &#39;hybrid&#39;,
                nested=nested
            ),
            merge=True
        )

        # Copy dict
        dct = copy_dict(dict(dct), **copy_kwargs)

        # Convert child dicts
        if convert_dicts:
            if not nested:
                raise ValueError(&#34;convert_dicts requires nested to be True&#34;)
            for k, v in dct.items():
                if isinstance(v, dict) and not isinstance(v, Config):
                    if isinstance(convert_dicts, bool):
                        config_cls = self.__class__
                    elif issubclass(convert_dicts, Config):
                        config_cls = convert_dicts
                    else:
                        raise TypeError(&#34;convert_dicts must be either boolean or a subclass of Config&#34;)
                    dct[k] = config_cls(
                        v,
                        copy_kwargs=copy_kwargs,
                        reset_dct_copy_kwargs=reset_dct_copy_kwargs,
                        frozen_keys=frozen_keys,
                        readonly=readonly,
                        nested=nested,
                        convert_dicts=convert_dicts,
                        as_attrs=as_attrs
                    )

        # Copy initial config
        if reset_dct is None:
            reset_dct = dct
        reset_dct = copy_dict(dict(reset_dct), **reset_dct_copy_kwargs)

        dict.__init__(self, dct)

        # Store params in an instance variable
        checks.assert_type(copy_kwargs, dict)
        checks.assert_type(reset_dct, dict)
        checks.assert_type(reset_dct_copy_kwargs, dict)
        checks.assert_type(frozen_keys, bool)
        checks.assert_type(readonly, bool)
        checks.assert_type(nested, bool)
        checks.assert_type(convert_dicts, (bool, type))
        checks.assert_type(as_attrs, bool)

        self.__dict__[&#39;_copy_kwargs_&#39;] = copy_kwargs
        self.__dict__[&#39;_reset_dct_&#39;] = reset_dct
        self.__dict__[&#39;_reset_dct_copy_kwargs_&#39;] = reset_dct_copy_kwargs
        self.__dict__[&#39;_frozen_keys_&#39;] = frozen_keys
        self.__dict__[&#39;_readonly_&#39;] = readonly
        self.__dict__[&#39;_nested_&#39;] = nested
        self.__dict__[&#39;_convert_dicts_&#39;] = convert_dicts
        self.__dict__[&#39;_as_attrs_&#39;] = as_attrs

        # Set keys as attributes for autocomplete
        if as_attrs:
            for k, v in self.items():
                if k in self.__dir__():
                    raise ValueError(f&#34;Cannot set key &#39;{k}&#39; as attribute of the config. Disable set_attrs.&#34;)
                self.__dict__[k] = v

    @property
    def copy_kwargs_(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Parameters for copying `dct`.&#34;&#34;&#34;
        return self._copy_kwargs_

    @property
    def reset_dct_(self) -&gt; dict:
        &#34;&#34;&#34;Dict to fall back to in case of resetting.&#34;&#34;&#34;
        return self._reset_dct_

    @property
    def reset_dct_copy_kwargs_(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Parameters for copying `reset_dct`.&#34;&#34;&#34;
        return self._reset_dct_copy_kwargs_

    @property
    def frozen_keys_(self) -&gt; bool:
        &#34;&#34;&#34;Whether to deny updates to the keys and values of the config.&#34;&#34;&#34;
        return self._frozen_keys_

    @property
    def readonly_(self) -&gt; bool:
        &#34;&#34;&#34;Whether to deny any updates to the config.&#34;&#34;&#34;
        return self._readonly_

    @property
    def nested_(self) -&gt; bool:
        &#34;&#34;&#34;Whether to do operations recursively on each child dict.&#34;&#34;&#34;
        return self._nested_

    @property
    def convert_dicts_(self) -&gt; tp.Union[bool, tp.Type[&#34;Config&#34;]]:
        &#34;&#34;&#34;Whether to convert child dicts to configs with the same configuration.&#34;&#34;&#34;
        return self._convert_dicts_

    @property
    def as_attrs_(self) -&gt; bool:
        &#34;&#34;&#34;Whether to enable accessing dict keys via dot notation.&#34;&#34;&#34;
        return self._as_attrs_

    def __setattr__(self, k: str, v: tp.Any) -&gt; None:
        if self.as_attrs_:
            self.__setitem__(k, v)

    def __setitem__(self, k: str, v: tp.Any, force: bool = False) -&gt; None:
        if not force and self.readonly_:
            raise TypeError(&#34;Config is read-only&#34;)
        if not force and self.frozen_keys_:
            if k not in self:
                raise KeyError(f&#34;Config keys are frozen: key &#39;{k}&#39; not found&#34;)
        dict.__setitem__(self, k, v)
        if self.as_attrs_:
            self.__dict__[k] = v

    def __delattr__(self, k: str) -&gt; None:
        if self.as_attrs_:
            self.__delitem__(k)

    def __delitem__(self, k: str, force: bool = False) -&gt; None:
        if not force and self.readonly_:
            raise TypeError(&#34;Config is read-only&#34;)
        if not force and self.frozen_keys_:
            raise KeyError(f&#34;Config keys are frozen&#34;)
        dict.__delitem__(self, k)
        if self.as_attrs_:
            del self.__dict__[k]

    def _clear_attrs(self, prior_keys: tp.Iterable[str]) -&gt; None:
        &#34;&#34;&#34;Remove attributes of the removed keys given keys prior to the removal.&#34;&#34;&#34;
        if self.as_attrs_:
            for k in set(prior_keys).difference(self.keys()):
                del self.__dict__[k]

    def pop(self, k: str, v: tp.Any = _RaiseKeyError, force: bool = False) -&gt; tp.Any:
        &#34;&#34;&#34;Remove and return the pair by the key.&#34;&#34;&#34;
        if not force and self.readonly_:
            raise TypeError(&#34;Config is read-only&#34;)
        if not force and self.frozen_keys_:
            raise KeyError(f&#34;Config keys are frozen&#34;)
        prior_keys = list(self.keys())
        if v is _RaiseKeyError:
            result = dict.pop(self, k)
        else:
            result = dict.pop(self, k, v)
        self._clear_attrs(prior_keys)
        return result

    def popitem(self, force: bool = False) -&gt; tp.Tuple[tp.Any, tp.Any]:
        &#34;&#34;&#34;Remove and return some pair.&#34;&#34;&#34;
        if not force and self.readonly_:
            raise TypeError(&#34;Config is read-only&#34;)
        if not force and self.frozen_keys_:
            raise KeyError(f&#34;Config keys are frozen&#34;)
        prior_keys = list(self.keys())
        result = dict.popitem(self)
        self._clear_attrs(prior_keys)
        return result

    def clear(self, force: bool = False) -&gt; None:
        &#34;&#34;&#34;Remove all items.&#34;&#34;&#34;
        if not force and self.readonly_:
            raise TypeError(&#34;Config is read-only&#34;)
        if not force and self.frozen_keys_:
            raise KeyError(f&#34;Config keys are frozen&#34;)
        prior_keys = list(self.keys())
        dict.clear(self)
        self._clear_attrs(prior_keys)

    def update(self, *args, nested: tp.Optional[bool] = None, force: bool = False, **kwargs) -&gt; None:
        &#34;&#34;&#34;Update the config.

        See `update_dict`.&#34;&#34;&#34;
        other = dict(*args, **kwargs)
        if nested is None:
            nested = self.nested_
        update_dict(self, other, nested=nested, force=force)

    def __copy__(self: ConfigT) -&gt; ConfigT:
        &#34;&#34;&#34;Shallow operation, primarily used by `copy.copy`.

        Does not take into account copy parameters.&#34;&#34;&#34;
        cls = self.__class__
        self_copy = cls.__new__(cls)
        for k, v in self.__dict__.items():
            if k not in self_copy:  # otherwise copies dict keys twice
                self_copy.__dict__[k] = v
        self_copy.clear(force=True)
        self_copy.update(copy(dict(self)), nested=False, force=True)
        return self_copy

    def __deepcopy__(self: ConfigT, memo: tp.DictLike = None) -&gt; ConfigT:
        &#34;&#34;&#34;Deep operation, primarily used by `copy.deepcopy`.

        Does not take into account copy parameters.&#34;&#34;&#34;
        if memo is None:
            memo = {}
        cls = self.__class__
        self_copy = cls.__new__(cls)
        memo[id(self)] = self_copy
        for k, v in self.__dict__.items():
            if k not in self_copy:  # otherwise copies dict keys twice
                self_copy.__dict__[k] = deepcopy(v, memo)
        self_copy.clear(force=True)
        self_copy.update(deepcopy(dict(self), memo), nested=False, force=True)
        return self_copy

    def copy(self: ConfigT, reset_dct_copy_kwargs: tp.KwargsLike = None, **copy_kwargs) -&gt; ConfigT:
        &#34;&#34;&#34;Copy the instance in the same way it&#39;s done during initialization.

        `copy_kwargs` override `Config.copy_kwargs_` and `Config.reset_dct_copy_kwargs_` via merging.
        `reset_dct_copy_kwargs` override merged `Config.reset_dct_copy_kwargs_`.&#34;&#34;&#34;
        self_copy = self.__copy__()

        reset_dct_copy_kwargs = merge_dicts(self.reset_dct_copy_kwargs_, copy_kwargs, reset_dct_copy_kwargs)
        reset_dct = copy_dict(dict(self.reset_dct_), **reset_dct_copy_kwargs)
        self.__dict__[&#39;_reset_dct_&#39;] = reset_dct

        copy_kwargs = merge_dicts(self.copy_kwargs_, copy_kwargs)
        dct = copy_dict(dict(self), **copy_kwargs)
        self_copy.update(dct, nested=False, force=True)

        return self_copy

    def merge_with(self: ConfigT, other: InConfigLikeT,
                   nested: tp.Optional[bool] = None, **kwargs) -&gt; OutConfigLikeT:
        &#34;&#34;&#34;Merge with another dict into one single dict.

        See `merge_dicts`.&#34;&#34;&#34;
        if nested is None:
            nested = self.nested_
        return merge_dicts(self, other, nested=nested, **kwargs)

    def reset(self, force: bool = False, **reset_dct_copy_kwargs) -&gt; None:
        &#34;&#34;&#34;Clears the config and updates it with the initial config.

        `reset_dct_copy_kwargs` override `Config.reset_dct_copy_kwargs_`.&#34;&#34;&#34;
        if not force and self.readonly_:
            raise TypeError(&#34;Config is read-only&#34;)
        reset_dct_copy_kwargs = merge_dicts(self.reset_dct_copy_kwargs_, reset_dct_copy_kwargs)
        reset_dct = copy_dict(dict(self.reset_dct_), **reset_dct_copy_kwargs)
        self.clear(force=True)
        self.update(self.reset_dct_, nested=False, force=True)
        self.__dict__[&#39;_reset_dct_&#39;] = reset_dct

    def make_checkpoint(self, force: bool = False, **reset_dct_copy_kwargs) -&gt; None:
        &#34;&#34;&#34;Replace `reset_dct` by the current state.

        `reset_dct_copy_kwargs` override `Config.reset_dct_copy_kwargs_`.&#34;&#34;&#34;
        if not force and self.readonly_:
            raise TypeError(&#34;Config is read-only&#34;)
        reset_dct_copy_kwargs = merge_dicts(self.reset_dct_copy_kwargs_, reset_dct_copy_kwargs)
        reset_dct = copy_dict(dict(self), **reset_dct_copy_kwargs)
        self.__dict__[&#39;_reset_dct_&#39;] = reset_dct

    def dumps(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
        return dill.dumps(dict(
            dct=PickleableDict(self).dumps(**kwargs),
            copy_kwargs=self.copy_kwargs_,
            reset_dct=PickleableDict(self.reset_dct_).dumps(**kwargs),
            reset_dct_copy_kwargs=self.reset_dct_copy_kwargs_,
            frozen_keys=self.frozen_keys_,
            readonly=self.readonly_,
            nested=self.nested_,
            convert_dicts=self.convert_dicts_,
            as_attrs=self.as_attrs_
        ), **kwargs)

    @classmethod
    def loads(cls: tp.Type[ConfigT], dumps: bytes, **kwargs) -&gt; ConfigT:
        &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
        obj = dill.loads(dumps, **kwargs)
        return cls(
            dct=PickleableDict.loads(obj[&#39;dct&#39;], **kwargs),
            copy_kwargs=obj[&#39;copy_kwargs&#39;],
            reset_dct=PickleableDict.loads(obj[&#39;reset_dct&#39;], **kwargs),
            reset_dct_copy_kwargs=obj[&#39;reset_dct_copy_kwargs&#39;],
            frozen_keys=obj[&#39;frozen_keys&#39;],
            readonly=obj[&#39;readonly&#39;],
            nested=obj[&#39;nested&#39;],
            convert_dicts=obj[&#39;convert_dicts&#39;],
            as_attrs=obj[&#39;as_attrs&#39;]
        )

    def load_update(self, fname: tp.FileName, **kwargs) -&gt; None:
        &#34;&#34;&#34;Load dumps from a file and update this instance.

        !!! note
            Updates both the config properties and dictionary.&#34;&#34;&#34;
        loaded = self.load(fname, **kwargs)
        self.clear(force=True)
        self.__dict__.clear()
        self.__dict__.update(loaded.__dict__)
        self.update(loaded, nested=False, force=True)

    def __eq__(self, other: tp.Any) -&gt; bool:
        return checks.is_deep_equal(dict(self), dict(other))</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.config.PickleableDict" href="#vectorbt.utils.config.PickleableDict">PickleableDict</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li>builtins.dict</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt._settings.SettingsConfig" href="../_settings.html#vectorbt._settings.SettingsConfig">SettingsConfig</a></li>
<li><a title="vectorbt.utils.config.AtomicConfig" href="#vectorbt.utils.config.AtomicConfig">AtomicConfig</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.utils.config.Config.as_attrs_"><code class="name">var <span class="ident">as_attrs_</span></code></dt>
<dd>
<div class="desc"><p>Whether to enable accessing dict keys via dot notation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_attrs_(self) -&gt; bool:
    &#34;&#34;&#34;Whether to enable accessing dict keys via dot notation.&#34;&#34;&#34;
    return self._as_attrs_</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.convert_dicts_"><code class="name">var <span class="ident">convert_dicts_</span></code></dt>
<dd>
<div class="desc"><p>Whether to convert child dicts to configs with the same configuration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def convert_dicts_(self) -&gt; tp.Union[bool, tp.Type[&#34;Config&#34;]]:
    &#34;&#34;&#34;Whether to convert child dicts to configs with the same configuration.&#34;&#34;&#34;
    return self._convert_dicts_</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.copy_kwargs_"><code class="name">var <span class="ident">copy_kwargs_</span></code></dt>
<dd>
<div class="desc"><p>Parameters for copying <code>dct</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def copy_kwargs_(self) -&gt; tp.Kwargs:
    &#34;&#34;&#34;Parameters for copying `dct`.&#34;&#34;&#34;
    return self._copy_kwargs_</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.frozen_keys_"><code class="name">var <span class="ident">frozen_keys_</span></code></dt>
<dd>
<div class="desc"><p>Whether to deny updates to the keys and values of the config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frozen_keys_(self) -&gt; bool:
    &#34;&#34;&#34;Whether to deny updates to the keys and values of the config.&#34;&#34;&#34;
    return self._frozen_keys_</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.nested_"><code class="name">var <span class="ident">nested_</span></code></dt>
<dd>
<div class="desc"><p>Whether to do operations recursively on each child dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nested_(self) -&gt; bool:
    &#34;&#34;&#34;Whether to do operations recursively on each child dict.&#34;&#34;&#34;
    return self._nested_</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.readonly_"><code class="name">var <span class="ident">readonly_</span></code></dt>
<dd>
<div class="desc"><p>Whether to deny any updates to the config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def readonly_(self) -&gt; bool:
    &#34;&#34;&#34;Whether to deny any updates to the config.&#34;&#34;&#34;
    return self._readonly_</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.reset_dct_"><code class="name">var <span class="ident">reset_dct_</span></code></dt>
<dd>
<div class="desc"><p>Dict to fall back to in case of resetting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reset_dct_(self) -&gt; dict:
    &#34;&#34;&#34;Dict to fall back to in case of resetting.&#34;&#34;&#34;
    return self._reset_dct_</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.reset_dct_copy_kwargs_"><code class="name">var <span class="ident">reset_dct_copy_kwargs_</span></code></dt>
<dd>
<div class="desc"><p>Parameters for copying <code>reset_dct</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reset_dct_copy_kwargs_(self) -&gt; tp.Kwargs:
    &#34;&#34;&#34;Parameters for copying `reset_dct`.&#34;&#34;&#34;
    return self._reset_dct_copy_kwargs_</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.utils.config.Config.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all items.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self, force: bool = False) -&gt; None:
    &#34;&#34;&#34;Remove all items.&#34;&#34;&#34;
    if not force and self.readonly_:
        raise TypeError(&#34;Config is read-only&#34;)
    if not force and self.frozen_keys_:
        raise KeyError(f&#34;Config keys are frozen&#34;)
    prior_keys = list(self.keys())
    dict.clear(self)
    self._clear_attrs(prior_keys)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, reset_dct_copy_kwargs=None, **copy_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy the instance in the same way it's done during initialization.</p>
<p><code>copy_kwargs</code> override <code><a title="vectorbt.utils.config.Config.copy_kwargs_" href="#vectorbt.utils.config.Config.copy_kwargs_">Config.copy_kwargs_</a></code> and <code><a title="vectorbt.utils.config.Config.reset_dct_copy_kwargs_" href="#vectorbt.utils.config.Config.reset_dct_copy_kwargs_">Config.reset_dct_copy_kwargs_</a></code> via merging.
<code>reset_dct_copy_kwargs</code> override merged <code><a title="vectorbt.utils.config.Config.reset_dct_copy_kwargs_" href="#vectorbt.utils.config.Config.reset_dct_copy_kwargs_">Config.reset_dct_copy_kwargs_</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self: ConfigT, reset_dct_copy_kwargs: tp.KwargsLike = None, **copy_kwargs) -&gt; ConfigT:
    &#34;&#34;&#34;Copy the instance in the same way it&#39;s done during initialization.

    `copy_kwargs` override `Config.copy_kwargs_` and `Config.reset_dct_copy_kwargs_` via merging.
    `reset_dct_copy_kwargs` override merged `Config.reset_dct_copy_kwargs_`.&#34;&#34;&#34;
    self_copy = self.__copy__()

    reset_dct_copy_kwargs = merge_dicts(self.reset_dct_copy_kwargs_, copy_kwargs, reset_dct_copy_kwargs)
    reset_dct = copy_dict(dict(self.reset_dct_), **reset_dct_copy_kwargs)
    self.__dict__[&#39;_reset_dct_&#39;] = reset_dct

    copy_kwargs = merge_dicts(self.copy_kwargs_, copy_kwargs)
    dct = copy_dict(dict(self), **copy_kwargs)
    self_copy.update(dct, nested=False, force=True)

    return self_copy</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.load_update"><code class="name flex">
<span>def <span class="ident">load_update</span></span>(<span>self, fname, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load dumps from a file and update this instance.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Updates both the config properties and dictionary.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_update(self, fname: tp.FileName, **kwargs) -&gt; None:
    &#34;&#34;&#34;Load dumps from a file and update this instance.

    !!! note
        Updates both the config properties and dictionary.&#34;&#34;&#34;
    loaded = self.load(fname, **kwargs)
    self.clear(force=True)
    self.__dict__.clear()
    self.__dict__.update(loaded.__dict__)
    self.update(loaded, nested=False, force=True)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.make_checkpoint"><code class="name flex">
<span>def <span class="ident">make_checkpoint</span></span>(<span>self, force=False, **reset_dct_copy_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace <code>reset_dct</code> by the current state.</p>
<p><code>reset_dct_copy_kwargs</code> override <code><a title="vectorbt.utils.config.Config.reset_dct_copy_kwargs_" href="#vectorbt.utils.config.Config.reset_dct_copy_kwargs_">Config.reset_dct_copy_kwargs_</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_checkpoint(self, force: bool = False, **reset_dct_copy_kwargs) -&gt; None:
    &#34;&#34;&#34;Replace `reset_dct` by the current state.

    `reset_dct_copy_kwargs` override `Config.reset_dct_copy_kwargs_`.&#34;&#34;&#34;
    if not force and self.readonly_:
        raise TypeError(&#34;Config is read-only&#34;)
    reset_dct_copy_kwargs = merge_dicts(self.reset_dct_copy_kwargs_, reset_dct_copy_kwargs)
    reset_dct = copy_dict(dict(self), **reset_dct_copy_kwargs)
    self.__dict__[&#39;_reset_dct_&#39;] = reset_dct</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.merge_with"><code class="name flex">
<span>def <span class="ident">merge_with</span></span>(<span>self, other, nested=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge with another dict into one single dict.</p>
<p>See <code><a title="vectorbt.utils.config.merge_dicts" href="#vectorbt.utils.config.merge_dicts">merge_dicts()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_with(self: ConfigT, other: InConfigLikeT,
               nested: tp.Optional[bool] = None, **kwargs) -&gt; OutConfigLikeT:
    &#34;&#34;&#34;Merge with another dict into one single dict.

    See `merge_dicts`.&#34;&#34;&#34;
    if nested is None:
        nested = self.nested_
    return merge_dicts(self, other, nested=nested, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, k, v=&lt;object object&gt;, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove and return the pair by the key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, k: str, v: tp.Any = _RaiseKeyError, force: bool = False) -&gt; tp.Any:
    &#34;&#34;&#34;Remove and return the pair by the key.&#34;&#34;&#34;
    if not force and self.readonly_:
        raise TypeError(&#34;Config is read-only&#34;)
    if not force and self.frozen_keys_:
        raise KeyError(f&#34;Config keys are frozen&#34;)
    prior_keys = list(self.keys())
    if v is _RaiseKeyError:
        result = dict.pop(self, k)
    else:
        result = dict.pop(self, k, v)
    self._clear_attrs(prior_keys)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.popitem"><code class="name flex">
<span>def <span class="ident">popitem</span></span>(<span>self, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove and return some pair.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popitem(self, force: bool = False) -&gt; tp.Tuple[tp.Any, tp.Any]:
    &#34;&#34;&#34;Remove and return some pair.&#34;&#34;&#34;
    if not force and self.readonly_:
        raise TypeError(&#34;Config is read-only&#34;)
    if not force and self.frozen_keys_:
        raise KeyError(f&#34;Config keys are frozen&#34;)
    prior_keys = list(self.keys())
    result = dict.popitem(self)
    self._clear_attrs(prior_keys)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, force=False, **reset_dct_copy_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the config and updates it with the initial config.</p>
<p><code>reset_dct_copy_kwargs</code> override <code><a title="vectorbt.utils.config.Config.reset_dct_copy_kwargs_" href="#vectorbt.utils.config.Config.reset_dct_copy_kwargs_">Config.reset_dct_copy_kwargs_</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self, force: bool = False, **reset_dct_copy_kwargs) -&gt; None:
    &#34;&#34;&#34;Clears the config and updates it with the initial config.

    `reset_dct_copy_kwargs` override `Config.reset_dct_copy_kwargs_`.&#34;&#34;&#34;
    if not force and self.readonly_:
        raise TypeError(&#34;Config is read-only&#34;)
    reset_dct_copy_kwargs = merge_dicts(self.reset_dct_copy_kwargs_, reset_dct_copy_kwargs)
    reset_dct = copy_dict(dict(self.reset_dct_), **reset_dct_copy_kwargs)
    self.clear(force=True)
    self.update(self.reset_dct_, nested=False, force=True)
    self.__dict__[&#39;_reset_dct_&#39;] = reset_dct</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Config.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, *args, nested=None, force=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the config.</p>
<p>See <code><a title="vectorbt.utils.config.update_dict" href="#vectorbt.utils.config.update_dict">update_dict()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, *args, nested: tp.Optional[bool] = None, force: bool = False, **kwargs) -&gt; None:
    &#34;&#34;&#34;Update the config.

    See `update_dict`.&#34;&#34;&#34;
    other = dict(*args, **kwargs)
    if nested is None:
        nested = self.nested_
    update_dict(self, other, nested=nested, force=force)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.utils.config.PickleableDict" href="#vectorbt.utils.config.PickleableDict">PickleableDict</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.utils.config.PickleableDict.dumps" href="#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.utils.config.PickleableDict.load" href="#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.utils.config.PickleableDict.loads" href="#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.utils.config.PickleableDict.save" href="#vectorbt.utils.config.Pickleable.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.utils.config.Configured"><code class="flex name class">
<span>class <span class="ident">Configured</span></span>
<span>(</span><span>**config)</span>
</code></dt>
<dd>
<div class="desc"><p>Class with an initialization config.</p>
<p>All operations are done using config rather than the instance, which makes it easier to pickle.</p>
<p>Config settings are defined under <code>config.configured</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If the instance has writable attributes or depends upon global defaults,
their values won't be copied over. Make sure to pass them explicitly to
make the saved &amp; loaded / copied instance resilient to changes in globals.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Configured(Pickleable):
    &#34;&#34;&#34;Class with an initialization config.

    All operations are done using config rather than the instance, which makes it easier to pickle.

    Config settings are defined under `config.configured` in `vectorbt._settings.settings`.

    !!! warning
        If the instance has writable attributes or depends upon global defaults,
        their values won&#39;t be copied over. Make sure to pass them explicitly to
        make the saved &amp; loaded / copied instance resilient to changes in globals.&#34;&#34;&#34;

    def __init__(self, **config) -&gt; None:
        from vectorbt._settings import settings
        configured_cfg = settings[&#39;config&#39;][&#39;configured&#39;]

        self._config = Config(config, **configured_cfg)

    @property
    def config(self) -&gt; Config:
        &#34;&#34;&#34;Initialization config.&#34;&#34;&#34;
        return self._config

    def copy(self: ConfiguredT, **new_config) -&gt; ConfiguredT:
        &#34;&#34;&#34;Create a new instance based on the config.

        !!! warning
            This &#34;copy&#34; operation won&#39;t return a copy of the instance but a new instance
            initialized with the same config.&#34;&#34;&#34;
        return self.__class__(**self.config.merge_with(new_config))

    def dumps(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
        return self.config.dumps(**kwargs)

    @classmethod
    def loads(cls: tp.Type[ConfiguredT], dumps: bytes, **kwargs) -&gt; ConfiguredT:
        &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
        return cls(**Config.loads(dumps, **kwargs))

    def __eq__(self, other: tp.Any) -&gt; bool:
        &#34;&#34;&#34;Objects are equal if their configs are equal.&#34;&#34;&#34;
        if type(self) != type(other):
            return False
        return self.config == other.config

    def getattr(self, attr_chain: tp.Union[str, tuple, list]) -&gt; tp.Any:
        &#34;&#34;&#34;See `vectorbt.utils.attr.deep_getattr`.&#34;&#34;&#34;
        return deep_getattr(self, attr_chain)

    def update_config(self, *args, **kwargs) -&gt; None:
        &#34;&#34;&#34;Force-update the config.&#34;&#34;&#34;
        self.config.update(*args, **kwargs, force=True)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.config.Pickleable" href="#vectorbt.utils.config.Pickleable">Pickleable</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></li>
<li><a title="vectorbt.data.updater.DataUpdater" href="../data/updater.html#vectorbt.data.updater.DataUpdater">DataUpdater</a></li>
<li><a title="vectorbt.generic.plotting.Bar" href="../generic/plotting.html#vectorbt.generic.plotting.Bar">Bar</a></li>
<li><a title="vectorbt.generic.plotting.Box" href="../generic/plotting.html#vectorbt.generic.plotting.Box">Box</a></li>
<li><a title="vectorbt.generic.plotting.Gauge" href="../generic/plotting.html#vectorbt.generic.plotting.Gauge">Gauge</a></li>
<li><a title="vectorbt.generic.plotting.Heatmap" href="../generic/plotting.html#vectorbt.generic.plotting.Heatmap">Heatmap</a></li>
<li><a title="vectorbt.generic.plotting.Histogram" href="../generic/plotting.html#vectorbt.generic.plotting.Histogram">Histogram</a></li>
<li><a title="vectorbt.generic.plotting.Scatter" href="../generic/plotting.html#vectorbt.generic.plotting.Scatter">Scatter</a></li>
<li><a title="vectorbt.generic.plotting.Volume" href="../generic/plotting.html#vectorbt.generic.plotting.Volume">Volume</a></li>
<li><a title="vectorbt.messaging.telegram.TelegramBot" href="../messaging/telegram.html#vectorbt.messaging.telegram.TelegramBot">TelegramBot</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.utils.config.Configured.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"><p>Initialization config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def config(self) -&gt; Config:
    &#34;&#34;&#34;Initialization config.&#34;&#34;&#34;
    return self._config</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.utils.config.Configured.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, **new_config)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new instance based on the config.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This "copy" operation won't return a copy of the instance but a new instance
initialized with the same config.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self: ConfiguredT, **new_config) -&gt; ConfiguredT:
    &#34;&#34;&#34;Create a new instance based on the config.

    !!! warning
        This &#34;copy&#34; operation won&#39;t return a copy of the instance but a new instance
        initialized with the same config.&#34;&#34;&#34;
    return self.__class__(**self.config.merge_with(new_config))</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Configured.getattr"><code class="name flex">
<span>def <span class="ident">getattr</span></span>(<span>self, attr_chain)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.utils.attr.deep_getattr" href="attr.html#vectorbt.utils.attr.deep_getattr">deep_getattr()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getattr(self, attr_chain: tp.Union[str, tuple, list]) -&gt; tp.Any:
    &#34;&#34;&#34;See `vectorbt.utils.attr.deep_getattr`.&#34;&#34;&#34;
    return deep_getattr(self, attr_chain)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Configured.update_config"><code class="name flex">
<span>def <span class="ident">update_config</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Force-update the config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_config(self, *args, **kwargs) -&gt; None:
    &#34;&#34;&#34;Force-update the config.&#34;&#34;&#34;
    self.config.update(*args, **kwargs, force=True)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.utils.config.Pickleable" href="#vectorbt.utils.config.Pickleable">Pickleable</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.utils.config.Pickleable.dumps" href="#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.load" href="#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.loads" href="#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.save" href="#vectorbt.utils.config.Pickleable.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.utils.config.DumpTuple"><code class="flex name class">
<span>class <span class="ident">DumpTuple</span></span>
<span>(</span><span>cls, dumps)</span>
</code></dt>
<dd>
<div class="desc"><p>DumpTuple(cls, dumps)</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.utils.config.DumpTuple.cls"><code class="name">var <span class="ident">cls</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="vectorbt.utils.config.DumpTuple.dumps"><code class="name">var <span class="ident">dumps</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="vectorbt.utils.config.Pickleable"><code class="flex name class">
<span>class <span class="ident">Pickleable</span></span>
</code></dt>
<dd>
<div class="desc"><p>Superclass that defines abstract properties and methods for pickle-able classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pickleable:
    &#34;&#34;&#34;Superclass that defines abstract properties and methods for pickle-able classes.&#34;&#34;&#34;

    def dumps(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def loads(cls: tp.Type[PickleableT], dumps: bytes, **kwargs) -&gt; PickleableT:
        &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
        raise NotImplementedError

    def save(self, fname: tp.FileName, **kwargs) -&gt; None:
        &#34;&#34;&#34;Save dumps to a file.&#34;&#34;&#34;
        dumps = self.dumps(**kwargs)
        with open(fname, &#34;wb&#34;) as f:
            f.write(dumps)

    @classmethod
    def load(cls: tp.Type[PickleableT], fname: tp.FileName, **kwargs) -&gt; PickleableT:
        &#34;&#34;&#34;Load dumps from a file and create new instance.&#34;&#34;&#34;
        with open(fname, &#34;rb&#34;) as f:
            dumps = f.read()
        return cls.loads(dumps, **kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.config.Configured" href="#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.PickleableDict" href="#vectorbt.utils.config.PickleableDict">PickleableDict</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.utils.config.Pickleable.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>fname, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load dumps from a file and create new instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls: tp.Type[PickleableT], fname: tp.FileName, **kwargs) -&gt; PickleableT:
    &#34;&#34;&#34;Load dumps from a file and create new instance.&#34;&#34;&#34;
    with open(fname, &#34;rb&#34;) as f:
        dumps = f.read()
    return cls.loads(dumps, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Pickleable.loads"><code class="name flex">
<span>def <span class="ident">loads</span></span>(<span>dumps, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Unpickle from bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def loads(cls: tp.Type[PickleableT], dumps: bytes, **kwargs) -&gt; PickleableT:
    &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.utils.config.Pickleable.dumps"><code class="name flex">
<span>def <span class="ident">dumps</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Pickle to bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dumps(self, **kwargs) -&gt; bytes:
    &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.config.Pickleable.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, fname, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Save dumps to a file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, fname: tp.FileName, **kwargs) -&gt; None:
    &#34;&#34;&#34;Save dumps to a file.&#34;&#34;&#34;
    dumps = self.dumps(**kwargs)
    with open(fname, &#34;wb&#34;) as f:
        f.write(dumps)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.utils.config.PickleableDict"><code class="flex name class">
<span>class <span class="ident">PickleableDict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Dict that may contain values of type <code><a title="vectorbt.utils.config.Pickleable" href="#vectorbt.utils.config.Pickleable">Pickleable</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PickleableDict(Pickleable, dict):
    &#34;&#34;&#34;Dict that may contain values of type `Pickleable`.&#34;&#34;&#34;

    def dumps(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Pickle to bytes.&#34;&#34;&#34;
        dct = dict()
        for k, v in self.items():
            if isinstance(v, Pickleable):
                dct[k] = DumpTuple(cls=v.__class__, dumps=v.dumps(**kwargs))
            else:
                dct[k] = v
        return dill.dumps(dct, **kwargs)

    @classmethod
    def loads(cls: tp.Type[PickleableDictT], dumps: bytes, **kwargs) -&gt; PickleableDictT:
        &#34;&#34;&#34;Unpickle from bytes.&#34;&#34;&#34;
        config = dill.loads(dumps, **kwargs)
        for k, v in config.items():
            if isinstance(v, DumpTuple):
                config[k] = v.cls.loads(v.dumps, **kwargs)
        return cls(**config)

    def load_update(self, fname: tp.FileName, **kwargs) -&gt; None:
        &#34;&#34;&#34;Load dumps from a file and update this instance.&#34;&#34;&#34;
        self.clear()
        self.update(self.load(fname, **kwargs))</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.config.Pickleable" href="#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li>builtins.dict</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.config.Config" href="#vectorbt.utils.config.Config">Config</a></li>
</ul>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.utils.config.PickleableDict.load_update"><code class="name flex">
<span>def <span class="ident">load_update</span></span>(<span>self, fname, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load dumps from a file and update this instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_update(self, fname: tp.FileName, **kwargs) -&gt; None:
    &#34;&#34;&#34;Load dumps from a file and update this instance.&#34;&#34;&#34;
    self.clear()
    self.update(self.load(fname, **kwargs))</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.utils.config.Pickleable" href="#vectorbt.utils.config.Pickleable">Pickleable</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.utils.config.Pickleable.dumps" href="#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.load" href="#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.loads" href="#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.save" href="#vectorbt.utils.config.Pickleable.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.utils.config.atomic_dict"><code class="flex name class">
<span>class <span class="ident">atomic_dict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Dict that behaves like a single value when merging.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class atomic_dict(dict):
    &#34;&#34;&#34;Dict that behaves like a single value when merging.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.config.AtomicConfig" href="#vectorbt.utils.config.AtomicConfig">AtomicConfig</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRUYwMDAwO30KCS5zdDF7ZmlsbDojRkY5MDAwO30KCS5zdDJ7ZmlsbDojRkZERjAwO30KCS5zdDN7ZmlsbDojMjgyQzM0O30KPC9zdHlsZT4KPGc+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNTUuMywzMDAuMSAyODMuMSwwIDIwOCwwIDExMC44LDAgMzUuOCwwIDEuMiw0NTAuMiA3Ni4zLDQ1MC4yIAkJCSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjIzMC40LDMwMC4xIDM1OC4xLDAgMjgzLjEsMCAxODUuOCwwIDExMC44LDAgNzYuMyw0NTAuMiAxNTEuMyw0NTAuMiAJCQkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIzMDUuNCwzMDAuMSA0MzMuMSwwIDM1OC4xLDAgMzMxLjYsNjIuMyAyNjAuOCwwIDE4NS44LDAgMTUxLjMsNDUwLjIgMjI2LjQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iNTEwLjgsMCA0MzMuMSwwIDMwNS40LDMwMC4xIDMzOC40LDAgMjYwLjgsMCAyMjYuNCw0NTAuMiAzMDQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.utils" href="index.html">vectorbt.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="vectorbt.utils.config.convert_to_dict" href="#vectorbt.utils.config.convert_to_dict">convert_to_dict</a></code></li>
<li><code><a title="vectorbt.utils.config.copy_dict" href="#vectorbt.utils.config.copy_dict">copy_dict</a></code></li>
<li><code><a title="vectorbt.utils.config.get_func_kwargs" href="#vectorbt.utils.config.get_func_kwargs">get_func_kwargs</a></code></li>
<li><code><a title="vectorbt.utils.config.merge_dicts" href="#vectorbt.utils.config.merge_dicts">merge_dicts</a></code></li>
<li><code><a title="vectorbt.utils.config.resolve_dict" href="#vectorbt.utils.config.resolve_dict">resolve_dict</a></code></li>
<li><code><a title="vectorbt.utils.config.set_dict_item" href="#vectorbt.utils.config.set_dict_item">set_dict_item</a></code></li>
<li><code><a title="vectorbt.utils.config.update_dict" href="#vectorbt.utils.config.update_dict">update_dict</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.utils.config.AtomicConfig" href="#vectorbt.utils.config.AtomicConfig">AtomicConfig</a></code></h4>
</li>
<li>
<h4><code><a title="vectorbt.utils.config.Config" href="#vectorbt.utils.config.Config">Config</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.config.Config.as_attrs_" href="#vectorbt.utils.config.Config.as_attrs_">as_attrs_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.clear" href="#vectorbt.utils.config.Config.clear">clear</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.convert_dicts_" href="#vectorbt.utils.config.Config.convert_dicts_">convert_dicts_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.copy" href="#vectorbt.utils.config.Config.copy">copy</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.copy_kwargs_" href="#vectorbt.utils.config.Config.copy_kwargs_">copy_kwargs_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.frozen_keys_" href="#vectorbt.utils.config.Config.frozen_keys_">frozen_keys_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.load_update" href="#vectorbt.utils.config.Config.load_update">load_update</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.make_checkpoint" href="#vectorbt.utils.config.Config.make_checkpoint">make_checkpoint</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.merge_with" href="#vectorbt.utils.config.Config.merge_with">merge_with</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.nested_" href="#vectorbt.utils.config.Config.nested_">nested_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.pop" href="#vectorbt.utils.config.Config.pop">pop</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.popitem" href="#vectorbt.utils.config.Config.popitem">popitem</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.readonly_" href="#vectorbt.utils.config.Config.readonly_">readonly_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.reset" href="#vectorbt.utils.config.Config.reset">reset</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.reset_dct_" href="#vectorbt.utils.config.Config.reset_dct_">reset_dct_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.reset_dct_copy_kwargs_" href="#vectorbt.utils.config.Config.reset_dct_copy_kwargs_">reset_dct_copy_kwargs_</a></code></li>
<li><code><a title="vectorbt.utils.config.Config.update" href="#vectorbt.utils.config.Config.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.config.Configured" href="#vectorbt.utils.config.Configured">Configured</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.config.Configured.config" href="#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.copy" href="#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.getattr" href="#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.update_config" href="#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.config.DumpTuple" href="#vectorbt.utils.config.DumpTuple">DumpTuple</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.config.DumpTuple.cls" href="#vectorbt.utils.config.DumpTuple.cls">cls</a></code></li>
<li><code><a title="vectorbt.utils.config.DumpTuple.dumps" href="#vectorbt.utils.config.DumpTuple.dumps">dumps</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.config.Pickleable" href="#vectorbt.utils.config.Pickleable">Pickleable</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.config.Pickleable.dumps" href="#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.load" href="#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.loads" href="#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.utils.config.Pickleable.save" href="#vectorbt.utils.config.Pickleable.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.config.PickleableDict" href="#vectorbt.utils.config.PickleableDict">PickleableDict</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.config.PickleableDict.load_update" href="#vectorbt.utils.config.PickleableDict.load_update">load_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.config.atomic_dict" href="#vectorbt.utils.config.atomic_dict">atomic_dict</a></code></h4>
</li>
</ul>
</li>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>