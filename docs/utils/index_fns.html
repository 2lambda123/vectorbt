<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.utils.index_fns API documentation</title>
<meta name="description" content="Utility functions for working with index/columns." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.utils.index_fns</code></h1>
</header>
<section id="section-intro">
<p>Utility functions for working with index/columns.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Utility functions for working with index/columns.&#34;&#34;&#34;

import numpy as np
import pandas as pd
from collections.abc import Iterable

from vectorbt.utils import checks


def from_values(values, name=None):
    &#34;&#34;&#34;Create a new `pd.Index` with `name` by parsing an iterable `values`.
    
    Each in `values` will correspond to an element in the new index.&#34;&#34;&#34;
    checks.assert_type(values, Iterable)

    value_names = []
    for i, v in enumerate(values):
        v = np.asarray(v)
        if np.all(v == v.item(0)):
            value_names.append(v.item(0))
        else:
            value_names.append(&#39;mix_%d&#39; % i)
    return pd.Index(value_names, name=name)


def repeat(index, n):
    &#34;&#34;&#34;Repeat each element in `index` `n` times.&#34;&#34;&#34;
    if not isinstance(index, pd.Index):
        index = pd.Index(index)

    return np.repeat(index, n)


def tile(index, n):
    &#34;&#34;&#34;Tile the whole `index` `n` times.&#34;&#34;&#34;
    if not isinstance(index, pd.Index):
        index = pd.Index(index)

    if isinstance(index, pd.MultiIndex):
        return pd.MultiIndex.from_tuples(np.tile(index, n), names=index.names)
    return pd.Index(np.tile(index, n), name=index.name)


def stack(*indexes):
    &#34;&#34;&#34;Stack each index in `indexes` on top of each other.&#34;&#34;&#34;
    new_index = indexes[0]
    for i in range(1, len(indexes)):
        index1, index2 = new_index, indexes[i]
        checks.assert_same_shape(index1, index2)
        if not isinstance(index1, pd.MultiIndex):
            index1 = pd.MultiIndex.from_arrays([index1])
        if not isinstance(index2, pd.MultiIndex):
            index2 = pd.MultiIndex.from_arrays([index2])

        levels = []
        for i in range(len(index1.names)):
            levels.append(index1.get_level_values(i))
        for i in range(len(index2.names)):
            levels.append(index2.get_level_values(i))

        new_index = pd.MultiIndex.from_arrays(levels)
    return new_index


def combine(*indexes):
    &#34;&#34;&#34;Combine each index in `indexes` using Cartesian product.&#34;&#34;&#34;
    new_index = indexes[0]
    for i in range(1, len(indexes)):
        index1, index2 = new_index, indexes[i]
        if not isinstance(index1, pd.Index):
            index1 = pd.Index(index1)
        if not isinstance(index2, pd.Index):
            index2 = pd.Index(index2)

        if len(index1) == 1:
            return index2
        elif len(index2) == 1:
            return index1

        tuples1 = np.repeat(index1.to_numpy(), len(index2))
        tuples2 = np.tile(index2.to_numpy(), len(index1))

        if isinstance(index1, pd.MultiIndex):
            index1 = pd.MultiIndex.from_tuples(tuples1, names=index1.names)
        else:
            index1 = pd.Index(tuples1, name=index1.name)
        if isinstance(index2, pd.MultiIndex):
            index2 = pd.MultiIndex.from_tuples(tuples2, names=index2.names)
        else:
            index2 = pd.Index(tuples2, name=index2.name)

        new_index = stack(index1, index2)
    return new_index


def drop_levels(index, levels):
    &#34;&#34;&#34;Drop `levels` in `index` by name/position.&#34;&#34;&#34;
    checks.assert_type(index, pd.MultiIndex)

    levels_to_drop = []
    if not isinstance(levels, (tuple, list)):
        levels = [levels]
    for level in levels:
        if level in index.names:
            levels_to_drop.append(level)
    if len(levels_to_drop) &lt; len(index.names):
        # Drop only if there will be some indexes left
        return index.droplevel(levels_to_drop)
    return index


def rename_levels(index, name_dict):
    &#34;&#34;&#34;Rename levels in `index` by `name_dict`.&#34;&#34;&#34;
    for k, v in name_dict.items():
        if isinstance(index, pd.MultiIndex):
            if k in index.names:
                index = index.rename(v, level=k)
        else:
            if index.name == k:
                index.name = v
    return index


def select_levels(index, level_names):
    &#34;&#34;&#34;Build a new index by selecting one or multiple `level_names` from `index`.&#34;&#34;&#34;
    checks.assert_type(index, pd.MultiIndex)

    if isinstance(level_names, (list, tuple)):
        levels = [index.get_level_values(level_name) for level_name in level_names]
        return pd.MultiIndex.from_arrays(levels)
    else:
        return index.get_level_values(level_names)


def drop_redundant_levels(index):
    &#34;&#34;&#34;Drop levels in `index` that either have a single value or a range from 0 to n.&#34;&#34;&#34;
    if not isinstance(index, pd.Index):
        index = pd.Index(index)
    if len(index) == 1:
        return index

    if isinstance(index, pd.MultiIndex):
        levels_to_drop = []
        for i, level in enumerate(index.levels):
            if len(level) == 1:
                levels_to_drop.append(i)
            elif level.name is None and (level == np.arange(len(level))).all():  # basic range
                if len(index.get_level_values(i)) == len(level):
                    levels_to_drop.append(i)
        # Remove redundant levels only if there are some non-redundant levels left
        if len(levels_to_drop) &lt; len(index.levels):
            return index.droplevel(levels_to_drop)
    return index


def drop_duplicate_levels(index, keep=&#39;last&#39;):
    &#34;&#34;&#34;Drop levels in `index` with the same name and values.
    
    Set `keep` to &#39;last&#39; to keep last levels, otherwise &#39;first&#39;.&#34;&#34;&#34;
    if isinstance(index, pd.Index) and not isinstance(index, pd.MultiIndex):
        return index
    checks.assert_type(index, pd.MultiIndex)

    levels = []
    levels_to_drop = []
    if keep == &#39;first&#39;:
        r = range(0, len(index.levels))
    elif keep == &#39;last&#39;:
        r = range(len(index.levels)-1, -1, -1)  # loop backwards
    for i in r:
        level = (index.levels[i].name, tuple(index.get_level_values(i).to_numpy().tolist()))
        if level not in levels:
            levels.append(level)
        else:
            levels_to_drop.append(i)
    return index.droplevel(levels_to_drop)


def align_to(index1, index2):
    &#34;&#34;&#34;Align `index1` to have the same shape of `index2`.

    Returns integer indices of occurrences and None if aligning not needed.

    The second one must contain all levels from the first (and can have some more). In all these levels, 
    both must share the same elements.&#34;&#34;&#34;
    if not isinstance(index1, pd.MultiIndex):
        index1 = pd.MultiIndex.from_arrays([index1])
    if not isinstance(index2, pd.MultiIndex):
        index2 = pd.MultiIndex.from_arrays([index2])
    if index1.duplicated().any():
        raise ValueError(&#34;Duplicates index values are not allowed for the first index&#34;)

    if pd.Index.equals(index1, index2):
        return pd.IndexSlice[:]
    if len(index1) &lt;= len(index2):
        if len(index1) == 1:
            return pd.IndexSlice[np.tile([0])]
        js = []
        for i in range(len(index1.names)):
            for j in range(len(index2.names)):
                if index1.names[i] == index2.names[j]:
                    if np.array_equal(index1.levels[i], index2.levels[j]):
                        js.append(j)
                        break
        if len(index1.names) == len(js):
            new_index = pd.MultiIndex.from_arrays([index2.get_level_values(j) for j in js])
            xsorted = np.argsort(index1)
            ypos = np.searchsorted(index1[xsorted], new_index)
            return pd.IndexSlice[xsorted[ypos]]

    raise ValueError(&#34;Indexes could not be aligned together&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.utils.index_fns.align_to"><code class="name flex">
<span>def <span class="ident">align_to</span></span>(<span>index1, index2)</span>
</code></dt>
<dd>
<div class="desc"><p>Align <code>index1</code> to have the same shape of <code>index2</code>.</p>
<p>Returns integer indices of occurrences and None if aligning not needed.</p>
<p>The second one must contain all levels from the first (and can have some more). In all these levels,
both must share the same elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_to(index1, index2):
    &#34;&#34;&#34;Align `index1` to have the same shape of `index2`.

    Returns integer indices of occurrences and None if aligning not needed.

    The second one must contain all levels from the first (and can have some more). In all these levels, 
    both must share the same elements.&#34;&#34;&#34;
    if not isinstance(index1, pd.MultiIndex):
        index1 = pd.MultiIndex.from_arrays([index1])
    if not isinstance(index2, pd.MultiIndex):
        index2 = pd.MultiIndex.from_arrays([index2])
    if index1.duplicated().any():
        raise ValueError(&#34;Duplicates index values are not allowed for the first index&#34;)

    if pd.Index.equals(index1, index2):
        return pd.IndexSlice[:]
    if len(index1) &lt;= len(index2):
        if len(index1) == 1:
            return pd.IndexSlice[np.tile([0])]
        js = []
        for i in range(len(index1.names)):
            for j in range(len(index2.names)):
                if index1.names[i] == index2.names[j]:
                    if np.array_equal(index1.levels[i], index2.levels[j]):
                        js.append(j)
                        break
        if len(index1.names) == len(js):
            new_index = pd.MultiIndex.from_arrays([index2.get_level_values(j) for j in js])
            xsorted = np.argsort(index1)
            ypos = np.searchsorted(index1[xsorted], new_index)
            return pd.IndexSlice[xsorted[ypos]]

    raise ValueError(&#34;Indexes could not be aligned together&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.index_fns.combine"><code class="name flex">
<span>def <span class="ident">combine</span></span>(<span>*indexes)</span>
</code></dt>
<dd>
<div class="desc"><p>Combine each index in <code>indexes</code> using Cartesian product.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine(*indexes):
    &#34;&#34;&#34;Combine each index in `indexes` using Cartesian product.&#34;&#34;&#34;
    new_index = indexes[0]
    for i in range(1, len(indexes)):
        index1, index2 = new_index, indexes[i]
        if not isinstance(index1, pd.Index):
            index1 = pd.Index(index1)
        if not isinstance(index2, pd.Index):
            index2 = pd.Index(index2)

        if len(index1) == 1:
            return index2
        elif len(index2) == 1:
            return index1

        tuples1 = np.repeat(index1.to_numpy(), len(index2))
        tuples2 = np.tile(index2.to_numpy(), len(index1))

        if isinstance(index1, pd.MultiIndex):
            index1 = pd.MultiIndex.from_tuples(tuples1, names=index1.names)
        else:
            index1 = pd.Index(tuples1, name=index1.name)
        if isinstance(index2, pd.MultiIndex):
            index2 = pd.MultiIndex.from_tuples(tuples2, names=index2.names)
        else:
            index2 = pd.Index(tuples2, name=index2.name)

        new_index = stack(index1, index2)
    return new_index</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.index_fns.drop_duplicate_levels"><code class="name flex">
<span>def <span class="ident">drop_duplicate_levels</span></span>(<span>index, keep='last')</span>
</code></dt>
<dd>
<div class="desc"><p>Drop levels in <code>index</code> with the same name and values.</p>
<p>Set <code>keep</code> to 'last' to keep last levels, otherwise 'first'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drop_duplicate_levels(index, keep=&#39;last&#39;):
    &#34;&#34;&#34;Drop levels in `index` with the same name and values.
    
    Set `keep` to &#39;last&#39; to keep last levels, otherwise &#39;first&#39;.&#34;&#34;&#34;
    if isinstance(index, pd.Index) and not isinstance(index, pd.MultiIndex):
        return index
    checks.assert_type(index, pd.MultiIndex)

    levels = []
    levels_to_drop = []
    if keep == &#39;first&#39;:
        r = range(0, len(index.levels))
    elif keep == &#39;last&#39;:
        r = range(len(index.levels)-1, -1, -1)  # loop backwards
    for i in r:
        level = (index.levels[i].name, tuple(index.get_level_values(i).to_numpy().tolist()))
        if level not in levels:
            levels.append(level)
        else:
            levels_to_drop.append(i)
    return index.droplevel(levels_to_drop)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.index_fns.drop_levels"><code class="name flex">
<span>def <span class="ident">drop_levels</span></span>(<span>index, levels)</span>
</code></dt>
<dd>
<div class="desc"><p>Drop <code>levels</code> in <code>index</code> by name/position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drop_levels(index, levels):
    &#34;&#34;&#34;Drop `levels` in `index` by name/position.&#34;&#34;&#34;
    checks.assert_type(index, pd.MultiIndex)

    levels_to_drop = []
    if not isinstance(levels, (tuple, list)):
        levels = [levels]
    for level in levels:
        if level in index.names:
            levels_to_drop.append(level)
    if len(levels_to_drop) &lt; len(index.names):
        # Drop only if there will be some indexes left
        return index.droplevel(levels_to_drop)
    return index</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.index_fns.drop_redundant_levels"><code class="name flex">
<span>def <span class="ident">drop_redundant_levels</span></span>(<span>index)</span>
</code></dt>
<dd>
<div class="desc"><p>Drop levels in <code>index</code> that either have a single value or a range from 0 to n.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drop_redundant_levels(index):
    &#34;&#34;&#34;Drop levels in `index` that either have a single value or a range from 0 to n.&#34;&#34;&#34;
    if not isinstance(index, pd.Index):
        index = pd.Index(index)
    if len(index) == 1:
        return index

    if isinstance(index, pd.MultiIndex):
        levels_to_drop = []
        for i, level in enumerate(index.levels):
            if len(level) == 1:
                levels_to_drop.append(i)
            elif level.name is None and (level == np.arange(len(level))).all():  # basic range
                if len(index.get_level_values(i)) == len(level):
                    levels_to_drop.append(i)
        # Remove redundant levels only if there are some non-redundant levels left
        if len(levels_to_drop) &lt; len(index.levels):
            return index.droplevel(levels_to_drop)
    return index</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.index_fns.from_values"><code class="name flex">
<span>def <span class="ident">from_values</span></span>(<span>values, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code>pd.Index</code> with <code>name</code> by parsing an iterable <code>values</code>.</p>
<p>Each in <code>values</code> will correspond to an element in the new index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_values(values, name=None):
    &#34;&#34;&#34;Create a new `pd.Index` with `name` by parsing an iterable `values`.
    
    Each in `values` will correspond to an element in the new index.&#34;&#34;&#34;
    checks.assert_type(values, Iterable)

    value_names = []
    for i, v in enumerate(values):
        v = np.asarray(v)
        if np.all(v == v.item(0)):
            value_names.append(v.item(0))
        else:
            value_names.append(&#39;mix_%d&#39; % i)
    return pd.Index(value_names, name=name)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.index_fns.rename_levels"><code class="name flex">
<span>def <span class="ident">rename_levels</span></span>(<span>index, name_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Rename levels in <code>index</code> by <code>name_dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_levels(index, name_dict):
    &#34;&#34;&#34;Rename levels in `index` by `name_dict`.&#34;&#34;&#34;
    for k, v in name_dict.items():
        if isinstance(index, pd.MultiIndex):
            if k in index.names:
                index = index.rename(v, level=k)
        else:
            if index.name == k:
                index.name = v
    return index</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.index_fns.repeat"><code class="name flex">
<span>def <span class="ident">repeat</span></span>(<span>index, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Repeat each element in <code>index</code> <code>n</code> times.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat(index, n):
    &#34;&#34;&#34;Repeat each element in `index` `n` times.&#34;&#34;&#34;
    if not isinstance(index, pd.Index):
        index = pd.Index(index)

    return np.repeat(index, n)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.index_fns.select_levels"><code class="name flex">
<span>def <span class="ident">select_levels</span></span>(<span>index, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Build a new index by selecting one or multiple <code>level_names</code> from <code>index</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_levels(index, level_names):
    &#34;&#34;&#34;Build a new index by selecting one or multiple `level_names` from `index`.&#34;&#34;&#34;
    checks.assert_type(index, pd.MultiIndex)

    if isinstance(level_names, (list, tuple)):
        levels = [index.get_level_values(level_name) for level_name in level_names]
        return pd.MultiIndex.from_arrays(levels)
    else:
        return index.get_level_values(level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.index_fns.stack"><code class="name flex">
<span>def <span class="ident">stack</span></span>(<span>*indexes)</span>
</code></dt>
<dd>
<div class="desc"><p>Stack each index in <code>indexes</code> on top of each other.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stack(*indexes):
    &#34;&#34;&#34;Stack each index in `indexes` on top of each other.&#34;&#34;&#34;
    new_index = indexes[0]
    for i in range(1, len(indexes)):
        index1, index2 = new_index, indexes[i]
        checks.assert_same_shape(index1, index2)
        if not isinstance(index1, pd.MultiIndex):
            index1 = pd.MultiIndex.from_arrays([index1])
        if not isinstance(index2, pd.MultiIndex):
            index2 = pd.MultiIndex.from_arrays([index2])

        levels = []
        for i in range(len(index1.names)):
            levels.append(index1.get_level_values(i))
        for i in range(len(index2.names)):
            levels.append(index2.get_level_values(i))

        new_index = pd.MultiIndex.from_arrays(levels)
    return new_index</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.index_fns.tile"><code class="name flex">
<span>def <span class="ident">tile</span></span>(<span>index, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Tile the whole <code>index</code> <code>n</code> times.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tile(index, n):
    &#34;&#34;&#34;Tile the whole `index` `n` times.&#34;&#34;&#34;
    if not isinstance(index, pd.Index):
        index = pd.Index(index)

    if isinstance(index, pd.MultiIndex):
        return pd.MultiIndex.from_tuples(np.tile(index, n), names=index.names)
    return pd.Index(np.tile(index, n), name=index.name)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.utils" href="index.html">vectorbt.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.utils.index_fns.align_to" href="#vectorbt.utils.index_fns.align_to">align_to</a></code></li>
<li><code><a title="vectorbt.utils.index_fns.combine" href="#vectorbt.utils.index_fns.combine">combine</a></code></li>
<li><code><a title="vectorbt.utils.index_fns.drop_duplicate_levels" href="#vectorbt.utils.index_fns.drop_duplicate_levels">drop_duplicate_levels</a></code></li>
<li><code><a title="vectorbt.utils.index_fns.drop_levels" href="#vectorbt.utils.index_fns.drop_levels">drop_levels</a></code></li>
<li><code><a title="vectorbt.utils.index_fns.drop_redundant_levels" href="#vectorbt.utils.index_fns.drop_redundant_levels">drop_redundant_levels</a></code></li>
<li><code><a title="vectorbt.utils.index_fns.from_values" href="#vectorbt.utils.index_fns.from_values">from_values</a></code></li>
<li><code><a title="vectorbt.utils.index_fns.rename_levels" href="#vectorbt.utils.index_fns.rename_levels">rename_levels</a></code></li>
<li><code><a title="vectorbt.utils.index_fns.repeat" href="#vectorbt.utils.index_fns.repeat">repeat</a></code></li>
<li><code><a title="vectorbt.utils.index_fns.select_levels" href="#vectorbt.utils.index_fns.select_levels">select_levels</a></code></li>
<li><code><a title="vectorbt.utils.index_fns.stack" href="#vectorbt.utils.index_fns.stack">stack</a></code></li>
<li><code><a title="vectorbt.utils.index_fns.tile" href="#vectorbt.utils.index_fns.tile">tile</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>