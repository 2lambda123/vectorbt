<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.utils.accessors API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.utils.accessors</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import pandas as pd
from collections.abc import Iterable

from vectorbt.utils import checks, combine_fns, index_fns, reshape_fns
from vectorbt.utils.common import class_or_instancemethod, fix_class_for_pdoc


class Base_Accessor():
    def __init__(self, obj):
        self._obj = obj._obj  # access pandas object
        self._validate(self._obj)

    dtype = None

    @classmethod
    def _validate(cls, obj):
        pass

    def validate(self):
        # Don&#39;t override it, just call it for the object to be instantiated
        pass

    @classmethod
    def empty(cls, *args, **kwargs):
        raise NotImplementedError

    @classmethod
    def empty_like(cls, *args, **kwargs):
        raise NotImplementedError

    def to_1d_array(self):
        return reshape_fns.to_1d(self._obj, raw=True)

    def to_2d_array(self):
        return reshape_fns.to_2d(self._obj, raw=True)

    def wrap_array(self, *args, **kwargs):
        raise NotImplementedError

    def plot(self, *args, **kwargs):
        raise NotImplementedError

    def tile(self, n, as_columns=None):
        tiled = reshape_fns.tile(self._obj, n, along_axis=1)
        if as_columns is not None:
            new_columns = index_fns.combine(as_columns, reshape_fns.to_2d(self._obj).columns)
            return self.wrap_array(tiled.values, columns=new_columns)
        return tiled

    def repeat(self, n, as_columns=None):
        repeated = reshape_fns.repeat(self._obj, n, along_axis=1)
        if as_columns is not None:
            new_columns = index_fns.combine(reshape_fns.to_2d(self._obj).columns, as_columns)
            return self.wrap_array(repeated.values, columns=new_columns)
        return repeated

    def align_to(self, other):
        checks.assert_type(other, (pd.Series, pd.DataFrame))
        obj = reshape_fns.to_2d(self._obj)
        other = reshape_fns.to_2d(other)

        aligned_index = index_fns.align_to(obj.index, other.index)
        aligned_columns = index_fns.align_to(obj.columns, other.columns)
        obj = obj.iloc[aligned_index, aligned_columns]
        return self.wrap_array(obj.values, index=other.index, columns=other.columns)

    @class_or_instancemethod
    def broadcast(self_or_cls, *others, **kwargs):
        others = tuple(map(lambda x: x._obj if isinstance(x, Base_Accessor) else x, others))
        if isinstance(self_or_cls, type):
            return reshape_fns.broadcast(*others, **kwargs)
        return reshape_fns.broadcast(self_or_cls._obj, *others, **kwargs)

    def broadcast_to(self, other, **kwargs):
        if isinstance(other, Base_Accessor):
            other = other._obj
        return reshape_fns.broadcast_to(self._obj, other, **kwargs)

    def make_symmetric(self):
        return reshape_fns.make_symmetric(self._obj)

    def unstack_to_array(self, **kwargs):
        return reshape_fns.unstack_to_array(self._obj, **kwargs)

    def unstack_to_df(self, **kwargs):
        return reshape_fns.unstack_to_df(self._obj, **kwargs)

    @class_or_instancemethod
    def concat(self_or_cls, *others, as_columns=None, broadcast_kwargs={}):
        others = tuple(map(lambda x: x._obj if isinstance(x, Base_Accessor) else x, others))
        if isinstance(self_or_cls, type):
            objs = others
        else:
            objs = (self_or_cls._obj,) + others
        broadcasted = reshape_fns.broadcast(*objs, **broadcast_kwargs)
        broadcasted = tuple(map(reshape_fns.to_2d, broadcasted))
        if checks.is_pandas(broadcasted[0]):
            concated = pd.concat(broadcasted, axis=1)
            if as_columns is not None:
                concated.columns = index_fns.combine(as_columns, broadcasted[0].columns)
        else:
            concated = np.hstack(broadcasted)
        return concated

    def apply_and_concat(self, ntimes, *args, apply_func=None, as_columns=None, **kwargs):
        &#34;&#34;&#34;Apply a function n times and concatenate results into a single dataframe.&#34;&#34;&#34;
        checks.assert_not_none(apply_func)
        if checks.is_numba_func(apply_func):
            # NOTE: your apply_func must a numba-compiled function and arguments must be numba-compatible
            # Also NOTE: outputs of apply_func must always be 2-dimensional
            result = combine_fns.apply_and_concat_nb(np.asarray(self._obj), ntimes, apply_func, *args, **kwargs)
        else:
            result = combine_fns.apply_and_concat(np.asarray(self._obj), ntimes, apply_func, *args, **kwargs)
        # Build column hierarchy
        if as_columns is not None:
            new_columns = index_fns.combine(as_columns, reshape_fns.to_2d(self._obj).columns)
        else:
            new_columns = index_fns.tile(reshape_fns.to_2d(self._obj).columns, ntimes)
        return self.wrap_array(result, columns=new_columns)

    def combine_with(self, other, *args, combine_func=None, broadcast_kwargs={}, **kwargs):
        &#34;&#34;&#34;Broadcast with other and combine.

        The returned shape is the same as broadcasted shape.&#34;&#34;&#34;
        if isinstance(other, Base_Accessor):
            other = other._obj
        checks.assert_not_none(combine_func)
        if checks.is_numba_func(combine_func):
            # Numba requires writable arrays
            broadcast_kwargs = {**dict(writeable=True), **broadcast_kwargs}
        new_obj, new_other = reshape_fns.broadcast(self._obj, other, **broadcast_kwargs)
        return new_obj.vbt.wrap_array(combine_func(np.asarray(new_obj), np.asarray(new_other), *args, **kwargs))

    def combine_with_multiple(self, others, *args, combine_func=None, concat=False,
                              broadcast_kwargs={}, as_columns=None, **kwargs):
        &#34;&#34;&#34;Broadcast with other objects to the same shape and combine them all pairwise.

        The returned shape is the same as broadcasted shape if concat is False.
        The returned shape is concatenation of broadcasted shapes if concat is True.&#34;&#34;&#34;
        others = tuple(map(lambda x: x._obj if isinstance(x, Base_Accessor) else x, others))
        checks.assert_not_none(combine_func)
        checks.assert_type(others, Iterable)
        # Broadcast arguments
        if checks.is_numba_func(combine_func):
            # Numba requires writable arrays
            broadcast_kwargs = {**dict(writeable=True), **broadcast_kwargs}
            # Plus all of our arrays must be in the same order
            broadcast_kwargs[&#39;copy_kwargs&#39;] = {**dict(order=&#39;C&#39;), **broadcast_kwargs.get(&#39;copy_kwargs&#39;, {})}
        new_obj, *new_others = reshape_fns.broadcast(self._obj, *others, **broadcast_kwargs)
        broadcasted = tuple(map(np.asarray, (new_obj, *new_others)))
        if concat:
            # Concat the results horizontally
            if checks.is_numba_func(combine_func):
                for i in range(1, len(broadcasted)):
                    # NOTE: all inputs must have the same dtype
                    checks.assert_same_meta(broadcasted[i-1], broadcasted[i])
                result = combine_fns.combine_and_concat_nb(broadcasted[0], broadcasted[1:], combine_func, *args, **kwargs)
            else:
                result = combine_fns.combine_and_concat(broadcasted[0], broadcasted[1:], combine_func, *args, **kwargs)
            if as_columns is not None:
                new_columns = index_fns.combine(as_columns, reshape_fns.to_2d(new_obj).columns)
            else:
                new_columns = index_fns.tile(reshape_fns.to_2d(new_obj).columns, len(others))
            return new_obj.vbt.wrap_array(result, columns=new_columns)
        else:
            # Combine arguments pairwise into one object
            if checks.is_numba_func(combine_func):
                for i in range(1, len(broadcasted)):
                    # NOTE: all inputs must have the same dtype
                    checks.assert_same_dtype(broadcasted[i-1], broadcasted[i])
                result = combine_fns.combine_multiple_nb(broadcasted, combine_func, *args, **kwargs)
            else:
                result = combine_fns.combine_multiple(broadcasted, combine_func, *args, **kwargs)
            return new_obj.vbt.wrap_array(result)

    # Comparison operators
    def __eq__(self, other): return self.combine_with(other, combine_func=np.equal)
    def __ne__(self, other): return self.combine_with(other, combine_func=np.not_equal)
    def __lt__(self, other): return self.combine_with(other, combine_func=np.less)
    def __gt__(self, other): return self.combine_with(other, combine_func=np.greater)
    def __le__(self, other): return self.combine_with(other, combine_func=np.less_equal)
    def __ge__(self, other): return self.combine_with(other, combine_func=np.greater_equal)

    # Binary operators
    def __add__(self, other): return self.combine_with(other, combine_func=np.add)
    def __sub__(self, other): return self.combine_with(other, combine_func=np.subtract)
    def __mul__(self, other): return self.combine_with(other, combine_func=np.multiply)
    def __div__(self, other): return self.combine_with(other, combine_func=np.divide)
    __radd__ = __add__
    __rsub__ = __sub__
    __rmul__ = __mul__
    __rdiv__ = __div__

    # Boolean operators
    def __and__(self, other): return self.combine_with(other, combine_func=np.logical_and)
    def __or__(self, other): return self.combine_with(other, combine_func=np.logical_or)
    def __xor__(self, other): return self.combine_with(other, combine_func=np.logical_xor)
    __rand__ = __and__
    __ror__ = __or__
    __rxor__ = __xor__

class Base_DFAccessor(Base_Accessor):

    @classmethod
    def _validate(cls, obj):
        checks.assert_type(obj, pd.DataFrame)

    @classmethod
    def empty(cls, shape, fill_value=np.nan, index=None, columns=None):
        return pd.DataFrame(
            np.full(shape, fill_value),
            index=index,
            columns=columns,
            dtype=cls.dtype)

    @classmethod
    def empty_like(cls, df, fill_value=np.nan):
        cls._validate(df)

        return cls.empty(
            df.shape,
            fill_value=fill_value,
            index=df.index,
            columns=df.columns)

    def wrap_array(self, a, index=None, columns=None, dtype=None):
        return reshape_fns.wrap_array(
            a,
            index=index,
            columns=columns,
            dtype=dtype,
            default_index=self._obj.index,
            default_columns=self._obj.columns,
            to_ndim=2)


class Base_SRAccessor(Base_Accessor):
    # series is just a dataframe with one column
    # this way we don&#39;t have to define our custom functions for working with 1d data
    @classmethod
    def _validate(cls, obj):
        checks.assert_type(obj, pd.Series)

    @classmethod
    def empty(cls, size, fill_value=np.nan, index=None, name=None):
        return pd.Series(
            np.full(size, fill_value),
            index=index,
            name=name,
            dtype=cls.dtype)

    @classmethod
    def empty_like(cls, sr, fill_value=np.nan):
        cls._validate(sr)

        return cls.empty(
            sr.shape,
            fill_value=fill_value,
            index=sr.index,
            name=sr.name)

    def wrap_array(self, a, index=None, columns=None, dtype=None):
        return reshape_fns.wrap_array(
            a,
            index=index,
            columns=columns,
            dtype=dtype,
            default_index=self._obj.index,
            default_columns=[self._obj.name],
            to_ndim=1)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.utils.accessors.Base_Accessor"><code class="flex name class">
<span>class <span class="ident">Base_Accessor</span></span>
<span>(</span><span>obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Base_Accessor():
    def __init__(self, obj):
        self._obj = obj._obj  # access pandas object
        self._validate(self._obj)

    dtype = None

    @classmethod
    def _validate(cls, obj):
        pass

    def validate(self):
        # Don&#39;t override it, just call it for the object to be instantiated
        pass

    @classmethod
    def empty(cls, *args, **kwargs):
        raise NotImplementedError

    @classmethod
    def empty_like(cls, *args, **kwargs):
        raise NotImplementedError

    def to_1d_array(self):
        return reshape_fns.to_1d(self._obj, raw=True)

    def to_2d_array(self):
        return reshape_fns.to_2d(self._obj, raw=True)

    def wrap_array(self, *args, **kwargs):
        raise NotImplementedError

    def plot(self, *args, **kwargs):
        raise NotImplementedError

    def tile(self, n, as_columns=None):
        tiled = reshape_fns.tile(self._obj, n, along_axis=1)
        if as_columns is not None:
            new_columns = index_fns.combine(as_columns, reshape_fns.to_2d(self._obj).columns)
            return self.wrap_array(tiled.values, columns=new_columns)
        return tiled

    def repeat(self, n, as_columns=None):
        repeated = reshape_fns.repeat(self._obj, n, along_axis=1)
        if as_columns is not None:
            new_columns = index_fns.combine(reshape_fns.to_2d(self._obj).columns, as_columns)
            return self.wrap_array(repeated.values, columns=new_columns)
        return repeated

    def align_to(self, other):
        checks.assert_type(other, (pd.Series, pd.DataFrame))
        obj = reshape_fns.to_2d(self._obj)
        other = reshape_fns.to_2d(other)

        aligned_index = index_fns.align_to(obj.index, other.index)
        aligned_columns = index_fns.align_to(obj.columns, other.columns)
        obj = obj.iloc[aligned_index, aligned_columns]
        return self.wrap_array(obj.values, index=other.index, columns=other.columns)

    @class_or_instancemethod
    def broadcast(self_or_cls, *others, **kwargs):
        others = tuple(map(lambda x: x._obj if isinstance(x, Base_Accessor) else x, others))
        if isinstance(self_or_cls, type):
            return reshape_fns.broadcast(*others, **kwargs)
        return reshape_fns.broadcast(self_or_cls._obj, *others, **kwargs)

    def broadcast_to(self, other, **kwargs):
        if isinstance(other, Base_Accessor):
            other = other._obj
        return reshape_fns.broadcast_to(self._obj, other, **kwargs)

    def make_symmetric(self):
        return reshape_fns.make_symmetric(self._obj)

    def unstack_to_array(self, **kwargs):
        return reshape_fns.unstack_to_array(self._obj, **kwargs)

    def unstack_to_df(self, **kwargs):
        return reshape_fns.unstack_to_df(self._obj, **kwargs)

    @class_or_instancemethod
    def concat(self_or_cls, *others, as_columns=None, broadcast_kwargs={}):
        others = tuple(map(lambda x: x._obj if isinstance(x, Base_Accessor) else x, others))
        if isinstance(self_or_cls, type):
            objs = others
        else:
            objs = (self_or_cls._obj,) + others
        broadcasted = reshape_fns.broadcast(*objs, **broadcast_kwargs)
        broadcasted = tuple(map(reshape_fns.to_2d, broadcasted))
        if checks.is_pandas(broadcasted[0]):
            concated = pd.concat(broadcasted, axis=1)
            if as_columns is not None:
                concated.columns = index_fns.combine(as_columns, broadcasted[0].columns)
        else:
            concated = np.hstack(broadcasted)
        return concated

    def apply_and_concat(self, ntimes, *args, apply_func=None, as_columns=None, **kwargs):
        &#34;&#34;&#34;Apply a function n times and concatenate results into a single dataframe.&#34;&#34;&#34;
        checks.assert_not_none(apply_func)
        if checks.is_numba_func(apply_func):
            # NOTE: your apply_func must a numba-compiled function and arguments must be numba-compatible
            # Also NOTE: outputs of apply_func must always be 2-dimensional
            result = combine_fns.apply_and_concat_nb(np.asarray(self._obj), ntimes, apply_func, *args, **kwargs)
        else:
            result = combine_fns.apply_and_concat(np.asarray(self._obj), ntimes, apply_func, *args, **kwargs)
        # Build column hierarchy
        if as_columns is not None:
            new_columns = index_fns.combine(as_columns, reshape_fns.to_2d(self._obj).columns)
        else:
            new_columns = index_fns.tile(reshape_fns.to_2d(self._obj).columns, ntimes)
        return self.wrap_array(result, columns=new_columns)

    def combine_with(self, other, *args, combine_func=None, broadcast_kwargs={}, **kwargs):
        &#34;&#34;&#34;Broadcast with other and combine.

        The returned shape is the same as broadcasted shape.&#34;&#34;&#34;
        if isinstance(other, Base_Accessor):
            other = other._obj
        checks.assert_not_none(combine_func)
        if checks.is_numba_func(combine_func):
            # Numba requires writable arrays
            broadcast_kwargs = {**dict(writeable=True), **broadcast_kwargs}
        new_obj, new_other = reshape_fns.broadcast(self._obj, other, **broadcast_kwargs)
        return new_obj.vbt.wrap_array(combine_func(np.asarray(new_obj), np.asarray(new_other), *args, **kwargs))

    def combine_with_multiple(self, others, *args, combine_func=None, concat=False,
                              broadcast_kwargs={}, as_columns=None, **kwargs):
        &#34;&#34;&#34;Broadcast with other objects to the same shape and combine them all pairwise.

        The returned shape is the same as broadcasted shape if concat is False.
        The returned shape is concatenation of broadcasted shapes if concat is True.&#34;&#34;&#34;
        others = tuple(map(lambda x: x._obj if isinstance(x, Base_Accessor) else x, others))
        checks.assert_not_none(combine_func)
        checks.assert_type(others, Iterable)
        # Broadcast arguments
        if checks.is_numba_func(combine_func):
            # Numba requires writable arrays
            broadcast_kwargs = {**dict(writeable=True), **broadcast_kwargs}
            # Plus all of our arrays must be in the same order
            broadcast_kwargs[&#39;copy_kwargs&#39;] = {**dict(order=&#39;C&#39;), **broadcast_kwargs.get(&#39;copy_kwargs&#39;, {})}
        new_obj, *new_others = reshape_fns.broadcast(self._obj, *others, **broadcast_kwargs)
        broadcasted = tuple(map(np.asarray, (new_obj, *new_others)))
        if concat:
            # Concat the results horizontally
            if checks.is_numba_func(combine_func):
                for i in range(1, len(broadcasted)):
                    # NOTE: all inputs must have the same dtype
                    checks.assert_same_meta(broadcasted[i-1], broadcasted[i])
                result = combine_fns.combine_and_concat_nb(broadcasted[0], broadcasted[1:], combine_func, *args, **kwargs)
            else:
                result = combine_fns.combine_and_concat(broadcasted[0], broadcasted[1:], combine_func, *args, **kwargs)
            if as_columns is not None:
                new_columns = index_fns.combine(as_columns, reshape_fns.to_2d(new_obj).columns)
            else:
                new_columns = index_fns.tile(reshape_fns.to_2d(new_obj).columns, len(others))
            return new_obj.vbt.wrap_array(result, columns=new_columns)
        else:
            # Combine arguments pairwise into one object
            if checks.is_numba_func(combine_func):
                for i in range(1, len(broadcasted)):
                    # NOTE: all inputs must have the same dtype
                    checks.assert_same_dtype(broadcasted[i-1], broadcasted[i])
                result = combine_fns.combine_multiple_nb(broadcasted, combine_func, *args, **kwargs)
            else:
                result = combine_fns.combine_multiple(broadcasted, combine_func, *args, **kwargs)
            return new_obj.vbt.wrap_array(result)

    # Comparison operators
    def __eq__(self, other): return self.combine_with(other, combine_func=np.equal)
    def __ne__(self, other): return self.combine_with(other, combine_func=np.not_equal)
    def __lt__(self, other): return self.combine_with(other, combine_func=np.less)
    def __gt__(self, other): return self.combine_with(other, combine_func=np.greater)
    def __le__(self, other): return self.combine_with(other, combine_func=np.less_equal)
    def __ge__(self, other): return self.combine_with(other, combine_func=np.greater_equal)

    # Binary operators
    def __add__(self, other): return self.combine_with(other, combine_func=np.add)
    def __sub__(self, other): return self.combine_with(other, combine_func=np.subtract)
    def __mul__(self, other): return self.combine_with(other, combine_func=np.multiply)
    def __div__(self, other): return self.combine_with(other, combine_func=np.divide)
    __radd__ = __add__
    __rsub__ = __sub__
    __rmul__ = __mul__
    __rdiv__ = __div__

    # Boolean operators
    def __and__(self, other): return self.combine_with(other, combine_func=np.logical_and)
    def __or__(self, other): return self.combine_with(other, combine_func=np.logical_or)
    def __xor__(self, other): return self.combine_with(other, combine_func=np.logical_xor)
    __rand__ = __and__
    __ror__ = __or__
    __rxor__ = __xor__</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.accessors.Base_DFAccessor" href="#vectorbt.utils.accessors.Base_DFAccessor">Base_DFAccessor</a></li>
<li><a title="vectorbt.utils.accessors.Base_SRAccessor" href="#vectorbt.utils.accessors.Base_SRAccessor">Base_SRAccessor</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="vectorbt.utils.accessors.Base_Accessor.dtype"><code class="name">var <span class="ident">dtype</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.utils.accessors.Base_Accessor.broadcast"><code class="name flex">
<span>def <span class="ident">broadcast</span></span>(<span>*others, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@class_or_instancemethod
def broadcast(self_or_cls, *others, **kwargs):
    others = tuple(map(lambda x: x._obj if isinstance(x, Base_Accessor) else x, others))
    if isinstance(self_or_cls, type):
        return reshape_fns.broadcast(*others, **kwargs)
    return reshape_fns.broadcast(self_or_cls._obj, *others, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>*others, as_columns=None, broadcast_kwargs={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@class_or_instancemethod
def concat(self_or_cls, *others, as_columns=None, broadcast_kwargs={}):
    others = tuple(map(lambda x: x._obj if isinstance(x, Base_Accessor) else x, others))
    if isinstance(self_or_cls, type):
        objs = others
    else:
        objs = (self_or_cls._obj,) + others
    broadcasted = reshape_fns.broadcast(*objs, **broadcast_kwargs)
    broadcasted = tuple(map(reshape_fns.to_2d, broadcasted))
    if checks.is_pandas(broadcasted[0]):
        concated = pd.concat(broadcasted, axis=1)
        if as_columns is not None:
            concated.columns = index_fns.combine(as_columns, broadcasted[0].columns)
    else:
        concated = np.hstack(broadcasted)
    return concated</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def empty(cls, *args, **kwargs):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.empty_like"><code class="name flex">
<span>def <span class="ident">empty_like</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def empty_like(cls, *args, **kwargs):
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.utils.accessors.Base_Accessor.align_to"><code class="name flex">
<span>def <span class="ident">align_to</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_to(self, other):
    checks.assert_type(other, (pd.Series, pd.DataFrame))
    obj = reshape_fns.to_2d(self._obj)
    other = reshape_fns.to_2d(other)

    aligned_index = index_fns.align_to(obj.index, other.index)
    aligned_columns = index_fns.align_to(obj.columns, other.columns)
    obj = obj.iloc[aligned_index, aligned_columns]
    return self.wrap_array(obj.values, index=other.index, columns=other.columns)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.apply_and_concat"><code class="name flex">
<span>def <span class="ident">apply_and_concat</span></span>(<span>self, ntimes, *args, apply_func=None, as_columns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a function n times and concatenate results into a single dataframe.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_and_concat(self, ntimes, *args, apply_func=None, as_columns=None, **kwargs):
    &#34;&#34;&#34;Apply a function n times and concatenate results into a single dataframe.&#34;&#34;&#34;
    checks.assert_not_none(apply_func)
    if checks.is_numba_func(apply_func):
        # NOTE: your apply_func must a numba-compiled function and arguments must be numba-compatible
        # Also NOTE: outputs of apply_func must always be 2-dimensional
        result = combine_fns.apply_and_concat_nb(np.asarray(self._obj), ntimes, apply_func, *args, **kwargs)
    else:
        result = combine_fns.apply_and_concat(np.asarray(self._obj), ntimes, apply_func, *args, **kwargs)
    # Build column hierarchy
    if as_columns is not None:
        new_columns = index_fns.combine(as_columns, reshape_fns.to_2d(self._obj).columns)
    else:
        new_columns = index_fns.tile(reshape_fns.to_2d(self._obj).columns, ntimes)
    return self.wrap_array(result, columns=new_columns)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.broadcast_to"><code class="name flex">
<span>def <span class="ident">broadcast_to</span></span>(<span>self, other, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcast_to(self, other, **kwargs):
    if isinstance(other, Base_Accessor):
        other = other._obj
    return reshape_fns.broadcast_to(self._obj, other, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.combine_with"><code class="name flex">
<span>def <span class="ident">combine_with</span></span>(<span>self, other, *args, combine_func=None, broadcast_kwargs={}, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Broadcast with other and combine.</p>
<p>The returned shape is the same as broadcasted shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_with(self, other, *args, combine_func=None, broadcast_kwargs={}, **kwargs):
    &#34;&#34;&#34;Broadcast with other and combine.

    The returned shape is the same as broadcasted shape.&#34;&#34;&#34;
    if isinstance(other, Base_Accessor):
        other = other._obj
    checks.assert_not_none(combine_func)
    if checks.is_numba_func(combine_func):
        # Numba requires writable arrays
        broadcast_kwargs = {**dict(writeable=True), **broadcast_kwargs}
    new_obj, new_other = reshape_fns.broadcast(self._obj, other, **broadcast_kwargs)
    return new_obj.vbt.wrap_array(combine_func(np.asarray(new_obj), np.asarray(new_other), *args, **kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.combine_with_multiple"><code class="name flex">
<span>def <span class="ident">combine_with_multiple</span></span>(<span>self, others, *args, combine_func=None, concat=False, broadcast_kwargs={}, as_columns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Broadcast with other objects to the same shape and combine them all pairwise.</p>
<p>The returned shape is the same as broadcasted shape if concat is False.
The returned shape is concatenation of broadcasted shapes if concat is True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_with_multiple(self, others, *args, combine_func=None, concat=False,
                          broadcast_kwargs={}, as_columns=None, **kwargs):
    &#34;&#34;&#34;Broadcast with other objects to the same shape and combine them all pairwise.

    The returned shape is the same as broadcasted shape if concat is False.
    The returned shape is concatenation of broadcasted shapes if concat is True.&#34;&#34;&#34;
    others = tuple(map(lambda x: x._obj if isinstance(x, Base_Accessor) else x, others))
    checks.assert_not_none(combine_func)
    checks.assert_type(others, Iterable)
    # Broadcast arguments
    if checks.is_numba_func(combine_func):
        # Numba requires writable arrays
        broadcast_kwargs = {**dict(writeable=True), **broadcast_kwargs}
        # Plus all of our arrays must be in the same order
        broadcast_kwargs[&#39;copy_kwargs&#39;] = {**dict(order=&#39;C&#39;), **broadcast_kwargs.get(&#39;copy_kwargs&#39;, {})}
    new_obj, *new_others = reshape_fns.broadcast(self._obj, *others, **broadcast_kwargs)
    broadcasted = tuple(map(np.asarray, (new_obj, *new_others)))
    if concat:
        # Concat the results horizontally
        if checks.is_numba_func(combine_func):
            for i in range(1, len(broadcasted)):
                # NOTE: all inputs must have the same dtype
                checks.assert_same_meta(broadcasted[i-1], broadcasted[i])
            result = combine_fns.combine_and_concat_nb(broadcasted[0], broadcasted[1:], combine_func, *args, **kwargs)
        else:
            result = combine_fns.combine_and_concat(broadcasted[0], broadcasted[1:], combine_func, *args, **kwargs)
        if as_columns is not None:
            new_columns = index_fns.combine(as_columns, reshape_fns.to_2d(new_obj).columns)
        else:
            new_columns = index_fns.tile(reshape_fns.to_2d(new_obj).columns, len(others))
        return new_obj.vbt.wrap_array(result, columns=new_columns)
    else:
        # Combine arguments pairwise into one object
        if checks.is_numba_func(combine_func):
            for i in range(1, len(broadcasted)):
                # NOTE: all inputs must have the same dtype
                checks.assert_same_dtype(broadcasted[i-1], broadcasted[i])
            result = combine_fns.combine_multiple_nb(broadcasted, combine_func, *args, **kwargs)
        else:
            result = combine_fns.combine_multiple(broadcasted, combine_func, *args, **kwargs)
        return new_obj.vbt.wrap_array(result)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.make_symmetric"><code class="name flex">
<span>def <span class="ident">make_symmetric</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_symmetric(self):
    return reshape_fns.make_symmetric(self._obj)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, *args, **kwargs):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.repeat"><code class="name flex">
<span>def <span class="ident">repeat</span></span>(<span>self, n, as_columns=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat(self, n, as_columns=None):
    repeated = reshape_fns.repeat(self._obj, n, along_axis=1)
    if as_columns is not None:
        new_columns = index_fns.combine(reshape_fns.to_2d(self._obj).columns, as_columns)
        return self.wrap_array(repeated.values, columns=new_columns)
    return repeated</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.tile"><code class="name flex">
<span>def <span class="ident">tile</span></span>(<span>self, n, as_columns=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tile(self, n, as_columns=None):
    tiled = reshape_fns.tile(self._obj, n, along_axis=1)
    if as_columns is not None:
        new_columns = index_fns.combine(as_columns, reshape_fns.to_2d(self._obj).columns)
        return self.wrap_array(tiled.values, columns=new_columns)
    return tiled</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.to_1d_array"><code class="name flex">
<span>def <span class="ident">to_1d_array</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_1d_array(self):
    return reshape_fns.to_1d(self._obj, raw=True)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.to_2d_array"><code class="name flex">
<span>def <span class="ident">to_2d_array</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_2d_array(self):
    return reshape_fns.to_2d(self._obj, raw=True)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.unstack_to_array"><code class="name flex">
<span>def <span class="ident">unstack_to_array</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack_to_array(self, **kwargs):
    return reshape_fns.unstack_to_array(self._obj, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.unstack_to_df"><code class="name flex">
<span>def <span class="ident">unstack_to_df</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack_to_df(self, **kwargs):
    return reshape_fns.unstack_to_df(self._obj, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self):
    # Don&#39;t override it, just call it for the object to be instantiated
    pass</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_Accessor.wrap_array"><code class="name flex">
<span>def <span class="ident">wrap_array</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_array(self, *args, **kwargs):
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.utils.accessors.Base_DFAccessor"><code class="flex name class">
<span>class <span class="ident">Base_DFAccessor</span></span>
<span>(</span><span>obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Base_DFAccessor(Base_Accessor):

    @classmethod
    def _validate(cls, obj):
        checks.assert_type(obj, pd.DataFrame)

    @classmethod
    def empty(cls, shape, fill_value=np.nan, index=None, columns=None):
        return pd.DataFrame(
            np.full(shape, fill_value),
            index=index,
            columns=columns,
            dtype=cls.dtype)

    @classmethod
    def empty_like(cls, df, fill_value=np.nan):
        cls._validate(df)

        return cls.empty(
            df.shape,
            fill_value=fill_value,
            index=df.index,
            columns=df.columns)

    def wrap_array(self, a, index=None, columns=None, dtype=None):
        return reshape_fns.wrap_array(
            a,
            index=index,
            columns=columns,
            dtype=dtype,
            default_index=self._obj.index,
            default_columns=self._obj.columns,
            to_ndim=2)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.accessors.Base_Accessor" href="#vectorbt.utils.accessors.Base_Accessor">Base_Accessor</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.accessors.Vbt_DFAccessor" href="../accessors.html#vectorbt.accessors.Vbt_DFAccessor">Vbt_DFAccessor</a></li>
<li><a title="vectorbt.signals.accessors.Signals_DFAccessor" href="../signals/accessors.html#vectorbt.signals.accessors.Signals_DFAccessor">Signals_DFAccessor</a></li>
<li><a title="vectorbt.timeseries.accessors.TimeSeries_DFAccessor" href="../timeseries/accessors.html#vectorbt.timeseries.accessors.TimeSeries_DFAccessor">TimeSeries_DFAccessor</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.utils.accessors.Base_DFAccessor.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>shape, fill_value=nan, index=None, columns=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def empty(cls, shape, fill_value=np.nan, index=None, columns=None):
    return pd.DataFrame(
        np.full(shape, fill_value),
        index=index,
        columns=columns,
        dtype=cls.dtype)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_DFAccessor.empty_like"><code class="name flex">
<span>def <span class="ident">empty_like</span></span>(<span>df, fill_value=nan)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def empty_like(cls, df, fill_value=np.nan):
    cls._validate(df)

    return cls.empty(
        df.shape,
        fill_value=fill_value,
        index=df.index,
        columns=df.columns)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.utils.accessors.Base_DFAccessor.wrap_array"><code class="name flex">
<span>def <span class="ident">wrap_array</span></span>(<span>self, a, index=None, columns=None, dtype=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_array(self, a, index=None, columns=None, dtype=None):
    return reshape_fns.wrap_array(
        a,
        index=index,
        columns=columns,
        dtype=dtype,
        default_index=self._obj.index,
        default_columns=self._obj.columns,
        to_ndim=2)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.utils.accessors.Base_Accessor" href="#vectorbt.utils.accessors.Base_Accessor">Base_Accessor</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.apply_and_concat" href="#vectorbt.utils.accessors.Base_Accessor.apply_and_concat">apply_and_concat</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.combine_with" href="#vectorbt.utils.accessors.Base_Accessor.combine_with">combine_with</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.combine_with_multiple" href="#vectorbt.utils.accessors.Base_Accessor.combine_with_multiple">combine_with_multiple</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.utils.accessors.Base_SRAccessor"><code class="flex name class">
<span>class <span class="ident">Base_SRAccessor</span></span>
<span>(</span><span>obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Base_SRAccessor(Base_Accessor):
    # series is just a dataframe with one column
    # this way we don&#39;t have to define our custom functions for working with 1d data
    @classmethod
    def _validate(cls, obj):
        checks.assert_type(obj, pd.Series)

    @classmethod
    def empty(cls, size, fill_value=np.nan, index=None, name=None):
        return pd.Series(
            np.full(size, fill_value),
            index=index,
            name=name,
            dtype=cls.dtype)

    @classmethod
    def empty_like(cls, sr, fill_value=np.nan):
        cls._validate(sr)

        return cls.empty(
            sr.shape,
            fill_value=fill_value,
            index=sr.index,
            name=sr.name)

    def wrap_array(self, a, index=None, columns=None, dtype=None):
        return reshape_fns.wrap_array(
            a,
            index=index,
            columns=columns,
            dtype=dtype,
            default_index=self._obj.index,
            default_columns=[self._obj.name],
            to_ndim=1)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.accessors.Base_Accessor" href="#vectorbt.utils.accessors.Base_Accessor">Base_Accessor</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.accessors.Vbt_SRAccessor" href="../accessors.html#vectorbt.accessors.Vbt_SRAccessor">Vbt_SRAccessor</a></li>
<li><a title="vectorbt.signals.accessors.Signals_SRAccessor" href="../signals/accessors.html#vectorbt.signals.accessors.Signals_SRAccessor">Signals_SRAccessor</a></li>
<li><a title="vectorbt.timeseries.accessors.TimeSeries_SRAccessor" href="../timeseries/accessors.html#vectorbt.timeseries.accessors.TimeSeries_SRAccessor">TimeSeries_SRAccessor</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.utils.accessors.Base_SRAccessor.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>size, fill_value=nan, index=None, name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def empty(cls, size, fill_value=np.nan, index=None, name=None):
    return pd.Series(
        np.full(size, fill_value),
        index=index,
        name=name,
        dtype=cls.dtype)</code></pre>
</details>
</dd>
<dt id="vectorbt.utils.accessors.Base_SRAccessor.empty_like"><code class="name flex">
<span>def <span class="ident">empty_like</span></span>(<span>sr, fill_value=nan)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def empty_like(cls, sr, fill_value=np.nan):
    cls._validate(sr)

    return cls.empty(
        sr.shape,
        fill_value=fill_value,
        index=sr.index,
        name=sr.name)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.utils.accessors.Base_SRAccessor.wrap_array"><code class="name flex">
<span>def <span class="ident">wrap_array</span></span>(<span>self, a, index=None, columns=None, dtype=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_array(self, a, index=None, columns=None, dtype=None):
    return reshape_fns.wrap_array(
        a,
        index=index,
        columns=columns,
        dtype=dtype,
        default_index=self._obj.index,
        default_columns=[self._obj.name],
        to_ndim=1)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.utils.accessors.Base_Accessor" href="#vectorbt.utils.accessors.Base_Accessor">Base_Accessor</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.apply_and_concat" href="#vectorbt.utils.accessors.Base_Accessor.apply_and_concat">apply_and_concat</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.combine_with" href="#vectorbt.utils.accessors.Base_Accessor.combine_with">combine_with</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.combine_with_multiple" href="#vectorbt.utils.accessors.Base_Accessor.combine_with_multiple">combine_with_multiple</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.utils" href="index.html">vectorbt.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.utils.accessors.Base_Accessor" href="#vectorbt.utils.accessors.Base_Accessor">Base_Accessor</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.align_to" href="#vectorbt.utils.accessors.Base_Accessor.align_to">align_to</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.apply_and_concat" href="#vectorbt.utils.accessors.Base_Accessor.apply_and_concat">apply_and_concat</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.broadcast" href="#vectorbt.utils.accessors.Base_Accessor.broadcast">broadcast</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.broadcast_to" href="#vectorbt.utils.accessors.Base_Accessor.broadcast_to">broadcast_to</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.combine_with" href="#vectorbt.utils.accessors.Base_Accessor.combine_with">combine_with</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.combine_with_multiple" href="#vectorbt.utils.accessors.Base_Accessor.combine_with_multiple">combine_with_multiple</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.concat" href="#vectorbt.utils.accessors.Base_Accessor.concat">concat</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.dtype" href="#vectorbt.utils.accessors.Base_Accessor.dtype">dtype</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.empty" href="#vectorbt.utils.accessors.Base_Accessor.empty">empty</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.empty_like" href="#vectorbt.utils.accessors.Base_Accessor.empty_like">empty_like</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.make_symmetric" href="#vectorbt.utils.accessors.Base_Accessor.make_symmetric">make_symmetric</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.plot" href="#vectorbt.utils.accessors.Base_Accessor.plot">plot</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.repeat" href="#vectorbt.utils.accessors.Base_Accessor.repeat">repeat</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.tile" href="#vectorbt.utils.accessors.Base_Accessor.tile">tile</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.to_1d_array" href="#vectorbt.utils.accessors.Base_Accessor.to_1d_array">to_1d_array</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.to_2d_array" href="#vectorbt.utils.accessors.Base_Accessor.to_2d_array">to_2d_array</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.unstack_to_array" href="#vectorbt.utils.accessors.Base_Accessor.unstack_to_array">unstack_to_array</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.unstack_to_df" href="#vectorbt.utils.accessors.Base_Accessor.unstack_to_df">unstack_to_df</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.validate" href="#vectorbt.utils.accessors.Base_Accessor.validate">validate</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_Accessor.wrap_array" href="#vectorbt.utils.accessors.Base_Accessor.wrap_array">wrap_array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.accessors.Base_DFAccessor" href="#vectorbt.utils.accessors.Base_DFAccessor">Base_DFAccessor</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.accessors.Base_DFAccessor.empty" href="#vectorbt.utils.accessors.Base_DFAccessor.empty">empty</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_DFAccessor.empty_like" href="#vectorbt.utils.accessors.Base_DFAccessor.empty_like">empty_like</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_DFAccessor.wrap_array" href="#vectorbt.utils.accessors.Base_DFAccessor.wrap_array">wrap_array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.utils.accessors.Base_SRAccessor" href="#vectorbt.utils.accessors.Base_SRAccessor">Base_SRAccessor</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.utils.accessors.Base_SRAccessor.empty" href="#vectorbt.utils.accessors.Base_SRAccessor.empty">empty</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_SRAccessor.empty_like" href="#vectorbt.utils.accessors.Base_SRAccessor.empty_like">empty_like</a></code></li>
<li><code><a title="vectorbt.utils.accessors.Base_SRAccessor.wrap_array" href="#vectorbt.utils.accessors.Base_SRAccessor.wrap_array">wrap_array</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>