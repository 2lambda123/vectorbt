<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>vectorbt.data.base API documentation</title>
<meta name="description" content="Base data class â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@alpha" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#e82;--docsearch-primary-color:#e82;--docsearch-searchbox-focus-background:#ebedf0}body{line-height:1.5em}.version{font-weight:normal;font-style:italic;font-size:.75em;color:#8b949e}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}h2[id^="header-"]{margin-top:2em}.ident{color:#900}.headerlink{color:inherit}.headerlink:hover{color:inherit}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important;word-break:normal}.hljs-keyword{color:#ff7b72 !important}.hljs-comment{color:#8b949e !important}.hljs-meta{color:#8b949e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 1.5em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:1em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-weight:400;font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}.DocSearch-Button{width:100%;margin:0px;height:38px}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{min-width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}.hljs{margin-left:-15px;margin-right:-15px}.source pre code{margin-left:0px;margin-right:0px}dd{margin:0 0 1em 3em}dd dd{margin-left:2em}.flex{display:flex !important}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4QLCS0J048"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4QLCS0J048');
</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:100px;max-height:100px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.data.base</code></h1>
</header>
<section id="section-intro">
<p>Base data class.</p>
<p>Class <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> allows storing, downloading, updating, and managing data. It stores data
as a dictionary of Series/DataFrames keyed by symbol, and makes sure that
all pandas objects have the same index and columns by aligning them.</p>
<h2 id="downloading">Downloading</h2>
<p>Data can be downloaded by overriding the <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code> class method. What <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> does
under the hood is iterating over all symbols and calling this method.</p>
<p>Let's create a simple data class <code>RandomData</code> that generates price based on
random returns with provided mean and standard deviation:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; class RandomData(vbt.Data):
...     @classmethod
...     def download_symbol(cls, symbol, mean=0., stdev=0.1, start_value=100,
...                         start_dt='2021-01-01', end_dt='2021-01-10'):
...         index = pd.date_range(start_dt, end_dt)
...         rand_returns = np.random.normal(mean, stdev, size=len(index))
...         rand_price = start_value + np.cumprod(rand_returns + 1)
...         return pd.Series(rand_price, index=index)

&gt;&gt;&gt; rand_data = RandomData.download(['RANDNX1', 'RANDNX2'])
&gt;&gt;&gt; rand_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  101.042956  100.920462
2021-01-02  100.987327  100.956455
2021-01-03  101.022333  100.955128
2021-01-04  101.084243  100.791793
2021-01-05  101.158619  100.781000
2021-01-06  101.172688  100.786198
2021-01-07  101.311609  100.848192
2021-01-08  101.331841  100.861500
2021-01-09  101.440530  100.944935
2021-01-10  101.585689  100.993223
</code></pre>
<p>To provide different keyword arguments for different symbols, we can use <code><a title="vectorbt.data.base.symbol_dict" href="#vectorbt.data.base.symbol_dict">symbol_dict</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; start_value = vbt.symbol_dict({'RANDNX2': 200})
&gt;&gt;&gt; rand_data = RandomData.download(['RANDNX1', 'RANDNX2'], start_value=start_value)
&gt;&gt;&gt; rand_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  101.083324  200.886078
2021-01-02  101.113405  200.791934
2021-01-03  101.169194  200.852877
2021-01-04  101.164033  200.820111
2021-01-05  101.326248  201.060448
2021-01-06  101.394482  200.876984
2021-01-07  101.494227  200.845519
2021-01-08  101.422012  200.963474
2021-01-09  101.493162  200.790369
2021-01-10  101.606052  200.752296
</code></pre>
<p>In case two symbols have different index or columns, they are automatically aligned based on
<code>missing_index</code> and <code>missing_columns</code> respectively (see <code>data</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; start_dt = vbt.symbol_dict({'RANDNX2': '2021-01-03'})
&gt;&gt;&gt; end_dt = vbt.symbol_dict({'RANDNX2': '2021-01-07'})
&gt;&gt;&gt; rand_data = RandomData.download(
...     ['RANDNX1', 'RANDNX2'], start_value=start_value,
...     start_dt=start_dt, end_dt=end_dt)
&gt;&gt;&gt; rand_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  101.028054         NaN
2021-01-02  101.032090         NaN
2021-01-03  101.038531  200.936283
2021-01-04  101.068265  200.926764
2021-01-05  100.878492  200.898898
2021-01-06  100.857444  200.922368
2021-01-07  100.933123  200.987094
2021-01-08  100.938034         NaN
2021-01-09  101.044736         NaN
2021-01-10  101.098133         NaN
</code></pre>
<h2 id="updating">Updating</h2>
<p>Updating can be implemented by overriding the <code><a title="vectorbt.data.base.Data.update_symbol" href="#vectorbt.data.base.Data.update_symbol">Data.update_symbol()</a></code> instance method, which takes
the same arguments as <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>. In contrast to the download method, the update
method is an instance method and can access the data downloaded earlier. It can also access the
keyword arguments initially passed to the download method, accessible under <code><a title="vectorbt.data.base.Data.download_kwargs" href="#vectorbt.data.base.Data.download_kwargs">Data.download_kwargs</a></code>.
Those arguments can be used as default arguments and overriden by arguments passed directly
to the update method, using <code><a title="vectorbt.utils.config.merge_dicts" href="../utils/config.html#vectorbt.utils.config.merge_dicts">merge_dicts()</a></code>.</p>
<p>Let's define an update method that updates the latest data point and adds two news data points.
Note that updating data always returns a new <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> instance.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; from vectorbt.utils.config import merge_dicts

&gt;&gt;&gt; class RandomData(vbt.Data):
...     @classmethod
...     def download_symbol(cls, symbol, mean=0., stdev=0.1, start_value=100,
...                         start_dt='2021-01-01', end_dt='2021-01-10'):
...         index = pd.date_range(start_dt, end_dt)
...         rand_returns = np.random.normal(mean, stdev, size=len(index))
...         rand_price = start_value + np.cumprod(rand_returns + 1)
...         return pd.Series(rand_price, index=index)
...
...     def update_symbol(self, symbol, **kwargs):
...         download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
...         download_kwargs['start_dt'] = self.data[symbol].index[-1]
...         download_kwargs['end_dt'] = download_kwargs['start_dt'] + timedelta(days=2)
...         kwargs = merge_dicts(download_kwargs, kwargs)
...         return self.download_symbol(symbol, **kwargs)

&gt;&gt;&gt; rand_data = RandomData.download(['RANDNX1', 'RANDNX2'], end_dt='2021-01-05')
&gt;&gt;&gt; rand_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  100.834387  100.866549

&gt;&gt;&gt; rand_data = rand_data.update()
&gt;&gt;&gt; rand_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  101.011255  100.887049 &lt; updated from here
2021-01-06  101.004149  100.808410
2021-01-07  101.023673  100.714583

&gt;&gt;&gt; rand_data = rand_data.update()
&gt;&gt;&gt; rand_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  101.011255  100.887049
2021-01-06  101.004149  100.808410
2021-01-07  100.883400  100.874922 &lt; updated from here
2021-01-08  101.011738  100.780188
2021-01-09  100.912639  100.934014
</code></pre>
<h2 id="merging">Merging</h2>
<p>You can merge symbols from different <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> instances either by subclassing <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> and
defining custom download and update methods, or by manually merging their data dicts
into one data dict and passing it to the <code><a title="vectorbt.data.base.Data.from_data" href="#vectorbt.data.base.Data.from_data">Data.from_data()</a></code> class method.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; rand_data1 = RandomData.download('RANDNX1', mean=0.2)
&gt;&gt;&gt; rand_data2 = RandomData.download('RANDNX2', start_value=200, start_dt='2021-01-05')
&gt;&gt;&gt; merged_data = vbt.Data.from_data(vbt.merge_dicts(rand_data1.data, rand_data2.data))
&gt;&gt;&gt; merged_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  101.160718         NaN
2021-01-02  101.421020         NaN
2021-01-03  101.959176         NaN
2021-01-04  102.076670         NaN
2021-01-05  102.447234  200.916198
2021-01-06  103.195187  201.033907
2021-01-07  103.595915  200.908229
2021-01-08  104.332550  201.000497
2021-01-09  105.159708  201.019157
2021-01-10  106.729495  200.910210
</code></pre>
<h2 id="indexing">Indexing</h2>
<p>Like any other class subclassing <code><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></code>, we can do pandas indexing
on a <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> instance, which forwards indexing operation to each Series/DataFrame:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; rand_data.loc['2021-01-07':'2021-01-09']
&lt;__main__.RandomData at 0x7fdba4e36198&gt;

&gt;&gt;&gt; rand_data.loc['2021-01-07':'2021-01-09'].get()
symbol         RANDNX1     RANDNX2
2021-01-07  100.883400  100.874922
2021-01-08  101.011738  100.780188
2021-01-09  100.912639  100.934014
</code></pre>
<h2 id="saving-and-loading">Saving and loading</h2>
<p>Like any other class subclassing <code><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></code>, we can save a <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code>
instance to the disk with <code><a title="vectorbt.data.base.Data.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">Pickleable.save()</a></code> and load it with <code><a title="vectorbt.data.base.Data.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">Pickleable.load()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; rand_data.save('rand_data')
&gt;&gt;&gt; rand_data = RandomData.load('rand_data')
&gt;&gt;&gt; rand_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  101.011255  100.887049
2021-01-06  101.004149  100.808410
2021-01-07  100.883400  100.874922
2021-01-08  101.011738  100.780188
2021-01-09  100.912639  100.934014
</code></pre>
<h2 id="stats">Stats</h2>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>See <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code> and <code><a title="vectorbt.data.base.Data.metrics" href="#vectorbt.data.base.Data.metrics">Data.metrics</a></code>.</p>
</div>
<pre><code class="language-python-repl">&gt;&gt;&gt; rand_data = RandomData.download(['RANDNX1', 'RANDNX2'])

&gt;&gt;&gt; rand_data.stats(column='a')
Start                   2021-01-01 00:00:00+00:00
End                     2021-01-10 00:00:00+00:00
Period                           10 days 00:00:00
Total Symbols                                   2
Null Counts: RANDNX1                            0
Null Counts: RANDNX2                            0
dtype: object
</code></pre>
<p><code><a title="vectorbt.data.base.Data.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code> also supports (re-)grouping:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; rand_data.stats(group_by=True)
Start                   2021-01-01 00:00:00+00:00
End                     2021-01-10 00:00:00+00:00
Period                           10 days 00:00:00
Total Symbols                                   2
Null Counts: RANDNX1                            0
Null Counts: RANDNX2                            0
Name: group, dtype: object
</code></pre>
<h2 id="plots">Plots</h2>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>See <code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">PlotsBuilderMixin.plots()</a></code> and <code><a title="vectorbt.data.base.Data.subplots" href="#vectorbt.data.base.Data.subplots">Data.subplots</a></code>.</p>
</div>
<p><code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> class has a single subplot based on <code><a title="vectorbt.data.base.Data.plot" href="#vectorbt.data.base.Data.plot">Data.plot()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; rand_data.plots(settings=dict(base=100)).show_svg()
</code></pre>
<p><img alt="" src="/docs/img/data_plots.svg"></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;Base data class.

Class `Data` allows storing, downloading, updating, and managing data. It stores data
as a dictionary of Series/DataFrames keyed by symbol, and makes sure that
all pandas objects have the same index and columns by aligning them.

## Downloading

Data can be downloaded by overriding the `Data.download_symbol` class method. What `Data` does
under the hood is iterating over all symbols and calling this method.

Let&#39;s create a simple data class `RandomData` that generates price based on
random returns with provided mean and standard deviation:

```python-repl
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; class RandomData(vbt.Data):
...     @classmethod
...     def download_symbol(cls, symbol, mean=0., stdev=0.1, start_value=100,
...                         start_dt=&#39;2021-01-01&#39;, end_dt=&#39;2021-01-10&#39;):
...         index = pd.date_range(start_dt, end_dt)
...         rand_returns = np.random.normal(mean, stdev, size=len(index))
...         rand_price = start_value + np.cumprod(rand_returns + 1)
...         return pd.Series(rand_price, index=index)

&gt;&gt;&gt; rand_data = RandomData.download([&#39;RANDNX1&#39;, &#39;RANDNX2&#39;])
&gt;&gt;&gt; rand_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  101.042956  100.920462
2021-01-02  100.987327  100.956455
2021-01-03  101.022333  100.955128
2021-01-04  101.084243  100.791793
2021-01-05  101.158619  100.781000
2021-01-06  101.172688  100.786198
2021-01-07  101.311609  100.848192
2021-01-08  101.331841  100.861500
2021-01-09  101.440530  100.944935
2021-01-10  101.585689  100.993223
```

To provide different keyword arguments for different symbols, we can use `symbol_dict`:

```python-repl
&gt;&gt;&gt; start_value = vbt.symbol_dict({&#39;RANDNX2&#39;: 200})
&gt;&gt;&gt; rand_data = RandomData.download([&#39;RANDNX1&#39;, &#39;RANDNX2&#39;], start_value=start_value)
&gt;&gt;&gt; rand_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  101.083324  200.886078
2021-01-02  101.113405  200.791934
2021-01-03  101.169194  200.852877
2021-01-04  101.164033  200.820111
2021-01-05  101.326248  201.060448
2021-01-06  101.394482  200.876984
2021-01-07  101.494227  200.845519
2021-01-08  101.422012  200.963474
2021-01-09  101.493162  200.790369
2021-01-10  101.606052  200.752296
```

In case two symbols have different index or columns, they are automatically aligned based on
`missing_index` and `missing_columns` respectively (see `data` in `vectorbt._settings.settings`):

```python-repl
&gt;&gt;&gt; start_dt = vbt.symbol_dict({&#39;RANDNX2&#39;: &#39;2021-01-03&#39;})
&gt;&gt;&gt; end_dt = vbt.symbol_dict({&#39;RANDNX2&#39;: &#39;2021-01-07&#39;})
&gt;&gt;&gt; rand_data = RandomData.download(
...     [&#39;RANDNX1&#39;, &#39;RANDNX2&#39;], start_value=start_value,
...     start_dt=start_dt, end_dt=end_dt)
&gt;&gt;&gt; rand_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  101.028054         NaN
2021-01-02  101.032090         NaN
2021-01-03  101.038531  200.936283
2021-01-04  101.068265  200.926764
2021-01-05  100.878492  200.898898
2021-01-06  100.857444  200.922368
2021-01-07  100.933123  200.987094
2021-01-08  100.938034         NaN
2021-01-09  101.044736         NaN
2021-01-10  101.098133         NaN
```

## Updating

Updating can be implemented by overriding the `Data.update_symbol` instance method, which takes
the same arguments as `Data.download_symbol`. In contrast to the download method, the update
method is an instance method and can access the data downloaded earlier. It can also access the
keyword arguments initially passed to the download method, accessible under `Data.download_kwargs`.
Those arguments can be used as default arguments and overriden by arguments passed directly
to the update method, using `vectorbt.utils.config.merge_dicts`.

Let&#39;s define an update method that updates the latest data point and adds two news data points.
Note that updating data always returns a new `Data` instance.

```python-repl
&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; from vectorbt.utils.config import merge_dicts

&gt;&gt;&gt; class RandomData(vbt.Data):
...     @classmethod
...     def download_symbol(cls, symbol, mean=0., stdev=0.1, start_value=100,
...                         start_dt=&#39;2021-01-01&#39;, end_dt=&#39;2021-01-10&#39;):
...         index = pd.date_range(start_dt, end_dt)
...         rand_returns = np.random.normal(mean, stdev, size=len(index))
...         rand_price = start_value + np.cumprod(rand_returns + 1)
...         return pd.Series(rand_price, index=index)
...
...     def update_symbol(self, symbol, **kwargs):
...         download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
...         download_kwargs[&#39;start_dt&#39;] = self.data[symbol].index[-1]
...         download_kwargs[&#39;end_dt&#39;] = download_kwargs[&#39;start_dt&#39;] + timedelta(days=2)
...         kwargs = merge_dicts(download_kwargs, kwargs)
...         return self.download_symbol(symbol, **kwargs)

&gt;&gt;&gt; rand_data = RandomData.download([&#39;RANDNX1&#39;, &#39;RANDNX2&#39;], end_dt=&#39;2021-01-05&#39;)
&gt;&gt;&gt; rand_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  100.834387  100.866549

&gt;&gt;&gt; rand_data = rand_data.update()
&gt;&gt;&gt; rand_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  101.011255  100.887049 &lt; updated from here
2021-01-06  101.004149  100.808410
2021-01-07  101.023673  100.714583

&gt;&gt;&gt; rand_data = rand_data.update()
&gt;&gt;&gt; rand_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  101.011255  100.887049
2021-01-06  101.004149  100.808410
2021-01-07  100.883400  100.874922 &lt; updated from here
2021-01-08  101.011738  100.780188
2021-01-09  100.912639  100.934014
```

## Merging

You can merge symbols from different `Data` instances either by subclassing `Data` and
defining custom download and update methods, or by manually merging their data dicts
into one data dict and passing it to the `Data.from_data` class method.

```python-repl
&gt;&gt;&gt; rand_data1 = RandomData.download(&#39;RANDNX1&#39;, mean=0.2)
&gt;&gt;&gt; rand_data2 = RandomData.download(&#39;RANDNX2&#39;, start_value=200, start_dt=&#39;2021-01-05&#39;)
&gt;&gt;&gt; merged_data = vbt.Data.from_data(vbt.merge_dicts(rand_data1.data, rand_data2.data))
&gt;&gt;&gt; merged_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  101.160718         NaN
2021-01-02  101.421020         NaN
2021-01-03  101.959176         NaN
2021-01-04  102.076670         NaN
2021-01-05  102.447234  200.916198
2021-01-06  103.195187  201.033907
2021-01-07  103.595915  200.908229
2021-01-08  104.332550  201.000497
2021-01-09  105.159708  201.019157
2021-01-10  106.729495  200.910210
```

## Indexing

Like any other class subclassing `vectorbt.base.array_wrapper.Wrapping`, we can do pandas indexing
on a `Data` instance, which forwards indexing operation to each Series/DataFrame:

```python-repl
&gt;&gt;&gt; rand_data.loc[&#39;2021-01-07&#39;:&#39;2021-01-09&#39;]
&lt;__main__.RandomData at 0x7fdba4e36198&gt;

&gt;&gt;&gt; rand_data.loc[&#39;2021-01-07&#39;:&#39;2021-01-09&#39;].get()
symbol         RANDNX1     RANDNX2
2021-01-07  100.883400  100.874922
2021-01-08  101.011738  100.780188
2021-01-09  100.912639  100.934014
```

## Saving and loading

Like any other class subclassing `vectorbt.utils.config.Pickleable`, we can save a `Data`
instance to the disk with `Data.save` and load it with `Data.load`:

```python-repl
&gt;&gt;&gt; rand_data.save(&#39;rand_data&#39;)
&gt;&gt;&gt; rand_data = RandomData.load(&#39;rand_data&#39;)
&gt;&gt;&gt; rand_data.get()
symbol         RANDNX1     RANDNX2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  101.011255  100.887049
2021-01-06  101.004149  100.808410
2021-01-07  100.883400  100.874922
2021-01-08  101.011738  100.780188
2021-01-09  100.912639  100.934014
```

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats` and `Data.metrics`.

```python-repl
&gt;&gt;&gt; rand_data = RandomData.download([&#39;RANDNX1&#39;, &#39;RANDNX2&#39;])

&gt;&gt;&gt; rand_data.stats(column=&#39;a&#39;)
Start                   2021-01-01 00:00:00+00:00
End                     2021-01-10 00:00:00+00:00
Period                           10 days 00:00:00
Total Symbols                                   2
Null Counts: RANDNX1                            0
Null Counts: RANDNX2                            0
dtype: object
```

`Data.stats` also supports (re-)grouping:

```python-repl
&gt;&gt;&gt; rand_data.stats(group_by=True)
Start                   2021-01-01 00:00:00+00:00
End                     2021-01-10 00:00:00+00:00
Period                           10 days 00:00:00
Total Symbols                                   2
Null Counts: RANDNX1                            0
Null Counts: RANDNX2                            0
Name: group, dtype: object
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots` and `Data.subplots`.

`Data` class has a single subplot based on `Data.plot`:

```python-repl
&gt;&gt;&gt; rand_data.plots(settings=dict(base=100)).show_svg()
```

![](/docs/img/data_plots.svg)
&#34;&#34;&#34;

import warnings

import numpy as np
import pandas as pd

from vectorbt import _typing as tp
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic import plotting
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, Config
from vectorbt.utils.datetime_ import is_tz_aware, to_timezone
from vectorbt.utils.decorators import cached_method

__pdoc__ = {}


class symbol_dict(dict):
    &#34;&#34;&#34;Dict that contains symbols as keys.&#34;&#34;&#34;
    pass


class MetaData(type(StatsBuilderMixin), type(PlotsBuilderMixin)):
    pass


DataT = tp.TypeVar(&#34;DataT&#34;, bound=&#34;Data&#34;)


class Data(Wrapping, StatsBuilderMixin, PlotsBuilderMixin, metaclass=MetaData):
    &#34;&#34;&#34;Class that downloads, updates, and manages data coming from a data source.&#34;&#34;&#34;

    def __init__(self,
                 wrapper: ArrayWrapper,
                 data: tp.Data,
                 tz_localize: tp.Optional[tp.TimezoneLike],
                 tz_convert: tp.Optional[tp.TimezoneLike],
                 missing_index: str,
                 missing_columns: str,
                 download_kwargs: dict,
                 **kwargs) -&gt; None:
        Wrapping.__init__(
            self,
            wrapper,
            data=data,
            tz_localize=tz_localize,
            tz_convert=tz_convert,
            missing_index=missing_index,
            missing_columns=missing_columns,
            download_kwargs=download_kwargs,
            **kwargs
        )
        StatsBuilderMixin.__init__(self)
        PlotsBuilderMixin.__init__(self)

        checks.assert_instance_of(data, dict)
        for k, v in data.items():
            checks.assert_meta_equal(v, data[list(data.keys())[0]])
        self._data = data
        self._tz_localize = tz_localize
        self._tz_convert = tz_convert
        self._missing_index = missing_index
        self._missing_columns = missing_columns
        self._download_kwargs = download_kwargs

    def indexing_func(self: DataT, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; DataT:
        &#34;&#34;&#34;Perform indexing on `Data`.&#34;&#34;&#34;
        new_wrapper = pd_indexing_func(self.wrapper)
        new_data = {k: pd_indexing_func(v) for k, v in self.data.items()}
        return self.replace(
            wrapper=new_wrapper,
            data=new_data
        )

    @property
    def data(self) -&gt; tp.Data:
        &#34;&#34;&#34;Data dictionary keyed by symbol.&#34;&#34;&#34;
        return self._data

    @property
    def symbols(self) -&gt; tp.List[tp.Label]:
        &#34;&#34;&#34;List of symbols.&#34;&#34;&#34;
        return list(self.data.keys())

    @property
    def tz_localize(self) -&gt; tp.Optional[tp.TimezoneLike]:
        &#34;&#34;&#34;`tz_localize` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._tz_localize

    @property
    def tz_convert(self) -&gt; tp.Optional[tp.TimezoneLike]:
        &#34;&#34;&#34;`tz_convert` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._tz_convert

    @property
    def missing_index(self) -&gt; str:
        &#34;&#34;&#34;`missing_index` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._missing_index

    @property
    def missing_columns(self) -&gt; str:
        &#34;&#34;&#34;`missing_columns` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._missing_columns

    @property
    def download_kwargs(self) -&gt; dict:
        &#34;&#34;&#34;Keyword arguments initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._download_kwargs

    @classmethod
    def align_index(cls, data: tp.Data, missing: str = &#39;nan&#39;) -&gt; tp.Data:
        &#34;&#34;&#34;Align data to have the same index.

        The argument `missing` accepts the following values:

        * &#39;nan&#39;: set missing data points to NaN
        * &#39;drop&#39;: remove missing data points
        * &#39;raise&#39;: raise an error&#34;&#34;&#34;
        if len(data) == 1:
            return data

        index = None
        for k, v in data.items():
            if index is None:
                index = v.index
            else:
                if len(index.intersection(v.index)) != len(index.union(v.index)):
                    if missing == &#39;nan&#39;:
                        warnings.warn(&#34;Symbols have mismatching index. &#34;
                                      &#34;Setting missing data points to NaN.&#34;, stacklevel=2)
                        index = index.union(v.index)
                    elif missing == &#39;drop&#39;:
                        warnings.warn(&#34;Symbols have mismatching index. &#34;
                                      &#34;Dropping missing data points.&#34;, stacklevel=2)
                        index = index.intersection(v.index)
                    elif missing == &#39;raise&#39;:
                        raise ValueError(&#34;Symbols have mismatching index&#34;)
                    else:
                        raise ValueError(f&#34;missing=&#39;{missing}&#39; is not recognized&#34;)

        # reindex
        new_data = {k: v.reindex(index=index) for k, v in data.items()}
        return new_data

    @classmethod
    def align_columns(cls, data: tp.Data, missing: str = &#39;raise&#39;) -&gt; tp.Data:
        &#34;&#34;&#34;Align data to have the same columns.

        See `Data.align_index` for `missing`.&#34;&#34;&#34;
        if len(data) == 1:
            return data

        columns = None
        multiple_columns = False
        name_is_none = False
        for k, v in data.items():
            if isinstance(v, pd.Series):
                if v.name is None:
                    name_is_none = True
                v = v.to_frame()
            else:
                multiple_columns = True
            if columns is None:
                columns = v.columns
            else:
                if len(columns.intersection(v.columns)) != len(columns.union(v.columns)):
                    if missing == &#39;nan&#39;:
                        warnings.warn(&#34;Symbols have mismatching columns. &#34;
                                      &#34;Setting missing data points to NaN.&#34;, stacklevel=2)
                        columns = columns.union(v.columns)
                    elif missing == &#39;drop&#39;:
                        warnings.warn(&#34;Symbols have mismatching columns. &#34;
                                      &#34;Dropping missing data points.&#34;, stacklevel=2)
                        columns = columns.intersection(v.columns)
                    elif missing == &#39;raise&#39;:
                        raise ValueError(&#34;Symbols have mismatching columns&#34;)
                    else:
                        raise ValueError(f&#34;missing=&#39;{missing}&#39; is not recognized&#34;)

        # reindex
        new_data = {}
        for k, v in data.items():
            if isinstance(v, pd.Series):
                v = v.to_frame(name=v.name)
            v = v.reindex(columns=columns)
            if not multiple_columns:
                v = v[columns[0]]
                if name_is_none:
                    v = v.rename(None)
            new_data[k] = v
        return new_data

    @classmethod
    def select_symbol_kwargs(cls, symbol: tp.Label, kwargs: dict) -&gt; dict:
        &#34;&#34;&#34;Select keyword arguments belonging to `symbol`.&#34;&#34;&#34;
        _kwargs = dict()
        for k, v in kwargs.items():
            if isinstance(v, symbol_dict):
                if symbol in v:
                    _kwargs[k] = v[symbol]
            else:
                _kwargs[k] = v
        return _kwargs

    @classmethod
    def from_data(cls: tp.Type[DataT],
                  data: tp.Data,
                  tz_localize: tp.Optional[tp.TimezoneLike] = None,
                  tz_convert: tp.Optional[tp.TimezoneLike] = None,
                  missing_index: tp.Optional[str] = None,
                  missing_columns: tp.Optional[str] = None,
                  wrapper_kwargs: tp.KwargsLike = None,
                  **kwargs) -&gt; DataT:
        &#34;&#34;&#34;Create a new `Data` instance from (aligned) data.

        Args:
            data (dict): Dictionary of array-like objects keyed by symbol.
            tz_localize (timezone_like): If the index is tz-naive, convert to a timezone.

                See `vectorbt.utils.datetime_.to_timezone`.
            tz_convert (timezone_like): Convert the index from one timezone to another.

                See `vectorbt.utils.datetime_.to_timezone`.
            missing_index (str): See `Data.align_index`.
            missing_columns (str): See `Data.align_columns`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `data` in `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        data_cfg = settings[&#39;data&#39;]

        # Get global defaults
        if tz_localize is None:
            tz_localize = data_cfg[&#39;tz_localize&#39;]
        if tz_convert is None:
            tz_convert = data_cfg[&#39;tz_convert&#39;]
        if missing_index is None:
            missing_index = data_cfg[&#39;missing_index&#39;]
        if missing_columns is None:
            missing_columns = data_cfg[&#39;missing_columns&#39;]
        if wrapper_kwargs is None:
            wrapper_kwargs = {}

        data = data.copy()
        for k, v in data.items():
            # Convert array to pandas
            if not isinstance(v, (pd.Series, pd.DataFrame)):
                v = np.asarray(v)
                if v.ndim == 1:
                    v = pd.Series(v)
                else:
                    v = pd.DataFrame(v)

            # Perform operations with datetime-like index
            if isinstance(v.index, pd.DatetimeIndex):
                if tz_localize is not None:
                    if not is_tz_aware(v.index):
                        v = v.tz_localize(to_timezone(tz_localize))
                if tz_convert is not None:
                    v = v.tz_convert(to_timezone(tz_convert))
                v.index.freq = v.index.inferred_freq
            data[k] = v

        # Align index and columns
        data = cls.align_index(data, missing=missing_index)
        data = cls.align_columns(data, missing=missing_columns)

        # Create new instance
        symbols = list(data.keys())
        wrapper = ArrayWrapper.from_obj(data[symbols[0]], **wrapper_kwargs)
        return cls(
            wrapper,
            data,
            tz_localize=tz_localize,
            tz_convert=tz_convert,
            missing_index=missing_index,
            missing_columns=missing_columns,
            **kwargs
        )

    @classmethod
    def download_symbol(cls, symbol: tp.Label, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Abstract method to download a symbol.&#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def download(cls: tp.Type[DataT],
                 symbols: tp.Union[tp.Label, tp.Labels],
                 tz_localize: tp.Optional[tp.TimezoneLike] = None,
                 tz_convert: tp.Optional[tp.TimezoneLike] = None,
                 missing_index: tp.Optional[str] = None,
                 missing_columns: tp.Optional[str] = None,
                 wrapper_kwargs: tp.KwargsLike = None,
                 **kwargs) -&gt; DataT:
        &#34;&#34;&#34;Download data using `Data.download_symbol`.

        Args:
            symbols (hashable or sequence of hashable): One or multiple symbols.

                !!! note
                    Tuple is considered as a single symbol (since hashable).
            tz_localize (any): See `Data.from_data`.
            tz_convert (any): See `Data.from_data`.
            missing_index (str): See `Data.from_data`.
            missing_columns (str): See `Data.from_data`.
            wrapper_kwargs (dict): See `Data.from_data`.
            **kwargs: Passed to `Data.download_symbol`.

                If two symbols require different keyword arguments, pass `symbol_dict` for each argument.
        &#34;&#34;&#34;
        if checks.is_hashable(symbols):
            symbols = [symbols]
        elif not checks.is_sequence(symbols):
            raise TypeError(&#34;Symbols must be either hashable or sequence of hashable&#34;)

        data = dict()
        for s in symbols:
            # Select keyword arguments for this symbol
            _kwargs = cls.select_symbol_kwargs(s, kwargs)

            # Download data for this symbol
            data[s] = cls.download_symbol(s, **_kwargs)

        # Create new instance from data
        return cls.from_data(
            data,
            tz_localize=tz_localize,
            tz_convert=tz_convert,
            missing_index=missing_index,
            missing_columns=missing_columns,
            wrapper_kwargs=wrapper_kwargs,
            download_kwargs=kwargs
        )

    def update_symbol(self, symbol: tp.Label, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Abstract method to update a symbol.&#34;&#34;&#34;
        raise NotImplementedError

    def update(self: DataT, **kwargs) -&gt; DataT:
        &#34;&#34;&#34;Update the data using `Data.update_symbol`.

        Args:
            **kwargs: Passed to `Data.update_symbol`.

                If two symbols require different keyword arguments, pass `symbol_dict` for each argument.

        !!! note
            Returns a new `Data` instance.&#34;&#34;&#34;
        new_data = dict()
        for k, v in self.data.items():
            # Select keyword arguments for this symbol
            _kwargs = self.select_symbol_kwargs(k, kwargs)

            # Download new data for this symbol
            new_obj = self.update_symbol(k, **_kwargs)

            # Convert array to pandas
            if not isinstance(new_obj, (pd.Series, pd.DataFrame)):
                new_obj = np.asarray(new_obj)
                index = pd.RangeIndex(
                    start=v.index[-1],
                    stop=v.index[-1] + new_obj.shape[0],
                    step=1
                )
                if new_obj.ndim == 1:
                    new_obj = pd.Series(new_obj, index=index)
                else:
                    new_obj = pd.DataFrame(new_obj, index=index)

            # Perform operations with datetime-like index
            if isinstance(new_obj.index, pd.DatetimeIndex):
                if self.tz_localize is not None:
                    if not is_tz_aware(new_obj.index):
                        new_obj = new_obj.tz_localize(to_timezone(self.tz_localize))
                if self.tz_convert is not None:
                    new_obj = new_obj.tz_convert(to_timezone(self.tz_convert))

            new_data[k] = new_obj

        # Align index and columns
        new_data = self.align_index(new_data, missing=self.missing_index)
        new_data = self.align_columns(new_data, missing=self.missing_columns)

        # Concatenate old and new data
        for k, v in new_data.items():
            if isinstance(self.data[k], pd.Series):
                if isinstance(v, pd.DataFrame):
                    v = v[self.data[k].name]
            else:
                v = v[self.data[k].columns]
            v = pd.concat((self.data[k], v), axis=0)
            v = v[~v.index.duplicated(keep=&#39;last&#39;)]
            if isinstance(v.index, pd.DatetimeIndex):
                v.index.freq = v.index.inferred_freq
            new_data[k] = v

        # Create new instance
        new_index = new_data[self.symbols[0]].index
        return self.replace(
            wrapper=self.wrapper.replace(index=new_index),
            data=new_data
        )

    @cached_method
    def concat(self, level_name: str = &#39;symbol&#39;) -&gt; tp.Data:
        &#34;&#34;&#34;Return a dict of Series/DataFrames with symbols as columns, keyed by column name.&#34;&#34;&#34;
        first_data = self.data[self.symbols[0]]
        index = first_data.index
        if isinstance(first_data, pd.Series):
            columns = pd.Index([first_data.name])
        else:
            columns = first_data.columns
        if len(self.symbols) &gt; 1:
            new_data = {c: pd.DataFrame(
                index=index,
                columns=pd.Index(self.symbols, name=level_name)
            ) for c in columns}
        else:
            new_data = {c: pd.Series(
                index=index,
                name=self.symbols[0]
            ) for c in columns}
        for c in columns:
            for s in self.symbols:
                if isinstance(self.data[s], pd.Series):
                    col_data = self.data[s]
                else:
                    col_data = self.data[s][c]
                if len(self.symbols) &gt; 1:
                    new_data[c].loc[:, s] = col_data
                else:
                    new_data[c].loc[:] = col_data

        return new_data

    def get(self, column: tp.Optional[tp.Label] = None, **kwargs) -&gt; tp.MaybeTuple[tp.SeriesFrame]:
        &#34;&#34;&#34;Get column data.

        If one symbol, returns data for that symbol.
        If multiple symbols, performs concatenation first and returns a DataFrame if one column
        and a tuple of DataFrames if a list of columns passed.&#34;&#34;&#34;
        if len(self.symbols) == 1:
            if column is None:
                return self.data[self.symbols[0]]
            return self.data[self.symbols[0]][column]

        concat_data = self.concat(**kwargs)
        if len(concat_data) == 1:
            return tuple(concat_data.values())[0]
        if column is not None:
            if isinstance(column, list):
                return tuple([concat_data[c] for c in column])
            return concat_data[column]
        return tuple(concat_data.values())

    # ############# Stats ############# #

    @property
    def stats_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `Data.stats`.

        Merges `vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults` and
        `data.stats` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        data_stats_cfg = settings[&#39;data&#39;][&#39;stats&#39;]

        return merge_dicts(
            StatsBuilderMixin.stats_defaults.__get__(self),
            data_stats_cfg
        )

    _metrics: tp.ClassVar[Config] = Config(
        dict(
            start=dict(
                title=&#39;Start&#39;,
                calc_func=lambda self: self.wrapper.index[0],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            end=dict(
                title=&#39;End&#39;,
                calc_func=lambda self: self.wrapper.index[-1],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            period=dict(
                title=&#39;Period&#39;,
                calc_func=lambda self: len(self.wrapper.index),
                apply_to_timedelta=True,
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            total_symbols=dict(
                title=&#39;Total Symbols&#39;,
                calc_func=lambda self: len(self.symbols),
                agg_func=None,
                tags=&#39;data&#39;
            ),
            null_counts=dict(
                title=&#39;Null Counts&#39;,
                calc_func=lambda self, group_by:
                {
                    k: v.isnull().vbt(wrapper=self.wrapper).sum(group_by=group_by)
                    for k, v in self.data.items()
                },
                tags=&#39;data&#39;
            )
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def metrics(self) -&gt; Config:
        return self._metrics

    # ############# Plotting ############# #

    def plot(self,
             column: tp.Optional[tp.Label] = None,
             base: tp.Optional[float] = None,
             **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
        &#34;&#34;&#34;Plot orders.

        Args:
            column (str): Name of the column to plot.
            base (float): Rebase all series of a column to a given intial base.

                !!! note
                    The column should contain prices.
            kwargs (dict): Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.plot`.

        ## Example

        ```python-repl
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; start = &#39;2021-01-01 UTC&#39;  # crypto is in UTC
        &gt;&gt;&gt; end = &#39;2021-06-01 UTC&#39;
        &gt;&gt;&gt; data = vbt.YFData.download([&#39;BTC-USD&#39;, &#39;ETH-USD&#39;, &#39;ADA-USD&#39;], start=start, end=end)

        &gt;&gt;&gt; data.plot(column=&#39;Close&#39;, base=1)
        ```

        ![](/docs/img/data_plot.svg)&#34;&#34;&#34;
        self_col = self.select_one(column=column, group_by=False)
        data = self_col.get()
        if base is not None:
            data = data.vbt.rebase(base)
        return data.vbt.plot(**kwargs)

    @property
    def plots_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `Data.plots`.

        Merges `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults` and
        `data.plots` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        data_plots_cfg = settings[&#39;data&#39;][&#39;plots&#39;]

        return merge_dicts(
            PlotsBuilderMixin.plots_defaults.__get__(self),
            data_plots_cfg
        )

    _subplots: tp.ClassVar[Config] = Config(
        dict(
            plot=dict(
                check_is_not_grouped=True,
                plot_func=&#39;plot&#39;,
                pass_add_trace_kwargs=True,
                tags=&#39;data&#39;
            )
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def subplots(self) -&gt; Config:
        return self._subplots


Data.override_metrics_doc(__pdoc__)
Data.override_subplots_doc(__pdoc__)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.data.base.Data"><code class="flex name class">
<span>class <span class="ident parent-name">Data</span></span>
(<span class="params">wrapper, data, tz_localize, tz_convert, missing_index, missing_columns, download_kwargs, **kwargs</span>)
</code></dt>
<dd>
<div class="desc"><p>Class that downloads, updates, and manages data coming from a data source.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Data(Wrapping, StatsBuilderMixin, PlotsBuilderMixin, metaclass=MetaData):
    &#34;&#34;&#34;Class that downloads, updates, and manages data coming from a data source.&#34;&#34;&#34;

    def __init__(self,
                 wrapper: ArrayWrapper,
                 data: tp.Data,
                 tz_localize: tp.Optional[tp.TimezoneLike],
                 tz_convert: tp.Optional[tp.TimezoneLike],
                 missing_index: str,
                 missing_columns: str,
                 download_kwargs: dict,
                 **kwargs) -&gt; None:
        Wrapping.__init__(
            self,
            wrapper,
            data=data,
            tz_localize=tz_localize,
            tz_convert=tz_convert,
            missing_index=missing_index,
            missing_columns=missing_columns,
            download_kwargs=download_kwargs,
            **kwargs
        )
        StatsBuilderMixin.__init__(self)
        PlotsBuilderMixin.__init__(self)

        checks.assert_instance_of(data, dict)
        for k, v in data.items():
            checks.assert_meta_equal(v, data[list(data.keys())[0]])
        self._data = data
        self._tz_localize = tz_localize
        self._tz_convert = tz_convert
        self._missing_index = missing_index
        self._missing_columns = missing_columns
        self._download_kwargs = download_kwargs

    def indexing_func(self: DataT, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; DataT:
        &#34;&#34;&#34;Perform indexing on `Data`.&#34;&#34;&#34;
        new_wrapper = pd_indexing_func(self.wrapper)
        new_data = {k: pd_indexing_func(v) for k, v in self.data.items()}
        return self.replace(
            wrapper=new_wrapper,
            data=new_data
        )

    @property
    def data(self) -&gt; tp.Data:
        &#34;&#34;&#34;Data dictionary keyed by symbol.&#34;&#34;&#34;
        return self._data

    @property
    def symbols(self) -&gt; tp.List[tp.Label]:
        &#34;&#34;&#34;List of symbols.&#34;&#34;&#34;
        return list(self.data.keys())

    @property
    def tz_localize(self) -&gt; tp.Optional[tp.TimezoneLike]:
        &#34;&#34;&#34;`tz_localize` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._tz_localize

    @property
    def tz_convert(self) -&gt; tp.Optional[tp.TimezoneLike]:
        &#34;&#34;&#34;`tz_convert` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._tz_convert

    @property
    def missing_index(self) -&gt; str:
        &#34;&#34;&#34;`missing_index` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._missing_index

    @property
    def missing_columns(self) -&gt; str:
        &#34;&#34;&#34;`missing_columns` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._missing_columns

    @property
    def download_kwargs(self) -&gt; dict:
        &#34;&#34;&#34;Keyword arguments initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._download_kwargs

    @classmethod
    def align_index(cls, data: tp.Data, missing: str = &#39;nan&#39;) -&gt; tp.Data:
        &#34;&#34;&#34;Align data to have the same index.

        The argument `missing` accepts the following values:

        * &#39;nan&#39;: set missing data points to NaN
        * &#39;drop&#39;: remove missing data points
        * &#39;raise&#39;: raise an error&#34;&#34;&#34;
        if len(data) == 1:
            return data

        index = None
        for k, v in data.items():
            if index is None:
                index = v.index
            else:
                if len(index.intersection(v.index)) != len(index.union(v.index)):
                    if missing == &#39;nan&#39;:
                        warnings.warn(&#34;Symbols have mismatching index. &#34;
                                      &#34;Setting missing data points to NaN.&#34;, stacklevel=2)
                        index = index.union(v.index)
                    elif missing == &#39;drop&#39;:
                        warnings.warn(&#34;Symbols have mismatching index. &#34;
                                      &#34;Dropping missing data points.&#34;, stacklevel=2)
                        index = index.intersection(v.index)
                    elif missing == &#39;raise&#39;:
                        raise ValueError(&#34;Symbols have mismatching index&#34;)
                    else:
                        raise ValueError(f&#34;missing=&#39;{missing}&#39; is not recognized&#34;)

        # reindex
        new_data = {k: v.reindex(index=index) for k, v in data.items()}
        return new_data

    @classmethod
    def align_columns(cls, data: tp.Data, missing: str = &#39;raise&#39;) -&gt; tp.Data:
        &#34;&#34;&#34;Align data to have the same columns.

        See `Data.align_index` for `missing`.&#34;&#34;&#34;
        if len(data) == 1:
            return data

        columns = None
        multiple_columns = False
        name_is_none = False
        for k, v in data.items():
            if isinstance(v, pd.Series):
                if v.name is None:
                    name_is_none = True
                v = v.to_frame()
            else:
                multiple_columns = True
            if columns is None:
                columns = v.columns
            else:
                if len(columns.intersection(v.columns)) != len(columns.union(v.columns)):
                    if missing == &#39;nan&#39;:
                        warnings.warn(&#34;Symbols have mismatching columns. &#34;
                                      &#34;Setting missing data points to NaN.&#34;, stacklevel=2)
                        columns = columns.union(v.columns)
                    elif missing == &#39;drop&#39;:
                        warnings.warn(&#34;Symbols have mismatching columns. &#34;
                                      &#34;Dropping missing data points.&#34;, stacklevel=2)
                        columns = columns.intersection(v.columns)
                    elif missing == &#39;raise&#39;:
                        raise ValueError(&#34;Symbols have mismatching columns&#34;)
                    else:
                        raise ValueError(f&#34;missing=&#39;{missing}&#39; is not recognized&#34;)

        # reindex
        new_data = {}
        for k, v in data.items():
            if isinstance(v, pd.Series):
                v = v.to_frame(name=v.name)
            v = v.reindex(columns=columns)
            if not multiple_columns:
                v = v[columns[0]]
                if name_is_none:
                    v = v.rename(None)
            new_data[k] = v
        return new_data

    @classmethod
    def select_symbol_kwargs(cls, symbol: tp.Label, kwargs: dict) -&gt; dict:
        &#34;&#34;&#34;Select keyword arguments belonging to `symbol`.&#34;&#34;&#34;
        _kwargs = dict()
        for k, v in kwargs.items():
            if isinstance(v, symbol_dict):
                if symbol in v:
                    _kwargs[k] = v[symbol]
            else:
                _kwargs[k] = v
        return _kwargs

    @classmethod
    def from_data(cls: tp.Type[DataT],
                  data: tp.Data,
                  tz_localize: tp.Optional[tp.TimezoneLike] = None,
                  tz_convert: tp.Optional[tp.TimezoneLike] = None,
                  missing_index: tp.Optional[str] = None,
                  missing_columns: tp.Optional[str] = None,
                  wrapper_kwargs: tp.KwargsLike = None,
                  **kwargs) -&gt; DataT:
        &#34;&#34;&#34;Create a new `Data` instance from (aligned) data.

        Args:
            data (dict): Dictionary of array-like objects keyed by symbol.
            tz_localize (timezone_like): If the index is tz-naive, convert to a timezone.

                See `vectorbt.utils.datetime_.to_timezone`.
            tz_convert (timezone_like): Convert the index from one timezone to another.

                See `vectorbt.utils.datetime_.to_timezone`.
            missing_index (str): See `Data.align_index`.
            missing_columns (str): See `Data.align_columns`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `data` in `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        data_cfg = settings[&#39;data&#39;]

        # Get global defaults
        if tz_localize is None:
            tz_localize = data_cfg[&#39;tz_localize&#39;]
        if tz_convert is None:
            tz_convert = data_cfg[&#39;tz_convert&#39;]
        if missing_index is None:
            missing_index = data_cfg[&#39;missing_index&#39;]
        if missing_columns is None:
            missing_columns = data_cfg[&#39;missing_columns&#39;]
        if wrapper_kwargs is None:
            wrapper_kwargs = {}

        data = data.copy()
        for k, v in data.items():
            # Convert array to pandas
            if not isinstance(v, (pd.Series, pd.DataFrame)):
                v = np.asarray(v)
                if v.ndim == 1:
                    v = pd.Series(v)
                else:
                    v = pd.DataFrame(v)

            # Perform operations with datetime-like index
            if isinstance(v.index, pd.DatetimeIndex):
                if tz_localize is not None:
                    if not is_tz_aware(v.index):
                        v = v.tz_localize(to_timezone(tz_localize))
                if tz_convert is not None:
                    v = v.tz_convert(to_timezone(tz_convert))
                v.index.freq = v.index.inferred_freq
            data[k] = v

        # Align index and columns
        data = cls.align_index(data, missing=missing_index)
        data = cls.align_columns(data, missing=missing_columns)

        # Create new instance
        symbols = list(data.keys())
        wrapper = ArrayWrapper.from_obj(data[symbols[0]], **wrapper_kwargs)
        return cls(
            wrapper,
            data,
            tz_localize=tz_localize,
            tz_convert=tz_convert,
            missing_index=missing_index,
            missing_columns=missing_columns,
            **kwargs
        )

    @classmethod
    def download_symbol(cls, symbol: tp.Label, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Abstract method to download a symbol.&#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def download(cls: tp.Type[DataT],
                 symbols: tp.Union[tp.Label, tp.Labels],
                 tz_localize: tp.Optional[tp.TimezoneLike] = None,
                 tz_convert: tp.Optional[tp.TimezoneLike] = None,
                 missing_index: tp.Optional[str] = None,
                 missing_columns: tp.Optional[str] = None,
                 wrapper_kwargs: tp.KwargsLike = None,
                 **kwargs) -&gt; DataT:
        &#34;&#34;&#34;Download data using `Data.download_symbol`.

        Args:
            symbols (hashable or sequence of hashable): One or multiple symbols.

                !!! note
                    Tuple is considered as a single symbol (since hashable).
            tz_localize (any): See `Data.from_data`.
            tz_convert (any): See `Data.from_data`.
            missing_index (str): See `Data.from_data`.
            missing_columns (str): See `Data.from_data`.
            wrapper_kwargs (dict): See `Data.from_data`.
            **kwargs: Passed to `Data.download_symbol`.

                If two symbols require different keyword arguments, pass `symbol_dict` for each argument.
        &#34;&#34;&#34;
        if checks.is_hashable(symbols):
            symbols = [symbols]
        elif not checks.is_sequence(symbols):
            raise TypeError(&#34;Symbols must be either hashable or sequence of hashable&#34;)

        data = dict()
        for s in symbols:
            # Select keyword arguments for this symbol
            _kwargs = cls.select_symbol_kwargs(s, kwargs)

            # Download data for this symbol
            data[s] = cls.download_symbol(s, **_kwargs)

        # Create new instance from data
        return cls.from_data(
            data,
            tz_localize=tz_localize,
            tz_convert=tz_convert,
            missing_index=missing_index,
            missing_columns=missing_columns,
            wrapper_kwargs=wrapper_kwargs,
            download_kwargs=kwargs
        )

    def update_symbol(self, symbol: tp.Label, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Abstract method to update a symbol.&#34;&#34;&#34;
        raise NotImplementedError

    def update(self: DataT, **kwargs) -&gt; DataT:
        &#34;&#34;&#34;Update the data using `Data.update_symbol`.

        Args:
            **kwargs: Passed to `Data.update_symbol`.

                If two symbols require different keyword arguments, pass `symbol_dict` for each argument.

        !!! note
            Returns a new `Data` instance.&#34;&#34;&#34;
        new_data = dict()
        for k, v in self.data.items():
            # Select keyword arguments for this symbol
            _kwargs = self.select_symbol_kwargs(k, kwargs)

            # Download new data for this symbol
            new_obj = self.update_symbol(k, **_kwargs)

            # Convert array to pandas
            if not isinstance(new_obj, (pd.Series, pd.DataFrame)):
                new_obj = np.asarray(new_obj)
                index = pd.RangeIndex(
                    start=v.index[-1],
                    stop=v.index[-1] + new_obj.shape[0],
                    step=1
                )
                if new_obj.ndim == 1:
                    new_obj = pd.Series(new_obj, index=index)
                else:
                    new_obj = pd.DataFrame(new_obj, index=index)

            # Perform operations with datetime-like index
            if isinstance(new_obj.index, pd.DatetimeIndex):
                if self.tz_localize is not None:
                    if not is_tz_aware(new_obj.index):
                        new_obj = new_obj.tz_localize(to_timezone(self.tz_localize))
                if self.tz_convert is not None:
                    new_obj = new_obj.tz_convert(to_timezone(self.tz_convert))

            new_data[k] = new_obj

        # Align index and columns
        new_data = self.align_index(new_data, missing=self.missing_index)
        new_data = self.align_columns(new_data, missing=self.missing_columns)

        # Concatenate old and new data
        for k, v in new_data.items():
            if isinstance(self.data[k], pd.Series):
                if isinstance(v, pd.DataFrame):
                    v = v[self.data[k].name]
            else:
                v = v[self.data[k].columns]
            v = pd.concat((self.data[k], v), axis=0)
            v = v[~v.index.duplicated(keep=&#39;last&#39;)]
            if isinstance(v.index, pd.DatetimeIndex):
                v.index.freq = v.index.inferred_freq
            new_data[k] = v

        # Create new instance
        new_index = new_data[self.symbols[0]].index
        return self.replace(
            wrapper=self.wrapper.replace(index=new_index),
            data=new_data
        )

    @cached_method
    def concat(self, level_name: str = &#39;symbol&#39;) -&gt; tp.Data:
        &#34;&#34;&#34;Return a dict of Series/DataFrames with symbols as columns, keyed by column name.&#34;&#34;&#34;
        first_data = self.data[self.symbols[0]]
        index = first_data.index
        if isinstance(first_data, pd.Series):
            columns = pd.Index([first_data.name])
        else:
            columns = first_data.columns
        if len(self.symbols) &gt; 1:
            new_data = {c: pd.DataFrame(
                index=index,
                columns=pd.Index(self.symbols, name=level_name)
            ) for c in columns}
        else:
            new_data = {c: pd.Series(
                index=index,
                name=self.symbols[0]
            ) for c in columns}
        for c in columns:
            for s in self.symbols:
                if isinstance(self.data[s], pd.Series):
                    col_data = self.data[s]
                else:
                    col_data = self.data[s][c]
                if len(self.symbols) &gt; 1:
                    new_data[c].loc[:, s] = col_data
                else:
                    new_data[c].loc[:] = col_data

        return new_data

    def get(self, column: tp.Optional[tp.Label] = None, **kwargs) -&gt; tp.MaybeTuple[tp.SeriesFrame]:
        &#34;&#34;&#34;Get column data.

        If one symbol, returns data for that symbol.
        If multiple symbols, performs concatenation first and returns a DataFrame if one column
        and a tuple of DataFrames if a list of columns passed.&#34;&#34;&#34;
        if len(self.symbols) == 1:
            if column is None:
                return self.data[self.symbols[0]]
            return self.data[self.symbols[0]][column]

        concat_data = self.concat(**kwargs)
        if len(concat_data) == 1:
            return tuple(concat_data.values())[0]
        if column is not None:
            if isinstance(column, list):
                return tuple([concat_data[c] for c in column])
            return concat_data[column]
        return tuple(concat_data.values())

    # ############# Stats ############# #

    @property
    def stats_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `Data.stats`.

        Merges `vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults` and
        `data.stats` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        data_stats_cfg = settings[&#39;data&#39;][&#39;stats&#39;]

        return merge_dicts(
            StatsBuilderMixin.stats_defaults.__get__(self),
            data_stats_cfg
        )

    _metrics: tp.ClassVar[Config] = Config(
        dict(
            start=dict(
                title=&#39;Start&#39;,
                calc_func=lambda self: self.wrapper.index[0],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            end=dict(
                title=&#39;End&#39;,
                calc_func=lambda self: self.wrapper.index[-1],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            period=dict(
                title=&#39;Period&#39;,
                calc_func=lambda self: len(self.wrapper.index),
                apply_to_timedelta=True,
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            total_symbols=dict(
                title=&#39;Total Symbols&#39;,
                calc_func=lambda self: len(self.symbols),
                agg_func=None,
                tags=&#39;data&#39;
            ),
            null_counts=dict(
                title=&#39;Null Counts&#39;,
                calc_func=lambda self, group_by:
                {
                    k: v.isnull().vbt(wrapper=self.wrapper).sum(group_by=group_by)
                    for k, v in self.data.items()
                },
                tags=&#39;data&#39;
            )
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def metrics(self) -&gt; Config:
        return self._metrics

    # ############# Plotting ############# #

    def plot(self,
             column: tp.Optional[tp.Label] = None,
             base: tp.Optional[float] = None,
             **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
        &#34;&#34;&#34;Plot orders.

        Args:
            column (str): Name of the column to plot.
            base (float): Rebase all series of a column to a given intial base.

                !!! note
                    The column should contain prices.
            kwargs (dict): Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.plot`.

        ## Example

        ```python-repl
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; start = &#39;2021-01-01 UTC&#39;  # crypto is in UTC
        &gt;&gt;&gt; end = &#39;2021-06-01 UTC&#39;
        &gt;&gt;&gt; data = vbt.YFData.download([&#39;BTC-USD&#39;, &#39;ETH-USD&#39;, &#39;ADA-USD&#39;], start=start, end=end)

        &gt;&gt;&gt; data.plot(column=&#39;Close&#39;, base=1)
        ```

        ![](/docs/img/data_plot.svg)&#34;&#34;&#34;
        self_col = self.select_one(column=column, group_by=False)
        data = self_col.get()
        if base is not None:
            data = data.vbt.rebase(base)
        return data.vbt.plot(**kwargs)

    @property
    def plots_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `Data.plots`.

        Merges `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults` and
        `data.plots` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        data_plots_cfg = settings[&#39;data&#39;][&#39;plots&#39;]

        return merge_dicts(
            PlotsBuilderMixin.plots_defaults.__get__(self),
            data_plots_cfg
        )

    _subplots: tp.ClassVar[Config] = Config(
        dict(
            plot=dict(
                check_is_not_grouped=True,
                plot_func=&#39;plot&#39;,
                pass_add_trace_kwargs=True,
                tags=&#39;data&#39;
            )
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def subplots(self) -&gt; Config:
        return self._subplots</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr_.AttrResolver" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.data.custom.BinanceData" href="custom.html#vectorbt.data.custom.BinanceData">BinanceData</a></li>
<li><a title="vectorbt.data.custom.CCXTData" href="custom.html#vectorbt.data.custom.CCXTData">CCXTData</a></li>
<li><a title="vectorbt.data.custom.SyntheticData" href="custom.html#vectorbt.data.custom.SyntheticData">SyntheticData</a></li>
<li><a title="vectorbt.data.custom.YFData" href="custom.html#vectorbt.data.custom.YFData">YFData</a></li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.data.base.Data.metrics"><code class="name">var <span class="ident child-name">metrics</span></code></dt>
<dd>
<div class="desc"><p>Metrics supported by <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code>.</p>
<pre><code class="language-json">Config({
    &quot;start&quot;: {
        &quot;title&quot;: &quot;Start&quot;,
        &quot;calc_func&quot;: &quot;&lt;function Data.&lt;lambda&gt; at 0x7f421fc6c950&gt;&quot;,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    },
    &quot;end&quot;: {
        &quot;title&quot;: &quot;End&quot;,
        &quot;calc_func&quot;: &quot;&lt;function Data.&lt;lambda&gt; at 0x7f421fc6c9d8&gt;&quot;,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    },
    &quot;period&quot;: {
        &quot;title&quot;: &quot;Period&quot;,
        &quot;calc_func&quot;: &quot;&lt;function Data.&lt;lambda&gt; at 0x7f421fc6ca60&gt;&quot;,
        &quot;apply_to_timedelta&quot;: true,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    },
    &quot;total_symbols&quot;: {
        &quot;title&quot;: &quot;Total Symbols&quot;,
        &quot;calc_func&quot;: &quot;&lt;function Data.&lt;lambda&gt; at 0x7f421fc6cae8&gt;&quot;,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;data&quot;
    },
    &quot;null_counts&quot;: {
        &quot;title&quot;: &quot;Null Counts&quot;,
        &quot;calc_func&quot;: &quot;&lt;function Data.&lt;lambda&gt; at 0x7f421fc6cb70&gt;&quot;,
        &quot;tags&quot;: &quot;data&quot;
    }
})
</code></pre>
<p>Returns <code>Data._metrics</code>, which gets (deep) copied upon creation of each instance.
Thus, changing this config won't affect the class.</p>
<p>To change metrics, you can either change the config in-place, override this property,
or overwrite the instance variable <code>Data._metrics</code>.</p></div>
</dd>
<dt id="vectorbt.data.base.Data.subplots"><code class="name">var <span class="ident child-name">subplots</span></code></dt>
<dd>
<div class="desc"><p>Subplots supported by <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code>.</p>
<pre><code class="language-json">Config({
    &quot;plot&quot;: {
        &quot;check_is_not_grouped&quot;: true,
        &quot;plot_func&quot;: &quot;plot&quot;,
        &quot;pass_add_trace_kwargs&quot;: true,
        &quot;tags&quot;: &quot;data&quot;
    }
})
</code></pre>
<p>Returns <code>Data._subplots</code>, which gets (deep) copied upon creation of each instance.
Thus, changing this config won't affect the class.</p>
<p>To change subplots, you can either change the config in-place, override this property,
or overwrite the instance variable <code>Data._subplots</code>.</p></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.data.base.Data.align_columns"><code class="name flex">
<span>def <span class="ident child-name">align_columns</span></span>(<span class="params">data, missing='raise')</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Align data to have the same columns.</p>
<p>See <code><a title="vectorbt.data.base.Data.align_index" href="#vectorbt.data.base.Data.align_index">Data.align_index()</a></code> for <code>missing</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def align_columns(cls, data: tp.Data, missing: str = &#39;raise&#39;) -&gt; tp.Data:
    &#34;&#34;&#34;Align data to have the same columns.

    See `Data.align_index` for `missing`.&#34;&#34;&#34;
    if len(data) == 1:
        return data

    columns = None
    multiple_columns = False
    name_is_none = False
    for k, v in data.items():
        if isinstance(v, pd.Series):
            if v.name is None:
                name_is_none = True
            v = v.to_frame()
        else:
            multiple_columns = True
        if columns is None:
            columns = v.columns
        else:
            if len(columns.intersection(v.columns)) != len(columns.union(v.columns)):
                if missing == &#39;nan&#39;:
                    warnings.warn(&#34;Symbols have mismatching columns. &#34;
                                  &#34;Setting missing data points to NaN.&#34;, stacklevel=2)
                    columns = columns.union(v.columns)
                elif missing == &#39;drop&#39;:
                    warnings.warn(&#34;Symbols have mismatching columns. &#34;
                                  &#34;Dropping missing data points.&#34;, stacklevel=2)
                    columns = columns.intersection(v.columns)
                elif missing == &#39;raise&#39;:
                    raise ValueError(&#34;Symbols have mismatching columns&#34;)
                else:
                    raise ValueError(f&#34;missing=&#39;{missing}&#39; is not recognized&#34;)

    # reindex
    new_data = {}
    for k, v in data.items():
        if isinstance(v, pd.Series):
            v = v.to_frame(name=v.name)
        v = v.reindex(columns=columns)
        if not multiple_columns:
            v = v[columns[0]]
            if name_is_none:
                v = v.rename(None)
        new_data[k] = v
    return new_data</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.align_index"><code class="name flex">
<span>def <span class="ident child-name">align_index</span></span>(<span class="params">data, missing='nan')</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Align data to have the same index.</p>
<p>The argument <code>missing</code> accepts the following values:</p>
<ul>
<li>'nan': set missing data points to NaN</li>
<li>'drop': remove missing data points</li>
<li>'raise': raise an error</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def align_index(cls, data: tp.Data, missing: str = &#39;nan&#39;) -&gt; tp.Data:
    &#34;&#34;&#34;Align data to have the same index.

    The argument `missing` accepts the following values:

    * &#39;nan&#39;: set missing data points to NaN
    * &#39;drop&#39;: remove missing data points
    * &#39;raise&#39;: raise an error&#34;&#34;&#34;
    if len(data) == 1:
        return data

    index = None
    for k, v in data.items():
        if index is None:
            index = v.index
        else:
            if len(index.intersection(v.index)) != len(index.union(v.index)):
                if missing == &#39;nan&#39;:
                    warnings.warn(&#34;Symbols have mismatching index. &#34;
                                  &#34;Setting missing data points to NaN.&#34;, stacklevel=2)
                    index = index.union(v.index)
                elif missing == &#39;drop&#39;:
                    warnings.warn(&#34;Symbols have mismatching index. &#34;
                                  &#34;Dropping missing data points.&#34;, stacklevel=2)
                    index = index.intersection(v.index)
                elif missing == &#39;raise&#39;:
                    raise ValueError(&#34;Symbols have mismatching index&#34;)
                else:
                    raise ValueError(f&#34;missing=&#39;{missing}&#39; is not recognized&#34;)

    # reindex
    new_data = {k: v.reindex(index=index) for k, v in data.items()}
    return new_data</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.download"><code class="name flex">
<span>def <span class="ident child-name">download</span></span>(<span class="params">symbols, tz_localize=None, tz_convert=None, missing_index=None, missing_columns=None, wrapper_kwargs=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Download data using <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>symbols</code></strong> :&ensp;<code>hashable</code> or <code>sequence</code> of <code>hashable</code></dt>
<dd>
<p>One or multiple symbols.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Tuple is considered as a single symbol (since hashable).</p>
</div>
</dd>
<dt><strong><code>tz_localize</code></strong> :&ensp;<code>any</code></dt>
<dd>See <code><a title="vectorbt.data.base.Data.from_data" href="#vectorbt.data.base.Data.from_data">Data.from_data()</a></code>.</dd>
<dt><strong><code>tz_convert</code></strong> :&ensp;<code>any</code></dt>
<dd>See <code><a title="vectorbt.data.base.Data.from_data" href="#vectorbt.data.base.Data.from_data">Data.from_data()</a></code>.</dd>
<dt><strong><code>missing_index</code></strong> :&ensp;<code>str</code></dt>
<dd>See <code><a title="vectorbt.data.base.Data.from_data" href="#vectorbt.data.base.Data.from_data">Data.from_data()</a></code>.</dd>
<dt><strong><code>missing_columns</code></strong> :&ensp;<code>str</code></dt>
<dd>See <code><a title="vectorbt.data.base.Data.from_data" href="#vectorbt.data.base.Data.from_data">Data.from_data()</a></code>.</dd>
<dt><strong><code>wrapper_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>See <code><a title="vectorbt.data.base.Data.from_data" href="#vectorbt.data.base.Data.from_data">Data.from_data()</a></code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>
<p>Passed to <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>.</p>
<p>If two symbols require different keyword arguments, pass <code><a title="vectorbt.data.base.symbol_dict" href="#vectorbt.data.base.symbol_dict">symbol_dict</a></code> for each argument.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def download(cls: tp.Type[DataT],
             symbols: tp.Union[tp.Label, tp.Labels],
             tz_localize: tp.Optional[tp.TimezoneLike] = None,
             tz_convert: tp.Optional[tp.TimezoneLike] = None,
             missing_index: tp.Optional[str] = None,
             missing_columns: tp.Optional[str] = None,
             wrapper_kwargs: tp.KwargsLike = None,
             **kwargs) -&gt; DataT:
    &#34;&#34;&#34;Download data using `Data.download_symbol`.

    Args:
        symbols (hashable or sequence of hashable): One or multiple symbols.

            !!! note
                Tuple is considered as a single symbol (since hashable).
        tz_localize (any): See `Data.from_data`.
        tz_convert (any): See `Data.from_data`.
        missing_index (str): See `Data.from_data`.
        missing_columns (str): See `Data.from_data`.
        wrapper_kwargs (dict): See `Data.from_data`.
        **kwargs: Passed to `Data.download_symbol`.

            If two symbols require different keyword arguments, pass `symbol_dict` for each argument.
    &#34;&#34;&#34;
    if checks.is_hashable(symbols):
        symbols = [symbols]
    elif not checks.is_sequence(symbols):
        raise TypeError(&#34;Symbols must be either hashable or sequence of hashable&#34;)

    data = dict()
    for s in symbols:
        # Select keyword arguments for this symbol
        _kwargs = cls.select_symbol_kwargs(s, kwargs)

        # Download data for this symbol
        data[s] = cls.download_symbol(s, **_kwargs)

    # Create new instance from data
    return cls.from_data(
        data,
        tz_localize=tz_localize,
        tz_convert=tz_convert,
        missing_index=missing_index,
        missing_columns=missing_columns,
        wrapper_kwargs=wrapper_kwargs,
        download_kwargs=kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.download_symbol"><code class="name flex">
<span>def <span class="ident child-name">download_symbol</span></span>(<span class="params">symbol, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract method to download a symbol.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def download_symbol(cls, symbol: tp.Label, **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Abstract method to download a symbol.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.from_data"><code class="name flex">
<span>def <span class="ident child-name">from_data</span></span>(<span class="params">data, tz_localize=None, tz_convert=None, missing_index=None, missing_columns=None, wrapper_kwargs=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> instance from (aligned) data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of array-like objects keyed by symbol.</dd>
<dt><strong><code>tz_localize</code></strong> :&ensp;<code>timezone_like</code></dt>
<dd>
<p>If the index is tz-naive, convert to a timezone.</p>
<p>See <code><a title="vectorbt.utils.datetime_.to_timezone" href="../utils/datetime_.html#vectorbt.utils.datetime_.to_timezone">to_timezone()</a></code>.</p>
</dd>
<dt><strong><code>tz_convert</code></strong> :&ensp;<code>timezone_like</code></dt>
<dd>
<p>Convert the index from one timezone to another.</p>
<p>See <code><a title="vectorbt.utils.datetime_.to_timezone" href="../utils/datetime_.html#vectorbt.utils.datetime_.to_timezone">to_timezone()</a></code>.</p>
</dd>
<dt><strong><code>missing_index</code></strong> :&ensp;<code>str</code></dt>
<dd>See <code><a title="vectorbt.data.base.Data.align_index" href="#vectorbt.data.base.Data.align_index">Data.align_index()</a></code>.</dd>
<dt><strong><code>missing_columns</code></strong> :&ensp;<code>str</code></dt>
<dd>See <code><a title="vectorbt.data.base.Data.align_columns" href="#vectorbt.data.base.Data.align_columns">Data.align_columns()</a></code>.</dd>
<dt><strong><code>wrapper_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>For defaults, see <code>data</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_data(cls: tp.Type[DataT],
              data: tp.Data,
              tz_localize: tp.Optional[tp.TimezoneLike] = None,
              tz_convert: tp.Optional[tp.TimezoneLike] = None,
              missing_index: tp.Optional[str] = None,
              missing_columns: tp.Optional[str] = None,
              wrapper_kwargs: tp.KwargsLike = None,
              **kwargs) -&gt; DataT:
    &#34;&#34;&#34;Create a new `Data` instance from (aligned) data.

    Args:
        data (dict): Dictionary of array-like objects keyed by symbol.
        tz_localize (timezone_like): If the index is tz-naive, convert to a timezone.

            See `vectorbt.utils.datetime_.to_timezone`.
        tz_convert (timezone_like): Convert the index from one timezone to another.

            See `vectorbt.utils.datetime_.to_timezone`.
        missing_index (str): See `Data.align_index`.
        missing_columns (str): See `Data.align_columns`.
        wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
        **kwargs: Keyword arguments passed to the `__init__` method.

    For defaults, see `data` in `vectorbt._settings.settings`.&#34;&#34;&#34;
    from vectorbt._settings import settings
    data_cfg = settings[&#39;data&#39;]

    # Get global defaults
    if tz_localize is None:
        tz_localize = data_cfg[&#39;tz_localize&#39;]
    if tz_convert is None:
        tz_convert = data_cfg[&#39;tz_convert&#39;]
    if missing_index is None:
        missing_index = data_cfg[&#39;missing_index&#39;]
    if missing_columns is None:
        missing_columns = data_cfg[&#39;missing_columns&#39;]
    if wrapper_kwargs is None:
        wrapper_kwargs = {}

    data = data.copy()
    for k, v in data.items():
        # Convert array to pandas
        if not isinstance(v, (pd.Series, pd.DataFrame)):
            v = np.asarray(v)
            if v.ndim == 1:
                v = pd.Series(v)
            else:
                v = pd.DataFrame(v)

        # Perform operations with datetime-like index
        if isinstance(v.index, pd.DatetimeIndex):
            if tz_localize is not None:
                if not is_tz_aware(v.index):
                    v = v.tz_localize(to_timezone(tz_localize))
            if tz_convert is not None:
                v = v.tz_convert(to_timezone(tz_convert))
            v.index.freq = v.index.inferred_freq
        data[k] = v

    # Align index and columns
    data = cls.align_index(data, missing=missing_index)
    data = cls.align_columns(data, missing=missing_columns)

    # Create new instance
    symbols = list(data.keys())
    wrapper = ArrayWrapper.from_obj(data[symbols[0]], **wrapper_kwargs)
    return cls(
        wrapper,
        data,
        tz_localize=tz_localize,
        tz_convert=tz_convert,
        missing_index=missing_index,
        missing_columns=missing_columns,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.select_symbol_kwargs"><code class="name flex">
<span>def <span class="ident child-name">select_symbol_kwargs</span></span>(<span class="params">symbol, kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Select keyword arguments belonging to <code>symbol</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def select_symbol_kwargs(cls, symbol: tp.Label, kwargs: dict) -&gt; dict:
    &#34;&#34;&#34;Select keyword arguments belonging to `symbol`.&#34;&#34;&#34;
    _kwargs = dict()
    for k, v in kwargs.items():
        if isinstance(v, symbol_dict):
            if symbol in v:
                _kwargs[k] = v[symbol]
        else:
            _kwargs[k] = v
    return _kwargs</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.data.base.Data.data"><code class="name">var <span class="ident child-name">data</span></code></dt>
<dd>
<div class="desc"><p>Data dictionary keyed by symbol.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; tp.Data:
    &#34;&#34;&#34;Data dictionary keyed by symbol.&#34;&#34;&#34;
    return self._data</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.download_kwargs"><code class="name">var <span class="ident child-name">download_kwargs</span></code></dt>
<dd>
<div class="desc"><p>Keyword arguments initially passed to <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def download_kwargs(self) -&gt; dict:
    &#34;&#34;&#34;Keyword arguments initially passed to `Data.download_symbol`.&#34;&#34;&#34;
    return self._download_kwargs</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.missing_columns"><code class="name">var <span class="ident child-name">missing_columns</span></code></dt>
<dd>
<div class="desc"><p><code>missing_columns</code> initially passed to <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def missing_columns(self) -&gt; str:
    &#34;&#34;&#34;`missing_columns` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
    return self._missing_columns</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.missing_index"><code class="name">var <span class="ident child-name">missing_index</span></code></dt>
<dd>
<div class="desc"><p><code>missing_index</code> initially passed to <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def missing_index(self) -&gt; str:
    &#34;&#34;&#34;`missing_index` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
    return self._missing_index</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.plots_defaults"><code class="name">var <span class="ident child-name">plots_defaults</span></code></dt>
<dd>
<div class="desc"><p>Defaults for <code><a title="vectorbt.data.base.Data.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">PlotsBuilderMixin.plots()</a></code>.</p>
<p>Merges <code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults">PlotsBuilderMixin.plots_defaults</a></code> and
<code>data.plots</code> from <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plots_defaults(self) -&gt; tp.Kwargs:
    &#34;&#34;&#34;Defaults for `Data.plots`.

    Merges `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults` and
    `data.plots` from `vectorbt._settings.settings`.&#34;&#34;&#34;
    from vectorbt._settings import settings
    data_plots_cfg = settings[&#39;data&#39;][&#39;plots&#39;]

    return merge_dicts(
        PlotsBuilderMixin.plots_defaults.__get__(self),
        data_plots_cfg
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.stats_defaults"><code class="name">var <span class="ident child-name">stats_defaults</span></code></dt>
<dd>
<div class="desc"><p>Defaults for <code><a title="vectorbt.data.base.Data.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code>.</p>
<p>Merges <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">StatsBuilderMixin.stats_defaults</a></code> and
<code>data.stats</code> from <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stats_defaults(self) -&gt; tp.Kwargs:
    &#34;&#34;&#34;Defaults for `Data.stats`.

    Merges `vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults` and
    `data.stats` from `vectorbt._settings.settings`.&#34;&#34;&#34;
    from vectorbt._settings import settings
    data_stats_cfg = settings[&#39;data&#39;][&#39;stats&#39;]

    return merge_dicts(
        StatsBuilderMixin.stats_defaults.__get__(self),
        data_stats_cfg
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.symbols"><code class="name">var <span class="ident child-name">symbols</span></code></dt>
<dd>
<div class="desc"><p>List of symbols.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def symbols(self) -&gt; tp.List[tp.Label]:
    &#34;&#34;&#34;List of symbols.&#34;&#34;&#34;
    return list(self.data.keys())</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.tz_convert"><code class="name">var <span class="ident child-name">tz_convert</span></code></dt>
<dd>
<div class="desc"><p><code>tz_convert</code> initially passed to <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tz_convert(self) -&gt; tp.Optional[tp.TimezoneLike]:
    &#34;&#34;&#34;`tz_convert` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
    return self._tz_convert</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.tz_localize"><code class="name">var <span class="ident child-name">tz_localize</span></code></dt>
<dd>
<div class="desc"><p><code>tz_localize</code> initially passed to <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tz_localize(self) -&gt; tp.Optional[tp.TimezoneLike]:
    &#34;&#34;&#34;`tz_localize` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
    return self._tz_localize</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.data.base.Data.concat"><code class="name flex">
<span>def <span class="ident child-name">concat</span></span>(<span class="params">self, level_name='symbol')</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return a dict of Series/DataFrames with symbols as columns, keyed by column name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def concat(self, level_name: str = &#39;symbol&#39;) -&gt; tp.Data:
    &#34;&#34;&#34;Return a dict of Series/DataFrames with symbols as columns, keyed by column name.&#34;&#34;&#34;
    first_data = self.data[self.symbols[0]]
    index = first_data.index
    if isinstance(first_data, pd.Series):
        columns = pd.Index([first_data.name])
    else:
        columns = first_data.columns
    if len(self.symbols) &gt; 1:
        new_data = {c: pd.DataFrame(
            index=index,
            columns=pd.Index(self.symbols, name=level_name)
        ) for c in columns}
    else:
        new_data = {c: pd.Series(
            index=index,
            name=self.symbols[0]
        ) for c in columns}
    for c in columns:
        for s in self.symbols:
            if isinstance(self.data[s], pd.Series):
                col_data = self.data[s]
            else:
                col_data = self.data[s][c]
            if len(self.symbols) &gt; 1:
                new_data[c].loc[:, s] = col_data
            else:
                new_data[c].loc[:] = col_data

    return new_data</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.get"><code class="name flex">
<span>def <span class="ident child-name">get</span></span>(<span class="params">self, column=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get column data.</p>
<p>If one symbol, returns data for that symbol.
If multiple symbols, performs concatenation first and returns a DataFrame if one column
and a tuple of DataFrames if a list of columns passed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, column: tp.Optional[tp.Label] = None, **kwargs) -&gt; tp.MaybeTuple[tp.SeriesFrame]:
    &#34;&#34;&#34;Get column data.

    If one symbol, returns data for that symbol.
    If multiple symbols, performs concatenation first and returns a DataFrame if one column
    and a tuple of DataFrames if a list of columns passed.&#34;&#34;&#34;
    if len(self.symbols) == 1:
        if column is None:
            return self.data[self.symbols[0]]
        return self.data[self.symbols[0]][column]

    concat_data = self.concat(**kwargs)
    if len(concat_data) == 1:
        return tuple(concat_data.values())[0]
    if column is not None:
        if isinstance(column, list):
            return tuple([concat_data[c] for c in column])
        return concat_data[column]
    return tuple(concat_data.values())</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.indexing_func"><code class="name flex">
<span>def <span class="ident child-name">indexing_func</span></span>(<span class="params">self, pd_indexing_func, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Perform indexing on <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indexing_func(self: DataT, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; DataT:
    &#34;&#34;&#34;Perform indexing on `Data`.&#34;&#34;&#34;
    new_wrapper = pd_indexing_func(self.wrapper)
    new_data = {k: pd_indexing_func(v) for k, v in self.data.items()}
    return self.replace(
        wrapper=new_wrapper,
        data=new_data
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.plot"><code class="name flex">
<span>def <span class="ident child-name">plot</span></span>(<span class="params">self, column=None, base=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Plot orders.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column to plot.</dd>
<dt><strong><code>base</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Rebase all series of a column to a given intial base.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The column should contain prices.</p>
</div>
</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.generic.accessors.GenericAccessor.plot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.plot">GenericAccessor.plot()</a></code>.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; start = '2021-01-01 UTC'  # crypto is in UTC
&gt;&gt;&gt; end = '2021-06-01 UTC'
&gt;&gt;&gt; data = vbt.YFData.download(['BTC-USD', 'ETH-USD', 'ADA-USD'], start=start, end=end)

&gt;&gt;&gt; data.plot(column='Close', base=1)
</code></pre>
<p><img alt="" src="/docs/img/data_plot.svg"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         column: tp.Optional[tp.Label] = None,
         base: tp.Optional[float] = None,
         **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
    &#34;&#34;&#34;Plot orders.

    Args:
        column (str): Name of the column to plot.
        base (float): Rebase all series of a column to a given intial base.

            !!! note
                The column should contain prices.
        kwargs (dict): Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.plot`.

    ## Example

    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; start = &#39;2021-01-01 UTC&#39;  # crypto is in UTC
    &gt;&gt;&gt; end = &#39;2021-06-01 UTC&#39;
    &gt;&gt;&gt; data = vbt.YFData.download([&#39;BTC-USD&#39;, &#39;ETH-USD&#39;, &#39;ADA-USD&#39;], start=start, end=end)

    &gt;&gt;&gt; data.plot(column=&#39;Close&#39;, base=1)
    ```

    ![](/docs/img/data_plot.svg)&#34;&#34;&#34;
    self_col = self.select_one(column=column, group_by=False)
    data = self_col.get()
    if base is not None:
        data = data.vbt.rebase(base)
    return data.vbt.plot(**kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.update"><code class="name flex">
<span>def <span class="ident child-name">update</span></span>(<span class="params">self, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Update the data using <code><a title="vectorbt.data.base.Data.update_symbol" href="#vectorbt.data.base.Data.update_symbol">Data.update_symbol()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>
<p>Passed to <code><a title="vectorbt.data.base.Data.update_symbol" href="#vectorbt.data.base.Data.update_symbol">Data.update_symbol()</a></code>.</p>
<p>If two symbols require different keyword arguments, pass <code><a title="vectorbt.data.base.symbol_dict" href="#vectorbt.data.base.symbol_dict">symbol_dict</a></code> for each argument.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a new <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> instance.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self: DataT, **kwargs) -&gt; DataT:
    &#34;&#34;&#34;Update the data using `Data.update_symbol`.

    Args:
        **kwargs: Passed to `Data.update_symbol`.

            If two symbols require different keyword arguments, pass `symbol_dict` for each argument.

    !!! note
        Returns a new `Data` instance.&#34;&#34;&#34;
    new_data = dict()
    for k, v in self.data.items():
        # Select keyword arguments for this symbol
        _kwargs = self.select_symbol_kwargs(k, kwargs)

        # Download new data for this symbol
        new_obj = self.update_symbol(k, **_kwargs)

        # Convert array to pandas
        if not isinstance(new_obj, (pd.Series, pd.DataFrame)):
            new_obj = np.asarray(new_obj)
            index = pd.RangeIndex(
                start=v.index[-1],
                stop=v.index[-1] + new_obj.shape[0],
                step=1
            )
            if new_obj.ndim == 1:
                new_obj = pd.Series(new_obj, index=index)
            else:
                new_obj = pd.DataFrame(new_obj, index=index)

        # Perform operations with datetime-like index
        if isinstance(new_obj.index, pd.DatetimeIndex):
            if self.tz_localize is not None:
                if not is_tz_aware(new_obj.index):
                    new_obj = new_obj.tz_localize(to_timezone(self.tz_localize))
            if self.tz_convert is not None:
                new_obj = new_obj.tz_convert(to_timezone(self.tz_convert))

        new_data[k] = new_obj

    # Align index and columns
    new_data = self.align_index(new_data, missing=self.missing_index)
    new_data = self.align_columns(new_data, missing=self.missing_columns)

    # Concatenate old and new data
    for k, v in new_data.items():
        if isinstance(self.data[k], pd.Series):
            if isinstance(v, pd.DataFrame):
                v = v[self.data[k].name]
        else:
            v = v[self.data[k].columns]
        v = pd.concat((self.data[k], v), axis=0)
        v = v[~v.index.duplicated(keep=&#39;last&#39;)]
        if isinstance(v.index, pd.DatetimeIndex):
            v.index.freq = v.index.inferred_freq
        new_data[k] = v

    # Create new instance
    new_index = new_data[self.symbols[0]].index
    return self.replace(
        wrapper=self.wrapper.replace(index=new_index),
        data=new_data
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.update_symbol"><code class="name flex">
<span>def <span class="ident child-name">update_symbol</span></span>(<span class="params">self, symbol, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract method to update a symbol.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_symbol(self, symbol: tp.Label, **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Abstract method to update a symbol.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.deep_getattr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.post_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.pre_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.replace" href="../utils/config.html#vectorbt.utils.config.Configured.replace">replace</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.resolve_self" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.self_aliases" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
<li><code><b><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
</ul>
</li>
<li><code><b><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.data.base.MetaData"><code class="flex name class">
<span>class <span class="ident parent-name">MetaData</span></span>
(<span class="params">*args, **kwargs</span>)
</code></dt>
<dd>
<div class="desc"><p>Meta class that exposes a read-only class property <code>StatsBuilderMixin.metrics</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaData(type(StatsBuilderMixin), type(PlotsBuilderMixin)):
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.generic.stats_builder.MetaStatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.MetaStatsBuilderMixin">MetaStatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.MetaPlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.MetaPlotsBuilderMixin">MetaPlotsBuilderMixin</a></li>
<li>builtins.type</li>
</ul>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.generic.stats_builder.MetaStatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.MetaStatsBuilderMixin">MetaStatsBuilderMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.generic.stats_builder.MetaStatsBuilderMixin.metrics" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.MetaStatsBuilderMixin.metrics">metrics</a></code></li>
</ul>
</li>
<li><code><b><a title="vectorbt.generic.plots_builder.MetaPlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.MetaPlotsBuilderMixin">MetaPlotsBuilderMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.generic.plots_builder.MetaPlotsBuilderMixin.subplots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.MetaPlotsBuilderMixin.subplots">subplots</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.data.base.symbol_dict"><code class="flex name class">
<span>class <span class="ident parent-name">symbol_dict</span></span>
(<span class="params">*args, **kwargs</span>)
</code></dt>
<dd>
<div class="desc"><p>Dict that contains symbols as keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class symbol_dict(dict):
    &#34;&#34;&#34;Dict that contains symbols as keys.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRUYwMDAwO30KCS5zdDF7ZmlsbDojRkY5MDAwO30KCS5zdDJ7ZmlsbDojRkZERjAwO30KCS5zdDN7ZmlsbDojMjgyQzM0O30KPC9zdHlsZT4KPGc+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNTUuMywzMDAuMSAyODMuMSwwIDIwOCwwIDExMC44LDAgMzUuOCwwIDEuMiw0NTAuMiA3Ni4zLDQ1MC4yIAkJCSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjIzMC40LDMwMC4xIDM1OC4xLDAgMjgzLjEsMCAxODUuOCwwIDExMC44LDAgNzYuMyw0NTAuMiAxNTEuMyw0NTAuMiAJCQkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIzMDUuNCwzMDAuMSA0MzMuMSwwIDM1OC4xLDAgMzMxLjYsNjIuMyAyNjAuOCwwIDE4NS44LDAgMTUxLjMsNDUwLjIgMjI2LjQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iNTEwLjgsMCA0MzMuMSwwIDMwNS40LDMwMC4xIDMzOC40LDAgMjYwLjgsMCAyMjYuNCw0NTAuMiAzMDQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="/>
vectorbt <span class="version">0.22.0</span></a>
</header>
<div class="search-container" id="docsearch"></div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul>
<li><a href="#downloading">Downloading</a></li>
<li><a href="#updating">Updating</a></li>
<li><a href="#merging">Merging</a></li>
<li><a href="#indexing">Indexing</a></li>
<li><a href="#saving-and-loading">Saving and loading</a></li>
<li><a href="#stats">Stats</a></li>
<li><a href="#plots">Plots</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.data" href="index.html">vectorbt.data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.data.base.Data.align_columns" href="#vectorbt.data.base.Data.align_columns">align_columns</a></code></li>
<li><code><a title="vectorbt.data.base.Data.align_index" href="#vectorbt.data.base.Data.align_index">align_index</a></code></li>
<li><code><a title="vectorbt.data.base.Data.concat" href="#vectorbt.data.base.Data.concat">concat</a></code></li>
<li><code><a title="vectorbt.data.base.Data.data" href="#vectorbt.data.base.Data.data">data</a></code></li>
<li><code><a title="vectorbt.data.base.Data.download" href="#vectorbt.data.base.Data.download">download</a></code></li>
<li><code><a title="vectorbt.data.base.Data.download_kwargs" href="#vectorbt.data.base.Data.download_kwargs">download_kwargs</a></code></li>
<li><code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">download_symbol</a></code></li>
<li><code><a title="vectorbt.data.base.Data.from_data" href="#vectorbt.data.base.Data.from_data">from_data</a></code></li>
<li><code><a title="vectorbt.data.base.Data.get" href="#vectorbt.data.base.Data.get">get</a></code></li>
<li><code><a title="vectorbt.data.base.Data.indexing_func" href="#vectorbt.data.base.Data.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.data.base.Data.metrics" href="#vectorbt.data.base.Data.metrics">metrics</a></code></li>
<li><code><a title="vectorbt.data.base.Data.missing_columns" href="#vectorbt.data.base.Data.missing_columns">missing_columns</a></code></li>
<li><code><a title="vectorbt.data.base.Data.missing_index" href="#vectorbt.data.base.Data.missing_index">missing_index</a></code></li>
<li><code><a title="vectorbt.data.base.Data.plot" href="#vectorbt.data.base.Data.plot">plot</a></code></li>
<li><code><a title="vectorbt.data.base.Data.plots_defaults" href="#vectorbt.data.base.Data.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.data.base.Data.select_symbol_kwargs" href="#vectorbt.data.base.Data.select_symbol_kwargs">select_symbol_kwargs</a></code></li>
<li><code><a title="vectorbt.data.base.Data.stats_defaults" href="#vectorbt.data.base.Data.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.data.base.Data.subplots" href="#vectorbt.data.base.Data.subplots">subplots</a></code></li>
<li><code><a title="vectorbt.data.base.Data.symbols" href="#vectorbt.data.base.Data.symbols">symbols</a></code></li>
<li><code><a title="vectorbt.data.base.Data.tz_convert" href="#vectorbt.data.base.Data.tz_convert">tz_convert</a></code></li>
<li><code><a title="vectorbt.data.base.Data.tz_localize" href="#vectorbt.data.base.Data.tz_localize">tz_localize</a></code></li>
<li><code><a title="vectorbt.data.base.Data.update" href="#vectorbt.data.base.Data.update">update</a></code></li>
<li><code><a title="vectorbt.data.base.Data.update_symbol" href="#vectorbt.data.base.Data.update_symbol">update_symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.data.base.MetaData" href="#vectorbt.data.base.MetaData">MetaData</a></code></h4>
</li>
<li>
<h4><code><a title="vectorbt.data.base.symbol_dict" href="#vectorbt.data.base.symbol_dict">symbol_dict</a></code></h4>
</li>
</ul>
</li>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script src="https://cdn.jsdelivr.net/npm/@docsearch/js@alpha"></script>
<script type="text/javascript">
docsearch({
container: '#docsearch',
appId: 'KNQTBBHKVB',
indexName: 'vectorbt',
apiKey: 'a945e6e8f1cb2fdc30e936936aa3307b',
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous"></script>
<script>
$(document).ready(function() {
$("article dt[id], #section-intro [id]").each(function() {
const thisId = $(this).attr('id');
$(this).wrap('<a class="headerlink" href="#' + thisId + '">');
});
});
</script>
</body>
</html>