<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.data.base API documentation</title>
<meta name="description" content="Base data class â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.data.base</code></h1>
</header>
<section id="section-intro">
<p>Base data class.</p>
<p>Class <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> allows storing, downloading, updating, and managing data. It stores data
as a dictionary of Series/DataFrames keyed by symbol, and makes sure that
all pandas objects have the same index and columns by aligning them.</p>
<h2 id="downloading">Downloading</h2>
<p>Data can be downloaded by overriding the <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code> class method. What <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> does
under the hood is iterating over all symbols and calling this method.</p>
<p>Let's create a simple data class <code>RandomData</code> that generates price based on
random returns with provided mean and standard deviation:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; class RandomData(vbt.Data):
...     @classmethod
...     def download_symbol(cls, symbol, mean=0., stdev=0.1, start_value=100,
...                         start_dt='2021-01-01', end_dt='2021-01-10'):
...         index = pd.date_range(start_dt, end_dt)
...         rand_returns = np.random.normal(mean, stdev, size=len(index))
...         rand_price = start_value + np.cumprod(rand_returns + 1)
...         return pd.Series(rand_price, index=index)

&gt;&gt;&gt; rand_data = RandomData.download(['RAND1', 'RAND2'])
&gt;&gt;&gt; rand_data.get()
symbol           RAND1       RAND2
2021-01-01  101.042956  100.920462
2021-01-02  100.987327  100.956455
2021-01-03  101.022333  100.955128
2021-01-04  101.084243  100.791793
2021-01-05  101.158619  100.781000
2021-01-06  101.172688  100.786198
2021-01-07  101.311609  100.848192
2021-01-08  101.331841  100.861500
2021-01-09  101.440530  100.944935
2021-01-10  101.585689  100.993223
</code></pre>
<p>To provide different keyword arguments for different symbols, we can use <code><a title="vectorbt.data.base.symbol_dict" href="#vectorbt.data.base.symbol_dict">symbol_dict</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; start_value = vbt.symbol_dict({'RAND2': 200})
&gt;&gt;&gt; rand_data = RandomData.download(['RAND1', 'RAND2'], start_value=start_value)
&gt;&gt;&gt; rand_data.get()
symbol           RAND1       RAND2
2021-01-01  101.083324  200.886078
2021-01-02  101.113405  200.791934
2021-01-03  101.169194  200.852877
2021-01-04  101.164033  200.820111
2021-01-05  101.326248  201.060448
2021-01-06  101.394482  200.876984
2021-01-07  101.494227  200.845519
2021-01-08  101.422012  200.963474
2021-01-09  101.493162  200.790369
2021-01-10  101.606052  200.752296
</code></pre>
<p>In case two symbols have different index or columns, they are automatically aligned based on
the settings <code>missing_index</code> and <code>missing_columns</code> (see <code><a title="vectorbt.settings.data" href="../settings.html#vectorbt.settings.data">data</a></code>):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; start_dt = vbt.symbol_dict({'RAND2': '2021-01-03'})
&gt;&gt;&gt; end_dt = vbt.symbol_dict({'RAND2': '2021-01-07'})
&gt;&gt;&gt; rand_data = RandomData.download(
...     ['RAND1', 'RAND2'], start_value=start_value,
...     start_dt=start_dt, end_dt=end_dt)
&gt;&gt;&gt; rand_data.get()
symbol           RAND1       RAND2
2021-01-01  101.028054         NaN
2021-01-02  101.032090         NaN
2021-01-03  101.038531  200.936283
2021-01-04  101.068265  200.926764
2021-01-05  100.878492  200.898898
2021-01-06  100.857444  200.922368
2021-01-07  100.933123  200.987094
2021-01-08  100.938034         NaN
2021-01-09  101.044736         NaN
2021-01-10  101.098133         NaN
</code></pre>
<h2 id="updating">Updating</h2>
<p>Updating can be implemented by overriding the <code><a title="vectorbt.data.base.Data.update_symbol" href="#vectorbt.data.base.Data.update_symbol">Data.update_symbol()</a></code> instance method, which takes
the same arguments as <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>. In contrast to the download method, the update
method is an instance method and can access the data downloaded earlier. It can also access the
keyword arguments initially passed to the download method, accessible under <code><a title="vectorbt.data.base.Data.download_kwargs" href="#vectorbt.data.base.Data.download_kwargs">Data.download_kwargs</a></code>.
These arguments can be used as default arguments and overriden by arguments passed directly
to the update method, using <code><a title="vectorbt.utils.config.merge_dicts" href="../utils/config.html#vectorbt.utils.config.merge_dicts">merge_dicts()</a></code>.</p>
<p>Let's define an update method that updates the latest data point and adds two news data points.
Note that updating data always returns a new <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> instance.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; from vectorbt.utils.config import merge_dicts

&gt;&gt;&gt; class RandomData(vbt.Data):
...     @classmethod
...     def download_symbol(cls, symbol, mean=0., stdev=0.1, start_value=100,
...                         start_dt='2021-01-01', end_dt='2021-01-10'):
...         index = pd.date_range(start_dt, end_dt)
...         rand_returns = np.random.normal(mean, stdev, size=len(index))
...         rand_price = start_value + np.cumprod(rand_returns + 1)
...         return pd.Series(rand_price, index=index)
...
...     def update_symbol(self, symbol, **kwargs):
...         download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
...         download_kwargs['start_dt'] = self.data[symbol].index[-1]
...         download_kwargs['end_dt'] = download_kwargs['start_dt'] + timedelta(days=2)
...         kwargs = merge_dicts(download_kwargs, kwargs)
...         return self.download_symbol(symbol, **kwargs)

&gt;&gt;&gt; rand_data = RandomData.download(['RAND1', 'RAND2'], end_dt='2021-01-05')
&gt;&gt;&gt; rand_data.get()
symbol           RAND1       RAND2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  100.834387  100.866549

&gt;&gt;&gt; rand_data = rand_data.update()
&gt;&gt;&gt; rand_data.get()
symbol           RAND1       RAND2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  101.011255  100.887049 &lt; updated from here
2021-01-06  101.004149  100.808410
2021-01-07  101.023673  100.714583

&gt;&gt;&gt; rand_data = rand_data.update()
&gt;&gt;&gt; rand_data.get()
symbol           RAND1       RAND2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  101.011255  100.887049
2021-01-06  101.004149  100.808410
2021-01-07  100.883400  100.874922 &lt; updated from here
2021-01-08  101.011738  100.780188
2021-01-09  100.912639  100.934014
</code></pre>
<h2 id="merging">Merging</h2>
<p>You can merge symbols from different <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> instances either by subclassing <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> and
defining custom download and update methods, or by manually merging their data dicts
into one data dict and passing it to the <code><a title="vectorbt.data.base.Data.from_data" href="#vectorbt.data.base.Data.from_data">Data.from_data()</a></code> class method.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; rand_data1 = RandomData.download('RAND1', mean=0.2)
&gt;&gt;&gt; rand_data2 = RandomData.download('RAND2', start_value=200, start_dt='2021-01-05')
&gt;&gt;&gt; merged_data = vbt.Data.from_data(vbt.merge_dicts(rand_data1.data, rand_data2.data))
&gt;&gt;&gt; merged_data.get()
symbol           RAND1       RAND2
2021-01-01  101.160718         NaN
2021-01-02  101.421020         NaN
2021-01-03  101.959176         NaN
2021-01-04  102.076670         NaN
2021-01-05  102.447234  200.916198
2021-01-06  103.195187  201.033907
2021-01-07  103.595915  200.908229
2021-01-08  104.332550  201.000497
2021-01-09  105.159708  201.019157
2021-01-10  106.729495  200.910210
</code></pre>
<h2 id="indexing">Indexing</h2>
<p>Like any other class subclassing <code><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></code>, we can do pandas indexing
on a <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> instance, which forwards indexing operation to each Series/DataFrame:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; rand_data.loc['2021-01-07':'2021-01-09']
&lt;__main__.RandomData at 0x7fdba4e36198&gt;

&gt;&gt;&gt; rand_data.loc['2021-01-07':'2021-01-09'].get()
symbol           RAND1       RAND2
2021-01-07  100.883400  100.874922
2021-01-08  101.011738  100.780188
2021-01-09  100.912639  100.934014
</code></pre>
<h2 id="saving-and-loading">Saving and loading</h2>
<p>Like any other class subclassing <code><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></code>, we can save a <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code>
instance to the disk with <code><a title="vectorbt.data.base.Data.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">Pickleable.save()</a></code> and load it with <code><a title="vectorbt.data.base.Data.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">Pickleable.load()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; rand_data.save('rand_data')
&gt;&gt;&gt; rand_data = RandomData.load('rand_data')
&gt;&gt;&gt; rand_data.get()
symbol           RAND1       RAND2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  101.011255  100.887049
2021-01-06  101.004149  100.808410
2021-01-07  100.883400  100.874922
2021-01-08  101.011738  100.780188
2021-01-09  100.912639  100.934014
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Base data class.

Class `Data` allows storing, downloading, updating, and managing data. It stores data
as a dictionary of Series/DataFrames keyed by symbol, and makes sure that
all pandas objects have the same index and columns by aligning them.

## Downloading

Data can be downloaded by overriding the `Data.download_symbol` class method. What `Data` does
under the hood is iterating over all symbols and calling this method.

Let&#39;s create a simple data class `RandomData` that generates price based on
random returns with provided mean and standard deviation:

```python-repl
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; class RandomData(vbt.Data):
...     @classmethod
...     def download_symbol(cls, symbol, mean=0., stdev=0.1, start_value=100,
...                         start_dt=&#39;2021-01-01&#39;, end_dt=&#39;2021-01-10&#39;):
...         index = pd.date_range(start_dt, end_dt)
...         rand_returns = np.random.normal(mean, stdev, size=len(index))
...         rand_price = start_value + np.cumprod(rand_returns + 1)
...         return pd.Series(rand_price, index=index)

&gt;&gt;&gt; rand_data = RandomData.download([&#39;RAND1&#39;, &#39;RAND2&#39;])
&gt;&gt;&gt; rand_data.get()
symbol           RAND1       RAND2
2021-01-01  101.042956  100.920462
2021-01-02  100.987327  100.956455
2021-01-03  101.022333  100.955128
2021-01-04  101.084243  100.791793
2021-01-05  101.158619  100.781000
2021-01-06  101.172688  100.786198
2021-01-07  101.311609  100.848192
2021-01-08  101.331841  100.861500
2021-01-09  101.440530  100.944935
2021-01-10  101.585689  100.993223
```

To provide different keyword arguments for different symbols, we can use `vectorbt.data.base.symbol_dict`:

```python-repl
&gt;&gt;&gt; start_value = vbt.symbol_dict({&#39;RAND2&#39;: 200})
&gt;&gt;&gt; rand_data = RandomData.download([&#39;RAND1&#39;, &#39;RAND2&#39;], start_value=start_value)
&gt;&gt;&gt; rand_data.get()
symbol           RAND1       RAND2
2021-01-01  101.083324  200.886078
2021-01-02  101.113405  200.791934
2021-01-03  101.169194  200.852877
2021-01-04  101.164033  200.820111
2021-01-05  101.326248  201.060448
2021-01-06  101.394482  200.876984
2021-01-07  101.494227  200.845519
2021-01-08  101.422012  200.963474
2021-01-09  101.493162  200.790369
2021-01-10  101.606052  200.752296
```

In case two symbols have different index or columns, they are automatically aligned based on
the settings `missing_index` and `missing_columns` (see `vectorbt.settings.data`):

```python-repl
&gt;&gt;&gt; start_dt = vbt.symbol_dict({&#39;RAND2&#39;: &#39;2021-01-03&#39;})
&gt;&gt;&gt; end_dt = vbt.symbol_dict({&#39;RAND2&#39;: &#39;2021-01-07&#39;})
&gt;&gt;&gt; rand_data = RandomData.download(
...     [&#39;RAND1&#39;, &#39;RAND2&#39;], start_value=start_value,
...     start_dt=start_dt, end_dt=end_dt)
&gt;&gt;&gt; rand_data.get()
symbol           RAND1       RAND2
2021-01-01  101.028054         NaN
2021-01-02  101.032090         NaN
2021-01-03  101.038531  200.936283
2021-01-04  101.068265  200.926764
2021-01-05  100.878492  200.898898
2021-01-06  100.857444  200.922368
2021-01-07  100.933123  200.987094
2021-01-08  100.938034         NaN
2021-01-09  101.044736         NaN
2021-01-10  101.098133         NaN
```

## Updating

Updating can be implemented by overriding the `Data.update_symbol` instance method, which takes
the same arguments as `Data.download_symbol`. In contrast to the download method, the update
method is an instance method and can access the data downloaded earlier. It can also access the
keyword arguments initially passed to the download method, accessible under `Data.download_kwargs`.
These arguments can be used as default arguments and overriden by arguments passed directly
to the update method, using `vectorbt.utils.config.merge_dicts`.

Let&#39;s define an update method that updates the latest data point and adds two news data points.
Note that updating data always returns a new `Data` instance.

```python-repl
&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; from vectorbt.utils.config import merge_dicts

&gt;&gt;&gt; class RandomData(vbt.Data):
...     @classmethod
...     def download_symbol(cls, symbol, mean=0., stdev=0.1, start_value=100,
...                         start_dt=&#39;2021-01-01&#39;, end_dt=&#39;2021-01-10&#39;):
...         index = pd.date_range(start_dt, end_dt)
...         rand_returns = np.random.normal(mean, stdev, size=len(index))
...         rand_price = start_value + np.cumprod(rand_returns + 1)
...         return pd.Series(rand_price, index=index)
...
...     def update_symbol(self, symbol, **kwargs):
...         download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
...         download_kwargs[&#39;start_dt&#39;] = self.data[symbol].index[-1]
...         download_kwargs[&#39;end_dt&#39;] = download_kwargs[&#39;start_dt&#39;] + timedelta(days=2)
...         kwargs = merge_dicts(download_kwargs, kwargs)
...         return self.download_symbol(symbol, **kwargs)

&gt;&gt;&gt; rand_data = RandomData.download([&#39;RAND1&#39;, &#39;RAND2&#39;], end_dt=&#39;2021-01-05&#39;)
&gt;&gt;&gt; rand_data.get()
symbol           RAND1       RAND2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  100.834387  100.866549

&gt;&gt;&gt; rand_data = rand_data.update()
&gt;&gt;&gt; rand_data.get()
symbol           RAND1       RAND2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  101.011255  100.887049 &lt; updated from here
2021-01-06  101.004149  100.808410
2021-01-07  101.023673  100.714583

&gt;&gt;&gt; rand_data = rand_data.update()
&gt;&gt;&gt; rand_data.get()
symbol           RAND1       RAND2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  101.011255  100.887049
2021-01-06  101.004149  100.808410
2021-01-07  100.883400  100.874922 &lt; updated from here
2021-01-08  101.011738  100.780188
2021-01-09  100.912639  100.934014
```

## Merging

You can merge symbols from different `Data` instances either by subclassing `Data` and
defining custom download and update methods, or by manually merging their data dicts
into one data dict and passing it to the `Data.from_data` class method.

```python-repl
&gt;&gt;&gt; rand_data1 = RandomData.download(&#39;RAND1&#39;, mean=0.2)
&gt;&gt;&gt; rand_data2 = RandomData.download(&#39;RAND2&#39;, start_value=200, start_dt=&#39;2021-01-05&#39;)
&gt;&gt;&gt; merged_data = vbt.Data.from_data(vbt.merge_dicts(rand_data1.data, rand_data2.data))
&gt;&gt;&gt; merged_data.get()
symbol           RAND1       RAND2
2021-01-01  101.160718         NaN
2021-01-02  101.421020         NaN
2021-01-03  101.959176         NaN
2021-01-04  102.076670         NaN
2021-01-05  102.447234  200.916198
2021-01-06  103.195187  201.033907
2021-01-07  103.595915  200.908229
2021-01-08  104.332550  201.000497
2021-01-09  105.159708  201.019157
2021-01-10  106.729495  200.910210
```

## Indexing

Like any other class subclassing `vectorbt.base.array_wrapper.Wrapping`, we can do pandas indexing
on a `Data` instance, which forwards indexing operation to each Series/DataFrame:

```python-repl
&gt;&gt;&gt; rand_data.loc[&#39;2021-01-07&#39;:&#39;2021-01-09&#39;]
&lt;__main__.RandomData at 0x7fdba4e36198&gt;

&gt;&gt;&gt; rand_data.loc[&#39;2021-01-07&#39;:&#39;2021-01-09&#39;].get()
symbol           RAND1       RAND2
2021-01-07  100.883400  100.874922
2021-01-08  101.011738  100.780188
2021-01-09  100.912639  100.934014
```

## Saving and loading

Like any other class subclassing `vectorbt.utils.config.Pickleable`, we can save a `Data`
instance to the disk with `Data.save` and load it with `Data.load`:

```python-repl
&gt;&gt;&gt; rand_data.save(&#39;rand_data&#39;)
&gt;&gt;&gt; rand_data = RandomData.load(&#39;rand_data&#39;)
&gt;&gt;&gt; rand_data.get()
symbol           RAND1       RAND2
2021-01-01  100.956601  100.970865
2021-01-02  100.919011  100.987026
2021-01-03  101.062733  100.835376
2021-01-04  100.960535  100.820817
2021-01-05  101.011255  100.887049
2021-01-06  101.004149  100.808410
2021-01-07  100.883400  100.874922
2021-01-08  101.011738  100.780188
2021-01-09  100.912639  100.934014
```
&#34;&#34;&#34;

import numpy as np
import pandas as pd
import warnings

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_method
from vectorbt.utils.datetime import is_tz_aware, to_timezone
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


class symbol_dict(dict):
    &#34;&#34;&#34;Dict that contains symbols as keys.&#34;&#34;&#34;
    pass


class Data(Wrapping):
    &#34;&#34;&#34;Class that downloads, updates, and manages data coming from a data source.&#34;&#34;&#34;

    def __init__(self, wrapper, data, tz_localize=None, tz_convert=None, missing_index=None,
                 missing_columns=None, download_kwargs=None, **kwargs):
        Wrapping.__init__(
            self,
            wrapper,
            data=data,
            tz_localize=tz_localize,
            tz_convert=tz_convert,
            missing_index=missing_index,
            missing_columns=missing_columns,
            download_kwargs=download_kwargs,
            **kwargs
        )

        checks.assert_type(data, dict)
        for k, v in data.items():
            checks.assert_meta_equal(v, data[list(data.keys())[0]])
        self._data = data
        self._tz_localize = tz_localize
        self._tz_convert = tz_convert
        self._missing_index = missing_index
        self._missing_columns = missing_columns
        self._download_kwargs = download_kwargs

    def _indexing_func(self, pd_indexing_func, **kwargs):
        &#34;&#34;&#34;Perform indexing on `Data`.&#34;&#34;&#34;
        new_wrapper = pd_indexing_func(self.wrapper, **kwargs)
        new_data = {k: pd_indexing_func(v, **kwargs) for k, v in self.data.items()}
        return self.copy(
            wrapper=new_wrapper,
            data=new_data
        )

    @property
    def data(self):
        &#34;&#34;&#34;Data dictionary keyed by symbol.&#34;&#34;&#34;
        return self._data

    @property
    def symbols(self):
        &#34;&#34;&#34;List of symbols.&#34;&#34;&#34;
        return list(self.data.keys())

    @property
    def tz_localize(self):
        &#34;&#34;&#34;`tz_localize` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._tz_localize

    @property
    def tz_convert(self):
        &#34;&#34;&#34;`tz_convert` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._tz_convert

    @property
    def missing_index(self):
        &#34;&#34;&#34;`missing_index` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._missing_index

    @property
    def missing_columns(self):
        &#34;&#34;&#34;`missing_columns` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._missing_columns

    @property
    def download_kwargs(self):
        &#34;&#34;&#34;Keyword arguments initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._download_kwargs

    @classmethod
    def align_index(cls, data, missing=&#39;nan&#39;):
        &#34;&#34;&#34;Align data to have the same index.

        The argument `missing` accepts the following values:

        * &#39;nan&#39;: set missing data points to NaN
        * &#39;drop&#39;: remove missing data points
        * &#39;raise&#39;: raise an error&#34;&#34;&#34;
        if len(data) == 1:
            return data

        index = None
        for k, v in data.items():
            if index is None:
                index = v.index
            else:
                if len(index.intersection(v.index)) != len(index.union(v.index)):
                    if missing == &#39;nan&#39;:
                        warnings.warn(&#34;Symbols have mismatching index. &#34;
                                      &#34;Setting missing data points to NaN.&#34;, stacklevel=2)
                        index = index.union(v.index)
                    elif missing == &#39;drop&#39;:
                        warnings.warn(&#34;Symbols have mismatching index. &#34;
                                      &#34;Dropping missing data points.&#34;, stacklevel=2)
                        index = index.intersection(v.index)
                    elif missing == &#39;raise&#39;:
                        raise ValueError(&#34;Symbols have mismatching index&#34;)
                    else:
                        raise ValueError(f&#34;missing=&#39;{missing}&#39; is not recognized&#34;)

        # reindex
        new_data = {k: v.reindex(index=index) for k, v in data.items()}
        return new_data

    @classmethod
    def align_columns(cls, data, missing=&#39;raise&#39;):
        &#34;&#34;&#34;Align data to have the same columns.

        See `Data.align_index` for `missing`.&#34;&#34;&#34;
        if len(data) == 1:
            return data

        columns = None
        multiple_columns = False
        name_is_none = False
        for k, v in data.items():
            if isinstance(v, pd.Series):
                if v.name is None:
                    name_is_none = True
                v = v.to_frame()
            else:
                multiple_columns = True
            if columns is None:
                columns = v.columns
            else:
                if len(columns.intersection(v.columns)) != len(columns.union(v.columns)):
                    if missing == &#39;nan&#39;:
                        warnings.warn(&#34;Symbols have mismatching columns. &#34;
                                      &#34;Setting missing data points to NaN.&#34;, stacklevel=2)
                        columns = columns.union(v.columns)
                    elif missing == &#39;drop&#39;:
                        warnings.warn(&#34;Symbols have mismatching columns. &#34;
                                      &#34;Dropping missing data points.&#34;, stacklevel=2)
                        columns = columns.intersection(v.columns)
                    elif missing == &#39;raise&#39;:
                        raise ValueError(&#34;Symbols have mismatching columns&#34;)
                    else:
                        raise ValueError(f&#34;missing=&#39;{missing}&#39; is not recognized&#34;)

        # reindex
        new_data = {}
        for k, v in data.items():
            if isinstance(v, pd.Series):
                v = v.to_frame(name=v.name)
            v = v.reindex(columns=columns)
            if not multiple_columns:
                v = v[columns[0]]
                if name_is_none:
                    v = v.rename(None)
            new_data[k] = v
        return new_data

    @classmethod
    def select_symbol_kwargs(cls, symbol, kwargs):
        &#34;&#34;&#34;Select keyword arguments belonging to `symbol`.&#34;&#34;&#34;
        _kwargs = dict()
        for k, v in kwargs.items():
            if isinstance(v, symbol_dict):
                if symbol in v:
                    _kwargs[k] = v[symbol]
            else:
                _kwargs[k] = v
        return _kwargs

    @classmethod
    def from_data(cls, data, tz_localize=None, tz_convert=None, missing_index=None,
                  missing_columns=None, wrapper_kwargs=None, **kwargs):
        &#34;&#34;&#34;Create a new `Data` instance from (aligned) data.

        Args:
            data (dict): Dictionary of array-like objects keyed by symbol.
            tz_localize (any): If the index is tz-naive, convert to a timezone.

                See `vectorbt.utils.datetime.to_timezone`.
            tz_convert (any): Convert the index from one timezone to another.

                See `vectorbt.utils.datetime.to_timezone`.

                Defaults to `tz_convert` in `vectorbt.settings.data`.
            missing_index (str): See `Data.align_index`.

                Defaults to `missing_index` in `vectorbt.settings.data`.
            missing_columns (str): See `Data.align_columns`.

                Defaults to `missing_columns` in `vectorbt.settings.data`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            **kwargs: Keyword arguments passed to the `__init__` method.&#34;&#34;&#34;
        from vectorbt import settings

        # Get global defaults
        if tz_localize is None:
            tz_localize = settings.data[&#39;tz_localize&#39;]
        if tz_convert is None:
            tz_convert = settings.data[&#39;tz_convert&#39;]
        if missing_index is None:
            missing_index = settings.data[&#39;missing_index&#39;]
        if missing_columns is None:
            missing_columns = settings.data[&#39;missing_columns&#39;]
        if wrapper_kwargs is None:
            wrapper_kwargs = {}

        data = data.copy()
        for k, v in data.items():
            # Convert array to pandas
            if not isinstance(v, (pd.Series, pd.DataFrame)):
                v = np.asarray(v)
                if v.ndim == 1:
                    v = pd.Series(v)
                else:
                    v = pd.DataFrame(v)

            # Perform operations with datetime-like index
            if isinstance(v.index, pd.DatetimeIndex):
                if tz_localize is not None:
                    if not is_tz_aware(v.index):
                        v = v.tz_localize(to_timezone(tz_localize))
                if tz_convert is not None:
                    v = v.tz_convert(to_timezone(tz_convert))
                v.index.freq = v.index.inferred_freq
            data[k] = v

        # Align index and columns
        data = cls.align_index(data, missing=missing_index)
        data = cls.align_columns(data, missing=missing_columns)

        # Create new instance
        symbols = list(data.keys())
        wrapper = ArrayWrapper.from_obj(data[symbols[0]], **wrapper_kwargs)
        return cls(
            wrapper,
            data,
            tz_localize=tz_localize,
            tz_convert=tz_convert,
            missing_index=missing_index,
            missing_columns=missing_columns,
            **kwargs
        )

    @classmethod
    def download_symbol(cls, symbol, **kwargs):
        &#34;&#34;&#34;Abstract method to download a symbol.&#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def download(cls, symbols, tz_localize=None, tz_convert=None, missing_index=None,
                 missing_columns=None, wrapper_kwargs=None, **kwargs):
        &#34;&#34;&#34;Download data using `Data.download_symbol`.

        Args:
            symbols (any or list of any): One or multiple symbols.

                !!! note
                    Tuple is considered as a single symbol.
            tz_localize (any): See `Data.from_data`.
            tz_convert (any): See `Data.from_data`.
            missing_index (str): See `Data.from_data`.
            missing_columns (str): See `Data.from_data`.
            wrapper_kwargs (dict): See `Data.from_data`.
            **kwargs: Passed to `Data.download_symbol`.

                If two symbols require different keyword arguments, pass `symbol_dict` for each argument.
        &#34;&#34;&#34;
        if not isinstance(symbols, list):
            symbols = [symbols]

        data = dict()
        for s in symbols:
            # Select keyword arguments for this symbol
            _kwargs = cls.select_symbol_kwargs(s, kwargs)

            # Download data for this symbol
            data[s] = cls.download_symbol(s, **_kwargs)

        # Create new instance from data
        return cls.from_data(
            data,
            tz_localize=tz_localize,
            tz_convert=tz_convert,
            missing_index=missing_index,
            missing_columns=missing_columns,
            wrapper_kwargs=wrapper_kwargs,
            download_kwargs=kwargs
        )

    def update_symbol(self, symbol, **kwargs):
        &#34;&#34;&#34;Abstract method to update a symbol.&#34;&#34;&#34;
        raise NotImplementedError

    def update(self, **kwargs):
        &#34;&#34;&#34;Update the data using `Data.update_symbol`.

        Args:
            **kwargs: Passed to `Data.update_symbol`.

                If two symbols require different keyword arguments, pass `symbol_dict` for each argument.

        !!! note
            Returns a new `Data` instance.&#34;&#34;&#34;
        new_data = dict()
        for k, v in self.data.items():
            # Select keyword arguments for this symbol
            _kwargs = self.select_symbol_kwargs(k, kwargs)

            # Download new data for this symbol
            new_obj = self.update_symbol(k, **_kwargs)

            # Convert array to pandas
            if not isinstance(new_obj, (pd.Series, pd.DataFrame)):
                new_obj = np.asarray(new_obj)
                index = pd.RangeIndex(
                    start=v.index[-1],
                    stop=v.index[-1] + new_obj.shape[0],
                    step=1
                )
                if new_obj.ndim == 1:
                    new_obj = pd.Series(new_obj, index=index)
                else:
                    new_obj = pd.DataFrame(new_obj, index=index)

            # Perform operations with datetime-like index
            if isinstance(new_obj.index, pd.DatetimeIndex):
                if self.tz_localize is not None:
                    if not is_tz_aware(new_obj.index):
                        new_obj = new_obj.tz_localize(to_timezone(self.tz_localize))
                if self.tz_convert is not None:
                    new_obj = new_obj.tz_convert(to_timezone(self.tz_convert))

            new_data[k] = new_obj

        # Align index and columns
        new_data = self.align_index(new_data, missing=self.missing_index)
        new_data = self.align_columns(new_data, missing=self.missing_columns)

        # Concatenate old and new data
        for k, v in new_data.items():
            if isinstance(self.data[k], pd.Series):
                if isinstance(v, pd.DataFrame):
                    v = v[self.data[k].name]
            else:
                v = v[self.data[k].columns]
            v = pd.concat((self.data[k], v), axis=0)
            v = v[~v.index.duplicated(keep=&#39;last&#39;)]
            if isinstance(v.index, pd.DatetimeIndex):
                v.index.freq = v.index.inferred_freq
            new_data[k] = v

        # Create new instance
        new_index = new_data[self.symbols[0]].index
        return self.copy(
            wrapper=self.wrapper.copy(index=new_index),
            data=new_data
        )

    @cached_method
    def concat(self, level_name=&#39;symbol&#39;):
        &#34;&#34;&#34;Return a dict of Series/DataFrames with symbols as columns, keyed by column name.&#34;&#34;&#34;
        first_data = self.data[self.symbols[0]]
        index = first_data.index
        if isinstance(first_data, pd.Series):
            columns = pd.Index([first_data.name])
        else:
            columns = first_data.columns
        if len(self.symbols) &gt; 1:
            new_data = {c: pd.DataFrame(
                index=index,
                columns=pd.Index(self.symbols, name=level_name)
            ) for c in columns}
        else:
            new_data = {c: pd.Series(
                index=index,
                name=self.symbols[0]
            ) for c in columns}
        for c in columns:
            for s in self.symbols:
                if isinstance(self.data[s], pd.Series):
                    col_data = self.data[s]
                else:
                    col_data = self.data[s][c]
                if len(self.symbols) &gt; 1:
                    new_data[c].loc[:, s] = col_data
                else:
                    new_data[c].loc[:] = col_data

        return new_data

    def get(self, column=None, **kwargs):
        &#34;&#34;&#34;Get column data.

        If one symbol, returns data for that symbol.
        If multiple symbols, performs concatenation first and returns a DataFrame if one column
        and a tuple of DataFrames if a list of columns passed.&#34;&#34;&#34;
        if len(self.symbols) == 1:
            if column is None:
                return self.data[self.symbols[0]]
            return self.data[self.symbols[0]][column]

        concat_data = self.concat(**kwargs)
        if len(concat_data) == 1:
            return tuple(concat_data.values())[0]
        if column is not None:
            if isinstance(column, list):
                return tuple([concat_data[c] for c in column])
            return concat_data[column]
        return tuple(concat_data.values())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.data.base.Data"><code class="flex name class">
<span>class <span class="ident parent-fname">Data</span></span>
<span>(</span><span>wrapper, data, tz_localize=None, tz_convert=None, missing_index=None, missing_columns=None, download_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that downloads, updates, and manages data coming from a data source.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Data(Wrapping):
    &#34;&#34;&#34;Class that downloads, updates, and manages data coming from a data source.&#34;&#34;&#34;

    def __init__(self, wrapper, data, tz_localize=None, tz_convert=None, missing_index=None,
                 missing_columns=None, download_kwargs=None, **kwargs):
        Wrapping.__init__(
            self,
            wrapper,
            data=data,
            tz_localize=tz_localize,
            tz_convert=tz_convert,
            missing_index=missing_index,
            missing_columns=missing_columns,
            download_kwargs=download_kwargs,
            **kwargs
        )

        checks.assert_type(data, dict)
        for k, v in data.items():
            checks.assert_meta_equal(v, data[list(data.keys())[0]])
        self._data = data
        self._tz_localize = tz_localize
        self._tz_convert = tz_convert
        self._missing_index = missing_index
        self._missing_columns = missing_columns
        self._download_kwargs = download_kwargs

    def _indexing_func(self, pd_indexing_func, **kwargs):
        &#34;&#34;&#34;Perform indexing on `Data`.&#34;&#34;&#34;
        new_wrapper = pd_indexing_func(self.wrapper, **kwargs)
        new_data = {k: pd_indexing_func(v, **kwargs) for k, v in self.data.items()}
        return self.copy(
            wrapper=new_wrapper,
            data=new_data
        )

    @property
    def data(self):
        &#34;&#34;&#34;Data dictionary keyed by symbol.&#34;&#34;&#34;
        return self._data

    @property
    def symbols(self):
        &#34;&#34;&#34;List of symbols.&#34;&#34;&#34;
        return list(self.data.keys())

    @property
    def tz_localize(self):
        &#34;&#34;&#34;`tz_localize` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._tz_localize

    @property
    def tz_convert(self):
        &#34;&#34;&#34;`tz_convert` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._tz_convert

    @property
    def missing_index(self):
        &#34;&#34;&#34;`missing_index` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._missing_index

    @property
    def missing_columns(self):
        &#34;&#34;&#34;`missing_columns` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._missing_columns

    @property
    def download_kwargs(self):
        &#34;&#34;&#34;Keyword arguments initially passed to `Data.download_symbol`.&#34;&#34;&#34;
        return self._download_kwargs

    @classmethod
    def align_index(cls, data, missing=&#39;nan&#39;):
        &#34;&#34;&#34;Align data to have the same index.

        The argument `missing` accepts the following values:

        * &#39;nan&#39;: set missing data points to NaN
        * &#39;drop&#39;: remove missing data points
        * &#39;raise&#39;: raise an error&#34;&#34;&#34;
        if len(data) == 1:
            return data

        index = None
        for k, v in data.items():
            if index is None:
                index = v.index
            else:
                if len(index.intersection(v.index)) != len(index.union(v.index)):
                    if missing == &#39;nan&#39;:
                        warnings.warn(&#34;Symbols have mismatching index. &#34;
                                      &#34;Setting missing data points to NaN.&#34;, stacklevel=2)
                        index = index.union(v.index)
                    elif missing == &#39;drop&#39;:
                        warnings.warn(&#34;Symbols have mismatching index. &#34;
                                      &#34;Dropping missing data points.&#34;, stacklevel=2)
                        index = index.intersection(v.index)
                    elif missing == &#39;raise&#39;:
                        raise ValueError(&#34;Symbols have mismatching index&#34;)
                    else:
                        raise ValueError(f&#34;missing=&#39;{missing}&#39; is not recognized&#34;)

        # reindex
        new_data = {k: v.reindex(index=index) for k, v in data.items()}
        return new_data

    @classmethod
    def align_columns(cls, data, missing=&#39;raise&#39;):
        &#34;&#34;&#34;Align data to have the same columns.

        See `Data.align_index` for `missing`.&#34;&#34;&#34;
        if len(data) == 1:
            return data

        columns = None
        multiple_columns = False
        name_is_none = False
        for k, v in data.items():
            if isinstance(v, pd.Series):
                if v.name is None:
                    name_is_none = True
                v = v.to_frame()
            else:
                multiple_columns = True
            if columns is None:
                columns = v.columns
            else:
                if len(columns.intersection(v.columns)) != len(columns.union(v.columns)):
                    if missing == &#39;nan&#39;:
                        warnings.warn(&#34;Symbols have mismatching columns. &#34;
                                      &#34;Setting missing data points to NaN.&#34;, stacklevel=2)
                        columns = columns.union(v.columns)
                    elif missing == &#39;drop&#39;:
                        warnings.warn(&#34;Symbols have mismatching columns. &#34;
                                      &#34;Dropping missing data points.&#34;, stacklevel=2)
                        columns = columns.intersection(v.columns)
                    elif missing == &#39;raise&#39;:
                        raise ValueError(&#34;Symbols have mismatching columns&#34;)
                    else:
                        raise ValueError(f&#34;missing=&#39;{missing}&#39; is not recognized&#34;)

        # reindex
        new_data = {}
        for k, v in data.items():
            if isinstance(v, pd.Series):
                v = v.to_frame(name=v.name)
            v = v.reindex(columns=columns)
            if not multiple_columns:
                v = v[columns[0]]
                if name_is_none:
                    v = v.rename(None)
            new_data[k] = v
        return new_data

    @classmethod
    def select_symbol_kwargs(cls, symbol, kwargs):
        &#34;&#34;&#34;Select keyword arguments belonging to `symbol`.&#34;&#34;&#34;
        _kwargs = dict()
        for k, v in kwargs.items():
            if isinstance(v, symbol_dict):
                if symbol in v:
                    _kwargs[k] = v[symbol]
            else:
                _kwargs[k] = v
        return _kwargs

    @classmethod
    def from_data(cls, data, tz_localize=None, tz_convert=None, missing_index=None,
                  missing_columns=None, wrapper_kwargs=None, **kwargs):
        &#34;&#34;&#34;Create a new `Data` instance from (aligned) data.

        Args:
            data (dict): Dictionary of array-like objects keyed by symbol.
            tz_localize (any): If the index is tz-naive, convert to a timezone.

                See `vectorbt.utils.datetime.to_timezone`.
            tz_convert (any): Convert the index from one timezone to another.

                See `vectorbt.utils.datetime.to_timezone`.

                Defaults to `tz_convert` in `vectorbt.settings.data`.
            missing_index (str): See `Data.align_index`.

                Defaults to `missing_index` in `vectorbt.settings.data`.
            missing_columns (str): See `Data.align_columns`.

                Defaults to `missing_columns` in `vectorbt.settings.data`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            **kwargs: Keyword arguments passed to the `__init__` method.&#34;&#34;&#34;
        from vectorbt import settings

        # Get global defaults
        if tz_localize is None:
            tz_localize = settings.data[&#39;tz_localize&#39;]
        if tz_convert is None:
            tz_convert = settings.data[&#39;tz_convert&#39;]
        if missing_index is None:
            missing_index = settings.data[&#39;missing_index&#39;]
        if missing_columns is None:
            missing_columns = settings.data[&#39;missing_columns&#39;]
        if wrapper_kwargs is None:
            wrapper_kwargs = {}

        data = data.copy()
        for k, v in data.items():
            # Convert array to pandas
            if not isinstance(v, (pd.Series, pd.DataFrame)):
                v = np.asarray(v)
                if v.ndim == 1:
                    v = pd.Series(v)
                else:
                    v = pd.DataFrame(v)

            # Perform operations with datetime-like index
            if isinstance(v.index, pd.DatetimeIndex):
                if tz_localize is not None:
                    if not is_tz_aware(v.index):
                        v = v.tz_localize(to_timezone(tz_localize))
                if tz_convert is not None:
                    v = v.tz_convert(to_timezone(tz_convert))
                v.index.freq = v.index.inferred_freq
            data[k] = v

        # Align index and columns
        data = cls.align_index(data, missing=missing_index)
        data = cls.align_columns(data, missing=missing_columns)

        # Create new instance
        symbols = list(data.keys())
        wrapper = ArrayWrapper.from_obj(data[symbols[0]], **wrapper_kwargs)
        return cls(
            wrapper,
            data,
            tz_localize=tz_localize,
            tz_convert=tz_convert,
            missing_index=missing_index,
            missing_columns=missing_columns,
            **kwargs
        )

    @classmethod
    def download_symbol(cls, symbol, **kwargs):
        &#34;&#34;&#34;Abstract method to download a symbol.&#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def download(cls, symbols, tz_localize=None, tz_convert=None, missing_index=None,
                 missing_columns=None, wrapper_kwargs=None, **kwargs):
        &#34;&#34;&#34;Download data using `Data.download_symbol`.

        Args:
            symbols (any or list of any): One or multiple symbols.

                !!! note
                    Tuple is considered as a single symbol.
            tz_localize (any): See `Data.from_data`.
            tz_convert (any): See `Data.from_data`.
            missing_index (str): See `Data.from_data`.
            missing_columns (str): See `Data.from_data`.
            wrapper_kwargs (dict): See `Data.from_data`.
            **kwargs: Passed to `Data.download_symbol`.

                If two symbols require different keyword arguments, pass `symbol_dict` for each argument.
        &#34;&#34;&#34;
        if not isinstance(symbols, list):
            symbols = [symbols]

        data = dict()
        for s in symbols:
            # Select keyword arguments for this symbol
            _kwargs = cls.select_symbol_kwargs(s, kwargs)

            # Download data for this symbol
            data[s] = cls.download_symbol(s, **_kwargs)

        # Create new instance from data
        return cls.from_data(
            data,
            tz_localize=tz_localize,
            tz_convert=tz_convert,
            missing_index=missing_index,
            missing_columns=missing_columns,
            wrapper_kwargs=wrapper_kwargs,
            download_kwargs=kwargs
        )

    def update_symbol(self, symbol, **kwargs):
        &#34;&#34;&#34;Abstract method to update a symbol.&#34;&#34;&#34;
        raise NotImplementedError

    def update(self, **kwargs):
        &#34;&#34;&#34;Update the data using `Data.update_symbol`.

        Args:
            **kwargs: Passed to `Data.update_symbol`.

                If two symbols require different keyword arguments, pass `symbol_dict` for each argument.

        !!! note
            Returns a new `Data` instance.&#34;&#34;&#34;
        new_data = dict()
        for k, v in self.data.items():
            # Select keyword arguments for this symbol
            _kwargs = self.select_symbol_kwargs(k, kwargs)

            # Download new data for this symbol
            new_obj = self.update_symbol(k, **_kwargs)

            # Convert array to pandas
            if not isinstance(new_obj, (pd.Series, pd.DataFrame)):
                new_obj = np.asarray(new_obj)
                index = pd.RangeIndex(
                    start=v.index[-1],
                    stop=v.index[-1] + new_obj.shape[0],
                    step=1
                )
                if new_obj.ndim == 1:
                    new_obj = pd.Series(new_obj, index=index)
                else:
                    new_obj = pd.DataFrame(new_obj, index=index)

            # Perform operations with datetime-like index
            if isinstance(new_obj.index, pd.DatetimeIndex):
                if self.tz_localize is not None:
                    if not is_tz_aware(new_obj.index):
                        new_obj = new_obj.tz_localize(to_timezone(self.tz_localize))
                if self.tz_convert is not None:
                    new_obj = new_obj.tz_convert(to_timezone(self.tz_convert))

            new_data[k] = new_obj

        # Align index and columns
        new_data = self.align_index(new_data, missing=self.missing_index)
        new_data = self.align_columns(new_data, missing=self.missing_columns)

        # Concatenate old and new data
        for k, v in new_data.items():
            if isinstance(self.data[k], pd.Series):
                if isinstance(v, pd.DataFrame):
                    v = v[self.data[k].name]
            else:
                v = v[self.data[k].columns]
            v = pd.concat((self.data[k], v), axis=0)
            v = v[~v.index.duplicated(keep=&#39;last&#39;)]
            if isinstance(v.index, pd.DatetimeIndex):
                v.index.freq = v.index.inferred_freq
            new_data[k] = v

        # Create new instance
        new_index = new_data[self.symbols[0]].index
        return self.copy(
            wrapper=self.wrapper.copy(index=new_index),
            data=new_data
        )

    @cached_method
    def concat(self, level_name=&#39;symbol&#39;):
        &#34;&#34;&#34;Return a dict of Series/DataFrames with symbols as columns, keyed by column name.&#34;&#34;&#34;
        first_data = self.data[self.symbols[0]]
        index = first_data.index
        if isinstance(first_data, pd.Series):
            columns = pd.Index([first_data.name])
        else:
            columns = first_data.columns
        if len(self.symbols) &gt; 1:
            new_data = {c: pd.DataFrame(
                index=index,
                columns=pd.Index(self.symbols, name=level_name)
            ) for c in columns}
        else:
            new_data = {c: pd.Series(
                index=index,
                name=self.symbols[0]
            ) for c in columns}
        for c in columns:
            for s in self.symbols:
                if isinstance(self.data[s], pd.Series):
                    col_data = self.data[s]
                else:
                    col_data = self.data[s][c]
                if len(self.symbols) &gt; 1:
                    new_data[c].loc[:, s] = col_data
                else:
                    new_data[c].loc[:] = col_data

        return new_data

    def get(self, column=None, **kwargs):
        &#34;&#34;&#34;Get column data.

        If one symbol, returns data for that symbol.
        If multiple symbols, performs concatenation first and returns a DataFrame if one column
        and a tuple of DataFrames if a list of columns passed.&#34;&#34;&#34;
        if len(self.symbols) == 1:
            if column is None:
                return self.data[self.symbols[0]]
            return self.data[self.symbols[0]][column]

        concat_data = self.concat(**kwargs)
        if len(concat_data) == 1:
            return tuple(concat_data.values())[0]
        if column is not None:
            if isinstance(column, list):
                return tuple([concat_data[c] for c in column])
            return concat_data[column]
        return tuple(concat_data.values())</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.data.custom.BinanceData" href="custom.html#vectorbt.data.custom.BinanceData">BinanceData</a></li>
<li><a title="vectorbt.data.custom.CCXTData" href="custom.html#vectorbt.data.custom.CCXTData">CCXTData</a></li>
<li><a title="vectorbt.data.custom.SyntheticData" href="custom.html#vectorbt.data.custom.SyntheticData">SyntheticData</a></li>
<li><a title="vectorbt.data.custom.YFData" href="custom.html#vectorbt.data.custom.YFData">YFData</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.data.base.Data.align_columns"><code class="name flex">
<span>def <span class="ident fname">align_columns</span></span>(<span>data, missing='raise')</span>
</code></dt>
<dd>
<div class="desc"><p>Align data to have the same columns.</p>
<p>See <code><a title="vectorbt.data.base.Data.align_index" href="#vectorbt.data.base.Data.align_index">Data.align_index()</a></code> for <code>missing</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def align_columns(cls, data, missing=&#39;raise&#39;):
    &#34;&#34;&#34;Align data to have the same columns.

    See `Data.align_index` for `missing`.&#34;&#34;&#34;
    if len(data) == 1:
        return data

    columns = None
    multiple_columns = False
    name_is_none = False
    for k, v in data.items():
        if isinstance(v, pd.Series):
            if v.name is None:
                name_is_none = True
            v = v.to_frame()
        else:
            multiple_columns = True
        if columns is None:
            columns = v.columns
        else:
            if len(columns.intersection(v.columns)) != len(columns.union(v.columns)):
                if missing == &#39;nan&#39;:
                    warnings.warn(&#34;Symbols have mismatching columns. &#34;
                                  &#34;Setting missing data points to NaN.&#34;, stacklevel=2)
                    columns = columns.union(v.columns)
                elif missing == &#39;drop&#39;:
                    warnings.warn(&#34;Symbols have mismatching columns. &#34;
                                  &#34;Dropping missing data points.&#34;, stacklevel=2)
                    columns = columns.intersection(v.columns)
                elif missing == &#39;raise&#39;:
                    raise ValueError(&#34;Symbols have mismatching columns&#34;)
                else:
                    raise ValueError(f&#34;missing=&#39;{missing}&#39; is not recognized&#34;)

    # reindex
    new_data = {}
    for k, v in data.items():
        if isinstance(v, pd.Series):
            v = v.to_frame(name=v.name)
        v = v.reindex(columns=columns)
        if not multiple_columns:
            v = v[columns[0]]
            if name_is_none:
                v = v.rename(None)
        new_data[k] = v
    return new_data</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.align_index"><code class="name flex">
<span>def <span class="ident fname">align_index</span></span>(<span>data, missing='nan')</span>
</code></dt>
<dd>
<div class="desc"><p>Align data to have the same index.</p>
<p>The argument <code>missing</code> accepts the following values:</p>
<ul>
<li>'nan': set missing data points to NaN</li>
<li>'drop': remove missing data points</li>
<li>'raise': raise an error</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def align_index(cls, data, missing=&#39;nan&#39;):
    &#34;&#34;&#34;Align data to have the same index.

    The argument `missing` accepts the following values:

    * &#39;nan&#39;: set missing data points to NaN
    * &#39;drop&#39;: remove missing data points
    * &#39;raise&#39;: raise an error&#34;&#34;&#34;
    if len(data) == 1:
        return data

    index = None
    for k, v in data.items():
        if index is None:
            index = v.index
        else:
            if len(index.intersection(v.index)) != len(index.union(v.index)):
                if missing == &#39;nan&#39;:
                    warnings.warn(&#34;Symbols have mismatching index. &#34;
                                  &#34;Setting missing data points to NaN.&#34;, stacklevel=2)
                    index = index.union(v.index)
                elif missing == &#39;drop&#39;:
                    warnings.warn(&#34;Symbols have mismatching index. &#34;
                                  &#34;Dropping missing data points.&#34;, stacklevel=2)
                    index = index.intersection(v.index)
                elif missing == &#39;raise&#39;:
                    raise ValueError(&#34;Symbols have mismatching index&#34;)
                else:
                    raise ValueError(f&#34;missing=&#39;{missing}&#39; is not recognized&#34;)

    # reindex
    new_data = {k: v.reindex(index=index) for k, v in data.items()}
    return new_data</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.download"><code class="name flex">
<span>def <span class="ident fname">download</span></span>(<span>symbols, tz_localize=None, tz_convert=None, missing_index=None, missing_columns=None, wrapper_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Download data using <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>symbols</code></strong> :&ensp;<code>any</code> or <code>list</code> of <code>any</code></dt>
<dd>
<p>One or multiple symbols.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Tuple is considered as a single symbol.</p>
</div>
</dd>
<dt><strong><code>tz_localize</code></strong> :&ensp;<code>any</code></dt>
<dd>See <code><a title="vectorbt.data.base.Data.from_data" href="#vectorbt.data.base.Data.from_data">Data.from_data()</a></code>.</dd>
<dt><strong><code>tz_convert</code></strong> :&ensp;<code>any</code></dt>
<dd>See <code><a title="vectorbt.data.base.Data.from_data" href="#vectorbt.data.base.Data.from_data">Data.from_data()</a></code>.</dd>
<dt><strong><code>missing_index</code></strong> :&ensp;<code>str</code></dt>
<dd>See <code><a title="vectorbt.data.base.Data.from_data" href="#vectorbt.data.base.Data.from_data">Data.from_data()</a></code>.</dd>
<dt><strong><code>missing_columns</code></strong> :&ensp;<code>str</code></dt>
<dd>See <code><a title="vectorbt.data.base.Data.from_data" href="#vectorbt.data.base.Data.from_data">Data.from_data()</a></code>.</dd>
<dt><strong><code>wrapper_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>See <code><a title="vectorbt.data.base.Data.from_data" href="#vectorbt.data.base.Data.from_data">Data.from_data()</a></code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>
<p>Passed to <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>.</p>
<p>If two symbols require different keyword arguments, pass <code><a title="vectorbt.data.base.symbol_dict" href="#vectorbt.data.base.symbol_dict">symbol_dict</a></code> for each argument.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def download(cls, symbols, tz_localize=None, tz_convert=None, missing_index=None,
             missing_columns=None, wrapper_kwargs=None, **kwargs):
    &#34;&#34;&#34;Download data using `Data.download_symbol`.

    Args:
        symbols (any or list of any): One or multiple symbols.

            !!! note
                Tuple is considered as a single symbol.
        tz_localize (any): See `Data.from_data`.
        tz_convert (any): See `Data.from_data`.
        missing_index (str): See `Data.from_data`.
        missing_columns (str): See `Data.from_data`.
        wrapper_kwargs (dict): See `Data.from_data`.
        **kwargs: Passed to `Data.download_symbol`.

            If two symbols require different keyword arguments, pass `symbol_dict` for each argument.
    &#34;&#34;&#34;
    if not isinstance(symbols, list):
        symbols = [symbols]

    data = dict()
    for s in symbols:
        # Select keyword arguments for this symbol
        _kwargs = cls.select_symbol_kwargs(s, kwargs)

        # Download data for this symbol
        data[s] = cls.download_symbol(s, **_kwargs)

    # Create new instance from data
    return cls.from_data(
        data,
        tz_localize=tz_localize,
        tz_convert=tz_convert,
        missing_index=missing_index,
        missing_columns=missing_columns,
        wrapper_kwargs=wrapper_kwargs,
        download_kwargs=kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.download_symbol"><code class="name flex">
<span>def <span class="ident fname">download_symbol</span></span>(<span>symbol, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract method to download a symbol.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def download_symbol(cls, symbol, **kwargs):
    &#34;&#34;&#34;Abstract method to download a symbol.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.from_data"><code class="name flex">
<span>def <span class="ident fname">from_data</span></span>(<span>data, tz_localize=None, tz_convert=None, missing_index=None, missing_columns=None, wrapper_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> instance from (aligned) data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of array-like objects keyed by symbol.</dd>
<dt><strong><code>tz_localize</code></strong> :&ensp;<code>any</code></dt>
<dd>
<p>If the index is tz-naive, convert to a timezone.</p>
<p>See <code><a title="vectorbt.utils.datetime.to_timezone" href="../utils/datetime.html#vectorbt.utils.datetime.to_timezone">to_timezone()</a></code>.</p>
</dd>
<dt><strong><code>tz_convert</code></strong> :&ensp;<code>any</code></dt>
<dd>
<p>Convert the index from one timezone to another.</p>
<p>See <code><a title="vectorbt.utils.datetime.to_timezone" href="../utils/datetime.html#vectorbt.utils.datetime.to_timezone">to_timezone()</a></code>.</p>
<p>Defaults to <code>tz_convert</code> in <code><a title="vectorbt.settings.data" href="../settings.html#vectorbt.settings.data">data</a></code>.</p>
</dd>
<dt><strong><code>missing_index</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>See <code><a title="vectorbt.data.base.Data.align_index" href="#vectorbt.data.base.Data.align_index">Data.align_index()</a></code>.</p>
<p>Defaults to <code>missing_index</code> in <code><a title="vectorbt.settings.data" href="../settings.html#vectorbt.settings.data">data</a></code>.</p>
</dd>
<dt><strong><code>missing_columns</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>See <code><a title="vectorbt.data.base.Data.align_columns" href="#vectorbt.data.base.Data.align_columns">Data.align_columns()</a></code>.</p>
<p>Defaults to <code>missing_columns</code> in <code><a title="vectorbt.settings.data" href="../settings.html#vectorbt.settings.data">data</a></code>.</p>
</dd>
<dt><strong><code>wrapper_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_data(cls, data, tz_localize=None, tz_convert=None, missing_index=None,
              missing_columns=None, wrapper_kwargs=None, **kwargs):
    &#34;&#34;&#34;Create a new `Data` instance from (aligned) data.

    Args:
        data (dict): Dictionary of array-like objects keyed by symbol.
        tz_localize (any): If the index is tz-naive, convert to a timezone.

            See `vectorbt.utils.datetime.to_timezone`.
        tz_convert (any): Convert the index from one timezone to another.

            See `vectorbt.utils.datetime.to_timezone`.

            Defaults to `tz_convert` in `vectorbt.settings.data`.
        missing_index (str): See `Data.align_index`.

            Defaults to `missing_index` in `vectorbt.settings.data`.
        missing_columns (str): See `Data.align_columns`.

            Defaults to `missing_columns` in `vectorbt.settings.data`.
        wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
        **kwargs: Keyword arguments passed to the `__init__` method.&#34;&#34;&#34;
    from vectorbt import settings

    # Get global defaults
    if tz_localize is None:
        tz_localize = settings.data[&#39;tz_localize&#39;]
    if tz_convert is None:
        tz_convert = settings.data[&#39;tz_convert&#39;]
    if missing_index is None:
        missing_index = settings.data[&#39;missing_index&#39;]
    if missing_columns is None:
        missing_columns = settings.data[&#39;missing_columns&#39;]
    if wrapper_kwargs is None:
        wrapper_kwargs = {}

    data = data.copy()
    for k, v in data.items():
        # Convert array to pandas
        if not isinstance(v, (pd.Series, pd.DataFrame)):
            v = np.asarray(v)
            if v.ndim == 1:
                v = pd.Series(v)
            else:
                v = pd.DataFrame(v)

        # Perform operations with datetime-like index
        if isinstance(v.index, pd.DatetimeIndex):
            if tz_localize is not None:
                if not is_tz_aware(v.index):
                    v = v.tz_localize(to_timezone(tz_localize))
            if tz_convert is not None:
                v = v.tz_convert(to_timezone(tz_convert))
            v.index.freq = v.index.inferred_freq
        data[k] = v

    # Align index and columns
    data = cls.align_index(data, missing=missing_index)
    data = cls.align_columns(data, missing=missing_columns)

    # Create new instance
    symbols = list(data.keys())
    wrapper = ArrayWrapper.from_obj(data[symbols[0]], **wrapper_kwargs)
    return cls(
        wrapper,
        data,
        tz_localize=tz_localize,
        tz_convert=tz_convert,
        missing_index=missing_index,
        missing_columns=missing_columns,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.select_symbol_kwargs"><code class="name flex">
<span>def <span class="ident fname">select_symbol_kwargs</span></span>(<span>symbol, kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Select keyword arguments belonging to <code>symbol</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def select_symbol_kwargs(cls, symbol, kwargs):
    &#34;&#34;&#34;Select keyword arguments belonging to `symbol`.&#34;&#34;&#34;
    _kwargs = dict()
    for k, v in kwargs.items():
        if isinstance(v, symbol_dict):
            if symbol in v:
                _kwargs[k] = v[symbol]
        else:
            _kwargs[k] = v
    return _kwargs</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.data.base.Data.data"><code class="name">var <span class="ident fname">data</span></code></dt>
<dd>
<div class="desc"><p>Data dictionary keyed by symbol.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    &#34;&#34;&#34;Data dictionary keyed by symbol.&#34;&#34;&#34;
    return self._data</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.download_kwargs"><code class="name">var <span class="ident fname">download_kwargs</span></code></dt>
<dd>
<div class="desc"><p>Keyword arguments initially passed to <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def download_kwargs(self):
    &#34;&#34;&#34;Keyword arguments initially passed to `Data.download_symbol`.&#34;&#34;&#34;
    return self._download_kwargs</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.missing_columns"><code class="name">var <span class="ident fname">missing_columns</span></code></dt>
<dd>
<div class="desc"><p><code>missing_columns</code> initially passed to <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def missing_columns(self):
    &#34;&#34;&#34;`missing_columns` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
    return self._missing_columns</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.missing_index"><code class="name">var <span class="ident fname">missing_index</span></code></dt>
<dd>
<div class="desc"><p><code>missing_index</code> initially passed to <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def missing_index(self):
    &#34;&#34;&#34;`missing_index` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
    return self._missing_index</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.symbols"><code class="name">var <span class="ident fname">symbols</span></code></dt>
<dd>
<div class="desc"><p>List of symbols.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def symbols(self):
    &#34;&#34;&#34;List of symbols.&#34;&#34;&#34;
    return list(self.data.keys())</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.tz_convert"><code class="name">var <span class="ident fname">tz_convert</span></code></dt>
<dd>
<div class="desc"><p><code>tz_convert</code> initially passed to <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tz_convert(self):
    &#34;&#34;&#34;`tz_convert` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
    return self._tz_convert</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.tz_localize"><code class="name">var <span class="ident fname">tz_localize</span></code></dt>
<dd>
<div class="desc"><p><code>tz_localize</code> initially passed to <code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">Data.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tz_localize(self):
    &#34;&#34;&#34;`tz_localize` initially passed to `Data.download_symbol`.&#34;&#34;&#34;
    return self._tz_localize</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.data.base.Data.concat"><code class="name flex">
<span>def <span class="ident fname">concat</span></span>(<span>self, level_name='symbol')</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dict of Series/DataFrames with symbols as columns, keyed by column name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def concat(self, level_name=&#39;symbol&#39;):
    &#34;&#34;&#34;Return a dict of Series/DataFrames with symbols as columns, keyed by column name.&#34;&#34;&#34;
    first_data = self.data[self.symbols[0]]
    index = first_data.index
    if isinstance(first_data, pd.Series):
        columns = pd.Index([first_data.name])
    else:
        columns = first_data.columns
    if len(self.symbols) &gt; 1:
        new_data = {c: pd.DataFrame(
            index=index,
            columns=pd.Index(self.symbols, name=level_name)
        ) for c in columns}
    else:
        new_data = {c: pd.Series(
            index=index,
            name=self.symbols[0]
        ) for c in columns}
    for c in columns:
        for s in self.symbols:
            if isinstance(self.data[s], pd.Series):
                col_data = self.data[s]
            else:
                col_data = self.data[s][c]
            if len(self.symbols) &gt; 1:
                new_data[c].loc[:, s] = col_data
            else:
                new_data[c].loc[:] = col_data

    return new_data</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.get"><code class="name flex">
<span>def <span class="ident fname">get</span></span>(<span>self, column=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get column data.</p>
<p>If one symbol, returns data for that symbol.
If multiple symbols, performs concatenation first and returns a DataFrame if one column
and a tuple of DataFrames if a list of columns passed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, column=None, **kwargs):
    &#34;&#34;&#34;Get column data.

    If one symbol, returns data for that symbol.
    If multiple symbols, performs concatenation first and returns a DataFrame if one column
    and a tuple of DataFrames if a list of columns passed.&#34;&#34;&#34;
    if len(self.symbols) == 1:
        if column is None:
            return self.data[self.symbols[0]]
        return self.data[self.symbols[0]][column]

    concat_data = self.concat(**kwargs)
    if len(concat_data) == 1:
        return tuple(concat_data.values())[0]
    if column is not None:
        if isinstance(column, list):
            return tuple([concat_data[c] for c in column])
        return concat_data[column]
    return tuple(concat_data.values())</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.update"><code class="name flex">
<span>def <span class="ident fname">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the data using <code><a title="vectorbt.data.base.Data.update_symbol" href="#vectorbt.data.base.Data.update_symbol">Data.update_symbol()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>
<p>Passed to <code><a title="vectorbt.data.base.Data.update_symbol" href="#vectorbt.data.base.Data.update_symbol">Data.update_symbol()</a></code>.</p>
<p>If two symbols require different keyword arguments, pass <code><a title="vectorbt.data.base.symbol_dict" href="#vectorbt.data.base.symbol_dict">symbol_dict</a></code> for each argument.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Returns a new <code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code> instance.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;Update the data using `Data.update_symbol`.

    Args:
        **kwargs: Passed to `Data.update_symbol`.

            If two symbols require different keyword arguments, pass `symbol_dict` for each argument.

    !!! note
        Returns a new `Data` instance.&#34;&#34;&#34;
    new_data = dict()
    for k, v in self.data.items():
        # Select keyword arguments for this symbol
        _kwargs = self.select_symbol_kwargs(k, kwargs)

        # Download new data for this symbol
        new_obj = self.update_symbol(k, **_kwargs)

        # Convert array to pandas
        if not isinstance(new_obj, (pd.Series, pd.DataFrame)):
            new_obj = np.asarray(new_obj)
            index = pd.RangeIndex(
                start=v.index[-1],
                stop=v.index[-1] + new_obj.shape[0],
                step=1
            )
            if new_obj.ndim == 1:
                new_obj = pd.Series(new_obj, index=index)
            else:
                new_obj = pd.DataFrame(new_obj, index=index)

        # Perform operations with datetime-like index
        if isinstance(new_obj.index, pd.DatetimeIndex):
            if self.tz_localize is not None:
                if not is_tz_aware(new_obj.index):
                    new_obj = new_obj.tz_localize(to_timezone(self.tz_localize))
            if self.tz_convert is not None:
                new_obj = new_obj.tz_convert(to_timezone(self.tz_convert))

        new_data[k] = new_obj

    # Align index and columns
    new_data = self.align_index(new_data, missing=self.missing_index)
    new_data = self.align_columns(new_data, missing=self.missing_columns)

    # Concatenate old and new data
    for k, v in new_data.items():
        if isinstance(self.data[k], pd.Series):
            if isinstance(v, pd.DataFrame):
                v = v[self.data[k].name]
        else:
            v = v[self.data[k].columns]
        v = pd.concat((self.data[k], v), axis=0)
        v = v[~v.index.duplicated(keep=&#39;last&#39;)]
        if isinstance(v.index, pd.DatetimeIndex):
            v.index.freq = v.index.inferred_freq
        new_data[k] = v

    # Create new instance
    new_index = new_data[self.symbols[0]].index
    return self.copy(
        wrapper=self.wrapper.copy(index=new_index),
        data=new_data
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.data.base.Data.update_symbol"><code class="name flex">
<span>def <span class="ident fname">update_symbol</span></span>(<span>self, symbol, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract method to update a symbol.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_symbol(self, symbol, **kwargs):
    &#34;&#34;&#34;Abstract method to update a symbol.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.data.base.symbol_dict"><code class="flex name class">
<span>class <span class="ident parent-fname">symbol_dict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Dict that contains symbols as keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class symbol_dict(dict):
    &#34;&#34;&#34;Dict that contains symbols as keys.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAALiAAAC4gFJuvgEAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAACiFJREFUeJztXV1zU8cZfvboyB+yzJe/BAm4SaaZNinttGlvOrnoP+hdr/ML+heaptOJKQ0kDQVTSEghbWjI0DBJmrYZOm7ChIJsDMaSjEMcaEwAk9iWLX/JOmd7gW1sWUfSPrvyVq2eK0vn7O6xHr377vvs+64EAnAPaHaBqaDrxVD3QyDyE6YlgKcBtKg3u/tVHX70zLfJQYH+Zy6hwfXvv9iBPvwATzH9/PinT54b/qzxaeohpOhygq651MdyH04T2xJAmGs2OR2ih9zSkHtABgDshh98dzDG0+748GeN3ycfY0Hmci8HEiKAVrJjCB1C6rlmE2mXHjLWlH3wogmjaMD3mH66ju4cANDAtJXA69eu9X8RSIhnixDWQjI8IR2RxQcvvoNPASibm+eJ3HsfbXucfATpytA+AChmIfSURRMSRpEnKg4dC9keXbIQF7NoA+WITr7f1ut7Ygf1AALvJBIXkkBxQmgLoX1IHTsiMDnNE9IeWSLkcfQC2Mr08fIfdjSy4/u+3Lv8d7Hv48ZbiCVCYtGlKesxxJj2ieuR6+mMS1mWAC4OJ/rOLb/+73LqOoToOvUY+uGA8gHPHuy8DUBwoztda14F3eazFuIAglpnwJqFdESywG4sMG2nMqH04CdN1KoMEsOpwYtnVr9l3EJEE+jvig4hE1MahLRlb6MRVPzw62M7LwPg5gRHvACsjXmK+RCKEBtBIcATsqneQ9NT/jUIKHfg+/DfPtvyKDUwxFgm6p7If9e4U7cRFAL8lNURzUq041tM29NnW3sXPbGTGhjypdHz5+fy3w0kRNoghJyycp7AzBwnncQ6s4DgZoP9xx9i58kZ5JzDhS4U7HAMiApSAhBRptUSSEIm0i6k5NrG2rKUxxsaaRwZnwx/l2krBY5cG7r4VaFrBS0krBMURtiWoKcsLdmkZbH0TQXw3OHOUXDLl5yT814MuliQEGvCIunUtYTFlmzpm/KQmQ1lLqeilHUI4GQq1X8z6HoQIRsfpQP8lKWx5I21qROy/8TDfVKimRlP+NhX7HpBQrSUXtaHuEFPUxpasonilCUl5Ft/bd3FjSb+lkz29he7w/yUxfoQjSWvzpTV0apmIe/0tPRlc+IRZizHwd5S9wT9J/xuIWshGkEhayFNjR6iEU+pzb7XHqLGAuSV5EDvP0rdZd6HWLAQlhBV/zEy2nDz7ngdpVsJKboAlFycFyTEZ6csBxDsroAF2UTVf/z8YOcNMJ5OyhsdbdG3yrnVqA8REfDCog0LUfAfs3POTPxqM7XUhcC+np6eXDm3BrHNCYsWonQAmCQtpEMhBjlwckefBDYRw4yH5Pyxcm8OIoTTsXSidAvSe6y1/CnrjXfbt1ODSHkgkUhkyr29ICG0sGjBQnKeQGaWExbLXfJ+8PHW/vms83ViiPkQnEMqDdYRoiUsWojS09MawmKZhHQd3akezgMQEMcSifgdlTbrCNESFm3IJhXWsT6/XX/ri3t1zG6iB8/Zr9poHSFWonSAJoRVehsbfGyKlg4Kf9G96zqIxDkI/DmVuvCJarNChPBBoaW9EAblWMd81pk71795N9O/EP4LTLt1hFhJIbUgLJbjP373ZqxXSmwjuv9nauDSv4h2hqcsC/lY/JK3NCGvnenoYPoWkCVFxCAU+l5ufBmChXysUjFIT3zLlbn5kHLinABSqcG+96mHgmkfUkUW0l7Chzx/ZOe6jJByIKXcA3D1JUABQqwIi1qyCZltUmTKunMvfPfft+uJCip5K4T5N6gHWoIxH6IlLGpZCCcTF1N6nzvcmQKlPzsvJhIJKohc6aHAe9SUpRUUaim9Zi0kuygWeuKbnyS6nMrW+0eoh1mFQoTwOb0stPZC1BvX1/nY3FxYDX/ldCwufdGm2qeU4tBIX19a+WHysI4QKxmLpIV4PicsxlqzEAHT6yunY0zcseiFnANEu3VYQ4g1YZG0kHQmBJ9YzwQtec9faR6cmQ09odqfAE5cH7gwqv4k67GGEB1hsZoqb4M2pn7Z3cnU5Uvhi6K5VipYQ4hODGKnNt1clD42Hh77dLSBUXXfTSbjCepBCiCfkKqyEHrrdtv6Kev5I7uSIBbgjuPTMknB/la/sJKxGMp/ivJB61h56T85Tyx+8PGWbxBdxZMDlz6iHiIAxqasqsrHypuyTpxpj3u+ICpwRVfpe9SQ/93c+IxFG9kmeYQc+tN2JptkZOibXztT+jY1mPMhrIVssLBYF5bYtulBUNifjA5Nz7rqJW0Cv8KpU2p5qGVgDSFawmKVTFkdLWuDwme7O79UH1mMZaLh4+rtSsOIDxGN4IXFDU4hXR2DsMcpScjfFCrYNIF8H/I/n7G4Okonj1OaETmnW3ngMmGEEBv5WAAwQUxZyyss9jglAXl0KKBg0wTWEFJNwqLvA1NECtDyCos8TikHz1fOtVLBCiHVJyy6nLC4tDFFHackxZvFCjZNYIWQsK1CT1Y2YU9uaM0iSR6nJEJcrpUKVgjROrDMQsaiToLcz7jjlP6eGui7RA2qACOEaGUsbqDS64Yk3JCkjlMSQhgVEYOwQohnY8pywWTNAuBikPaWRew//jBxnJK8kroaP6s8IAEzFqJz6CUJJgZp35oFdZySFHtQRsGmCaxe9jJ7yQDs6FjMlHXtRmSROE7pZqwtekp5MBKrLUQ502KlEwtKLxMUzi04yjYpIcsu2DSBFULoMxaFRsaijrCoUaijgHFXzr+6EQMtQ9uHiAjoHT8bpzeoQErxW5WCTRNY/VFuvI6lc76JxglAZWLBBQ5WepB8aBNi69BLdrewXAhAuWDTBFYIqTZhMZ3hf56inCHghYzlWqnAAaqvFHp6xoXnsztiZYEq2DQBB7AoLLI6VqUdunAqLiIGwQEs/RICwJdCV9Z/fDh09eL5Sg5QDNqEVNsZi6VhNhNRFQ5gSVgMgRYWKxiDDA0NXvpLpTovB/YsxNLB+0UhhFbBpgks/2dVVXlbGR8ib4X8uT9WoGMl2HPqWkqv+RhEQrykW7BpAg6gKSzaOBbWvIVMNbo57YJNE9CyENEIK8LiRFqjcQFIge7Lly9PGu2UxPLHWVXC4qRZ2WQxLIWRgk0TWCaEq023lUJq1kJeHxyMf26yQx1oEWLjwDIpjQqL0vGFNZmkENw79zMwqD0/GweWZWZDyHmmhEX5XjLZa6xg0wSc+v9j2UQIx6pMUghO1Z2xaI6QeOpq/ENTnZmCAxt1hYB9C5HYY6Yjs3DoMjbYERYNETIy9MQjb5voyDT0pqwqOtJvNSTk3koUbJqAi2oTFrUJEWMzzeHfa3ZSMej5EBvSu2aCnBD+gUoVbJqAI9kpSwBoIhOQNQj5Mh2mftV5CbPeApQOx99ouOL+xzOh2lA0QAqJEASxoRPBHYD7MfkbtxpuAYL9IahXh4d7ibr0GmqooYYaaqihhhpqqKGGGmqooYYaaqghH/8BoRM6nLZ12boAAAAASUVORK5CYII="/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul>
<li><a href="#downloading">Downloading</a></li>
<li><a href="#updating">Updating</a></li>
<li><a href="#merging">Merging</a></li>
<li><a href="#indexing">Indexing</a></li>
<li><a href="#saving-and-loading">Saving and loading</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.data" href="index.html">vectorbt.data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.data.base.Data" href="#vectorbt.data.base.Data">Data</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.data.base.Data.align_columns" href="#vectorbt.data.base.Data.align_columns">align_columns</a></code></li>
<li><code><a title="vectorbt.data.base.Data.align_index" href="#vectorbt.data.base.Data.align_index">align_index</a></code></li>
<li><code><a title="vectorbt.data.base.Data.concat" href="#vectorbt.data.base.Data.concat">concat</a></code></li>
<li><code><a title="vectorbt.data.base.Data.data" href="#vectorbt.data.base.Data.data">data</a></code></li>
<li><code><a title="vectorbt.data.base.Data.download" href="#vectorbt.data.base.Data.download">download</a></code></li>
<li><code><a title="vectorbt.data.base.Data.download_kwargs" href="#vectorbt.data.base.Data.download_kwargs">download_kwargs</a></code></li>
<li><code><a title="vectorbt.data.base.Data.download_symbol" href="#vectorbt.data.base.Data.download_symbol">download_symbol</a></code></li>
<li><code><a title="vectorbt.data.base.Data.from_data" href="#vectorbt.data.base.Data.from_data">from_data</a></code></li>
<li><code><a title="vectorbt.data.base.Data.get" href="#vectorbt.data.base.Data.get">get</a></code></li>
<li><code><a title="vectorbt.data.base.Data.missing_columns" href="#vectorbt.data.base.Data.missing_columns">missing_columns</a></code></li>
<li><code><a title="vectorbt.data.base.Data.missing_index" href="#vectorbt.data.base.Data.missing_index">missing_index</a></code></li>
<li><code><a title="vectorbt.data.base.Data.select_symbol_kwargs" href="#vectorbt.data.base.Data.select_symbol_kwargs">select_symbol_kwargs</a></code></li>
<li><code><a title="vectorbt.data.base.Data.symbols" href="#vectorbt.data.base.Data.symbols">symbols</a></code></li>
<li><code><a title="vectorbt.data.base.Data.tz_convert" href="#vectorbt.data.base.Data.tz_convert">tz_convert</a></code></li>
<li><code><a title="vectorbt.data.base.Data.tz_localize" href="#vectorbt.data.base.Data.tz_localize">tz_localize</a></code></li>
<li><code><a title="vectorbt.data.base.Data.update" href="#vectorbt.data.base.Data.update">update</a></code></li>
<li><code><a title="vectorbt.data.base.Data.update_symbol" href="#vectorbt.data.base.Data.update_symbol">update_symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.data.base.symbol_dict" href="#vectorbt.data.base.symbol_dict">symbol_dict</a></code></h4>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>