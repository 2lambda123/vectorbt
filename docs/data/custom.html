<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.data.custom API documentation</title>
<meta name="description" content="Custom data classes that subclass `vectorbt.data.base.Data`." />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#31353f}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #31353f}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #31353f;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#31353f}#sidebar{background:#3B4556}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#31353f}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#31353f">
<meta name="theme-color" content="#31353f">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.data.custom</code></h1>
</header>
<section id="section-intro">
<p>Custom data classes that subclass <code><a title="vectorbt.data.base.Data" href="base.html#vectorbt.data.base.Data">Data</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Custom data classes that subclass `vectorbt.data.base.Data`.&#34;&#34;&#34;

import numpy as np
import pandas as pd
from tqdm import tqdm
import time
import warnings
from functools import wraps

from vectorbt.utils.datetime import (
    get_utc_tz,
    get_local_tz,
    to_tzaware_datetime,
    datetime_to_ms
)
from vectorbt.utils.config import merge_dicts, get_func_kwargs
from vectorbt.data.base import Data


class SyntheticData(Data):
    &#34;&#34;&#34;`Data` for synthetically generated data.&#34;&#34;&#34;

    @classmethod
    def generate_symbol(cls, symbol, index, **kwargs):
        &#34;&#34;&#34;Abstract method to generate a symbol.&#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def download_symbol(cls, symbol, start=0, end=&#39;now&#39;, freq=None, date_range_kwargs=None, **kwargs):
        &#34;&#34;&#34;Download the symbol.

        Generates datetime index and passes it to `SyntheticData.generate_symbol` to fill
        the Series/DataFrame with generated data.&#34;&#34;&#34;
        if date_range_kwargs is None:
            date_range_kwargs = {}
        index = pd.date_range(
            start=to_tzaware_datetime(start),
            end=to_tzaware_datetime(end),
            freq=freq,
            **date_range_kwargs
        )
        if len(index) == 0:
            raise ValueError(&#34;Date range is empty&#34;)
        return cls.generate_symbol(symbol, index, **kwargs)

    def update_symbol(self, symbol, **kwargs):
        &#34;&#34;&#34;Update the symbol.

        `**kwargs` will override keyword arguments passed to `SyntheticData.download_symbol`.&#34;&#34;&#34;
        download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
        download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
        kwargs = merge_dicts(download_kwargs, kwargs)
        return self.download_symbol(symbol, **kwargs)


def generate_gbm_paths(S0, mu, sigma, T, M, I, seed=None):
    &#34;&#34;&#34;Generate using Geometric Brownian Motion (GBM).

    See https://stackoverflow.com/a/45036114/8141780.&#34;&#34;&#34;
    if seed is not None:
        np.random.seed(seed)

    dt = float(T) / M
    paths = np.zeros((M + 1, I), np.float64)
    paths[0] = S0
    for t in range(1, M + 1):
        rand = np.random.standard_normal(I)
        paths[t] = paths[t - 1] * np.exp((mu - 0.5 * sigma ** 2) * dt + sigma * np.sqrt(dt) * rand)
    return paths


class GBMData(SyntheticData):
    &#34;&#34;&#34;`SyntheticData` for data generated using Geometric Brownian Motion (GBM).

    ## Example

    See the example under `BinanceData`.

    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; gbm_data = vbt.GBMData.download(&#39;GBM&#39;, start=&#39;2 hours ago&#39;, end=&#39;now&#39;, freq=&#39;1min&#39;, seed=42)
    &gt;&gt;&gt; gbm_data.get()
    2021-03-15 17:56:59.174370+01:00    102.386605
    2021-03-15 17:57:59.174370+01:00    101.554203
    2021-03-15 17:58:59.174370+01:00    104.765771
    ...                                        ...
    2021-03-15 19:54:59.174370+01:00     51.614839
    2021-03-15 19:55:59.174370+01:00     53.525376
    2021-03-15 19:56:59.174370+01:00     55.615250
    Freq: T, Length: 121, dtype: float64

    &gt;&gt;&gt; import time
    &gt;&gt;&gt; time.sleep(60)

    &gt;&gt;&gt; gbm_data = gbm_data.update()
    &gt;&gt;&gt; gbm_data.get()
    2021-03-15 17:56:59.174370+01:00    102.386605
    2021-03-15 17:57:59.174370+01:00    101.554203
    2021-03-15 17:58:59.174370+01:00    104.765771
    ...                                        ...
    2021-03-15 19:55:59.174370+01:00     53.525376
    2021-03-15 19:56:59.174370+01:00     51.082220
    2021-03-15 19:57:59.174370+01:00     54.725304
    Freq: T, Length: 122, dtype: float64
    ```&#34;&#34;&#34;

    @classmethod
    def generate_symbol(cls, symbol, index, S0=100., mu=0., sigma=0.05, T=None, I=1, seed=None):
        &#34;&#34;&#34;Generate the symbol using `generate_gbm_paths`.

        Args:
            symbol (str): Symbol.
            index (pd.Index): Pandas index.
            S0 (float): Value at time 0.

                Does not appear as the first value in the output data.
            mu (float): Drift, or mean of the percentage change.
            sigma (float): Standard deviation of the percentage change.
            T (int): Number of time steps.

                Defaults to the length of `index`.
            I (int): Number of generated paths (columns in our case).
            seed (int): Set seed to make the results deterministic.
        &#34;&#34;&#34;
        if T is None:
            T = len(index)
        out = generate_gbm_paths(S0, mu, sigma, T, len(index), I, seed=seed)[1:]
        if out.shape[1] == 1:
            return pd.Series(out[:, 0], index=index)
        columns = pd.RangeIndex(stop=out.shape[1], name=&#39;path&#39;)
        return pd.DataFrame(out, index=index, columns=columns)

    def update_symbol(self, symbol, **kwargs):
        &#34;&#34;&#34;Update the symbol.

        `**kwargs` will override keyword arguments passed to `GBMData.download_symbol`.&#34;&#34;&#34;
        download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
        download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
        _ = download_kwargs.pop(&#39;S0&#39;, None)
        S0 = self.data[symbol].iloc[-2]
        _ = download_kwargs.pop(&#39;T&#39;, None)
        download_kwargs[&#39;seed&#39;] = None
        kwargs = merge_dicts(download_kwargs, kwargs)
        return self.download_symbol(symbol, S0=S0, **kwargs)


class YFData(Data):
    &#34;&#34;&#34;`Data` for data coming from `yfinance`.

    !!! note
        Sometimes `yfinance` returns a tz-naive datetime index. To produce a
        tz-aware datetime index, pass `tz_localize` to `YFData.download`. In this case,
        you would need to find a timezone that fits the data (+0500, +0000, etc.)

    ## Example

    Fetch the business day except the last 5 minutes of trading data, and then update with the missing 5 minutes:

    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; yf_data = vbt.YFData.download(
    ...     &#34;TSLA&#34;,
    ...     start=&#39;2021-03-12 09:30:00 -0500&#39;,
    ...     end=&#39;2021-03-12 15:55:00 -0500&#39;,
    ...     interval=&#39;1m&#39;
    ... )
    &gt;&gt;&gt; yf_data.get()
                                     Open        High         Low       Close  \\
    Datetime
    2021-03-12 09:30:00-05:00  670.000000  674.455811  667.510010  673.445007
    2021-03-12 09:31:00-05:00  673.424988  674.455811  668.099976  669.599976
    2021-03-12 09:32:00-05:00  669.270020  673.000000  668.239990  670.929993
    ...                               ...         ...         ...         ...
    2021-03-12 15:52:00-05:00  690.630005  691.030029  690.380005  690.929993
    2021-03-12 15:53:00-05:00  690.989990  692.200012  690.960022  692.039978
    2021-03-12 15:54:00-05:00  692.000000  692.783875  691.929993  692.479980

                               Volume  Dividends  Stock Splits
    Datetime
    2021-03-12 09:30:00-05:00       0          0             0
    2021-03-12 09:31:00-05:00  198906          0             0
    2021-03-12 09:32:00-05:00  202002          0             0
    ...                           ...        ...           ...
    2021-03-12 15:52:00-05:00   97941          0             0
    2021-03-12 15:53:00-05:00  155552          0             0
    2021-03-12 15:54:00-05:00  110320          0             0

    [382 rows x 7 columns]

    &gt;&gt;&gt; yf_data = yf_data.update(end=&#39;2021-03-12 16:00:00 -0500&#39;)
    &gt;&gt;&gt; yf_data.get()
                                     Open        High         Low       Close  \\
    Datetime
    2021-03-12 09:30:00-05:00  670.000000  674.455811  667.510010  673.445007
    2021-03-12 09:31:00-05:00  673.424988  674.455811  668.099976  669.599976
    2021-03-12 09:32:00-05:00  669.270020  673.000000  668.239990  670.929993
    ...                               ...         ...         ...         ...
    2021-03-12 15:57:00-05:00  693.239990  693.599976  693.039978  693.250000
    2021-03-12 15:58:00-05:00  693.255005  693.419983  692.640015  692.950012
    2021-03-12 15:59:00-05:00  692.909973  694.099976  692.570007  693.840027

                               Volume  Dividends  Stock Splits
    Datetime
    2021-03-12 09:30:00-05:00       0          0             0
    2021-03-12 09:31:00-05:00  198906          0             0
    2021-03-12 09:32:00-05:00  202002          0             0
    ...                           ...        ...           ...
    2021-03-12 15:57:00-05:00  136808          0             0
    2021-03-12 15:58:00-05:00  104432          0             0
    2021-03-12 15:59:00-05:00  192474          0             0

    [387 rows x 7 columns]
    ```
    &#34;&#34;&#34;

    @classmethod
    def download_symbol(cls, symbol, period=&#39;max&#39;, start=None, end=None, **kwargs):
        &#34;&#34;&#34;Download the symbol.

        Args:
            symbol (str): Symbol.
            start (any): Start datetime.

                See `vectorbt.utils.datetime.to_tzaware_datetime`.
            end (any): End datetime.

                See `vectorbt.utils.datetime.to_tzaware_datetime`.
            **kwargs: Keyword arguments passed to `yfinance.base.TickerBase.history`.
        &#34;&#34;&#34;
        import yfinance as yf

        # yfinance still uses mktime, which assumes that the passed date is in local time
        if start is not None:
            start = to_tzaware_datetime(start, tz=get_local_tz())
        if end is not None:
            end = to_tzaware_datetime(end, tz=get_local_tz())

        return yf.Ticker(symbol).history(period=period, start=start, end=end, **kwargs)

    def update_symbol(self, symbol, **kwargs):
        &#34;&#34;&#34;Update the symbol.

        `**kwargs` will override keyword arguments passed to `YFData.download_symbol`.&#34;&#34;&#34;
        download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
        download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
        kwargs = merge_dicts(download_kwargs, kwargs)
        return self.download_symbol(symbol, **kwargs)


class BinanceData(Data):
    &#34;&#34;&#34;`Data` for data coming from `python-binance`.

    ## Example

    Fetch the 1-minute data of the last 2 hours, wait 1 minute, and update:

    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; binance_data = vbt.BinanceData.download(
    ...     &#34;BTCUSDT&#34;,
    ...     start=&#39;2 hours ago UTC&#39;,
    ...     end=&#39;now UTC&#39;,
    ...     interval=&#39;1m&#39;
    ... )
    &gt;&gt;&gt; binance_data.get()
    2021-03-22 21:39:22.067000+00:00 - 2021-03-22 23:39:00+00:00: : 1it [00:00,  3.80it/s]

                                   Open      High       Low     Close     Volume  \\
    Open time
    2021-03-22 21:40:00+00:00  54676.30  54691.41  54532.77  54549.49  35.566780
    2021-03-22 21:41:00+00:00  54547.36  54593.96  54543.23  54589.81  32.813574
    2021-03-22 21:42:00+00:00  54589.81  54655.85  54585.57  54650.04  19.616003
    ...                             ...       ...       ...       ...        ...
    2021-03-22 23:37:00+00:00  54443.83  54568.80  54403.49  54511.87  26.505448
    2021-03-22 23:38:00+00:00  54511.86  54511.86  54388.00  54406.59  24.879893
    2021-03-22 23:39:00+00:00  54411.55  54430.74  54386.70  54430.73   4.010454

                                                    Close time  Quote volume  \\
    Open time
    2021-03-22 21:40:00+00:00 2021-03-22 21:40:59.999000+00:00  1.943891e+06
    2021-03-22 21:41:00+00:00 2021-03-22 21:41:59.999000+00:00  1.790163e+06
    2021-03-22 21:42:00+00:00 2021-03-22 21:42:59.999000+00:00  1.071824e+06
    ...                                                    ...           ...
    2021-03-22 23:37:00+00:00 2021-03-22 23:37:59.999000+00:00  1.444602e+06
    2021-03-22 23:38:00+00:00 2021-03-22 23:38:59.999000+00:00  1.354316e+06
    2021-03-22 23:39:00+00:00 2021-03-22 23:39:59.999000+00:00  2.182080e+05

                               Number of trades  Taker base volume  \\
    Open time
    2021-03-22 21:40:00+00:00              1544          15.160921
    2021-03-22 21:41:00+00:00              1638          15.132376
    2021-03-22 21:42:00+00:00              1022          10.442487
    ...                                     ...                ...
    2021-03-22 23:37:00+00:00               795          13.412746
    2021-03-22 23:38:00+00:00               815          10.808586
    2021-03-22 23:39:00+00:00               209           2.312393

                               Taker quote volume
    Open time
    2021-03-22 21:40:00+00:00        8.288645e+05
    2021-03-22 21:41:00+00:00        8.256025e+05
    2021-03-22 21:42:00+00:00        5.706188e+05
    ...                                       ...
    2021-03-22 23:37:00+00:00        7.310994e+05
    2021-03-22 23:38:00+00:00        5.883322e+05
    2021-03-22 23:39:00+00:00        1.258189e+05

    [120 rows x 10 columns]

    &gt;&gt;&gt; import time
    &gt;&gt;&gt; time.sleep(60)

    &gt;&gt;&gt; binance_data = binance_data.update()
    &gt;&gt;&gt; binance_data.get()
                                   Open      High       Low     Close     Volume  \\
    Open time
    2021-03-22 21:40:00+00:00  54676.30  54691.41  54532.77  54549.49  35.566780
    2021-03-22 21:41:00+00:00  54547.36  54593.96  54543.23  54589.81  32.813574
    2021-03-22 21:42:00+00:00  54589.81  54655.85  54585.57  54650.04  19.616003
    ...                             ...       ...       ...       ...        ...
    2021-03-22 23:38:00+00:00  54511.86  54511.86  54388.00  54406.59  24.879893
    2021-03-22 23:39:00+00:00  54411.55  54499.49  54386.70  54460.91  21.214675
    2021-03-22 23:40:00+00:00  54460.90  54571.00  54458.12  54570.99  11.484854

                                                    Close time  Quote volume  \\
    Open time
    2021-03-22 21:40:00+00:00 2021-03-22 21:40:59.999000+00:00  1.943891e+06
    2021-03-22 21:41:00+00:00 2021-03-22 21:41:59.999000+00:00  1.790163e+06
    2021-03-22 21:42:00+00:00 2021-03-22 21:42:59.999000+00:00  1.071824e+06
    ...                                                    ...           ...
    2021-03-22 23:38:00+00:00 2021-03-22 23:38:59.999000+00:00  1.354316e+06
    2021-03-22 23:39:00+00:00 2021-03-22 23:39:59.999000+00:00  1.155268e+06
    2021-03-22 23:40:00+00:00 2021-03-22 23:40:59.999000+00:00  6.262655e+05

                               Number of trades  Taker base volume  \\
    Open time
    2021-03-22 21:40:00+00:00              1544          15.160921
    2021-03-22 21:41:00+00:00              1638          15.132376
    2021-03-22 21:42:00+00:00              1022          10.442487
    ...                                     ...                ...
    2021-03-22 23:38:00+00:00               815          10.808586
    2021-03-22 23:39:00+00:00               693          10.565621
    2021-03-22 23:40:00+00:00               448           6.107031

                               Taker quote volume
    Open time
    2021-03-22 21:40:00+00:00        8.288645e+05
    2021-03-22 21:41:00+00:00        8.256025e+05
    2021-03-22 21:42:00+00:00        5.706188e+05
    ...                                       ...
    2021-03-22 23:38:00+00:00        5.883322e+05
    2021-03-22 23:39:00+00:00        5.753598e+05
    2021-03-22 23:40:00+00:00        3.330209e+05

    [121 rows x 10 columns]
    ```&#34;&#34;&#34;

    @classmethod
    def download(cls, symbols, client=None, **kwargs):
        &#34;&#34;&#34;Override `vectorbt.data.base.Data.download` to instantiate a Binance client.&#34;&#34;&#34;
        from binance.client import Client
        from vectorbt import settings

        client_kwargs = dict()
        for k in get_func_kwargs(Client):
            if k in kwargs:
                client_kwargs[k] = kwargs.pop(k)
        client_kwargs = merge_dicts(settings.data[&#39;binance&#39;], client_kwargs)
        if client is None:
            client = Client(**client_kwargs)
        return super(BinanceData, cls).download(symbols, client=client, **kwargs)

    @classmethod
    def download_symbol(cls, symbol, client=None, interval=None, start=0, end=&#39;now UTC&#39;,
                        delay=500, limit=500, show_progress=True):
        &#34;&#34;&#34;Download the symbol.

        Args:
            symbol (str): Symbol.
            client (binance.client.Client): Binance client of type `binance.client.Client`.

                Overrides `binance` settings defined in `vectorbt.settings.data`.
            interval (str): Kline interval.

                See `binance.enums`.
            start (any): Start datetime.

                See `vectorbt.utils.datetime.to_tzaware_datetime`.
            end (any): End datetime.

                See `vectorbt.utils.datetime.to_tzaware_datetime`.
            delay (int or float): Time to sleep after each request (in milliseconds).
            limit (int): The maximum number of returned items.
            show_progress (bool): Whether to show the progress bar.
        &#34;&#34;&#34;
        if client is None:
            raise ValueError(&#34;client must be provided&#34;)

        # Establish the timestamps
        start_ts = datetime_to_ms(to_tzaware_datetime(start, tz=get_utc_tz()))
        try:
            first_data = client.get_klines(
                symbol=symbol,
                interval=interval,
                limit=1,
                startTime=0,
                endTime=None
            )
            first_valid_ts = first_data[0][0]
            next_start_ts = start_ts = max(start_ts, first_valid_ts)
        except:
            next_start_ts = start_ts
        end_ts = datetime_to_ms(to_tzaware_datetime(end, tz=get_utc_tz()))

        def _ts_to_str(ts):
            return str(pd.Timestamp(to_tzaware_datetime(ts, tz=get_utc_tz())))

        # Iteratively collect the data
        data = []
        with tqdm(disable=not show_progress) as pbar:
            pbar.set_description(_ts_to_str(start_ts))
            while True:
                # Fetch the klines for the next interval
                next_data = client.get_klines(
                    symbol=symbol,
                    interval=interval,
                    limit=limit,
                    startTime=next_start_ts,
                    endTime=end_ts
                )
                if len(data) &gt; 0:
                    next_data = list(filter(lambda d: next_start_ts &lt; d[0] &lt; end_ts, next_data))
                else:
                    next_data = list(filter(lambda d: d[0] &lt; end_ts, next_data))

                # Update the timestamps and the progress bar
                if not len(next_data):
                    break
                data += next_data
                pbar.set_description(&#34;{} - {}&#34;.format(
                    _ts_to_str(start_ts),
                    _ts_to_str(next_data[-1][0])
                ))
                pbar.update(1)
                next_start_ts = next_data[-1][0]
                if delay is not None:
                    time.sleep(delay / 1000)  # be kind to api

        # Convert data to a DataFrame
        df = pd.DataFrame(data, columns=[
            &#39;Open time&#39;,
            &#39;Open&#39;,
            &#39;High&#39;,
            &#39;Low&#39;,
            &#39;Close&#39;,
            &#39;Volume&#39;,
            &#39;Close time&#39;,
            &#39;Quote volume&#39;,
            &#39;Number of trades&#39;,
            &#39;Taker base volume&#39;,
            &#39;Taker quote volume&#39;,
            &#39;Ignore&#39;
        ])
        df.index = pd.to_datetime(df[&#39;Open time&#39;], unit=&#39;ms&#39;, utc=True)
        del df[&#39;Open time&#39;]
        df[&#39;Open&#39;] = df[&#39;Open&#39;].astype(float)
        df[&#39;High&#39;] = df[&#39;High&#39;].astype(float)
        df[&#39;Low&#39;] = df[&#39;Low&#39;].astype(float)
        df[&#39;Close&#39;] = df[&#39;Close&#39;].astype(float)
        df[&#39;Volume&#39;] = df[&#39;Volume&#39;].astype(float)
        df[&#39;Close time&#39;] = pd.to_datetime(df[&#39;Close time&#39;], unit=&#39;ms&#39;, utc=True)
        df[&#39;Quote volume&#39;] = df[&#39;Quote volume&#39;].astype(float)
        df[&#39;Number of trades&#39;] = df[&#39;Number of trades&#39;].astype(int)
        df[&#39;Taker base volume&#39;] = df[&#39;Taker base volume&#39;].astype(float)
        df[&#39;Taker quote volume&#39;] = df[&#39;Taker quote volume&#39;].astype(float)
        del df[&#39;Ignore&#39;]

        return df

    def update_symbol(self, symbol, **kwargs):
        &#34;&#34;&#34;Update the symbol.

        `**kwargs` will override keyword arguments passed to `BinanceData.download_symbol`.&#34;&#34;&#34;
        download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
        download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
        download_kwargs[&#39;show_progress&#39;] = False
        kwargs = merge_dicts(download_kwargs, kwargs)
        return self.download_symbol(symbol, **kwargs)


class CCXTData(Data):
    &#34;&#34;&#34;`Data` for data coming from `ccxt`.

    ## Example

    Fetch the 1-minute data of the last 2 hours, wait 1 minute, and update:

    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; ccxt_data = vbt.CCXTData.download(
    ...     &#34;BTC/USDT&#34;,
    ...     start=&#39;2 hours ago UTC&#39;,
    ...     end=&#39;now UTC&#39;,
    ...     timeframe=&#39;1m&#39;
    ... )
    &gt;&gt;&gt; ccxt_data.get()
    2021-03-22 21:08:45.826000+00:00 - 2021-03-22 23:08:00+00:00: : 1it [00:00,  1.96it/s]

                                   Open      High       Low     Close      Volume
    Open time
    2021-03-22 21:09:00+00:00  54840.01  54843.01  54752.86  54819.23   34.311598
    2021-03-22 21:10:00+00:00  54819.23  54868.27  54818.05  54857.81   33.024841
    2021-03-22 21:11:00+00:00  54853.90  54917.13  54848.26  54915.80   30.612839
    ...                             ...       ...       ...       ...         ...
    2021-03-22 23:06:00+00:00  54802.16  54871.14  54802.16  54850.00   67.792298
    2021-03-22 23:07:00+00:00  54850.00  54856.23  54771.89  54816.47   63.103731
    2021-03-22 23:08:00+00:00  54816.45  54826.41  54733.86  54765.74   48.825476

    [120 rows x 5 columns]

    &gt;&gt;&gt; import time
    &gt;&gt;&gt; time.sleep(60)

    &gt;&gt;&gt; ccxt_data = ccxt_data.update()
    &gt;&gt;&gt; ccxt_data.get()
                                   Open      High       Low     Close      Volume
    Open time
    2021-03-22 21:09:00+00:00  54840.01  54843.01  54752.86  54819.23   34.311598
    2021-03-22 21:10:00+00:00  54819.23  54868.27  54818.05  54857.81   33.024841
    2021-03-22 21:11:00+00:00  54853.90  54917.13  54848.26  54915.80   30.612839
    ...                             ...       ...       ...       ...         ...
    2021-03-22 23:07:00+00:00  54850.00  54856.23  54771.89  54816.47   63.103731
    2021-03-22 23:08:00+00:00  54816.45  54826.41  54733.86  54777.12   74.730137
    2021-03-22 23:09:00+00:00  54777.12  54869.48  54770.55  54827.52   45.687450

    [121 rows x 5 columns]
    ```&#34;&#34;&#34;

    @classmethod
    def download_symbol(cls, symbol, exchange=&#39;binance&#39;, config=None, timeframe=&#39;1d&#39;, start=0,
                        end=&#39;now UTC&#39;, delay=None, limit=500, retries=3, show_progress=True, params=None):
        &#34;&#34;&#34;Download the symbol.

        Args:
            symbol (str): Symbol.
            exchange (str or object): Exchange identifier or an exchange object of type
                `ccxt.base.exchange.Exchange`.
            config (dict): Config passed to the exchange upon instantiation.

                Overrides settings under `ccxt` in `vectorbt.settings.data`.

                Will raise an exception if exchange has been already instantiated.
            timeframe (str): Timeframe supported by the exchange.
            start (any): Start datetime.

                See `vectorbt.utils.datetime.to_tzaware_datetime`.
            end (any): End datetime.

                See `vectorbt.utils.datetime.to_tzaware_datetime`.
            delay (int or float): Time to sleep after each request (in milliseconds).

                !!! note
                    Use only if `enableRateLimit` is not set.
            limit (int): The maximum number of returned items.
            retries (int): The number of retries on failure to fetch data.
            show_progress (bool): Whether to show the progress bar.
            params (dict): Exchange-specific key-value parameters.
        &#34;&#34;&#34;
        import ccxt
        from vectorbt import settings

        if config is None:
            config = {}
        if params is None:
            params = {}
        if isinstance(exchange, str):
            if not hasattr(ccxt, exchange):
                raise ValueError(f&#34;Exchange {exchange} not found&#34;)
            # Resolve config
            default_config = {}
            for k, v in settings.data[&#39;ccxt&#39;].items():
                # Get general (not per exchange) settings
                if k in ccxt.exchanges:
                    continue
                default_config[k] = v
            if exchange in settings.data[&#39;ccxt&#39;]:
                default_config = merge_dicts(default_config, settings.data[&#39;ccxt&#39;][exchange])
            config = merge_dicts(default_config, config)
            exchange = getattr(ccxt, exchange)(config)
        else:
            if len(config) &gt; 0:
                raise ValueError(&#34;Cannot apply config after instantiation of the exchange&#34;)
        if not exchange.has[&#39;fetchOHLCV&#39;]:
            raise ValueError(f&#34;Exchange {exchange} does not support OHLCV&#34;)
        if timeframe not in exchange.timeframes:
            raise ValueError(f&#34;Exchange {exchange} does not support {timeframe} timeframe&#34;)
        if exchange.has[&#39;fetchOHLCV&#39;] == &#39;emulated&#39;:
            warnings.warn(&#34;Using emulated OHLCV candles&#34;, stacklevel=2)

        def _retry(method):
            @wraps(method)
            def retry_method(*args, **kwargs):
                for i in range(retries):
                    try:
                        return method(*args, **kwargs)
                    except (ccxt.NetworkError, ccxt.ExchangeError) as e:
                        if i == retries - 1:
                            raise e
                    if delay is not None:
                        time.sleep(delay / 1000)

            return retry_method

        @_retry
        def _fetch(_since, _limit):
            return exchange.fetch_ohlcv(
                symbol,
                timeframe=timeframe,
                since=_since,
                limit=_limit,
                params=params
            )

        # Establish the timestamps
        start_ts = datetime_to_ms(to_tzaware_datetime(start, tz=get_utc_tz()))
        try:
            first_data = _fetch(0, 1)
            first_valid_ts = first_data[0][0]
            next_start_ts = start_ts = max(start_ts, first_valid_ts)
        except:
            next_start_ts = start_ts
        end_ts = datetime_to_ms(to_tzaware_datetime(end, tz=get_utc_tz()))

        def _ts_to_str(ts):
            return str(pd.Timestamp(to_tzaware_datetime(ts, tz=get_utc_tz())))

        # Iteratively collect the data
        data = []
        with tqdm(disable=not show_progress) as pbar:
            pbar.set_description(_ts_to_str(start_ts))
            while True:
                # Fetch the klines for the next interval
                next_data = _fetch(next_start_ts, limit)
                if len(data) &gt; 0:
                    next_data = list(filter(lambda d: next_start_ts &lt; d[0] &lt; end_ts, next_data))
                else:
                    next_data = list(filter(lambda d: d[0] &lt; end_ts, next_data))

                # Update the timestamps and the progress bar
                if not len(next_data):
                    break
                data += next_data
                pbar.set_description(&#34;{} - {}&#34;.format(
                    _ts_to_str(start_ts),
                    _ts_to_str(next_data[-1][0])
                ))
                pbar.update(1)
                next_start_ts = next_data[-1][0]
                if delay is not None:
                    time.sleep(delay / 1000)  # be kind to api

        # Convert data to a DataFrame
        df = pd.DataFrame(data, columns=[
            &#39;Open time&#39;,
            &#39;Open&#39;,
            &#39;High&#39;,
            &#39;Low&#39;,
            &#39;Close&#39;,
            &#39;Volume&#39;
        ])
        df.index = pd.to_datetime(df[&#39;Open time&#39;], unit=&#39;ms&#39;, utc=True)
        del df[&#39;Open time&#39;]
        df[&#39;Open&#39;] = df[&#39;Open&#39;].astype(float)
        df[&#39;High&#39;] = df[&#39;High&#39;].astype(float)
        df[&#39;Low&#39;] = df[&#39;Low&#39;].astype(float)
        df[&#39;Close&#39;] = df[&#39;Close&#39;].astype(float)
        df[&#39;Volume&#39;] = df[&#39;Volume&#39;].astype(float)

        return df

    def update_symbol(self, symbol, **kwargs):
        &#34;&#34;&#34;Update the symbol.

        `**kwargs` will override keyword arguments passed to `CCXTData.download_symbol`.&#34;&#34;&#34;
        download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
        download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
        download_kwargs[&#39;show_progress&#39;] = False
        kwargs = merge_dicts(download_kwargs, kwargs)
        return self.download_symbol(symbol, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.data.custom.generate_gbm_paths"><code class="name flex">
<span>def <span class="ident fname">generate_gbm_paths</span></span>(<span>S0, mu, sigma, T, M, I, seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate using Geometric Brownian Motion (GBM).</p>
<p>See <a href="https://stackoverflow.com/a/45036114/8141780.">https://stackoverflow.com/a/45036114/8141780.</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_gbm_paths(S0, mu, sigma, T, M, I, seed=None):
    &#34;&#34;&#34;Generate using Geometric Brownian Motion (GBM).

    See https://stackoverflow.com/a/45036114/8141780.&#34;&#34;&#34;
    if seed is not None:
        np.random.seed(seed)

    dt = float(T) / M
    paths = np.zeros((M + 1, I), np.float64)
    paths[0] = S0
    for t in range(1, M + 1):
        rand = np.random.standard_normal(I)
        paths[t] = paths[t - 1] * np.exp((mu - 0.5 * sigma ** 2) * dt + sigma * np.sqrt(dt) * rand)
    return paths</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.data.custom.BinanceData"><code class="flex name class">
<span>class <span class="ident parent-fname">BinanceData</span></span>
<span>(</span><span>wrapper, data, tz_localize=None, tz_convert=None, missing_index=None, missing_columns=None, download_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><code>Data</code> for data coming from <code>python-binance</code>.</p>
<h2 id="example">Example</h2>
<p>Fetch the 1-minute data of the last 2 hours, wait 1 minute, and update:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; binance_data = vbt.BinanceData.download(
...     &quot;BTCUSDT&quot;,
...     start='2 hours ago UTC',
...     end='now UTC',
...     interval='1m'
... )
&gt;&gt;&gt; binance_data.get()
2021-03-22 21:39:22.067000+00:00 - 2021-03-22 23:39:00+00:00: : 1it [00:00,  3.80it/s]

                               Open      High       Low     Close     Volume  \
Open time
2021-03-22 21:40:00+00:00  54676.30  54691.41  54532.77  54549.49  35.566780
2021-03-22 21:41:00+00:00  54547.36  54593.96  54543.23  54589.81  32.813574
2021-03-22 21:42:00+00:00  54589.81  54655.85  54585.57  54650.04  19.616003
...                             ...       ...       ...       ...        ...
2021-03-22 23:37:00+00:00  54443.83  54568.80  54403.49  54511.87  26.505448
2021-03-22 23:38:00+00:00  54511.86  54511.86  54388.00  54406.59  24.879893
2021-03-22 23:39:00+00:00  54411.55  54430.74  54386.70  54430.73   4.010454

                                                Close time  Quote volume  \
Open time
2021-03-22 21:40:00+00:00 2021-03-22 21:40:59.999000+00:00  1.943891e+06
2021-03-22 21:41:00+00:00 2021-03-22 21:41:59.999000+00:00  1.790163e+06
2021-03-22 21:42:00+00:00 2021-03-22 21:42:59.999000+00:00  1.071824e+06
...                                                    ...           ...
2021-03-22 23:37:00+00:00 2021-03-22 23:37:59.999000+00:00  1.444602e+06
2021-03-22 23:38:00+00:00 2021-03-22 23:38:59.999000+00:00  1.354316e+06
2021-03-22 23:39:00+00:00 2021-03-22 23:39:59.999000+00:00  2.182080e+05

                           Number of trades  Taker base volume  \
Open time
2021-03-22 21:40:00+00:00              1544          15.160921
2021-03-22 21:41:00+00:00              1638          15.132376
2021-03-22 21:42:00+00:00              1022          10.442487
...                                     ...                ...
2021-03-22 23:37:00+00:00               795          13.412746
2021-03-22 23:38:00+00:00               815          10.808586
2021-03-22 23:39:00+00:00               209           2.312393

                           Taker quote volume
Open time
2021-03-22 21:40:00+00:00        8.288645e+05
2021-03-22 21:41:00+00:00        8.256025e+05
2021-03-22 21:42:00+00:00        5.706188e+05
...                                       ...
2021-03-22 23:37:00+00:00        7.310994e+05
2021-03-22 23:38:00+00:00        5.883322e+05
2021-03-22 23:39:00+00:00        1.258189e+05

[120 rows x 10 columns]

&gt;&gt;&gt; import time
&gt;&gt;&gt; time.sleep(60)

&gt;&gt;&gt; binance_data = binance_data.update()
&gt;&gt;&gt; binance_data.get()
                               Open      High       Low     Close     Volume  \
Open time
2021-03-22 21:40:00+00:00  54676.30  54691.41  54532.77  54549.49  35.566780
2021-03-22 21:41:00+00:00  54547.36  54593.96  54543.23  54589.81  32.813574
2021-03-22 21:42:00+00:00  54589.81  54655.85  54585.57  54650.04  19.616003
...                             ...       ...       ...       ...        ...
2021-03-22 23:38:00+00:00  54511.86  54511.86  54388.00  54406.59  24.879893
2021-03-22 23:39:00+00:00  54411.55  54499.49  54386.70  54460.91  21.214675
2021-03-22 23:40:00+00:00  54460.90  54571.00  54458.12  54570.99  11.484854

                                                Close time  Quote volume  \
Open time
2021-03-22 21:40:00+00:00 2021-03-22 21:40:59.999000+00:00  1.943891e+06
2021-03-22 21:41:00+00:00 2021-03-22 21:41:59.999000+00:00  1.790163e+06
2021-03-22 21:42:00+00:00 2021-03-22 21:42:59.999000+00:00  1.071824e+06
...                                                    ...           ...
2021-03-22 23:38:00+00:00 2021-03-22 23:38:59.999000+00:00  1.354316e+06
2021-03-22 23:39:00+00:00 2021-03-22 23:39:59.999000+00:00  1.155268e+06
2021-03-22 23:40:00+00:00 2021-03-22 23:40:59.999000+00:00  6.262655e+05

                           Number of trades  Taker base volume  \
Open time
2021-03-22 21:40:00+00:00              1544          15.160921
2021-03-22 21:41:00+00:00              1638          15.132376
2021-03-22 21:42:00+00:00              1022          10.442487
...                                     ...                ...
2021-03-22 23:38:00+00:00               815          10.808586
2021-03-22 23:39:00+00:00               693          10.565621
2021-03-22 23:40:00+00:00               448           6.107031

                           Taker quote volume
Open time
2021-03-22 21:40:00+00:00        8.288645e+05
2021-03-22 21:41:00+00:00        8.256025e+05
2021-03-22 21:42:00+00:00        5.706188e+05
...                                       ...
2021-03-22 23:38:00+00:00        5.883322e+05
2021-03-22 23:39:00+00:00        5.753598e+05
2021-03-22 23:40:00+00:00        3.330209e+05

[121 rows x 10 columns]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinanceData(Data):
    &#34;&#34;&#34;`Data` for data coming from `python-binance`.

    ## Example

    Fetch the 1-minute data of the last 2 hours, wait 1 minute, and update:

    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; binance_data = vbt.BinanceData.download(
    ...     &#34;BTCUSDT&#34;,
    ...     start=&#39;2 hours ago UTC&#39;,
    ...     end=&#39;now UTC&#39;,
    ...     interval=&#39;1m&#39;
    ... )
    &gt;&gt;&gt; binance_data.get()
    2021-03-22 21:39:22.067000+00:00 - 2021-03-22 23:39:00+00:00: : 1it [00:00,  3.80it/s]

                                   Open      High       Low     Close     Volume  \\
    Open time
    2021-03-22 21:40:00+00:00  54676.30  54691.41  54532.77  54549.49  35.566780
    2021-03-22 21:41:00+00:00  54547.36  54593.96  54543.23  54589.81  32.813574
    2021-03-22 21:42:00+00:00  54589.81  54655.85  54585.57  54650.04  19.616003
    ...                             ...       ...       ...       ...        ...
    2021-03-22 23:37:00+00:00  54443.83  54568.80  54403.49  54511.87  26.505448
    2021-03-22 23:38:00+00:00  54511.86  54511.86  54388.00  54406.59  24.879893
    2021-03-22 23:39:00+00:00  54411.55  54430.74  54386.70  54430.73   4.010454

                                                    Close time  Quote volume  \\
    Open time
    2021-03-22 21:40:00+00:00 2021-03-22 21:40:59.999000+00:00  1.943891e+06
    2021-03-22 21:41:00+00:00 2021-03-22 21:41:59.999000+00:00  1.790163e+06
    2021-03-22 21:42:00+00:00 2021-03-22 21:42:59.999000+00:00  1.071824e+06
    ...                                                    ...           ...
    2021-03-22 23:37:00+00:00 2021-03-22 23:37:59.999000+00:00  1.444602e+06
    2021-03-22 23:38:00+00:00 2021-03-22 23:38:59.999000+00:00  1.354316e+06
    2021-03-22 23:39:00+00:00 2021-03-22 23:39:59.999000+00:00  2.182080e+05

                               Number of trades  Taker base volume  \\
    Open time
    2021-03-22 21:40:00+00:00              1544          15.160921
    2021-03-22 21:41:00+00:00              1638          15.132376
    2021-03-22 21:42:00+00:00              1022          10.442487
    ...                                     ...                ...
    2021-03-22 23:37:00+00:00               795          13.412746
    2021-03-22 23:38:00+00:00               815          10.808586
    2021-03-22 23:39:00+00:00               209           2.312393

                               Taker quote volume
    Open time
    2021-03-22 21:40:00+00:00        8.288645e+05
    2021-03-22 21:41:00+00:00        8.256025e+05
    2021-03-22 21:42:00+00:00        5.706188e+05
    ...                                       ...
    2021-03-22 23:37:00+00:00        7.310994e+05
    2021-03-22 23:38:00+00:00        5.883322e+05
    2021-03-22 23:39:00+00:00        1.258189e+05

    [120 rows x 10 columns]

    &gt;&gt;&gt; import time
    &gt;&gt;&gt; time.sleep(60)

    &gt;&gt;&gt; binance_data = binance_data.update()
    &gt;&gt;&gt; binance_data.get()
                                   Open      High       Low     Close     Volume  \\
    Open time
    2021-03-22 21:40:00+00:00  54676.30  54691.41  54532.77  54549.49  35.566780
    2021-03-22 21:41:00+00:00  54547.36  54593.96  54543.23  54589.81  32.813574
    2021-03-22 21:42:00+00:00  54589.81  54655.85  54585.57  54650.04  19.616003
    ...                             ...       ...       ...       ...        ...
    2021-03-22 23:38:00+00:00  54511.86  54511.86  54388.00  54406.59  24.879893
    2021-03-22 23:39:00+00:00  54411.55  54499.49  54386.70  54460.91  21.214675
    2021-03-22 23:40:00+00:00  54460.90  54571.00  54458.12  54570.99  11.484854

                                                    Close time  Quote volume  \\
    Open time
    2021-03-22 21:40:00+00:00 2021-03-22 21:40:59.999000+00:00  1.943891e+06
    2021-03-22 21:41:00+00:00 2021-03-22 21:41:59.999000+00:00  1.790163e+06
    2021-03-22 21:42:00+00:00 2021-03-22 21:42:59.999000+00:00  1.071824e+06
    ...                                                    ...           ...
    2021-03-22 23:38:00+00:00 2021-03-22 23:38:59.999000+00:00  1.354316e+06
    2021-03-22 23:39:00+00:00 2021-03-22 23:39:59.999000+00:00  1.155268e+06
    2021-03-22 23:40:00+00:00 2021-03-22 23:40:59.999000+00:00  6.262655e+05

                               Number of trades  Taker base volume  \\
    Open time
    2021-03-22 21:40:00+00:00              1544          15.160921
    2021-03-22 21:41:00+00:00              1638          15.132376
    2021-03-22 21:42:00+00:00              1022          10.442487
    ...                                     ...                ...
    2021-03-22 23:38:00+00:00               815          10.808586
    2021-03-22 23:39:00+00:00               693          10.565621
    2021-03-22 23:40:00+00:00               448           6.107031

                               Taker quote volume
    Open time
    2021-03-22 21:40:00+00:00        8.288645e+05
    2021-03-22 21:41:00+00:00        8.256025e+05
    2021-03-22 21:42:00+00:00        5.706188e+05
    ...                                       ...
    2021-03-22 23:38:00+00:00        5.883322e+05
    2021-03-22 23:39:00+00:00        5.753598e+05
    2021-03-22 23:40:00+00:00        3.330209e+05

    [121 rows x 10 columns]
    ```&#34;&#34;&#34;

    @classmethod
    def download(cls, symbols, client=None, **kwargs):
        &#34;&#34;&#34;Override `vectorbt.data.base.Data.download` to instantiate a Binance client.&#34;&#34;&#34;
        from binance.client import Client
        from vectorbt import settings

        client_kwargs = dict()
        for k in get_func_kwargs(Client):
            if k in kwargs:
                client_kwargs[k] = kwargs.pop(k)
        client_kwargs = merge_dicts(settings.data[&#39;binance&#39;], client_kwargs)
        if client is None:
            client = Client(**client_kwargs)
        return super(BinanceData, cls).download(symbols, client=client, **kwargs)

    @classmethod
    def download_symbol(cls, symbol, client=None, interval=None, start=0, end=&#39;now UTC&#39;,
                        delay=500, limit=500, show_progress=True):
        &#34;&#34;&#34;Download the symbol.

        Args:
            symbol (str): Symbol.
            client (binance.client.Client): Binance client of type `binance.client.Client`.

                Overrides `binance` settings defined in `vectorbt.settings.data`.
            interval (str): Kline interval.

                See `binance.enums`.
            start (any): Start datetime.

                See `vectorbt.utils.datetime.to_tzaware_datetime`.
            end (any): End datetime.

                See `vectorbt.utils.datetime.to_tzaware_datetime`.
            delay (int or float): Time to sleep after each request (in milliseconds).
            limit (int): The maximum number of returned items.
            show_progress (bool): Whether to show the progress bar.
        &#34;&#34;&#34;
        if client is None:
            raise ValueError(&#34;client must be provided&#34;)

        # Establish the timestamps
        start_ts = datetime_to_ms(to_tzaware_datetime(start, tz=get_utc_tz()))
        try:
            first_data = client.get_klines(
                symbol=symbol,
                interval=interval,
                limit=1,
                startTime=0,
                endTime=None
            )
            first_valid_ts = first_data[0][0]
            next_start_ts = start_ts = max(start_ts, first_valid_ts)
        except:
            next_start_ts = start_ts
        end_ts = datetime_to_ms(to_tzaware_datetime(end, tz=get_utc_tz()))

        def _ts_to_str(ts):
            return str(pd.Timestamp(to_tzaware_datetime(ts, tz=get_utc_tz())))

        # Iteratively collect the data
        data = []
        with tqdm(disable=not show_progress) as pbar:
            pbar.set_description(_ts_to_str(start_ts))
            while True:
                # Fetch the klines for the next interval
                next_data = client.get_klines(
                    symbol=symbol,
                    interval=interval,
                    limit=limit,
                    startTime=next_start_ts,
                    endTime=end_ts
                )
                if len(data) &gt; 0:
                    next_data = list(filter(lambda d: next_start_ts &lt; d[0] &lt; end_ts, next_data))
                else:
                    next_data = list(filter(lambda d: d[0] &lt; end_ts, next_data))

                # Update the timestamps and the progress bar
                if not len(next_data):
                    break
                data += next_data
                pbar.set_description(&#34;{} - {}&#34;.format(
                    _ts_to_str(start_ts),
                    _ts_to_str(next_data[-1][0])
                ))
                pbar.update(1)
                next_start_ts = next_data[-1][0]
                if delay is not None:
                    time.sleep(delay / 1000)  # be kind to api

        # Convert data to a DataFrame
        df = pd.DataFrame(data, columns=[
            &#39;Open time&#39;,
            &#39;Open&#39;,
            &#39;High&#39;,
            &#39;Low&#39;,
            &#39;Close&#39;,
            &#39;Volume&#39;,
            &#39;Close time&#39;,
            &#39;Quote volume&#39;,
            &#39;Number of trades&#39;,
            &#39;Taker base volume&#39;,
            &#39;Taker quote volume&#39;,
            &#39;Ignore&#39;
        ])
        df.index = pd.to_datetime(df[&#39;Open time&#39;], unit=&#39;ms&#39;, utc=True)
        del df[&#39;Open time&#39;]
        df[&#39;Open&#39;] = df[&#39;Open&#39;].astype(float)
        df[&#39;High&#39;] = df[&#39;High&#39;].astype(float)
        df[&#39;Low&#39;] = df[&#39;Low&#39;].astype(float)
        df[&#39;Close&#39;] = df[&#39;Close&#39;].astype(float)
        df[&#39;Volume&#39;] = df[&#39;Volume&#39;].astype(float)
        df[&#39;Close time&#39;] = pd.to_datetime(df[&#39;Close time&#39;], unit=&#39;ms&#39;, utc=True)
        df[&#39;Quote volume&#39;] = df[&#39;Quote volume&#39;].astype(float)
        df[&#39;Number of trades&#39;] = df[&#39;Number of trades&#39;].astype(int)
        df[&#39;Taker base volume&#39;] = df[&#39;Taker base volume&#39;].astype(float)
        df[&#39;Taker quote volume&#39;] = df[&#39;Taker quote volume&#39;].astype(float)
        del df[&#39;Ignore&#39;]

        return df

    def update_symbol(self, symbol, **kwargs):
        &#34;&#34;&#34;Update the symbol.

        `**kwargs` will override keyword arguments passed to `BinanceData.download_symbol`.&#34;&#34;&#34;
        download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
        download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
        download_kwargs[&#39;show_progress&#39;] = False
        kwargs = merge_dicts(download_kwargs, kwargs)
        return self.download_symbol(symbol, **kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.data.base.Data" href="base.html#vectorbt.data.base.Data">Data</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.data.custom.BinanceData.download"><code class="name flex">
<span>def <span class="ident fname">download</span></span>(<span>symbols, client=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Override <code><a title="vectorbt.data.base.Data.download" href="base.html#vectorbt.data.base.Data.download">Data.download()</a></code> to instantiate a Binance client.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def download(cls, symbols, client=None, **kwargs):
    &#34;&#34;&#34;Override `vectorbt.data.base.Data.download` to instantiate a Binance client.&#34;&#34;&#34;
    from binance.client import Client
    from vectorbt import settings

    client_kwargs = dict()
    for k in get_func_kwargs(Client):
        if k in kwargs:
            client_kwargs[k] = kwargs.pop(k)
    client_kwargs = merge_dicts(settings.data[&#39;binance&#39;], client_kwargs)
    if client is None:
        client = Client(**client_kwargs)
    return super(BinanceData, cls).download(symbols, client=client, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.data.custom.BinanceData.download_symbol"><code class="name flex">
<span>def <span class="ident fname">download_symbol</span></span>(<span>symbol, client=None, interval=None, start=0, end='now UTC', delay=500, limit=500, show_progress=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Download the symbol.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>symbol</code></strong> :&ensp;<code>str</code></dt>
<dd>Symbol.</dd>
<dt><strong><code>client</code></strong> :&ensp;<code>binance.client.Client</code></dt>
<dd>
<p>Binance client of type <code>binance.client.Client</code>.</p>
<p>Overrides <code>binance</code> settings defined in <code><a title="vectorbt.settings.data" href="../settings.html#vectorbt.settings.data">data</a></code>.</p>
</dd>
<dt><strong><code>interval</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Kline interval.</p>
<p>See <code>binance.enums</code>.</p>
</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>any</code></dt>
<dd>
<p>Start datetime.</p>
<p>See <code><a title="vectorbt.utils.datetime.to_tzaware_datetime" href="../utils/datetime.html#vectorbt.utils.datetime.to_tzaware_datetime">to_tzaware_datetime()</a></code>.</p>
</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>any</code></dt>
<dd>
<p>End datetime.</p>
<p>See <code><a title="vectorbt.utils.datetime.to_tzaware_datetime" href="../utils/datetime.html#vectorbt.utils.datetime.to_tzaware_datetime">to_tzaware_datetime()</a></code>.</p>
</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Time to sleep after each request (in milliseconds).</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of returned items.</dd>
<dt><strong><code>show_progress</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the progress bar.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def download_symbol(cls, symbol, client=None, interval=None, start=0, end=&#39;now UTC&#39;,
                    delay=500, limit=500, show_progress=True):
    &#34;&#34;&#34;Download the symbol.

    Args:
        symbol (str): Symbol.
        client (binance.client.Client): Binance client of type `binance.client.Client`.

            Overrides `binance` settings defined in `vectorbt.settings.data`.
        interval (str): Kline interval.

            See `binance.enums`.
        start (any): Start datetime.

            See `vectorbt.utils.datetime.to_tzaware_datetime`.
        end (any): End datetime.

            See `vectorbt.utils.datetime.to_tzaware_datetime`.
        delay (int or float): Time to sleep after each request (in milliseconds).
        limit (int): The maximum number of returned items.
        show_progress (bool): Whether to show the progress bar.
    &#34;&#34;&#34;
    if client is None:
        raise ValueError(&#34;client must be provided&#34;)

    # Establish the timestamps
    start_ts = datetime_to_ms(to_tzaware_datetime(start, tz=get_utc_tz()))
    try:
        first_data = client.get_klines(
            symbol=symbol,
            interval=interval,
            limit=1,
            startTime=0,
            endTime=None
        )
        first_valid_ts = first_data[0][0]
        next_start_ts = start_ts = max(start_ts, first_valid_ts)
    except:
        next_start_ts = start_ts
    end_ts = datetime_to_ms(to_tzaware_datetime(end, tz=get_utc_tz()))

    def _ts_to_str(ts):
        return str(pd.Timestamp(to_tzaware_datetime(ts, tz=get_utc_tz())))

    # Iteratively collect the data
    data = []
    with tqdm(disable=not show_progress) as pbar:
        pbar.set_description(_ts_to_str(start_ts))
        while True:
            # Fetch the klines for the next interval
            next_data = client.get_klines(
                symbol=symbol,
                interval=interval,
                limit=limit,
                startTime=next_start_ts,
                endTime=end_ts
            )
            if len(data) &gt; 0:
                next_data = list(filter(lambda d: next_start_ts &lt; d[0] &lt; end_ts, next_data))
            else:
                next_data = list(filter(lambda d: d[0] &lt; end_ts, next_data))

            # Update the timestamps and the progress bar
            if not len(next_data):
                break
            data += next_data
            pbar.set_description(&#34;{} - {}&#34;.format(
                _ts_to_str(start_ts),
                _ts_to_str(next_data[-1][0])
            ))
            pbar.update(1)
            next_start_ts = next_data[-1][0]
            if delay is not None:
                time.sleep(delay / 1000)  # be kind to api

    # Convert data to a DataFrame
    df = pd.DataFrame(data, columns=[
        &#39;Open time&#39;,
        &#39;Open&#39;,
        &#39;High&#39;,
        &#39;Low&#39;,
        &#39;Close&#39;,
        &#39;Volume&#39;,
        &#39;Close time&#39;,
        &#39;Quote volume&#39;,
        &#39;Number of trades&#39;,
        &#39;Taker base volume&#39;,
        &#39;Taker quote volume&#39;,
        &#39;Ignore&#39;
    ])
    df.index = pd.to_datetime(df[&#39;Open time&#39;], unit=&#39;ms&#39;, utc=True)
    del df[&#39;Open time&#39;]
    df[&#39;Open&#39;] = df[&#39;Open&#39;].astype(float)
    df[&#39;High&#39;] = df[&#39;High&#39;].astype(float)
    df[&#39;Low&#39;] = df[&#39;Low&#39;].astype(float)
    df[&#39;Close&#39;] = df[&#39;Close&#39;].astype(float)
    df[&#39;Volume&#39;] = df[&#39;Volume&#39;].astype(float)
    df[&#39;Close time&#39;] = pd.to_datetime(df[&#39;Close time&#39;], unit=&#39;ms&#39;, utc=True)
    df[&#39;Quote volume&#39;] = df[&#39;Quote volume&#39;].astype(float)
    df[&#39;Number of trades&#39;] = df[&#39;Number of trades&#39;].astype(int)
    df[&#39;Taker base volume&#39;] = df[&#39;Taker base volume&#39;].astype(float)
    df[&#39;Taker quote volume&#39;] = df[&#39;Taker quote volume&#39;].astype(float)
    del df[&#39;Ignore&#39;]

    return df</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.data.custom.BinanceData.update_symbol"><code class="name flex">
<span>def <span class="ident fname">update_symbol</span></span>(<span>self, symbol, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the symbol.</p>
<p><code>**kwargs</code> will override keyword arguments passed to <code><a title="vectorbt.data.custom.BinanceData.download_symbol" href="#vectorbt.data.custom.BinanceData.download_symbol">BinanceData.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_symbol(self, symbol, **kwargs):
    &#34;&#34;&#34;Update the symbol.

    `**kwargs` will override keyword arguments passed to `BinanceData.download_symbol`.&#34;&#34;&#34;
    download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
    download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
    download_kwargs[&#39;show_progress&#39;] = False
    kwargs = merge_dicts(download_kwargs, kwargs)
    return self.download_symbol(symbol, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.data.base.Data" href="base.html#vectorbt.data.base.Data">Data</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.data.base.Data.align_columns" href="base.html#vectorbt.data.base.Data.align_columns">align_columns</a></code></li>
<li><code><a title="vectorbt.data.base.Data.align_index" href="base.html#vectorbt.data.base.Data.align_index">align_index</a></code></li>
<li><code><a title="vectorbt.data.base.Data.concat" href="base.html#vectorbt.data.base.Data.concat">concat</a></code></li>
<li><code><a title="vectorbt.data.base.Data.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.data.base.Data.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.data.base.Data.data" href="base.html#vectorbt.data.base.Data.data">data</a></code></li>
<li><code><a title="vectorbt.data.base.Data.download_kwargs" href="base.html#vectorbt.data.base.Data.download_kwargs">download_kwargs</a></code></li>
<li><code><a title="vectorbt.data.base.Data.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.data.base.Data.from_data" href="base.html#vectorbt.data.base.Data.from_data">from_data</a></code></li>
<li><code><a title="vectorbt.data.base.Data.get" href="base.html#vectorbt.data.base.Data.get">get</a></code></li>
<li><code><a title="vectorbt.data.base.Data.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.data.base.Data.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.data.base.Data.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.data.base.Data.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.data.base.Data.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.data.base.Data.missing_columns" href="base.html#vectorbt.data.base.Data.missing_columns">missing_columns</a></code></li>
<li><code><a title="vectorbt.data.base.Data.missing_index" href="base.html#vectorbt.data.base.Data.missing_index">missing_index</a></code></li>
<li><code><a title="vectorbt.data.base.Data.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.data.base.Data.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.data.base.Data.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.data.base.Data.select_symbol_kwargs" href="base.html#vectorbt.data.base.Data.select_symbol_kwargs">select_symbol_kwargs</a></code></li>
<li><code><a title="vectorbt.data.base.Data.symbols" href="base.html#vectorbt.data.base.Data.symbols">symbols</a></code></li>
<li><code><a title="vectorbt.data.base.Data.tz_convert" href="base.html#vectorbt.data.base.Data.tz_convert">tz_convert</a></code></li>
<li><code><a title="vectorbt.data.base.Data.tz_localize" href="base.html#vectorbt.data.base.Data.tz_localize">tz_localize</a></code></li>
<li><code><a title="vectorbt.data.base.Data.update" href="base.html#vectorbt.data.base.Data.update">update</a></code></li>
<li><code><a title="vectorbt.data.base.Data.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.data.base.Data.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.data.base.Data.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.data.custom.CCXTData"><code class="flex name class">
<span>class <span class="ident parent-fname">CCXTData</span></span>
<span>(</span><span>wrapper, data, tz_localize=None, tz_convert=None, missing_index=None, missing_columns=None, download_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><code>Data</code> for data coming from <code>ccxt</code>.</p>
<h2 id="example">Example</h2>
<p>Fetch the 1-minute data of the last 2 hours, wait 1 minute, and update:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; ccxt_data = vbt.CCXTData.download(
...     &quot;BTC/USDT&quot;,
...     start='2 hours ago UTC',
...     end='now UTC',
...     timeframe='1m'
... )
&gt;&gt;&gt; ccxt_data.get()
2021-03-22 21:08:45.826000+00:00 - 2021-03-22 23:08:00+00:00: : 1it [00:00,  1.96it/s]

                               Open      High       Low     Close      Volume
Open time
2021-03-22 21:09:00+00:00  54840.01  54843.01  54752.86  54819.23   34.311598
2021-03-22 21:10:00+00:00  54819.23  54868.27  54818.05  54857.81   33.024841
2021-03-22 21:11:00+00:00  54853.90  54917.13  54848.26  54915.80   30.612839
...                             ...       ...       ...       ...         ...
2021-03-22 23:06:00+00:00  54802.16  54871.14  54802.16  54850.00   67.792298
2021-03-22 23:07:00+00:00  54850.00  54856.23  54771.89  54816.47   63.103731
2021-03-22 23:08:00+00:00  54816.45  54826.41  54733.86  54765.74   48.825476

[120 rows x 5 columns]

&gt;&gt;&gt; import time
&gt;&gt;&gt; time.sleep(60)

&gt;&gt;&gt; ccxt_data = ccxt_data.update()
&gt;&gt;&gt; ccxt_data.get()
                               Open      High       Low     Close      Volume
Open time
2021-03-22 21:09:00+00:00  54840.01  54843.01  54752.86  54819.23   34.311598
2021-03-22 21:10:00+00:00  54819.23  54868.27  54818.05  54857.81   33.024841
2021-03-22 21:11:00+00:00  54853.90  54917.13  54848.26  54915.80   30.612839
...                             ...       ...       ...       ...         ...
2021-03-22 23:07:00+00:00  54850.00  54856.23  54771.89  54816.47   63.103731
2021-03-22 23:08:00+00:00  54816.45  54826.41  54733.86  54777.12   74.730137
2021-03-22 23:09:00+00:00  54777.12  54869.48  54770.55  54827.52   45.687450

[121 rows x 5 columns]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CCXTData(Data):
    &#34;&#34;&#34;`Data` for data coming from `ccxt`.

    ## Example

    Fetch the 1-minute data of the last 2 hours, wait 1 minute, and update:

    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; ccxt_data = vbt.CCXTData.download(
    ...     &#34;BTC/USDT&#34;,
    ...     start=&#39;2 hours ago UTC&#39;,
    ...     end=&#39;now UTC&#39;,
    ...     timeframe=&#39;1m&#39;
    ... )
    &gt;&gt;&gt; ccxt_data.get()
    2021-03-22 21:08:45.826000+00:00 - 2021-03-22 23:08:00+00:00: : 1it [00:00,  1.96it/s]

                                   Open      High       Low     Close      Volume
    Open time
    2021-03-22 21:09:00+00:00  54840.01  54843.01  54752.86  54819.23   34.311598
    2021-03-22 21:10:00+00:00  54819.23  54868.27  54818.05  54857.81   33.024841
    2021-03-22 21:11:00+00:00  54853.90  54917.13  54848.26  54915.80   30.612839
    ...                             ...       ...       ...       ...         ...
    2021-03-22 23:06:00+00:00  54802.16  54871.14  54802.16  54850.00   67.792298
    2021-03-22 23:07:00+00:00  54850.00  54856.23  54771.89  54816.47   63.103731
    2021-03-22 23:08:00+00:00  54816.45  54826.41  54733.86  54765.74   48.825476

    [120 rows x 5 columns]

    &gt;&gt;&gt; import time
    &gt;&gt;&gt; time.sleep(60)

    &gt;&gt;&gt; ccxt_data = ccxt_data.update()
    &gt;&gt;&gt; ccxt_data.get()
                                   Open      High       Low     Close      Volume
    Open time
    2021-03-22 21:09:00+00:00  54840.01  54843.01  54752.86  54819.23   34.311598
    2021-03-22 21:10:00+00:00  54819.23  54868.27  54818.05  54857.81   33.024841
    2021-03-22 21:11:00+00:00  54853.90  54917.13  54848.26  54915.80   30.612839
    ...                             ...       ...       ...       ...         ...
    2021-03-22 23:07:00+00:00  54850.00  54856.23  54771.89  54816.47   63.103731
    2021-03-22 23:08:00+00:00  54816.45  54826.41  54733.86  54777.12   74.730137
    2021-03-22 23:09:00+00:00  54777.12  54869.48  54770.55  54827.52   45.687450

    [121 rows x 5 columns]
    ```&#34;&#34;&#34;

    @classmethod
    def download_symbol(cls, symbol, exchange=&#39;binance&#39;, config=None, timeframe=&#39;1d&#39;, start=0,
                        end=&#39;now UTC&#39;, delay=None, limit=500, retries=3, show_progress=True, params=None):
        &#34;&#34;&#34;Download the symbol.

        Args:
            symbol (str): Symbol.
            exchange (str or object): Exchange identifier or an exchange object of type
                `ccxt.base.exchange.Exchange`.
            config (dict): Config passed to the exchange upon instantiation.

                Overrides settings under `ccxt` in `vectorbt.settings.data`.

                Will raise an exception if exchange has been already instantiated.
            timeframe (str): Timeframe supported by the exchange.
            start (any): Start datetime.

                See `vectorbt.utils.datetime.to_tzaware_datetime`.
            end (any): End datetime.

                See `vectorbt.utils.datetime.to_tzaware_datetime`.
            delay (int or float): Time to sleep after each request (in milliseconds).

                !!! note
                    Use only if `enableRateLimit` is not set.
            limit (int): The maximum number of returned items.
            retries (int): The number of retries on failure to fetch data.
            show_progress (bool): Whether to show the progress bar.
            params (dict): Exchange-specific key-value parameters.
        &#34;&#34;&#34;
        import ccxt
        from vectorbt import settings

        if config is None:
            config = {}
        if params is None:
            params = {}
        if isinstance(exchange, str):
            if not hasattr(ccxt, exchange):
                raise ValueError(f&#34;Exchange {exchange} not found&#34;)
            # Resolve config
            default_config = {}
            for k, v in settings.data[&#39;ccxt&#39;].items():
                # Get general (not per exchange) settings
                if k in ccxt.exchanges:
                    continue
                default_config[k] = v
            if exchange in settings.data[&#39;ccxt&#39;]:
                default_config = merge_dicts(default_config, settings.data[&#39;ccxt&#39;][exchange])
            config = merge_dicts(default_config, config)
            exchange = getattr(ccxt, exchange)(config)
        else:
            if len(config) &gt; 0:
                raise ValueError(&#34;Cannot apply config after instantiation of the exchange&#34;)
        if not exchange.has[&#39;fetchOHLCV&#39;]:
            raise ValueError(f&#34;Exchange {exchange} does not support OHLCV&#34;)
        if timeframe not in exchange.timeframes:
            raise ValueError(f&#34;Exchange {exchange} does not support {timeframe} timeframe&#34;)
        if exchange.has[&#39;fetchOHLCV&#39;] == &#39;emulated&#39;:
            warnings.warn(&#34;Using emulated OHLCV candles&#34;, stacklevel=2)

        def _retry(method):
            @wraps(method)
            def retry_method(*args, **kwargs):
                for i in range(retries):
                    try:
                        return method(*args, **kwargs)
                    except (ccxt.NetworkError, ccxt.ExchangeError) as e:
                        if i == retries - 1:
                            raise e
                    if delay is not None:
                        time.sleep(delay / 1000)

            return retry_method

        @_retry
        def _fetch(_since, _limit):
            return exchange.fetch_ohlcv(
                symbol,
                timeframe=timeframe,
                since=_since,
                limit=_limit,
                params=params
            )

        # Establish the timestamps
        start_ts = datetime_to_ms(to_tzaware_datetime(start, tz=get_utc_tz()))
        try:
            first_data = _fetch(0, 1)
            first_valid_ts = first_data[0][0]
            next_start_ts = start_ts = max(start_ts, first_valid_ts)
        except:
            next_start_ts = start_ts
        end_ts = datetime_to_ms(to_tzaware_datetime(end, tz=get_utc_tz()))

        def _ts_to_str(ts):
            return str(pd.Timestamp(to_tzaware_datetime(ts, tz=get_utc_tz())))

        # Iteratively collect the data
        data = []
        with tqdm(disable=not show_progress) as pbar:
            pbar.set_description(_ts_to_str(start_ts))
            while True:
                # Fetch the klines for the next interval
                next_data = _fetch(next_start_ts, limit)
                if len(data) &gt; 0:
                    next_data = list(filter(lambda d: next_start_ts &lt; d[0] &lt; end_ts, next_data))
                else:
                    next_data = list(filter(lambda d: d[0] &lt; end_ts, next_data))

                # Update the timestamps and the progress bar
                if not len(next_data):
                    break
                data += next_data
                pbar.set_description(&#34;{} - {}&#34;.format(
                    _ts_to_str(start_ts),
                    _ts_to_str(next_data[-1][0])
                ))
                pbar.update(1)
                next_start_ts = next_data[-1][0]
                if delay is not None:
                    time.sleep(delay / 1000)  # be kind to api

        # Convert data to a DataFrame
        df = pd.DataFrame(data, columns=[
            &#39;Open time&#39;,
            &#39;Open&#39;,
            &#39;High&#39;,
            &#39;Low&#39;,
            &#39;Close&#39;,
            &#39;Volume&#39;
        ])
        df.index = pd.to_datetime(df[&#39;Open time&#39;], unit=&#39;ms&#39;, utc=True)
        del df[&#39;Open time&#39;]
        df[&#39;Open&#39;] = df[&#39;Open&#39;].astype(float)
        df[&#39;High&#39;] = df[&#39;High&#39;].astype(float)
        df[&#39;Low&#39;] = df[&#39;Low&#39;].astype(float)
        df[&#39;Close&#39;] = df[&#39;Close&#39;].astype(float)
        df[&#39;Volume&#39;] = df[&#39;Volume&#39;].astype(float)

        return df

    def update_symbol(self, symbol, **kwargs):
        &#34;&#34;&#34;Update the symbol.

        `**kwargs` will override keyword arguments passed to `CCXTData.download_symbol`.&#34;&#34;&#34;
        download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
        download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
        download_kwargs[&#39;show_progress&#39;] = False
        kwargs = merge_dicts(download_kwargs, kwargs)
        return self.download_symbol(symbol, **kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.data.base.Data" href="base.html#vectorbt.data.base.Data">Data</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.data.custom.CCXTData.download_symbol"><code class="name flex">
<span>def <span class="ident fname">download_symbol</span></span>(<span>symbol, exchange='binance', config=None, timeframe='1d', start=0, end='now UTC', delay=None, limit=500, retries=3, show_progress=True, params=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Download the symbol.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>symbol</code></strong> :&ensp;<code>str</code></dt>
<dd>Symbol.</dd>
<dt><strong><code>exchange</code></strong> :&ensp;<code>str</code> or <code>object</code></dt>
<dd>Exchange identifier or an exchange object of type
<code>ccxt.base.exchange.Exchange</code>.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Config passed to the exchange upon instantiation.</p>
<p>Overrides settings under <code>ccxt</code> in <code><a title="vectorbt.settings.data" href="../settings.html#vectorbt.settings.data">data</a></code>.</p>
<p>Will raise an exception if exchange has been already instantiated.</p>
</dd>
<dt><strong><code>timeframe</code></strong> :&ensp;<code>str</code></dt>
<dd>Timeframe supported by the exchange.</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>any</code></dt>
<dd>
<p>Start datetime.</p>
<p>See <code><a title="vectorbt.utils.datetime.to_tzaware_datetime" href="../utils/datetime.html#vectorbt.utils.datetime.to_tzaware_datetime">to_tzaware_datetime()</a></code>.</p>
</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>any</code></dt>
<dd>
<p>End datetime.</p>
<p>See <code><a title="vectorbt.utils.datetime.to_tzaware_datetime" href="../utils/datetime.html#vectorbt.utils.datetime.to_tzaware_datetime">to_tzaware_datetime()</a></code>.</p>
</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>
<p>Time to sleep after each request (in milliseconds).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use only if <code>enableRateLimit</code> is not set.</p>
</div>
</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of returned items.</dd>
<dt><strong><code>retries</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of retries on failure to fetch data.</dd>
<dt><strong><code>show_progress</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the progress bar.</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Exchange-specific key-value parameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def download_symbol(cls, symbol, exchange=&#39;binance&#39;, config=None, timeframe=&#39;1d&#39;, start=0,
                    end=&#39;now UTC&#39;, delay=None, limit=500, retries=3, show_progress=True, params=None):
    &#34;&#34;&#34;Download the symbol.

    Args:
        symbol (str): Symbol.
        exchange (str or object): Exchange identifier or an exchange object of type
            `ccxt.base.exchange.Exchange`.
        config (dict): Config passed to the exchange upon instantiation.

            Overrides settings under `ccxt` in `vectorbt.settings.data`.

            Will raise an exception if exchange has been already instantiated.
        timeframe (str): Timeframe supported by the exchange.
        start (any): Start datetime.

            See `vectorbt.utils.datetime.to_tzaware_datetime`.
        end (any): End datetime.

            See `vectorbt.utils.datetime.to_tzaware_datetime`.
        delay (int or float): Time to sleep after each request (in milliseconds).

            !!! note
                Use only if `enableRateLimit` is not set.
        limit (int): The maximum number of returned items.
        retries (int): The number of retries on failure to fetch data.
        show_progress (bool): Whether to show the progress bar.
        params (dict): Exchange-specific key-value parameters.
    &#34;&#34;&#34;
    import ccxt
    from vectorbt import settings

    if config is None:
        config = {}
    if params is None:
        params = {}
    if isinstance(exchange, str):
        if not hasattr(ccxt, exchange):
            raise ValueError(f&#34;Exchange {exchange} not found&#34;)
        # Resolve config
        default_config = {}
        for k, v in settings.data[&#39;ccxt&#39;].items():
            # Get general (not per exchange) settings
            if k in ccxt.exchanges:
                continue
            default_config[k] = v
        if exchange in settings.data[&#39;ccxt&#39;]:
            default_config = merge_dicts(default_config, settings.data[&#39;ccxt&#39;][exchange])
        config = merge_dicts(default_config, config)
        exchange = getattr(ccxt, exchange)(config)
    else:
        if len(config) &gt; 0:
            raise ValueError(&#34;Cannot apply config after instantiation of the exchange&#34;)
    if not exchange.has[&#39;fetchOHLCV&#39;]:
        raise ValueError(f&#34;Exchange {exchange} does not support OHLCV&#34;)
    if timeframe not in exchange.timeframes:
        raise ValueError(f&#34;Exchange {exchange} does not support {timeframe} timeframe&#34;)
    if exchange.has[&#39;fetchOHLCV&#39;] == &#39;emulated&#39;:
        warnings.warn(&#34;Using emulated OHLCV candles&#34;, stacklevel=2)

    def _retry(method):
        @wraps(method)
        def retry_method(*args, **kwargs):
            for i in range(retries):
                try:
                    return method(*args, **kwargs)
                except (ccxt.NetworkError, ccxt.ExchangeError) as e:
                    if i == retries - 1:
                        raise e
                if delay is not None:
                    time.sleep(delay / 1000)

        return retry_method

    @_retry
    def _fetch(_since, _limit):
        return exchange.fetch_ohlcv(
            symbol,
            timeframe=timeframe,
            since=_since,
            limit=_limit,
            params=params
        )

    # Establish the timestamps
    start_ts = datetime_to_ms(to_tzaware_datetime(start, tz=get_utc_tz()))
    try:
        first_data = _fetch(0, 1)
        first_valid_ts = first_data[0][0]
        next_start_ts = start_ts = max(start_ts, first_valid_ts)
    except:
        next_start_ts = start_ts
    end_ts = datetime_to_ms(to_tzaware_datetime(end, tz=get_utc_tz()))

    def _ts_to_str(ts):
        return str(pd.Timestamp(to_tzaware_datetime(ts, tz=get_utc_tz())))

    # Iteratively collect the data
    data = []
    with tqdm(disable=not show_progress) as pbar:
        pbar.set_description(_ts_to_str(start_ts))
        while True:
            # Fetch the klines for the next interval
            next_data = _fetch(next_start_ts, limit)
            if len(data) &gt; 0:
                next_data = list(filter(lambda d: next_start_ts &lt; d[0] &lt; end_ts, next_data))
            else:
                next_data = list(filter(lambda d: d[0] &lt; end_ts, next_data))

            # Update the timestamps and the progress bar
            if not len(next_data):
                break
            data += next_data
            pbar.set_description(&#34;{} - {}&#34;.format(
                _ts_to_str(start_ts),
                _ts_to_str(next_data[-1][0])
            ))
            pbar.update(1)
            next_start_ts = next_data[-1][0]
            if delay is not None:
                time.sleep(delay / 1000)  # be kind to api

    # Convert data to a DataFrame
    df = pd.DataFrame(data, columns=[
        &#39;Open time&#39;,
        &#39;Open&#39;,
        &#39;High&#39;,
        &#39;Low&#39;,
        &#39;Close&#39;,
        &#39;Volume&#39;
    ])
    df.index = pd.to_datetime(df[&#39;Open time&#39;], unit=&#39;ms&#39;, utc=True)
    del df[&#39;Open time&#39;]
    df[&#39;Open&#39;] = df[&#39;Open&#39;].astype(float)
    df[&#39;High&#39;] = df[&#39;High&#39;].astype(float)
    df[&#39;Low&#39;] = df[&#39;Low&#39;].astype(float)
    df[&#39;Close&#39;] = df[&#39;Close&#39;].astype(float)
    df[&#39;Volume&#39;] = df[&#39;Volume&#39;].astype(float)

    return df</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.data.custom.CCXTData.update_symbol"><code class="name flex">
<span>def <span class="ident fname">update_symbol</span></span>(<span>self, symbol, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the symbol.</p>
<p><code>**kwargs</code> will override keyword arguments passed to <code><a title="vectorbt.data.custom.CCXTData.download_symbol" href="#vectorbt.data.custom.CCXTData.download_symbol">CCXTData.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_symbol(self, symbol, **kwargs):
    &#34;&#34;&#34;Update the symbol.

    `**kwargs` will override keyword arguments passed to `CCXTData.download_symbol`.&#34;&#34;&#34;
    download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
    download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
    download_kwargs[&#39;show_progress&#39;] = False
    kwargs = merge_dicts(download_kwargs, kwargs)
    return self.download_symbol(symbol, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.data.base.Data" href="base.html#vectorbt.data.base.Data">Data</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.data.base.Data.align_columns" href="base.html#vectorbt.data.base.Data.align_columns">align_columns</a></code></li>
<li><code><a title="vectorbt.data.base.Data.align_index" href="base.html#vectorbt.data.base.Data.align_index">align_index</a></code></li>
<li><code><a title="vectorbt.data.base.Data.concat" href="base.html#vectorbt.data.base.Data.concat">concat</a></code></li>
<li><code><a title="vectorbt.data.base.Data.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.data.base.Data.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.data.base.Data.data" href="base.html#vectorbt.data.base.Data.data">data</a></code></li>
<li><code><a title="vectorbt.data.base.Data.download" href="base.html#vectorbt.data.base.Data.download">download</a></code></li>
<li><code><a title="vectorbt.data.base.Data.download_kwargs" href="base.html#vectorbt.data.base.Data.download_kwargs">download_kwargs</a></code></li>
<li><code><a title="vectorbt.data.base.Data.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.data.base.Data.from_data" href="base.html#vectorbt.data.base.Data.from_data">from_data</a></code></li>
<li><code><a title="vectorbt.data.base.Data.get" href="base.html#vectorbt.data.base.Data.get">get</a></code></li>
<li><code><a title="vectorbt.data.base.Data.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.data.base.Data.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.data.base.Data.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.data.base.Data.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.data.base.Data.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.data.base.Data.missing_columns" href="base.html#vectorbt.data.base.Data.missing_columns">missing_columns</a></code></li>
<li><code><a title="vectorbt.data.base.Data.missing_index" href="base.html#vectorbt.data.base.Data.missing_index">missing_index</a></code></li>
<li><code><a title="vectorbt.data.base.Data.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.data.base.Data.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.data.base.Data.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.data.base.Data.select_symbol_kwargs" href="base.html#vectorbt.data.base.Data.select_symbol_kwargs">select_symbol_kwargs</a></code></li>
<li><code><a title="vectorbt.data.base.Data.symbols" href="base.html#vectorbt.data.base.Data.symbols">symbols</a></code></li>
<li><code><a title="vectorbt.data.base.Data.tz_convert" href="base.html#vectorbt.data.base.Data.tz_convert">tz_convert</a></code></li>
<li><code><a title="vectorbt.data.base.Data.tz_localize" href="base.html#vectorbt.data.base.Data.tz_localize">tz_localize</a></code></li>
<li><code><a title="vectorbt.data.base.Data.update" href="base.html#vectorbt.data.base.Data.update">update</a></code></li>
<li><code><a title="vectorbt.data.base.Data.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.data.base.Data.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.data.base.Data.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.data.custom.GBMData"><code class="flex name class">
<span>class <span class="ident parent-fname">GBMData</span></span>
<span>(</span><span>wrapper, data, tz_localize=None, tz_convert=None, missing_index=None, missing_columns=None, download_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.data.custom.SyntheticData" href="#vectorbt.data.custom.SyntheticData">SyntheticData</a></code> for data generated using Geometric Brownian Motion (GBM).</p>
<h2 id="example">Example</h2>
<p>See the example under <code><a title="vectorbt.data.custom.BinanceData" href="#vectorbt.data.custom.BinanceData">BinanceData</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; gbm_data = vbt.GBMData.download('GBM', start='2 hours ago', end='now', freq='1min', seed=42)
&gt;&gt;&gt; gbm_data.get()
2021-03-15 17:56:59.174370+01:00    102.386605
2021-03-15 17:57:59.174370+01:00    101.554203
2021-03-15 17:58:59.174370+01:00    104.765771
...                                        ...
2021-03-15 19:54:59.174370+01:00     51.614839
2021-03-15 19:55:59.174370+01:00     53.525376
2021-03-15 19:56:59.174370+01:00     55.615250
Freq: T, Length: 121, dtype: float64

&gt;&gt;&gt; import time
&gt;&gt;&gt; time.sleep(60)

&gt;&gt;&gt; gbm_data = gbm_data.update()
&gt;&gt;&gt; gbm_data.get()
2021-03-15 17:56:59.174370+01:00    102.386605
2021-03-15 17:57:59.174370+01:00    101.554203
2021-03-15 17:58:59.174370+01:00    104.765771
...                                        ...
2021-03-15 19:55:59.174370+01:00     53.525376
2021-03-15 19:56:59.174370+01:00     51.082220
2021-03-15 19:57:59.174370+01:00     54.725304
Freq: T, Length: 122, dtype: float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GBMData(SyntheticData):
    &#34;&#34;&#34;`SyntheticData` for data generated using Geometric Brownian Motion (GBM).

    ## Example

    See the example under `BinanceData`.

    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; gbm_data = vbt.GBMData.download(&#39;GBM&#39;, start=&#39;2 hours ago&#39;, end=&#39;now&#39;, freq=&#39;1min&#39;, seed=42)
    &gt;&gt;&gt; gbm_data.get()
    2021-03-15 17:56:59.174370+01:00    102.386605
    2021-03-15 17:57:59.174370+01:00    101.554203
    2021-03-15 17:58:59.174370+01:00    104.765771
    ...                                        ...
    2021-03-15 19:54:59.174370+01:00     51.614839
    2021-03-15 19:55:59.174370+01:00     53.525376
    2021-03-15 19:56:59.174370+01:00     55.615250
    Freq: T, Length: 121, dtype: float64

    &gt;&gt;&gt; import time
    &gt;&gt;&gt; time.sleep(60)

    &gt;&gt;&gt; gbm_data = gbm_data.update()
    &gt;&gt;&gt; gbm_data.get()
    2021-03-15 17:56:59.174370+01:00    102.386605
    2021-03-15 17:57:59.174370+01:00    101.554203
    2021-03-15 17:58:59.174370+01:00    104.765771
    ...                                        ...
    2021-03-15 19:55:59.174370+01:00     53.525376
    2021-03-15 19:56:59.174370+01:00     51.082220
    2021-03-15 19:57:59.174370+01:00     54.725304
    Freq: T, Length: 122, dtype: float64
    ```&#34;&#34;&#34;

    @classmethod
    def generate_symbol(cls, symbol, index, S0=100., mu=0., sigma=0.05, T=None, I=1, seed=None):
        &#34;&#34;&#34;Generate the symbol using `generate_gbm_paths`.

        Args:
            symbol (str): Symbol.
            index (pd.Index): Pandas index.
            S0 (float): Value at time 0.

                Does not appear as the first value in the output data.
            mu (float): Drift, or mean of the percentage change.
            sigma (float): Standard deviation of the percentage change.
            T (int): Number of time steps.

                Defaults to the length of `index`.
            I (int): Number of generated paths (columns in our case).
            seed (int): Set seed to make the results deterministic.
        &#34;&#34;&#34;
        if T is None:
            T = len(index)
        out = generate_gbm_paths(S0, mu, sigma, T, len(index), I, seed=seed)[1:]
        if out.shape[1] == 1:
            return pd.Series(out[:, 0], index=index)
        columns = pd.RangeIndex(stop=out.shape[1], name=&#39;path&#39;)
        return pd.DataFrame(out, index=index, columns=columns)

    def update_symbol(self, symbol, **kwargs):
        &#34;&#34;&#34;Update the symbol.

        `**kwargs` will override keyword arguments passed to `GBMData.download_symbol`.&#34;&#34;&#34;
        download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
        download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
        _ = download_kwargs.pop(&#39;S0&#39;, None)
        S0 = self.data[symbol].iloc[-2]
        _ = download_kwargs.pop(&#39;T&#39;, None)
        download_kwargs[&#39;seed&#39;] = None
        kwargs = merge_dicts(download_kwargs, kwargs)
        return self.download_symbol(symbol, S0=S0, **kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.data.custom.SyntheticData" href="#vectorbt.data.custom.SyntheticData">SyntheticData</a></li>
<li><a title="vectorbt.data.base.Data" href="base.html#vectorbt.data.base.Data">Data</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.data.custom.GBMData.generate_symbol"><code class="name flex">
<span>def <span class="ident fname">generate_symbol</span></span>(<span>symbol, index, S0=100.0, mu=0.0, sigma=0.05, T=None, I=1, seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the symbol using <code><a title="vectorbt.data.custom.generate_gbm_paths" href="#vectorbt.data.custom.generate_gbm_paths">generate_gbm_paths()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>symbol</code></strong> :&ensp;<code>str</code></dt>
<dd>Symbol.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>pd.Index</code></dt>
<dd>Pandas index.</dd>
<dt><strong><code>S0</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Value at time 0.</p>
<p>Does not appear as the first value in the output data.</p>
</dd>
<dt><strong><code>mu</code></strong> :&ensp;<code>float</code></dt>
<dd>Drift, or mean of the percentage change.</dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code>float</code></dt>
<dd>Standard deviation of the percentage change.</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Number of time steps.</p>
<p>Defaults to the length of <code>index</code>.</p>
</dd>
<dt><strong><code>I</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of generated paths (columns in our case).</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Set seed to make the results deterministic.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def generate_symbol(cls, symbol, index, S0=100., mu=0., sigma=0.05, T=None, I=1, seed=None):
    &#34;&#34;&#34;Generate the symbol using `generate_gbm_paths`.

    Args:
        symbol (str): Symbol.
        index (pd.Index): Pandas index.
        S0 (float): Value at time 0.

            Does not appear as the first value in the output data.
        mu (float): Drift, or mean of the percentage change.
        sigma (float): Standard deviation of the percentage change.
        T (int): Number of time steps.

            Defaults to the length of `index`.
        I (int): Number of generated paths (columns in our case).
        seed (int): Set seed to make the results deterministic.
    &#34;&#34;&#34;
    if T is None:
        T = len(index)
    out = generate_gbm_paths(S0, mu, sigma, T, len(index), I, seed=seed)[1:]
    if out.shape[1] == 1:
        return pd.Series(out[:, 0], index=index)
    columns = pd.RangeIndex(stop=out.shape[1], name=&#39;path&#39;)
    return pd.DataFrame(out, index=index, columns=columns)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.data.custom.GBMData.update_symbol"><code class="name flex">
<span>def <span class="ident fname">update_symbol</span></span>(<span>self, symbol, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the symbol.</p>
<p><code>**kwargs</code> will override keyword arguments passed to <code><a title="vectorbt.data.custom.GBMData.download_symbol" href="#vectorbt.data.custom.SyntheticData.download_symbol">SyntheticData.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_symbol(self, symbol, **kwargs):
    &#34;&#34;&#34;Update the symbol.

    `**kwargs` will override keyword arguments passed to `GBMData.download_symbol`.&#34;&#34;&#34;
    download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
    download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
    _ = download_kwargs.pop(&#39;S0&#39;, None)
    S0 = self.data[symbol].iloc[-2]
    _ = download_kwargs.pop(&#39;T&#39;, None)
    download_kwargs[&#39;seed&#39;] = None
    kwargs = merge_dicts(download_kwargs, kwargs)
    return self.download_symbol(symbol, S0=S0, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.data.custom.SyntheticData" href="#vectorbt.data.custom.SyntheticData">SyntheticData</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.data.custom.SyntheticData.align_columns" href="base.html#vectorbt.data.base.Data.align_columns">align_columns</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.align_index" href="base.html#vectorbt.data.base.Data.align_index">align_index</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.concat" href="base.html#vectorbt.data.base.Data.concat">concat</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.data" href="base.html#vectorbt.data.base.Data.data">data</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.download" href="base.html#vectorbt.data.base.Data.download">download</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.download_kwargs" href="base.html#vectorbt.data.base.Data.download_kwargs">download_kwargs</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.download_symbol" href="#vectorbt.data.custom.SyntheticData.download_symbol">download_symbol</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.from_data" href="base.html#vectorbt.data.base.Data.from_data">from_data</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.get" href="base.html#vectorbt.data.base.Data.get">get</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.missing_columns" href="base.html#vectorbt.data.base.Data.missing_columns">missing_columns</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.missing_index" href="base.html#vectorbt.data.base.Data.missing_index">missing_index</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.select_symbol_kwargs" href="base.html#vectorbt.data.base.Data.select_symbol_kwargs">select_symbol_kwargs</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.symbols" href="base.html#vectorbt.data.base.Data.symbols">symbols</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.tz_convert" href="base.html#vectorbt.data.base.Data.tz_convert">tz_convert</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.tz_localize" href="base.html#vectorbt.data.base.Data.tz_localize">tz_localize</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.update" href="base.html#vectorbt.data.base.Data.update">update</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.data.custom.SyntheticData"><code class="flex name class">
<span>class <span class="ident parent-fname">SyntheticData</span></span>
<span>(</span><span>wrapper, data, tz_localize=None, tz_convert=None, missing_index=None, missing_columns=None, download_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><code>Data</code> for synthetically generated data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SyntheticData(Data):
    &#34;&#34;&#34;`Data` for synthetically generated data.&#34;&#34;&#34;

    @classmethod
    def generate_symbol(cls, symbol, index, **kwargs):
        &#34;&#34;&#34;Abstract method to generate a symbol.&#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def download_symbol(cls, symbol, start=0, end=&#39;now&#39;, freq=None, date_range_kwargs=None, **kwargs):
        &#34;&#34;&#34;Download the symbol.

        Generates datetime index and passes it to `SyntheticData.generate_symbol` to fill
        the Series/DataFrame with generated data.&#34;&#34;&#34;
        if date_range_kwargs is None:
            date_range_kwargs = {}
        index = pd.date_range(
            start=to_tzaware_datetime(start),
            end=to_tzaware_datetime(end),
            freq=freq,
            **date_range_kwargs
        )
        if len(index) == 0:
            raise ValueError(&#34;Date range is empty&#34;)
        return cls.generate_symbol(symbol, index, **kwargs)

    def update_symbol(self, symbol, **kwargs):
        &#34;&#34;&#34;Update the symbol.

        `**kwargs` will override keyword arguments passed to `SyntheticData.download_symbol`.&#34;&#34;&#34;
        download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
        download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
        kwargs = merge_dicts(download_kwargs, kwargs)
        return self.download_symbol(symbol, **kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.data.base.Data" href="base.html#vectorbt.data.base.Data">Data</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.data.custom.GBMData" href="#vectorbt.data.custom.GBMData">GBMData</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.data.custom.SyntheticData.download_symbol"><code class="name flex">
<span>def <span class="ident fname">download_symbol</span></span>(<span>symbol, start=0, end='now', freq=None, date_range_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Download the symbol.</p>
<p>Generates datetime index and passes it to <code><a title="vectorbt.data.custom.SyntheticData.generate_symbol" href="#vectorbt.data.custom.SyntheticData.generate_symbol">SyntheticData.generate_symbol()</a></code> to fill
the Series/DataFrame with generated data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def download_symbol(cls, symbol, start=0, end=&#39;now&#39;, freq=None, date_range_kwargs=None, **kwargs):
    &#34;&#34;&#34;Download the symbol.

    Generates datetime index and passes it to `SyntheticData.generate_symbol` to fill
    the Series/DataFrame with generated data.&#34;&#34;&#34;
    if date_range_kwargs is None:
        date_range_kwargs = {}
    index = pd.date_range(
        start=to_tzaware_datetime(start),
        end=to_tzaware_datetime(end),
        freq=freq,
        **date_range_kwargs
    )
    if len(index) == 0:
        raise ValueError(&#34;Date range is empty&#34;)
    return cls.generate_symbol(symbol, index, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.data.custom.SyntheticData.generate_symbol"><code class="name flex">
<span>def <span class="ident fname">generate_symbol</span></span>(<span>symbol, index, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract method to generate a symbol.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def generate_symbol(cls, symbol, index, **kwargs):
    &#34;&#34;&#34;Abstract method to generate a symbol.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.data.custom.SyntheticData.update_symbol"><code class="name flex">
<span>def <span class="ident fname">update_symbol</span></span>(<span>self, symbol, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the symbol.</p>
<p><code>**kwargs</code> will override keyword arguments passed to <code><a title="vectorbt.data.custom.SyntheticData.download_symbol" href="#vectorbt.data.custom.SyntheticData.download_symbol">SyntheticData.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_symbol(self, symbol, **kwargs):
    &#34;&#34;&#34;Update the symbol.

    `**kwargs` will override keyword arguments passed to `SyntheticData.download_symbol`.&#34;&#34;&#34;
    download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
    download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
    kwargs = merge_dicts(download_kwargs, kwargs)
    return self.download_symbol(symbol, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.data.base.Data" href="base.html#vectorbt.data.base.Data">Data</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.data.base.Data.align_columns" href="base.html#vectorbt.data.base.Data.align_columns">align_columns</a></code></li>
<li><code><a title="vectorbt.data.base.Data.align_index" href="base.html#vectorbt.data.base.Data.align_index">align_index</a></code></li>
<li><code><a title="vectorbt.data.base.Data.concat" href="base.html#vectorbt.data.base.Data.concat">concat</a></code></li>
<li><code><a title="vectorbt.data.base.Data.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.data.base.Data.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.data.base.Data.data" href="base.html#vectorbt.data.base.Data.data">data</a></code></li>
<li><code><a title="vectorbt.data.base.Data.download" href="base.html#vectorbt.data.base.Data.download">download</a></code></li>
<li><code><a title="vectorbt.data.base.Data.download_kwargs" href="base.html#vectorbt.data.base.Data.download_kwargs">download_kwargs</a></code></li>
<li><code><a title="vectorbt.data.base.Data.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.data.base.Data.from_data" href="base.html#vectorbt.data.base.Data.from_data">from_data</a></code></li>
<li><code><a title="vectorbt.data.base.Data.get" href="base.html#vectorbt.data.base.Data.get">get</a></code></li>
<li><code><a title="vectorbt.data.base.Data.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.data.base.Data.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.data.base.Data.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.data.base.Data.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.data.base.Data.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.data.base.Data.missing_columns" href="base.html#vectorbt.data.base.Data.missing_columns">missing_columns</a></code></li>
<li><code><a title="vectorbt.data.base.Data.missing_index" href="base.html#vectorbt.data.base.Data.missing_index">missing_index</a></code></li>
<li><code><a title="vectorbt.data.base.Data.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.data.base.Data.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.data.base.Data.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.data.base.Data.select_symbol_kwargs" href="base.html#vectorbt.data.base.Data.select_symbol_kwargs">select_symbol_kwargs</a></code></li>
<li><code><a title="vectorbt.data.base.Data.symbols" href="base.html#vectorbt.data.base.Data.symbols">symbols</a></code></li>
<li><code><a title="vectorbt.data.base.Data.tz_convert" href="base.html#vectorbt.data.base.Data.tz_convert">tz_convert</a></code></li>
<li><code><a title="vectorbt.data.base.Data.tz_localize" href="base.html#vectorbt.data.base.Data.tz_localize">tz_localize</a></code></li>
<li><code><a title="vectorbt.data.base.Data.update" href="base.html#vectorbt.data.base.Data.update">update</a></code></li>
<li><code><a title="vectorbt.data.base.Data.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.data.base.Data.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.data.base.Data.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.data.custom.YFData"><code class="flex name class">
<span>class <span class="ident parent-fname">YFData</span></span>
<span>(</span><span>wrapper, data, tz_localize=None, tz_convert=None, missing_index=None, missing_columns=None, download_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><code>Data</code> for data coming from <code>yfinance</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Sometimes <code>yfinance</code> returns a tz-naive datetime index. To produce a
tz-aware datetime index, pass <code>tz_localize</code> to <code><a title="vectorbt.data.custom.YFData.download" href="base.html#vectorbt.data.base.Data.download">Data.download()</a></code>. In this case,
you would need to find a timezone that fits the data (+0500, +0000, etc.)</p>
</div>
<h2 id="example">Example</h2>
<p>Fetch the business day except the last 5 minutes of trading data, and then update with the missing 5 minutes:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; yf_data = vbt.YFData.download(
...     &quot;TSLA&quot;,
...     start='2021-03-12 09:30:00 -0500',
...     end='2021-03-12 15:55:00 -0500',
...     interval='1m'
... )
&gt;&gt;&gt; yf_data.get()
                                 Open        High         Low       Close  \
Datetime
2021-03-12 09:30:00-05:00  670.000000  674.455811  667.510010  673.445007
2021-03-12 09:31:00-05:00  673.424988  674.455811  668.099976  669.599976
2021-03-12 09:32:00-05:00  669.270020  673.000000  668.239990  670.929993
...                               ...         ...         ...         ...
2021-03-12 15:52:00-05:00  690.630005  691.030029  690.380005  690.929993
2021-03-12 15:53:00-05:00  690.989990  692.200012  690.960022  692.039978
2021-03-12 15:54:00-05:00  692.000000  692.783875  691.929993  692.479980

                           Volume  Dividends  Stock Splits
Datetime
2021-03-12 09:30:00-05:00       0          0             0
2021-03-12 09:31:00-05:00  198906          0             0
2021-03-12 09:32:00-05:00  202002          0             0
...                           ...        ...           ...
2021-03-12 15:52:00-05:00   97941          0             0
2021-03-12 15:53:00-05:00  155552          0             0
2021-03-12 15:54:00-05:00  110320          0             0

[382 rows x 7 columns]

&gt;&gt;&gt; yf_data = yf_data.update(end='2021-03-12 16:00:00 -0500')
&gt;&gt;&gt; yf_data.get()
                                 Open        High         Low       Close  \
Datetime
2021-03-12 09:30:00-05:00  670.000000  674.455811  667.510010  673.445007
2021-03-12 09:31:00-05:00  673.424988  674.455811  668.099976  669.599976
2021-03-12 09:32:00-05:00  669.270020  673.000000  668.239990  670.929993
...                               ...         ...         ...         ...
2021-03-12 15:57:00-05:00  693.239990  693.599976  693.039978  693.250000
2021-03-12 15:58:00-05:00  693.255005  693.419983  692.640015  692.950012
2021-03-12 15:59:00-05:00  692.909973  694.099976  692.570007  693.840027

                           Volume  Dividends  Stock Splits
Datetime
2021-03-12 09:30:00-05:00       0          0             0
2021-03-12 09:31:00-05:00  198906          0             0
2021-03-12 09:32:00-05:00  202002          0             0
...                           ...        ...           ...
2021-03-12 15:57:00-05:00  136808          0             0
2021-03-12 15:58:00-05:00  104432          0             0
2021-03-12 15:59:00-05:00  192474          0             0

[387 rows x 7 columns]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class YFData(Data):
    &#34;&#34;&#34;`Data` for data coming from `yfinance`.

    !!! note
        Sometimes `yfinance` returns a tz-naive datetime index. To produce a
        tz-aware datetime index, pass `tz_localize` to `YFData.download`. In this case,
        you would need to find a timezone that fits the data (+0500, +0000, etc.)

    ## Example

    Fetch the business day except the last 5 minutes of trading data, and then update with the missing 5 minutes:

    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; yf_data = vbt.YFData.download(
    ...     &#34;TSLA&#34;,
    ...     start=&#39;2021-03-12 09:30:00 -0500&#39;,
    ...     end=&#39;2021-03-12 15:55:00 -0500&#39;,
    ...     interval=&#39;1m&#39;
    ... )
    &gt;&gt;&gt; yf_data.get()
                                     Open        High         Low       Close  \\
    Datetime
    2021-03-12 09:30:00-05:00  670.000000  674.455811  667.510010  673.445007
    2021-03-12 09:31:00-05:00  673.424988  674.455811  668.099976  669.599976
    2021-03-12 09:32:00-05:00  669.270020  673.000000  668.239990  670.929993
    ...                               ...         ...         ...         ...
    2021-03-12 15:52:00-05:00  690.630005  691.030029  690.380005  690.929993
    2021-03-12 15:53:00-05:00  690.989990  692.200012  690.960022  692.039978
    2021-03-12 15:54:00-05:00  692.000000  692.783875  691.929993  692.479980

                               Volume  Dividends  Stock Splits
    Datetime
    2021-03-12 09:30:00-05:00       0          0             0
    2021-03-12 09:31:00-05:00  198906          0             0
    2021-03-12 09:32:00-05:00  202002          0             0
    ...                           ...        ...           ...
    2021-03-12 15:52:00-05:00   97941          0             0
    2021-03-12 15:53:00-05:00  155552          0             0
    2021-03-12 15:54:00-05:00  110320          0             0

    [382 rows x 7 columns]

    &gt;&gt;&gt; yf_data = yf_data.update(end=&#39;2021-03-12 16:00:00 -0500&#39;)
    &gt;&gt;&gt; yf_data.get()
                                     Open        High         Low       Close  \\
    Datetime
    2021-03-12 09:30:00-05:00  670.000000  674.455811  667.510010  673.445007
    2021-03-12 09:31:00-05:00  673.424988  674.455811  668.099976  669.599976
    2021-03-12 09:32:00-05:00  669.270020  673.000000  668.239990  670.929993
    ...                               ...         ...         ...         ...
    2021-03-12 15:57:00-05:00  693.239990  693.599976  693.039978  693.250000
    2021-03-12 15:58:00-05:00  693.255005  693.419983  692.640015  692.950012
    2021-03-12 15:59:00-05:00  692.909973  694.099976  692.570007  693.840027

                               Volume  Dividends  Stock Splits
    Datetime
    2021-03-12 09:30:00-05:00       0          0             0
    2021-03-12 09:31:00-05:00  198906          0             0
    2021-03-12 09:32:00-05:00  202002          0             0
    ...                           ...        ...           ...
    2021-03-12 15:57:00-05:00  136808          0             0
    2021-03-12 15:58:00-05:00  104432          0             0
    2021-03-12 15:59:00-05:00  192474          0             0

    [387 rows x 7 columns]
    ```
    &#34;&#34;&#34;

    @classmethod
    def download_symbol(cls, symbol, period=&#39;max&#39;, start=None, end=None, **kwargs):
        &#34;&#34;&#34;Download the symbol.

        Args:
            symbol (str): Symbol.
            start (any): Start datetime.

                See `vectorbt.utils.datetime.to_tzaware_datetime`.
            end (any): End datetime.

                See `vectorbt.utils.datetime.to_tzaware_datetime`.
            **kwargs: Keyword arguments passed to `yfinance.base.TickerBase.history`.
        &#34;&#34;&#34;
        import yfinance as yf

        # yfinance still uses mktime, which assumes that the passed date is in local time
        if start is not None:
            start = to_tzaware_datetime(start, tz=get_local_tz())
        if end is not None:
            end = to_tzaware_datetime(end, tz=get_local_tz())

        return yf.Ticker(symbol).history(period=period, start=start, end=end, **kwargs)

    def update_symbol(self, symbol, **kwargs):
        &#34;&#34;&#34;Update the symbol.

        `**kwargs` will override keyword arguments passed to `YFData.download_symbol`.&#34;&#34;&#34;
        download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
        download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
        kwargs = merge_dicts(download_kwargs, kwargs)
        return self.download_symbol(symbol, **kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.data.base.Data" href="base.html#vectorbt.data.base.Data">Data</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.data.custom.YFData.download_symbol"><code class="name flex">
<span>def <span class="ident fname">download_symbol</span></span>(<span>symbol, period='max', start=None, end=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Download the symbol.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>symbol</code></strong> :&ensp;<code>str</code></dt>
<dd>Symbol.</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>any</code></dt>
<dd>
<p>Start datetime.</p>
<p>See <code><a title="vectorbt.utils.datetime.to_tzaware_datetime" href="../utils/datetime.html#vectorbt.utils.datetime.to_tzaware_datetime">to_tzaware_datetime()</a></code>.</p>
</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>any</code></dt>
<dd>
<p>End datetime.</p>
<p>See <code><a title="vectorbt.utils.datetime.to_tzaware_datetime" href="../utils/datetime.html#vectorbt.utils.datetime.to_tzaware_datetime">to_tzaware_datetime()</a></code>.</p>
</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code>yfinance.base.TickerBase.history</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def download_symbol(cls, symbol, period=&#39;max&#39;, start=None, end=None, **kwargs):
    &#34;&#34;&#34;Download the symbol.

    Args:
        symbol (str): Symbol.
        start (any): Start datetime.

            See `vectorbt.utils.datetime.to_tzaware_datetime`.
        end (any): End datetime.

            See `vectorbt.utils.datetime.to_tzaware_datetime`.
        **kwargs: Keyword arguments passed to `yfinance.base.TickerBase.history`.
    &#34;&#34;&#34;
    import yfinance as yf

    # yfinance still uses mktime, which assumes that the passed date is in local time
    if start is not None:
        start = to_tzaware_datetime(start, tz=get_local_tz())
    if end is not None:
        end = to_tzaware_datetime(end, tz=get_local_tz())

    return yf.Ticker(symbol).history(period=period, start=start, end=end, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.data.custom.YFData.update_symbol"><code class="name flex">
<span>def <span class="ident fname">update_symbol</span></span>(<span>self, symbol, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the symbol.</p>
<p><code>**kwargs</code> will override keyword arguments passed to <code><a title="vectorbt.data.custom.YFData.download_symbol" href="#vectorbt.data.custom.YFData.download_symbol">YFData.download_symbol()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_symbol(self, symbol, **kwargs):
    &#34;&#34;&#34;Update the symbol.

    `**kwargs` will override keyword arguments passed to `YFData.download_symbol`.&#34;&#34;&#34;
    download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)
    download_kwargs[&#39;start&#39;] = self.data[symbol].index[-1]
    kwargs = merge_dicts(download_kwargs, kwargs)
    return self.download_symbol(symbol, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.data.base.Data" href="base.html#vectorbt.data.base.Data">Data</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.data.base.Data.align_columns" href="base.html#vectorbt.data.base.Data.align_columns">align_columns</a></code></li>
<li><code><a title="vectorbt.data.base.Data.align_index" href="base.html#vectorbt.data.base.Data.align_index">align_index</a></code></li>
<li><code><a title="vectorbt.data.base.Data.concat" href="base.html#vectorbt.data.base.Data.concat">concat</a></code></li>
<li><code><a title="vectorbt.data.base.Data.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.data.base.Data.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.data.base.Data.data" href="base.html#vectorbt.data.base.Data.data">data</a></code></li>
<li><code><a title="vectorbt.data.base.Data.download" href="base.html#vectorbt.data.base.Data.download">download</a></code></li>
<li><code><a title="vectorbt.data.base.Data.download_kwargs" href="base.html#vectorbt.data.base.Data.download_kwargs">download_kwargs</a></code></li>
<li><code><a title="vectorbt.data.base.Data.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.data.base.Data.from_data" href="base.html#vectorbt.data.base.Data.from_data">from_data</a></code></li>
<li><code><a title="vectorbt.data.base.Data.get" href="base.html#vectorbt.data.base.Data.get">get</a></code></li>
<li><code><a title="vectorbt.data.base.Data.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.data.base.Data.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.data.base.Data.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.data.base.Data.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.data.base.Data.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.data.base.Data.missing_columns" href="base.html#vectorbt.data.base.Data.missing_columns">missing_columns</a></code></li>
<li><code><a title="vectorbt.data.base.Data.missing_index" href="base.html#vectorbt.data.base.Data.missing_index">missing_index</a></code></li>
<li><code><a title="vectorbt.data.base.Data.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.data.base.Data.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.data.base.Data.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.data.base.Data.select_symbol_kwargs" href="base.html#vectorbt.data.base.Data.select_symbol_kwargs">select_symbol_kwargs</a></code></li>
<li><code><a title="vectorbt.data.base.Data.symbols" href="base.html#vectorbt.data.base.Data.symbols">symbols</a></code></li>
<li><code><a title="vectorbt.data.base.Data.tz_convert" href="base.html#vectorbt.data.base.Data.tz_convert">tz_convert</a></code></li>
<li><code><a title="vectorbt.data.base.Data.tz_localize" href="base.html#vectorbt.data.base.Data.tz_localize">tz_localize</a></code></li>
<li><code><a title="vectorbt.data.base.Data.update" href="base.html#vectorbt.data.base.Data.update">update</a></code></li>
<li><code><a title="vectorbt.data.base.Data.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.data.base.Data.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.data.base.Data.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAOwAAADsAEnxA+tAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAADSJJREFUeJztXVtzW9UV/vY58k12Lo0dWwRIWgZaWlqgtMND3/vU1z73pTP9BX3oU2lpC0wIBAKEXKAJEC4l3KETSoaQYYAUW0qcxIotx0loxgRy9U2+STpn98FxKtuSzpH2d46W3fM9ZEbK0Tpn5E9rrb3WXt9W8MAlINEAfON1nR803gfEf8OwBOAeAN/lmPrV736Ms980U2z99u5v8fv7hxe++Ut0I477TW3n8mr23l/fN65dtd7UFgAopf9geV1kA+2MmwGAirMsAWjkmRqZjNFsdcbzC9+I42vE8TOG7T1vJ5KsPz6AiSbb2elJAAvoIN0Qqo1lCTQCuC4wnrU5xgAkWnML37gXQwAoN9j9ZuI7DDtz0Dt7e3tHPQmgmAQQ6AEmJmNwXMUxBiDRVkQAG9NYj58w7B45vqpvcsr+EcMWgLyt8RQAeBIAzBDQyrIEGgFGJnjuHwAS8SICfB9JAOsYdv+2Y9M4ww4AQKlX0unUecAHAVyiB7AEEmB0nEcAW2m0xwv/e+N2dDLsXh6JXTkz3EzJIwBo11Vb51/4CQE8D8DKAWLw57t8YIRIgM7WPGyl514k0AsLP2DYfWjXpj4ATQxbGjgwmO4+Pv/az9coLwcgrgBGiSFgQQJ4F2YYNguOyh/8Yu2dDFsAoIBHi1+HmwOwPABzCUj0ADcI0IKLaOMs/fZ90NnjuCrBsAUgOdCXPFz8hicBNMsDNACK9YdjegAiAbrmawB3ox9AA8Pm9tc2rGLYAQCt9ObF74W2DJSYAAIBeAALs+jCXQx7x061DUxkbcoyEsDZzJ23vbX4zdBCgMQlIACMTvCKQF1tOeB29ECBUq17cMfGKww7AKCht2D/fmfx+xUJoOfc2BrGA1AJQMmH5zAyRvHUAIBEax64g7PuvzYWuzZwLv5zhi0AV5us/Iul/qMiASbnihiUMhmVALy/GUaJZeCOm/MZxECp1m1+/tYTADgdKqW2nThxYrLUf1UkwKzUIhDRA4ySPICtNBK/yF1l2HJc5fzz03W3M2wBmHJn3e3l/rMiAaiNIIEeQGtgjOQB2tfkdWytprjs1w+sTxYcdQvDFjT+PjiYKptLeCWBMvsAJA+QnbJRcDiNoERXXoGUnm57ZQPH9QNOQeknKl1QkQDUTqDAVQBzCXhTR877Ih84NRQfGh2P3U0xBuwf6kudqXRBRQKs9EYQkwBdJAI8sH3TNyAl3q7GVq9rvDyAvBBgg9YIolYB2/PeF3lgPGuP9Z1uvY/wONAaHw+mk91e1y2/HIBZA2BWAdvNPcCWPbf2AqB8Uwruo95XeRNAXg4gtBNoGgJcF+47H7ffRnqckwPpox/5udCrEsghQAxQrF+uUAIkOsxCwDuHOpJ5R93KeBYNtRmA9nNtKDmA1CLQyBiHAJYFdK4z8wBbX7iZxcbhtib3H34vDiUESCwCAcBolvOdt6/NoyHm6wdXEmfOt3x1ZbThp4xnURqPp1Ip3+6oLAH03MYreY0gZiuY5AFME8A/PrPpPChLPzXiFpqeq+YTZQkwOef+OY0ggfMAAG8ZaJIAZqfs7LH+NsqvH9DPZjKfT1TzibIEoDaCmPMAzByAlAQmDGoAT+zbkNIajF0/s8rRT1f7obIEsCTuBQSoOcAYiQC1egCtofcf6NxIeQilX+zvT1U9w1kpCZS3GxigeYCJKRv5AqkRVCMBPvi0PZUrqO8RHkE7WnuWfUuhLAGojSCBHoBZBq61BrBlzy21Lx2KoIF3T/cd7a/ls2UJ4K7wqWBqI6iGVcDZ4ebzl642ULaOKyhfZd9SqOQBaASwmBNBpB1crCqgUkDnuuo9wJ+f3XQOhLaWAj4b6Ov5otbPL68cgFkEInmAdasLaGp0q/rMzKw11XNy1T2M+7saNf/6gbAIwPIAzL2AdawBPP3qhqTWWEu4fSaTTn5gYiD4EGATG0FMD8CqAdRAgJff77yJce/rc37VuZ9FqFQK5kwEMVcAAvcCVOsBDn6x9thMzrqDcOuL09m2l02NBB4CqCsAogdgEaDaKuAjz2/k7B1T+omvvjpsPIFckgDURpBQD1CPEDD8bdOFC5caGVvHJ5ptZwfBTmkCUBtBQlvBrE5gNTWAB3duPA3KQlbt6u3tHTW3U4YA/xcTQaS9AH6rgDM5a/qz1BrGpG/e1u42gh0AZQhAbQQJ3QtAWwb69AC7X08ktaYMjr46L/DEQLkkUN5mUIBGgMlpG7m8eYRbu7qA5iZ/q7C97yYo36mtVU1Nn3IoSQCxE0GkEBB2Avhpcs2JqRnrh6b3UxoH0umeXlM7xShJAGojSGASyFsC+iPAQ7s3lhzNrhYutFHZtxTKeQBeI4g5EURqBNH2AvpIAL+93HDxPxeaGEu/ZCad+oRgZwGWTw4gcB6g04cH+OuuTRTBKG3Q8q2E5UMAgWVgLw+QL6jcoe41DMGoczd1tC4ReGIg2BAgtRFEI0BlD7D37UQPQ95daTx2+PDhgveV1aNcKZgnDccS4qYWgTjJhBcBdr2RYLR8rzbYub0EOyURaAiQuAIAgNEQysBfHl+Vzk7ZDPf/VDmBJwaWEEDsRJCweYDVbQ7izeWLQH/ZtZFRq58qNDhlBZ4YWEIAsY0gYWXgSjWAyyOxK2fOt5gv/RT2DB07dtnYTgUsIcCs1CKQNAJUiP8P76bIuzu261YUeGJgCQGY0nASdYEATh2g3E6ggqPyH31uLu+ugTfS6aNDpna8UCoJlFcDAGgEmJ6xMJMzFxkqpwnEkne33domfarFkm9CpDAUIG4gpFwIoMi7K3Xo1KnUl8Z2fGAJAZjScBIJEGQnkCXvrl2zvf7VIFAPQNsRzGwEBbgZlCTvfjKT7vkXwY4vBJsDSDwjKKDt4Cx59+t7/SlDo35QigDydAGYsjCEENDa4qAtvvDsBZK8+7Clp30LPDFQKgRwPACzESTMAyTWL/z10+Tdld6aTqc5cwM+UaoULK8RJI0Ai+L//g/X9xDk3cdzjXje0EbVCCwESFwBAJwQsNgDbHuZIe+unzmbSo2Z26kOCwhwvRHEaGHKJQChE1jcBzg1FB8aGY+ZjnrPKmfuMOewsYAAWalnBAkbCCmuAv6JIO+uoV6qReCJgQUEyEktAgkbCZtfAo5n7bGT5vLuOqatUMq+pWAteiGzESRsKHS+CvjYC7cYy7srjffS6S9PGT9UjVicBMrsA5A8wEzOwsyseSMo0Z6D68J9+2CHsby7i/DKvqWw4NtY8RNBhCVgS7OL1W0ORd5dAd2ZdPJz44cywAICiG0ECdIGnD8ciiLvrvTDxjYMsdgDyJsIsjC3OCWAUQPoas+x5N0z/SdT7xk/kCHk5wDSagAdOYq8u9J6CwwFnhhYTAB5IUCYNFxLs84R5N0vTk+u2mf8MAQEkwRagGKdfUn0AGOT5psKDh5ZkyXIu29jCDwxsLgUzOsDCGwEXRs1zyYvX2s0VfmYRMHaafwgJAQSAlZyEcgYGjsHBropp4wzcIMAYhtBArUBDZC3oZ+s90MU4wYBxDaChM0DmEADrzEFnhi4QQCxjSDmMrDOHiCm1eN1fYASuEEAkUUgQNxuoJqh8CFb4ImBYgKsaA8wm7MwNUM6drwGaNffYc5hQz4BhEnD1QZ9PJM+Shd4YuAGAcRKwwkbCasFCtbDCHGvfzUo9onyCGCBd0bQOMlQ9TjX1dH6Zr1u7oVAQgBtJIyqCkIsKFQDhceDEnhioNgDyBsJoyqD1cUDXGtUuT31uLFf8JeBFqBaKJZWQhk4UIEnBopLwbwjYliNIIHagFVgqtDgPBP2TasFPQRIPSQqbAJo6L1BCzwxYAGAnsu1OdJwUg+JCjcEOLEaD3MOGxYAZOfiP6VMJvWQKJZCuB8oqLfCEHhiwALI0nBCPUCoSaDliGv6lIN1/R95NQBApEK4D3zSf+Lov8O6mSksgNwHEHhUfL6gMDUTTh3AVfWd9KkW8wSQJwsD8JTBxmPQ4VTi+wZPJj8M5U4kWIDgiSBWIyik+K90uAJPDMx/MzIbQaS/Wzg1AP21hZnXQrgRFfQcgLYbaPltBQtd4ImB+bW/PA+wvAgwnmvCc0HfJAhwPQCzEbSc9gJqtb0eAk8MzJeC5TWCls928FldKNRF4IkBagiQOhEUZAjQwL5M5tiFwG4QMKzrjaAVPREUoAfQMW0vm7JvKVjXJ4I4jSCBNQAgwBxA4f16CjwxYM1KLQItg91Arss/zDlsWMxGkNQQEEQrWAHdg+nUZ3TDIcMSOxJG8gAFRyE7HUQjyHokAKOhwxI7ESS5EaQx2N/X/S7Zal1grfRGUCAJoKUegwCBJwYscEMA57dGnAjidwLVpWxb7CWy0bqBmgOodkxQDDWCVlEcGYuRf6n6yeEjR6a5NuuHmAYOAbhEsebABuB4XueFGGzMuVhjj5KdtBytFS0LjCG2g2UrQoQIESJEiBAhQoQIESJEiBAhQoQIESJEiBAhQoQIESJECAj/BQOpOG9o03XTAAAAAElFTkSuQmCC"/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.data" href="index.html">vectorbt.data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.data.custom.generate_gbm_paths" href="#vectorbt.data.custom.generate_gbm_paths">generate_gbm_paths</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.data.custom.BinanceData" href="#vectorbt.data.custom.BinanceData">BinanceData</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.data.custom.BinanceData.download" href="#vectorbt.data.custom.BinanceData.download">download</a></code></li>
<li><code><a title="vectorbt.data.custom.BinanceData.download_symbol" href="#vectorbt.data.custom.BinanceData.download_symbol">download_symbol</a></code></li>
<li><code><a title="vectorbt.data.custom.BinanceData.update_symbol" href="#vectorbt.data.custom.BinanceData.update_symbol">update_symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.data.custom.CCXTData" href="#vectorbt.data.custom.CCXTData">CCXTData</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.data.custom.CCXTData.download_symbol" href="#vectorbt.data.custom.CCXTData.download_symbol">download_symbol</a></code></li>
<li><code><a title="vectorbt.data.custom.CCXTData.update_symbol" href="#vectorbt.data.custom.CCXTData.update_symbol">update_symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.data.custom.GBMData" href="#vectorbt.data.custom.GBMData">GBMData</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.data.custom.GBMData.generate_symbol" href="#vectorbt.data.custom.GBMData.generate_symbol">generate_symbol</a></code></li>
<li><code><a title="vectorbt.data.custom.GBMData.update_symbol" href="#vectorbt.data.custom.GBMData.update_symbol">update_symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.data.custom.SyntheticData" href="#vectorbt.data.custom.SyntheticData">SyntheticData</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.data.custom.SyntheticData.download_symbol" href="#vectorbt.data.custom.SyntheticData.download_symbol">download_symbol</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.generate_symbol" href="#vectorbt.data.custom.SyntheticData.generate_symbol">generate_symbol</a></code></li>
<li><code><a title="vectorbt.data.custom.SyntheticData.update_symbol" href="#vectorbt.data.custom.SyntheticData.update_symbol">update_symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.data.custom.YFData" href="#vectorbt.data.custom.YFData">YFData</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.data.custom.YFData.download_symbol" href="#vectorbt.data.custom.YFData.download_symbol">download_symbol</a></code></li>
<li><code><a title="vectorbt.data.custom.YFData.update_symbol" href="#vectorbt.data.custom.YFData.update_symbol">update_symbol</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>