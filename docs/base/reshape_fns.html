<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.base.reshape_fns API documentation</title>
<meta name="description" content="Functions for reshaping arrays â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#31353f}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #31353f}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #31353f;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#31353f}#sidebar{background:#3B4556}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#31353f}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#31353f">
<meta name="theme-color" content="#31353f">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.base.reshape_fns</code></h1>
</header>
<section id="section-intro">
<p>Functions for reshaping arrays.</p>
<p>Reshape functions transform a pandas object/NumPy array in some way, such as tiling, broadcasting,
and unstacking.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions for reshaping arrays.

Reshape functions transform a pandas object/NumPy array in some way, such as tiling, broadcasting,
and unstacking.&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit

from vectorbt.utils import checks
from vectorbt.base import index_fns, array_wrapper


def soft_to_ndim(arg, ndim):
    &#34;&#34;&#34;Try to softly bring `arg` to the specified number of dimensions `ndim` (max 2).&#34;&#34;&#34;
    if not checks.is_any_array(arg):
        arg = np.asarray(arg)
    if ndim == 1:
        if arg.ndim == 2:
            if arg.shape[1] == 1:
                if checks.is_frame(arg):
                    return arg.iloc[:, 0]
                return arg[:, 0]  # downgrade
    if ndim == 2:
        if arg.ndim == 1:
            if checks.is_series(arg):
                return arg.to_frame()
            return arg[:, None]  # upgrade
    return arg  # do nothing


def to_1d(arg, raw=False):
    &#34;&#34;&#34;Reshape argument to one dimension. 

    If `raw` is True, returns NumPy array.
    If 2-dim, will collapse along axis 1 (i.e., DataFrame with one column to Series).&#34;&#34;&#34;
    if raw or not checks.is_any_array(arg):
        arg = np.asarray(arg)
    if arg.ndim == 2:
        if arg.shape[1] == 1:
            if checks.is_frame(arg):
                return arg.iloc[:, 0]
            return arg[:, 0]
    if arg.ndim == 1:
        return arg
    elif arg.ndim == 0:
        return arg.reshape((1,))
    raise ValueError(f&#34;Cannot reshape a {arg.ndim}-dimensional array to 1 dimension&#34;)


def to_2d(arg, raw=False, expand_axis=1):
    &#34;&#34;&#34;Reshape argument to two dimensions. 

    If `raw` is True, returns NumPy array.
    If 1-dim, will expand along axis 1 (i.e., Series to DataFrame with one column).&#34;&#34;&#34;
    if raw or not checks.is_any_array(arg):
        arg = np.asarray(arg)
    if arg.ndim == 2:
        return arg
    elif arg.ndim == 1:
        if checks.is_series(arg):
            if expand_axis == 0:
                return pd.DataFrame(arg.values[None, :], columns=arg.index)
            elif expand_axis == 1:
                return arg.to_frame()
        return np.expand_dims(arg, expand_axis)
    elif arg.ndim == 0:
        return arg.reshape((1, 1))
    raise ValueError(f&#34;Cannot reshape a {arg.ndim}-dimensional array to 2 dimensions&#34;)


def repeat(arg, n, axis=1):
    &#34;&#34;&#34;Repeat each element in `arg` `n` times along the specified axis.&#34;&#34;&#34;
    if not checks.is_any_array(arg):
        arg = np.asarray(arg)
    if axis == 0:
        if checks.is_pandas(arg):
            return array_wrapper.ArrayWrapper.from_obj(arg).wrap(
                np.repeat(arg.values, n, axis=0), index=index_fns.repeat_index(arg.index, n))
        return np.repeat(arg, n, axis=0)
    elif axis == 1:
        arg = to_2d(arg)
        if checks.is_pandas(arg):
            return array_wrapper.ArrayWrapper.from_obj(arg).wrap(
                np.repeat(arg.values, n, axis=1), columns=index_fns.repeat_index(arg.columns, n))
        return np.repeat(arg, n, axis=1)
    else:
        raise ValueError(&#34;Only axis 0 and 1 are supported&#34;)


def tile(arg, n, axis=1):
    &#34;&#34;&#34;Repeat the whole `arg` `n` times along the specified axis.&#34;&#34;&#34;
    if not checks.is_any_array(arg):
        arg = np.asarray(arg)
    if axis == 0:
        if arg.ndim == 2:
            if checks.is_pandas(arg):
                return array_wrapper.ArrayWrapper.from_obj(arg).wrap(
                    np.tile(arg.values, (n, 1)), index=index_fns.tile_index(arg.index, n))
            return np.tile(arg, (n, 1))
        if checks.is_pandas(arg):
            return array_wrapper.ArrayWrapper.from_obj(arg).wrap(
                np.tile(arg.values, n), index=index_fns.tile_index(arg.index, n))
        return np.tile(arg, n)
    elif axis == 1:
        arg = to_2d(arg)
        if checks.is_pandas(arg):
            return array_wrapper.ArrayWrapper.from_obj(arg).wrap(
                np.tile(arg.values, (1, n)), columns=index_fns.tile_index(arg.columns, n))
        return np.tile(arg, (1, n))
    else:
        raise ValueError(&#34;Only axis 0 and 1 are supported&#34;)


def broadcast_index(args, to_shape, index_from=None, axis=0, ignore_sr_names=None, **kwargs):
    &#34;&#34;&#34;Produce a broadcast index/columns.

    Args:
        *args (array_like): Array-like objects.
        to_shape (tuple): Target shape.
        index_from (None, int, str or array_like): Broadcasting rule for this index/these columns.

            Accepts the following values:

            * &#39;default&#39; - take the value from `vectorbt.settings.broadcasting`
            * &#39;strict&#39; - ensure that all pandas objects have the same index/columns
            * &#39;stack&#39; - stack different indexes/columns using `vectorbt.base.index_fns.stack_indexes`
            * &#39;ignore&#39; - ignore any index/columns
            * integer - use the index/columns of the i-nth object in `args`
            * None - use the original index/columns of the objects in `args`
            * everything else will be converted to `pd.Index`

        axis (int): Set to 0 for index and 1 for columns.
        ignore_sr_names (bool): Whether to ignore Series names if they are in conflict.

            Conflicting Series names are those that are different but not None.
        **kwargs: Keyword arguments passed to `vectorbt.base.index_fns.stack_indexes`.

    For defaults, see `vectorbt.settings.broadcasting`.

    !!! note
        Series names are treated as columns with a single element but without a name.
        If a column level without a name loses its meaning, better to convert Series to DataFrames
        with one column prior to broadcasting. If the name of a Series is not that important,
        better to drop it altogether by setting it to None.
    &#34;&#34;&#34;
    from vectorbt import settings

    if ignore_sr_names is None:
        ignore_sr_names = settings.broadcasting[&#39;ignore_sr_names&#39;]
    index_str = &#39;columns&#39; if axis == 1 else &#39;index&#39;
    to_shape_2d = (to_shape[0], 1) if len(to_shape) == 1 else to_shape
    # maxlen stores the length of the longest index
    maxlen = to_shape_2d[1] if axis == 1 else to_shape_2d[0]
    new_index = None

    if index_from is not None:
        if isinstance(index_from, int):
            # Take index/columns of the object indexed by index_from
            if not checks.is_pandas(args[index_from]):
                raise TypeError(f&#34;Argument under index {index_from} must be a pandas object&#34;)
            new_index = index_fns.get_index(args[index_from], axis)
        elif isinstance(index_from, str):
            if index_from == &#39;ignore&#39;:
                # Ignore index/columns
                new_index = pd.RangeIndex(start=0, stop=maxlen, step=1)
            elif index_from in (&#39;stack&#39;, &#39;strict&#39;):
                # Check whether all indexes/columns are equal
                last_index = None  # of type pd.Index
                index_conflict = False
                for arg in args:
                    if checks.is_pandas(arg):
                        index = index_fns.get_index(arg, axis)
                        if last_index is not None:
                            if not pd.Index.equals(index, last_index):
                                index_conflict = True
                        last_index = index
                        continue
                if not index_conflict:
                    new_index = last_index
                else:
                    # If pandas objects have different index/columns, stack them together
                    for arg in args:
                        if checks.is_pandas(arg):
                            index = index_fns.get_index(arg, axis)
                            if axis == 1 and checks.is_series(arg) and ignore_sr_names:
                                # ignore Series name
                                continue
                            if checks.is_default_index(index):
                                # ignore simple ranges without name
                                continue
                            if new_index is None:
                                new_index = index
                            else:
                                if index_from == &#39;strict&#39;:
                                    # If pandas objects have different index/columns, raise an exception
                                    if not pd.Index.equals(index, new_index):
                                        raise ValueError(
                                            f&#34;Broadcasting {index_str} is not allowed when {index_str}_from=strict&#34;)
                                # Broadcasting index must follow the rules of a regular broadcasting operation
                                # https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html#general-broadcasting-rules
                                # 1. rule: if indexes are of the same length, they are simply stacked
                                # 2. rule: if index has one element, it gets repeated and then stacked

                                if pd.Index.equals(index, new_index):
                                    continue
                                if len(index) != len(new_index):
                                    if len(index) &gt; 1 and len(new_index) &gt; 1:
                                        raise ValueError(&#34;Indexes could not be broadcast together&#34;)
                                    if len(index) &gt; len(new_index):
                                        new_index = index_fns.repeat_index(new_index, len(index))
                                    elif len(index) &lt; len(new_index):
                                        index = index_fns.repeat_index(index, len(new_index))
                                new_index = index_fns.stack_indexes([new_index, index], **kwargs)
            else:
                raise ValueError(f&#34;Invalid value {index_from} for {&#39;columns&#39; if axis == 1 else &#39;index&#39;}_from&#34;)
        else:
            new_index = index_from
        if new_index is not None:
            if maxlen &gt; len(new_index):
                if index_from == &#39;strict&#39;:
                    raise ValueError(f&#34;Broadcasting {index_str} is not allowed when {index_str}_from=strict&#34;)
                # This happens only when some numpy object is longer than the new pandas index
                # In this case, new pandas index (one element) should be repeated to match this length.
                if maxlen &gt; 1 and len(new_index) &gt; 1:
                    raise ValueError(&#34;Indexes could not be broadcast together&#34;)
                new_index = index_fns.repeat_index(new_index, maxlen)
        else:
            # new_index=None can mean two things: 1) take original metadata or 2) reset index/columns
            # In case when index_from is not None, we choose 2)
            new_index = pd.RangeIndex(start=0, stop=maxlen, step=1)
    return new_index


def wrap_broadcasted(old_arg, new_arg, is_pd=False, new_index=None, new_columns=None):
    &#34;&#34;&#34;If the newly brodcasted array was originally a pandas object, make it pandas object again 
    and assign it the newly broadcast index/columns.&#34;&#34;&#34;
    if is_pd:
        if checks.is_pandas(old_arg):
            if new_index is None:
                # Take index from original pandas object
                old_index = index_fns.get_index(old_arg, 0)
                if old_arg.shape[0] == new_arg.shape[0]:
                    new_index = old_index
                else:
                    new_index = index_fns.repeat_index(old_index, new_arg.shape[0])
            if new_columns is None:
                # Take columns from original pandas object
                old_columns = index_fns.get_index(old_arg, 1)
                new_ncols = new_arg.shape[1] if new_arg.ndim == 2 else 1
                if len(old_columns) == new_ncols:
                    new_columns = old_columns
                else:
                    new_columns = index_fns.repeat_index(old_columns, new_ncols)
        if new_arg.ndim == 2:
            return pd.DataFrame(new_arg, index=new_index, columns=new_columns)
        if new_columns is not None and len(new_columns) == 1:
            name = new_columns[0]
            if name == 0:
                name = None
        else:
            name = None
        return pd.Series(new_arg, index=new_index, name=name)
    return new_arg


def broadcast(*args, to_shape=None, to_pd=None, to_frame=None, align_index=None, align_columns=None,
              index_from=&#39;default&#39;, columns_from=&#39;default&#39;, require_kwargs=None, keep_raw=False,
              return_meta=False, **kwargs):
    &#34;&#34;&#34;Bring any array-like object in `args` to the same shape by using NumPy broadcasting.

    See [Broadcasting](https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html).

    Can broadcast pandas objects by broadcasting their index/columns with `broadcast_index`.

    Args:
        *args (array_like): Array-like objects.
        to_shape (tuple): Target shape. If set, will broadcast every element in `args` to `to_shape`.
        to_pd (bool, tuple or list): Whether to convert all output arrays to pandas, otherwise returns
            raw NumPy arrays. If None, converts only if there is at least one pandas object among them.
        to_frame (bool): Whether to convert all Series to DataFrames.
        align_index (bool): Whether to align index of pandas objects using multi-index.
        align_columns (bool): Whether to align columns of pandas objects using multi-index.
        index_from (any): Broadcasting rule for index.
        columns_from (any): Broadcasting rule for columns.
        require_kwargs (dict or list of dict): Keyword arguments passed to `np.require`.
        keep_raw (bool, tuple or list): Whether to keep the unbroadcasted version of the array.

            Only makes sure that the array can be broadcast to the target shape.
        return_meta (bool): If True, will also return new shape, index and columns.
        **kwargs: Keyword arguments passed to `broadcast_index`.

    For defaults, see `vectorbt.settings.broadcasting`.

    ## Example

    Without broadcasting index and columns:
    ```python-repl
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from vectorbt.base.reshape_fns import broadcast

    &gt;&gt;&gt; v = 0
    &gt;&gt;&gt; a = np.array([1, 2, 3])
    &gt;&gt;&gt; sr = pd.Series([1, 2, 3], index=pd.Index([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]), name=&#39;a&#39;)
    &gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],
    ...     index=pd.Index([&#39;x2&#39;, &#39;y2&#39;, &#39;z2&#39;]),
    ...     columns=pd.Index([&#39;a2&#39;, &#39;b2&#39;, &#39;c2&#39;]))

    &gt;&gt;&gt; for i in broadcast(
    ...     v, a, sr, df,
    ...     index_from=None,
    ...     columns_from=None,
    ... ): print(i)
       0  1  2
    0  0  0  0
    1  0  0  0
    2  0  0  0
       0  1  2
    0  1  2  3
    1  1  2  3
    2  1  2  3
       a  a  a
    x  1  1  1
    y  2  2  2
    z  3  3  3
        a2  b2  c2
    x2   1   2   3
    y2   4   5   6
    z2   7   8   9
    ```

    Taking new index and columns from position:
    ```python-repl
    &gt;&gt;&gt; for i in broadcast(
    ...     v, a, sr, df,
    ...     index_from=2,
    ...     columns_from=3
    ... ): print(i)
       a2  b2  c2
    x   0   0   0
    y   0   0   0
    z   0   0   0
       a2  b2  c2
    x   1   2   3
    y   1   2   3
    z   1   2   3
       a2  b2  c2
    x   1   1   1
    y   2   2   2
    z   3   3   3
       a2  b2  c2
    x   1   2   3
    y   4   5   6
    z   7   8   9
    ```

    Broadcasting index and columns through stacking:
    ```python-repl
    &gt;&gt;&gt; for i in broadcast(
    ...     v, a, sr, df,
    ...     index_from=&#39;stack&#39;,
    ...     columns_from=&#39;stack&#39;
    ... ): print(i)
          a2  b2  c2
    x x2   0   0   0
    y y2   0   0   0
    z z2   0   0   0
          a2  b2  c2
    x x2   1   2   3
    y y2   1   2   3
    z z2   1   2   3
          a2  b2  c2
    x x2   1   1   1
    y y2   2   2   2
    z z2   3   3   3
          a2  b2  c2
    x x2   1   2   3
    y y2   4   5   6
    z z2   7   8   9
    ```

    Setting index and columns manually:
    ```python-repl
    &gt;&gt;&gt; for i in broadcast(
    ...     v, a, sr, df,
    ...     index_from=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
    ...     columns_from=[&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
    ... ): print(i)
       d  e  f
    a  0  0  0
    b  0  0  0
    c  0  0  0
       d  e  f
    a  1  2  3
    b  1  2  3
    c  1  2  3
       d  e  f
    a  1  1  1
    b  2  2  2
    c  3  3  3
       d  e  f
    a  1  2  3
    b  4  5  6
    c  7  8  9
    ```
    &#34;&#34;&#34;
    from vectorbt import settings

    is_pd = False
    is_2d = False
    args = list(args)
    if require_kwargs is None:
        require_kwargs = {}
    if align_index is None:
        align_index = settings.broadcasting[&#39;align_index&#39;]
    if align_columns is None:
        align_columns = settings.broadcasting[&#39;align_columns&#39;]
    if isinstance(index_from, str) and index_from == &#39;default&#39;:
        index_from = settings.broadcasting[&#39;index_from&#39;]
    if isinstance(columns_from, str) and columns_from == &#39;default&#39;:
        columns_from = settings.broadcasting[&#39;columns_from&#39;]

    # Convert to np.ndarray object if not numpy or pandas
    # Also check whether we broadcast to pandas and whether work on 2-dim data
    for i in range(len(args)):
        if not checks.is_any_array(args[i]):
            args[i] = np.asarray(args[i])
        if args[i].ndim &gt; 1:
            is_2d = True
        if checks.is_pandas(args[i]):
            is_pd = True

    # If target shape specified, check again if we work on 2-dim data
    if to_shape is not None:
        if isinstance(to_shape, int):
            to_shape = (to_shape,)
        checks.assert_type(to_shape, tuple)
        if len(to_shape) &gt; 1:
            is_2d = True

    if to_frame is not None:
        # force either keeping Series or converting them to DataFrames
        is_2d = to_frame

    if to_pd is not None:
        # force either raw or pandas
        if isinstance(to_pd, (tuple, list)):
            is_pd = any(to_pd)
        else:
            is_pd = to_pd

    # Align pandas objects
    if align_index:
        index_to_align = []
        for i in range(len(args)):
            if checks.is_pandas(args[i]) and len(args[i].index) &gt; 1:
                index_to_align.append(i)
        if len(index_to_align) &gt; 1:
            indexes = [args[i].index for i in index_to_align]
            if len(set(map(len, indexes))) &gt; 1:
                index_indices = index_fns.align_indexes(indexes)
                for i in range(len(args)):
                    if i in index_to_align:
                        args[i] = args[i].iloc[index_indices[index_to_align.index(i)]]
    if align_columns:
        cols_to_align = []
        for i in range(len(args)):
            if checks.is_frame(args[i]) and len(args[i].columns) &gt; 1:
                cols_to_align.append(i)
        if len(cols_to_align) &gt; 1:
            indexes = [args[i].columns for i in cols_to_align]
            if len(set(map(len, indexes))) &gt; 1:
                col_indices = index_fns.align_indexes(indexes)
                for i in range(len(args)):
                    if i in cols_to_align:
                        args[i] = args[i].iloc[:, col_indices[cols_to_align.index(i)]]

    # Convert all pd.Series objects to pd.DataFrame if we work on 2-dim data
    args_2d = [arg.to_frame() if is_2d and checks.is_series(arg) else arg for arg in args]

    # Get final shape
    if to_shape is None:
        to_shape = np.lib.stride_tricks._broadcast_shape(*args_2d)

    # Perform broadcasting
    new_args = []
    for i, arg in enumerate(args_2d):
        if isinstance(keep_raw, (tuple, list)):
            _keep_raw = keep_raw[i]
        else:
            _keep_raw = keep_raw
        bc_arg = np.broadcast_to(arg, to_shape)
        if _keep_raw:
            new_args.append(arg)
            continue
        new_args.append(bc_arg)

    # Force to match requirements
    for i in range(len(new_args)):
        if isinstance(require_kwargs, (tuple, list)):
            _require_kwargs = require_kwargs[i]
        else:
            _require_kwargs = require_kwargs
        new_args[i] = np.require(new_args[i], **_require_kwargs)

    if is_pd:
        # Decide on index and columns
        # NOTE: Important to pass args, not args_2d, to preserve original shape info
        new_index = broadcast_index(args, to_shape, index_from=index_from, axis=0, **kwargs)
        new_columns = broadcast_index(args, to_shape, index_from=columns_from, axis=1, **kwargs)
    else:
        new_index, new_columns = None, None

    # Bring arrays to their old types (e.g. array -&gt; pandas)
    for i in range(len(new_args)):
        if isinstance(keep_raw, (tuple, list)):
            _keep_raw = keep_raw[i]
        else:
            _keep_raw = keep_raw
        if _keep_raw:
            continue
        if isinstance(to_pd, (tuple, list)):
            _is_pd = to_pd[i]
        else:
            _is_pd = is_pd
        new_args[i] = wrap_broadcasted(
            args[i],
            new_args[i],
            is_pd=_is_pd,
            new_index=new_index,
            new_columns=new_columns
        )

    if len(new_args) &gt; 1:
        if return_meta:
            return tuple(new_args), to_shape, new_index, new_columns
        return tuple(new_args)
    if return_meta:
        return new_args[0], to_shape, new_index, new_columns
    return new_args[0]


def broadcast_to(arg1, arg2, to_pd=None, index_from=None, columns_from=None, **kwargs):
    &#34;&#34;&#34;Broadcast `arg1` to `arg2`.

    Keyword arguments `**kwargs` are passed to `broadcast`.

    ## Example

    ```python-repl
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from vectorbt.base.reshape_fns import broadcast_to

    &gt;&gt;&gt; a = np.array([1, 2, 3])
    &gt;&gt;&gt; sr = pd.Series([4, 5, 6], index=pd.Index([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]), name=&#39;a&#39;)

    &gt;&gt;&gt; broadcast_to(a, sr)
    x    1
    y    2
    z    3
    Name: a, dtype: int64

    &gt;&gt;&gt; broadcast_to(sr, a)
    array([4, 5, 6])
    ```
    &#34;&#34;&#34;
    if not checks.is_any_array(arg1):
        arg1 = np.asarray(arg1)
    if not checks.is_any_array(arg2):
        arg2 = np.asarray(arg2)
    if to_pd is None:
        to_pd = checks.is_pandas(arg2)
    if to_pd:
        # Take index and columns from arg2
        if index_from is None:
            index_from = index_fns.get_index(arg2, 0)
        if columns_from is None:
            columns_from = index_fns.get_index(arg2, 1)
    return broadcast(arg1, to_shape=arg2.shape, to_pd=to_pd, index_from=index_from, columns_from=columns_from, **kwargs)


def broadcast_to_array_of(arg1, arg2):
    &#34;&#34;&#34;Broadcast `arg1` to the shape `(1, *arg2.shape)`.

    `arg1` must be either a scalar, a 1-dim array, or have 1 dimension more than `arg2`.

    ## Example

    ```python-repl
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from vectorbt.base.reshape_fns import broadcast_to_array_of

    &gt;&gt;&gt; broadcast_to_array_of([0.1, 0.2], np.empty((2, 2)))
    [[[0.1 0.1]
      [0.1 0.1]]

     [[0.2 0.2]
      [0.2 0.2]]]
    ```
    &#34;&#34;&#34;
    arg1 = np.asarray(arg1)
    arg2 = np.asarray(arg2)
    if arg1.ndim == arg2.ndim + 1:
        if arg1.shape[1:] == arg2.shape:
            return arg1
    # From here on arg1 can be only a 1-dim array
    if arg1.ndim == 0:
        arg1 = to_1d(arg1)
    checks.assert_ndim(arg1, 1)

    if arg2.ndim == 0:
        return arg1
    for i in range(arg2.ndim):
        arg1 = np.expand_dims(arg1, axis=-1)
    return np.tile(arg1, (1, *arg2.shape))


def broadcast_to_axis_of(arg1, arg2, axis, require_kwargs=None):
    &#34;&#34;&#34;Broadcast `arg1` to an axis of `arg2`.

    If `arg2` has less dimensions than requested, will broadcast `arg1` to a single number.

    For other keyword arguments, see `broadcast`.&#34;&#34;&#34;
    if require_kwargs is None:
        require_kwargs = {}
    if not checks.is_any_array(arg2):
        arg2 = np.asarray(arg2)
    if arg2.ndim &lt; axis + 1:
        return np.broadcast_to(arg1, (1,))[0]  # to a single number
    arg1 = np.broadcast_to(arg1, (arg2.shape[axis],))
    arg1 = np.require(arg1, **require_kwargs)
    return arg1


def unstack_to_array(arg, levels=None):
    &#34;&#34;&#34;Reshape `arg` based on its multi-index into a multi-dimensional array.

    Use `levels` to specify what index levels to unstack and in which order.

    ## Example

    ```python-repl
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from vectorbt.base.reshape_fns import unstack_to_array

    &gt;&gt;&gt; index = pd.MultiIndex.from_arrays(
    ...     [[1, 1, 2, 2], [3, 4, 3, 4], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]])
    &gt;&gt;&gt; sr = pd.Series([1, 2, 3, 4], index=index)

    &gt;&gt;&gt; unstack_to_array(sr).shape
    (2, 2, 4)

    &gt;&gt;&gt; unstack_to_array(sr)
    [[[ 1. nan nan nan]
     [nan  2. nan nan]]

     [[nan nan  3. nan]
    [nan nan nan  4.]]]

    &gt;&gt;&gt; unstack_to_array(sr, levels=(2, 0))
    [[ 1. nan]
     [ 2. nan]
     [nan  3.]
     [nan  4.]]
    ```
    &#34;&#34;&#34;
    checks.assert_type(arg, pd.Series)
    checks.assert_type(arg.index, pd.MultiIndex)
    if arg.index.duplicated().any():
        raise ValueError(&#34;Index contains duplicate entries, cannot reshape&#34;)

    unique_idx_list = []
    vals_idx_list = []
    if levels is None:
        levels = range(arg.index.nlevels)
    for level in levels:
        vals = index_fns.select_levels(arg.index, level).to_numpy()
        unique_vals = np.unique(vals)
        unique_idx_list.append(unique_vals)
        idx_map = dict(zip(unique_vals, range(len(unique_vals))))
        vals_idx = list(map(lambda x: idx_map[x], vals))
        vals_idx_list.append(vals_idx)

    a = np.full(list(map(len, unique_idx_list)), np.nan)
    a[tuple(zip(vals_idx_list))] = arg.values
    return a


def make_symmetric(arg, sort=True):
    &#34;&#34;&#34;Make `arg` symmetric.

    The index and columns of the resulting DataFrame will be identical.

    Requires the index and columns to have the same number of levels.

    Pass `sort=False` if index and columns should not be sorted, but concatenated
    and get duplicates removed.

    ## Example

    ```python-repl
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from vectorbt.base.reshape_fns import make_symmetric

    &gt;&gt;&gt; df = pd.DataFrame([[1, 2], [3, 4]], index=[&#39;a&#39;, &#39;b&#39;], columns=[&#39;c&#39;, &#39;d&#39;])

    &gt;&gt;&gt; make_symmetric(df)
         a    b    c    d
    a  NaN  NaN  1.0  2.0
    b  NaN  NaN  3.0  4.0
    c  1.0  3.0  NaN  NaN
    d  2.0  4.0  NaN  NaN
    ```
    &#34;&#34;&#34;
    checks.assert_type(arg, (pd.Series, pd.DataFrame))
    arg = to_2d(arg)
    if isinstance(arg.index, pd.MultiIndex) or isinstance(arg.columns, pd.MultiIndex):
        checks.assert_type(arg.index, pd.MultiIndex)
        checks.assert_type(arg.columns, pd.MultiIndex)
        checks.assert_array_equal(arg.index.nlevels, arg.columns.nlevels)
        names1, names2 = tuple(arg.index.names), tuple(arg.columns.names)
    else:
        names1, names2 = arg.index.name, arg.columns.name

    if names1 == names2:
        new_name = names1
    else:
        if isinstance(arg.index, pd.MultiIndex):
            new_name = tuple(zip(*[names1, names2]))
        else:
            new_name = (names1, names2)
    if sort:
        idx_vals = np.unique(np.concatenate((arg.index, arg.columns))).tolist()
    else:
        idx_vals = list(dict.fromkeys(np.concatenate((arg.index, arg.columns))))
    arg = arg.copy()
    if isinstance(arg.index, pd.MultiIndex):
        unique_index = pd.MultiIndex.from_tuples(idx_vals, names=new_name)
        arg.index.names = new_name
        arg.columns.names = new_name
    else:
        unique_index = pd.Index(idx_vals, name=new_name)
        arg.index.name = new_name
        arg.columns.name = new_name
    df_out = pd.DataFrame(index=unique_index, columns=unique_index)
    df_out.loc[:, :] = arg
    df_out[df_out.isnull()] = arg.transpose()
    return df_out


def unstack_to_df(arg, index_levels=None, column_levels=None, symmetric=False, sort=True):
    &#34;&#34;&#34;Reshape `arg` based on its multi-index into a DataFrame.

    Use `index_levels` to specify what index levels will form new index, and `column_levels` 
    for new columns. Set `symmetric` to True to make DataFrame symmetric.

    ## Example

    ```python-repl
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from vectorbt.base.reshape_fns import unstack_to_df

    &gt;&gt;&gt; index = pd.MultiIndex.from_arrays(
    ...     [[1, 1, 2, 2], [3, 4, 3, 4], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]],
    ...     names=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])
    &gt;&gt;&gt; sr = pd.Series([1, 2, 3, 4], index=index)

    &gt;&gt;&gt; unstack_to_df(sr, index_levels=(0, 1), column_levels=2)
    z      a    b    c    d
    x y
    1 3  1.0  NaN  NaN  NaN
    1 4  NaN  2.0  NaN  NaN
    2 3  NaN  NaN  3.0  NaN
    2 4  NaN  NaN  NaN  4.0
    ```
    &#34;&#34;&#34;
    # Perform checks
    checks.assert_type(arg, (pd.Series, pd.DataFrame))
    if checks.is_frame(arg):
        if arg.shape[0] == 1:
            arg = arg.iloc[0, :]
        elif arg.shape[1] == 1:
            arg = arg.iloc[:, 0]
    checks.assert_type(arg.index, pd.MultiIndex)
    sr = to_1d(arg)

    if len(sr.index.levels) &gt; 2:
        if index_levels is None:
            raise ValueError(&#34;index_levels must be specified&#34;)
        if column_levels is None:
            raise ValueError(&#34;column_levels must be specified&#34;)
    else:
        index_levels = 0
        column_levels = 1

    # Build new index and column hierarchies
    new_index = index_fns.select_levels(arg.index, index_levels).unique()
    new_columns = index_fns.select_levels(arg.index, column_levels).unique()

    # Unstack and post-process
    unstacked = unstack_to_array(sr, levels=(index_levels, column_levels))
    df = pd.DataFrame(unstacked, index=new_index, columns=new_columns)
    if symmetric:
        return make_symmetric(df, sort=sort)
    return df


@njit(cache=True)
def flex_choose_i_and_col_nb(a, flex_2d):
    &#34;&#34;&#34;Choose selection index and column based on the array&#39;s shape.

    Instead of expensive broadcasting, keep original shape and do indexing in a smart way.
    A nice feature of this is that it has almost no memory footprint and can broadcast in
    any direction indefinitely.

    Call it once before using `flex_select_nb`.

    if `flex_2d` is True, 1-dim array will correspond to columns, otherwise to rows.&#34;&#34;&#34;
    i = -1
    col = -1
    if a.ndim == 0:
        i = 0
        col = 0
    elif a.ndim == 1:
        if flex_2d:
            i = 0
            if a.shape[0] == 1:
                col = 0
        else:
            col = 0
            if a.shape[0] == 1:
                i = 0
    else:
        if a.shape[0] == 1:
            i = 0
        if a.shape[1] == 1:
            col = 0
    return i, col


@njit(cache=True)
def flex_select_nb(i, col, a, flex_i, flex_col, flex_2d):
    &#34;&#34;&#34;Select element of `a` as if it has been broadcast.&#34;&#34;&#34;
    if flex_i == -1:
        flex_i = i
    if flex_col == -1:
        flex_col = col
    if a.ndim == 0:
        return a.item()
    if a.ndim == 1:
        if flex_2d:
            return a[flex_col]
        return a[flex_i]
    return a[flex_i, flex_col]


@njit(cache=True)
def flex_select_auto_nb(i, col, a, flex_2d):
    &#34;&#34;&#34;Combines `flex_choose_i_and_col_nb` and `flex_select_nb`.

    !!! note
        Slower since it must call `flex_choose_i_and_col_nb` each time.&#34;&#34;&#34;
    flex_i, flex_col = flex_choose_i_and_col_nb(a, flex_2d)
    return flex_select_nb(i, col, a, flex_i, flex_col, flex_2d)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.base.reshape_fns.broadcast"><code class="name flex">
<span>def <span class="ident fname">broadcast</span></span>(<span>*args, to_shape=None, to_pd=None, to_frame=None, align_index=None, align_columns=None, index_from='default', columns_from='default', require_kwargs=None, keep_raw=False, return_meta=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Bring any array-like object in <code>args</code> to the same shape by using NumPy broadcasting.</p>
<p>See <a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">Broadcasting</a>.</p>
<p>Can broadcast pandas objects by broadcasting their index/columns with <code><a title="vectorbt.base.reshape_fns.broadcast_index" href="#vectorbt.base.reshape_fns.broadcast_index">broadcast_index()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Array-like objects.</dd>
<dt><strong><code>to_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Target shape. If set, will broadcast every element in <code>args</code> to <code>to_shape</code>.</dd>
<dt><strong><code>to_pd</code></strong> :&ensp;<code>bool, tuple</code> or <code>list</code></dt>
<dd>Whether to convert all output arrays to pandas, otherwise returns
raw NumPy arrays. If None, converts only if there is at least one pandas object among them.</dd>
<dt><strong><code>to_frame</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to convert all Series to DataFrames.</dd>
<dt><strong><code>align_index</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to align index of pandas objects using multi-index.</dd>
<dt><strong><code>align_columns</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to align columns of pandas objects using multi-index.</dd>
<dt><strong><code>index_from</code></strong> :&ensp;<code>any</code></dt>
<dd>Broadcasting rule for index.</dd>
<dt><strong><code>columns_from</code></strong> :&ensp;<code>any</code></dt>
<dd>Broadcasting rule for columns.</dd>
<dt><strong><code>require_kwargs</code></strong> :&ensp;<code>dict</code> or <code>list</code> of <code>dict</code></dt>
<dd>Keyword arguments passed to <code>np.require</code>.</dd>
<dt><strong><code>keep_raw</code></strong> :&ensp;<code>bool, tuple</code> or <code>list</code></dt>
<dd>
<p>Whether to keep the unbroadcasted version of the array.</p>
<p>Only makes sure that the array can be broadcast to the target shape.</p>
</dd>
<dt><strong><code>return_meta</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, will also return new shape, index and columns.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.reshape_fns.broadcast_index" href="#vectorbt.base.reshape_fns.broadcast_index">broadcast_index()</a></code>.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.settings.broadcasting" href="../settings.html#vectorbt.settings.broadcasting">broadcasting</a></code>.</p>
<h2 id="example">Example</h2>
<p>Without broadcasting index and columns:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from vectorbt.base.reshape_fns import broadcast

&gt;&gt;&gt; v = 0
&gt;&gt;&gt; a = np.array([1, 2, 3])
&gt;&gt;&gt; sr = pd.Series([1, 2, 3], index=pd.Index(['x', 'y', 'z']), name='a')
&gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],
...     index=pd.Index(['x2', 'y2', 'z2']),
...     columns=pd.Index(['a2', 'b2', 'c2']))

&gt;&gt;&gt; for i in broadcast(
...     v, a, sr, df,
...     index_from=None,
...     columns_from=None,
... ): print(i)
   0  1  2
0  0  0  0
1  0  0  0
2  0  0  0
   0  1  2
0  1  2  3
1  1  2  3
2  1  2  3
   a  a  a
x  1  1  1
y  2  2  2
z  3  3  3
    a2  b2  c2
x2   1   2   3
y2   4   5   6
z2   7   8   9
</code></pre>
<p>Taking new index and columns from position:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; for i in broadcast(
...     v, a, sr, df,
...     index_from=2,
...     columns_from=3
... ): print(i)
   a2  b2  c2
x   0   0   0
y   0   0   0
z   0   0   0
   a2  b2  c2
x   1   2   3
y   1   2   3
z   1   2   3
   a2  b2  c2
x   1   1   1
y   2   2   2
z   3   3   3
   a2  b2  c2
x   1   2   3
y   4   5   6
z   7   8   9
</code></pre>
<p>Broadcasting index and columns through stacking:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; for i in broadcast(
...     v, a, sr, df,
...     index_from='stack',
...     columns_from='stack'
... ): print(i)
      a2  b2  c2
x x2   0   0   0
y y2   0   0   0
z z2   0   0   0
      a2  b2  c2
x x2   1   2   3
y y2   1   2   3
z z2   1   2   3
      a2  b2  c2
x x2   1   1   1
y y2   2   2   2
z z2   3   3   3
      a2  b2  c2
x x2   1   2   3
y y2   4   5   6
z z2   7   8   9
</code></pre>
<p>Setting index and columns manually:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; for i in broadcast(
...     v, a, sr, df,
...     index_from=['a', 'b', 'c'],
...     columns_from=['d', 'e', 'f']
... ): print(i)
   d  e  f
a  0  0  0
b  0  0  0
c  0  0  0
   d  e  f
a  1  2  3
b  1  2  3
c  1  2  3
   d  e  f
a  1  1  1
b  2  2  2
c  3  3  3
   d  e  f
a  1  2  3
b  4  5  6
c  7  8  9
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcast(*args, to_shape=None, to_pd=None, to_frame=None, align_index=None, align_columns=None,
              index_from=&#39;default&#39;, columns_from=&#39;default&#39;, require_kwargs=None, keep_raw=False,
              return_meta=False, **kwargs):
    &#34;&#34;&#34;Bring any array-like object in `args` to the same shape by using NumPy broadcasting.

    See [Broadcasting](https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html).

    Can broadcast pandas objects by broadcasting their index/columns with `broadcast_index`.

    Args:
        *args (array_like): Array-like objects.
        to_shape (tuple): Target shape. If set, will broadcast every element in `args` to `to_shape`.
        to_pd (bool, tuple or list): Whether to convert all output arrays to pandas, otherwise returns
            raw NumPy arrays. If None, converts only if there is at least one pandas object among them.
        to_frame (bool): Whether to convert all Series to DataFrames.
        align_index (bool): Whether to align index of pandas objects using multi-index.
        align_columns (bool): Whether to align columns of pandas objects using multi-index.
        index_from (any): Broadcasting rule for index.
        columns_from (any): Broadcasting rule for columns.
        require_kwargs (dict or list of dict): Keyword arguments passed to `np.require`.
        keep_raw (bool, tuple or list): Whether to keep the unbroadcasted version of the array.

            Only makes sure that the array can be broadcast to the target shape.
        return_meta (bool): If True, will also return new shape, index and columns.
        **kwargs: Keyword arguments passed to `broadcast_index`.

    For defaults, see `vectorbt.settings.broadcasting`.

    ## Example

    Without broadcasting index and columns:
    ```python-repl
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from vectorbt.base.reshape_fns import broadcast

    &gt;&gt;&gt; v = 0
    &gt;&gt;&gt; a = np.array([1, 2, 3])
    &gt;&gt;&gt; sr = pd.Series([1, 2, 3], index=pd.Index([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]), name=&#39;a&#39;)
    &gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],
    ...     index=pd.Index([&#39;x2&#39;, &#39;y2&#39;, &#39;z2&#39;]),
    ...     columns=pd.Index([&#39;a2&#39;, &#39;b2&#39;, &#39;c2&#39;]))

    &gt;&gt;&gt; for i in broadcast(
    ...     v, a, sr, df,
    ...     index_from=None,
    ...     columns_from=None,
    ... ): print(i)
       0  1  2
    0  0  0  0
    1  0  0  0
    2  0  0  0
       0  1  2
    0  1  2  3
    1  1  2  3
    2  1  2  3
       a  a  a
    x  1  1  1
    y  2  2  2
    z  3  3  3
        a2  b2  c2
    x2   1   2   3
    y2   4   5   6
    z2   7   8   9
    ```

    Taking new index and columns from position:
    ```python-repl
    &gt;&gt;&gt; for i in broadcast(
    ...     v, a, sr, df,
    ...     index_from=2,
    ...     columns_from=3
    ... ): print(i)
       a2  b2  c2
    x   0   0   0
    y   0   0   0
    z   0   0   0
       a2  b2  c2
    x   1   2   3
    y   1   2   3
    z   1   2   3
       a2  b2  c2
    x   1   1   1
    y   2   2   2
    z   3   3   3
       a2  b2  c2
    x   1   2   3
    y   4   5   6
    z   7   8   9
    ```

    Broadcasting index and columns through stacking:
    ```python-repl
    &gt;&gt;&gt; for i in broadcast(
    ...     v, a, sr, df,
    ...     index_from=&#39;stack&#39;,
    ...     columns_from=&#39;stack&#39;
    ... ): print(i)
          a2  b2  c2
    x x2   0   0   0
    y y2   0   0   0
    z z2   0   0   0
          a2  b2  c2
    x x2   1   2   3
    y y2   1   2   3
    z z2   1   2   3
          a2  b2  c2
    x x2   1   1   1
    y y2   2   2   2
    z z2   3   3   3
          a2  b2  c2
    x x2   1   2   3
    y y2   4   5   6
    z z2   7   8   9
    ```

    Setting index and columns manually:
    ```python-repl
    &gt;&gt;&gt; for i in broadcast(
    ...     v, a, sr, df,
    ...     index_from=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
    ...     columns_from=[&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]
    ... ): print(i)
       d  e  f
    a  0  0  0
    b  0  0  0
    c  0  0  0
       d  e  f
    a  1  2  3
    b  1  2  3
    c  1  2  3
       d  e  f
    a  1  1  1
    b  2  2  2
    c  3  3  3
       d  e  f
    a  1  2  3
    b  4  5  6
    c  7  8  9
    ```
    &#34;&#34;&#34;
    from vectorbt import settings

    is_pd = False
    is_2d = False
    args = list(args)
    if require_kwargs is None:
        require_kwargs = {}
    if align_index is None:
        align_index = settings.broadcasting[&#39;align_index&#39;]
    if align_columns is None:
        align_columns = settings.broadcasting[&#39;align_columns&#39;]
    if isinstance(index_from, str) and index_from == &#39;default&#39;:
        index_from = settings.broadcasting[&#39;index_from&#39;]
    if isinstance(columns_from, str) and columns_from == &#39;default&#39;:
        columns_from = settings.broadcasting[&#39;columns_from&#39;]

    # Convert to np.ndarray object if not numpy or pandas
    # Also check whether we broadcast to pandas and whether work on 2-dim data
    for i in range(len(args)):
        if not checks.is_any_array(args[i]):
            args[i] = np.asarray(args[i])
        if args[i].ndim &gt; 1:
            is_2d = True
        if checks.is_pandas(args[i]):
            is_pd = True

    # If target shape specified, check again if we work on 2-dim data
    if to_shape is not None:
        if isinstance(to_shape, int):
            to_shape = (to_shape,)
        checks.assert_type(to_shape, tuple)
        if len(to_shape) &gt; 1:
            is_2d = True

    if to_frame is not None:
        # force either keeping Series or converting them to DataFrames
        is_2d = to_frame

    if to_pd is not None:
        # force either raw or pandas
        if isinstance(to_pd, (tuple, list)):
            is_pd = any(to_pd)
        else:
            is_pd = to_pd

    # Align pandas objects
    if align_index:
        index_to_align = []
        for i in range(len(args)):
            if checks.is_pandas(args[i]) and len(args[i].index) &gt; 1:
                index_to_align.append(i)
        if len(index_to_align) &gt; 1:
            indexes = [args[i].index for i in index_to_align]
            if len(set(map(len, indexes))) &gt; 1:
                index_indices = index_fns.align_indexes(indexes)
                for i in range(len(args)):
                    if i in index_to_align:
                        args[i] = args[i].iloc[index_indices[index_to_align.index(i)]]
    if align_columns:
        cols_to_align = []
        for i in range(len(args)):
            if checks.is_frame(args[i]) and len(args[i].columns) &gt; 1:
                cols_to_align.append(i)
        if len(cols_to_align) &gt; 1:
            indexes = [args[i].columns for i in cols_to_align]
            if len(set(map(len, indexes))) &gt; 1:
                col_indices = index_fns.align_indexes(indexes)
                for i in range(len(args)):
                    if i in cols_to_align:
                        args[i] = args[i].iloc[:, col_indices[cols_to_align.index(i)]]

    # Convert all pd.Series objects to pd.DataFrame if we work on 2-dim data
    args_2d = [arg.to_frame() if is_2d and checks.is_series(arg) else arg for arg in args]

    # Get final shape
    if to_shape is None:
        to_shape = np.lib.stride_tricks._broadcast_shape(*args_2d)

    # Perform broadcasting
    new_args = []
    for i, arg in enumerate(args_2d):
        if isinstance(keep_raw, (tuple, list)):
            _keep_raw = keep_raw[i]
        else:
            _keep_raw = keep_raw
        bc_arg = np.broadcast_to(arg, to_shape)
        if _keep_raw:
            new_args.append(arg)
            continue
        new_args.append(bc_arg)

    # Force to match requirements
    for i in range(len(new_args)):
        if isinstance(require_kwargs, (tuple, list)):
            _require_kwargs = require_kwargs[i]
        else:
            _require_kwargs = require_kwargs
        new_args[i] = np.require(new_args[i], **_require_kwargs)

    if is_pd:
        # Decide on index and columns
        # NOTE: Important to pass args, not args_2d, to preserve original shape info
        new_index = broadcast_index(args, to_shape, index_from=index_from, axis=0, **kwargs)
        new_columns = broadcast_index(args, to_shape, index_from=columns_from, axis=1, **kwargs)
    else:
        new_index, new_columns = None, None

    # Bring arrays to their old types (e.g. array -&gt; pandas)
    for i in range(len(new_args)):
        if isinstance(keep_raw, (tuple, list)):
            _keep_raw = keep_raw[i]
        else:
            _keep_raw = keep_raw
        if _keep_raw:
            continue
        if isinstance(to_pd, (tuple, list)):
            _is_pd = to_pd[i]
        else:
            _is_pd = is_pd
        new_args[i] = wrap_broadcasted(
            args[i],
            new_args[i],
            is_pd=_is_pd,
            new_index=new_index,
            new_columns=new_columns
        )

    if len(new_args) &gt; 1:
        if return_meta:
            return tuple(new_args), to_shape, new_index, new_columns
        return tuple(new_args)
    if return_meta:
        return new_args[0], to_shape, new_index, new_columns
    return new_args[0]</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.broadcast_index"><code class="name flex">
<span>def <span class="ident fname">broadcast_index</span></span>(<span>args, to_shape, index_from=None, axis=0, ignore_sr_names=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a broadcast index/columns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Array-like objects.</dd>
<dt><strong><code>to_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Target shape.</dd>
<dt><strong><code>index_from</code></strong> :&ensp;<code>None, int, str</code> or <code>array_like</code></dt>
<dd>
<p>Broadcasting rule for this index/these columns.</p>
<p>Accepts the following values:</p>
<ul>
<li>'default' - take the value from <code><a title="vectorbt.settings.broadcasting" href="../settings.html#vectorbt.settings.broadcasting">broadcasting</a></code></li>
<li>'strict' - ensure that all pandas objects have the same index/columns</li>
<li>'stack' - stack different indexes/columns using <code><a title="vectorbt.base.index_fns.stack_indexes" href="index_fns.html#vectorbt.base.index_fns.stack_indexes">stack_indexes()</a></code></li>
<li>'ignore' - ignore any index/columns</li>
<li>integer - use the index/columns of the i-nth object in <code>args</code></li>
<li>None - use the original index/columns of the objects in <code>args</code></li>
<li>everything else will be converted to <code>pd.Index</code></li>
</ul>
</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code></dt>
<dd>Set to 0 for index and 1 for columns.</dd>
<dt><strong><code>ignore_sr_names</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to ignore Series names if they are in conflict.</p>
<p>Conflicting Series names are those that are different but not None.</p>
</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.index_fns.stack_indexes" href="index_fns.html#vectorbt.base.index_fns.stack_indexes">stack_indexes()</a></code>.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.settings.broadcasting" href="../settings.html#vectorbt.settings.broadcasting">broadcasting</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Series names are treated as columns with a single element but without a name.
If a column level without a name loses its meaning, better to convert Series to DataFrames
with one column prior to broadcasting. If the name of a Series is not that important,
better to drop it altogether by setting it to None.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcast_index(args, to_shape, index_from=None, axis=0, ignore_sr_names=None, **kwargs):
    &#34;&#34;&#34;Produce a broadcast index/columns.

    Args:
        *args (array_like): Array-like objects.
        to_shape (tuple): Target shape.
        index_from (None, int, str or array_like): Broadcasting rule for this index/these columns.

            Accepts the following values:

            * &#39;default&#39; - take the value from `vectorbt.settings.broadcasting`
            * &#39;strict&#39; - ensure that all pandas objects have the same index/columns
            * &#39;stack&#39; - stack different indexes/columns using `vectorbt.base.index_fns.stack_indexes`
            * &#39;ignore&#39; - ignore any index/columns
            * integer - use the index/columns of the i-nth object in `args`
            * None - use the original index/columns of the objects in `args`
            * everything else will be converted to `pd.Index`

        axis (int): Set to 0 for index and 1 for columns.
        ignore_sr_names (bool): Whether to ignore Series names if they are in conflict.

            Conflicting Series names are those that are different but not None.
        **kwargs: Keyword arguments passed to `vectorbt.base.index_fns.stack_indexes`.

    For defaults, see `vectorbt.settings.broadcasting`.

    !!! note
        Series names are treated as columns with a single element but without a name.
        If a column level without a name loses its meaning, better to convert Series to DataFrames
        with one column prior to broadcasting. If the name of a Series is not that important,
        better to drop it altogether by setting it to None.
    &#34;&#34;&#34;
    from vectorbt import settings

    if ignore_sr_names is None:
        ignore_sr_names = settings.broadcasting[&#39;ignore_sr_names&#39;]
    index_str = &#39;columns&#39; if axis == 1 else &#39;index&#39;
    to_shape_2d = (to_shape[0], 1) if len(to_shape) == 1 else to_shape
    # maxlen stores the length of the longest index
    maxlen = to_shape_2d[1] if axis == 1 else to_shape_2d[0]
    new_index = None

    if index_from is not None:
        if isinstance(index_from, int):
            # Take index/columns of the object indexed by index_from
            if not checks.is_pandas(args[index_from]):
                raise TypeError(f&#34;Argument under index {index_from} must be a pandas object&#34;)
            new_index = index_fns.get_index(args[index_from], axis)
        elif isinstance(index_from, str):
            if index_from == &#39;ignore&#39;:
                # Ignore index/columns
                new_index = pd.RangeIndex(start=0, stop=maxlen, step=1)
            elif index_from in (&#39;stack&#39;, &#39;strict&#39;):
                # Check whether all indexes/columns are equal
                last_index = None  # of type pd.Index
                index_conflict = False
                for arg in args:
                    if checks.is_pandas(arg):
                        index = index_fns.get_index(arg, axis)
                        if last_index is not None:
                            if not pd.Index.equals(index, last_index):
                                index_conflict = True
                        last_index = index
                        continue
                if not index_conflict:
                    new_index = last_index
                else:
                    # If pandas objects have different index/columns, stack them together
                    for arg in args:
                        if checks.is_pandas(arg):
                            index = index_fns.get_index(arg, axis)
                            if axis == 1 and checks.is_series(arg) and ignore_sr_names:
                                # ignore Series name
                                continue
                            if checks.is_default_index(index):
                                # ignore simple ranges without name
                                continue
                            if new_index is None:
                                new_index = index
                            else:
                                if index_from == &#39;strict&#39;:
                                    # If pandas objects have different index/columns, raise an exception
                                    if not pd.Index.equals(index, new_index):
                                        raise ValueError(
                                            f&#34;Broadcasting {index_str} is not allowed when {index_str}_from=strict&#34;)
                                # Broadcasting index must follow the rules of a regular broadcasting operation
                                # https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html#general-broadcasting-rules
                                # 1. rule: if indexes are of the same length, they are simply stacked
                                # 2. rule: if index has one element, it gets repeated and then stacked

                                if pd.Index.equals(index, new_index):
                                    continue
                                if len(index) != len(new_index):
                                    if len(index) &gt; 1 and len(new_index) &gt; 1:
                                        raise ValueError(&#34;Indexes could not be broadcast together&#34;)
                                    if len(index) &gt; len(new_index):
                                        new_index = index_fns.repeat_index(new_index, len(index))
                                    elif len(index) &lt; len(new_index):
                                        index = index_fns.repeat_index(index, len(new_index))
                                new_index = index_fns.stack_indexes([new_index, index], **kwargs)
            else:
                raise ValueError(f&#34;Invalid value {index_from} for {&#39;columns&#39; if axis == 1 else &#39;index&#39;}_from&#34;)
        else:
            new_index = index_from
        if new_index is not None:
            if maxlen &gt; len(new_index):
                if index_from == &#39;strict&#39;:
                    raise ValueError(f&#34;Broadcasting {index_str} is not allowed when {index_str}_from=strict&#34;)
                # This happens only when some numpy object is longer than the new pandas index
                # In this case, new pandas index (one element) should be repeated to match this length.
                if maxlen &gt; 1 and len(new_index) &gt; 1:
                    raise ValueError(&#34;Indexes could not be broadcast together&#34;)
                new_index = index_fns.repeat_index(new_index, maxlen)
        else:
            # new_index=None can mean two things: 1) take original metadata or 2) reset index/columns
            # In case when index_from is not None, we choose 2)
            new_index = pd.RangeIndex(start=0, stop=maxlen, step=1)
    return new_index</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.broadcast_to"><code class="name flex">
<span>def <span class="ident fname">broadcast_to</span></span>(<span>arg1, arg2, to_pd=None, index_from=None, columns_from=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Broadcast <code>arg1</code> to <code>arg2</code>.</p>
<p>Keyword arguments <code>**kwargs</code> are passed to <code><a title="vectorbt.base.reshape_fns.broadcast" href="#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from vectorbt.base.reshape_fns import broadcast_to

&gt;&gt;&gt; a = np.array([1, 2, 3])
&gt;&gt;&gt; sr = pd.Series([4, 5, 6], index=pd.Index(['x', 'y', 'z']), name='a')

&gt;&gt;&gt; broadcast_to(a, sr)
x    1
y    2
z    3
Name: a, dtype: int64

&gt;&gt;&gt; broadcast_to(sr, a)
array([4, 5, 6])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcast_to(arg1, arg2, to_pd=None, index_from=None, columns_from=None, **kwargs):
    &#34;&#34;&#34;Broadcast `arg1` to `arg2`.

    Keyword arguments `**kwargs` are passed to `broadcast`.

    ## Example

    ```python-repl
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from vectorbt.base.reshape_fns import broadcast_to

    &gt;&gt;&gt; a = np.array([1, 2, 3])
    &gt;&gt;&gt; sr = pd.Series([4, 5, 6], index=pd.Index([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]), name=&#39;a&#39;)

    &gt;&gt;&gt; broadcast_to(a, sr)
    x    1
    y    2
    z    3
    Name: a, dtype: int64

    &gt;&gt;&gt; broadcast_to(sr, a)
    array([4, 5, 6])
    ```
    &#34;&#34;&#34;
    if not checks.is_any_array(arg1):
        arg1 = np.asarray(arg1)
    if not checks.is_any_array(arg2):
        arg2 = np.asarray(arg2)
    if to_pd is None:
        to_pd = checks.is_pandas(arg2)
    if to_pd:
        # Take index and columns from arg2
        if index_from is None:
            index_from = index_fns.get_index(arg2, 0)
        if columns_from is None:
            columns_from = index_fns.get_index(arg2, 1)
    return broadcast(arg1, to_shape=arg2.shape, to_pd=to_pd, index_from=index_from, columns_from=columns_from, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.broadcast_to_array_of"><code class="name flex">
<span>def <span class="ident fname">broadcast_to_array_of</span></span>(<span>arg1, arg2)</span>
</code></dt>
<dd>
<div class="desc"><p>Broadcast <code>arg1</code> to the shape <code>(1, *arg2.shape)</code>.</p>
<p><code>arg1</code> must be either a scalar, a 1-dim array, or have 1 dimension more than <code>arg2</code>.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from vectorbt.base.reshape_fns import broadcast_to_array_of

&gt;&gt;&gt; broadcast_to_array_of([0.1, 0.2], np.empty((2, 2)))
[[[0.1 0.1]
  [0.1 0.1]]

 [[0.2 0.2]
  [0.2 0.2]]]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcast_to_array_of(arg1, arg2):
    &#34;&#34;&#34;Broadcast `arg1` to the shape `(1, *arg2.shape)`.

    `arg1` must be either a scalar, a 1-dim array, or have 1 dimension more than `arg2`.

    ## Example

    ```python-repl
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from vectorbt.base.reshape_fns import broadcast_to_array_of

    &gt;&gt;&gt; broadcast_to_array_of([0.1, 0.2], np.empty((2, 2)))
    [[[0.1 0.1]
      [0.1 0.1]]

     [[0.2 0.2]
      [0.2 0.2]]]
    ```
    &#34;&#34;&#34;
    arg1 = np.asarray(arg1)
    arg2 = np.asarray(arg2)
    if arg1.ndim == arg2.ndim + 1:
        if arg1.shape[1:] == arg2.shape:
            return arg1
    # From here on arg1 can be only a 1-dim array
    if arg1.ndim == 0:
        arg1 = to_1d(arg1)
    checks.assert_ndim(arg1, 1)

    if arg2.ndim == 0:
        return arg1
    for i in range(arg2.ndim):
        arg1 = np.expand_dims(arg1, axis=-1)
    return np.tile(arg1, (1, *arg2.shape))</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.broadcast_to_axis_of"><code class="name flex">
<span>def <span class="ident fname">broadcast_to_axis_of</span></span>(<span>arg1, arg2, axis, require_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Broadcast <code>arg1</code> to an axis of <code>arg2</code>.</p>
<p>If <code>arg2</code> has less dimensions than requested, will broadcast <code>arg1</code> to a single number.</p>
<p>For other keyword arguments, see <code><a title="vectorbt.base.reshape_fns.broadcast" href="#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcast_to_axis_of(arg1, arg2, axis, require_kwargs=None):
    &#34;&#34;&#34;Broadcast `arg1` to an axis of `arg2`.

    If `arg2` has less dimensions than requested, will broadcast `arg1` to a single number.

    For other keyword arguments, see `broadcast`.&#34;&#34;&#34;
    if require_kwargs is None:
        require_kwargs = {}
    if not checks.is_any_array(arg2):
        arg2 = np.asarray(arg2)
    if arg2.ndim &lt; axis + 1:
        return np.broadcast_to(arg1, (1,))[0]  # to a single number
    arg1 = np.broadcast_to(arg1, (arg2.shape[axis],))
    arg1 = np.require(arg1, **require_kwargs)
    return arg1</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.flex_choose_i_and_col_nb"><code class="name flex">
<span>def <span class="ident fname">flex_choose_i_and_col_nb</span></span>(<span>a, flex_2d)</span>
</code></dt>
<dd>
<div class="desc"><p>Choose selection index and column based on the array's shape.</p>
<p>Instead of expensive broadcasting, keep original shape and do indexing in a smart way.
A nice feature of this is that it has almost no memory footprint and can broadcast in
any direction indefinitely.</p>
<p>Call it once before using <code><a title="vectorbt.base.reshape_fns.flex_select_nb" href="#vectorbt.base.reshape_fns.flex_select_nb">flex_select_nb()</a></code>.</p>
<p>if <code>flex_2d</code> is True, 1-dim array will correspond to columns, otherwise to rows.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def flex_choose_i_and_col_nb(a, flex_2d):
    &#34;&#34;&#34;Choose selection index and column based on the array&#39;s shape.

    Instead of expensive broadcasting, keep original shape and do indexing in a smart way.
    A nice feature of this is that it has almost no memory footprint and can broadcast in
    any direction indefinitely.

    Call it once before using `flex_select_nb`.

    if `flex_2d` is True, 1-dim array will correspond to columns, otherwise to rows.&#34;&#34;&#34;
    i = -1
    col = -1
    if a.ndim == 0:
        i = 0
        col = 0
    elif a.ndim == 1:
        if flex_2d:
            i = 0
            if a.shape[0] == 1:
                col = 0
        else:
            col = 0
            if a.shape[0] == 1:
                i = 0
    else:
        if a.shape[0] == 1:
            i = 0
        if a.shape[1] == 1:
            col = 0
    return i, col</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.flex_select_auto_nb"><code class="name flex">
<span>def <span class="ident fname">flex_select_auto_nb</span></span>(<span>i, col, a, flex_2d)</span>
</code></dt>
<dd>
<div class="desc"><p>Combines <code><a title="vectorbt.base.reshape_fns.flex_choose_i_and_col_nb" href="#vectorbt.base.reshape_fns.flex_choose_i_and_col_nb">flex_choose_i_and_col_nb()</a></code> and <code><a title="vectorbt.base.reshape_fns.flex_select_nb" href="#vectorbt.base.reshape_fns.flex_select_nb">flex_select_nb()</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Slower since it must call <code><a title="vectorbt.base.reshape_fns.flex_choose_i_and_col_nb" href="#vectorbt.base.reshape_fns.flex_choose_i_and_col_nb">flex_choose_i_and_col_nb()</a></code> each time.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def flex_select_auto_nb(i, col, a, flex_2d):
    &#34;&#34;&#34;Combines `flex_choose_i_and_col_nb` and `flex_select_nb`.

    !!! note
        Slower since it must call `flex_choose_i_and_col_nb` each time.&#34;&#34;&#34;
    flex_i, flex_col = flex_choose_i_and_col_nb(a, flex_2d)
    return flex_select_nb(i, col, a, flex_i, flex_col, flex_2d)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.flex_select_nb"><code class="name flex">
<span>def <span class="ident fname">flex_select_nb</span></span>(<span>i, col, a, flex_i, flex_col, flex_2d)</span>
</code></dt>
<dd>
<div class="desc"><p>Select element of <code>a</code> as if it has been broadcast.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def flex_select_nb(i, col, a, flex_i, flex_col, flex_2d):
    &#34;&#34;&#34;Select element of `a` as if it has been broadcast.&#34;&#34;&#34;
    if flex_i == -1:
        flex_i = i
    if flex_col == -1:
        flex_col = col
    if a.ndim == 0:
        return a.item()
    if a.ndim == 1:
        if flex_2d:
            return a[flex_col]
        return a[flex_i]
    return a[flex_i, flex_col]</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.make_symmetric"><code class="name flex">
<span>def <span class="ident fname">make_symmetric</span></span>(<span>arg, sort=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Make <code>arg</code> symmetric.</p>
<p>The index and columns of the resulting DataFrame will be identical.</p>
<p>Requires the index and columns to have the same number of levels.</p>
<p>Pass <code>sort=False</code> if index and columns should not be sorted, but concatenated
and get duplicates removed.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from vectorbt.base.reshape_fns import make_symmetric

&gt;&gt;&gt; df = pd.DataFrame([[1, 2], [3, 4]], index=['a', 'b'], columns=['c', 'd'])

&gt;&gt;&gt; make_symmetric(df)
     a    b    c    d
a  NaN  NaN  1.0  2.0
b  NaN  NaN  3.0  4.0
c  1.0  3.0  NaN  NaN
d  2.0  4.0  NaN  NaN
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_symmetric(arg, sort=True):
    &#34;&#34;&#34;Make `arg` symmetric.

    The index and columns of the resulting DataFrame will be identical.

    Requires the index and columns to have the same number of levels.

    Pass `sort=False` if index and columns should not be sorted, but concatenated
    and get duplicates removed.

    ## Example

    ```python-repl
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from vectorbt.base.reshape_fns import make_symmetric

    &gt;&gt;&gt; df = pd.DataFrame([[1, 2], [3, 4]], index=[&#39;a&#39;, &#39;b&#39;], columns=[&#39;c&#39;, &#39;d&#39;])

    &gt;&gt;&gt; make_symmetric(df)
         a    b    c    d
    a  NaN  NaN  1.0  2.0
    b  NaN  NaN  3.0  4.0
    c  1.0  3.0  NaN  NaN
    d  2.0  4.0  NaN  NaN
    ```
    &#34;&#34;&#34;
    checks.assert_type(arg, (pd.Series, pd.DataFrame))
    arg = to_2d(arg)
    if isinstance(arg.index, pd.MultiIndex) or isinstance(arg.columns, pd.MultiIndex):
        checks.assert_type(arg.index, pd.MultiIndex)
        checks.assert_type(arg.columns, pd.MultiIndex)
        checks.assert_array_equal(arg.index.nlevels, arg.columns.nlevels)
        names1, names2 = tuple(arg.index.names), tuple(arg.columns.names)
    else:
        names1, names2 = arg.index.name, arg.columns.name

    if names1 == names2:
        new_name = names1
    else:
        if isinstance(arg.index, pd.MultiIndex):
            new_name = tuple(zip(*[names1, names2]))
        else:
            new_name = (names1, names2)
    if sort:
        idx_vals = np.unique(np.concatenate((arg.index, arg.columns))).tolist()
    else:
        idx_vals = list(dict.fromkeys(np.concatenate((arg.index, arg.columns))))
    arg = arg.copy()
    if isinstance(arg.index, pd.MultiIndex):
        unique_index = pd.MultiIndex.from_tuples(idx_vals, names=new_name)
        arg.index.names = new_name
        arg.columns.names = new_name
    else:
        unique_index = pd.Index(idx_vals, name=new_name)
        arg.index.name = new_name
        arg.columns.name = new_name
    df_out = pd.DataFrame(index=unique_index, columns=unique_index)
    df_out.loc[:, :] = arg
    df_out[df_out.isnull()] = arg.transpose()
    return df_out</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.repeat"><code class="name flex">
<span>def <span class="ident fname">repeat</span></span>(<span>arg, n, axis=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Repeat each element in <code>arg</code> <code>n</code> times along the specified axis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat(arg, n, axis=1):
    &#34;&#34;&#34;Repeat each element in `arg` `n` times along the specified axis.&#34;&#34;&#34;
    if not checks.is_any_array(arg):
        arg = np.asarray(arg)
    if axis == 0:
        if checks.is_pandas(arg):
            return array_wrapper.ArrayWrapper.from_obj(arg).wrap(
                np.repeat(arg.values, n, axis=0), index=index_fns.repeat_index(arg.index, n))
        return np.repeat(arg, n, axis=0)
    elif axis == 1:
        arg = to_2d(arg)
        if checks.is_pandas(arg):
            return array_wrapper.ArrayWrapper.from_obj(arg).wrap(
                np.repeat(arg.values, n, axis=1), columns=index_fns.repeat_index(arg.columns, n))
        return np.repeat(arg, n, axis=1)
    else:
        raise ValueError(&#34;Only axis 0 and 1 are supported&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.soft_to_ndim"><code class="name flex">
<span>def <span class="ident fname">soft_to_ndim</span></span>(<span>arg, ndim)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to softly bring <code>arg</code> to the specified number of dimensions <code>ndim</code> (max 2).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soft_to_ndim(arg, ndim):
    &#34;&#34;&#34;Try to softly bring `arg` to the specified number of dimensions `ndim` (max 2).&#34;&#34;&#34;
    if not checks.is_any_array(arg):
        arg = np.asarray(arg)
    if ndim == 1:
        if arg.ndim == 2:
            if arg.shape[1] == 1:
                if checks.is_frame(arg):
                    return arg.iloc[:, 0]
                return arg[:, 0]  # downgrade
    if ndim == 2:
        if arg.ndim == 1:
            if checks.is_series(arg):
                return arg.to_frame()
            return arg[:, None]  # upgrade
    return arg  # do nothing</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.tile"><code class="name flex">
<span>def <span class="ident fname">tile</span></span>(<span>arg, n, axis=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Repeat the whole <code>arg</code> <code>n</code> times along the specified axis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tile(arg, n, axis=1):
    &#34;&#34;&#34;Repeat the whole `arg` `n` times along the specified axis.&#34;&#34;&#34;
    if not checks.is_any_array(arg):
        arg = np.asarray(arg)
    if axis == 0:
        if arg.ndim == 2:
            if checks.is_pandas(arg):
                return array_wrapper.ArrayWrapper.from_obj(arg).wrap(
                    np.tile(arg.values, (n, 1)), index=index_fns.tile_index(arg.index, n))
            return np.tile(arg, (n, 1))
        if checks.is_pandas(arg):
            return array_wrapper.ArrayWrapper.from_obj(arg).wrap(
                np.tile(arg.values, n), index=index_fns.tile_index(arg.index, n))
        return np.tile(arg, n)
    elif axis == 1:
        arg = to_2d(arg)
        if checks.is_pandas(arg):
            return array_wrapper.ArrayWrapper.from_obj(arg).wrap(
                np.tile(arg.values, (1, n)), columns=index_fns.tile_index(arg.columns, n))
        return np.tile(arg, (1, n))
    else:
        raise ValueError(&#34;Only axis 0 and 1 are supported&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.to_1d"><code class="name flex">
<span>def <span class="ident fname">to_1d</span></span>(<span>arg, raw=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Reshape argument to one dimension. </p>
<p>If <code>raw</code> is True, returns NumPy array.
If 2-dim, will collapse along axis 1 (i.e., DataFrame with one column to Series).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_1d(arg, raw=False):
    &#34;&#34;&#34;Reshape argument to one dimension. 

    If `raw` is True, returns NumPy array.
    If 2-dim, will collapse along axis 1 (i.e., DataFrame with one column to Series).&#34;&#34;&#34;
    if raw or not checks.is_any_array(arg):
        arg = np.asarray(arg)
    if arg.ndim == 2:
        if arg.shape[1] == 1:
            if checks.is_frame(arg):
                return arg.iloc[:, 0]
            return arg[:, 0]
    if arg.ndim == 1:
        return arg
    elif arg.ndim == 0:
        return arg.reshape((1,))
    raise ValueError(f&#34;Cannot reshape a {arg.ndim}-dimensional array to 1 dimension&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.to_2d"><code class="name flex">
<span>def <span class="ident fname">to_2d</span></span>(<span>arg, raw=False, expand_axis=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Reshape argument to two dimensions. </p>
<p>If <code>raw</code> is True, returns NumPy array.
If 1-dim, will expand along axis 1 (i.e., Series to DataFrame with one column).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_2d(arg, raw=False, expand_axis=1):
    &#34;&#34;&#34;Reshape argument to two dimensions. 

    If `raw` is True, returns NumPy array.
    If 1-dim, will expand along axis 1 (i.e., Series to DataFrame with one column).&#34;&#34;&#34;
    if raw or not checks.is_any_array(arg):
        arg = np.asarray(arg)
    if arg.ndim == 2:
        return arg
    elif arg.ndim == 1:
        if checks.is_series(arg):
            if expand_axis == 0:
                return pd.DataFrame(arg.values[None, :], columns=arg.index)
            elif expand_axis == 1:
                return arg.to_frame()
        return np.expand_dims(arg, expand_axis)
    elif arg.ndim == 0:
        return arg.reshape((1, 1))
    raise ValueError(f&#34;Cannot reshape a {arg.ndim}-dimensional array to 2 dimensions&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.unstack_to_array"><code class="name flex">
<span>def <span class="ident fname">unstack_to_array</span></span>(<span>arg, levels=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Reshape <code>arg</code> based on its multi-index into a multi-dimensional array.</p>
<p>Use <code>levels</code> to specify what index levels to unstack and in which order.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from vectorbt.base.reshape_fns import unstack_to_array

&gt;&gt;&gt; index = pd.MultiIndex.from_arrays(
...     [[1, 1, 2, 2], [3, 4, 3, 4], ['a', 'b', 'c', 'd']])
&gt;&gt;&gt; sr = pd.Series([1, 2, 3, 4], index=index)

&gt;&gt;&gt; unstack_to_array(sr).shape
(2, 2, 4)

&gt;&gt;&gt; unstack_to_array(sr)
[[[ 1. nan nan nan]
 [nan  2. nan nan]]

 [[nan nan  3. nan]
[nan nan nan  4.]]]

&gt;&gt;&gt; unstack_to_array(sr, levels=(2, 0))
[[ 1. nan]
 [ 2. nan]
 [nan  3.]
 [nan  4.]]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack_to_array(arg, levels=None):
    &#34;&#34;&#34;Reshape `arg` based on its multi-index into a multi-dimensional array.

    Use `levels` to specify what index levels to unstack and in which order.

    ## Example

    ```python-repl
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from vectorbt.base.reshape_fns import unstack_to_array

    &gt;&gt;&gt; index = pd.MultiIndex.from_arrays(
    ...     [[1, 1, 2, 2], [3, 4, 3, 4], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]])
    &gt;&gt;&gt; sr = pd.Series([1, 2, 3, 4], index=index)

    &gt;&gt;&gt; unstack_to_array(sr).shape
    (2, 2, 4)

    &gt;&gt;&gt; unstack_to_array(sr)
    [[[ 1. nan nan nan]
     [nan  2. nan nan]]

     [[nan nan  3. nan]
    [nan nan nan  4.]]]

    &gt;&gt;&gt; unstack_to_array(sr, levels=(2, 0))
    [[ 1. nan]
     [ 2. nan]
     [nan  3.]
     [nan  4.]]
    ```
    &#34;&#34;&#34;
    checks.assert_type(arg, pd.Series)
    checks.assert_type(arg.index, pd.MultiIndex)
    if arg.index.duplicated().any():
        raise ValueError(&#34;Index contains duplicate entries, cannot reshape&#34;)

    unique_idx_list = []
    vals_idx_list = []
    if levels is None:
        levels = range(arg.index.nlevels)
    for level in levels:
        vals = index_fns.select_levels(arg.index, level).to_numpy()
        unique_vals = np.unique(vals)
        unique_idx_list.append(unique_vals)
        idx_map = dict(zip(unique_vals, range(len(unique_vals))))
        vals_idx = list(map(lambda x: idx_map[x], vals))
        vals_idx_list.append(vals_idx)

    a = np.full(list(map(len, unique_idx_list)), np.nan)
    a[tuple(zip(vals_idx_list))] = arg.values
    return a</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.unstack_to_df"><code class="name flex">
<span>def <span class="ident fname">unstack_to_df</span></span>(<span>arg, index_levels=None, column_levels=None, symmetric=False, sort=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Reshape <code>arg</code> based on its multi-index into a DataFrame.</p>
<p>Use <code>index_levels</code> to specify what index levels will form new index, and <code>column_levels</code>
for new columns. Set <code>symmetric</code> to True to make DataFrame symmetric.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from vectorbt.base.reshape_fns import unstack_to_df

&gt;&gt;&gt; index = pd.MultiIndex.from_arrays(
...     [[1, 1, 2, 2], [3, 4, 3, 4], ['a', 'b', 'c', 'd']],
...     names=['x', 'y', 'z'])
&gt;&gt;&gt; sr = pd.Series([1, 2, 3, 4], index=index)

&gt;&gt;&gt; unstack_to_df(sr, index_levels=(0, 1), column_levels=2)
z      a    b    c    d
x y
1 3  1.0  NaN  NaN  NaN
1 4  NaN  2.0  NaN  NaN
2 3  NaN  NaN  3.0  NaN
2 4  NaN  NaN  NaN  4.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack_to_df(arg, index_levels=None, column_levels=None, symmetric=False, sort=True):
    &#34;&#34;&#34;Reshape `arg` based on its multi-index into a DataFrame.

    Use `index_levels` to specify what index levels will form new index, and `column_levels` 
    for new columns. Set `symmetric` to True to make DataFrame symmetric.

    ## Example

    ```python-repl
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from vectorbt.base.reshape_fns import unstack_to_df

    &gt;&gt;&gt; index = pd.MultiIndex.from_arrays(
    ...     [[1, 1, 2, 2], [3, 4, 3, 4], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]],
    ...     names=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])
    &gt;&gt;&gt; sr = pd.Series([1, 2, 3, 4], index=index)

    &gt;&gt;&gt; unstack_to_df(sr, index_levels=(0, 1), column_levels=2)
    z      a    b    c    d
    x y
    1 3  1.0  NaN  NaN  NaN
    1 4  NaN  2.0  NaN  NaN
    2 3  NaN  NaN  3.0  NaN
    2 4  NaN  NaN  NaN  4.0
    ```
    &#34;&#34;&#34;
    # Perform checks
    checks.assert_type(arg, (pd.Series, pd.DataFrame))
    if checks.is_frame(arg):
        if arg.shape[0] == 1:
            arg = arg.iloc[0, :]
        elif arg.shape[1] == 1:
            arg = arg.iloc[:, 0]
    checks.assert_type(arg.index, pd.MultiIndex)
    sr = to_1d(arg)

    if len(sr.index.levels) &gt; 2:
        if index_levels is None:
            raise ValueError(&#34;index_levels must be specified&#34;)
        if column_levels is None:
            raise ValueError(&#34;column_levels must be specified&#34;)
    else:
        index_levels = 0
        column_levels = 1

    # Build new index and column hierarchies
    new_index = index_fns.select_levels(arg.index, index_levels).unique()
    new_columns = index_fns.select_levels(arg.index, column_levels).unique()

    # Unstack and post-process
    unstacked = unstack_to_array(sr, levels=(index_levels, column_levels))
    df = pd.DataFrame(unstacked, index=new_index, columns=new_columns)
    if symmetric:
        return make_symmetric(df, sort=sort)
    return df</code></pre>
</details>
</dd>
<dt id="vectorbt.base.reshape_fns.wrap_broadcasted"><code class="name flex">
<span>def <span class="ident fname">wrap_broadcasted</span></span>(<span>old_arg, new_arg, is_pd=False, new_index=None, new_columns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>If the newly brodcasted array was originally a pandas object, make it pandas object again
and assign it the newly broadcast index/columns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_broadcasted(old_arg, new_arg, is_pd=False, new_index=None, new_columns=None):
    &#34;&#34;&#34;If the newly brodcasted array was originally a pandas object, make it pandas object again 
    and assign it the newly broadcast index/columns.&#34;&#34;&#34;
    if is_pd:
        if checks.is_pandas(old_arg):
            if new_index is None:
                # Take index from original pandas object
                old_index = index_fns.get_index(old_arg, 0)
                if old_arg.shape[0] == new_arg.shape[0]:
                    new_index = old_index
                else:
                    new_index = index_fns.repeat_index(old_index, new_arg.shape[0])
            if new_columns is None:
                # Take columns from original pandas object
                old_columns = index_fns.get_index(old_arg, 1)
                new_ncols = new_arg.shape[1] if new_arg.ndim == 2 else 1
                if len(old_columns) == new_ncols:
                    new_columns = old_columns
                else:
                    new_columns = index_fns.repeat_index(old_columns, new_ncols)
        if new_arg.ndim == 2:
            return pd.DataFrame(new_arg, index=new_index, columns=new_columns)
        if new_columns is not None and len(new_columns) == 1:
            name = new_columns[0]
            if name == 0:
                name = None
        else:
            name = None
        return pd.Series(new_arg, index=new_index, name=name)
    return new_arg</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,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"/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.base" href="index.html">vectorbt.base</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.base.reshape_fns.broadcast" href="#vectorbt.base.reshape_fns.broadcast">broadcast</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.broadcast_index" href="#vectorbt.base.reshape_fns.broadcast_index">broadcast_index</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.broadcast_to" href="#vectorbt.base.reshape_fns.broadcast_to">broadcast_to</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.broadcast_to_array_of" href="#vectorbt.base.reshape_fns.broadcast_to_array_of">broadcast_to_array_of</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.broadcast_to_axis_of" href="#vectorbt.base.reshape_fns.broadcast_to_axis_of">broadcast_to_axis_of</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.flex_choose_i_and_col_nb" href="#vectorbt.base.reshape_fns.flex_choose_i_and_col_nb">flex_choose_i_and_col_nb</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.flex_select_auto_nb" href="#vectorbt.base.reshape_fns.flex_select_auto_nb">flex_select_auto_nb</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.flex_select_nb" href="#vectorbt.base.reshape_fns.flex_select_nb">flex_select_nb</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.make_symmetric" href="#vectorbt.base.reshape_fns.make_symmetric">make_symmetric</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.repeat" href="#vectorbt.base.reshape_fns.repeat">repeat</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.soft_to_ndim" href="#vectorbt.base.reshape_fns.soft_to_ndim">soft_to_ndim</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.tile" href="#vectorbt.base.reshape_fns.tile">tile</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.to_1d" href="#vectorbt.base.reshape_fns.to_1d">to_1d</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.to_2d" href="#vectorbt.base.reshape_fns.to_2d">to_2d</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.unstack_to_array" href="#vectorbt.base.reshape_fns.unstack_to_array">unstack_to_array</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.unstack_to_df" href="#vectorbt.base.reshape_fns.unstack_to_df">unstack_to_df</a></code></li>
<li><code><a title="vectorbt.base.reshape_fns.wrap_broadcasted" href="#vectorbt.base.reshape_fns.wrap_broadcasted">wrap_broadcasted</a></code></li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>