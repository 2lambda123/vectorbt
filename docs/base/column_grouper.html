<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.base.column_grouper API documentation</title>
<meta name="description" content="Class that exposes methods to group columns â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#e82}body{line-height:1.5em}.version{font-weight:normal;font-style:italic;font-size:.75em;color:#8b949e}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}h2[id^="header-"]{margin-top:2em}.ident{color:#900}.headerlink{color:inherit}.headerlink:hover{color:inherit}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important;word-break:normal}.hljs-keyword{color:#ff7b72 !important}.hljs-comment{color:#8b949e !important}.hljs-meta{color:#8b949e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 1.5em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:1em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-weight:400;font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{min-width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}.hljs{margin-left:-15px;margin-right:-15px}.source pre code{margin-left:0px;margin-right:0px}dd{margin:0 0 1em 3em}dd dd{margin-left:2em}.flex{display:flex !important}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4QLCS0J048"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4QLCS0J048');
</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:100px;max-height:100px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.base.column_grouper</code></h1>
</header>
<section id="section-intro">
<p>Class that exposes methods to group columns.</p>
<p>Class <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code> stores metadata related to grouping columns. It can return, for example,
the number of groups, the start indices of groups, and other information useful for reducing
operations that utilize grouping. It also allows to dynamically enable/disable/modify groups
and checks whether a certain operation is permitted.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Class that exposes methods to group columns.

Class `ColumnGrouper` stores metadata related to grouping columns. It can return, for example,
the number of groups, the start indices of groups, and other information useful for reducing
operations that utilize grouping. It also allows to dynamically enable/disable/modify groups
and checks whether a certain operation is permitted.&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.array import is_sorted
from vectorbt.utils.decorators import cached_method
from vectorbt.utils.config import Configured
from vectorbt.base import index_fns


GroupByT = tp.Union[None, bool, tp.Index]


def group_by_to_index(index: tp.Index, group_by: tp.GroupByLike) -&gt; GroupByT:
    &#34;&#34;&#34;Convert mapper `group_by` to `pd.Index`.

    !!! note
        Index and mapper must have the same length.&#34;&#34;&#34;
    if group_by is None or group_by is False:
        return group_by
    if group_by is True:
        group_by = pd.Index([&#39;group&#39;] * len(index))  # one group
    elif isinstance(group_by, (int, str)):
        group_by = index_fns.select_levels(index, group_by)
    elif checks.is_sequence(group_by):
        if len(group_by) != len(index) \
                and isinstance(group_by[0], (int, str)) \
                and isinstance(index, pd.MultiIndex) \
                and len(group_by) &lt;= len(index.names):
            try:
                group_by = index_fns.select_levels(index, group_by)
            except (IndexError, KeyError):
                pass
    if not isinstance(group_by, pd.Index):
        group_by = pd.Index(group_by)
    if len(group_by) != len(index):
        raise ValueError(&#34;group_by and index must have the same length&#34;)
    return group_by


def get_groups_and_index(index: tp.Index, group_by: tp.GroupByLike) -&gt; tp.Tuple[tp.Array1d, tp.Index]:
    &#34;&#34;&#34;Return array of group indices pointing to the original index, and grouped index.
    &#34;&#34;&#34;
    if group_by is None or group_by is False:
        return np.arange(len(index)), index

    group_by = group_by_to_index(index, group_by)
    codes, uniques = pd.factorize(group_by)
    if not isinstance(uniques, pd.Index):
        new_index = pd.Index(uniques)
    else:
        new_index = uniques
    if isinstance(group_by, pd.MultiIndex):
        new_index.names = group_by.names
    elif isinstance(group_by, (pd.Index, pd.Series)):
        new_index.name = group_by.name
    return codes, new_index


@njit(cache=True)
def get_group_lens_nb(groups: tp.Array1d) -&gt; tp.Array1d:
    &#34;&#34;&#34;Return count per group.&#34;&#34;&#34;
    result = np.empty(groups.shape[0], dtype=np.int_)
    j = 0
    last_group = -1
    group_len = 0
    for i in range(groups.shape[0]):
        cur_group = groups[i]
        if cur_group &lt; last_group:
            raise ValueError(&#34;Groups must be coherent and sorted (such as [0, 0, 1, 2, 2, ...])&#34;)
        if cur_group != last_group:
            if last_group != -1:
                # Process previous group
                result[j] = group_len
                j += 1
                group_len = 0
            last_group = cur_group
        group_len += 1
        if i == groups.shape[0] - 1:
            # Process last group
            result[j] = group_len
            j += 1
            group_len = 0
    return result[:j]


class ColumnGrouper(Configured):
    &#34;&#34;&#34;Class that exposes methods to group columns.

    `group_by` can be:

    * boolean (False for no grouping, True for one group),
    * integer (level by position),
    * string (level by name),
    * sequence of integers or strings that is shorter than `columns` (multiple levels),
    * any other sequence that has the same length as `columns` (group per column).

    Set `allow_enable` to False to prohibit grouping if `ColumnGrouper.group_by` is None.
    Set `allow_disable` to False to prohibit disabling of grouping if `ColumnGrouper.group_by` is not None.
    Set `allow_modify` to False to prohibit modifying groups (you can still change their labels).

    All properties are read-only to enable caching.

    !!! note
        Columns should build groups that are coherent and sorted for using `get_group_lens_nb`.

    !!! note
        This class is meant to be immutable. To change any attribute, use `ColumnGrouper.copy`.&#34;&#34;&#34;

    def __init__(self, columns: tp.Index, group_by: tp.GroupByLike = None, allow_enable: bool = True,
                 allow_disable: bool = True, allow_modify: bool = True) -&gt; None:
        Configured.__init__(
            self,
            columns=columns,
            group_by=group_by,
            allow_enable=allow_enable,
            allow_disable=allow_disable,
            allow_modify=allow_modify
        )

        checks.assert_type(columns, pd.Index)
        self._columns = columns
        if group_by is None or group_by is False:
            self._group_by = None
        else:
            self._group_by = group_by_to_index(columns, group_by)

        # Everything is allowed by default
        self._allow_enable = allow_enable
        self._allow_disable = allow_disable
        self._allow_modify = allow_modify

    @property
    def columns(self) -&gt; tp.Index:
        &#34;&#34;&#34;Original columns.&#34;&#34;&#34;
        return self._columns

    @property
    def group_by(self) -&gt; GroupByT:
        &#34;&#34;&#34;Mapper for grouping.&#34;&#34;&#34;
        return self._group_by

    @property
    def allow_enable(self) -&gt; bool:
        &#34;&#34;&#34;Whether to allow enabling grouping.&#34;&#34;&#34;
        return self._allow_enable

    @property
    def allow_disable(self) -&gt; bool:
        &#34;&#34;&#34;Whether to allow disabling grouping.&#34;&#34;&#34;
        return self._allow_disable

    @property
    def allow_modify(self) -&gt; bool:
        &#34;&#34;&#34;Whether to allow changing groups.&#34;&#34;&#34;
        return self._allow_modify

    def is_grouped(self, group_by: tp.GroupByLike = None) -&gt; bool:
        &#34;&#34;&#34;Check whether columns are grouped.&#34;&#34;&#34;
        if group_by is False:
            return False
        if group_by is None:
            group_by = self.group_by
        return group_by is not None

    def is_grouping_enabled(self, group_by: tp.GroupByLike = None) -&gt; bool:
        &#34;&#34;&#34;Check whether column grouping has been enabled.&#34;&#34;&#34;
        return self.group_by is None and self.is_grouped(group_by=group_by)

    def is_grouping_disabled(self, group_by: tp.GroupByLike = None) -&gt; bool:
        &#34;&#34;&#34;Check whether column grouping has been disabled.&#34;&#34;&#34;
        return self.group_by is not None and not self.is_grouped(group_by=group_by)

    @cached_method
    def is_grouping_modified(self, group_by: tp.GroupByLike = None) -&gt; bool:
        &#34;&#34;&#34;Check whether column grouping has been modified.

        Doesn&#39;t care if grouping labels have been changed.&#34;&#34;&#34;
        if group_by is None or (group_by is False and self.group_by is None):
            return False
        group_by = group_by_to_index(self.columns, group_by)
        if isinstance(group_by, pd.Index) and isinstance(self.group_by, pd.Index):
            if not pd.Index.equals(group_by, self.group_by):
                groups1 = get_groups_and_index(self.columns, group_by)[0]
                groups2 = get_groups_and_index(self.columns, self.group_by)[0]
                if not np.array_equal(groups1, groups2):
                    return True
            return False
        return True

    @cached_method
    def is_grouping_changed(self, group_by: tp.GroupByLike = None) -&gt; bool:
        &#34;&#34;&#34;Check whether column grouping has changed in any way.&#34;&#34;&#34;
        if group_by is None or (group_by is False and self.group_by is None):
            return False
        if isinstance(group_by, pd.Index) and isinstance(self.group_by, pd.Index):
            if pd.Index.equals(group_by, self.group_by):
                return False
        return True

    def is_group_count_changed(self, group_by: tp.GroupByLike = None) -&gt; bool:
        &#34;&#34;&#34;Check whether the number of groups has changed.&#34;&#34;&#34;
        if group_by is None or (group_by is False and self.group_by is None):
            return False
        if isinstance(group_by, pd.Index) and isinstance(self.group_by, pd.Index):
            return len(group_by) != len(self.group_by)
        return True

    def check_group_by(self, group_by: tp.GroupByLike = None, allow_enable: tp.Optional[bool] = None,
                       allow_disable: tp.Optional[bool] = None, allow_modify: tp.Optional[bool] = None) -&gt; None:
        &#34;&#34;&#34;Check passed `group_by` object against restrictions.&#34;&#34;&#34;
        if allow_enable is None:
            allow_enable = self.allow_enable
        if allow_disable is None:
            allow_disable = self.allow_disable
        if allow_modify is None:
            allow_modify = self.allow_modify

        if self.is_grouping_enabled(group_by=group_by):
            if not allow_enable:
                raise ValueError(&#34;Enabling grouping is not allowed&#34;)
        elif self.is_grouping_disabled(group_by=group_by):
            if not allow_disable:
                raise ValueError(&#34;Disabling grouping is not allowed&#34;)
        elif self.is_grouping_modified(group_by=group_by):
            if not allow_modify:
                raise ValueError(&#34;Modifying groups is not allowed&#34;)

    def resolve_group_by(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; GroupByT:
        &#34;&#34;&#34;Resolve `group_by` from either object variable or keyword argument.&#34;&#34;&#34;
        if group_by is None:
            group_by = self.group_by
        if group_by is False and self.group_by is None:
            group_by = None
        self.check_group_by(group_by=group_by, **kwargs)
        return group_by_to_index(self.columns, group_by)

    @cached_method
    def get_groups_and_columns(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.Tuple[tp.Array1d, tp.Index]:
        &#34;&#34;&#34;See `get_groups_and_index`.&#34;&#34;&#34;
        group_by = self.resolve_group_by(group_by=group_by, **kwargs)
        return get_groups_and_index(self.columns, group_by)

    def get_groups(self, **kwargs) -&gt; tp.Array1d:
        &#34;&#34;&#34;Return groups array.&#34;&#34;&#34;
        return self.get_groups_and_columns(**kwargs)[0]

    def get_columns(self, **kwargs) -&gt; tp.Index:
        &#34;&#34;&#34;Return grouped columns.&#34;&#34;&#34;
        return self.get_groups_and_columns(**kwargs)[1]

    @cached_method
    def is_sorted(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; bool:
        &#34;&#34;&#34;Return whether groups are coherent and sorted.&#34;&#34;&#34;
        group_by = self.resolve_group_by(group_by=group_by, **kwargs)
        groups = self.get_groups(group_by=group_by)
        return is_sorted(groups)

    @cached_method
    def get_group_lens(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.Array1d:
        &#34;&#34;&#34;See get_group_lens_nb.&#34;&#34;&#34;
        if not self.is_sorted(group_by=group_by):
            raise ValueError(&#34;group_by must lead to groups that are coherent and sorted &#34;
                             &#34;(such as [0, 0, 1, 2, 2, ...])&#34;)
        group_by = self.resolve_group_by(group_by=group_by, **kwargs)
        if group_by is None or group_by is False:  # no grouping
            return np.full(len(self.columns), 1)
        groups = self.get_groups(group_by=group_by)
        return get_group_lens_nb(groups)

    @cached_method
    def get_group_count(self, **kwargs) -&gt; int:
        &#34;&#34;&#34;Get number of groups.&#34;&#34;&#34;
        return len(self.get_group_lens(**kwargs))

    @cached_method
    def get_group_start_idxs(self, **kwargs) -&gt; tp.Array1d:
        &#34;&#34;&#34;Get first index of each group as an array.&#34;&#34;&#34;
        group_lens = self.get_group_lens(**kwargs)
        return np.cumsum(group_lens) - group_lens

    @cached_method
    def get_group_end_idxs(self, **kwargs) -&gt; tp.Array1d:
        &#34;&#34;&#34;Get end index of each group as an array.&#34;&#34;&#34;
        group_lens = self.get_group_lens(**kwargs)
        return np.cumsum(group_lens)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.base.column_grouper.get_group_lens_nb"><code class="name flex">
<span>def <span class="ident parent-name">get_group_lens_nb</span></span>(<span class="params">groups)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return count per group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def get_group_lens_nb(groups: tp.Array1d) -&gt; tp.Array1d:
    &#34;&#34;&#34;Return count per group.&#34;&#34;&#34;
    result = np.empty(groups.shape[0], dtype=np.int_)
    j = 0
    last_group = -1
    group_len = 0
    for i in range(groups.shape[0]):
        cur_group = groups[i]
        if cur_group &lt; last_group:
            raise ValueError(&#34;Groups must be coherent and sorted (such as [0, 0, 1, 2, 2, ...])&#34;)
        if cur_group != last_group:
            if last_group != -1:
                # Process previous group
                result[j] = group_len
                j += 1
                group_len = 0
            last_group = cur_group
        group_len += 1
        if i == groups.shape[0] - 1:
            # Process last group
            result[j] = group_len
            j += 1
            group_len = 0
    return result[:j]</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.get_groups_and_index"><code class="name flex">
<span>def <span class="ident parent-name">get_groups_and_index</span></span>(<span class="params">index, group_by)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return array of group indices pointing to the original index, and grouped index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_groups_and_index(index: tp.Index, group_by: tp.GroupByLike) -&gt; tp.Tuple[tp.Array1d, tp.Index]:
    &#34;&#34;&#34;Return array of group indices pointing to the original index, and grouped index.
    &#34;&#34;&#34;
    if group_by is None or group_by is False:
        return np.arange(len(index)), index

    group_by = group_by_to_index(index, group_by)
    codes, uniques = pd.factorize(group_by)
    if not isinstance(uniques, pd.Index):
        new_index = pd.Index(uniques)
    else:
        new_index = uniques
    if isinstance(group_by, pd.MultiIndex):
        new_index.names = group_by.names
    elif isinstance(group_by, (pd.Index, pd.Series)):
        new_index.name = group_by.name
    return codes, new_index</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.group_by_to_index"><code class="name flex">
<span>def <span class="ident parent-name">group_by_to_index</span></span>(<span class="params">index, group_by)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Convert mapper <code>group_by</code> to <code>pd.Index</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Index and mapper must have the same length.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_by_to_index(index: tp.Index, group_by: tp.GroupByLike) -&gt; GroupByT:
    &#34;&#34;&#34;Convert mapper `group_by` to `pd.Index`.

    !!! note
        Index and mapper must have the same length.&#34;&#34;&#34;
    if group_by is None or group_by is False:
        return group_by
    if group_by is True:
        group_by = pd.Index([&#39;group&#39;] * len(index))  # one group
    elif isinstance(group_by, (int, str)):
        group_by = index_fns.select_levels(index, group_by)
    elif checks.is_sequence(group_by):
        if len(group_by) != len(index) \
                and isinstance(group_by[0], (int, str)) \
                and isinstance(index, pd.MultiIndex) \
                and len(group_by) &lt;= len(index.names):
            try:
                group_by = index_fns.select_levels(index, group_by)
            except (IndexError, KeyError):
                pass
    if not isinstance(group_by, pd.Index):
        group_by = pd.Index(group_by)
    if len(group_by) != len(index):
        raise ValueError(&#34;group_by and index must have the same length&#34;)
    return group_by</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.base.column_grouper.ColumnGrouper"><code class="flex name class">
<span>class <span class="ident parent-name">ColumnGrouper</span></span>
(<span class="params">columns, group_by=None, allow_enable=True, allow_disable=True, allow_modify=True</span>)
</code></dt>
<dd>
<div class="desc"><p>Class that exposes methods to group columns.</p>
<p><code>group_by</code> can be:</p>
<ul>
<li>boolean (False for no grouping, True for one group),</li>
<li>integer (level by position),</li>
<li>string (level by name),</li>
<li>sequence of integers or strings that is shorter than <code>columns</code> (multiple levels),</li>
<li>any other sequence that has the same length as <code>columns</code> (group per column).</li>
</ul>
<p>Set <code>allow_enable</code> to False to prohibit grouping if <code><a title="vectorbt.base.column_grouper.ColumnGrouper.group_by" href="#vectorbt.base.column_grouper.ColumnGrouper.group_by">ColumnGrouper.group_by</a></code> is None.
Set <code>allow_disable</code> to False to prohibit disabling of grouping if <code><a title="vectorbt.base.column_grouper.ColumnGrouper.group_by" href="#vectorbt.base.column_grouper.ColumnGrouper.group_by">ColumnGrouper.group_by</a></code> is not None.
Set <code>allow_modify</code> to False to prohibit modifying groups (you can still change their labels).</p>
<p>All properties are read-only to enable caching.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Columns should build groups that are coherent and sorted for using <code><a title="vectorbt.base.column_grouper.get_group_lens_nb" href="#vectorbt.base.column_grouper.get_group_lens_nb">get_group_lens_nb()</a></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is meant to be immutable. To change any attribute, use <code><a title="vectorbt.base.column_grouper.ColumnGrouper.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">Configured.copy()</a></code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColumnGrouper(Configured):
    &#34;&#34;&#34;Class that exposes methods to group columns.

    `group_by` can be:

    * boolean (False for no grouping, True for one group),
    * integer (level by position),
    * string (level by name),
    * sequence of integers or strings that is shorter than `columns` (multiple levels),
    * any other sequence that has the same length as `columns` (group per column).

    Set `allow_enable` to False to prohibit grouping if `ColumnGrouper.group_by` is None.
    Set `allow_disable` to False to prohibit disabling of grouping if `ColumnGrouper.group_by` is not None.
    Set `allow_modify` to False to prohibit modifying groups (you can still change their labels).

    All properties are read-only to enable caching.

    !!! note
        Columns should build groups that are coherent and sorted for using `get_group_lens_nb`.

    !!! note
        This class is meant to be immutable. To change any attribute, use `ColumnGrouper.copy`.&#34;&#34;&#34;

    def __init__(self, columns: tp.Index, group_by: tp.GroupByLike = None, allow_enable: bool = True,
                 allow_disable: bool = True, allow_modify: bool = True) -&gt; None:
        Configured.__init__(
            self,
            columns=columns,
            group_by=group_by,
            allow_enable=allow_enable,
            allow_disable=allow_disable,
            allow_modify=allow_modify
        )

        checks.assert_type(columns, pd.Index)
        self._columns = columns
        if group_by is None or group_by is False:
            self._group_by = None
        else:
            self._group_by = group_by_to_index(columns, group_by)

        # Everything is allowed by default
        self._allow_enable = allow_enable
        self._allow_disable = allow_disable
        self._allow_modify = allow_modify

    @property
    def columns(self) -&gt; tp.Index:
        &#34;&#34;&#34;Original columns.&#34;&#34;&#34;
        return self._columns

    @property
    def group_by(self) -&gt; GroupByT:
        &#34;&#34;&#34;Mapper for grouping.&#34;&#34;&#34;
        return self._group_by

    @property
    def allow_enable(self) -&gt; bool:
        &#34;&#34;&#34;Whether to allow enabling grouping.&#34;&#34;&#34;
        return self._allow_enable

    @property
    def allow_disable(self) -&gt; bool:
        &#34;&#34;&#34;Whether to allow disabling grouping.&#34;&#34;&#34;
        return self._allow_disable

    @property
    def allow_modify(self) -&gt; bool:
        &#34;&#34;&#34;Whether to allow changing groups.&#34;&#34;&#34;
        return self._allow_modify

    def is_grouped(self, group_by: tp.GroupByLike = None) -&gt; bool:
        &#34;&#34;&#34;Check whether columns are grouped.&#34;&#34;&#34;
        if group_by is False:
            return False
        if group_by is None:
            group_by = self.group_by
        return group_by is not None

    def is_grouping_enabled(self, group_by: tp.GroupByLike = None) -&gt; bool:
        &#34;&#34;&#34;Check whether column grouping has been enabled.&#34;&#34;&#34;
        return self.group_by is None and self.is_grouped(group_by=group_by)

    def is_grouping_disabled(self, group_by: tp.GroupByLike = None) -&gt; bool:
        &#34;&#34;&#34;Check whether column grouping has been disabled.&#34;&#34;&#34;
        return self.group_by is not None and not self.is_grouped(group_by=group_by)

    @cached_method
    def is_grouping_modified(self, group_by: tp.GroupByLike = None) -&gt; bool:
        &#34;&#34;&#34;Check whether column grouping has been modified.

        Doesn&#39;t care if grouping labels have been changed.&#34;&#34;&#34;
        if group_by is None or (group_by is False and self.group_by is None):
            return False
        group_by = group_by_to_index(self.columns, group_by)
        if isinstance(group_by, pd.Index) and isinstance(self.group_by, pd.Index):
            if not pd.Index.equals(group_by, self.group_by):
                groups1 = get_groups_and_index(self.columns, group_by)[0]
                groups2 = get_groups_and_index(self.columns, self.group_by)[0]
                if not np.array_equal(groups1, groups2):
                    return True
            return False
        return True

    @cached_method
    def is_grouping_changed(self, group_by: tp.GroupByLike = None) -&gt; bool:
        &#34;&#34;&#34;Check whether column grouping has changed in any way.&#34;&#34;&#34;
        if group_by is None or (group_by is False and self.group_by is None):
            return False
        if isinstance(group_by, pd.Index) and isinstance(self.group_by, pd.Index):
            if pd.Index.equals(group_by, self.group_by):
                return False
        return True

    def is_group_count_changed(self, group_by: tp.GroupByLike = None) -&gt; bool:
        &#34;&#34;&#34;Check whether the number of groups has changed.&#34;&#34;&#34;
        if group_by is None or (group_by is False and self.group_by is None):
            return False
        if isinstance(group_by, pd.Index) and isinstance(self.group_by, pd.Index):
            return len(group_by) != len(self.group_by)
        return True

    def check_group_by(self, group_by: tp.GroupByLike = None, allow_enable: tp.Optional[bool] = None,
                       allow_disable: tp.Optional[bool] = None, allow_modify: tp.Optional[bool] = None) -&gt; None:
        &#34;&#34;&#34;Check passed `group_by` object against restrictions.&#34;&#34;&#34;
        if allow_enable is None:
            allow_enable = self.allow_enable
        if allow_disable is None:
            allow_disable = self.allow_disable
        if allow_modify is None:
            allow_modify = self.allow_modify

        if self.is_grouping_enabled(group_by=group_by):
            if not allow_enable:
                raise ValueError(&#34;Enabling grouping is not allowed&#34;)
        elif self.is_grouping_disabled(group_by=group_by):
            if not allow_disable:
                raise ValueError(&#34;Disabling grouping is not allowed&#34;)
        elif self.is_grouping_modified(group_by=group_by):
            if not allow_modify:
                raise ValueError(&#34;Modifying groups is not allowed&#34;)

    def resolve_group_by(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; GroupByT:
        &#34;&#34;&#34;Resolve `group_by` from either object variable or keyword argument.&#34;&#34;&#34;
        if group_by is None:
            group_by = self.group_by
        if group_by is False and self.group_by is None:
            group_by = None
        self.check_group_by(group_by=group_by, **kwargs)
        return group_by_to_index(self.columns, group_by)

    @cached_method
    def get_groups_and_columns(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.Tuple[tp.Array1d, tp.Index]:
        &#34;&#34;&#34;See `get_groups_and_index`.&#34;&#34;&#34;
        group_by = self.resolve_group_by(group_by=group_by, **kwargs)
        return get_groups_and_index(self.columns, group_by)

    def get_groups(self, **kwargs) -&gt; tp.Array1d:
        &#34;&#34;&#34;Return groups array.&#34;&#34;&#34;
        return self.get_groups_and_columns(**kwargs)[0]

    def get_columns(self, **kwargs) -&gt; tp.Index:
        &#34;&#34;&#34;Return grouped columns.&#34;&#34;&#34;
        return self.get_groups_and_columns(**kwargs)[1]

    @cached_method
    def is_sorted(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; bool:
        &#34;&#34;&#34;Return whether groups are coherent and sorted.&#34;&#34;&#34;
        group_by = self.resolve_group_by(group_by=group_by, **kwargs)
        groups = self.get_groups(group_by=group_by)
        return is_sorted(groups)

    @cached_method
    def get_group_lens(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.Array1d:
        &#34;&#34;&#34;See get_group_lens_nb.&#34;&#34;&#34;
        if not self.is_sorted(group_by=group_by):
            raise ValueError(&#34;group_by must lead to groups that are coherent and sorted &#34;
                             &#34;(such as [0, 0, 1, 2, 2, ...])&#34;)
        group_by = self.resolve_group_by(group_by=group_by, **kwargs)
        if group_by is None or group_by is False:  # no grouping
            return np.full(len(self.columns), 1)
        groups = self.get_groups(group_by=group_by)
        return get_group_lens_nb(groups)

    @cached_method
    def get_group_count(self, **kwargs) -&gt; int:
        &#34;&#34;&#34;Get number of groups.&#34;&#34;&#34;
        return len(self.get_group_lens(**kwargs))

    @cached_method
    def get_group_start_idxs(self, **kwargs) -&gt; tp.Array1d:
        &#34;&#34;&#34;Get first index of each group as an array.&#34;&#34;&#34;
        group_lens = self.get_group_lens(**kwargs)
        return np.cumsum(group_lens) - group_lens

    @cached_method
    def get_group_end_idxs(self, **kwargs) -&gt; tp.Array1d:
        &#34;&#34;&#34;Get end index of each group as an array.&#34;&#34;&#34;
        group_lens = self.get_group_lens(**kwargs)
        return np.cumsum(group_lens)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.allow_disable"><code class="name">var <span class="ident child-name">allow_disable</span></code></dt>
<dd>
<div class="desc"><p>Whether to allow disabling grouping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def allow_disable(self) -&gt; bool:
    &#34;&#34;&#34;Whether to allow disabling grouping.&#34;&#34;&#34;
    return self._allow_disable</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.allow_enable"><code class="name">var <span class="ident child-name">allow_enable</span></code></dt>
<dd>
<div class="desc"><p>Whether to allow enabling grouping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def allow_enable(self) -&gt; bool:
    &#34;&#34;&#34;Whether to allow enabling grouping.&#34;&#34;&#34;
    return self._allow_enable</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.allow_modify"><code class="name">var <span class="ident child-name">allow_modify</span></code></dt>
<dd>
<div class="desc"><p>Whether to allow changing groups.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def allow_modify(self) -&gt; bool:
    &#34;&#34;&#34;Whether to allow changing groups.&#34;&#34;&#34;
    return self._allow_modify</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.columns"><code class="name">var <span class="ident child-name">columns</span></code></dt>
<dd>
<div class="desc"><p>Original columns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def columns(self) -&gt; tp.Index:
    &#34;&#34;&#34;Original columns.&#34;&#34;&#34;
    return self._columns</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.group_by"><code class="name">var <span class="ident child-name">group_by</span></code></dt>
<dd>
<div class="desc"><p>Mapper for grouping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def group_by(self) -&gt; GroupByT:
    &#34;&#34;&#34;Mapper for grouping.&#34;&#34;&#34;
    return self._group_by</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.check_group_by"><code class="name flex">
<span>def <span class="ident child-name">check_group_by</span></span>(<span class="params">self, group_by=None, allow_enable=None, allow_disable=None, allow_modify=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Check passed <code>group_by</code> object against restrictions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_group_by(self, group_by: tp.GroupByLike = None, allow_enable: tp.Optional[bool] = None,
                   allow_disable: tp.Optional[bool] = None, allow_modify: tp.Optional[bool] = None) -&gt; None:
    &#34;&#34;&#34;Check passed `group_by` object against restrictions.&#34;&#34;&#34;
    if allow_enable is None:
        allow_enable = self.allow_enable
    if allow_disable is None:
        allow_disable = self.allow_disable
    if allow_modify is None:
        allow_modify = self.allow_modify

    if self.is_grouping_enabled(group_by=group_by):
        if not allow_enable:
            raise ValueError(&#34;Enabling grouping is not allowed&#34;)
    elif self.is_grouping_disabled(group_by=group_by):
        if not allow_disable:
            raise ValueError(&#34;Disabling grouping is not allowed&#34;)
    elif self.is_grouping_modified(group_by=group_by):
        if not allow_modify:
            raise ValueError(&#34;Modifying groups is not allowed&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.get_columns"><code class="name flex">
<span>def <span class="ident child-name">get_columns</span></span>(<span class="params">self, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return grouped columns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_columns(self, **kwargs) -&gt; tp.Index:
    &#34;&#34;&#34;Return grouped columns.&#34;&#34;&#34;
    return self.get_groups_and_columns(**kwargs)[1]</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.get_group_count"><code class="name flex">
<span>def <span class="ident child-name">get_group_count</span></span>(<span class="params">self, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get number of groups.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def get_group_count(self, **kwargs) -&gt; int:
    &#34;&#34;&#34;Get number of groups.&#34;&#34;&#34;
    return len(self.get_group_lens(**kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.get_group_end_idxs"><code class="name flex">
<span>def <span class="ident child-name">get_group_end_idxs</span></span>(<span class="params">self, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get end index of each group as an array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def get_group_end_idxs(self, **kwargs) -&gt; tp.Array1d:
    &#34;&#34;&#34;Get end index of each group as an array.&#34;&#34;&#34;
    group_lens = self.get_group_lens(**kwargs)
    return np.cumsum(group_lens)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.get_group_lens"><code class="name flex">
<span>def <span class="ident child-name">get_group_lens</span></span>(<span class="params">self, group_by=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>See get_group_lens_nb.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def get_group_lens(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.Array1d:
    &#34;&#34;&#34;See get_group_lens_nb.&#34;&#34;&#34;
    if not self.is_sorted(group_by=group_by):
        raise ValueError(&#34;group_by must lead to groups that are coherent and sorted &#34;
                         &#34;(such as [0, 0, 1, 2, 2, ...])&#34;)
    group_by = self.resolve_group_by(group_by=group_by, **kwargs)
    if group_by is None or group_by is False:  # no grouping
        return np.full(len(self.columns), 1)
    groups = self.get_groups(group_by=group_by)
    return get_group_lens_nb(groups)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.get_group_start_idxs"><code class="name flex">
<span>def <span class="ident child-name">get_group_start_idxs</span></span>(<span class="params">self, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get first index of each group as an array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def get_group_start_idxs(self, **kwargs) -&gt; tp.Array1d:
    &#34;&#34;&#34;Get first index of each group as an array.&#34;&#34;&#34;
    group_lens = self.get_group_lens(**kwargs)
    return np.cumsum(group_lens) - group_lens</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.get_groups"><code class="name flex">
<span>def <span class="ident child-name">get_groups</span></span>(<span class="params">self, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return groups array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_groups(self, **kwargs) -&gt; tp.Array1d:
    &#34;&#34;&#34;Return groups array.&#34;&#34;&#34;
    return self.get_groups_and_columns(**kwargs)[0]</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.get_groups_and_columns"><code class="name flex">
<span>def <span class="ident child-name">get_groups_and_columns</span></span>(<span class="params">self, group_by=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.base.column_grouper.get_groups_and_index" href="#vectorbt.base.column_grouper.get_groups_and_index">get_groups_and_index()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def get_groups_and_columns(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.Tuple[tp.Array1d, tp.Index]:
    &#34;&#34;&#34;See `get_groups_and_index`.&#34;&#34;&#34;
    group_by = self.resolve_group_by(group_by=group_by, **kwargs)
    return get_groups_and_index(self.columns, group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.is_group_count_changed"><code class="name flex">
<span>def <span class="ident child-name">is_group_count_changed</span></span>(<span class="params">self, group_by=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the number of groups has changed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_group_count_changed(self, group_by: tp.GroupByLike = None) -&gt; bool:
    &#34;&#34;&#34;Check whether the number of groups has changed.&#34;&#34;&#34;
    if group_by is None or (group_by is False and self.group_by is None):
        return False
    if isinstance(group_by, pd.Index) and isinstance(self.group_by, pd.Index):
        return len(group_by) != len(self.group_by)
    return True</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.is_grouped"><code class="name flex">
<span>def <span class="ident child-name">is_grouped</span></span>(<span class="params">self, group_by=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Check whether columns are grouped.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_grouped(self, group_by: tp.GroupByLike = None) -&gt; bool:
    &#34;&#34;&#34;Check whether columns are grouped.&#34;&#34;&#34;
    if group_by is False:
        return False
    if group_by is None:
        group_by = self.group_by
    return group_by is not None</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.is_grouping_changed"><code class="name flex">
<span>def <span class="ident child-name">is_grouping_changed</span></span>(<span class="params">self, group_by=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Check whether column grouping has changed in any way.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def is_grouping_changed(self, group_by: tp.GroupByLike = None) -&gt; bool:
    &#34;&#34;&#34;Check whether column grouping has changed in any way.&#34;&#34;&#34;
    if group_by is None or (group_by is False and self.group_by is None):
        return False
    if isinstance(group_by, pd.Index) and isinstance(self.group_by, pd.Index):
        if pd.Index.equals(group_by, self.group_by):
            return False
    return True</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.is_grouping_disabled"><code class="name flex">
<span>def <span class="ident child-name">is_grouping_disabled</span></span>(<span class="params">self, group_by=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Check whether column grouping has been disabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_grouping_disabled(self, group_by: tp.GroupByLike = None) -&gt; bool:
    &#34;&#34;&#34;Check whether column grouping has been disabled.&#34;&#34;&#34;
    return self.group_by is not None and not self.is_grouped(group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.is_grouping_enabled"><code class="name flex">
<span>def <span class="ident child-name">is_grouping_enabled</span></span>(<span class="params">self, group_by=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Check whether column grouping has been enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_grouping_enabled(self, group_by: tp.GroupByLike = None) -&gt; bool:
    &#34;&#34;&#34;Check whether column grouping has been enabled.&#34;&#34;&#34;
    return self.group_by is None and self.is_grouped(group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.is_grouping_modified"><code class="name flex">
<span>def <span class="ident child-name">is_grouping_modified</span></span>(<span class="params">self, group_by=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Check whether column grouping has been modified.</p>
<p>Doesn't care if grouping labels have been changed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def is_grouping_modified(self, group_by: tp.GroupByLike = None) -&gt; bool:
    &#34;&#34;&#34;Check whether column grouping has been modified.

    Doesn&#39;t care if grouping labels have been changed.&#34;&#34;&#34;
    if group_by is None or (group_by is False and self.group_by is None):
        return False
    group_by = group_by_to_index(self.columns, group_by)
    if isinstance(group_by, pd.Index) and isinstance(self.group_by, pd.Index):
        if not pd.Index.equals(group_by, self.group_by):
            groups1 = get_groups_and_index(self.columns, group_by)[0]
            groups2 = get_groups_and_index(self.columns, self.group_by)[0]
            if not np.array_equal(groups1, groups2):
                return True
        return False
    return True</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.is_sorted"><code class="name flex">
<span>def <span class="ident child-name">is_sorted</span></span>(<span class="params">self, group_by=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return whether groups are coherent and sorted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def is_sorted(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; bool:
    &#34;&#34;&#34;Return whether groups are coherent and sorted.&#34;&#34;&#34;
    group_by = self.resolve_group_by(group_by=group_by, **kwargs)
    groups = self.get_groups(group_by=group_by)
    return is_sorted(groups)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.column_grouper.ColumnGrouper.resolve_group_by"><code class="name flex">
<span>def <span class="ident child-name">resolve_group_by</span></span>(<span class="params">self, group_by=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve <code>group_by</code> from either object variable or keyword argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_group_by(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; GroupByT:
    &#34;&#34;&#34;Resolve `group_by` from either object variable or keyword argument.&#34;&#34;&#34;
    if group_by is None:
        group_by = self.group_by
    if group_by is False and self.group_by is None:
        group_by = None
    self.check_group_by(group_by=group_by, **kwargs)
    return group_by_to_index(self.columns, group_by)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.utils.config.Configured.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRUYwMDAwO30KCS5zdDF7ZmlsbDojRkY5MDAwO30KCS5zdDJ7ZmlsbDojRkZERjAwO30KCS5zdDN7ZmlsbDojMjgyQzM0O30KPC9zdHlsZT4KPGc+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNTUuMywzMDAuMSAyODMuMSwwIDIwOCwwIDExMC44LDAgMzUuOCwwIDEuMiw0NTAuMiA3Ni4zLDQ1MC4yIAkJCSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjIzMC40LDMwMC4xIDM1OC4xLDAgMjgzLjEsMCAxODUuOCwwIDExMC44LDAgNzYuMyw0NTAuMiAxNTEuMyw0NTAuMiAJCQkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIzMDUuNCwzMDAuMSA0MzMuMSwwIDM1OC4xLDAgMzMxLjYsNjIuMyAyNjAuOCwwIDE4NS44LDAgMTUxLjMsNDUwLjIgMjI2LjQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iNTEwLjgsMCA0MzMuMSwwIDMwNS40LDMwMC4xIDMzOC40LDAgMjYwLjgsMCAyMjYuNCw0NTAuMiAzMDQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="/>
vectorbt <span class="version">0.20.0</span></a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.base" href="index.html">vectorbt.base</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.base.column_grouper.get_group_lens_nb" href="#vectorbt.base.column_grouper.get_group_lens_nb">get_group_lens_nb</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.get_groups_and_index" href="#vectorbt.base.column_grouper.get_groups_and_index">get_groups_and_index</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.group_by_to_index" href="#vectorbt.base.column_grouper.group_by_to_index">group_by_to_index</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.allow_disable" href="#vectorbt.base.column_grouper.ColumnGrouper.allow_disable">allow_disable</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.allow_enable" href="#vectorbt.base.column_grouper.ColumnGrouper.allow_enable">allow_enable</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.allow_modify" href="#vectorbt.base.column_grouper.ColumnGrouper.allow_modify">allow_modify</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.check_group_by" href="#vectorbt.base.column_grouper.ColumnGrouper.check_group_by">check_group_by</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.columns" href="#vectorbt.base.column_grouper.ColumnGrouper.columns">columns</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.get_columns" href="#vectorbt.base.column_grouper.ColumnGrouper.get_columns">get_columns</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.get_group_count" href="#vectorbt.base.column_grouper.ColumnGrouper.get_group_count">get_group_count</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.get_group_end_idxs" href="#vectorbt.base.column_grouper.ColumnGrouper.get_group_end_idxs">get_group_end_idxs</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.get_group_lens" href="#vectorbt.base.column_grouper.ColumnGrouper.get_group_lens">get_group_lens</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.get_group_start_idxs" href="#vectorbt.base.column_grouper.ColumnGrouper.get_group_start_idxs">get_group_start_idxs</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.get_groups" href="#vectorbt.base.column_grouper.ColumnGrouper.get_groups">get_groups</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.get_groups_and_columns" href="#vectorbt.base.column_grouper.ColumnGrouper.get_groups_and_columns">get_groups_and_columns</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.group_by" href="#vectorbt.base.column_grouper.ColumnGrouper.group_by">group_by</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.is_group_count_changed" href="#vectorbt.base.column_grouper.ColumnGrouper.is_group_count_changed">is_group_count_changed</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.is_grouped" href="#vectorbt.base.column_grouper.ColumnGrouper.is_grouped">is_grouped</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.is_grouping_changed" href="#vectorbt.base.column_grouper.ColumnGrouper.is_grouping_changed">is_grouping_changed</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.is_grouping_disabled" href="#vectorbt.base.column_grouper.ColumnGrouper.is_grouping_disabled">is_grouping_disabled</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.is_grouping_enabled" href="#vectorbt.base.column_grouper.ColumnGrouper.is_grouping_enabled">is_grouping_enabled</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.is_grouping_modified" href="#vectorbt.base.column_grouper.ColumnGrouper.is_grouping_modified">is_grouping_modified</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.is_sorted" href="#vectorbt.base.column_grouper.ColumnGrouper.is_sorted">is_sorted</a></code></li>
<li><code><a title="vectorbt.base.column_grouper.ColumnGrouper.resolve_group_by" href="#vectorbt.base.column_grouper.ColumnGrouper.resolve_group_by">resolve_group_by</a></code></li>
</ul>
</li>
</ul>
</li>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous"></script>
<script>
$(document).ready(function() {
$("article dt[id], #section-intro [id]").each(function() {
const thisId = $(this).attr('id');
$(this).wrap('<a class="headerlink" href="#' + thisId + '">');
});
});
</script>
</body>
</html>