<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.base.index_fns API documentation</title>
<meta name="description" content="Functions for working with index/columns." />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:rgba(0,0,0,.2);border:none;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3A4D6B}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.base.index_fns</code></h1>
</header>
<section id="section-intro">
<p>Functions for working with index/columns.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions for working with index/columns.&#34;&#34;&#34;

import numpy as np
import pandas as pd
from collections.abc import Iterable

from vectorbt import defaults
from vectorbt.utils import checks


def get_index(arg, axis):
    &#34;&#34;&#34;Get index of `arg` by `axis`.&#34;&#34;&#34;
    checks.assert_type(arg, (pd.Series, pd.DataFrame))
    checks.assert_value_in(axis, (0, 1))

    if axis == 0:
        return arg.index
    else:
        if checks.is_series(arg):
            if arg.name is not None:
                return pd.Index([arg.name])
            return pd.Index([0])  # same as how pandas does it
        else:
            return arg.columns


def index_from_values(values, name=None):
    &#34;&#34;&#34;Create a new `pd.Index` with `name` by parsing an iterable `values`.

    Each in `values` will correspond to an element in the new index.&#34;&#34;&#34;
    checks.assert_type(values, Iterable)

    value_names = []
    for i, v in enumerate(values):
        v = np.asarray(v)
        if np.all(v == v.item(0)):
            value_names.append(v.item(0))
        else:
            value_names.append(&#39;mix_%d&#39; % i)
    return pd.Index(value_names, name=name)


def repeat_index(index, n):
    &#34;&#34;&#34;Repeat each element in `index` `n` times.&#34;&#34;&#34;
    if not isinstance(index, pd.Index):
        index = pd.Index(index)
    if pd.Index.equals(index, pd.RangeIndex(start=0, stop=len(index), step=1)):  # ignore simple ranges without name
        return pd.RangeIndex(start=0, stop=n, step=1)
    return np.repeat(index, n)


def tile_index(index, n):
    &#34;&#34;&#34;Tile the whole `index` `n` times.&#34;&#34;&#34;
    if not isinstance(index, pd.Index):
        index = pd.Index(index)
    if pd.Index.equals(index, pd.RangeIndex(start=0, stop=len(index), step=1)):  # ignore simple ranges without name
        return pd.RangeIndex(start=0, stop=n, step=1)
    if isinstance(index, pd.MultiIndex):
        return pd.MultiIndex.from_tuples(np.tile(index, n), names=index.names)
    return pd.Index(np.tile(index, n), name=index.name)


def stack_indexes(*indexes):
    &#34;&#34;&#34;Stack each index in `indexes` on top of each other, from top to bottom.&#34;&#34;&#34;
    new_index = indexes[0]
    for i in range(1, len(indexes)):
        index1, index2 = new_index, indexes[i]
        checks.assert_same_shape(index1, index2)
        if not isinstance(index1, pd.MultiIndex):
            index1 = pd.MultiIndex.from_arrays([index1])
        if not isinstance(index2, pd.MultiIndex):
            index2 = pd.MultiIndex.from_arrays([index2])

        levels = []
        for i in range(index1.nlevels):
            levels.append(index1.get_level_values(i))
        for i in range(index2.nlevels):
            levels.append(index2.get_level_values(i))

        new_index = pd.MultiIndex.from_arrays(levels)
    return new_index


def combine_indexes(*indexes, ignore_single=None):
    &#34;&#34;&#34;Combine each index in `indexes` using Cartesian product.

    If `ignore_single` is `True`, ignores indexes/columns with one value. If both are with one
    value, will keep both regardless of `ignore_single`.

    For defaults, see `vectorbt.defaults.broadcasting`.&#34;&#34;&#34;
    if ignore_single is None:
        ignore_single = defaults.broadcasting[&#39;ignore_single&#39;]

    new_index = indexes[0]
    for i in range(1, len(indexes)):
        index1, index2 = new_index, indexes[i]
        if not isinstance(index1, pd.Index):
            index1 = pd.Index(index1)
        if not isinstance(index2, pd.Index):
            index2 = pd.Index(index2)

        if ignore_single:
            if len(index1) &gt; 1 or len(index2) &gt; 1:
                if len(index1) == 1:
                    new_index = index2
                    continue
                if len(index2) == 1:
                    new_index = index1
                    continue
        tuples1 = np.repeat(index1.to_numpy(), len(index2))
        tuples2 = np.tile(index2.to_numpy(), len(index1))

        if isinstance(index1, pd.MultiIndex):
            index1 = pd.MultiIndex.from_tuples(tuples1, names=index1.names)
        else:
            index1 = pd.Index(tuples1, name=index1.name)
        if isinstance(index2, pd.MultiIndex):
            index2 = pd.MultiIndex.from_tuples(tuples2, names=index2.names)
        else:
            index2 = pd.Index(tuples2, name=index2.name)

        new_index = stack_indexes(index1, index2)
    return new_index


def drop_levels(index, levels):
    &#34;&#34;&#34;Softly drop `levels` in `index` by their name/position.&#34;&#34;&#34;
    if not isinstance(index, pd.MultiIndex):
        return index

    levels_to_drop = []
    if not isinstance(levels, (tuple, list)):
        levels = [levels]
    for level in levels:
        if level in index.names:
            if level not in levels_to_drop:
                levels_to_drop.append(level)
        elif isinstance(level, int):
            if 0 &lt;= level &lt; index.nlevels or level == -1:
                if level not in levels_to_drop:
                    levels_to_drop.append(level)
    if len(levels_to_drop) &lt; index.nlevels:
        # Drop only if there will be some indexes left
        return index.droplevel(levels_to_drop)
    return index


def rename_levels(index, name_dict):
    &#34;&#34;&#34;Rename levels in `index` by `name_dict`.&#34;&#34;&#34;
    for k, v in name_dict.items():
        if isinstance(index, pd.MultiIndex):
            if k in index.names:
                index = index.rename(v, level=k)
        else:
            if index.name == k:
                index.name = v
    return index


def select_levels(index, level_names):
    &#34;&#34;&#34;Build a new index by selecting one or multiple `level_names` from `index`.&#34;&#34;&#34;
    checks.assert_type(index, pd.MultiIndex)

    if isinstance(level_names, (list, tuple)):
        levels = [index.get_level_values(level_name) for level_name in level_names]
        return pd.MultiIndex.from_arrays(levels)
    else:
        return index.get_level_values(level_names)


def drop_redundant_levels(index):
    &#34;&#34;&#34;Drop levels in `index` that either have a single value or a range from 0 to n.&#34;&#34;&#34;
    if not isinstance(index, pd.MultiIndex):
        return index
    if len(index) == 1:
        return index

    levels_to_drop = []
    for i, level in enumerate(index.levels):
        if len(level) == 1:
            levels_to_drop.append(i)
        elif level.name is None and (level == np.arange(len(level))).all():  # basic range
            if len(index.get_level_values(i)) == len(level):
                levels_to_drop.append(i)
    # Remove redundant levels only if there are some non-redundant levels left
    if len(levels_to_drop) &lt; index.nlevels:
        return index.droplevel(levels_to_drop)
    return index


def drop_duplicate_levels(index, keep=&#39;last&#39;):
    &#34;&#34;&#34;Drop levels in `index` with the same name and values.

    Set `keep` to &#39;last&#39; to keep last levels, otherwise &#39;first&#39;.&#34;&#34;&#34;
    if not isinstance(index, pd.MultiIndex):
        return index

    levels = []
    levels_to_drop = []
    if keep == &#39;first&#39;:
        r = range(0, index.nlevels)
    elif keep == &#39;last&#39;:
        r = range(index.nlevels-1, -1, -1)  # loop backwards
    for i in r:
        level = (index.levels[i].name, tuple(index.get_level_values(i).to_numpy().tolist()))
        if level not in levels:
            levels.append(level)
        else:
            levels_to_drop.append(i)
    return index.droplevel(levels_to_drop)


def align_index_to(index1, index2):
    &#34;&#34;&#34;Align `index1` to have the same shape of `index2`.

    Returns integer indices of occurrences and None if aligning not needed.

    The second one must contain all levels from the first (and can have some more). In all these levels, 
    both must share the same elements.&#34;&#34;&#34;
    if not isinstance(index1, pd.MultiIndex):
        index1 = pd.MultiIndex.from_arrays([index1])
    if not isinstance(index2, pd.MultiIndex):
        index2 = pd.MultiIndex.from_arrays([index2])
    if index1.duplicated().any():
        raise ValueError(&#34;Duplicates index values are not allowed for the first index&#34;)

    if pd.Index.equals(index1, index2):
        return pd.IndexSlice[:]
    if len(index1) &lt;= len(index2):
        if len(index1) == 1:
            return pd.IndexSlice[np.tile([0])]
        js = []
        for i in range(index1.nlevels):
            for j in range(index2.nlevels):
                if index1.names[i] == index2.names[j]:
                    if np.array_equal(index1.levels[i], index2.levels[j]):
                        js.append(j)
                        break
        if index1.nlevels == len(js):
            new_index = pd.MultiIndex.from_arrays([index2.get_level_values(j) for j in js])
            xsorted = np.argsort(index1)
            ypos = np.searchsorted(index1[xsorted], new_index)
            return pd.IndexSlice[xsorted[ypos]]

    raise ValueError(&#34;Indexes could not be aligned together&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.base.index_fns.align_index_to"><code class="name flex">
<span>def <span class="ident fname">align_index_to</span></span>(<span>index1, index2)</span>
</code></dt>
<dd>
<div class="desc"><p>Align <code>index1</code> to have the same shape of <code>index2</code>.</p>
<p>Returns integer indices of occurrences and None if aligning not needed.</p>
<p>The second one must contain all levels from the first (and can have some more). In all these levels,
both must share the same elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_index_to(index1, index2):
    &#34;&#34;&#34;Align `index1` to have the same shape of `index2`.

    Returns integer indices of occurrences and None if aligning not needed.

    The second one must contain all levels from the first (and can have some more). In all these levels, 
    both must share the same elements.&#34;&#34;&#34;
    if not isinstance(index1, pd.MultiIndex):
        index1 = pd.MultiIndex.from_arrays([index1])
    if not isinstance(index2, pd.MultiIndex):
        index2 = pd.MultiIndex.from_arrays([index2])
    if index1.duplicated().any():
        raise ValueError(&#34;Duplicates index values are not allowed for the first index&#34;)

    if pd.Index.equals(index1, index2):
        return pd.IndexSlice[:]
    if len(index1) &lt;= len(index2):
        if len(index1) == 1:
            return pd.IndexSlice[np.tile([0])]
        js = []
        for i in range(index1.nlevels):
            for j in range(index2.nlevels):
                if index1.names[i] == index2.names[j]:
                    if np.array_equal(index1.levels[i], index2.levels[j]):
                        js.append(j)
                        break
        if index1.nlevels == len(js):
            new_index = pd.MultiIndex.from_arrays([index2.get_level_values(j) for j in js])
            xsorted = np.argsort(index1)
            ypos = np.searchsorted(index1[xsorted], new_index)
            return pd.IndexSlice[xsorted[ypos]]

    raise ValueError(&#34;Indexes could not be aligned together&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.index_fns.combine_indexes"><code class="name flex">
<span>def <span class="ident fname">combine_indexes</span></span>(<span>*indexes, ignore_single=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Combine each index in <code>indexes</code> using Cartesian product.</p>
<p>If <code>ignore_single</code> is <code>True</code>, ignores indexes/columns with one value. If both are with one
value, will keep both regardless of <code>ignore_single</code>.</p>
<p>For defaults, see <code><a title="vectorbt.defaults.broadcasting" href="../defaults.html#vectorbt.defaults.broadcasting">broadcasting</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_indexes(*indexes, ignore_single=None):
    &#34;&#34;&#34;Combine each index in `indexes` using Cartesian product.

    If `ignore_single` is `True`, ignores indexes/columns with one value. If both are with one
    value, will keep both regardless of `ignore_single`.

    For defaults, see `vectorbt.defaults.broadcasting`.&#34;&#34;&#34;
    if ignore_single is None:
        ignore_single = defaults.broadcasting[&#39;ignore_single&#39;]

    new_index = indexes[0]
    for i in range(1, len(indexes)):
        index1, index2 = new_index, indexes[i]
        if not isinstance(index1, pd.Index):
            index1 = pd.Index(index1)
        if not isinstance(index2, pd.Index):
            index2 = pd.Index(index2)

        if ignore_single:
            if len(index1) &gt; 1 or len(index2) &gt; 1:
                if len(index1) == 1:
                    new_index = index2
                    continue
                if len(index2) == 1:
                    new_index = index1
                    continue
        tuples1 = np.repeat(index1.to_numpy(), len(index2))
        tuples2 = np.tile(index2.to_numpy(), len(index1))

        if isinstance(index1, pd.MultiIndex):
            index1 = pd.MultiIndex.from_tuples(tuples1, names=index1.names)
        else:
            index1 = pd.Index(tuples1, name=index1.name)
        if isinstance(index2, pd.MultiIndex):
            index2 = pd.MultiIndex.from_tuples(tuples2, names=index2.names)
        else:
            index2 = pd.Index(tuples2, name=index2.name)

        new_index = stack_indexes(index1, index2)
    return new_index</code></pre>
</details>
</dd>
<dt id="vectorbt.base.index_fns.drop_duplicate_levels"><code class="name flex">
<span>def <span class="ident fname">drop_duplicate_levels</span></span>(<span>index, keep='last')</span>
</code></dt>
<dd>
<div class="desc"><p>Drop levels in <code>index</code> with the same name and values.</p>
<p>Set <code>keep</code> to 'last' to keep last levels, otherwise 'first'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drop_duplicate_levels(index, keep=&#39;last&#39;):
    &#34;&#34;&#34;Drop levels in `index` with the same name and values.

    Set `keep` to &#39;last&#39; to keep last levels, otherwise &#39;first&#39;.&#34;&#34;&#34;
    if not isinstance(index, pd.MultiIndex):
        return index

    levels = []
    levels_to_drop = []
    if keep == &#39;first&#39;:
        r = range(0, index.nlevels)
    elif keep == &#39;last&#39;:
        r = range(index.nlevels-1, -1, -1)  # loop backwards
    for i in r:
        level = (index.levels[i].name, tuple(index.get_level_values(i).to_numpy().tolist()))
        if level not in levels:
            levels.append(level)
        else:
            levels_to_drop.append(i)
    return index.droplevel(levels_to_drop)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.index_fns.drop_levels"><code class="name flex">
<span>def <span class="ident fname">drop_levels</span></span>(<span>index, levels)</span>
</code></dt>
<dd>
<div class="desc"><p>Softly drop <code>levels</code> in <code>index</code> by their name/position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drop_levels(index, levels):
    &#34;&#34;&#34;Softly drop `levels` in `index` by their name/position.&#34;&#34;&#34;
    if not isinstance(index, pd.MultiIndex):
        return index

    levels_to_drop = []
    if not isinstance(levels, (tuple, list)):
        levels = [levels]
    for level in levels:
        if level in index.names:
            if level not in levels_to_drop:
                levels_to_drop.append(level)
        elif isinstance(level, int):
            if 0 &lt;= level &lt; index.nlevels or level == -1:
                if level not in levels_to_drop:
                    levels_to_drop.append(level)
    if len(levels_to_drop) &lt; index.nlevels:
        # Drop only if there will be some indexes left
        return index.droplevel(levels_to_drop)
    return index</code></pre>
</details>
</dd>
<dt id="vectorbt.base.index_fns.drop_redundant_levels"><code class="name flex">
<span>def <span class="ident fname">drop_redundant_levels</span></span>(<span>index)</span>
</code></dt>
<dd>
<div class="desc"><p>Drop levels in <code>index</code> that either have a single value or a range from 0 to n.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drop_redundant_levels(index):
    &#34;&#34;&#34;Drop levels in `index` that either have a single value or a range from 0 to n.&#34;&#34;&#34;
    if not isinstance(index, pd.MultiIndex):
        return index
    if len(index) == 1:
        return index

    levels_to_drop = []
    for i, level in enumerate(index.levels):
        if len(level) == 1:
            levels_to_drop.append(i)
        elif level.name is None and (level == np.arange(len(level))).all():  # basic range
            if len(index.get_level_values(i)) == len(level):
                levels_to_drop.append(i)
    # Remove redundant levels only if there are some non-redundant levels left
    if len(levels_to_drop) &lt; index.nlevels:
        return index.droplevel(levels_to_drop)
    return index</code></pre>
</details>
</dd>
<dt id="vectorbt.base.index_fns.get_index"><code class="name flex">
<span>def <span class="ident fname">get_index</span></span>(<span>arg, axis)</span>
</code></dt>
<dd>
<div class="desc"><p>Get index of <code>arg</code> by <code>axis</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_index(arg, axis):
    &#34;&#34;&#34;Get index of `arg` by `axis`.&#34;&#34;&#34;
    checks.assert_type(arg, (pd.Series, pd.DataFrame))
    checks.assert_value_in(axis, (0, 1))

    if axis == 0:
        return arg.index
    else:
        if checks.is_series(arg):
            if arg.name is not None:
                return pd.Index([arg.name])
            return pd.Index([0])  # same as how pandas does it
        else:
            return arg.columns</code></pre>
</details>
</dd>
<dt id="vectorbt.base.index_fns.index_from_values"><code class="name flex">
<span>def <span class="ident fname">index_from_values</span></span>(<span>values, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code>pd.Index</code> with <code>name</code> by parsing an iterable <code>values</code>.</p>
<p>Each in <code>values</code> will correspond to an element in the new index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_from_values(values, name=None):
    &#34;&#34;&#34;Create a new `pd.Index` with `name` by parsing an iterable `values`.

    Each in `values` will correspond to an element in the new index.&#34;&#34;&#34;
    checks.assert_type(values, Iterable)

    value_names = []
    for i, v in enumerate(values):
        v = np.asarray(v)
        if np.all(v == v.item(0)):
            value_names.append(v.item(0))
        else:
            value_names.append(&#39;mix_%d&#39; % i)
    return pd.Index(value_names, name=name)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.index_fns.rename_levels"><code class="name flex">
<span>def <span class="ident fname">rename_levels</span></span>(<span>index, name_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Rename levels in <code>index</code> by <code>name_dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_levels(index, name_dict):
    &#34;&#34;&#34;Rename levels in `index` by `name_dict`.&#34;&#34;&#34;
    for k, v in name_dict.items():
        if isinstance(index, pd.MultiIndex):
            if k in index.names:
                index = index.rename(v, level=k)
        else:
            if index.name == k:
                index.name = v
    return index</code></pre>
</details>
</dd>
<dt id="vectorbt.base.index_fns.repeat_index"><code class="name flex">
<span>def <span class="ident fname">repeat_index</span></span>(<span>index, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Repeat each element in <code>index</code> <code>n</code> times.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat_index(index, n):
    &#34;&#34;&#34;Repeat each element in `index` `n` times.&#34;&#34;&#34;
    if not isinstance(index, pd.Index):
        index = pd.Index(index)
    if pd.Index.equals(index, pd.RangeIndex(start=0, stop=len(index), step=1)):  # ignore simple ranges without name
        return pd.RangeIndex(start=0, stop=n, step=1)
    return np.repeat(index, n)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.index_fns.select_levels"><code class="name flex">
<span>def <span class="ident fname">select_levels</span></span>(<span>index, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Build a new index by selecting one or multiple <code>level_names</code> from <code>index</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_levels(index, level_names):
    &#34;&#34;&#34;Build a new index by selecting one or multiple `level_names` from `index`.&#34;&#34;&#34;
    checks.assert_type(index, pd.MultiIndex)

    if isinstance(level_names, (list, tuple)):
        levels = [index.get_level_values(level_name) for level_name in level_names]
        return pd.MultiIndex.from_arrays(levels)
    else:
        return index.get_level_values(level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.base.index_fns.stack_indexes"><code class="name flex">
<span>def <span class="ident fname">stack_indexes</span></span>(<span>*indexes)</span>
</code></dt>
<dd>
<div class="desc"><p>Stack each index in <code>indexes</code> on top of each other, from top to bottom.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stack_indexes(*indexes):
    &#34;&#34;&#34;Stack each index in `indexes` on top of each other, from top to bottom.&#34;&#34;&#34;
    new_index = indexes[0]
    for i in range(1, len(indexes)):
        index1, index2 = new_index, indexes[i]
        checks.assert_same_shape(index1, index2)
        if not isinstance(index1, pd.MultiIndex):
            index1 = pd.MultiIndex.from_arrays([index1])
        if not isinstance(index2, pd.MultiIndex):
            index2 = pd.MultiIndex.from_arrays([index2])

        levels = []
        for i in range(index1.nlevels):
            levels.append(index1.get_level_values(i))
        for i in range(index2.nlevels):
            levels.append(index2.get_level_values(i))

        new_index = pd.MultiIndex.from_arrays(levels)
    return new_index</code></pre>
</details>
</dd>
<dt id="vectorbt.base.index_fns.tile_index"><code class="name flex">
<span>def <span class="ident fname">tile_index</span></span>(<span>index, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Tile the whole <code>index</code> <code>n</code> times.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tile_index(index, n):
    &#34;&#34;&#34;Tile the whole `index` `n` times.&#34;&#34;&#34;
    if not isinstance(index, pd.Index):
        index = pd.Index(index)
    if pd.Index.equals(index, pd.RangeIndex(start=0, stop=len(index), step=1)):  # ignore simple ranges without name
        return pd.RangeIndex(start=0, stop=n, step=1)
    if isinstance(index, pd.MultiIndex):
        return pd.MultiIndex.from_tuples(np.tile(index, n), names=index.names)
    return pd.Index(np.tile(index, n), name=index.name)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAACXBIWXMAACcQAAAnEAGUaVEZAAAGuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDggNzkuMTY0MDM2LCAyMDE5LzA4LzEzLTAxOjA2OjU3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjEuMCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjAtMDYtMjVUMjM6MzU6MTMrMDI6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjAtMDYtMjZUMTQ6MTA6MzgrMDI6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIwLTA2LTI2VDE0OjEwOjM4KzAyOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNzE0MGFiYi05Mjk1LTQ3MDYtYTNhZi1lMDg2OTFkOTk3NjQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NzZmN2Y4NjAtMThmMi00ZDgxLTg5NjUtNDU5ZjY1NDY2ZGZlIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NzZmN2Y4NjAtMThmMi00ZDgxLTg5NjUtNDU5ZjY1NDY2ZGZlIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjc2ZjdmODYwLTE4ZjItNGQ4MS04OTY1LTQ1OWY2NTQ2NmRmZSIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNVQyMzozNToxMyswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2NjI2MGIzLTY0ZmUtNGJiYy1iMTNiLWZkMDU3NDI3NjIyNCIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNlQxMzoyMTo1NSswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjA3MTQwYWJiLTkyOTUtNDcwNi1hM2FmLWUwODY5MWQ5OTc2NCIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNlQxNDoxMDozOCswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Qc/+aQAAAa5JREFUeJzt3cFJA0EYgFEjgj3FGmIjsQexByuxB4vy5kHwELJhCRPekP3eMYdl4Ms/y84Gstsfjg9xHvUCtq4AWAGwAmAFwAqAFQArAFYArABYAbACYAXACoAVACsAVgCsAFgBsAJgBcAKgBUAexp1oe+vz7Ofv7y+dZ0LmgCsAFgBsAJgBcAKgBUAKwBWAKwAWAGwAmAFwAqAFQAb9j5glFHn7KPcej1NAFYAzG9BP+/n3/ld9vwx1051tSYA8xPwZ/03+rqJmVYTgBUAm2UL+re0w6i7br8LunMFwAqAFQArAFYArADYdM8Bd3PKtlITgBUAm2ULurMzzvWaAMxPwNbuuieaAKwAmN+CTtz6/H02TQBWAKwAWAGwAmAFwAqAFQArAFYArABYAbACYAXACoANex8w23n9bOtZ0gRgBcAKgBUAKwBWAKwA2HT/HzDKbOtZ0gRgBcAKgBUAKwBWAKwAWAGwAmAFwAqAFQArAFYArADYbn846jVsWhOAFQArAFYArABYAbACYAXACoAVACsAVgCsAFgBsAJgBcAKgBUAKwBWAKwAWAGwAmC/7uUrwcQVST8AAAAASUVORK5CYII="/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.base" href="index.html">vectorbt.base</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.base.index_fns.align_index_to" href="#vectorbt.base.index_fns.align_index_to">align_index_to</a></code></li>
<li><code><a title="vectorbt.base.index_fns.combine_indexes" href="#vectorbt.base.index_fns.combine_indexes">combine_indexes</a></code></li>
<li><code><a title="vectorbt.base.index_fns.drop_duplicate_levels" href="#vectorbt.base.index_fns.drop_duplicate_levels">drop_duplicate_levels</a></code></li>
<li><code><a title="vectorbt.base.index_fns.drop_levels" href="#vectorbt.base.index_fns.drop_levels">drop_levels</a></code></li>
<li><code><a title="vectorbt.base.index_fns.drop_redundant_levels" href="#vectorbt.base.index_fns.drop_redundant_levels">drop_redundant_levels</a></code></li>
<li><code><a title="vectorbt.base.index_fns.get_index" href="#vectorbt.base.index_fns.get_index">get_index</a></code></li>
<li><code><a title="vectorbt.base.index_fns.index_from_values" href="#vectorbt.base.index_fns.index_from_values">index_from_values</a></code></li>
<li><code><a title="vectorbt.base.index_fns.rename_levels" href="#vectorbt.base.index_fns.rename_levels">rename_levels</a></code></li>
<li><code><a title="vectorbt.base.index_fns.repeat_index" href="#vectorbt.base.index_fns.repeat_index">repeat_index</a></code></li>
<li><code><a title="vectorbt.base.index_fns.select_levels" href="#vectorbt.base.index_fns.select_levels">select_levels</a></code></li>
<li><code><a title="vectorbt.base.index_fns.stack_indexes" href="#vectorbt.base.index_fns.stack_indexes">stack_indexes</a></code></li>
<li><code><a title="vectorbt.base.index_fns.tile_index" href="#vectorbt.base.index_fns.tile_index">tile_index</a></code></li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>