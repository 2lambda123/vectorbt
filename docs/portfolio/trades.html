<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.portfolio.trades API documentation</title>
<meta name="description" content="Base class for working with trade records â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3A4D6B}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.portfolio.trades</code></h1>
</header>
<section id="section-intro">
<p>Base class for working with trade records.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Both record types return both closed AND open trades, which may skew your performance results.
To only consider closed trades, you should explicitly query <code>closed</code> attribute.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Base class for working with trade records.

!!! warning
    Both record types return both closed AND open trades, which may skew your performance results.
    To only consider closed trades, you should explicitly query `closed` attribute.&#34;&#34;&#34;

import numpy as np
import pandas as pd
import plotly.graph_objects as go

from vectorbt.utils.colors import adjust_lightness
from vectorbt.utils.decorators import cached_property, cached_method
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.datetime import DatetimeTypes
from vectorbt.utils.enum import to_value_map
from vectorbt.utils.widgets import CustomFigureWidget
from vectorbt.utils.array import min_rel_rescale, max_rel_rescale
from vectorbt.base.reshape_fns import to_1d, to_2d, broadcast_to
from vectorbt.records.base import Records
from vectorbt.portfolio.enums import TradeDirection, TradeStatus, trade_dt, position_dt, TradeType
from vectorbt.portfolio import nb


# ############# Trades ############# #


class Trades(Records):
    &#34;&#34;&#34;Extends `Records` for working with trade records.

    In vectorbt, a trade is a partial closing operation; it&#39;s is a more fine-grained representation
    of a position. One position can incorporate multiple trades. Performance for this operation is
    calculated based on the size-weighted average of previous opening operations within the same
    position. The PnL of all trades combined always equals to the PnL of the entire position.

    For example, if you have a single large buy operation and 100 small sell operations, you will see
    100 trades, each opening with a fraction of the buy operation&#39;s size and fees. On the other hand,
    having 100 buy operations and just a single sell operation will generate a single trade with buy
    price being a size-weighted average over all purchase prices, and opening size and fees being
    the sum over all sizes and fees.

    ## Example

    Increasing position:
    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt
    &gt;&gt;&gt; import pandas as pd

    &gt;&gt;&gt; vbt.Portfolio.from_orders(
    ...     pd.Series([1., 2., 3., 4., 5.]),
    ...     pd.Series([1., 1., 1., 1., -4.]),
    ...     fixed_fees=1.).trades().records
       id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \\
    0   0    0   4.0          0          2.5         4.0         4         5.0

       exit_fees  pnl  return  direction  status  position_id
    0        1.0  5.0     0.5          0       1            0
    ```

    Decreasing position:
    ```python-repl
    &gt;&gt;&gt; vbt.Portfolio.from_orders(
    ...     pd.Series([1., 2., 3., 4., 5.]),
    ...     pd.Series([4., -1., -1., -1., -1.]),
    ...     fixed_fees=1.).trades().records
       id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \\
    0   0    0   1.0          0          1.0        0.25         1         2.0
    1   1    0   1.0          0          1.0        0.25         2         3.0
    2   2    0   1.0          0          1.0        0.25         3         4.0
    3   3    0   1.0          0          1.0        0.25         4         5.0

       exit_fees   pnl  return  direction  status  position_id
    0        1.0 -0.25   -0.25          0       1            0
    1        1.0  0.75    0.75          0       1            0
    2        1.0  1.75    1.75          0       1            0
    3        1.0  2.75    2.75          0       1            0
    ```

    Multiple reversing positions:
    ```python-repl
    &gt;&gt;&gt; vbt.Portfolio.from_orders(
    ...     pd.Series([1., 2., 3., 4., 5.]),
    ...     pd.Series([1., -2., 2., -2., 1.]),
    ...     fixed_fees=1.).trades().records
       id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \\
    0   0    0   1.0          0          1.0         1.0         1         2.0
    1   1    0   1.0          1          2.0         0.5         2         3.0
    2   2    0   1.0          2          3.0         0.5         3         4.0
    3   3    0   1.0          3          4.0         0.5         4         5.0

       exit_fees  pnl  return  direction  status  position_id
    0        0.5 -0.5  -0.500          0       1            0
    1        0.5 -2.0  -1.000          1       1            1
    2        0.5  0.0   0.000          0       1            2
    3        1.0 -2.5  -0.625          1       1            3
    ```

    Get count and PnL of trades:
    ```python-repl
    &gt;&gt;&gt; price = pd.Series([1., 2., 3., 4., 3., 2., 1.])
    &gt;&gt;&gt; orders = pd.Series([1., -0.5, -0.5, 2., -0.5, -0.5, -0.5])
    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders)

    &gt;&gt;&gt; trades = vbt.Trades.from_orders(portfolio.orders())
    &gt;&gt;&gt; trades.count()
    6
    &gt;&gt;&gt; trades.pnl.sum()
    -3.0
    &gt;&gt;&gt; trades.winning.count()
    2
    &gt;&gt;&gt; trades.winning.pnl.sum()
    1.5
    ```

    Get count and PnL of trades with duration of more than 2 days:
    ```python-repl
    &gt;&gt;&gt; mask = (trades.records[&#39;exit_idx&#39;] - trades.records[&#39;entry_idx&#39;]) &gt; 2
    &gt;&gt;&gt; trades_filtered = trades.filter_by_mask(mask)
    &gt;&gt;&gt; trades_filtered.count()
    2
    &gt;&gt;&gt; trades_filtered.pnl.sum()
    -3.0
    ```
    &#34;&#34;&#34;

    def __init__(self, wrapper, records_arr, close, idx_field=&#39;exit_idx&#39;,
                 trade_type=TradeType.Trade, **kwargs):
        Records.__init__(
            self,
            wrapper,
            records_arr,
            idx_field=idx_field,
            close=close,
            trade_type=trade_type,
            **kwargs
        )
        self._close = broadcast_to(close, wrapper.dummy(group_by=False))
        self._trade_type = trade_type

        if trade_type == TradeType.Trade:
            if not all(field in records_arr.dtype.names for field in trade_dt.names):
                raise TypeError(&#34;Records array must match trade_dt&#34;)
        else:
            if not all(field in records_arr.dtype.names for field in position_dt.names):
                raise TypeError(&#34;Records array must match position_dt&#34;)

    def _indexing_func_meta(self, pd_indexing_func):
        &#34;&#34;&#34;Perform indexing on `Trades` and also return metadata.&#34;&#34;&#34;
        new_wrapper, new_records_arr, group_idxs, col_idxs = \
            Records._indexing_func_meta(self, pd_indexing_func)
        new_close = new_wrapper.wrap(to_2d(self.close, raw=True)[:, col_idxs], group_by=False)
        return self.copy(
            wrapper=new_wrapper,
            records_arr=new_records_arr,
            close=new_close
        ), group_idxs, col_idxs

    def _indexing_func(self, pd_indexing_func):
        &#34;&#34;&#34;Perform indexing on `Trades`.&#34;&#34;&#34;
        return self._indexing_func_meta(pd_indexing_func)[0]

    @property
    def close(self):
        &#34;&#34;&#34;Reference price such as close.&#34;&#34;&#34;
        return self._close

    @property
    def trade_type(self):
        &#34;&#34;&#34;Trade type.&#34;&#34;&#34;
        return self._trade_type

    @classmethod
    def from_orders(cls, orders, **kwargs):
        &#34;&#34;&#34;Build `Trades` from `vectorbt.portfolio.orders.Orders`.&#34;&#34;&#34;
        trade_records_arr = nb.orders_to_trades_nb(
            orders.close.vbt.to_2d_array(),
            orders.values,
            orders.col_mapper.col_map
        )
        return cls(orders.wrapper, trade_records_arr, orders.close, **kwargs)

    @property  # no need for cached
    def records_readable(self):
        &#34;&#34;&#34;Records in readable format.&#34;&#34;&#34;
        records_df = self.records
        out = pd.DataFrame()
        _id_str = &#39;Trade Id&#39; if self.trade_type == TradeType.Trade else &#39;Position Id&#39;
        out[_id_str] = records_df[&#39;id&#39;]
        out[&#39;Column&#39;] = records_df[&#39;col&#39;].map(lambda x: self.wrapper.columns[x])
        out[&#39;Size&#39;] = records_df[&#39;size&#39;]
        out[&#39;Entry Date&#39;] = records_df[&#39;entry_idx&#39;].map(lambda x: self.wrapper.index[x])
        out[&#39;Avg. Entry Price&#39;] = records_df[&#39;entry_price&#39;]
        out[&#39;Entry Fees&#39;] = records_df[&#39;entry_fees&#39;]
        out[&#39;Exit Date&#39;] = records_df[&#39;exit_idx&#39;].map(lambda x: self.wrapper.index[x])
        out[&#39;Avg. Exit Price&#39;] = records_df[&#39;exit_price&#39;]
        out[&#39;Exit Fees&#39;] = records_df[&#39;exit_fees&#39;]
        out[&#39;PnL&#39;] = records_df[&#39;pnl&#39;]
        out[&#39;Return&#39;] = records_df[&#39;return&#39;]
        out[&#39;Direction&#39;] = records_df[&#39;direction&#39;].map(to_value_map(TradeDirection))
        out[&#39;Status&#39;] = records_df[&#39;status&#39;].map(to_value_map(TradeStatus))
        if self.trade_type == TradeType.Trade:
            out[&#39;Position Id&#39;] = records_df[&#39;position_id&#39;]
        return out

    @cached_property
    def duration(self):
        &#34;&#34;&#34;Duration of each trade (in raw format).&#34;&#34;&#34;
        return self.map(nb.trade_duration_map_nb)

    @cached_property
    def pnl(self):
        &#34;&#34;&#34;PnL of each trade.&#34;&#34;&#34;
        return self.map_field(&#39;pnl&#39;)

    @cached_property
    def returns(self):
        &#34;&#34;&#34;Return of each trade.&#34;&#34;&#34;
        return self.map_field(&#39;return&#39;)

    # ############# PnL ############# #

    @cached_property
    def winning(self):
        &#34;&#34;&#34;Winning trades.&#34;&#34;&#34;
        filter_mask = self.values[&#39;pnl&#39;] &gt; 0.
        return self.filter_by_mask(filter_mask)

    @cached_method
    def win_rate(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Rate of winning trades.&#34;&#34;&#34;
        win_count = to_1d(self.winning.count(group_by=group_by), raw=True)
        total_count = to_1d(self.count(group_by=group_by), raw=True)
        return self.wrapper.wrap_reduced(win_count / total_count, group_by=group_by, **kwargs)

    @cached_property
    def losing(self):
        &#34;&#34;&#34;Losing trades.&#34;&#34;&#34;
        filter_mask = self.values[&#39;pnl&#39;] &lt; 0.
        return self.filter_by_mask(filter_mask)

    @cached_method
    def loss_rate(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Rate of losing trades.&#34;&#34;&#34;
        loss_count = to_1d(self.losing.count(group_by=group_by), raw=True)
        total_count = to_1d(self.count(group_by=group_by), raw=True)
        return self.wrapper.wrap_reduced(loss_count / total_count, group_by=group_by, **kwargs)

    @cached_method
    def profit_factor(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Profit factor.&#34;&#34;&#34;
        total_win = to_1d(self.winning.pnl.sum(group_by=group_by), raw=True)
        total_loss = to_1d(self.losing.pnl.sum(group_by=group_by), raw=True)

        # Otherwise columns with only wins or losses will become NaNs
        has_values = to_1d(self.count(group_by=group_by), raw=True) &gt; 0
        total_win[np.isnan(total_win) &amp; has_values] = 0.
        total_loss[np.isnan(total_loss) &amp; has_values] = 0.

        profit_factor = total_win / np.abs(total_loss)
        return self.wrapper.wrap_reduced(profit_factor, group_by=group_by, **kwargs)

    @cached_method
    def expectancy(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Average profitability.&#34;&#34;&#34;
        win_rate = to_1d(self.win_rate(group_by=group_by), raw=True)
        avg_win = to_1d(self.winning.pnl.mean(group_by=group_by), raw=True)
        avg_loss = to_1d(self.losing.pnl.mean(group_by=group_by), raw=True)

        # Otherwise columns with only wins or losses will become NaNs
        has_values = to_1d(self.count(group_by=group_by), raw=True) &gt; 0
        avg_win[np.isnan(avg_win) &amp; has_values] = 0.
        avg_loss[np.isnan(avg_loss) &amp; has_values] = 0.

        expectancy = win_rate * avg_win - (1 - win_rate) * np.abs(avg_loss)
        return self.wrapper.wrap_reduced(expectancy, group_by=group_by, **kwargs)

    @cached_method
    def sqn(self, group_by=None, **kwargs):
        &#34;&#34;&#34;System Quality Number (SQN).&#34;&#34;&#34;
        count = to_1d(self.count(group_by=group_by), raw=True)
        pnl_mean = to_1d(self.pnl.mean(group_by=group_by), raw=True)
        pnl_std = to_1d(self.pnl.std(group_by=group_by), raw=True)
        sqn = np.sqrt(count) * pnl_mean / pnl_std
        return self.wrapper.wrap_reduced(sqn, group_by=group_by, **kwargs)

    # ############# TradeDirection ############# #

    @cached_property
    def direction(self):
        &#34;&#34;&#34;See `vectorbt.portfolio.enums.TradeDirection`.&#34;&#34;&#34;
        return self.map_field(&#39;direction&#39;)

    @cached_property
    def long(self):
        &#34;&#34;&#34;Long trades.&#34;&#34;&#34;
        filter_mask = self.values[&#39;direction&#39;] == TradeDirection.Long
        return self.filter_by_mask(filter_mask)

    @cached_method
    def long_rate(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Rate of long trades.&#34;&#34;&#34;
        long_count = to_1d(self.long.count(group_by=group_by), raw=True)
        total_count = to_1d(self.count(group_by=group_by), raw=True)
        return self.wrapper.wrap_reduced(long_count / total_count, group_by=group_by, **kwargs)

    @cached_property
    def short(self):
        &#34;&#34;&#34;Short trades.&#34;&#34;&#34;
        filter_mask = self.values[&#39;direction&#39;] == TradeDirection.Short
        return self.filter_by_mask(filter_mask)

    @cached_method
    def short_rate(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Rate of short trades.&#34;&#34;&#34;
        short_count = to_1d(self.short.count(group_by=group_by), raw=True)
        total_count = to_1d(self.count(group_by=group_by), raw=True)
        return self.wrapper.wrap_reduced(short_count / total_count, group_by=group_by, **kwargs)

    # ############# TradeStatus ############# #

    @cached_property
    def status(self):
        &#34;&#34;&#34;See `vectorbt.portfolio.enums.TradeStatus`.&#34;&#34;&#34;
        return self.map_field(&#39;status&#39;)

    @cached_property
    def open(self):
        &#34;&#34;&#34;Open trades.&#34;&#34;&#34;
        filter_mask = self.values[&#39;status&#39;] == TradeStatus.Open
        return self.filter_by_mask(filter_mask)

    @cached_method
    def open_rate(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Rate of open trades.&#34;&#34;&#34;
        open_count = to_1d(self.open.count(group_by=group_by), raw=True)
        total_count = to_1d(self.count(group_by=group_by), raw=True)
        return self.wrapper.wrap_reduced(open_count / total_count, group_by=group_by, **kwargs)

    @cached_property
    def closed(self):
        &#34;&#34;&#34;Closed trades.&#34;&#34;&#34;
        filter_mask = self.values[&#39;status&#39;] == TradeStatus.Closed
        return self.filter_by_mask(filter_mask)

    @cached_method
    def closed_rate(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Rate of closed trades.&#34;&#34;&#34;
        closed_count = to_1d(self.closed.count(group_by=group_by), raw=True)
        total_count = to_1d(self.count(group_by=group_by), raw=True)
        return self.wrapper.wrap_reduced(closed_count / total_count, group_by=group_by, **kwargs)

    # ############# Plotting ############# #

    def plot_pnl(self,
                 column=None,
                 marker_size_range=[7, 14],
                 opacity_range=[0.75, 0.9],
                 closed_profit_trace_kwargs=None,
                 closed_loss_trace_kwargs=None,
                 open_trace_kwargs=None,
                 hline_shape_kwargs=None,
                 row=None, col=None,
                 xref=&#39;x&#39;, yref=&#39;y&#39;,
                 fig=None,
                 **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot trade PnL.

        Args:
            column (str): Name of the column to plot.
            closed_profit_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Closed - Profit&#34; markers.
            closed_loss_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Closed - Loss&#34; markers.
            open_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Open&#34; markers.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            row (int): Row position.
            col (int): Column position.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.

        ## Example

        ```python-repl
        &gt;&gt;&gt; trades.plot_pnl()
        ```

        ![](/vectorbt/docs/img/trades_plot_pnl.png)
        &#34;&#34;&#34;
        from vectorbt.settings import contrast_color_schema

        self_col = self.select_series(column=column, group_by=False)

        if closed_profit_trace_kwargs is None:
            closed_profit_trace_kwargs = {}
        if closed_loss_trace_kwargs is None:
            closed_loss_trace_kwargs = {}
        if open_trace_kwargs is None:
            open_trace_kwargs = {}
        if hline_shape_kwargs is None:
            hline_shape_kwargs = {}
        marker_size_range = tuple(marker_size_range)

        if fig is None:
            fig = CustomFigureWidget()
        fig.update_layout(**layout_kwargs)
        x_domain = [0, 1]
        xaxis = &#39;xaxis&#39; + xref[1:]
        if xaxis in fig.layout:
            if &#39;domain&#39; in fig.layout[xaxis]:
                if fig.layout[xaxis][&#39;domain&#39;] is not None:
                    x_domain = fig.layout[xaxis][&#39;domain&#39;]

        if len(self_col.values) &gt; 0:
            # Extract information
            _id = self.values[&#39;id&#39;]
            _id_str = &#39;Trade Id&#39; if self.trade_type == TradeType.Trade else &#39;Position Id&#39;
            exit_idx = self.values[&#39;exit_idx&#39;]
            pnl = self.values[&#39;pnl&#39;]
            returns = self.values[&#39;return&#39;]
            status = self.values[&#39;status&#39;]

            neutral_mask = pnl == 0
            profit_mask = pnl &gt; 0
            loss_mask = pnl &lt; 0

            exit_idx = exit_idx[~neutral_mask]  # needed for rel_rescale
            pnl = pnl[~neutral_mask]
            returns = returns[~neutral_mask]
            marker_size = min_rel_rescale(np.abs(returns), marker_size_range)
            opacity = max_rel_rescale(np.abs(returns), opacity_range)

            open_mask = status == TradeStatus.Open
            closed_profit_mask = (~open_mask) &amp; profit_mask
            closed_loss_mask = (~open_mask) &amp; loss_mask
            open_mask &amp;= ~neutral_mask

            if np.any(closed_profit_mask):
                # Plot Profit markers
                profit_scatter = go.Scatter(
                    x=self_col.wrapper.index[exit_idx[closed_profit_mask]],
                    y=pnl[closed_profit_mask],
                    mode=&#39;markers&#39;,
                    marker=dict(
                        symbol=&#39;circle&#39;,
                        color=contrast_color_schema[&#39;green&#39;],
                        size=marker_size[closed_profit_mask],
                        opacity=opacity[closed_profit_mask],
                        line=dict(
                            width=1,
                            color=adjust_lightness(contrast_color_schema[&#39;green&#39;])
                        ),
                    ),
                    name=&#39;Closed - Profit&#39;,
                    customdata=np.stack((_id[closed_profit_mask], returns[closed_profit_mask]), axis=1),
                    hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                            &#34;&lt;br&gt;Date: %{x}&#34;
                                            &#34;&lt;br&gt;PnL: %{y}&#34;
                                            &#34;&lt;br&gt;Return: %{customdata[1]:.2%}&#34;
                )
                profit_scatter.update(**closed_profit_trace_kwargs)
                fig.add_trace(profit_scatter, row=row, col=col)

            if np.any(closed_loss_mask):
                # Plot Loss markers
                loss_scatter = go.Scatter(
                    x=self_col.wrapper.index[exit_idx[closed_loss_mask]],
                    y=pnl[closed_loss_mask],
                    mode=&#39;markers&#39;,
                    marker=dict(
                        symbol=&#39;circle&#39;,
                        color=contrast_color_schema[&#39;red&#39;],
                        size=marker_size[closed_loss_mask],
                        opacity=opacity[closed_loss_mask],
                        line=dict(
                            width=1,
                            color=adjust_lightness(contrast_color_schema[&#39;red&#39;])
                        )
                    ),
                    name=&#39;Closed - Loss&#39;,
                    customdata=np.stack((_id[closed_loss_mask], returns[closed_loss_mask]), axis=1),
                    hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                            &#34;&lt;br&gt;Date: %{x}&#34;
                                            &#34;&lt;br&gt;PnL: %{y}&#34;
                                            &#34;&lt;br&gt;Return: %{customdata[1]:.2%}&#34;
                )
                loss_scatter.update(**closed_loss_trace_kwargs)
                fig.add_trace(loss_scatter, row=row, col=col)

            if np.any(open_mask):
                # Plot Active markers
                active_scatter = go.Scatter(
                    x=self_col.wrapper.index[exit_idx[open_mask]],
                    y=pnl[open_mask],
                    mode=&#39;markers&#39;,
                    marker=dict(
                        symbol=&#39;circle&#39;,
                        color=contrast_color_schema[&#39;orange&#39;],
                        size=marker_size[open_mask],
                        opacity=opacity[open_mask],
                        line=dict(
                            width=1,
                            color=adjust_lightness(contrast_color_schema[&#39;orange&#39;])
                        )
                    ),
                    name=&#39;Open&#39;,
                    customdata=np.stack((_id[open_mask], returns[open_mask]), axis=1),
                    hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                            &#34;&lt;br&gt;Date: %{x}&#34;
                                            &#34;&lt;br&gt;PnL: %{y}&#34;
                                            &#34;&lt;br&gt;Return: %{customdata[1]:.2%}&#34;
                )
                active_scatter.update(**open_trace_kwargs)
                fig.add_trace(active_scatter, row=row, col=col)

        # Plot zeroline
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=0,
            x1=x_domain[1],
            y1=0,
            line=dict(
                color=&#34;gray&#34;,
                dash=&#34;dash&#34;,
            )
        ), hline_shape_kwargs))
        return fig

    def plot(self,
             column=None,
             plot_close=True,
             plot_zones=True,
             close_trace_kwargs=None,
             entry_trace_kwargs=None,
             exit_trace_kwargs=None,
             exit_profit_trace_kwargs=None,
             exit_loss_trace_kwargs=None,
             active_trace_kwargs=None,
             profit_shape_kwargs=None,
             loss_shape_kwargs=None,
             row=None, col=None,
             xref=&#39;x&#39;, yref=&#39;y&#39;,
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot orders.

        Args:
            column (str): Name of the column to plot.
            plot_close (bool): Whether to plot `Trades.close`.
            plot_zones (bool): Whether to plot zones.

                Set to False if there are many trades within one position.
            close_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `Trades.close`.
            entry_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Entry&#34; markers.
            exit_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Exit&#34; markers.
            exit_profit_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Exit - Profit&#34; markers.
            exit_loss_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Exit - Loss&#34; markers.
            active_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Active&#34; markers.
            profit_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for profit zones.
            loss_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for loss zones.
            row (int): Row position.
            col (int): Column position.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.

        ## Example

        ```python-repl
        &gt;&gt;&gt; trades.plot()
        ```

        ![](/vectorbt/docs/img/trades_plot.png)&#34;&#34;&#34;
        from vectorbt.settings import color_schema, contrast_color_schema

        self_col = self.select_series(column=column, group_by=False)

        if close_trace_kwargs is None:
            close_trace_kwargs = {}
        close_trace_kwargs = merge_dicts(dict(
            line_color=color_schema[&#39;blue&#39;],
            name=&#39;Close&#39; if self_col.wrapper.name is None else self_col.wrapper.name
        ), close_trace_kwargs)
        if entry_trace_kwargs is None:
            entry_trace_kwargs = {}
        if exit_trace_kwargs is None:
            exit_trace_kwargs = {}
        if exit_profit_trace_kwargs is None:
            exit_profit_trace_kwargs = {}
        if exit_loss_trace_kwargs is None:
            exit_loss_trace_kwargs = {}
        if active_trace_kwargs is None:
            active_trace_kwargs = {}
        if profit_shape_kwargs is None:
            profit_shape_kwargs = {}
        if loss_shape_kwargs is None:
            loss_shape_kwargs = {}

        if fig is None:
            fig = CustomFigureWidget()
        fig.update_layout(**layout_kwargs)

        # Plot close
        if plot_close:
            fig = self_col.close.vbt.plot(trace_kwargs=close_trace_kwargs, row=row, col=col, fig=fig)

        if len(self_col.values) &gt; 0:
            # Extract information
            _id = self_col.values[&#39;id&#39;]
            _id_str = &#39;Trade Id&#39; if self.trade_type == TradeType.Trade else &#39;Position Id&#39;
            size = self_col.values[&#39;size&#39;]
            entry_idx = self_col.values[&#39;entry_idx&#39;]
            entry_price = self_col.values[&#39;entry_price&#39;]
            entry_fees = self_col.values[&#39;entry_fees&#39;]
            exit_idx = self_col.values[&#39;exit_idx&#39;]
            exit_price = self_col.values[&#39;exit_price&#39;]
            exit_fees = self_col.values[&#39;exit_fees&#39;]
            pnl = self_col.values[&#39;pnl&#39;]
            ret = self_col.values[&#39;return&#39;]
            direction_value_map = to_value_map(TradeDirection)
            direction = self_col.values[&#39;direction&#39;]
            direction = np.vectorize(lambda x: str(direction_value_map[x]))(direction)
            status = self_col.values[&#39;status&#39;]

            def get_duration_str(from_idx, to_idx):
                if isinstance(self_col.wrapper.index, DatetimeTypes):
                    duration = self_col.wrapper.index[to_idx] - self_col.wrapper.index[from_idx]
                elif self_col.wrapper.freq is not None:
                    duration = self_col.wrapper.to_time_units(to_idx - from_idx)
                else:
                    duration = to_idx - from_idx
                return np.vectorize(str)(duration)

            duration = get_duration_str(entry_idx, exit_idx)

            if len(entry_idx) &gt; 0:
                # Plot Entry markers
                entry_customdata = np.stack((
                    _id,
                    size,
                    entry_fees,
                    direction,
                    *((self_col.values[&#39;position_id&#39;],)
                      if self.trade_type == TradeType.Trade else ())
                ), axis=1)
                entry_scatter = go.Scatter(
                    x=self_col.wrapper.index[entry_idx],
                    y=entry_price,
                    mode=&#39;markers&#39;,
                    marker=dict(
                        symbol=&#39;square&#39;,
                        color=contrast_color_schema[&#39;blue&#39;],
                        size=7,
                        line=dict(
                            width=1,
                            color=adjust_lightness(contrast_color_schema[&#39;blue&#39;])
                        )
                    ),
                    name=&#39;Entry&#39;,
                    customdata=entry_customdata,
                    hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                            &#34;&lt;br&gt;Date: %{x}&#34;
                                            &#34;&lt;br&gt;Avg. Price: %{y}&#34;
                                            &#34;&lt;br&gt;Size: %{customdata[1]:.6f}&#34;
                                            &#34;&lt;br&gt;Fees: %{customdata[2]:.6f}&#34;
                                            &#34;&lt;br&gt;Direction: %{customdata[3]}&#34;
                                  + (&#34;&lt;br&gt;Position Id: %{customdata[4]}&#34;
                                     if self.trade_type == TradeType.Trade else &#39;&#39;)
                )
                entry_scatter.update(**entry_trace_kwargs)
                fig.add_trace(entry_scatter, row=row, col=col)

            # Plot end markers
            def _plot_end_markers(mask, name, color, kwargs):
                if np.any(mask):
                    customdata = np.stack((
                        _id[mask],
                        duration[mask],
                        size[mask],
                        exit_fees[mask],
                        pnl[mask],
                        ret[mask],
                        direction[mask],
                        *((self_col.values[&#39;position_id&#39;][mask],)
                          if self.trade_type == TradeType.Trade else ())
                    ), axis=1)
                    scatter = go.Scatter(
                        x=self_col.wrapper.index[exit_idx[mask]],
                        y=exit_price[mask],
                        mode=&#39;markers&#39;,
                        marker=dict(
                            symbol=&#39;square&#39;,
                            color=color,
                            size=7,
                            line=dict(
                                width=1,
                                color=adjust_lightness(color)
                            )
                        ),
                        name=name,
                        customdata=customdata,
                        hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                                &#34;&lt;br&gt;Date: %{x}&#34;
                                                &#34;&lt;br&gt;Duration: %{customdata[1]}&#34;
                                                &#34;&lt;br&gt;Avg. Price: %{y}&#34;
                                                &#34;&lt;br&gt;Size: %{customdata[2]:.6f}&#34;
                                                &#34;&lt;br&gt;Fees: %{customdata[3]:.6f}&#34;
                                                &#34;&lt;br&gt;PnL: %{customdata[4]:.6f}&#34;
                                                &#34;&lt;br&gt;Return: %{customdata[5]:.2%}&#34;
                                                &#34;&lt;br&gt;Direction: %{customdata[6]}&#34;
                                      + (&#34;&lt;br&gt;Position Id: %{customdata[7]}&#34;
                                         if self.trade_type == TradeType.Trade else &#39;&#39;)
                    )
                    scatter.update(**kwargs)
                    fig.add_trace(scatter, row=row, col=col)

            # Plot Exit markers
            _plot_end_markers(
                (status == TradeStatus.Closed) &amp; (pnl == 0.),
                &#39;Exit&#39;,
                contrast_color_schema[&#39;gray&#39;],
                exit_trace_kwargs
            )

            # Plot Exit - Profit markers
            _plot_end_markers(
                (status == TradeStatus.Closed) &amp; (pnl &gt; 0.),
                &#39;Exit - Profit&#39;,
                contrast_color_schema[&#39;green&#39;],
                exit_profit_trace_kwargs
            )

            # Plot Exit - Loss markers
            _plot_end_markers(
                (status == TradeStatus.Closed) &amp; (pnl &lt; 0.),
                &#39;Exit - Loss&#39;,
                contrast_color_schema[&#39;red&#39;],
                exit_loss_trace_kwargs
            )

            # Plot Active markers
            _plot_end_markers(
                status == TradeStatus.Open,
                &#39;Active&#39;,
                contrast_color_schema[&#39;orange&#39;],
                active_trace_kwargs
            )

            if plot_zones:
                profit_mask = pnl &gt; 0.
                if np.any(profit_mask):
                    # Plot profit zones
                    for i in np.flatnonzero(profit_mask):
                        fig.add_shape(**merge_dicts(dict(
                            type=&#34;rect&#34;,
                            xref=xref,
                            yref=yref,
                            x0=self_col.wrapper.index[entry_idx[i]],
                            y0=entry_price[i],
                            x1=self_col.wrapper.index[exit_idx[i]],
                            y1=exit_price[i],
                            fillcolor=&#39;green&#39;,
                            opacity=0.2,
                            layer=&#34;below&#34;,
                            line_width=0,
                        ), profit_shape_kwargs))

                loss_mask = pnl &lt; 0.
                if np.any(loss_mask):
                    # Plot loss zones
                    for i in np.flatnonzero(loss_mask):
                        fig.add_shape(**merge_dicts(dict(
                            type=&#34;rect&#34;,
                            xref=xref,
                            yref=yref,
                            x0=self_col.wrapper.index[entry_idx[i]],
                            y0=entry_price[i],
                            x1=self_col.wrapper.index[exit_idx[i]],
                            y1=exit_price[i],
                            fillcolor=&#39;red&#39;,
                            opacity=0.2,
                            layer=&#34;below&#34;,
                            line_width=0,
                        ), loss_shape_kwargs))

        return fig


# ############# Positions ############# #


class Positions(Trades):
    &#34;&#34;&#34;Extends `Trades` for working with position records.

    In vectorbt, a position aggregates one or multiple trades sharing the same column
    and position index. It has the same layout as a trade.

    ## Example

    Increasing position:
    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt
    &gt;&gt;&gt; import pandas as pd

    &gt;&gt;&gt; vbt.Portfolio.from_orders(
    ...     pd.Series([1., 2., 3., 4., 5.]),
    ...     pd.Series([1., 1., 1., 1., -4.]),
    ...     fixed_fees=1.).positions().records
       id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \\
    0   0    0   4.0          0          2.5         4.0         4         5.0

       exit_fees  pnl  return  direction  status
    0        1.0  5.0     0.5          0       1
    ```

    Decreasing position:
    ```python-repl
    &gt;&gt;&gt; vbt.Portfolio.from_orders(
    ...     pd.Series([1., 2., 3., 4., 5.]),
    ...     pd.Series([4., -1., -1., -1., -1.]),
    ...     fixed_fees=1.).positions().records
       id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \\
    0   0    0   4.0          0          1.0         1.0         4         3.5

       exit_fees  pnl  return  direction  status
    0        4.0  5.0    1.25          0       1
    ```

    Multiple positions:
    ```python-repl
    &gt;&gt;&gt; vbt.Portfolio.from_orders(
    ...     pd.Series([1., 2., 3., 4., 5.]),
    ...     pd.Series([1., -2., 2., -2., 1.]),
    ...     fixed_fees=1.).positions().records
       id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \
    0   0    0   1.0          0          1.0         1.0         1         2.0
    1   1    0   1.0          1          2.0         0.5         2         3.0
    2   2    0   1.0          2          3.0         0.5         3         4.0
    3   3    0   1.0          3          4.0         0.5         4         5.0

       exit_fees  pnl  return  direction  status
    0        0.5 -0.5  -0.500          0       1
    1        0.5 -2.0  -1.000          1       1
    2        0.5  0.0   0.000          0       1
    3        1.0 -2.5  -0.625          1       1
    ```
    &#34;&#34;&#34;

    def __init__(self, *args, trade_type=TradeType.Position, **kwargs):
        if trade_type != TradeType.Position:
            raise ValueError(&#34;Trade type must be TradeType.Position&#34;)
        Trades.__init__(self, *args, trade_type=trade_type, **kwargs)

    @classmethod
    def from_orders(cls, orders, **kwargs):
        raise NotImplementedError

    @classmethod
    def from_trades(cls, trades, **kwargs):
        &#34;&#34;&#34;Build `Positions` from `Trades`.&#34;&#34;&#34;
        position_records_arr = nb.trades_to_positions_nb(trades.values, trades.col_mapper.col_map)
        return cls(trades.wrapper, position_records_arr, trades.close, **kwargs)

    @cached_method
    def coverage(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Coverage, that is, total duration divided by the whole period.&#34;&#34;&#34;
        total_duration = to_1d(self.duration.sum(group_by=group_by), raw=True)
        total_steps = self.wrapper.grouper.get_group_lens(group_by=group_by) * self.wrapper.shape[0]
        return self.wrapper.wrap_reduced(total_duration / total_steps, group_by=group_by, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.portfolio.trades.Positions"><code class="flex name class">
<span>class <span class="ident parent-fname">Positions</span></span>
<span>(</span><span>*args, trade_type=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code><a title="vectorbt.portfolio.trades.Trades" href="#vectorbt.portfolio.trades.Trades">Trades</a></code> for working with position records.</p>
<p>In vectorbt, a position aggregates one or multiple trades sharing the same column
and position index. It has the same layout as a trade.</p>
<h2 id="example">Example</h2>
<p>Increasing position:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import pandas as pd

&gt;&gt;&gt; vbt.Portfolio.from_orders(
...     pd.Series([1., 2., 3., 4., 5.]),
...     pd.Series([1., 1., 1., 1., -4.]),
...     fixed_fees=1.).positions().records
   id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \
0   0    0   4.0          0          2.5         4.0         4         5.0

   exit_fees  pnl  return  direction  status
0        1.0  5.0     0.5          0       1
</code></pre>
<p>Decreasing position:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.Portfolio.from_orders(
...     pd.Series([1., 2., 3., 4., 5.]),
...     pd.Series([4., -1., -1., -1., -1.]),
...     fixed_fees=1.).positions().records
   id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \
0   0    0   4.0          0          1.0         1.0         4         3.5

   exit_fees  pnl  return  direction  status
0        4.0  5.0    1.25          0       1
</code></pre>
<p>Multiple positions:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.Portfolio.from_orders(
...     pd.Series([1., 2., 3., 4., 5.]),
...     pd.Series([1., -2., 2., -2., 1.]),
...     fixed_fees=1.).positions().records
   id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price      0   0    0   1.0          0          1.0         1.0         1         2.0
1   1    0   1.0          1          2.0         0.5         2         3.0
2   2    0   1.0          2          3.0         0.5         3         4.0
3   3    0   1.0          3          4.0         0.5         4         5.0

   exit_fees  pnl  return  direction  status
0        0.5 -0.5  -0.500          0       1
1        0.5 -2.0  -1.000          1       1
2        0.5  0.0   0.000          0       1
3        1.0 -2.5  -0.625          1       1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Positions(Trades):
    &#34;&#34;&#34;Extends `Trades` for working with position records.

    In vectorbt, a position aggregates one or multiple trades sharing the same column
    and position index. It has the same layout as a trade.

    ## Example

    Increasing position:
    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt
    &gt;&gt;&gt; import pandas as pd

    &gt;&gt;&gt; vbt.Portfolio.from_orders(
    ...     pd.Series([1., 2., 3., 4., 5.]),
    ...     pd.Series([1., 1., 1., 1., -4.]),
    ...     fixed_fees=1.).positions().records
       id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \\
    0   0    0   4.0          0          2.5         4.0         4         5.0

       exit_fees  pnl  return  direction  status
    0        1.0  5.0     0.5          0       1
    ```

    Decreasing position:
    ```python-repl
    &gt;&gt;&gt; vbt.Portfolio.from_orders(
    ...     pd.Series([1., 2., 3., 4., 5.]),
    ...     pd.Series([4., -1., -1., -1., -1.]),
    ...     fixed_fees=1.).positions().records
       id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \\
    0   0    0   4.0          0          1.0         1.0         4         3.5

       exit_fees  pnl  return  direction  status
    0        4.0  5.0    1.25          0       1
    ```

    Multiple positions:
    ```python-repl
    &gt;&gt;&gt; vbt.Portfolio.from_orders(
    ...     pd.Series([1., 2., 3., 4., 5.]),
    ...     pd.Series([1., -2., 2., -2., 1.]),
    ...     fixed_fees=1.).positions().records
       id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \
    0   0    0   1.0          0          1.0         1.0         1         2.0
    1   1    0   1.0          1          2.0         0.5         2         3.0
    2   2    0   1.0          2          3.0         0.5         3         4.0
    3   3    0   1.0          3          4.0         0.5         4         5.0

       exit_fees  pnl  return  direction  status
    0        0.5 -0.5  -0.500          0       1
    1        0.5 -2.0  -1.000          1       1
    2        0.5  0.0   0.000          0       1
    3        1.0 -2.5  -0.625          1       1
    ```
    &#34;&#34;&#34;

    def __init__(self, *args, trade_type=TradeType.Position, **kwargs):
        if trade_type != TradeType.Position:
            raise ValueError(&#34;Trade type must be TradeType.Position&#34;)
        Trades.__init__(self, *args, trade_type=trade_type, **kwargs)

    @classmethod
    def from_orders(cls, orders, **kwargs):
        raise NotImplementedError

    @classmethod
    def from_trades(cls, trades, **kwargs):
        &#34;&#34;&#34;Build `Positions` from `Trades`.&#34;&#34;&#34;
        position_records_arr = nb.trades_to_positions_nb(trades.values, trades.col_mapper.col_map)
        return cls(trades.wrapper, position_records_arr, trades.close, **kwargs)

    @cached_method
    def coverage(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Coverage, that is, total duration divided by the whole period.&#34;&#34;&#34;
        total_duration = to_1d(self.duration.sum(group_by=group_by), raw=True)
        total_steps = self.wrapper.grouper.get_group_lens(group_by=group_by) * self.wrapper.shape[0]
        return self.wrapper.wrap_reduced(total_duration / total_steps, group_by=group_by, **kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.trades.Trades" href="#vectorbt.portfolio.trades.Trades">Trades</a></li>
<li><a title="vectorbt.records.base.Records" href="../records/base.html#vectorbt.records.base.Records">Records</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.portfolio.trades.Positions.from_trades"><code class="name flex">
<span>def <span class="ident fname">from_trades</span></span>(<span>trades, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build <code><a title="vectorbt.portfolio.trades.Positions" href="#vectorbt.portfolio.trades.Positions">Positions</a></code> from <code><a title="vectorbt.portfolio.trades.Trades" href="#vectorbt.portfolio.trades.Trades">Trades</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_trades(cls, trades, **kwargs):
    &#34;&#34;&#34;Build `Positions` from `Trades`.&#34;&#34;&#34;
    position_records_arr = nb.trades_to_positions_nb(trades.values, trades.col_mapper.col_map)
    return cls(trades.wrapper, position_records_arr, trades.close, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.portfolio.trades.Positions.coverage"><code class="name flex">
<span>def <span class="ident fname">coverage</span></span>(<span>self, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Coverage, that is, total duration divided by the whole period.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def coverage(self, group_by=None, **kwargs):
    &#34;&#34;&#34;Coverage, that is, total duration divided by the whole period.&#34;&#34;&#34;
    total_duration = to_1d(self.duration.sum(group_by=group_by), raw=True)
    total_steps = self.wrapper.grouper.get_group_lens(group_by=group_by) * self.wrapper.shape[0]
    return self.wrapper.wrap_reduced(total_duration / total_steps, group_by=group_by, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.portfolio.trades.Trades" href="#vectorbt.portfolio.trades.Trades">Trades</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.portfolio.trades.Trades.close" href="#vectorbt.portfolio.trades.Trades.close">close</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.closed" href="#vectorbt.portfolio.trades.Trades.closed">closed</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.closed_rate" href="#vectorbt.portfolio.trades.Trades.closed_rate">closed_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.col_mapper" href="../records/base.html#vectorbt.records.base.Records.col_mapper">col_mapper</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.count" href="../records/base.html#vectorbt.records.base.Records.count">count</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.direction" href="#vectorbt.portfolio.trades.Trades.direction">direction</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.duration" href="#vectorbt.portfolio.trades.Trades.duration">duration</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.expectancy" href="#vectorbt.portfolio.trades.Trades.expectancy">expectancy</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.filter_by_mask" href="../records/base.html#vectorbt.records.base.Records.filter_by_mask">filter_by_mask</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.from_orders" href="#vectorbt.portfolio.trades.Trades.from_orders">from_orders</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.idx_field" href="../records/base.html#vectorbt.records.base.Records.idx_field">idx_field</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.is_sorted" href="../records/base.html#vectorbt.records.base.Records.is_sorted">is_sorted</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.long" href="#vectorbt.portfolio.trades.Trades.long">long</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.long_rate" href="#vectorbt.portfolio.trades.Trades.long_rate">long_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.losing" href="#vectorbt.portfolio.trades.Trades.losing">losing</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.loss_rate" href="#vectorbt.portfolio.trades.Trades.loss_rate">loss_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.map" href="../records/base.html#vectorbt.records.base.Records.map">map</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.map_array" href="../records/base.html#vectorbt.records.base.Records.map_array">map_array</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.map_field" href="../records/base.html#vectorbt.records.base.Records.map_field">map_field</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.open" href="#vectorbt.portfolio.trades.Trades.open">open</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.open_rate" href="#vectorbt.portfolio.trades.Trades.open_rate">open_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.plot" href="#vectorbt.portfolio.trades.Trades.plot">plot</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.plot_pnl" href="#vectorbt.portfolio.trades.Trades.plot_pnl">plot_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.pnl" href="#vectorbt.portfolio.trades.Trades.pnl">pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.profit_factor" href="#vectorbt.portfolio.trades.Trades.profit_factor">profit_factor</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.records" href="../records/base.html#vectorbt.records.base.Records.records">records</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.records_arr" href="../records/base.html#vectorbt.records.base.Records.records_arr">records_arr</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.records_readable" href="#vectorbt.portfolio.trades.Trades.records_readable">records_readable</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.returns" href="#vectorbt.portfolio.trades.Trades.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.short" href="#vectorbt.portfolio.trades.Trades.short">short</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.short_rate" href="#vectorbt.portfolio.trades.Trades.short_rate">short_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.sort" href="../records/base.html#vectorbt.records.base.Records.sort">sort</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.sqn" href="#vectorbt.portfolio.trades.Trades.sqn">sqn</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.status" href="#vectorbt.portfolio.trades.Trades.status">status</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.trade_type" href="#vectorbt.portfolio.trades.Trades.trade_type">trade_type</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.values" href="../records/base.html#vectorbt.records.base.Records.values">values</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.win_rate" href="#vectorbt.portfolio.trades.Trades.win_rate">win_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.winning" href="#vectorbt.portfolio.trades.Trades.winning">winning</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.portfolio.trades.Trades"><code class="flex name class">
<span>class <span class="ident parent-fname">Trades</span></span>
<span>(</span><span>wrapper, records_arr, close, idx_field='exit_idx', trade_type=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code>Records</code> for working with trade records.</p>
<p>In vectorbt, a trade is a partial closing operation; it's is a more fine-grained representation
of a position. One position can incorporate multiple trades. Performance for this operation is
calculated based on the size-weighted average of previous opening operations within the same
position. The PnL of all trades combined always equals to the PnL of the entire position.</p>
<p>For example, if you have a single large buy operation and 100 small sell operations, you will see
100 trades, each opening with a fraction of the buy operation's size and fees. On the other hand,
having 100 buy operations and just a single sell operation will generate a single trade with buy
price being a size-weighted average over all purchase prices, and opening size and fees being
the sum over all sizes and fees.</p>
<h2 id="example">Example</h2>
<p>Increasing position:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import pandas as pd

&gt;&gt;&gt; vbt.Portfolio.from_orders(
...     pd.Series([1., 2., 3., 4., 5.]),
...     pd.Series([1., 1., 1., 1., -4.]),
...     fixed_fees=1.).trades().records
   id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \
0   0    0   4.0          0          2.5         4.0         4         5.0

   exit_fees  pnl  return  direction  status  position_id
0        1.0  5.0     0.5          0       1            0
</code></pre>
<p>Decreasing position:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.Portfolio.from_orders(
...     pd.Series([1., 2., 3., 4., 5.]),
...     pd.Series([4., -1., -1., -1., -1.]),
...     fixed_fees=1.).trades().records
   id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \
0   0    0   1.0          0          1.0        0.25         1         2.0
1   1    0   1.0          0          1.0        0.25         2         3.0
2   2    0   1.0          0          1.0        0.25         3         4.0
3   3    0   1.0          0          1.0        0.25         4         5.0

   exit_fees   pnl  return  direction  status  position_id
0        1.0 -0.25   -0.25          0       1            0
1        1.0  0.75    0.75          0       1            0
2        1.0  1.75    1.75          0       1            0
3        1.0  2.75    2.75          0       1            0
</code></pre>
<p>Multiple reversing positions:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.Portfolio.from_orders(
...     pd.Series([1., 2., 3., 4., 5.]),
...     pd.Series([1., -2., 2., -2., 1.]),
...     fixed_fees=1.).trades().records
   id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \
0   0    0   1.0          0          1.0         1.0         1         2.0
1   1    0   1.0          1          2.0         0.5         2         3.0
2   2    0   1.0          2          3.0         0.5         3         4.0
3   3    0   1.0          3          4.0         0.5         4         5.0

   exit_fees  pnl  return  direction  status  position_id
0        0.5 -0.5  -0.500          0       1            0
1        0.5 -2.0  -1.000          1       1            1
2        0.5  0.0   0.000          0       1            2
3        1.0 -2.5  -0.625          1       1            3
</code></pre>
<p>Get count and PnL of trades:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; price = pd.Series([1., 2., 3., 4., 3., 2., 1.])
&gt;&gt;&gt; orders = pd.Series([1., -0.5, -0.5, 2., -0.5, -0.5, -0.5])
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders)

&gt;&gt;&gt; trades = vbt.Trades.from_orders(portfolio.orders())
&gt;&gt;&gt; trades.count()
6
&gt;&gt;&gt; trades.pnl.sum()
-3.0
&gt;&gt;&gt; trades.winning.count()
2
&gt;&gt;&gt; trades.winning.pnl.sum()
1.5
</code></pre>
<p>Get count and PnL of trades with duration of more than 2 days:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask = (trades.records['exit_idx'] - trades.records['entry_idx']) &gt; 2
&gt;&gt;&gt; trades_filtered = trades.filter_by_mask(mask)
&gt;&gt;&gt; trades_filtered.count()
2
&gt;&gt;&gt; trades_filtered.pnl.sum()
-3.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trades(Records):
    &#34;&#34;&#34;Extends `Records` for working with trade records.

    In vectorbt, a trade is a partial closing operation; it&#39;s is a more fine-grained representation
    of a position. One position can incorporate multiple trades. Performance for this operation is
    calculated based on the size-weighted average of previous opening operations within the same
    position. The PnL of all trades combined always equals to the PnL of the entire position.

    For example, if you have a single large buy operation and 100 small sell operations, you will see
    100 trades, each opening with a fraction of the buy operation&#39;s size and fees. On the other hand,
    having 100 buy operations and just a single sell operation will generate a single trade with buy
    price being a size-weighted average over all purchase prices, and opening size and fees being
    the sum over all sizes and fees.

    ## Example

    Increasing position:
    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt
    &gt;&gt;&gt; import pandas as pd

    &gt;&gt;&gt; vbt.Portfolio.from_orders(
    ...     pd.Series([1., 2., 3., 4., 5.]),
    ...     pd.Series([1., 1., 1., 1., -4.]),
    ...     fixed_fees=1.).trades().records
       id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \\
    0   0    0   4.0          0          2.5         4.0         4         5.0

       exit_fees  pnl  return  direction  status  position_id
    0        1.0  5.0     0.5          0       1            0
    ```

    Decreasing position:
    ```python-repl
    &gt;&gt;&gt; vbt.Portfolio.from_orders(
    ...     pd.Series([1., 2., 3., 4., 5.]),
    ...     pd.Series([4., -1., -1., -1., -1.]),
    ...     fixed_fees=1.).trades().records
       id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \\
    0   0    0   1.0          0          1.0        0.25         1         2.0
    1   1    0   1.0          0          1.0        0.25         2         3.0
    2   2    0   1.0          0          1.0        0.25         3         4.0
    3   3    0   1.0          0          1.0        0.25         4         5.0

       exit_fees   pnl  return  direction  status  position_id
    0        1.0 -0.25   -0.25          0       1            0
    1        1.0  0.75    0.75          0       1            0
    2        1.0  1.75    1.75          0       1            0
    3        1.0  2.75    2.75          0       1            0
    ```

    Multiple reversing positions:
    ```python-repl
    &gt;&gt;&gt; vbt.Portfolio.from_orders(
    ...     pd.Series([1., 2., 3., 4., 5.]),
    ...     pd.Series([1., -2., 2., -2., 1.]),
    ...     fixed_fees=1.).trades().records
       id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \\
    0   0    0   1.0          0          1.0         1.0         1         2.0
    1   1    0   1.0          1          2.0         0.5         2         3.0
    2   2    0   1.0          2          3.0         0.5         3         4.0
    3   3    0   1.0          3          4.0         0.5         4         5.0

       exit_fees  pnl  return  direction  status  position_id
    0        0.5 -0.5  -0.500          0       1            0
    1        0.5 -2.0  -1.000          1       1            1
    2        0.5  0.0   0.000          0       1            2
    3        1.0 -2.5  -0.625          1       1            3
    ```

    Get count and PnL of trades:
    ```python-repl
    &gt;&gt;&gt; price = pd.Series([1., 2., 3., 4., 3., 2., 1.])
    &gt;&gt;&gt; orders = pd.Series([1., -0.5, -0.5, 2., -0.5, -0.5, -0.5])
    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders)

    &gt;&gt;&gt; trades = vbt.Trades.from_orders(portfolio.orders())
    &gt;&gt;&gt; trades.count()
    6
    &gt;&gt;&gt; trades.pnl.sum()
    -3.0
    &gt;&gt;&gt; trades.winning.count()
    2
    &gt;&gt;&gt; trades.winning.pnl.sum()
    1.5
    ```

    Get count and PnL of trades with duration of more than 2 days:
    ```python-repl
    &gt;&gt;&gt; mask = (trades.records[&#39;exit_idx&#39;] - trades.records[&#39;entry_idx&#39;]) &gt; 2
    &gt;&gt;&gt; trades_filtered = trades.filter_by_mask(mask)
    &gt;&gt;&gt; trades_filtered.count()
    2
    &gt;&gt;&gt; trades_filtered.pnl.sum()
    -3.0
    ```
    &#34;&#34;&#34;

    def __init__(self, wrapper, records_arr, close, idx_field=&#39;exit_idx&#39;,
                 trade_type=TradeType.Trade, **kwargs):
        Records.__init__(
            self,
            wrapper,
            records_arr,
            idx_field=idx_field,
            close=close,
            trade_type=trade_type,
            **kwargs
        )
        self._close = broadcast_to(close, wrapper.dummy(group_by=False))
        self._trade_type = trade_type

        if trade_type == TradeType.Trade:
            if not all(field in records_arr.dtype.names for field in trade_dt.names):
                raise TypeError(&#34;Records array must match trade_dt&#34;)
        else:
            if not all(field in records_arr.dtype.names for field in position_dt.names):
                raise TypeError(&#34;Records array must match position_dt&#34;)

    def _indexing_func_meta(self, pd_indexing_func):
        &#34;&#34;&#34;Perform indexing on `Trades` and also return metadata.&#34;&#34;&#34;
        new_wrapper, new_records_arr, group_idxs, col_idxs = \
            Records._indexing_func_meta(self, pd_indexing_func)
        new_close = new_wrapper.wrap(to_2d(self.close, raw=True)[:, col_idxs], group_by=False)
        return self.copy(
            wrapper=new_wrapper,
            records_arr=new_records_arr,
            close=new_close
        ), group_idxs, col_idxs

    def _indexing_func(self, pd_indexing_func):
        &#34;&#34;&#34;Perform indexing on `Trades`.&#34;&#34;&#34;
        return self._indexing_func_meta(pd_indexing_func)[0]

    @property
    def close(self):
        &#34;&#34;&#34;Reference price such as close.&#34;&#34;&#34;
        return self._close

    @property
    def trade_type(self):
        &#34;&#34;&#34;Trade type.&#34;&#34;&#34;
        return self._trade_type

    @classmethod
    def from_orders(cls, orders, **kwargs):
        &#34;&#34;&#34;Build `Trades` from `vectorbt.portfolio.orders.Orders`.&#34;&#34;&#34;
        trade_records_arr = nb.orders_to_trades_nb(
            orders.close.vbt.to_2d_array(),
            orders.values,
            orders.col_mapper.col_map
        )
        return cls(orders.wrapper, trade_records_arr, orders.close, **kwargs)

    @property  # no need for cached
    def records_readable(self):
        &#34;&#34;&#34;Records in readable format.&#34;&#34;&#34;
        records_df = self.records
        out = pd.DataFrame()
        _id_str = &#39;Trade Id&#39; if self.trade_type == TradeType.Trade else &#39;Position Id&#39;
        out[_id_str] = records_df[&#39;id&#39;]
        out[&#39;Column&#39;] = records_df[&#39;col&#39;].map(lambda x: self.wrapper.columns[x])
        out[&#39;Size&#39;] = records_df[&#39;size&#39;]
        out[&#39;Entry Date&#39;] = records_df[&#39;entry_idx&#39;].map(lambda x: self.wrapper.index[x])
        out[&#39;Avg. Entry Price&#39;] = records_df[&#39;entry_price&#39;]
        out[&#39;Entry Fees&#39;] = records_df[&#39;entry_fees&#39;]
        out[&#39;Exit Date&#39;] = records_df[&#39;exit_idx&#39;].map(lambda x: self.wrapper.index[x])
        out[&#39;Avg. Exit Price&#39;] = records_df[&#39;exit_price&#39;]
        out[&#39;Exit Fees&#39;] = records_df[&#39;exit_fees&#39;]
        out[&#39;PnL&#39;] = records_df[&#39;pnl&#39;]
        out[&#39;Return&#39;] = records_df[&#39;return&#39;]
        out[&#39;Direction&#39;] = records_df[&#39;direction&#39;].map(to_value_map(TradeDirection))
        out[&#39;Status&#39;] = records_df[&#39;status&#39;].map(to_value_map(TradeStatus))
        if self.trade_type == TradeType.Trade:
            out[&#39;Position Id&#39;] = records_df[&#39;position_id&#39;]
        return out

    @cached_property
    def duration(self):
        &#34;&#34;&#34;Duration of each trade (in raw format).&#34;&#34;&#34;
        return self.map(nb.trade_duration_map_nb)

    @cached_property
    def pnl(self):
        &#34;&#34;&#34;PnL of each trade.&#34;&#34;&#34;
        return self.map_field(&#39;pnl&#39;)

    @cached_property
    def returns(self):
        &#34;&#34;&#34;Return of each trade.&#34;&#34;&#34;
        return self.map_field(&#39;return&#39;)

    # ############# PnL ############# #

    @cached_property
    def winning(self):
        &#34;&#34;&#34;Winning trades.&#34;&#34;&#34;
        filter_mask = self.values[&#39;pnl&#39;] &gt; 0.
        return self.filter_by_mask(filter_mask)

    @cached_method
    def win_rate(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Rate of winning trades.&#34;&#34;&#34;
        win_count = to_1d(self.winning.count(group_by=group_by), raw=True)
        total_count = to_1d(self.count(group_by=group_by), raw=True)
        return self.wrapper.wrap_reduced(win_count / total_count, group_by=group_by, **kwargs)

    @cached_property
    def losing(self):
        &#34;&#34;&#34;Losing trades.&#34;&#34;&#34;
        filter_mask = self.values[&#39;pnl&#39;] &lt; 0.
        return self.filter_by_mask(filter_mask)

    @cached_method
    def loss_rate(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Rate of losing trades.&#34;&#34;&#34;
        loss_count = to_1d(self.losing.count(group_by=group_by), raw=True)
        total_count = to_1d(self.count(group_by=group_by), raw=True)
        return self.wrapper.wrap_reduced(loss_count / total_count, group_by=group_by, **kwargs)

    @cached_method
    def profit_factor(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Profit factor.&#34;&#34;&#34;
        total_win = to_1d(self.winning.pnl.sum(group_by=group_by), raw=True)
        total_loss = to_1d(self.losing.pnl.sum(group_by=group_by), raw=True)

        # Otherwise columns with only wins or losses will become NaNs
        has_values = to_1d(self.count(group_by=group_by), raw=True) &gt; 0
        total_win[np.isnan(total_win) &amp; has_values] = 0.
        total_loss[np.isnan(total_loss) &amp; has_values] = 0.

        profit_factor = total_win / np.abs(total_loss)
        return self.wrapper.wrap_reduced(profit_factor, group_by=group_by, **kwargs)

    @cached_method
    def expectancy(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Average profitability.&#34;&#34;&#34;
        win_rate = to_1d(self.win_rate(group_by=group_by), raw=True)
        avg_win = to_1d(self.winning.pnl.mean(group_by=group_by), raw=True)
        avg_loss = to_1d(self.losing.pnl.mean(group_by=group_by), raw=True)

        # Otherwise columns with only wins or losses will become NaNs
        has_values = to_1d(self.count(group_by=group_by), raw=True) &gt; 0
        avg_win[np.isnan(avg_win) &amp; has_values] = 0.
        avg_loss[np.isnan(avg_loss) &amp; has_values] = 0.

        expectancy = win_rate * avg_win - (1 - win_rate) * np.abs(avg_loss)
        return self.wrapper.wrap_reduced(expectancy, group_by=group_by, **kwargs)

    @cached_method
    def sqn(self, group_by=None, **kwargs):
        &#34;&#34;&#34;System Quality Number (SQN).&#34;&#34;&#34;
        count = to_1d(self.count(group_by=group_by), raw=True)
        pnl_mean = to_1d(self.pnl.mean(group_by=group_by), raw=True)
        pnl_std = to_1d(self.pnl.std(group_by=group_by), raw=True)
        sqn = np.sqrt(count) * pnl_mean / pnl_std
        return self.wrapper.wrap_reduced(sqn, group_by=group_by, **kwargs)

    # ############# TradeDirection ############# #

    @cached_property
    def direction(self):
        &#34;&#34;&#34;See `vectorbt.portfolio.enums.TradeDirection`.&#34;&#34;&#34;
        return self.map_field(&#39;direction&#39;)

    @cached_property
    def long(self):
        &#34;&#34;&#34;Long trades.&#34;&#34;&#34;
        filter_mask = self.values[&#39;direction&#39;] == TradeDirection.Long
        return self.filter_by_mask(filter_mask)

    @cached_method
    def long_rate(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Rate of long trades.&#34;&#34;&#34;
        long_count = to_1d(self.long.count(group_by=group_by), raw=True)
        total_count = to_1d(self.count(group_by=group_by), raw=True)
        return self.wrapper.wrap_reduced(long_count / total_count, group_by=group_by, **kwargs)

    @cached_property
    def short(self):
        &#34;&#34;&#34;Short trades.&#34;&#34;&#34;
        filter_mask = self.values[&#39;direction&#39;] == TradeDirection.Short
        return self.filter_by_mask(filter_mask)

    @cached_method
    def short_rate(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Rate of short trades.&#34;&#34;&#34;
        short_count = to_1d(self.short.count(group_by=group_by), raw=True)
        total_count = to_1d(self.count(group_by=group_by), raw=True)
        return self.wrapper.wrap_reduced(short_count / total_count, group_by=group_by, **kwargs)

    # ############# TradeStatus ############# #

    @cached_property
    def status(self):
        &#34;&#34;&#34;See `vectorbt.portfolio.enums.TradeStatus`.&#34;&#34;&#34;
        return self.map_field(&#39;status&#39;)

    @cached_property
    def open(self):
        &#34;&#34;&#34;Open trades.&#34;&#34;&#34;
        filter_mask = self.values[&#39;status&#39;] == TradeStatus.Open
        return self.filter_by_mask(filter_mask)

    @cached_method
    def open_rate(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Rate of open trades.&#34;&#34;&#34;
        open_count = to_1d(self.open.count(group_by=group_by), raw=True)
        total_count = to_1d(self.count(group_by=group_by), raw=True)
        return self.wrapper.wrap_reduced(open_count / total_count, group_by=group_by, **kwargs)

    @cached_property
    def closed(self):
        &#34;&#34;&#34;Closed trades.&#34;&#34;&#34;
        filter_mask = self.values[&#39;status&#39;] == TradeStatus.Closed
        return self.filter_by_mask(filter_mask)

    @cached_method
    def closed_rate(self, group_by=None, **kwargs):
        &#34;&#34;&#34;Rate of closed trades.&#34;&#34;&#34;
        closed_count = to_1d(self.closed.count(group_by=group_by), raw=True)
        total_count = to_1d(self.count(group_by=group_by), raw=True)
        return self.wrapper.wrap_reduced(closed_count / total_count, group_by=group_by, **kwargs)

    # ############# Plotting ############# #

    def plot_pnl(self,
                 column=None,
                 marker_size_range=[7, 14],
                 opacity_range=[0.75, 0.9],
                 closed_profit_trace_kwargs=None,
                 closed_loss_trace_kwargs=None,
                 open_trace_kwargs=None,
                 hline_shape_kwargs=None,
                 row=None, col=None,
                 xref=&#39;x&#39;, yref=&#39;y&#39;,
                 fig=None,
                 **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot trade PnL.

        Args:
            column (str): Name of the column to plot.
            closed_profit_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Closed - Profit&#34; markers.
            closed_loss_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Closed - Loss&#34; markers.
            open_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Open&#34; markers.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            row (int): Row position.
            col (int): Column position.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.

        ## Example

        ```python-repl
        &gt;&gt;&gt; trades.plot_pnl()
        ```

        ![](/vectorbt/docs/img/trades_plot_pnl.png)
        &#34;&#34;&#34;
        from vectorbt.settings import contrast_color_schema

        self_col = self.select_series(column=column, group_by=False)

        if closed_profit_trace_kwargs is None:
            closed_profit_trace_kwargs = {}
        if closed_loss_trace_kwargs is None:
            closed_loss_trace_kwargs = {}
        if open_trace_kwargs is None:
            open_trace_kwargs = {}
        if hline_shape_kwargs is None:
            hline_shape_kwargs = {}
        marker_size_range = tuple(marker_size_range)

        if fig is None:
            fig = CustomFigureWidget()
        fig.update_layout(**layout_kwargs)
        x_domain = [0, 1]
        xaxis = &#39;xaxis&#39; + xref[1:]
        if xaxis in fig.layout:
            if &#39;domain&#39; in fig.layout[xaxis]:
                if fig.layout[xaxis][&#39;domain&#39;] is not None:
                    x_domain = fig.layout[xaxis][&#39;domain&#39;]

        if len(self_col.values) &gt; 0:
            # Extract information
            _id = self.values[&#39;id&#39;]
            _id_str = &#39;Trade Id&#39; if self.trade_type == TradeType.Trade else &#39;Position Id&#39;
            exit_idx = self.values[&#39;exit_idx&#39;]
            pnl = self.values[&#39;pnl&#39;]
            returns = self.values[&#39;return&#39;]
            status = self.values[&#39;status&#39;]

            neutral_mask = pnl == 0
            profit_mask = pnl &gt; 0
            loss_mask = pnl &lt; 0

            exit_idx = exit_idx[~neutral_mask]  # needed for rel_rescale
            pnl = pnl[~neutral_mask]
            returns = returns[~neutral_mask]
            marker_size = min_rel_rescale(np.abs(returns), marker_size_range)
            opacity = max_rel_rescale(np.abs(returns), opacity_range)

            open_mask = status == TradeStatus.Open
            closed_profit_mask = (~open_mask) &amp; profit_mask
            closed_loss_mask = (~open_mask) &amp; loss_mask
            open_mask &amp;= ~neutral_mask

            if np.any(closed_profit_mask):
                # Plot Profit markers
                profit_scatter = go.Scatter(
                    x=self_col.wrapper.index[exit_idx[closed_profit_mask]],
                    y=pnl[closed_profit_mask],
                    mode=&#39;markers&#39;,
                    marker=dict(
                        symbol=&#39;circle&#39;,
                        color=contrast_color_schema[&#39;green&#39;],
                        size=marker_size[closed_profit_mask],
                        opacity=opacity[closed_profit_mask],
                        line=dict(
                            width=1,
                            color=adjust_lightness(contrast_color_schema[&#39;green&#39;])
                        ),
                    ),
                    name=&#39;Closed - Profit&#39;,
                    customdata=np.stack((_id[closed_profit_mask], returns[closed_profit_mask]), axis=1),
                    hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                            &#34;&lt;br&gt;Date: %{x}&#34;
                                            &#34;&lt;br&gt;PnL: %{y}&#34;
                                            &#34;&lt;br&gt;Return: %{customdata[1]:.2%}&#34;
                )
                profit_scatter.update(**closed_profit_trace_kwargs)
                fig.add_trace(profit_scatter, row=row, col=col)

            if np.any(closed_loss_mask):
                # Plot Loss markers
                loss_scatter = go.Scatter(
                    x=self_col.wrapper.index[exit_idx[closed_loss_mask]],
                    y=pnl[closed_loss_mask],
                    mode=&#39;markers&#39;,
                    marker=dict(
                        symbol=&#39;circle&#39;,
                        color=contrast_color_schema[&#39;red&#39;],
                        size=marker_size[closed_loss_mask],
                        opacity=opacity[closed_loss_mask],
                        line=dict(
                            width=1,
                            color=adjust_lightness(contrast_color_schema[&#39;red&#39;])
                        )
                    ),
                    name=&#39;Closed - Loss&#39;,
                    customdata=np.stack((_id[closed_loss_mask], returns[closed_loss_mask]), axis=1),
                    hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                            &#34;&lt;br&gt;Date: %{x}&#34;
                                            &#34;&lt;br&gt;PnL: %{y}&#34;
                                            &#34;&lt;br&gt;Return: %{customdata[1]:.2%}&#34;
                )
                loss_scatter.update(**closed_loss_trace_kwargs)
                fig.add_trace(loss_scatter, row=row, col=col)

            if np.any(open_mask):
                # Plot Active markers
                active_scatter = go.Scatter(
                    x=self_col.wrapper.index[exit_idx[open_mask]],
                    y=pnl[open_mask],
                    mode=&#39;markers&#39;,
                    marker=dict(
                        symbol=&#39;circle&#39;,
                        color=contrast_color_schema[&#39;orange&#39;],
                        size=marker_size[open_mask],
                        opacity=opacity[open_mask],
                        line=dict(
                            width=1,
                            color=adjust_lightness(contrast_color_schema[&#39;orange&#39;])
                        )
                    ),
                    name=&#39;Open&#39;,
                    customdata=np.stack((_id[open_mask], returns[open_mask]), axis=1),
                    hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                            &#34;&lt;br&gt;Date: %{x}&#34;
                                            &#34;&lt;br&gt;PnL: %{y}&#34;
                                            &#34;&lt;br&gt;Return: %{customdata[1]:.2%}&#34;
                )
                active_scatter.update(**open_trace_kwargs)
                fig.add_trace(active_scatter, row=row, col=col)

        # Plot zeroline
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=0,
            x1=x_domain[1],
            y1=0,
            line=dict(
                color=&#34;gray&#34;,
                dash=&#34;dash&#34;,
            )
        ), hline_shape_kwargs))
        return fig

    def plot(self,
             column=None,
             plot_close=True,
             plot_zones=True,
             close_trace_kwargs=None,
             entry_trace_kwargs=None,
             exit_trace_kwargs=None,
             exit_profit_trace_kwargs=None,
             exit_loss_trace_kwargs=None,
             active_trace_kwargs=None,
             profit_shape_kwargs=None,
             loss_shape_kwargs=None,
             row=None, col=None,
             xref=&#39;x&#39;, yref=&#39;y&#39;,
             fig=None,
             **layout_kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot orders.

        Args:
            column (str): Name of the column to plot.
            plot_close (bool): Whether to plot `Trades.close`.
            plot_zones (bool): Whether to plot zones.

                Set to False if there are many trades within one position.
            close_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `Trades.close`.
            entry_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Entry&#34; markers.
            exit_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Exit&#34; markers.
            exit_profit_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Exit - Profit&#34; markers.
            exit_loss_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Exit - Loss&#34; markers.
            active_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Active&#34; markers.
            profit_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for profit zones.
            loss_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for loss zones.
            row (int): Row position.
            col (int): Column position.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.

        ## Example

        ```python-repl
        &gt;&gt;&gt; trades.plot()
        ```

        ![](/vectorbt/docs/img/trades_plot.png)&#34;&#34;&#34;
        from vectorbt.settings import color_schema, contrast_color_schema

        self_col = self.select_series(column=column, group_by=False)

        if close_trace_kwargs is None:
            close_trace_kwargs = {}
        close_trace_kwargs = merge_dicts(dict(
            line_color=color_schema[&#39;blue&#39;],
            name=&#39;Close&#39; if self_col.wrapper.name is None else self_col.wrapper.name
        ), close_trace_kwargs)
        if entry_trace_kwargs is None:
            entry_trace_kwargs = {}
        if exit_trace_kwargs is None:
            exit_trace_kwargs = {}
        if exit_profit_trace_kwargs is None:
            exit_profit_trace_kwargs = {}
        if exit_loss_trace_kwargs is None:
            exit_loss_trace_kwargs = {}
        if active_trace_kwargs is None:
            active_trace_kwargs = {}
        if profit_shape_kwargs is None:
            profit_shape_kwargs = {}
        if loss_shape_kwargs is None:
            loss_shape_kwargs = {}

        if fig is None:
            fig = CustomFigureWidget()
        fig.update_layout(**layout_kwargs)

        # Plot close
        if plot_close:
            fig = self_col.close.vbt.plot(trace_kwargs=close_trace_kwargs, row=row, col=col, fig=fig)

        if len(self_col.values) &gt; 0:
            # Extract information
            _id = self_col.values[&#39;id&#39;]
            _id_str = &#39;Trade Id&#39; if self.trade_type == TradeType.Trade else &#39;Position Id&#39;
            size = self_col.values[&#39;size&#39;]
            entry_idx = self_col.values[&#39;entry_idx&#39;]
            entry_price = self_col.values[&#39;entry_price&#39;]
            entry_fees = self_col.values[&#39;entry_fees&#39;]
            exit_idx = self_col.values[&#39;exit_idx&#39;]
            exit_price = self_col.values[&#39;exit_price&#39;]
            exit_fees = self_col.values[&#39;exit_fees&#39;]
            pnl = self_col.values[&#39;pnl&#39;]
            ret = self_col.values[&#39;return&#39;]
            direction_value_map = to_value_map(TradeDirection)
            direction = self_col.values[&#39;direction&#39;]
            direction = np.vectorize(lambda x: str(direction_value_map[x]))(direction)
            status = self_col.values[&#39;status&#39;]

            def get_duration_str(from_idx, to_idx):
                if isinstance(self_col.wrapper.index, DatetimeTypes):
                    duration = self_col.wrapper.index[to_idx] - self_col.wrapper.index[from_idx]
                elif self_col.wrapper.freq is not None:
                    duration = self_col.wrapper.to_time_units(to_idx - from_idx)
                else:
                    duration = to_idx - from_idx
                return np.vectorize(str)(duration)

            duration = get_duration_str(entry_idx, exit_idx)

            if len(entry_idx) &gt; 0:
                # Plot Entry markers
                entry_customdata = np.stack((
                    _id,
                    size,
                    entry_fees,
                    direction,
                    *((self_col.values[&#39;position_id&#39;],)
                      if self.trade_type == TradeType.Trade else ())
                ), axis=1)
                entry_scatter = go.Scatter(
                    x=self_col.wrapper.index[entry_idx],
                    y=entry_price,
                    mode=&#39;markers&#39;,
                    marker=dict(
                        symbol=&#39;square&#39;,
                        color=contrast_color_schema[&#39;blue&#39;],
                        size=7,
                        line=dict(
                            width=1,
                            color=adjust_lightness(contrast_color_schema[&#39;blue&#39;])
                        )
                    ),
                    name=&#39;Entry&#39;,
                    customdata=entry_customdata,
                    hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                            &#34;&lt;br&gt;Date: %{x}&#34;
                                            &#34;&lt;br&gt;Avg. Price: %{y}&#34;
                                            &#34;&lt;br&gt;Size: %{customdata[1]:.6f}&#34;
                                            &#34;&lt;br&gt;Fees: %{customdata[2]:.6f}&#34;
                                            &#34;&lt;br&gt;Direction: %{customdata[3]}&#34;
                                  + (&#34;&lt;br&gt;Position Id: %{customdata[4]}&#34;
                                     if self.trade_type == TradeType.Trade else &#39;&#39;)
                )
                entry_scatter.update(**entry_trace_kwargs)
                fig.add_trace(entry_scatter, row=row, col=col)

            # Plot end markers
            def _plot_end_markers(mask, name, color, kwargs):
                if np.any(mask):
                    customdata = np.stack((
                        _id[mask],
                        duration[mask],
                        size[mask],
                        exit_fees[mask],
                        pnl[mask],
                        ret[mask],
                        direction[mask],
                        *((self_col.values[&#39;position_id&#39;][mask],)
                          if self.trade_type == TradeType.Trade else ())
                    ), axis=1)
                    scatter = go.Scatter(
                        x=self_col.wrapper.index[exit_idx[mask]],
                        y=exit_price[mask],
                        mode=&#39;markers&#39;,
                        marker=dict(
                            symbol=&#39;square&#39;,
                            color=color,
                            size=7,
                            line=dict(
                                width=1,
                                color=adjust_lightness(color)
                            )
                        ),
                        name=name,
                        customdata=customdata,
                        hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                                &#34;&lt;br&gt;Date: %{x}&#34;
                                                &#34;&lt;br&gt;Duration: %{customdata[1]}&#34;
                                                &#34;&lt;br&gt;Avg. Price: %{y}&#34;
                                                &#34;&lt;br&gt;Size: %{customdata[2]:.6f}&#34;
                                                &#34;&lt;br&gt;Fees: %{customdata[3]:.6f}&#34;
                                                &#34;&lt;br&gt;PnL: %{customdata[4]:.6f}&#34;
                                                &#34;&lt;br&gt;Return: %{customdata[5]:.2%}&#34;
                                                &#34;&lt;br&gt;Direction: %{customdata[6]}&#34;
                                      + (&#34;&lt;br&gt;Position Id: %{customdata[7]}&#34;
                                         if self.trade_type == TradeType.Trade else &#39;&#39;)
                    )
                    scatter.update(**kwargs)
                    fig.add_trace(scatter, row=row, col=col)

            # Plot Exit markers
            _plot_end_markers(
                (status == TradeStatus.Closed) &amp; (pnl == 0.),
                &#39;Exit&#39;,
                contrast_color_schema[&#39;gray&#39;],
                exit_trace_kwargs
            )

            # Plot Exit - Profit markers
            _plot_end_markers(
                (status == TradeStatus.Closed) &amp; (pnl &gt; 0.),
                &#39;Exit - Profit&#39;,
                contrast_color_schema[&#39;green&#39;],
                exit_profit_trace_kwargs
            )

            # Plot Exit - Loss markers
            _plot_end_markers(
                (status == TradeStatus.Closed) &amp; (pnl &lt; 0.),
                &#39;Exit - Loss&#39;,
                contrast_color_schema[&#39;red&#39;],
                exit_loss_trace_kwargs
            )

            # Plot Active markers
            _plot_end_markers(
                status == TradeStatus.Open,
                &#39;Active&#39;,
                contrast_color_schema[&#39;orange&#39;],
                active_trace_kwargs
            )

            if plot_zones:
                profit_mask = pnl &gt; 0.
                if np.any(profit_mask):
                    # Plot profit zones
                    for i in np.flatnonzero(profit_mask):
                        fig.add_shape(**merge_dicts(dict(
                            type=&#34;rect&#34;,
                            xref=xref,
                            yref=yref,
                            x0=self_col.wrapper.index[entry_idx[i]],
                            y0=entry_price[i],
                            x1=self_col.wrapper.index[exit_idx[i]],
                            y1=exit_price[i],
                            fillcolor=&#39;green&#39;,
                            opacity=0.2,
                            layer=&#34;below&#34;,
                            line_width=0,
                        ), profit_shape_kwargs))

                loss_mask = pnl &lt; 0.
                if np.any(loss_mask):
                    # Plot loss zones
                    for i in np.flatnonzero(loss_mask):
                        fig.add_shape(**merge_dicts(dict(
                            type=&#34;rect&#34;,
                            xref=xref,
                            yref=yref,
                            x0=self_col.wrapper.index[entry_idx[i]],
                            y0=entry_price[i],
                            x1=self_col.wrapper.index[exit_idx[i]],
                            y1=exit_price[i],
                            fillcolor=&#39;red&#39;,
                            opacity=0.2,
                            layer=&#34;below&#34;,
                            line_width=0,
                        ), loss_shape_kwargs))

        return fig</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.records.base.Records" href="../records/base.html#vectorbt.records.base.Records">Records</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.trades.Positions" href="#vectorbt.portfolio.trades.Positions">Positions</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.portfolio.trades.Trades.from_orders"><code class="name flex">
<span>def <span class="ident fname">from_orders</span></span>(<span>orders, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build <code><a title="vectorbt.portfolio.trades.Trades" href="#vectorbt.portfolio.trades.Trades">Trades</a></code> from <code><a title="vectorbt.portfolio.orders.Orders" href="orders.html#vectorbt.portfolio.orders.Orders">Orders</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_orders(cls, orders, **kwargs):
    &#34;&#34;&#34;Build `Trades` from `vectorbt.portfolio.orders.Orders`.&#34;&#34;&#34;
    trade_records_arr = nb.orders_to_trades_nb(
        orders.close.vbt.to_2d_array(),
        orders.values,
        orders.col_mapper.col_map
    )
    return cls(orders.wrapper, trade_records_arr, orders.close, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.trades.Trades.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Reference price such as close.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def close(self):
    &#34;&#34;&#34;Reference price such as close.&#34;&#34;&#34;
    return self._close</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.closed"><code class="name">var <span class="ident fname">closed</span></code></dt>
<dd>
<div class="desc"><p>Closed trades.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.direction"><code class="name">var <span class="ident fname">direction</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.portfolio.enums.TradeDirection" href="enums.html#vectorbt.portfolio.enums.TradeDirection">TradeDirection</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.duration"><code class="name">var <span class="ident fname">duration</span></code></dt>
<dd>
<div class="desc"><p>Duration of each trade (in raw format).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.long"><code class="name">var <span class="ident fname">long</span></code></dt>
<dd>
<div class="desc"><p>Long trades.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.losing"><code class="name">var <span class="ident fname">losing</span></code></dt>
<dd>
<div class="desc"><p>Losing trades.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.open"><code class="name">var <span class="ident fname">open</span></code></dt>
<dd>
<div class="desc"><p>Open trades.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.pnl"><code class="name">var <span class="ident fname">pnl</span></code></dt>
<dd>
<div class="desc"><p>PnL of each trade.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.records_readable"><code class="name">var <span class="ident fname">records_readable</span></code></dt>
<dd>
<div class="desc"><p>Records in readable format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property  # no need for cached
def records_readable(self):
    &#34;&#34;&#34;Records in readable format.&#34;&#34;&#34;
    records_df = self.records
    out = pd.DataFrame()
    _id_str = &#39;Trade Id&#39; if self.trade_type == TradeType.Trade else &#39;Position Id&#39;
    out[_id_str] = records_df[&#39;id&#39;]
    out[&#39;Column&#39;] = records_df[&#39;col&#39;].map(lambda x: self.wrapper.columns[x])
    out[&#39;Size&#39;] = records_df[&#39;size&#39;]
    out[&#39;Entry Date&#39;] = records_df[&#39;entry_idx&#39;].map(lambda x: self.wrapper.index[x])
    out[&#39;Avg. Entry Price&#39;] = records_df[&#39;entry_price&#39;]
    out[&#39;Entry Fees&#39;] = records_df[&#39;entry_fees&#39;]
    out[&#39;Exit Date&#39;] = records_df[&#39;exit_idx&#39;].map(lambda x: self.wrapper.index[x])
    out[&#39;Avg. Exit Price&#39;] = records_df[&#39;exit_price&#39;]
    out[&#39;Exit Fees&#39;] = records_df[&#39;exit_fees&#39;]
    out[&#39;PnL&#39;] = records_df[&#39;pnl&#39;]
    out[&#39;Return&#39;] = records_df[&#39;return&#39;]
    out[&#39;Direction&#39;] = records_df[&#39;direction&#39;].map(to_value_map(TradeDirection))
    out[&#39;Status&#39;] = records_df[&#39;status&#39;].map(to_value_map(TradeStatus))
    if self.trade_type == TradeType.Trade:
        out[&#39;Position Id&#39;] = records_df[&#39;position_id&#39;]
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.returns"><code class="name">var <span class="ident fname">returns</span></code></dt>
<dd>
<div class="desc"><p>Return of each trade.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.short"><code class="name">var <span class="ident fname">short</span></code></dt>
<dd>
<div class="desc"><p>Short trades.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.status"><code class="name">var <span class="ident fname">status</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.portfolio.enums.TradeStatus" href="enums.html#vectorbt.portfolio.enums.TradeStatus">TradeStatus</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.trade_type"><code class="name">var <span class="ident fname">trade_type</span></code></dt>
<dd>
<div class="desc"><p>Trade type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trade_type(self):
    &#34;&#34;&#34;Trade type.&#34;&#34;&#34;
    return self._trade_type</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.winning"><code class="name">var <span class="ident fname">winning</span></code></dt>
<dd>
<div class="desc"><p>Winning trades.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.portfolio.trades.Trades.closed_rate"><code class="name flex">
<span>def <span class="ident fname">closed_rate</span></span>(<span>self, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Rate of closed trades.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def closed_rate(self, group_by=None, **kwargs):
    &#34;&#34;&#34;Rate of closed trades.&#34;&#34;&#34;
    closed_count = to_1d(self.closed.count(group_by=group_by), raw=True)
    total_count = to_1d(self.count(group_by=group_by), raw=True)
    return self.wrapper.wrap_reduced(closed_count / total_count, group_by=group_by, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.expectancy"><code class="name flex">
<span>def <span class="ident fname">expectancy</span></span>(<span>self, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Average profitability.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def expectancy(self, group_by=None, **kwargs):
    &#34;&#34;&#34;Average profitability.&#34;&#34;&#34;
    win_rate = to_1d(self.win_rate(group_by=group_by), raw=True)
    avg_win = to_1d(self.winning.pnl.mean(group_by=group_by), raw=True)
    avg_loss = to_1d(self.losing.pnl.mean(group_by=group_by), raw=True)

    # Otherwise columns with only wins or losses will become NaNs
    has_values = to_1d(self.count(group_by=group_by), raw=True) &gt; 0
    avg_win[np.isnan(avg_win) &amp; has_values] = 0.
    avg_loss[np.isnan(avg_loss) &amp; has_values] = 0.

    expectancy = win_rate * avg_win - (1 - win_rate) * np.abs(avg_loss)
    return self.wrapper.wrap_reduced(expectancy, group_by=group_by, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.long_rate"><code class="name flex">
<span>def <span class="ident fname">long_rate</span></span>(<span>self, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Rate of long trades.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def long_rate(self, group_by=None, **kwargs):
    &#34;&#34;&#34;Rate of long trades.&#34;&#34;&#34;
    long_count = to_1d(self.long.count(group_by=group_by), raw=True)
    total_count = to_1d(self.count(group_by=group_by), raw=True)
    return self.wrapper.wrap_reduced(long_count / total_count, group_by=group_by, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.loss_rate"><code class="name flex">
<span>def <span class="ident fname">loss_rate</span></span>(<span>self, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Rate of losing trades.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def loss_rate(self, group_by=None, **kwargs):
    &#34;&#34;&#34;Rate of losing trades.&#34;&#34;&#34;
    loss_count = to_1d(self.losing.count(group_by=group_by), raw=True)
    total_count = to_1d(self.count(group_by=group_by), raw=True)
    return self.wrapper.wrap_reduced(loss_count / total_count, group_by=group_by, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.open_rate"><code class="name flex">
<span>def <span class="ident fname">open_rate</span></span>(<span>self, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Rate of open trades.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def open_rate(self, group_by=None, **kwargs):
    &#34;&#34;&#34;Rate of open trades.&#34;&#34;&#34;
    open_count = to_1d(self.open.count(group_by=group_by), raw=True)
    total_count = to_1d(self.count(group_by=group_by), raw=True)
    return self.wrapper.wrap_reduced(open_count / total_count, group_by=group_by, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, column=None, plot_close=True, plot_zones=True, close_trace_kwargs=None, entry_trace_kwargs=None, exit_trace_kwargs=None, exit_profit_trace_kwargs=None, exit_loss_trace_kwargs=None, active_trace_kwargs=None, profit_shape_kwargs=None, loss_shape_kwargs=None, row=None, col=None, xref='x', yref='y', fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot orders.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column to plot.</dd>
<dt><strong><code>plot_close</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to plot <code><a title="vectorbt.portfolio.trades.Trades.close" href="#vectorbt.portfolio.trades.Trades.close">Trades.close</a></code>.</dd>
<dt><strong><code>plot_zones</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to plot zones.</p>
<p>Set to False if there are many trades within one position.</p>
</dd>
<dt><strong><code>close_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.portfolio.trades.Trades.close" href="#vectorbt.portfolio.trades.Trades.close">Trades.close</a></code>.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for "Entry" markers.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for "Exit" markers.</dd>
<dt><strong><code>exit_profit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for "Exit - Profit" markers.</dd>
<dt><strong><code>exit_loss_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for "Exit - Loss" markers.</dd>
<dt><strong><code>active_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for "Active" markers.</dd>
<dt><strong><code>profit_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for profit zones.</dd>
<dt><strong><code>loss_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for loss zones.</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>Row position.</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>int</code></dt>
<dd>Column position.</dd>
<dt><strong><code>xref</code></strong> :&ensp;<code>str</code></dt>
<dd>X coordinate axis.</dd>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; trades.plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/trades_plot.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         column=None,
         plot_close=True,
         plot_zones=True,
         close_trace_kwargs=None,
         entry_trace_kwargs=None,
         exit_trace_kwargs=None,
         exit_profit_trace_kwargs=None,
         exit_loss_trace_kwargs=None,
         active_trace_kwargs=None,
         profit_shape_kwargs=None,
         loss_shape_kwargs=None,
         row=None, col=None,
         xref=&#39;x&#39;, yref=&#39;y&#39;,
         fig=None,
         **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot orders.

    Args:
        column (str): Name of the column to plot.
        plot_close (bool): Whether to plot `Trades.close`.
        plot_zones (bool): Whether to plot zones.

            Set to False if there are many trades within one position.
        close_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `Trades.close`.
        entry_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Entry&#34; markers.
        exit_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Exit&#34; markers.
        exit_profit_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Exit - Profit&#34; markers.
        exit_loss_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Exit - Loss&#34; markers.
        active_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Active&#34; markers.
        profit_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for profit zones.
        loss_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for loss zones.
        row (int): Row position.
        col (int): Column position.
        xref (str): X coordinate axis.
        yref (str): Y coordinate axis.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.

    ## Example

    ```python-repl
    &gt;&gt;&gt; trades.plot()
    ```

    ![](/vectorbt/docs/img/trades_plot.png)&#34;&#34;&#34;
    from vectorbt.settings import color_schema, contrast_color_schema

    self_col = self.select_series(column=column, group_by=False)

    if close_trace_kwargs is None:
        close_trace_kwargs = {}
    close_trace_kwargs = merge_dicts(dict(
        line_color=color_schema[&#39;blue&#39;],
        name=&#39;Close&#39; if self_col.wrapper.name is None else self_col.wrapper.name
    ), close_trace_kwargs)
    if entry_trace_kwargs is None:
        entry_trace_kwargs = {}
    if exit_trace_kwargs is None:
        exit_trace_kwargs = {}
    if exit_profit_trace_kwargs is None:
        exit_profit_trace_kwargs = {}
    if exit_loss_trace_kwargs is None:
        exit_loss_trace_kwargs = {}
    if active_trace_kwargs is None:
        active_trace_kwargs = {}
    if profit_shape_kwargs is None:
        profit_shape_kwargs = {}
    if loss_shape_kwargs is None:
        loss_shape_kwargs = {}

    if fig is None:
        fig = CustomFigureWidget()
    fig.update_layout(**layout_kwargs)

    # Plot close
    if plot_close:
        fig = self_col.close.vbt.plot(trace_kwargs=close_trace_kwargs, row=row, col=col, fig=fig)

    if len(self_col.values) &gt; 0:
        # Extract information
        _id = self_col.values[&#39;id&#39;]
        _id_str = &#39;Trade Id&#39; if self.trade_type == TradeType.Trade else &#39;Position Id&#39;
        size = self_col.values[&#39;size&#39;]
        entry_idx = self_col.values[&#39;entry_idx&#39;]
        entry_price = self_col.values[&#39;entry_price&#39;]
        entry_fees = self_col.values[&#39;entry_fees&#39;]
        exit_idx = self_col.values[&#39;exit_idx&#39;]
        exit_price = self_col.values[&#39;exit_price&#39;]
        exit_fees = self_col.values[&#39;exit_fees&#39;]
        pnl = self_col.values[&#39;pnl&#39;]
        ret = self_col.values[&#39;return&#39;]
        direction_value_map = to_value_map(TradeDirection)
        direction = self_col.values[&#39;direction&#39;]
        direction = np.vectorize(lambda x: str(direction_value_map[x]))(direction)
        status = self_col.values[&#39;status&#39;]

        def get_duration_str(from_idx, to_idx):
            if isinstance(self_col.wrapper.index, DatetimeTypes):
                duration = self_col.wrapper.index[to_idx] - self_col.wrapper.index[from_idx]
            elif self_col.wrapper.freq is not None:
                duration = self_col.wrapper.to_time_units(to_idx - from_idx)
            else:
                duration = to_idx - from_idx
            return np.vectorize(str)(duration)

        duration = get_duration_str(entry_idx, exit_idx)

        if len(entry_idx) &gt; 0:
            # Plot Entry markers
            entry_customdata = np.stack((
                _id,
                size,
                entry_fees,
                direction,
                *((self_col.values[&#39;position_id&#39;],)
                  if self.trade_type == TradeType.Trade else ())
            ), axis=1)
            entry_scatter = go.Scatter(
                x=self_col.wrapper.index[entry_idx],
                y=entry_price,
                mode=&#39;markers&#39;,
                marker=dict(
                    symbol=&#39;square&#39;,
                    color=contrast_color_schema[&#39;blue&#39;],
                    size=7,
                    line=dict(
                        width=1,
                        color=adjust_lightness(contrast_color_schema[&#39;blue&#39;])
                    )
                ),
                name=&#39;Entry&#39;,
                customdata=entry_customdata,
                hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                        &#34;&lt;br&gt;Date: %{x}&#34;
                                        &#34;&lt;br&gt;Avg. Price: %{y}&#34;
                                        &#34;&lt;br&gt;Size: %{customdata[1]:.6f}&#34;
                                        &#34;&lt;br&gt;Fees: %{customdata[2]:.6f}&#34;
                                        &#34;&lt;br&gt;Direction: %{customdata[3]}&#34;
                              + (&#34;&lt;br&gt;Position Id: %{customdata[4]}&#34;
                                 if self.trade_type == TradeType.Trade else &#39;&#39;)
            )
            entry_scatter.update(**entry_trace_kwargs)
            fig.add_trace(entry_scatter, row=row, col=col)

        # Plot end markers
        def _plot_end_markers(mask, name, color, kwargs):
            if np.any(mask):
                customdata = np.stack((
                    _id[mask],
                    duration[mask],
                    size[mask],
                    exit_fees[mask],
                    pnl[mask],
                    ret[mask],
                    direction[mask],
                    *((self_col.values[&#39;position_id&#39;][mask],)
                      if self.trade_type == TradeType.Trade else ())
                ), axis=1)
                scatter = go.Scatter(
                    x=self_col.wrapper.index[exit_idx[mask]],
                    y=exit_price[mask],
                    mode=&#39;markers&#39;,
                    marker=dict(
                        symbol=&#39;square&#39;,
                        color=color,
                        size=7,
                        line=dict(
                            width=1,
                            color=adjust_lightness(color)
                        )
                    ),
                    name=name,
                    customdata=customdata,
                    hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                            &#34;&lt;br&gt;Date: %{x}&#34;
                                            &#34;&lt;br&gt;Duration: %{customdata[1]}&#34;
                                            &#34;&lt;br&gt;Avg. Price: %{y}&#34;
                                            &#34;&lt;br&gt;Size: %{customdata[2]:.6f}&#34;
                                            &#34;&lt;br&gt;Fees: %{customdata[3]:.6f}&#34;
                                            &#34;&lt;br&gt;PnL: %{customdata[4]:.6f}&#34;
                                            &#34;&lt;br&gt;Return: %{customdata[5]:.2%}&#34;
                                            &#34;&lt;br&gt;Direction: %{customdata[6]}&#34;
                                  + (&#34;&lt;br&gt;Position Id: %{customdata[7]}&#34;
                                     if self.trade_type == TradeType.Trade else &#39;&#39;)
                )
                scatter.update(**kwargs)
                fig.add_trace(scatter, row=row, col=col)

        # Plot Exit markers
        _plot_end_markers(
            (status == TradeStatus.Closed) &amp; (pnl == 0.),
            &#39;Exit&#39;,
            contrast_color_schema[&#39;gray&#39;],
            exit_trace_kwargs
        )

        # Plot Exit - Profit markers
        _plot_end_markers(
            (status == TradeStatus.Closed) &amp; (pnl &gt; 0.),
            &#39;Exit - Profit&#39;,
            contrast_color_schema[&#39;green&#39;],
            exit_profit_trace_kwargs
        )

        # Plot Exit - Loss markers
        _plot_end_markers(
            (status == TradeStatus.Closed) &amp; (pnl &lt; 0.),
            &#39;Exit - Loss&#39;,
            contrast_color_schema[&#39;red&#39;],
            exit_loss_trace_kwargs
        )

        # Plot Active markers
        _plot_end_markers(
            status == TradeStatus.Open,
            &#39;Active&#39;,
            contrast_color_schema[&#39;orange&#39;],
            active_trace_kwargs
        )

        if plot_zones:
            profit_mask = pnl &gt; 0.
            if np.any(profit_mask):
                # Plot profit zones
                for i in np.flatnonzero(profit_mask):
                    fig.add_shape(**merge_dicts(dict(
                        type=&#34;rect&#34;,
                        xref=xref,
                        yref=yref,
                        x0=self_col.wrapper.index[entry_idx[i]],
                        y0=entry_price[i],
                        x1=self_col.wrapper.index[exit_idx[i]],
                        y1=exit_price[i],
                        fillcolor=&#39;green&#39;,
                        opacity=0.2,
                        layer=&#34;below&#34;,
                        line_width=0,
                    ), profit_shape_kwargs))

            loss_mask = pnl &lt; 0.
            if np.any(loss_mask):
                # Plot loss zones
                for i in np.flatnonzero(loss_mask):
                    fig.add_shape(**merge_dicts(dict(
                        type=&#34;rect&#34;,
                        xref=xref,
                        yref=yref,
                        x0=self_col.wrapper.index[entry_idx[i]],
                        y0=entry_price[i],
                        x1=self_col.wrapper.index[exit_idx[i]],
                        y1=exit_price[i],
                        fillcolor=&#39;red&#39;,
                        opacity=0.2,
                        layer=&#34;below&#34;,
                        line_width=0,
                    ), loss_shape_kwargs))

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.plot_pnl"><code class="name flex">
<span>def <span class="ident fname">plot_pnl</span></span>(<span>self, column=None, marker_size_range=[7, 14], opacity_range=[0.75, 0.9], closed_profit_trace_kwargs=None, closed_loss_trace_kwargs=None, open_trace_kwargs=None, hline_shape_kwargs=None, row=None, col=None, xref='x', yref='y', fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot trade PnL.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column to plot.</dd>
<dt><strong><code>closed_profit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for "Closed - Profit" markers.</dd>
<dt><strong><code>closed_loss_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for "Closed - Loss" markers.</dd>
<dt><strong><code>open_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for "Open" markers.</dd>
<dt><strong><code>hline_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline.</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>Row position.</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>int</code></dt>
<dd>Column position.</dd>
<dt><strong><code>xref</code></strong> :&ensp;<code>str</code></dt>
<dd>X coordinate axis.</dd>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; trades.plot_pnl()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/trades_plot_pnl.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_pnl(self,
             column=None,
             marker_size_range=[7, 14],
             opacity_range=[0.75, 0.9],
             closed_profit_trace_kwargs=None,
             closed_loss_trace_kwargs=None,
             open_trace_kwargs=None,
             hline_shape_kwargs=None,
             row=None, col=None,
             xref=&#39;x&#39;, yref=&#39;y&#39;,
             fig=None,
             **layout_kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot trade PnL.

    Args:
        column (str): Name of the column to plot.
        closed_profit_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Closed - Profit&#34; markers.
        closed_loss_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Closed - Loss&#34; markers.
        open_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Open&#34; markers.
        hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
        row (int): Row position.
        col (int): Column position.
        xref (str): X coordinate axis.
        yref (str): Y coordinate axis.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.

    ## Example

    ```python-repl
    &gt;&gt;&gt; trades.plot_pnl()
    ```

    ![](/vectorbt/docs/img/trades_plot_pnl.png)
    &#34;&#34;&#34;
    from vectorbt.settings import contrast_color_schema

    self_col = self.select_series(column=column, group_by=False)

    if closed_profit_trace_kwargs is None:
        closed_profit_trace_kwargs = {}
    if closed_loss_trace_kwargs is None:
        closed_loss_trace_kwargs = {}
    if open_trace_kwargs is None:
        open_trace_kwargs = {}
    if hline_shape_kwargs is None:
        hline_shape_kwargs = {}
    marker_size_range = tuple(marker_size_range)

    if fig is None:
        fig = CustomFigureWidget()
    fig.update_layout(**layout_kwargs)
    x_domain = [0, 1]
    xaxis = &#39;xaxis&#39; + xref[1:]
    if xaxis in fig.layout:
        if &#39;domain&#39; in fig.layout[xaxis]:
            if fig.layout[xaxis][&#39;domain&#39;] is not None:
                x_domain = fig.layout[xaxis][&#39;domain&#39;]

    if len(self_col.values) &gt; 0:
        # Extract information
        _id = self.values[&#39;id&#39;]
        _id_str = &#39;Trade Id&#39; if self.trade_type == TradeType.Trade else &#39;Position Id&#39;
        exit_idx = self.values[&#39;exit_idx&#39;]
        pnl = self.values[&#39;pnl&#39;]
        returns = self.values[&#39;return&#39;]
        status = self.values[&#39;status&#39;]

        neutral_mask = pnl == 0
        profit_mask = pnl &gt; 0
        loss_mask = pnl &lt; 0

        exit_idx = exit_idx[~neutral_mask]  # needed for rel_rescale
        pnl = pnl[~neutral_mask]
        returns = returns[~neutral_mask]
        marker_size = min_rel_rescale(np.abs(returns), marker_size_range)
        opacity = max_rel_rescale(np.abs(returns), opacity_range)

        open_mask = status == TradeStatus.Open
        closed_profit_mask = (~open_mask) &amp; profit_mask
        closed_loss_mask = (~open_mask) &amp; loss_mask
        open_mask &amp;= ~neutral_mask

        if np.any(closed_profit_mask):
            # Plot Profit markers
            profit_scatter = go.Scatter(
                x=self_col.wrapper.index[exit_idx[closed_profit_mask]],
                y=pnl[closed_profit_mask],
                mode=&#39;markers&#39;,
                marker=dict(
                    symbol=&#39;circle&#39;,
                    color=contrast_color_schema[&#39;green&#39;],
                    size=marker_size[closed_profit_mask],
                    opacity=opacity[closed_profit_mask],
                    line=dict(
                        width=1,
                        color=adjust_lightness(contrast_color_schema[&#39;green&#39;])
                    ),
                ),
                name=&#39;Closed - Profit&#39;,
                customdata=np.stack((_id[closed_profit_mask], returns[closed_profit_mask]), axis=1),
                hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                        &#34;&lt;br&gt;Date: %{x}&#34;
                                        &#34;&lt;br&gt;PnL: %{y}&#34;
                                        &#34;&lt;br&gt;Return: %{customdata[1]:.2%}&#34;
            )
            profit_scatter.update(**closed_profit_trace_kwargs)
            fig.add_trace(profit_scatter, row=row, col=col)

        if np.any(closed_loss_mask):
            # Plot Loss markers
            loss_scatter = go.Scatter(
                x=self_col.wrapper.index[exit_idx[closed_loss_mask]],
                y=pnl[closed_loss_mask],
                mode=&#39;markers&#39;,
                marker=dict(
                    symbol=&#39;circle&#39;,
                    color=contrast_color_schema[&#39;red&#39;],
                    size=marker_size[closed_loss_mask],
                    opacity=opacity[closed_loss_mask],
                    line=dict(
                        width=1,
                        color=adjust_lightness(contrast_color_schema[&#39;red&#39;])
                    )
                ),
                name=&#39;Closed - Loss&#39;,
                customdata=np.stack((_id[closed_loss_mask], returns[closed_loss_mask]), axis=1),
                hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                        &#34;&lt;br&gt;Date: %{x}&#34;
                                        &#34;&lt;br&gt;PnL: %{y}&#34;
                                        &#34;&lt;br&gt;Return: %{customdata[1]:.2%}&#34;
            )
            loss_scatter.update(**closed_loss_trace_kwargs)
            fig.add_trace(loss_scatter, row=row, col=col)

        if np.any(open_mask):
            # Plot Active markers
            active_scatter = go.Scatter(
                x=self_col.wrapper.index[exit_idx[open_mask]],
                y=pnl[open_mask],
                mode=&#39;markers&#39;,
                marker=dict(
                    symbol=&#39;circle&#39;,
                    color=contrast_color_schema[&#39;orange&#39;],
                    size=marker_size[open_mask],
                    opacity=opacity[open_mask],
                    line=dict(
                        width=1,
                        color=adjust_lightness(contrast_color_schema[&#39;orange&#39;])
                    )
                ),
                name=&#39;Open&#39;,
                customdata=np.stack((_id[open_mask], returns[open_mask]), axis=1),
                hovertemplate=_id_str + &#34;: %{customdata[0]}&#34;
                                        &#34;&lt;br&gt;Date: %{x}&#34;
                                        &#34;&lt;br&gt;PnL: %{y}&#34;
                                        &#34;&lt;br&gt;Return: %{customdata[1]:.2%}&#34;
            )
            active_scatter.update(**open_trace_kwargs)
            fig.add_trace(active_scatter, row=row, col=col)

    # Plot zeroline
    fig.add_shape(**merge_dicts(dict(
        type=&#39;line&#39;,
        xref=&#34;paper&#34;,
        yref=yref,
        x0=x_domain[0],
        y0=0,
        x1=x_domain[1],
        y1=0,
        line=dict(
            color=&#34;gray&#34;,
            dash=&#34;dash&#34;,
        )
    ), hline_shape_kwargs))
    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.profit_factor"><code class="name flex">
<span>def <span class="ident fname">profit_factor</span></span>(<span>self, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Profit factor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def profit_factor(self, group_by=None, **kwargs):
    &#34;&#34;&#34;Profit factor.&#34;&#34;&#34;
    total_win = to_1d(self.winning.pnl.sum(group_by=group_by), raw=True)
    total_loss = to_1d(self.losing.pnl.sum(group_by=group_by), raw=True)

    # Otherwise columns with only wins or losses will become NaNs
    has_values = to_1d(self.count(group_by=group_by), raw=True) &gt; 0
    total_win[np.isnan(total_win) &amp; has_values] = 0.
    total_loss[np.isnan(total_loss) &amp; has_values] = 0.

    profit_factor = total_win / np.abs(total_loss)
    return self.wrapper.wrap_reduced(profit_factor, group_by=group_by, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.short_rate"><code class="name flex">
<span>def <span class="ident fname">short_rate</span></span>(<span>self, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Rate of short trades.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def short_rate(self, group_by=None, **kwargs):
    &#34;&#34;&#34;Rate of short trades.&#34;&#34;&#34;
    short_count = to_1d(self.short.count(group_by=group_by), raw=True)
    total_count = to_1d(self.count(group_by=group_by), raw=True)
    return self.wrapper.wrap_reduced(short_count / total_count, group_by=group_by, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.sqn"><code class="name flex">
<span>def <span class="ident fname">sqn</span></span>(<span>self, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>System Quality Number (SQN).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def sqn(self, group_by=None, **kwargs):
    &#34;&#34;&#34;System Quality Number (SQN).&#34;&#34;&#34;
    count = to_1d(self.count(group_by=group_by), raw=True)
    pnl_mean = to_1d(self.pnl.mean(group_by=group_by), raw=True)
    pnl_std = to_1d(self.pnl.std(group_by=group_by), raw=True)
    sqn = np.sqrt(count) * pnl_mean / pnl_std
    return self.wrapper.wrap_reduced(sqn, group_by=group_by, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.trades.Trades.win_rate"><code class="name flex">
<span>def <span class="ident fname">win_rate</span></span>(<span>self, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Rate of winning trades.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def win_rate(self, group_by=None, **kwargs):
    &#34;&#34;&#34;Rate of winning trades.&#34;&#34;&#34;
    win_count = to_1d(self.winning.count(group_by=group_by), raw=True)
    total_count = to_1d(self.count(group_by=group_by), raw=True)
    return self.wrapper.wrap_reduced(win_count / total_count, group_by=group_by, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.records.base.Records" href="../records/base.html#vectorbt.records.base.Records">Records</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.records.base.Records.col_mapper" href="../records/base.html#vectorbt.records.base.Records.col_mapper">col_mapper</a></code></li>
<li><code><a title="vectorbt.records.base.Records.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.records.base.Records.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.records.base.Records.count" href="../records/base.html#vectorbt.records.base.Records.count">count</a></code></li>
<li><code><a title="vectorbt.records.base.Records.filter_by_mask" href="../records/base.html#vectorbt.records.base.Records.filter_by_mask">filter_by_mask</a></code></li>
<li><code><a title="vectorbt.records.base.Records.idx_field" href="../records/base.html#vectorbt.records.base.Records.idx_field">idx_field</a></code></li>
<li><code><a title="vectorbt.records.base.Records.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.records.base.Records.is_sorted" href="../records/base.html#vectorbt.records.base.Records.is_sorted">is_sorted</a></code></li>
<li><code><a title="vectorbt.records.base.Records.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map" href="../records/base.html#vectorbt.records.base.Records.map">map</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map_array" href="../records/base.html#vectorbt.records.base.Records.map_array">map_array</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map_field" href="../records/base.html#vectorbt.records.base.Records.map_field">map_field</a></code></li>
<li><code><a title="vectorbt.records.base.Records.records" href="../records/base.html#vectorbt.records.base.Records.records">records</a></code></li>
<li><code><a title="vectorbt.records.base.Records.records_arr" href="../records/base.html#vectorbt.records.base.Records.records_arr">records_arr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.records.base.Records.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.records.base.Records.sort" href="../records/base.html#vectorbt.records.base.Records.sort">sort</a></code></li>
<li><code><a title="vectorbt.records.base.Records.values" href="../records/base.html#vectorbt.records.base.Records.values">values</a></code></li>
<li><code><a title="vectorbt.records.base.Records.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.records.base.Records.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAACXBIWXMAACcQAAAnEAGUaVEZAAAGuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDggNzkuMTY0MDM2LCAyMDE5LzA4LzEzLTAxOjA2OjU3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjEuMCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjAtMDYtMjVUMjM6MzU6MTMrMDI6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjAtMDYtMjZUMTQ6MTA6MzgrMDI6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIwLTA2LTI2VDE0OjEwOjM4KzAyOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNzE0MGFiYi05Mjk1LTQ3MDYtYTNhZi1lMDg2OTFkOTk3NjQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NzZmN2Y4NjAtMThmMi00ZDgxLTg5NjUtNDU5ZjY1NDY2ZGZlIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NzZmN2Y4NjAtMThmMi00ZDgxLTg5NjUtNDU5ZjY1NDY2ZGZlIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjc2ZjdmODYwLTE4ZjItNGQ4MS04OTY1LTQ1OWY2NTQ2NmRmZSIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNVQyMzozNToxMyswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2NjI2MGIzLTY0ZmUtNGJiYy1iMTNiLWZkMDU3NDI3NjIyNCIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNlQxMzoyMTo1NSswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjA3MTQwYWJiLTkyOTUtNDcwNi1hM2FmLWUwODY5MWQ5OTc2NCIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNlQxNDoxMDozOCswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Qc/+aQAAAa5JREFUeJzt3cFJA0EYgFEjgj3FGmIjsQexByuxB4vy5kHwELJhCRPekP3eMYdl4Ms/y84Gstsfjg9xHvUCtq4AWAGwAmAFwAqAFQArAFYArABYAbACYAXACoAVACsAVgCsAFgBsAJgBcAKgBUAexp1oe+vz7Ofv7y+dZ0LmgCsAFgBsAJgBcAKgBUAKwBWAKwAWAGwAmAFwAqAFQAb9j5glFHn7KPcej1NAFYAzG9BP+/n3/ld9vwx1051tSYA8xPwZ/03+rqJmVYTgBUAm2UL+re0w6i7br8LunMFwAqAFQArAFYArADYdM8Bd3PKtlITgBUAm2ULurMzzvWaAMxPwNbuuieaAKwAmN+CTtz6/H02TQBWAKwAWAGwAmAFwAqAFQArAFYArABYAbACYAXACoANex8w23n9bOtZ0gRgBcAKgBUAKwBWAKwA2HT/HzDKbOtZ0gRgBcAKgBUAKwBWAKwAWAGwAmAFwAqAFQArAFYArADYbn846jVsWhOAFQArAFYArABYAbACYAXACoAVACsAVgCsAFgBsAJgBcAKgBUAKwBWAKwAWAGwAmC/7uUrwcQVST8AAAAASUVORK5CYII="/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.portfolio" href="index.html">vectorbt.portfolio</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.portfolio.trades.Positions" href="#vectorbt.portfolio.trades.Positions">Positions</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.portfolio.trades.Positions.coverage" href="#vectorbt.portfolio.trades.Positions.coverage">coverage</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Positions.from_trades" href="#vectorbt.portfolio.trades.Positions.from_trades">from_trades</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.portfolio.trades.Trades" href="#vectorbt.portfolio.trades.Trades">Trades</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.portfolio.trades.Trades.close" href="#vectorbt.portfolio.trades.Trades.close">close</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.closed" href="#vectorbt.portfolio.trades.Trades.closed">closed</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.closed_rate" href="#vectorbt.portfolio.trades.Trades.closed_rate">closed_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.direction" href="#vectorbt.portfolio.trades.Trades.direction">direction</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.duration" href="#vectorbt.portfolio.trades.Trades.duration">duration</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.expectancy" href="#vectorbt.portfolio.trades.Trades.expectancy">expectancy</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.from_orders" href="#vectorbt.portfolio.trades.Trades.from_orders">from_orders</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.long" href="#vectorbt.portfolio.trades.Trades.long">long</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.long_rate" href="#vectorbt.portfolio.trades.Trades.long_rate">long_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.losing" href="#vectorbt.portfolio.trades.Trades.losing">losing</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.loss_rate" href="#vectorbt.portfolio.trades.Trades.loss_rate">loss_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.open" href="#vectorbt.portfolio.trades.Trades.open">open</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.open_rate" href="#vectorbt.portfolio.trades.Trades.open_rate">open_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.plot" href="#vectorbt.portfolio.trades.Trades.plot">plot</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.plot_pnl" href="#vectorbt.portfolio.trades.Trades.plot_pnl">plot_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.pnl" href="#vectorbt.portfolio.trades.Trades.pnl">pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.profit_factor" href="#vectorbt.portfolio.trades.Trades.profit_factor">profit_factor</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.records_readable" href="#vectorbt.portfolio.trades.Trades.records_readable">records_readable</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.returns" href="#vectorbt.portfolio.trades.Trades.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.short" href="#vectorbt.portfolio.trades.Trades.short">short</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.short_rate" href="#vectorbt.portfolio.trades.Trades.short_rate">short_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.sqn" href="#vectorbt.portfolio.trades.Trades.sqn">sqn</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.status" href="#vectorbt.portfolio.trades.Trades.status">status</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.trade_type" href="#vectorbt.portfolio.trades.Trades.trade_type">trade_type</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.win_rate" href="#vectorbt.portfolio.trades.Trades.win_rate">win_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.trades.Trades.winning" href="#vectorbt.portfolio.trades.Trades.winning">winning</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>