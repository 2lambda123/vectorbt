<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.portfolio.nb API documentation</title>
<meta name="description" content="Numba-compiled 1-dim and 2-dim functions â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://github.com/polakowo/vectorbt/blob/master/logo.png?raw=true">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.portfolio.nb</code></h1>
</header>
<section id="section-intro">
<p>Numba-compiled 1-dim and 2-dim functions.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code><a title="vectorbt" href="../index.html">vectorbt</a></code> treats matrices as first-class citizens and expects input arrays to be
2-dim, unless function has suffix <code>_1d</code> or is meant to be input to another function.
Data is processed along index (axis 0).</p>
<p>All functions passed as argument must be Numba-compiled.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Numba-compiled 1-dim and 2-dim functions.

!!! note
    `vectorbt` treats matrices as first-class citizens and expects input arrays to be
    2-dim, unless function has suffix `_1d` or is meant to be input to another function. 
    Data is processed along index (axis 0).
    
    All functions passed as argument must be Numba-compiled.&#34;&#34;&#34;

import numpy as np
from numba import njit, b1, i1, i8, f8
from numba.core.types import UniTuple

from vectorbt import timeseries
from vectorbt.portfolio.enums import (
    Order,
    OrderSide,
    FilledOrder,
    OrderRecord,
    EventRecord,
    TradeRecord,
    PositionStatus,
    PositionRecord
)

# ############# Simulation ############# #


@njit(cache=True)
def buy_nb(run_cash, run_shares, order):
    &#34;&#34;&#34;Perform a Buy.

    Returns an updated cash and shares balance, the number of shares bought, 
    the price adjusted with slippage, and fees paid.&#34;&#34;&#34;

    # Compute cash required to complete this order
    adj_price = order.price * (1 + order.slippage)
    req_cash = order.size * adj_price
    adj_req_cash = req_cash * (1 + order.fees) + order.fixed_fees

    if adj_req_cash &lt;= run_cash:
        # Sufficient cash
        adj_size = order.size
        fees_paid = adj_req_cash - req_cash
    else:
        # Insufficient cash, size will be less than requested
        # For fees of 10%, you can buy shares for 90.9$ (adj_cash) to spend 100$ (run_cash) in total
        adj_cash = (run_cash - order.fixed_fees) / (1 + order.fees)

        # Update size and fees
        adj_size = adj_cash / adj_price
        fees_paid = run_cash - adj_cash

    if adj_size &gt; 0.:
        # Update current cash and shares
        run_cash -= adj_size * adj_price + fees_paid
        run_shares += adj_size
        return run_cash, run_shares, FilledOrder(adj_size, adj_price, fees_paid, OrderSide.Buy)
    return run_cash, run_shares, None


@njit(cache=True)
def sell_nb(run_cash, run_shares, order):
    &#34;&#34;&#34;Perform a Sell.

    Returns an updated cash and shares balance, the number of shares sold, 
    the price adjusted with slippage, and fees paid.&#34;&#34;&#34;

    # Compute acquired cash
    adj_price = order.price * (1 - order.slippage)
    adj_size = min(run_shares, abs(order.size))
    cash = adj_size * adj_price

    # Minus costs
    adj_cash = cash * (1 - order.fees) - order.fixed_fees

    # Update fees
    fees_paid = cash - adj_cash

    if adj_size &gt; 0.:
        # Update current cash and shares
        run_cash += adj_size * adj_price - fees_paid
        run_shares -= adj_size
        return run_cash, run_shares, FilledOrder(adj_size, adj_price, fees_paid, OrderSide.Sell)
    return run_cash, run_shares, None


@njit(cache=True)
def fill_order_nb(run_cash, run_shares, order):
    &#34;&#34;&#34;Fill an order.&#34;&#34;&#34;
    if order is not None:
        if order.size &gt; 0.:
            return buy_nb(run_cash, run_shares, order)
        if order.size &lt; 0.:
            return sell_nb(run_cash, run_shares, order)
    return run_cash, run_shares, None


@njit
def simulate_nb(target_shape, init_capital, order_func_nb, *args):
    &#34;&#34;&#34;Simulate a portfolio by generating and filling orders.

    Starting with initial capital `init_capital`, iterates over shape `target_shape`, 
    and for each data point, generates an order using `order_func_nb`. Tries then to 
    fulfill that order. If unsuccessful due to insufficient cash/shares, always orders 
    the available fraction. Updates then the current cash and shares balance.

    Returns order records of layout `vectorbt.portfolio.enums.OrderRecord`, but also 
    cash and shares as time series.

    `order_func_nb` must accept index of the current column `col`, the time step `i`,
    the amount of cash `run_cash` and shares `run_shares` held at the time step `i`, and `*args`.
    Must either return an `vectorbt.portfolio.enums.Order` tuple or `None` to do nothing.

    !!! warning
        In some cases, passing large arrays as `*args` can negatively impact performance. What can help
        is accessing arrays from `order_func_nb` as non-local variables as we do in the example below.

    Example:
        Simulate a basic buy-and-hold strategy:
        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from numba import njit
        &gt;&gt;&gt; from vectorbt.portfolio.nb import simulate_nb
        &gt;&gt;&gt; from vectorbt.portfolio.enums import Order, OrderRecord

        &gt;&gt;&gt; price = np.asarray([
        ...     [1, 5, 1],
        ...     [2, 4, 2],
        ...     [3, 3, 3],
        ...     [4, 2, 2],
        ...     [5, 1, 1]
        ... ])
        &gt;&gt;&gt; fees = 0.001
        &gt;&gt;&gt; fixed_fees = 1
        &gt;&gt;&gt; slippage = 0.001
        &gt;&gt;&gt; @njit
        ... def order_func_nb(col, i, run_cash, run_shares):
        ...     return Order(np.inf if i == 0 else 0, price[i, col], 
        ...         fees=fees, fixed_fees=fixed_fees, slippage=slippage)
        &gt;&gt;&gt; order_records, cash, shares = simulate_nb(price.shape, 100, order_func_nb)

        &gt;&gt;&gt; print(pd.DataFrame(order_records, columns=OrderRecord._fields))
        [[ 0.   0.   98.8022966   1.001   1.0989011   0.   ]
         [ 1.   0.   19.76045932  5.005   1.0989011   0.   ]
         [ 2.   0.   98.8022966   1.001   1.0989011   0.   ]]
        &gt;&gt;&gt; print(cash)
        [[0. 0. 0.]
         [0. 0. 0.]
         [0. 0. 0.]
         [0. 0. 0.]
         [0. 0. 0.]]
        &gt;&gt;&gt; print(shares)
        [[98.8022966  19.76045932 98.8022966 ]
         [98.8022966  19.76045932 98.8022966 ]
         [98.8022966  19.76045932 98.8022966 ]
         [98.8022966  19.76045932 98.8022966 ]
         [98.8022966  19.76045932 98.8022966 ]]
        ```
    &#34;&#34;&#34;
    order_records = np.empty((target_shape[0] * target_shape[1], len(OrderRecord)), dtype=f8)
    j = 0
    cash = np.empty(target_shape, dtype=f8)
    shares = np.empty(target_shape, dtype=f8)

    for col in range(target_shape[1]):
        run_cash = init_capital
        run_shares = 0.

        for i in range(target_shape[0]):
            # Generate the next oder or None to do nothing
            order = order_func_nb(col, i, run_cash, run_shares, *args)
            # Fill the order
            run_cash, run_shares, filled_order = fill_order_nb(run_cash, run_shares, order)

            # Add a new record
            if filled_order is not None:
                order_records[j, OrderRecord.Column] = col
                order_records[j, OrderRecord.Index] = i
                order_records[j, OrderRecord.Size] = filled_order.size
                order_records[j, OrderRecord.Price] = filled_order.price
                order_records[j, OrderRecord.Fees] = filled_order.fees
                order_records[j, OrderRecord.Side] = filled_order.side
                j += 1

            # Populate cash and shares
            cash[i, col], shares[i, col] = run_cash, run_shares

    return order_records[:j, :], cash, shares


@njit(cache=True)
def simulate_from_signals_nb(target_shape, init_capital, entries, exits, size, entry_price,
                             exit_price, fees, fixed_fees, slippage, accumulate):
    &#34;&#34;&#34;Adaptation of `simulate_nb` for simulation based on entry and exit signals.&#34;&#34;&#34;
    order_records = np.empty((target_shape[0] * target_shape[1], len(OrderRecord)), dtype=f8)
    j = 0
    cash = np.empty(target_shape, dtype=f8)
    shares = np.empty(target_shape, dtype=f8)

    for col in range(target_shape[1]):
        run_cash = init_capital
        run_shares = 0.

        for i in range(target_shape[0]):
            # Generate the next oder or None to do nothing
            if entries[i, col] or exits[i, col]:
                order = signals_order_func_nb(
                    run_shares,
                    entries[i, col],
                    exits[i, col],
                    size[i, col],
                    entry_price[i, col],
                    exit_price[i, col],
                    fees[i, col],
                    fixed_fees[i, col],
                    slippage[i, col],
                    accumulate)
                # Fill the order
                run_cash, run_shares, filled_order = fill_order_nb(run_cash, run_shares, order)

                # Add a new record
                if filled_order is not None:
                    order_records[j, OrderRecord.Column] = col
                    order_records[j, OrderRecord.Index] = i
                    order_records[j, OrderRecord.Size] = filled_order.size
                    order_records[j, OrderRecord.Price] = filled_order.price
                    order_records[j, OrderRecord.Fees] = filled_order.fees
                    order_records[j, OrderRecord.Side] = filled_order.side
                    j += 1

            # Populate cash and shares
            cash[i, col], shares[i, col] = run_cash, run_shares

    return order_records[:j, :], cash, shares


@njit(cache=True)
def signals_order_func_nb(run_shares, entries, exits, size, entry_price,
                          exit_price, fees, fixed_fees, slippage, accumulate):
    &#34;&#34;&#34;`order_func_nb` of `simulate_from_signals_nb`.&#34;&#34;&#34;
    if entries and not exits:
        # Buy the amount of shares specified in size (only once if not accumulate)
        if run_shares == 0. or accumulate:
            order_size = abs(size)
            order_price = entry_price
        else:
            return None
    elif not entries and exits:
        # Sell everything
        if run_shares &gt; 0.:
            order_size = -np.inf
            order_price = exit_price
        else:
            return None
    elif entries and exits:
        # Buy the difference between entry and exit size
        order_size = abs(size) - run_shares
        if order_size &gt; 0:
            order_price = entry_price
        elif order_size &lt; 0:
            order_price = exit_price
        else:
            return None
    return Order(
        order_size,
        order_price,
        fees=fees,
        fixed_fees=fixed_fees,
        slippage=slippage)


@njit(cache=True)
def simulate_from_orders_nb(target_shape, init_capital, size, price, fees, fixed_fees, slippage, is_target):
    &#34;&#34;&#34;Adaptation of `simulate_nb` for simulation based on orders.&#34;&#34;&#34;
    order_records = np.empty((target_shape[0] * target_shape[1], len(OrderRecord)), dtype=f8)
    j = 0
    cash = np.empty(target_shape, dtype=f8)
    shares = np.empty(target_shape, dtype=f8)

    for col in range(target_shape[1]):
        run_cash = init_capital
        run_shares = 0.

        for i in range(target_shape[0]):
            # Generate the next oder or None to do nothing
            order = size_order_func_nb(
                run_shares,
                size[i, col],
                price[i, col],
                fees[i, col],
                fixed_fees[i, col],
                slippage[i, col],
                is_target)
            # Fill the order
            run_cash, run_shares, filled_order = fill_order_nb(run_cash, run_shares, order)

            # Add a new record
            if filled_order is not None:
                order_records[j, OrderRecord.Column] = col
                order_records[j, OrderRecord.Index] = i
                order_records[j, OrderRecord.Size] = filled_order.size
                order_records[j, OrderRecord.Price] = filled_order.price
                order_records[j, OrderRecord.Fees] = filled_order.fees
                order_records[j, OrderRecord.Side] = filled_order.side
                j += 1

            # Populate cash and shares
            cash[i, col], shares[i, col] = run_cash, run_shares

    return order_records[:j, :], cash, shares


@njit(cache=True)
def size_order_func_nb(run_shares, size, price, fees, fixed_fees, slippage, is_target):
    &#34;&#34;&#34;`order_func_nb` of `simulate_from_orders_nb`.&#34;&#34;&#34;
    if is_target:
        order_size = size - run_shares
    else:
        order_size = size
    return Order(
        order_size,
        price,
        fees=fees,
        fixed_fees=fixed_fees,
        slippage=slippage)

# ############# Trades ############# #


@njit(cache=True)
def trade_records_nb(price, order_records):
    &#34;&#34;&#34;Find trades and store their information as records to an array.

    One position can have multiple trades. A trade in this regard is just a sell operation.
    Performance for this operation is calculated based on the size weighted average of 
    previous buy operations in the same position.

    Example:
        Build an array with trade information:
        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from numba import njit
        &gt;&gt;&gt; from vectorbt.portfolio.nb import simulate_nb, trade_records_nb
        &gt;&gt;&gt; from vectorbt.portfolio.enums import Order, TradeRecord

        &gt;&gt;&gt; order_price = price = np.arange(1, 6)[:, None]
        &gt;&gt;&gt; order_size = np.asarray([1, -1, 1, -1, 1])[:, None]

        &gt;&gt;&gt; @njit
        ... def order_func_nb(col, i, run_cash, run_shares):
        ...     return Order(order_size[i, col], order_price[i, col], 
        ...          fees=0.01, slippage=0., fixed_fees=0.)
        &gt;&gt;&gt; order_records, cash, shares = simulate_nb(price.shape, 100, order_func_nb)
        &gt;&gt;&gt; records = trade_records_nb(price, order_records)

        &gt;&gt;&gt; print(pd.DataFrame(records, columns=TradeRecord._fields)) 
           Column  Size  OpenAt  OpenPrice  OpenFees  CloseAt  ClosePrice  CloseFees  \\
        0     0.0   1.0     0.0        1.0      0.01      1.0         2.0       0.02   
        1     0.0   1.0     2.0        3.0      0.03      3.0         4.0       0.04   

            PnL    Return  Position  
        0  0.97  0.960396       0.0  
        1  0.93  0.306931       1.0  
        ```&#34;&#34;&#34;
    result = np.empty((price.shape[0] * price.shape[1], len(TradeRecord)), dtype=f8)
    position_idx = -1
    j = 0
    prev_col = -1

    for r in range(order_records.shape[0]):
        record = order_records[r]
        i = int(record[OrderRecord.Index])
        col = int(record[OrderRecord.Column])
        order_size = record[OrderRecord.Size]
        order_price = record[OrderRecord.Price]
        order_fees = record[OrderRecord.Fees]
        order_side = record[OrderRecord.Side]

        if col != prev_col:
            # Column has changed
            prev_col = col
            buy_size_sum = 0.
            buy_gross_sum = 0.
            buy_fees_sum = 0.

        if order_side == OrderSide.Buy:
            # Buy operation
            if buy_size_sum == 0.:
                position_start = i
                position_idx += 1

            # Position increased
            buy_size_sum += order_size
            buy_gross_sum += order_size * order_price
            buy_fees_sum += order_fees

        elif order_side == OrderSide.Sell:
            # Sell operation
            # Close the current trade
            # Opening price is the size-weighted average over all purchase prices
            avg_buy_price = buy_gross_sum / buy_size_sum
            # Opening fees are the size-weighted average over all purchase fees
            frac_buy_fees = order_size / buy_size_sum * buy_fees_sum
            # Calculate PnL and return
            buy_val = order_size * avg_buy_price + frac_buy_fees
            sell_val = order_size * order_price - order_fees
            pnl = sell_val - buy_val
            ret = (sell_val - buy_val) / buy_val

            # Save the trade to the records
            result[j, TradeRecord.Column] = col
            result[j, TradeRecord.Size] = order_size
            result[j, TradeRecord.OpenAt] = position_start
            result[j, TradeRecord.OpenPrice] = avg_buy_price
            result[j, TradeRecord.OpenFees] = frac_buy_fees
            result[j, TradeRecord.CloseAt] = i
            result[j, TradeRecord.ClosePrice] = order_price
            result[j, TradeRecord.CloseFees] = order_fees
            result[j, TradeRecord.PnL] = pnl
            result[j, TradeRecord.Return] = ret
            result[j, TradeRecord.Position] = position_idx
            j += 1

            # Position decreased, previous purchases have now less impact
            size_fraction = (buy_size_sum - order_size) / buy_size_sum
            buy_size_sum *= size_fraction
            buy_gross_sum *= size_fraction
            buy_fees_sum *= size_fraction
    return result[:j, :]

# ############# Positions ############# #


@njit(cache=True)
def position_records_nb(price, order_records):
    &#34;&#34;&#34;Find positions and store their information as records to an array.

    Example:
        Build an array with trade information:
        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from numba import njit
        &gt;&gt;&gt; from vectorbt.portfolio.nb import simulate_nb, position_records_nb
        &gt;&gt;&gt; from vectorbt.portfolio.enums import Order, PositionRecord

        &gt;&gt;&gt; order_price = price = np.arange(1, 6)[:, None]
        &gt;&gt;&gt; order_size = np.asarray([1, -1, 1, -1, 1])[:, None]

        &gt;&gt;&gt; @njit
        ... def order_func_nb(col, i, run_cash, run_shares):
        ...     return Order(order_size[i, col], order_price[i, col], 
        ...          fees=0.01, slippage=0., fixed_fees=0.)
        &gt;&gt;&gt; order_records, cash, shares = simulate_nb(price.shape, 100, order_func_nb)
        &gt;&gt;&gt; records = position_records_nb(price, order_records)

        &gt;&gt;&gt; print(pd.DataFrame(records, columns=PositionRecord._fields)) 
           Column  Size  OpenAt  OpenPrice  OpenFees  CloseAt  ClosePrice  CloseFees  \
        0     0.0   1.0     0.0        1.0      0.01      1.0         2.0       0.02   
        1     0.0   1.0     2.0        3.0      0.03      3.0         4.0       0.04   
        2     0.0   1.0     4.0        5.0      0.05      4.0         5.0       0.00   

            PnL    Return  Status  
        0  0.97  0.960396     1.0  
        1  0.93  0.306931     1.0  
        2 -0.05 -0.009901     0.0  
        ```&#34;&#34;&#34;
    result = np.empty((price.shape[0] * price.shape[1], len(PositionRecord)), dtype=f8)
    j = 0
    prev_col = -1

    for r in range(order_records.shape[0]):
        record = order_records[r]
        i = int(record[OrderRecord.Index])
        col = int(record[OrderRecord.Column])
        order_size = record[OrderRecord.Size]
        order_price = record[OrderRecord.Price]
        order_fees = record[OrderRecord.Fees]
        order_side = record[OrderRecord.Side]

        if col != prev_col:
            # Column has changed
            prev_col = col
            buy_size_sum = 0.
            buy_gross_sum = 0.
            buy_fees_sum = 0.
            sell_size_sum = 0.
            sell_gross_sum = 0.
            sell_fees_sum = 0.
            store_position = False

        if order_side == OrderSide.Buy:
            # Position increased
            if buy_size_sum == 0.:
                position_start = i

            buy_size_sum += order_size
            buy_gross_sum += order_size * order_price
            buy_fees_sum += order_fees

        elif order_side == OrderSide.Sell:
            # Position decreased
            sell_size_sum += order_size
            sell_gross_sum += order_size * order_price
            sell_fees_sum += order_fees

        if buy_size_sum == sell_size_sum:
            # Closed position
            status = PositionStatus.Closed
            store_position = True

        if i == price.shape[0] - 1 and buy_size_sum &gt; sell_size_sum:
            # If position hasn&#39;t been closed, calculate its unrealized metrics
            sell_size_sum += buy_size_sum
            sell_gross_sum += buy_size_sum * price[i, col]
            # NOTE: We have no information about fees here, so we don&#39;t add them
            status = PositionStatus.Open
            store_position = True

        if store_position:
            # Calculate PnL and return
            avg_buy_price = buy_gross_sum / buy_size_sum
            avg_sell_price = sell_gross_sum / sell_size_sum
            buy_val = buy_size_sum * avg_buy_price + buy_fees_sum
            sell_val = buy_size_sum * avg_sell_price - sell_fees_sum
            pnl = sell_val - buy_val
            ret = (sell_val - buy_val) / buy_val

            # Save position to the records
            result[j, PositionRecord.Column] = col
            result[j, PositionRecord.Size] = buy_size_sum
            result[j, PositionRecord.OpenAt] = position_start
            result[j, PositionRecord.OpenPrice] = avg_buy_price
            result[j, PositionRecord.OpenFees] = buy_fees_sum
            result[j, PositionRecord.CloseAt] = i
            result[j, PositionRecord.ClosePrice] = avg_sell_price
            result[j, PositionRecord.CloseFees] = sell_fees_sum
            result[j, PositionRecord.PnL] = pnl
            result[j, PositionRecord.Return] = ret
            result[j, PositionRecord.Status] = status
            j += 1

            # Reset running vars for a new position
            buy_size_sum = 0.
            buy_gross_sum = 0.
            buy_fees_sum = 0.
            sell_size_sum = 0.
            sell_gross_sum = 0.
            sell_fees_sum = 0.
            store_position = False
    return result[:j, :]


# ############# Mapping to matrix ############# #

@njit
def map_records_to_matrix_nb(records, target_shape, col_field, row_field, map_func_nb, *args):
    &#34;&#34;&#34;Map each record to a value that is then stored in a matrix.

    Maps each record to a value at `(row_field, col_field)`.

    `map_func_nb` must accept a single record and `*args`, and return a single value.&#34;&#34;&#34;
    result = np.full(target_shape, np.nan, dtype=f8)
    for i in range(records.shape[0]):
        record = records[i, :]
        col = int(record[col_field])
        i = int(record[row_field])
        result[i, col] = map_func_nb(record, *args)
    return result


@njit(cache=True)
def field_map_func_nb(record, field):
    &#34;&#34;&#34;`map_func_nb` that returns the specified field of the record.&#34;&#34;&#34;
    return record[field]


@njit(cache=True)
def duration_map_func_nb(record):
    &#34;&#34;&#34;`map_func_nb` that returns duration of the event.

    Record must have layout of `vectorbt.portfolio.enums.EventRecord`.&#34;&#34;&#34;
    return record[EventRecord.CloseAt] - record[EventRecord.OpenAt]


# ############# Reducing ############# #


@njit
def reduce_records_nb(records, n_cols, col_field, reduce_func_nb, *args):
    &#34;&#34;&#34;Perform a reducing operation over the records of each column.

    Faster than `map_records_to_matrix_nb` and `vbt.timeseries.*` used together, and also
    requires less memory. But does not take advantage of caching.

    `reduce_func_nb` must accept an array of records and `*args`, and return a single value.

    !!! note
        Records must be in the order they were created.&#34;&#34;&#34;
    result = np.full(n_cols, np.nan, dtype=f8)
    from_i = 0
    col = -1
    for i in range(records.shape[0]):
        record_col = int(records[i, col_field])
        if record_col != col:
            if col != -1:
                # At the beginning of second column do reduce on the first
                result[col] = reduce_func_nb(records[from_i:i, :], *args)
            from_i = i
            col = record_col
        if i == len(records) - 1:
            result[col] = reduce_func_nb(records[from_i:i+1, :], *args)
    return result


@njit(cache=True)
def count_reduce_func_nb(records):
    &#34;&#34;&#34;`reduce_func_nb` that returns the number of records.&#34;&#34;&#34;
    return len(records)

# ############# Financial risk and performance metrics ############# #


@njit(cache=True)
def total_return_apply_func_nb(col, idxs, returns):
    &#34;&#34;&#34;Calculate total return from returns.&#34;&#34;&#34;
    return timeseries.nb.product_1d_nb(returns + 1) - 1

# Functions from empyrical but Numba-compiled


@njit(cache=True)
def cum_returns_1d_nb(returns, starting_value=0):
    &#34;&#34;&#34;See `empyrical.cum_returns`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 1:
        return returns.copy()

    result = timeseries.nb.cumprod_1d_nb(returns + 1)
    if starting_value == 0:
        result -= 1
    else:
        result *= starting_value
    return result


@njit(cache=True)
def cum_returns_nb(returns, starting_value=0):
    &#34;&#34;&#34;2-dim version of `cum_returns_1d_nb`.&#34;&#34;&#34;
    result = np.empty_like(returns, dtype=f8)
    for col in range(returns.shape[1]):
        result[:, col] = cum_returns_1d_nb(returns[:, col], starting_value=starting_value)
    return result


@njit(cache=True)
def cum_returns_final_1d_nb(returns, starting_value=0):
    &#34;&#34;&#34;See `empyrical.cum_returns_final`.&#34;&#34;&#34;
    if returns.shape[0] == 0:
        return np.nan

    result = timeseries.nb.product_1d_nb(returns + 1)
    if starting_value == 0:
        result -= 1
    else:
        result *= starting_value
    return result


@njit(cache=True)
def cum_returns_final_nb(returns, starting_value=0):
    &#34;&#34;&#34;2-dim version of `cum_returns_final_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = cum_returns_final_1d_nb(returns[:, col], starting_value=starting_value)
    return result


@njit(cache=True)
def annualized_return_1d_nb(returns, ann_factor):
    &#34;&#34;&#34;See `empyrical.annual_return`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 1:
        return np.nan

    ending_value = cum_returns_final_1d_nb(returns, starting_value=1)
    return ending_value ** (ann_factor / returns.shape[0]) - 1


@njit(cache=True)
def annualized_return_nb(returns, ann_factor):
    &#34;&#34;&#34;2-dim version of `annualized_return_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = annualized_return_1d_nb(returns[:, col], ann_factor)
    return result


@njit(cache=True)
def annualized_volatility_1d_nb(returns, ann_factor, alpha=2.0):
    &#34;&#34;&#34;See `empyrical.annual_volatility`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 2:
        return np.nan

    return timeseries.nb.nanstd_1d_nb(returns, ddof=1) * ann_factor ** (1.0 / alpha)


@njit(cache=True)
def annualized_volatility_nb(returns, ann_factor, alpha=2.0):
    &#34;&#34;&#34;2-dim version of `annualized_volatility_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = annualized_volatility_1d_nb(returns[:, col], ann_factor, alpha=alpha)
    return result


@njit(cache=True)
def calmar_ratio_1d_nb(returns, annualized_return, max_drawdown, ann_factor):
    &#34;&#34;&#34;See `empyrical.calmar_ratio`.&#34;&#34;&#34;
    if max_drawdown == 0.:
        return np.nan
    return annualized_return / np.abs(max_drawdown)


@njit(cache=True)
def calmar_ratio_nb(returns, annualized_return, max_drawdown, ann_factor):
    &#34;&#34;&#34;2-dim version of `calmar_ratio_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = calmar_ratio_1d_nb(returns[:, col], annualized_return[col], max_drawdown[col], ann_factor)
    return result


@njit(cache=True)
def omega_ratio_1d_nb(returns, ann_factor, risk_free=0., required_return=0.):
    &#34;&#34;&#34;See `empyrical.omega_ratio`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 1:
        return np.nan

    if ann_factor == 1:
        return_threshold = required_return
    elif ann_factor &lt;= -1:
        return np.nan
    else:
        return_threshold = (1 + required_return) ** (1. / ann_factor) - 1
    returns_less_thresh = returns - risk_free - return_threshold
    numer = np.sum(returns_less_thresh[returns_less_thresh &gt; 0.0])
    denom = -1.0 * np.sum(returns_less_thresh[returns_less_thresh &lt; 0.0])
    if denom == 0.:
        return np.nan
    return numer / denom


@njit(cache=True)
def omega_ratio_nb(returns, ann_factor, risk_free=0., required_return=0.):
    &#34;&#34;&#34;2-dim version of `omega_ratio_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = omega_ratio_1d_nb(
            returns[:, col], ann_factor, risk_free=risk_free, required_return=required_return)
    return result


@njit(cache=True)
def sharpe_ratio_1d_nb(returns, ann_factor, risk_free=0.):
    &#34;&#34;&#34;See `empyrical.sharpe_ratio`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 2:
        return np.nan

    returns_risk_adj = returns - risk_free
    mean = np.nanmean(returns_risk_adj)
    std = timeseries.nb.nanstd_1d_nb(returns_risk_adj, ddof=1)
    if std == 0.:
        return np.nan
    return mean / std * np.sqrt(ann_factor)


@njit(cache=True)
def sharpe_ratio_nb(returns, ann_factor, risk_free=0.):
    &#34;&#34;&#34;2-dim version of `sharpe_ratio_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = sharpe_ratio_1d_nb(returns[:, col], ann_factor, risk_free=risk_free)
    return result


@njit(cache=True)
def downside_risk_1d_nb(returns, ann_factor, required_return=0.):
    &#34;&#34;&#34;See `empyrical.downside_risk`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 1:
        return np.nan

    adj_returns = returns - required_return
    adj_returns[adj_returns &gt; 0] = 0
    return np.sqrt(np.nanmean(adj_returns ** 2)) * np.sqrt(ann_factor)


@njit(cache=True)
def downside_risk_nb(returns, ann_factor, required_return=0.):
    &#34;&#34;&#34;2-dim version of `downside_risk_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = downside_risk_1d_nb(returns[:, col], ann_factor, required_return=required_return)
    return result


@njit(cache=True)
def sortino_ratio_1d_nb(returns, downside_risk, ann_factor, required_return=0.):
    &#34;&#34;&#34;See `empyrical.sortino_ratio`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 2:
        return np.nan

    adj_returns = returns - required_return
    average_annualized_return = np.nanmean(adj_returns) * ann_factor
    if downside_risk == 0.:
        return np.nan
    return average_annualized_return / downside_risk


@njit(cache=True)
def sortino_ratio_nb(returns, downside_risk, ann_factor, required_return=0.):
    &#34;&#34;&#34;2-dim version of `sortino_ratio_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = sortino_ratio_1d_nb(
            returns[:, col], downside_risk[col], ann_factor, required_return=required_return)
    return result


@njit(cache=True)
def information_ratio_1d_nb(returns, factor_returns):
    &#34;&#34;&#34;See `empyrical.excess_sharpe`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 2:
        return np.nan

    active_return = returns - factor_returns
    return np.nanmean(active_return) / timeseries.nb.nanstd_1d_nb(active_return, ddof=1)


@njit(cache=True)
def information_ratio_nb(returns, factor_returns):
    &#34;&#34;&#34;2-dim version of `information_ratio_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = information_ratio_1d_nb(returns[:, col], factor_returns[:, col])
    return result


@njit(cache=True)
def beta_1d_nb(returns, factor_returns, risk_free=0.):
    &#34;&#34;&#34;See `empyrical.beta`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 1 or factor_returns.shape[0] &lt; 2:
        return np.nan

    independent = np.where(
        np.isnan(returns),
        np.nan,
        factor_returns,
    )
    ind_residual = independent - np.nanmean(independent)
    covariances = np.nanmean(ind_residual * returns)
    ind_residual = ind_residual ** 2
    ind_variances = np.nanmean(ind_residual)
    if ind_variances &lt; 1.0e-30:
        ind_variances = np.nan
    if ind_variances == 0.:
        return np.nan
    return covariances / ind_variances


@njit(cache=True)
def beta_nb(returns, factor_returns, risk_free=0.):
    &#34;&#34;&#34;2-dim version of `beta_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = beta_1d_nb(returns[:, col], factor_returns[:, col], risk_free=risk_free)
    return result


@njit(cache=True)
def alpha_1d_nb(returns, factor_returns, beta, ann_factor, risk_free=0.):
    &#34;&#34;&#34;See `empyrical.alpha`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 2:
        return np.nan

    adj_returns = returns - risk_free
    adj_factor_returns = factor_returns - risk_free
    alpha_series = adj_returns - (beta * adj_factor_returns)
    return (np.nanmean(alpha_series) + 1) ** ann_factor - 1


@njit(cache=True)
def alpha_nb(returns, factor_returns, beta, ann_factor, risk_free=0.):
    &#34;&#34;&#34;2-dim version of `alpha_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = alpha_1d_nb(returns[:, col], factor_returns[:, col], beta[col], ann_factor, risk_free=risk_free)
    return result


@njit(cache=True)
def tail_ratio_1d_nb(returns):
    &#34;&#34;&#34;See `empyrical.tail_ratio`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 1:
        return np.nan

    returns = returns[~np.isnan(returns)]
    if len(returns) &lt; 1:
        return np.nan
    perc_95 = np.abs(np.percentile(returns, 95))
    perc_5 = np.abs(np.percentile(returns, 5))
    if perc_5 == 0.:
        return np.nan
    return perc_95 / perc_5


@njit(cache=True)
def tail_ratio_nb(returns):
    &#34;&#34;&#34;2-dim version of `tail_ratio_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = tail_ratio_1d_nb(returns[:, col])
    return result


@njit(cache=True)
def value_at_risk_1d_nb(returns, cutoff=0.05):
    &#34;&#34;&#34;See `empyrical.value_at_risk`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 1:
        return np.nan

    returns = returns[~np.isnan(returns)]
    if len(returns) &lt; 1:
        return np.nan
    return np.percentile(returns, 100 * cutoff)


@njit(cache=True)
def value_at_risk_nb(returns, cutoff=0.05):
    &#34;&#34;&#34;2-dim version of `value_at_risk_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = value_at_risk_1d_nb(returns[:, col], cutoff=cutoff)
    return result


@njit(cache=True)
def conditional_value_at_risk_1d_nb(returns, cutoff=0.05):
    &#34;&#34;&#34;See `empyrical.conditional_value_at_risk`.&#34;&#34;&#34;
    cutoff_index = int((len(returns) - 1) * cutoff)
    return np.mean(np.partition(returns, cutoff_index)[:cutoff_index + 1])


@njit(cache=True)
def conditional_value_at_risk_nb(returns, cutoff=0.05):
    &#34;&#34;&#34;2-dim version of `conditional_value_at_risk_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = conditional_value_at_risk_1d_nb(returns[:, col], cutoff=cutoff)
    return result


@njit(cache=True)
def capture_1d_nb(returns, factor_returns, ann_factor):
    &#34;&#34;&#34;See `empyrical.capture`.&#34;&#34;&#34;
    annualized_return1 = annualized_return_1d_nb(returns, ann_factor)
    annualized_return2 = annualized_return_1d_nb(factor_returns, ann_factor)
    if annualized_return2 == 0.:
        return np.nan
    return annualized_return1 / annualized_return2


@njit(cache=True)
def capture_nb(returns, factor_returns, ann_factor):
    &#34;&#34;&#34;2-dim version of `capture_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = capture_1d_nb(returns[:, col], factor_returns[:, col], ann_factor)
    return result


@njit(cache=True)
def up_capture_1d_nb(returns, factor_returns, ann_factor):
    &#34;&#34;&#34;See `empyrical.up_capture`.&#34;&#34;&#34;
    returns = returns[factor_returns &gt; 0]
    factor_returns = factor_returns[factor_returns &gt; 0]
    annualized_return1 = annualized_return_1d_nb(returns, ann_factor)
    annualized_return2 = annualized_return_1d_nb(factor_returns, ann_factor)
    if annualized_return2 == 0.:
        return np.nan
    return annualized_return1 / annualized_return2


@njit(cache=True)
def up_capture_nb(returns, factor_returns, ann_factor):
    &#34;&#34;&#34;2-dim version of `up_capture_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = up_capture_1d_nb(returns[:, col], factor_returns[:, col], ann_factor)
    return result


@njit(cache=True)
def down_capture_1d_nb(returns, factor_returns, ann_factor):
    &#34;&#34;&#34;See `empyrical.down_capture`.&#34;&#34;&#34;
    returns = returns[factor_returns &lt; 0]
    factor_returns = factor_returns[factor_returns &lt; 0]
    annualized_return1 = annualized_return_1d_nb(returns, ann_factor)
    annualized_return2 = annualized_return_1d_nb(factor_returns, ann_factor)
    if annualized_return2 == 0.:
        return np.nan
    return annualized_return1 / annualized_return2


@njit(cache=True)
def down_capture_nb(returns, factor_returns, ann_factor):
    &#34;&#34;&#34;2-dim version of `down_capture_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = down_capture_1d_nb(returns[:, col], factor_returns[:, col], ann_factor)
    return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.portfolio.nb.alpha_1d_nb"><code class="name flex">
<span>def <span class="ident">alpha_1d_nb</span></span>(<span>returns, factor_returns, beta, ann_factor, risk_free=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.alpha</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def alpha_1d_nb(returns, factor_returns, beta, ann_factor, risk_free=0.):
    &#34;&#34;&#34;See `empyrical.alpha`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 2:
        return np.nan

    adj_returns = returns - risk_free
    adj_factor_returns = factor_returns - risk_free
    alpha_series = adj_returns - (beta * adj_factor_returns)
    return (np.nanmean(alpha_series) + 1) ** ann_factor - 1</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.alpha_nb"><code class="name flex">
<span>def <span class="ident">alpha_nb</span></span>(<span>returns, factor_returns, beta, ann_factor, risk_free=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.alpha_1d_nb" href="#vectorbt.portfolio.nb.alpha_1d_nb">alpha_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def alpha_nb(returns, factor_returns, beta, ann_factor, risk_free=0.):
    &#34;&#34;&#34;2-dim version of `alpha_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = alpha_1d_nb(returns[:, col], factor_returns[:, col], beta[col], ann_factor, risk_free=risk_free)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.annualized_return_1d_nb"><code class="name flex">
<span>def <span class="ident">annualized_return_1d_nb</span></span>(<span>returns, ann_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.annual_return</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def annualized_return_1d_nb(returns, ann_factor):
    &#34;&#34;&#34;See `empyrical.annual_return`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 1:
        return np.nan

    ending_value = cum_returns_final_1d_nb(returns, starting_value=1)
    return ending_value ** (ann_factor / returns.shape[0]) - 1</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.annualized_return_nb"><code class="name flex">
<span>def <span class="ident">annualized_return_nb</span></span>(<span>returns, ann_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.annualized_return_1d_nb" href="#vectorbt.portfolio.nb.annualized_return_1d_nb">annualized_return_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def annualized_return_nb(returns, ann_factor):
    &#34;&#34;&#34;2-dim version of `annualized_return_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = annualized_return_1d_nb(returns[:, col], ann_factor)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.annualized_volatility_1d_nb"><code class="name flex">
<span>def <span class="ident">annualized_volatility_1d_nb</span></span>(<span>returns, ann_factor, alpha=2.0)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.annual_volatility</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def annualized_volatility_1d_nb(returns, ann_factor, alpha=2.0):
    &#34;&#34;&#34;See `empyrical.annual_volatility`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 2:
        return np.nan

    return timeseries.nb.nanstd_1d_nb(returns, ddof=1) * ann_factor ** (1.0 / alpha)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.annualized_volatility_nb"><code class="name flex">
<span>def <span class="ident">annualized_volatility_nb</span></span>(<span>returns, ann_factor, alpha=2.0)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.annualized_volatility_1d_nb" href="#vectorbt.portfolio.nb.annualized_volatility_1d_nb">annualized_volatility_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def annualized_volatility_nb(returns, ann_factor, alpha=2.0):
    &#34;&#34;&#34;2-dim version of `annualized_volatility_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = annualized_volatility_1d_nb(returns[:, col], ann_factor, alpha=alpha)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.beta_1d_nb"><code class="name flex">
<span>def <span class="ident">beta_1d_nb</span></span>(<span>returns, factor_returns, risk_free=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.beta</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def beta_1d_nb(returns, factor_returns, risk_free=0.):
    &#34;&#34;&#34;See `empyrical.beta`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 1 or factor_returns.shape[0] &lt; 2:
        return np.nan

    independent = np.where(
        np.isnan(returns),
        np.nan,
        factor_returns,
    )
    ind_residual = independent - np.nanmean(independent)
    covariances = np.nanmean(ind_residual * returns)
    ind_residual = ind_residual ** 2
    ind_variances = np.nanmean(ind_residual)
    if ind_variances &lt; 1.0e-30:
        ind_variances = np.nan
    if ind_variances == 0.:
        return np.nan
    return covariances / ind_variances</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.beta_nb"><code class="name flex">
<span>def <span class="ident">beta_nb</span></span>(<span>returns, factor_returns, risk_free=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.beta_1d_nb" href="#vectorbt.portfolio.nb.beta_1d_nb">beta_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def beta_nb(returns, factor_returns, risk_free=0.):
    &#34;&#34;&#34;2-dim version of `beta_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = beta_1d_nb(returns[:, col], factor_returns[:, col], risk_free=risk_free)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.buy_nb"><code class="name flex">
<span>def <span class="ident">buy_nb</span></span>(<span>run_cash, run_shares, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a Buy.</p>
<p>Returns an updated cash and shares balance, the number of shares bought,
the price adjusted with slippage, and fees paid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def buy_nb(run_cash, run_shares, order):
    &#34;&#34;&#34;Perform a Buy.

    Returns an updated cash and shares balance, the number of shares bought, 
    the price adjusted with slippage, and fees paid.&#34;&#34;&#34;

    # Compute cash required to complete this order
    adj_price = order.price * (1 + order.slippage)
    req_cash = order.size * adj_price
    adj_req_cash = req_cash * (1 + order.fees) + order.fixed_fees

    if adj_req_cash &lt;= run_cash:
        # Sufficient cash
        adj_size = order.size
        fees_paid = adj_req_cash - req_cash
    else:
        # Insufficient cash, size will be less than requested
        # For fees of 10%, you can buy shares for 90.9$ (adj_cash) to spend 100$ (run_cash) in total
        adj_cash = (run_cash - order.fixed_fees) / (1 + order.fees)

        # Update size and fees
        adj_size = adj_cash / adj_price
        fees_paid = run_cash - adj_cash

    if adj_size &gt; 0.:
        # Update current cash and shares
        run_cash -= adj_size * adj_price + fees_paid
        run_shares += adj_size
        return run_cash, run_shares, FilledOrder(adj_size, adj_price, fees_paid, OrderSide.Buy)
    return run_cash, run_shares, None</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.calmar_ratio_1d_nb"><code class="name flex">
<span>def <span class="ident">calmar_ratio_1d_nb</span></span>(<span>returns, annualized_return, max_drawdown, ann_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.calmar_ratio</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def calmar_ratio_1d_nb(returns, annualized_return, max_drawdown, ann_factor):
    &#34;&#34;&#34;See `empyrical.calmar_ratio`.&#34;&#34;&#34;
    if max_drawdown == 0.:
        return np.nan
    return annualized_return / np.abs(max_drawdown)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.calmar_ratio_nb"><code class="name flex">
<span>def <span class="ident">calmar_ratio_nb</span></span>(<span>returns, annualized_return, max_drawdown, ann_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.calmar_ratio_1d_nb" href="#vectorbt.portfolio.nb.calmar_ratio_1d_nb">calmar_ratio_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def calmar_ratio_nb(returns, annualized_return, max_drawdown, ann_factor):
    &#34;&#34;&#34;2-dim version of `calmar_ratio_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = calmar_ratio_1d_nb(returns[:, col], annualized_return[col], max_drawdown[col], ann_factor)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.capture_1d_nb"><code class="name flex">
<span>def <span class="ident">capture_1d_nb</span></span>(<span>returns, factor_returns, ann_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.capture</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def capture_1d_nb(returns, factor_returns, ann_factor):
    &#34;&#34;&#34;See `empyrical.capture`.&#34;&#34;&#34;
    annualized_return1 = annualized_return_1d_nb(returns, ann_factor)
    annualized_return2 = annualized_return_1d_nb(factor_returns, ann_factor)
    if annualized_return2 == 0.:
        return np.nan
    return annualized_return1 / annualized_return2</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.capture_nb"><code class="name flex">
<span>def <span class="ident">capture_nb</span></span>(<span>returns, factor_returns, ann_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.capture_1d_nb" href="#vectorbt.portfolio.nb.capture_1d_nb">capture_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def capture_nb(returns, factor_returns, ann_factor):
    &#34;&#34;&#34;2-dim version of `capture_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = capture_1d_nb(returns[:, col], factor_returns[:, col], ann_factor)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.conditional_value_at_risk_1d_nb"><code class="name flex">
<span>def <span class="ident">conditional_value_at_risk_1d_nb</span></span>(<span>returns, cutoff=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.conditional_value_at_risk</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def conditional_value_at_risk_1d_nb(returns, cutoff=0.05):
    &#34;&#34;&#34;See `empyrical.conditional_value_at_risk`.&#34;&#34;&#34;
    cutoff_index = int((len(returns) - 1) * cutoff)
    return np.mean(np.partition(returns, cutoff_index)[:cutoff_index + 1])</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.conditional_value_at_risk_nb"><code class="name flex">
<span>def <span class="ident">conditional_value_at_risk_nb</span></span>(<span>returns, cutoff=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.conditional_value_at_risk_1d_nb" href="#vectorbt.portfolio.nb.conditional_value_at_risk_1d_nb">conditional_value_at_risk_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def conditional_value_at_risk_nb(returns, cutoff=0.05):
    &#34;&#34;&#34;2-dim version of `conditional_value_at_risk_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = conditional_value_at_risk_1d_nb(returns[:, col], cutoff=cutoff)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.count_reduce_func_nb"><code class="name flex">
<span>def <span class="ident">count_reduce_func_nb</span></span>(<span>records)</span>
</code></dt>
<dd>
<div class="desc"><p><code>reduce_func_nb</code> that returns the number of records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def count_reduce_func_nb(records):
    &#34;&#34;&#34;`reduce_func_nb` that returns the number of records.&#34;&#34;&#34;
    return len(records)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.cum_returns_1d_nb"><code class="name flex">
<span>def <span class="ident">cum_returns_1d_nb</span></span>(<span>returns, starting_value=0)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.cum_returns</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def cum_returns_1d_nb(returns, starting_value=0):
    &#34;&#34;&#34;See `empyrical.cum_returns`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 1:
        return returns.copy()

    result = timeseries.nb.cumprod_1d_nb(returns + 1)
    if starting_value == 0:
        result -= 1
    else:
        result *= starting_value
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.cum_returns_final_1d_nb"><code class="name flex">
<span>def <span class="ident">cum_returns_final_1d_nb</span></span>(<span>returns, starting_value=0)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.cum_returns_final</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def cum_returns_final_1d_nb(returns, starting_value=0):
    &#34;&#34;&#34;See `empyrical.cum_returns_final`.&#34;&#34;&#34;
    if returns.shape[0] == 0:
        return np.nan

    result = timeseries.nb.product_1d_nb(returns + 1)
    if starting_value == 0:
        result -= 1
    else:
        result *= starting_value
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.cum_returns_final_nb"><code class="name flex">
<span>def <span class="ident">cum_returns_final_nb</span></span>(<span>returns, starting_value=0)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.cum_returns_final_1d_nb" href="#vectorbt.portfolio.nb.cum_returns_final_1d_nb">cum_returns_final_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def cum_returns_final_nb(returns, starting_value=0):
    &#34;&#34;&#34;2-dim version of `cum_returns_final_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = cum_returns_final_1d_nb(returns[:, col], starting_value=starting_value)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.cum_returns_nb"><code class="name flex">
<span>def <span class="ident">cum_returns_nb</span></span>(<span>returns, starting_value=0)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.cum_returns_1d_nb" href="#vectorbt.portfolio.nb.cum_returns_1d_nb">cum_returns_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def cum_returns_nb(returns, starting_value=0):
    &#34;&#34;&#34;2-dim version of `cum_returns_1d_nb`.&#34;&#34;&#34;
    result = np.empty_like(returns, dtype=f8)
    for col in range(returns.shape[1]):
        result[:, col] = cum_returns_1d_nb(returns[:, col], starting_value=starting_value)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.down_capture_1d_nb"><code class="name flex">
<span>def <span class="ident">down_capture_1d_nb</span></span>(<span>returns, factor_returns, ann_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.down_capture</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def down_capture_1d_nb(returns, factor_returns, ann_factor):
    &#34;&#34;&#34;See `empyrical.down_capture`.&#34;&#34;&#34;
    returns = returns[factor_returns &lt; 0]
    factor_returns = factor_returns[factor_returns &lt; 0]
    annualized_return1 = annualized_return_1d_nb(returns, ann_factor)
    annualized_return2 = annualized_return_1d_nb(factor_returns, ann_factor)
    if annualized_return2 == 0.:
        return np.nan
    return annualized_return1 / annualized_return2</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.down_capture_nb"><code class="name flex">
<span>def <span class="ident">down_capture_nb</span></span>(<span>returns, factor_returns, ann_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.down_capture_1d_nb" href="#vectorbt.portfolio.nb.down_capture_1d_nb">down_capture_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def down_capture_nb(returns, factor_returns, ann_factor):
    &#34;&#34;&#34;2-dim version of `down_capture_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = down_capture_1d_nb(returns[:, col], factor_returns[:, col], ann_factor)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.downside_risk_1d_nb"><code class="name flex">
<span>def <span class="ident">downside_risk_1d_nb</span></span>(<span>returns, ann_factor, required_return=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.downside_risk</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def downside_risk_1d_nb(returns, ann_factor, required_return=0.):
    &#34;&#34;&#34;See `empyrical.downside_risk`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 1:
        return np.nan

    adj_returns = returns - required_return
    adj_returns[adj_returns &gt; 0] = 0
    return np.sqrt(np.nanmean(adj_returns ** 2)) * np.sqrt(ann_factor)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.downside_risk_nb"><code class="name flex">
<span>def <span class="ident">downside_risk_nb</span></span>(<span>returns, ann_factor, required_return=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.downside_risk_1d_nb" href="#vectorbt.portfolio.nb.downside_risk_1d_nb">downside_risk_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def downside_risk_nb(returns, ann_factor, required_return=0.):
    &#34;&#34;&#34;2-dim version of `downside_risk_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = downside_risk_1d_nb(returns[:, col], ann_factor, required_return=required_return)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.duration_map_func_nb"><code class="name flex">
<span>def <span class="ident">duration_map_func_nb</span></span>(<span>record)</span>
</code></dt>
<dd>
<div class="desc"><p><code>map_func_nb</code> that returns duration of the event.</p>
<p>Record must have layout of <code><a title="vectorbt.portfolio.enums.EventRecord" href="enums.html#vectorbt.portfolio.enums.EventRecord">EventRecord</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def duration_map_func_nb(record):
    &#34;&#34;&#34;`map_func_nb` that returns duration of the event.

    Record must have layout of `vectorbt.portfolio.enums.EventRecord`.&#34;&#34;&#34;
    return record[EventRecord.CloseAt] - record[EventRecord.OpenAt]</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.field_map_func_nb"><code class="name flex">
<span>def <span class="ident">field_map_func_nb</span></span>(<span>record, field)</span>
</code></dt>
<dd>
<div class="desc"><p><code>map_func_nb</code> that returns the specified field of the record.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def field_map_func_nb(record, field):
    &#34;&#34;&#34;`map_func_nb` that returns the specified field of the record.&#34;&#34;&#34;
    return record[field]</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.fill_order_nb"><code class="name flex">
<span>def <span class="ident">fill_order_nb</span></span>(<span>run_cash, run_shares, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill an order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def fill_order_nb(run_cash, run_shares, order):
    &#34;&#34;&#34;Fill an order.&#34;&#34;&#34;
    if order is not None:
        if order.size &gt; 0.:
            return buy_nb(run_cash, run_shares, order)
        if order.size &lt; 0.:
            return sell_nb(run_cash, run_shares, order)
    return run_cash, run_shares, None</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.information_ratio_1d_nb"><code class="name flex">
<span>def <span class="ident">information_ratio_1d_nb</span></span>(<span>returns, factor_returns)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.excess_sharpe</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def information_ratio_1d_nb(returns, factor_returns):
    &#34;&#34;&#34;See `empyrical.excess_sharpe`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 2:
        return np.nan

    active_return = returns - factor_returns
    return np.nanmean(active_return) / timeseries.nb.nanstd_1d_nb(active_return, ddof=1)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.information_ratio_nb"><code class="name flex">
<span>def <span class="ident">information_ratio_nb</span></span>(<span>returns, factor_returns)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.information_ratio_1d_nb" href="#vectorbt.portfolio.nb.information_ratio_1d_nb">information_ratio_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def information_ratio_nb(returns, factor_returns):
    &#34;&#34;&#34;2-dim version of `information_ratio_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = information_ratio_1d_nb(returns[:, col], factor_returns[:, col])
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.map_records_to_matrix_nb"><code class="name flex">
<span>def <span class="ident">map_records_to_matrix_nb</span></span>(<span>records, target_shape, col_field, row_field, map_func_nb, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Map each record to a value that is then stored in a matrix.</p>
<p>Maps each record to a value at <code>(row_field, col_field)</code>.</p>
<p><code>map_func_nb</code> must accept a single record and <code>*args</code>, and return a single value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit
def map_records_to_matrix_nb(records, target_shape, col_field, row_field, map_func_nb, *args):
    &#34;&#34;&#34;Map each record to a value that is then stored in a matrix.

    Maps each record to a value at `(row_field, col_field)`.

    `map_func_nb` must accept a single record and `*args`, and return a single value.&#34;&#34;&#34;
    result = np.full(target_shape, np.nan, dtype=f8)
    for i in range(records.shape[0]):
        record = records[i, :]
        col = int(record[col_field])
        i = int(record[row_field])
        result[i, col] = map_func_nb(record, *args)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.omega_ratio_1d_nb"><code class="name flex">
<span>def <span class="ident">omega_ratio_1d_nb</span></span>(<span>returns, ann_factor, risk_free=0.0, required_return=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.omega_ratio</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def omega_ratio_1d_nb(returns, ann_factor, risk_free=0., required_return=0.):
    &#34;&#34;&#34;See `empyrical.omega_ratio`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 1:
        return np.nan

    if ann_factor == 1:
        return_threshold = required_return
    elif ann_factor &lt;= -1:
        return np.nan
    else:
        return_threshold = (1 + required_return) ** (1. / ann_factor) - 1
    returns_less_thresh = returns - risk_free - return_threshold
    numer = np.sum(returns_less_thresh[returns_less_thresh &gt; 0.0])
    denom = -1.0 * np.sum(returns_less_thresh[returns_less_thresh &lt; 0.0])
    if denom == 0.:
        return np.nan
    return numer / denom</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.omega_ratio_nb"><code class="name flex">
<span>def <span class="ident">omega_ratio_nb</span></span>(<span>returns, ann_factor, risk_free=0.0, required_return=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.omega_ratio_1d_nb" href="#vectorbt.portfolio.nb.omega_ratio_1d_nb">omega_ratio_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def omega_ratio_nb(returns, ann_factor, risk_free=0., required_return=0.):
    &#34;&#34;&#34;2-dim version of `omega_ratio_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = omega_ratio_1d_nb(
            returns[:, col], ann_factor, risk_free=risk_free, required_return=required_return)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.position_records_nb"><code class="name flex">
<span>def <span class="ident">position_records_nb</span></span>(<span>price, order_records)</span>
</code></dt>
<dd>
<div class="desc"><p>Find positions and store their information as records to an array.</p>
<h2 id="example">Example</h2>
<p>Build an array with trade information:</p>
<pre><code class="python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from vectorbt.portfolio.nb import simulate_nb, position_records_nb
&gt;&gt;&gt; from vectorbt.portfolio.enums import Order, PositionRecord

&gt;&gt;&gt; order_price = price = np.arange(1, 6)[:, None]
&gt;&gt;&gt; order_size = np.asarray([1, -1, 1, -1, 1])[:, None]

&gt;&gt;&gt; @njit
... def order_func_nb(col, i, run_cash, run_shares):
...     return Order(order_size[i, col], order_price[i, col], 
...          fees=0.01, slippage=0., fixed_fees=0.)
&gt;&gt;&gt; order_records, cash, shares = simulate_nb(price.shape, 100, order_func_nb)
&gt;&gt;&gt; records = position_records_nb(price, order_records)

&gt;&gt;&gt; print(pd.DataFrame(records, columns=PositionRecord._fields)) 
   Column  Size  OpenAt  OpenPrice  OpenFees  CloseAt  ClosePrice  CloseFees          0     0.0   1.0     0.0        1.0      0.01      1.0         2.0       0.02   
1     0.0   1.0     2.0        3.0      0.03      3.0         4.0       0.04   
2     0.0   1.0     4.0        5.0      0.05      4.0         5.0       0.00   

    PnL    Return  Status  
0  0.97  0.960396     1.0  
1  0.93  0.306931     1.0  
2 -0.05 -0.009901     0.0  
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def position_records_nb(price, order_records):
    &#34;&#34;&#34;Find positions and store their information as records to an array.

    Example:
        Build an array with trade information:
        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from numba import njit
        &gt;&gt;&gt; from vectorbt.portfolio.nb import simulate_nb, position_records_nb
        &gt;&gt;&gt; from vectorbt.portfolio.enums import Order, PositionRecord

        &gt;&gt;&gt; order_price = price = np.arange(1, 6)[:, None]
        &gt;&gt;&gt; order_size = np.asarray([1, -1, 1, -1, 1])[:, None]

        &gt;&gt;&gt; @njit
        ... def order_func_nb(col, i, run_cash, run_shares):
        ...     return Order(order_size[i, col], order_price[i, col], 
        ...          fees=0.01, slippage=0., fixed_fees=0.)
        &gt;&gt;&gt; order_records, cash, shares = simulate_nb(price.shape, 100, order_func_nb)
        &gt;&gt;&gt; records = position_records_nb(price, order_records)

        &gt;&gt;&gt; print(pd.DataFrame(records, columns=PositionRecord._fields)) 
           Column  Size  OpenAt  OpenPrice  OpenFees  CloseAt  ClosePrice  CloseFees  \
        0     0.0   1.0     0.0        1.0      0.01      1.0         2.0       0.02   
        1     0.0   1.0     2.0        3.0      0.03      3.0         4.0       0.04   
        2     0.0   1.0     4.0        5.0      0.05      4.0         5.0       0.00   

            PnL    Return  Status  
        0  0.97  0.960396     1.0  
        1  0.93  0.306931     1.0  
        2 -0.05 -0.009901     0.0  
        ```&#34;&#34;&#34;
    result = np.empty((price.shape[0] * price.shape[1], len(PositionRecord)), dtype=f8)
    j = 0
    prev_col = -1

    for r in range(order_records.shape[0]):
        record = order_records[r]
        i = int(record[OrderRecord.Index])
        col = int(record[OrderRecord.Column])
        order_size = record[OrderRecord.Size]
        order_price = record[OrderRecord.Price]
        order_fees = record[OrderRecord.Fees]
        order_side = record[OrderRecord.Side]

        if col != prev_col:
            # Column has changed
            prev_col = col
            buy_size_sum = 0.
            buy_gross_sum = 0.
            buy_fees_sum = 0.
            sell_size_sum = 0.
            sell_gross_sum = 0.
            sell_fees_sum = 0.
            store_position = False

        if order_side == OrderSide.Buy:
            # Position increased
            if buy_size_sum == 0.:
                position_start = i

            buy_size_sum += order_size
            buy_gross_sum += order_size * order_price
            buy_fees_sum += order_fees

        elif order_side == OrderSide.Sell:
            # Position decreased
            sell_size_sum += order_size
            sell_gross_sum += order_size * order_price
            sell_fees_sum += order_fees

        if buy_size_sum == sell_size_sum:
            # Closed position
            status = PositionStatus.Closed
            store_position = True

        if i == price.shape[0] - 1 and buy_size_sum &gt; sell_size_sum:
            # If position hasn&#39;t been closed, calculate its unrealized metrics
            sell_size_sum += buy_size_sum
            sell_gross_sum += buy_size_sum * price[i, col]
            # NOTE: We have no information about fees here, so we don&#39;t add them
            status = PositionStatus.Open
            store_position = True

        if store_position:
            # Calculate PnL and return
            avg_buy_price = buy_gross_sum / buy_size_sum
            avg_sell_price = sell_gross_sum / sell_size_sum
            buy_val = buy_size_sum * avg_buy_price + buy_fees_sum
            sell_val = buy_size_sum * avg_sell_price - sell_fees_sum
            pnl = sell_val - buy_val
            ret = (sell_val - buy_val) / buy_val

            # Save position to the records
            result[j, PositionRecord.Column] = col
            result[j, PositionRecord.Size] = buy_size_sum
            result[j, PositionRecord.OpenAt] = position_start
            result[j, PositionRecord.OpenPrice] = avg_buy_price
            result[j, PositionRecord.OpenFees] = buy_fees_sum
            result[j, PositionRecord.CloseAt] = i
            result[j, PositionRecord.ClosePrice] = avg_sell_price
            result[j, PositionRecord.CloseFees] = sell_fees_sum
            result[j, PositionRecord.PnL] = pnl
            result[j, PositionRecord.Return] = ret
            result[j, PositionRecord.Status] = status
            j += 1

            # Reset running vars for a new position
            buy_size_sum = 0.
            buy_gross_sum = 0.
            buy_fees_sum = 0.
            sell_size_sum = 0.
            sell_gross_sum = 0.
            sell_fees_sum = 0.
            store_position = False
    return result[:j, :]</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.reduce_records_nb"><code class="name flex">
<span>def <span class="ident">reduce_records_nb</span></span>(<span>records, n_cols, col_field, reduce_func_nb, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a reducing operation over the records of each column.</p>
<p>Faster than <code><a title="vectorbt.portfolio.nb.map_records_to_matrix_nb" href="#vectorbt.portfolio.nb.map_records_to_matrix_nb">map_records_to_matrix_nb()</a></code> and <code>vbt.timeseries.*</code> used together, and also
requires less memory. But does not take advantage of caching.</p>
<p><code>reduce_func_nb</code> must accept an array of records and <code>*args</code>, and return a single value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Records must be in the order they were created.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit
def reduce_records_nb(records, n_cols, col_field, reduce_func_nb, *args):
    &#34;&#34;&#34;Perform a reducing operation over the records of each column.

    Faster than `map_records_to_matrix_nb` and `vbt.timeseries.*` used together, and also
    requires less memory. But does not take advantage of caching.

    `reduce_func_nb` must accept an array of records and `*args`, and return a single value.

    !!! note
        Records must be in the order they were created.&#34;&#34;&#34;
    result = np.full(n_cols, np.nan, dtype=f8)
    from_i = 0
    col = -1
    for i in range(records.shape[0]):
        record_col = int(records[i, col_field])
        if record_col != col:
            if col != -1:
                # At the beginning of second column do reduce on the first
                result[col] = reduce_func_nb(records[from_i:i, :], *args)
            from_i = i
            col = record_col
        if i == len(records) - 1:
            result[col] = reduce_func_nb(records[from_i:i+1, :], *args)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.sell_nb"><code class="name flex">
<span>def <span class="ident">sell_nb</span></span>(<span>run_cash, run_shares, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a Sell.</p>
<p>Returns an updated cash and shares balance, the number of shares sold,
the price adjusted with slippage, and fees paid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def sell_nb(run_cash, run_shares, order):
    &#34;&#34;&#34;Perform a Sell.

    Returns an updated cash and shares balance, the number of shares sold, 
    the price adjusted with slippage, and fees paid.&#34;&#34;&#34;

    # Compute acquired cash
    adj_price = order.price * (1 - order.slippage)
    adj_size = min(run_shares, abs(order.size))
    cash = adj_size * adj_price

    # Minus costs
    adj_cash = cash * (1 - order.fees) - order.fixed_fees

    # Update fees
    fees_paid = cash - adj_cash

    if adj_size &gt; 0.:
        # Update current cash and shares
        run_cash += adj_size * adj_price - fees_paid
        run_shares -= adj_size
        return run_cash, run_shares, FilledOrder(adj_size, adj_price, fees_paid, OrderSide.Sell)
    return run_cash, run_shares, None</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.sharpe_ratio_1d_nb"><code class="name flex">
<span>def <span class="ident">sharpe_ratio_1d_nb</span></span>(<span>returns, ann_factor, risk_free=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.sharpe_ratio</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def sharpe_ratio_1d_nb(returns, ann_factor, risk_free=0.):
    &#34;&#34;&#34;See `empyrical.sharpe_ratio`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 2:
        return np.nan

    returns_risk_adj = returns - risk_free
    mean = np.nanmean(returns_risk_adj)
    std = timeseries.nb.nanstd_1d_nb(returns_risk_adj, ddof=1)
    if std == 0.:
        return np.nan
    return mean / std * np.sqrt(ann_factor)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.sharpe_ratio_nb"><code class="name flex">
<span>def <span class="ident">sharpe_ratio_nb</span></span>(<span>returns, ann_factor, risk_free=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.sharpe_ratio_1d_nb" href="#vectorbt.portfolio.nb.sharpe_ratio_1d_nb">sharpe_ratio_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def sharpe_ratio_nb(returns, ann_factor, risk_free=0.):
    &#34;&#34;&#34;2-dim version of `sharpe_ratio_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = sharpe_ratio_1d_nb(returns[:, col], ann_factor, risk_free=risk_free)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.signals_order_func_nb"><code class="name flex">
<span>def <span class="ident">signals_order_func_nb</span></span>(<span>run_shares, entries, exits, size, entry_price, exit_price, fees, fixed_fees, slippage, accumulate)</span>
</code></dt>
<dd>
<div class="desc"><p><code>order_func_nb</code> of <code><a title="vectorbt.portfolio.nb.simulate_from_signals_nb" href="#vectorbt.portfolio.nb.simulate_from_signals_nb">simulate_from_signals_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def signals_order_func_nb(run_shares, entries, exits, size, entry_price,
                          exit_price, fees, fixed_fees, slippage, accumulate):
    &#34;&#34;&#34;`order_func_nb` of `simulate_from_signals_nb`.&#34;&#34;&#34;
    if entries and not exits:
        # Buy the amount of shares specified in size (only once if not accumulate)
        if run_shares == 0. or accumulate:
            order_size = abs(size)
            order_price = entry_price
        else:
            return None
    elif not entries and exits:
        # Sell everything
        if run_shares &gt; 0.:
            order_size = -np.inf
            order_price = exit_price
        else:
            return None
    elif entries and exits:
        # Buy the difference between entry and exit size
        order_size = abs(size) - run_shares
        if order_size &gt; 0:
            order_price = entry_price
        elif order_size &lt; 0:
            order_price = exit_price
        else:
            return None
    return Order(
        order_size,
        order_price,
        fees=fees,
        fixed_fees=fixed_fees,
        slippage=slippage)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.simulate_from_orders_nb"><code class="name flex">
<span>def <span class="ident">simulate_from_orders_nb</span></span>(<span>target_shape, init_capital, size, price, fees, fixed_fees, slippage, is_target)</span>
</code></dt>
<dd>
<div class="desc"><p>Adaptation of <code><a title="vectorbt.portfolio.nb.simulate_nb" href="#vectorbt.portfolio.nb.simulate_nb">simulate_nb()</a></code> for simulation based on orders.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def simulate_from_orders_nb(target_shape, init_capital, size, price, fees, fixed_fees, slippage, is_target):
    &#34;&#34;&#34;Adaptation of `simulate_nb` for simulation based on orders.&#34;&#34;&#34;
    order_records = np.empty((target_shape[0] * target_shape[1], len(OrderRecord)), dtype=f8)
    j = 0
    cash = np.empty(target_shape, dtype=f8)
    shares = np.empty(target_shape, dtype=f8)

    for col in range(target_shape[1]):
        run_cash = init_capital
        run_shares = 0.

        for i in range(target_shape[0]):
            # Generate the next oder or None to do nothing
            order = size_order_func_nb(
                run_shares,
                size[i, col],
                price[i, col],
                fees[i, col],
                fixed_fees[i, col],
                slippage[i, col],
                is_target)
            # Fill the order
            run_cash, run_shares, filled_order = fill_order_nb(run_cash, run_shares, order)

            # Add a new record
            if filled_order is not None:
                order_records[j, OrderRecord.Column] = col
                order_records[j, OrderRecord.Index] = i
                order_records[j, OrderRecord.Size] = filled_order.size
                order_records[j, OrderRecord.Price] = filled_order.price
                order_records[j, OrderRecord.Fees] = filled_order.fees
                order_records[j, OrderRecord.Side] = filled_order.side
                j += 1

            # Populate cash and shares
            cash[i, col], shares[i, col] = run_cash, run_shares

    return order_records[:j, :], cash, shares</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.simulate_from_signals_nb"><code class="name flex">
<span>def <span class="ident">simulate_from_signals_nb</span></span>(<span>target_shape, init_capital, entries, exits, size, entry_price, exit_price, fees, fixed_fees, slippage, accumulate)</span>
</code></dt>
<dd>
<div class="desc"><p>Adaptation of <code><a title="vectorbt.portfolio.nb.simulate_nb" href="#vectorbt.portfolio.nb.simulate_nb">simulate_nb()</a></code> for simulation based on entry and exit signals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def simulate_from_signals_nb(target_shape, init_capital, entries, exits, size, entry_price,
                             exit_price, fees, fixed_fees, slippage, accumulate):
    &#34;&#34;&#34;Adaptation of `simulate_nb` for simulation based on entry and exit signals.&#34;&#34;&#34;
    order_records = np.empty((target_shape[0] * target_shape[1], len(OrderRecord)), dtype=f8)
    j = 0
    cash = np.empty(target_shape, dtype=f8)
    shares = np.empty(target_shape, dtype=f8)

    for col in range(target_shape[1]):
        run_cash = init_capital
        run_shares = 0.

        for i in range(target_shape[0]):
            # Generate the next oder or None to do nothing
            if entries[i, col] or exits[i, col]:
                order = signals_order_func_nb(
                    run_shares,
                    entries[i, col],
                    exits[i, col],
                    size[i, col],
                    entry_price[i, col],
                    exit_price[i, col],
                    fees[i, col],
                    fixed_fees[i, col],
                    slippage[i, col],
                    accumulate)
                # Fill the order
                run_cash, run_shares, filled_order = fill_order_nb(run_cash, run_shares, order)

                # Add a new record
                if filled_order is not None:
                    order_records[j, OrderRecord.Column] = col
                    order_records[j, OrderRecord.Index] = i
                    order_records[j, OrderRecord.Size] = filled_order.size
                    order_records[j, OrderRecord.Price] = filled_order.price
                    order_records[j, OrderRecord.Fees] = filled_order.fees
                    order_records[j, OrderRecord.Side] = filled_order.side
                    j += 1

            # Populate cash and shares
            cash[i, col], shares[i, col] = run_cash, run_shares

    return order_records[:j, :], cash, shares</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.simulate_nb"><code class="name flex">
<span>def <span class="ident">simulate_nb</span></span>(<span>target_shape, init_capital, order_func_nb, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate a portfolio by generating and filling orders.</p>
<p>Starting with initial capital <code>init_capital</code>, iterates over shape <code>target_shape</code>,
and for each data point, generates an order using <code>order_func_nb</code>. Tries then to
fulfill that order. If unsuccessful due to insufficient cash/shares, always orders
the available fraction. Updates then the current cash and shares balance.</p>
<p>Returns order records of layout <code><a title="vectorbt.portfolio.enums.OrderRecord" href="enums.html#vectorbt.portfolio.enums.OrderRecord">OrderRecord</a></code>, but also
cash and shares as time series.</p>
<p><code>order_func_nb</code> must accept index of the current column <code>col</code>, the time step <code>i</code>,
the amount of cash <code>run_cash</code> and shares <code>run_shares</code> held at the time step <code>i</code>, and <code>*args</code>.
Must either return an <code><a title="vectorbt.portfolio.enums.Order" href="enums.html#vectorbt.portfolio.enums.Order">Order</a></code> tuple or <code>None</code> to do nothing.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In some cases, passing large arrays as <code>*args</code> can negatively impact performance. What can help
is accessing arrays from <code>order_func_nb</code> as non-local variables as we do in the example below.</p>
</div>
<h2 id="example">Example</h2>
<p>Simulate a basic buy-and-hold strategy:</p>
<pre><code class="python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from vectorbt.portfolio.nb import simulate_nb
&gt;&gt;&gt; from vectorbt.portfolio.enums import Order, OrderRecord

&gt;&gt;&gt; price = np.asarray([
...     [1, 5, 1],
...     [2, 4, 2],
...     [3, 3, 3],
...     [4, 2, 2],
...     [5, 1, 1]
... ])
&gt;&gt;&gt; fees = 0.001
&gt;&gt;&gt; fixed_fees = 1
&gt;&gt;&gt; slippage = 0.001
&gt;&gt;&gt; @njit
... def order_func_nb(col, i, run_cash, run_shares):
...     return Order(np.inf if i == 0 else 0, price[i, col], 
...         fees=fees, fixed_fees=fixed_fees, slippage=slippage)
&gt;&gt;&gt; order_records, cash, shares = simulate_nb(price.shape, 100, order_func_nb)

&gt;&gt;&gt; print(pd.DataFrame(order_records, columns=OrderRecord._fields))
[[ 0.   0.   98.8022966   1.001   1.0989011   0.   ]
 [ 1.   0.   19.76045932  5.005   1.0989011   0.   ]
 [ 2.   0.   98.8022966   1.001   1.0989011   0.   ]]
&gt;&gt;&gt; print(cash)
[[0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]]
&gt;&gt;&gt; print(shares)
[[98.8022966  19.76045932 98.8022966 ]
 [98.8022966  19.76045932 98.8022966 ]
 [98.8022966  19.76045932 98.8022966 ]
 [98.8022966  19.76045932 98.8022966 ]
 [98.8022966  19.76045932 98.8022966 ]]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit
def simulate_nb(target_shape, init_capital, order_func_nb, *args):
    &#34;&#34;&#34;Simulate a portfolio by generating and filling orders.

    Starting with initial capital `init_capital`, iterates over shape `target_shape`, 
    and for each data point, generates an order using `order_func_nb`. Tries then to 
    fulfill that order. If unsuccessful due to insufficient cash/shares, always orders 
    the available fraction. Updates then the current cash and shares balance.

    Returns order records of layout `vectorbt.portfolio.enums.OrderRecord`, but also 
    cash and shares as time series.

    `order_func_nb` must accept index of the current column `col`, the time step `i`,
    the amount of cash `run_cash` and shares `run_shares` held at the time step `i`, and `*args`.
    Must either return an `vectorbt.portfolio.enums.Order` tuple or `None` to do nothing.

    !!! warning
        In some cases, passing large arrays as `*args` can negatively impact performance. What can help
        is accessing arrays from `order_func_nb` as non-local variables as we do in the example below.

    Example:
        Simulate a basic buy-and-hold strategy:
        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from numba import njit
        &gt;&gt;&gt; from vectorbt.portfolio.nb import simulate_nb
        &gt;&gt;&gt; from vectorbt.portfolio.enums import Order, OrderRecord

        &gt;&gt;&gt; price = np.asarray([
        ...     [1, 5, 1],
        ...     [2, 4, 2],
        ...     [3, 3, 3],
        ...     [4, 2, 2],
        ...     [5, 1, 1]
        ... ])
        &gt;&gt;&gt; fees = 0.001
        &gt;&gt;&gt; fixed_fees = 1
        &gt;&gt;&gt; slippage = 0.001
        &gt;&gt;&gt; @njit
        ... def order_func_nb(col, i, run_cash, run_shares):
        ...     return Order(np.inf if i == 0 else 0, price[i, col], 
        ...         fees=fees, fixed_fees=fixed_fees, slippage=slippage)
        &gt;&gt;&gt; order_records, cash, shares = simulate_nb(price.shape, 100, order_func_nb)

        &gt;&gt;&gt; print(pd.DataFrame(order_records, columns=OrderRecord._fields))
        [[ 0.   0.   98.8022966   1.001   1.0989011   0.   ]
         [ 1.   0.   19.76045932  5.005   1.0989011   0.   ]
         [ 2.   0.   98.8022966   1.001   1.0989011   0.   ]]
        &gt;&gt;&gt; print(cash)
        [[0. 0. 0.]
         [0. 0. 0.]
         [0. 0. 0.]
         [0. 0. 0.]
         [0. 0. 0.]]
        &gt;&gt;&gt; print(shares)
        [[98.8022966  19.76045932 98.8022966 ]
         [98.8022966  19.76045932 98.8022966 ]
         [98.8022966  19.76045932 98.8022966 ]
         [98.8022966  19.76045932 98.8022966 ]
         [98.8022966  19.76045932 98.8022966 ]]
        ```
    &#34;&#34;&#34;
    order_records = np.empty((target_shape[0] * target_shape[1], len(OrderRecord)), dtype=f8)
    j = 0
    cash = np.empty(target_shape, dtype=f8)
    shares = np.empty(target_shape, dtype=f8)

    for col in range(target_shape[1]):
        run_cash = init_capital
        run_shares = 0.

        for i in range(target_shape[0]):
            # Generate the next oder or None to do nothing
            order = order_func_nb(col, i, run_cash, run_shares, *args)
            # Fill the order
            run_cash, run_shares, filled_order = fill_order_nb(run_cash, run_shares, order)

            # Add a new record
            if filled_order is not None:
                order_records[j, OrderRecord.Column] = col
                order_records[j, OrderRecord.Index] = i
                order_records[j, OrderRecord.Size] = filled_order.size
                order_records[j, OrderRecord.Price] = filled_order.price
                order_records[j, OrderRecord.Fees] = filled_order.fees
                order_records[j, OrderRecord.Side] = filled_order.side
                j += 1

            # Populate cash and shares
            cash[i, col], shares[i, col] = run_cash, run_shares

    return order_records[:j, :], cash, shares</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.size_order_func_nb"><code class="name flex">
<span>def <span class="ident">size_order_func_nb</span></span>(<span>run_shares, size, price, fees, fixed_fees, slippage, is_target)</span>
</code></dt>
<dd>
<div class="desc"><p><code>order_func_nb</code> of <code><a title="vectorbt.portfolio.nb.simulate_from_orders_nb" href="#vectorbt.portfolio.nb.simulate_from_orders_nb">simulate_from_orders_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def size_order_func_nb(run_shares, size, price, fees, fixed_fees, slippage, is_target):
    &#34;&#34;&#34;`order_func_nb` of `simulate_from_orders_nb`.&#34;&#34;&#34;
    if is_target:
        order_size = size - run_shares
    else:
        order_size = size
    return Order(
        order_size,
        price,
        fees=fees,
        fixed_fees=fixed_fees,
        slippage=slippage)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.sortino_ratio_1d_nb"><code class="name flex">
<span>def <span class="ident">sortino_ratio_1d_nb</span></span>(<span>returns, downside_risk, ann_factor, required_return=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.sortino_ratio</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def sortino_ratio_1d_nb(returns, downside_risk, ann_factor, required_return=0.):
    &#34;&#34;&#34;See `empyrical.sortino_ratio`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 2:
        return np.nan

    adj_returns = returns - required_return
    average_annualized_return = np.nanmean(adj_returns) * ann_factor
    if downside_risk == 0.:
        return np.nan
    return average_annualized_return / downside_risk</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.sortino_ratio_nb"><code class="name flex">
<span>def <span class="ident">sortino_ratio_nb</span></span>(<span>returns, downside_risk, ann_factor, required_return=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.sortino_ratio_1d_nb" href="#vectorbt.portfolio.nb.sortino_ratio_1d_nb">sortino_ratio_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def sortino_ratio_nb(returns, downside_risk, ann_factor, required_return=0.):
    &#34;&#34;&#34;2-dim version of `sortino_ratio_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = sortino_ratio_1d_nb(
            returns[:, col], downside_risk[col], ann_factor, required_return=required_return)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.tail_ratio_1d_nb"><code class="name flex">
<span>def <span class="ident">tail_ratio_1d_nb</span></span>(<span>returns)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.tail_ratio</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def tail_ratio_1d_nb(returns):
    &#34;&#34;&#34;See `empyrical.tail_ratio`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 1:
        return np.nan

    returns = returns[~np.isnan(returns)]
    if len(returns) &lt; 1:
        return np.nan
    perc_95 = np.abs(np.percentile(returns, 95))
    perc_5 = np.abs(np.percentile(returns, 5))
    if perc_5 == 0.:
        return np.nan
    return perc_95 / perc_5</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.tail_ratio_nb"><code class="name flex">
<span>def <span class="ident">tail_ratio_nb</span></span>(<span>returns)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.tail_ratio_1d_nb" href="#vectorbt.portfolio.nb.tail_ratio_1d_nb">tail_ratio_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def tail_ratio_nb(returns):
    &#34;&#34;&#34;2-dim version of `tail_ratio_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = tail_ratio_1d_nb(returns[:, col])
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.total_return_apply_func_nb"><code class="name flex">
<span>def <span class="ident">total_return_apply_func_nb</span></span>(<span>col, idxs, returns)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate total return from returns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def total_return_apply_func_nb(col, idxs, returns):
    &#34;&#34;&#34;Calculate total return from returns.&#34;&#34;&#34;
    return timeseries.nb.product_1d_nb(returns + 1) - 1</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.trade_records_nb"><code class="name flex">
<span>def <span class="ident">trade_records_nb</span></span>(<span>price, order_records)</span>
</code></dt>
<dd>
<div class="desc"><p>Find trades and store their information as records to an array.</p>
<p>One position can have multiple trades. A trade in this regard is just a sell operation.
Performance for this operation is calculated based on the size weighted average of
previous buy operations in the same position.</p>
<h2 id="example">Example</h2>
<p>Build an array with trade information:</p>
<pre><code class="python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from vectorbt.portfolio.nb import simulate_nb, trade_records_nb
&gt;&gt;&gt; from vectorbt.portfolio.enums import Order, TradeRecord

&gt;&gt;&gt; order_price = price = np.arange(1, 6)[:, None]
&gt;&gt;&gt; order_size = np.asarray([1, -1, 1, -1, 1])[:, None]

&gt;&gt;&gt; @njit
... def order_func_nb(col, i, run_cash, run_shares):
...     return Order(order_size[i, col], order_price[i, col], 
...          fees=0.01, slippage=0., fixed_fees=0.)
&gt;&gt;&gt; order_records, cash, shares = simulate_nb(price.shape, 100, order_func_nb)
&gt;&gt;&gt; records = trade_records_nb(price, order_records)

&gt;&gt;&gt; print(pd.DataFrame(records, columns=TradeRecord._fields)) 
   Column  Size  OpenAt  OpenPrice  OpenFees  CloseAt  ClosePrice  CloseFees  \
0     0.0   1.0     0.0        1.0      0.01      1.0         2.0       0.02   
1     0.0   1.0     2.0        3.0      0.03      3.0         4.0       0.04   

    PnL    Return  Position  
0  0.97  0.960396       0.0  
1  0.93  0.306931       1.0  
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def trade_records_nb(price, order_records):
    &#34;&#34;&#34;Find trades and store their information as records to an array.

    One position can have multiple trades. A trade in this regard is just a sell operation.
    Performance for this operation is calculated based on the size weighted average of 
    previous buy operations in the same position.

    Example:
        Build an array with trade information:
        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from numba import njit
        &gt;&gt;&gt; from vectorbt.portfolio.nb import simulate_nb, trade_records_nb
        &gt;&gt;&gt; from vectorbt.portfolio.enums import Order, TradeRecord

        &gt;&gt;&gt; order_price = price = np.arange(1, 6)[:, None]
        &gt;&gt;&gt; order_size = np.asarray([1, -1, 1, -1, 1])[:, None]

        &gt;&gt;&gt; @njit
        ... def order_func_nb(col, i, run_cash, run_shares):
        ...     return Order(order_size[i, col], order_price[i, col], 
        ...          fees=0.01, slippage=0., fixed_fees=0.)
        &gt;&gt;&gt; order_records, cash, shares = simulate_nb(price.shape, 100, order_func_nb)
        &gt;&gt;&gt; records = trade_records_nb(price, order_records)

        &gt;&gt;&gt; print(pd.DataFrame(records, columns=TradeRecord._fields)) 
           Column  Size  OpenAt  OpenPrice  OpenFees  CloseAt  ClosePrice  CloseFees  \\
        0     0.0   1.0     0.0        1.0      0.01      1.0         2.0       0.02   
        1     0.0   1.0     2.0        3.0      0.03      3.0         4.0       0.04   

            PnL    Return  Position  
        0  0.97  0.960396       0.0  
        1  0.93  0.306931       1.0  
        ```&#34;&#34;&#34;
    result = np.empty((price.shape[0] * price.shape[1], len(TradeRecord)), dtype=f8)
    position_idx = -1
    j = 0
    prev_col = -1

    for r in range(order_records.shape[0]):
        record = order_records[r]
        i = int(record[OrderRecord.Index])
        col = int(record[OrderRecord.Column])
        order_size = record[OrderRecord.Size]
        order_price = record[OrderRecord.Price]
        order_fees = record[OrderRecord.Fees]
        order_side = record[OrderRecord.Side]

        if col != prev_col:
            # Column has changed
            prev_col = col
            buy_size_sum = 0.
            buy_gross_sum = 0.
            buy_fees_sum = 0.

        if order_side == OrderSide.Buy:
            # Buy operation
            if buy_size_sum == 0.:
                position_start = i
                position_idx += 1

            # Position increased
            buy_size_sum += order_size
            buy_gross_sum += order_size * order_price
            buy_fees_sum += order_fees

        elif order_side == OrderSide.Sell:
            # Sell operation
            # Close the current trade
            # Opening price is the size-weighted average over all purchase prices
            avg_buy_price = buy_gross_sum / buy_size_sum
            # Opening fees are the size-weighted average over all purchase fees
            frac_buy_fees = order_size / buy_size_sum * buy_fees_sum
            # Calculate PnL and return
            buy_val = order_size * avg_buy_price + frac_buy_fees
            sell_val = order_size * order_price - order_fees
            pnl = sell_val - buy_val
            ret = (sell_val - buy_val) / buy_val

            # Save the trade to the records
            result[j, TradeRecord.Column] = col
            result[j, TradeRecord.Size] = order_size
            result[j, TradeRecord.OpenAt] = position_start
            result[j, TradeRecord.OpenPrice] = avg_buy_price
            result[j, TradeRecord.OpenFees] = frac_buy_fees
            result[j, TradeRecord.CloseAt] = i
            result[j, TradeRecord.ClosePrice] = order_price
            result[j, TradeRecord.CloseFees] = order_fees
            result[j, TradeRecord.PnL] = pnl
            result[j, TradeRecord.Return] = ret
            result[j, TradeRecord.Position] = position_idx
            j += 1

            # Position decreased, previous purchases have now less impact
            size_fraction = (buy_size_sum - order_size) / buy_size_sum
            buy_size_sum *= size_fraction
            buy_gross_sum *= size_fraction
            buy_fees_sum *= size_fraction
    return result[:j, :]</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.up_capture_1d_nb"><code class="name flex">
<span>def <span class="ident">up_capture_1d_nb</span></span>(<span>returns, factor_returns, ann_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.up_capture</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def up_capture_1d_nb(returns, factor_returns, ann_factor):
    &#34;&#34;&#34;See `empyrical.up_capture`.&#34;&#34;&#34;
    returns = returns[factor_returns &gt; 0]
    factor_returns = factor_returns[factor_returns &gt; 0]
    annualized_return1 = annualized_return_1d_nb(returns, ann_factor)
    annualized_return2 = annualized_return_1d_nb(factor_returns, ann_factor)
    if annualized_return2 == 0.:
        return np.nan
    return annualized_return1 / annualized_return2</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.up_capture_nb"><code class="name flex">
<span>def <span class="ident">up_capture_nb</span></span>(<span>returns, factor_returns, ann_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.up_capture_1d_nb" href="#vectorbt.portfolio.nb.up_capture_1d_nb">up_capture_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def up_capture_nb(returns, factor_returns, ann_factor):
    &#34;&#34;&#34;2-dim version of `up_capture_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = up_capture_1d_nb(returns[:, col], factor_returns[:, col], ann_factor)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.value_at_risk_1d_nb"><code class="name flex">
<span>def <span class="ident">value_at_risk_1d_nb</span></span>(<span>returns, cutoff=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>empyrical.value_at_risk</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def value_at_risk_1d_nb(returns, cutoff=0.05):
    &#34;&#34;&#34;See `empyrical.value_at_risk`.&#34;&#34;&#34;
    if returns.shape[0] &lt; 1:
        return np.nan

    returns = returns[~np.isnan(returns)]
    if len(returns) &lt; 1:
        return np.nan
    return np.percentile(returns, 100 * cutoff)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.nb.value_at_risk_nb"><code class="name flex">
<span>def <span class="ident">value_at_risk_nb</span></span>(<span>returns, cutoff=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>2-dim version of <code><a title="vectorbt.portfolio.nb.value_at_risk_1d_nb" href="#vectorbt.portfolio.nb.value_at_risk_1d_nb">value_at_risk_1d_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def value_at_risk_nb(returns, cutoff=0.05):
    &#34;&#34;&#34;2-dim version of `value_at_risk_1d_nb`.&#34;&#34;&#34;
    result = np.empty(returns.shape[1], dtype=f8)
    for col in range(returns.shape[1]):
        result[col] = value_at_risk_1d_nb(returns[:, col], cutoff=cutoff)
    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="https://github.com/polakowo/vectorbt/blob/master/logo.png?raw=true" alt=""> vectorbt
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.portfolio" href="index.html">vectorbt.portfolio</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.portfolio.nb.alpha_1d_nb" href="#vectorbt.portfolio.nb.alpha_1d_nb">alpha_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.alpha_nb" href="#vectorbt.portfolio.nb.alpha_nb">alpha_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.annualized_return_1d_nb" href="#vectorbt.portfolio.nb.annualized_return_1d_nb">annualized_return_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.annualized_return_nb" href="#vectorbt.portfolio.nb.annualized_return_nb">annualized_return_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.annualized_volatility_1d_nb" href="#vectorbt.portfolio.nb.annualized_volatility_1d_nb">annualized_volatility_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.annualized_volatility_nb" href="#vectorbt.portfolio.nb.annualized_volatility_nb">annualized_volatility_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.beta_1d_nb" href="#vectorbt.portfolio.nb.beta_1d_nb">beta_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.beta_nb" href="#vectorbt.portfolio.nb.beta_nb">beta_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.buy_nb" href="#vectorbt.portfolio.nb.buy_nb">buy_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.calmar_ratio_1d_nb" href="#vectorbt.portfolio.nb.calmar_ratio_1d_nb">calmar_ratio_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.calmar_ratio_nb" href="#vectorbt.portfolio.nb.calmar_ratio_nb">calmar_ratio_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.capture_1d_nb" href="#vectorbt.portfolio.nb.capture_1d_nb">capture_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.capture_nb" href="#vectorbt.portfolio.nb.capture_nb">capture_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.conditional_value_at_risk_1d_nb" href="#vectorbt.portfolio.nb.conditional_value_at_risk_1d_nb">conditional_value_at_risk_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.conditional_value_at_risk_nb" href="#vectorbt.portfolio.nb.conditional_value_at_risk_nb">conditional_value_at_risk_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.count_reduce_func_nb" href="#vectorbt.portfolio.nb.count_reduce_func_nb">count_reduce_func_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.cum_returns_1d_nb" href="#vectorbt.portfolio.nb.cum_returns_1d_nb">cum_returns_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.cum_returns_final_1d_nb" href="#vectorbt.portfolio.nb.cum_returns_final_1d_nb">cum_returns_final_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.cum_returns_final_nb" href="#vectorbt.portfolio.nb.cum_returns_final_nb">cum_returns_final_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.cum_returns_nb" href="#vectorbt.portfolio.nb.cum_returns_nb">cum_returns_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.down_capture_1d_nb" href="#vectorbt.portfolio.nb.down_capture_1d_nb">down_capture_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.down_capture_nb" href="#vectorbt.portfolio.nb.down_capture_nb">down_capture_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.downside_risk_1d_nb" href="#vectorbt.portfolio.nb.downside_risk_1d_nb">downside_risk_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.downside_risk_nb" href="#vectorbt.portfolio.nb.downside_risk_nb">downside_risk_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.duration_map_func_nb" href="#vectorbt.portfolio.nb.duration_map_func_nb">duration_map_func_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.field_map_func_nb" href="#vectorbt.portfolio.nb.field_map_func_nb">field_map_func_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.fill_order_nb" href="#vectorbt.portfolio.nb.fill_order_nb">fill_order_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.information_ratio_1d_nb" href="#vectorbt.portfolio.nb.information_ratio_1d_nb">information_ratio_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.information_ratio_nb" href="#vectorbt.portfolio.nb.information_ratio_nb">information_ratio_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.map_records_to_matrix_nb" href="#vectorbt.portfolio.nb.map_records_to_matrix_nb">map_records_to_matrix_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.omega_ratio_1d_nb" href="#vectorbt.portfolio.nb.omega_ratio_1d_nb">omega_ratio_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.omega_ratio_nb" href="#vectorbt.portfolio.nb.omega_ratio_nb">omega_ratio_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.position_records_nb" href="#vectorbt.portfolio.nb.position_records_nb">position_records_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.reduce_records_nb" href="#vectorbt.portfolio.nb.reduce_records_nb">reduce_records_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.sell_nb" href="#vectorbt.portfolio.nb.sell_nb">sell_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.sharpe_ratio_1d_nb" href="#vectorbt.portfolio.nb.sharpe_ratio_1d_nb">sharpe_ratio_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.sharpe_ratio_nb" href="#vectorbt.portfolio.nb.sharpe_ratio_nb">sharpe_ratio_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.signals_order_func_nb" href="#vectorbt.portfolio.nb.signals_order_func_nb">signals_order_func_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.simulate_from_orders_nb" href="#vectorbt.portfolio.nb.simulate_from_orders_nb">simulate_from_orders_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.simulate_from_signals_nb" href="#vectorbt.portfolio.nb.simulate_from_signals_nb">simulate_from_signals_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.simulate_nb" href="#vectorbt.portfolio.nb.simulate_nb">simulate_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.size_order_func_nb" href="#vectorbt.portfolio.nb.size_order_func_nb">size_order_func_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.sortino_ratio_1d_nb" href="#vectorbt.portfolio.nb.sortino_ratio_1d_nb">sortino_ratio_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.sortino_ratio_nb" href="#vectorbt.portfolio.nb.sortino_ratio_nb">sortino_ratio_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.tail_ratio_1d_nb" href="#vectorbt.portfolio.nb.tail_ratio_1d_nb">tail_ratio_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.tail_ratio_nb" href="#vectorbt.portfolio.nb.tail_ratio_nb">tail_ratio_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.total_return_apply_func_nb" href="#vectorbt.portfolio.nb.total_return_apply_func_nb">total_return_apply_func_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.trade_records_nb" href="#vectorbt.portfolio.nb.trade_records_nb">trade_records_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.up_capture_1d_nb" href="#vectorbt.portfolio.nb.up_capture_1d_nb">up_capture_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.up_capture_nb" href="#vectorbt.portfolio.nb.up_capture_nb">up_capture_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.value_at_risk_1d_nb" href="#vectorbt.portfolio.nb.value_at_risk_1d_nb">value_at_risk_1d_nb</a></code></li>
<li><code><a title="vectorbt.portfolio.nb.value_at_risk_nb" href="#vectorbt.portfolio.nb.value_at_risk_nb">value_at_risk_nb</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>