<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.portfolio.main API documentation</title>
<meta name="description" content="Main class for modeling portfolio performance â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://github.com/polakowo/vectorbt/blob/master/logo.png?raw=true">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.portfolio.main</code></h1>
</header>
<section id="section-intro">
<p>Main class for modeling portfolio performance.</p>
<p>The job of the <code><a title="vectorbt.portfolio.main.Portfolio" href="#vectorbt.portfolio.main.Portfolio">Portfolio</a></code> class is to create a series of positions allocated
against a cash component, produce an equity curve, incorporate basic transaction costs
and produce a set of statistics about its performance. In particular it outputs
position/profit metrics and drawdown information.</p>
<h2 id="workflow">Workflow</h2>
<p><code><a title="vectorbt.portfolio.main.Portfolio" href="#vectorbt.portfolio.main.Portfolio">Portfolio</a></code> class can be instantiated using main price of the asset, initial capital,
records of filled orders, and cash and shares balances (as a result of filling orders).
It also accepts many other parameters such as annualization factor.</p>
<ul>
<li>Order records are used to track trades and positions, and to measure their performance.</li>
<li>Main price, initial capital, and balances are used to compute risk and performance metrics.</li>
</ul>
<p>To simplify creation of order records and keeping track of balances, it exposes several convenience methods
with prefix <code>from_</code>. For example, you can use <code><a title="vectorbt.portfolio.main.Portfolio.from_signals" href="#vectorbt.portfolio.main.Portfolio.from_signals">Portfolio.from_signals()</a></code> method to create and fill orders
based on entry and exit signals. Alternatively, you can use <code><a title="vectorbt.portfolio.main.Portfolio.from_order_func" href="#vectorbt.portfolio.main.Portfolio.from_order_func">Portfolio.from_order_func()</a></code> to define
a custom order function. The results are then automatically passed to the constructor method of
<code><a title="vectorbt.portfolio.main.Portfolio" href="#vectorbt.portfolio.main.Portfolio">Portfolio</a></code> and you will receive a portfolio instance ready to be used for performance measurements.</p>
<h2 id="properties">Properties</h2>
<p>The <code><a title="vectorbt.portfolio.main.Portfolio" href="#vectorbt.portfolio.main.Portfolio">Portfolio</a></code> class offers numerous properties for measuring the performance of a strategy.
They can be categorized as follows:</p>
<ul>
<li>Time series indexed by time, such as <code><a title="vectorbt.portfolio.main.Portfolio.equity" href="#vectorbt.portfolio.main.Portfolio.equity">Portfolio.equity</a></code>.</li>
<li>Metrics indexed by columns, such as <code><a title="vectorbt.portfolio.main.Portfolio.total_profit" href="#vectorbt.portfolio.main.Portfolio.total_profit">Portfolio.total_profit</a></code>.</li>
<li>Group objects with own time series and metrics, such as <code><a title="vectorbt.portfolio.main.Portfolio.positions" href="#vectorbt.portfolio.main.Portfolio.positions">Portfolio.positions</a></code>.</li>
</ul>
<h3 id="caching">Caching</h3>
<p>Each property is cached, thus properties can effectively build upon each other. </p>
<p>Take for example the <code><a title="vectorbt.portfolio.main.Portfolio.max_drawdown" href="#vectorbt.portfolio.main.Portfolio.max_drawdown">Portfolio.max_drawdown</a></code> property: it depends upon <code><a title="vectorbt.portfolio.main.Portfolio.drawdown" href="#vectorbt.portfolio.main.Portfolio.drawdown">Portfolio.drawdown</a></code>,
which in turn depends upon <code><a title="vectorbt.portfolio.main.Portfolio.equity" href="#vectorbt.portfolio.main.Portfolio.equity">Portfolio.equity</a></code>, and so on. Without caching, <code><a title="vectorbt.portfolio.main.Portfolio.max_drawdown" href="#vectorbt.portfolio.main.Portfolio.max_drawdown">Portfolio.max_drawdown</a></code>
would have re-calculated everything starting from equity, each time.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code><a title="vectorbt.portfolio.main.Portfolio" href="#vectorbt.portfolio.main.Portfolio">Portfolio</a></code> class is meant to be immutable due to caching, thus each public attribute is
marked as read-only. To change an attribute, you need to create a new Portfolio instance.</p>
</div>
<h3 id="property-hierarchy">Property hierarchy</h3>
<p>All those properties are building a hierarchy with time series and metrics as leafs, and group
objects as nodes. By implementing custom cachable property classes <code><a title="vectorbt.portfolio.common.timeseries_property" href="common.html#vectorbt.portfolio.common.timeseries_property">timeseries_property</a></code>
and <code><a title="vectorbt.portfolio.common.metric_property" href="common.html#vectorbt.portfolio.common.metric_property">metric_property</a></code>, we are also able to encode information into each property,
such as the full name of a metric and its display format. And by defining the group properties with
<code><a title="vectorbt.portfolio.common.group_property" href="common.html#vectorbt.portfolio.common.group_property">group_property</a></code>, we are able to define gateaway points that can be easily traversed.</p>
<pre><code class="plaintext">Portfolio
+-- @timeseries_property
+-- @metric_property
+-- @records_property
+-- ...
+-- @group_property
    +-- @timeseries_property
    +-- @metric_property
    +-- @records_property
    +-- ...
</code></pre>
<p>This way, the <code><a title="vectorbt.portfolio.main.Portfolio" href="#vectorbt.portfolio.main.Portfolio">Portfolio</a></code> class acts as an extendable tree data structure for properties with
annotations. Instead of hard-coding the list of available time series and metrics with something
like <code>_PERFORMANCE_METRICS_PROPS</code>, we can call <code><a title="vectorbt.portfolio.main.Portfolio.traverse_properties" href="common.html#vectorbt.portfolio.common.PropertyTraverser.traverse_properties">PropertyTraverser.traverse_properties()</a></code> and build the list on the fly.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Hierarchy and annotations are only visible when traversing the class, not the class instance.
To add a new attribute to the hierarchy, you need to subclass <code><a title="vectorbt.portfolio.main.Portfolio" href="#vectorbt.portfolio.main.Portfolio">Portfolio</a></code> and define your
properties there. Each property must be a subclass of <code><a title="vectorbt.utils.decorators.custom_property" href="../utils/decorators.html#vectorbt.utils.decorators.custom_property">custom_property</a></code>.</p>
</div>
<pre><code class="py">import vectorbt as vbt
import numpy as np
import pandas as pd
from numba import njit
from datetime import datetime
index = pd.Index([
    datetime(2018, 1, 1),
    datetime(2018, 1, 2),
    datetime(2018, 1, 3),
    datetime(2018, 1, 4),
    datetime(2018, 1, 5)
])
price = pd.Series([1, 2, 3, 2, 1], index=index, name='a')
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Main class for modeling portfolio performance.

The job of the `Portfolio` class is to create a series of positions allocated 
    against a cash component, produce an equity curve, incorporate basic transaction costs 
    and produce a set of statistics about its performance. In particular it outputs 
    position/profit metrics and drawdown information.

## Workflow

`Portfolio` class can be instantiated using main price of the asset, initial capital, 
records of filled orders, and cash and shares balances (as a result of filling orders).
It also accepts many other parameters such as annualization factor.

* Order records are used to track trades and positions, and to measure their performance.
* Main price, initial capital, and balances are used to compute risk and performance metrics.

To simplify creation of order records and keeping track of balances, it exposes several convenience methods
with prefix `from_`. For example, you can use `Portfolio.from_signals` method to create and fill orders 
based on entry and exit signals. Alternatively, you can use `Portfolio.from_order_func` to define 
a custom order function. The results are then automatically passed to the constructor method of 
`Portfolio` and you will receive a portfolio instance ready to be used for performance measurements.

## Properties

The `Portfolio` class offers numerous properties for measuring the performance of a strategy. 
They can be categorized as follows:

* Time series indexed by time, such as `Portfolio.equity`.
* Metrics indexed by columns, such as `Portfolio.total_profit`.
* Group objects with own time series and metrics, such as `Portfolio.positions`.

### Caching

Each property is cached, thus properties can effectively build upon each other. 

Take for example the `Portfolio.max_drawdown` property: it depends upon `Portfolio.drawdown`,
which in turn depends upon `Portfolio.equity`, and so on. Without caching, `Portfolio.max_drawdown` 
would have re-calculated everything starting from equity, each time.

!!! note
    `Portfolio` class is meant to be immutable due to caching, thus each public attribute is
    marked as read-only. To change an attribute, you need to create a new Portfolio instance.
    
### Property hierarchy

All those properties are building a hierarchy with time series and metrics as leafs, and group 
objects as nodes. By implementing custom cachable property classes `vectorbt.portfolio.common.timeseries_property` 
and `vectorbt.portfolio.common.metric_property`, we are also able to encode information into each property, 
such as the full name of a metric and its display format. And by defining the group properties with 
`vectorbt.portfolio.common.group_property`, we are able to define gateaway points that can be easily traversed.

```plaintext
Portfolio
+-- @timeseries_property
+-- @metric_property
+-- @records_property
+-- ...
+-- @group_property
    +-- @timeseries_property
    +-- @metric_property
    +-- @records_property
    +-- ...
```

This way, the `Portfolio` class acts as an extendable tree data structure for properties with 
annotations. Instead of hard-coding the list of available time series and metrics with something 
like `_PERFORMANCE_METRICS_PROPS`, we can call `Portfolio.traverse_properties` and build the list on the fly.

!!! note
    Hierarchy and annotations are only visible when traversing the class, not the class instance.
    To add a new attribute to the hierarchy, you need to subclass `Portfolio` and define your
    properties there. Each property must be a subclass of `vectorbt.utils.decorators.custom_property`.
    
```py
import vectorbt as vbt
import numpy as np
import pandas as pd
from numba import njit
from datetime import datetime
index = pd.Index([
    datetime(2018, 1, 1),
    datetime(2018, 1, 2),
    datetime(2018, 1, 3),
    datetime(2018, 1, 4),
    datetime(2018, 1, 5)
])
price = pd.Series([1, 2, 3, 2, 1], index=index, name=&#39;a&#39;)
```&#34;&#34;&#34;

import numpy as np
import pandas as pd
from datetime import timedelta
from scipy import stats

from vectorbt import timeseries, accessors, defaults
from vectorbt.utils import checks, reshape_fns
from vectorbt.utils.config import merge_kwargs
from vectorbt.portfolio import nb
from vectorbt.portfolio.records import Orders, Trades, Positions
from vectorbt.portfolio.enums import OrderRecord, TradeRecord, PositionRecord
from vectorbt.portfolio.common import (
    TSRArrayWrapper,
    timeseries_property,
    metric_property,
    records_property,
    group_property,
    PropertyTraverser
)


class Portfolio(PropertyTraverser):
    &#34;&#34;&#34;Class for building a portfolio and measuring its performance.

    Args:
        price (pandas_like): Main price of the asset.
        init_capital (int or float): The initial capital.
        order_records (array_like): Records of type `vectorbt.portfolio.enums.OrderRecord`.
        cash (pandas_like): Cash held at each time step.
        shares (pandas_like): Shares held at each time step.
        data_freq (any): Data frequency in case `price.index` is not datetime-like. 

            Will be passed to `pandas.to_timedelta`.
        year_freq (any): Year frequency. Will be passed to `pandas.to_timedelta`.
        risk_free (float): Constant risk-free return throughout the period.
        required_return (float): Minimum acceptance return of the investor.
        cutoff (float): Decimal representing the percentage cutoff for the bottom percentile of returns.
        factor_returns (pandas_like): Benchmark return to compare returns against. 

            If set, will be broadcasted to the shape of `price`.

    For defaults, see `vectorbt.defaults.portfolio`.

    !!! note
        Use class methods with `from_` prefix to build a portfolio.
        The `__init__` method is reserved for indexing purposes.

        All array objects must have the same metadata as `price`.&#34;&#34;&#34;

    def __init__(self, price, init_capital, order_records, cash, shares, data_freq=None,
                 year_freq=None, risk_free=None, required_return=None, cutoff=None, factor_returns=None):
        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_type(order_records, np.ndarray)
        checks.assert_same_shape(order_records, OrderRecord, axis=(1, 0))
        checks.assert_same_meta(price, cash)
        checks.assert_same_meta(price, shares)

        # Main parameters
        self._price = price
        self._init_capital = init_capital
        self._order_records = order_records
        self._cash = cash
        self._shares = shares

        # Other parameters
        if data_freq is None:
            data_freq = price.vbt.timeseries.timedelta
        else:
            data_freq = pd.to_timedelta(data_freq)
        self._data_freq = data_freq
        year_freq = defaults.portfolio[&#39;year_freq&#39;] if year_freq is None else year_freq
        year_freq = pd.to_timedelta(year_freq)
        self._year_freq = year_freq
        self._ann_factor = year_freq / data_freq
        self._risk_free = defaults.portfolio[&#39;risk_free&#39;] if risk_free is None else risk_free
        self._required_return = defaults.portfolio[&#39;required_return&#39;] if required_return is None else required_return
        self._cutoff = defaults.portfolio[&#39;cutoff&#39;] if cutoff is None else cutoff
        if factor_returns is not None:
            factor_returns = reshape_fns.broadcast_to(factor_returns, price)
        self._factor_returns = factor_returns

        # Supercharge
        self.wrapper = TSRArrayWrapper.from_obj(price)

    # ############# Class methods ############# #

    @classmethod
    def from_signals(cls, price, entries, exits, size=np.inf, entry_price=None, exit_price=None, init_capital=None,
                     fees=None, fixed_fees=None, slippage=None, accumulate=False, broadcast_kwargs={}, **kwargs):
        &#34;&#34;&#34;Build portfolio from entry and exit signals.

        At each entry signal in `entries`, buys `size` of shares for `entry_price` to enter
        a position. At each exit signal in `exits`, sells everything for `exit_price` 
        to exit the position. Accumulation of orders is disabled by default.

        Args:
            price (pandas_like): Main price of the asset, such as close.
            entries (array_like): Boolean array of entry signals.
            exits (array_like): Boolean array of exit signals.
            size (int, float or array_like): The amount of shares to order. 

                To buy/sell everything, set the size to `numpy.inf`.
            entry_price (array_like): Entry price. Defaults to `price`.
            exit_price (array_like): Exit price. Defaults to `price`.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Fees in percentage of the order value.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order.
            slippage (float or array_like): Slippage in percentage of price.
            accumulate (bool): If `accumulate` is `True`, entering the market when already 
                in the market will be allowed to increase a position.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast` 
        with `broadcast_kwargs`. At the end, all array objects will have the same metadata.

        Example:
            Portfolio from various signal sequences:
            ```python-repl
            &gt;&gt;&gt; entries = pd.DataFrame({
            ...     &#39;a&#39;: [True, False, False, False, False],
            ...     &#39;b&#39;: [True, False, True, False, True],
            ...     &#39;c&#39;: [True, True, True, True, True]
            ... }, index=index)
            &gt;&gt;&gt; exits = pd.DataFrame({
            ...     &#39;a&#39;: [False, False, False, False, False],
            ...     &#39;b&#39;: [False, True, False, True, False],
            ...     &#39;c&#39;: [True, True, True, True, True]
            ... }, index=index)
            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
            ...     price, entries, exits, size=10,
            ...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

            &gt;&gt;&gt; print(portfolio.order_records)
               Column  Index  Size  Price      Fees  Side
            0     0.0    0.0  10.0  1.001  1.025025   0.0
            1     1.0    0.0  10.0  1.001  1.025025   0.0
            2     1.0    1.0  10.0  1.998  1.049950   1.0
            3     1.0    2.0  10.0  3.003  1.075075   0.0
            4     1.0    3.0  10.0  1.998  1.049950   1.0
            5     1.0    4.0  10.0  1.001  1.025025   0.0
            6     2.0    0.0  10.0  1.001  1.025025   0.0
            &gt;&gt;&gt; print(portfolio.shares)
                           a     b     c
            2018-01-01  10.0  10.0  10.0
            2018-01-02  10.0   0.0  10.0
            2018-01-03  10.0  10.0  10.0
            2018-01-04  10.0   0.0  10.0
            2018-01-05  10.0  10.0  10.0
            &gt;&gt;&gt; print(portfolio.cash)
                                a           b          c
            2018-01-01  88.964975   88.964975  88.964975
            2018-01-02  88.964975  107.895025  88.964975
            2018-01-03  88.964975   76.789950  88.964975
            2018-01-04  88.964975   95.720000  88.964975
            2018-01-05  88.964975   84.684975  88.964975
            ```
        &#34;&#34;&#34;
        # Get defaults
        if entry_price is None:
            entry_price = price
        if exit_price is None:
            exit_price = price
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_dtype(entries, np.bool_)
        checks.assert_dtype(exits, np.bool_)

        # Broadcast inputs
        price, entries, exits, size, entry_price, exit_price, fees, fixed_fees, slippage = \
            reshape_fns.broadcast(price, entries, exits, size, entry_price, exit_price, fees,
                                  fixed_fees, slippage, **broadcast_kwargs, writeable=True)

        # Perform calculation
        order_records, cash, shares = nb.simulate_from_signals_nb(
            reshape_fns.to_2d(price, raw=True).shape,
            init_capital,
            reshape_fns.to_2d(entries, raw=True),
            reshape_fns.to_2d(exits, raw=True),
            reshape_fns.to_2d(size, raw=True),
            reshape_fns.to_2d(entry_price, raw=True),
            reshape_fns.to_2d(exit_price, raw=True),
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(fixed_fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            accumulate)

        # Bring to the same meta
        cash = price.vbt.wrap(cash)
        shares = price.vbt.wrap(shares)

        return cls(price, init_capital, order_records, cash, shares, **kwargs)

    @classmethod
    def from_orders(cls, price, order_size, order_price=None, init_capital=None, fees=None, fixed_fees=None,
                    slippage=None, is_target=False, broadcast_kwargs={}, **kwargs):
        &#34;&#34;&#34;Build portfolio from orders.

        Starting with initial capital `init_capital`, at each time step, orders the number 
        of shares specified in `order_size` for `order_price`. 

        Args:
            price (pandas_like): Main price of the asset, such as close.
            order_size (int, float or array_like): The amount of shares to order. 

                If the size is positive, this is the number of shares to buy. 
                If the size is negative, this is the number of shares to sell.
                To buy/sell everything, set the size to `numpy.inf`.
            order_price (array_like): Order price. Defaults to `price`.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Fees in percentage of the order value.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order.
            slippage (float or array_like): Slippage in percentage of `order_price`.
            is_target (bool): If `True`, will order the difference between current and target size.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast` 
        with `broadcast_kwargs`. At the end, all array objects will have the same metadata.

        Example:
            Portfolio from various order sequences:
            ```python-repl
            &gt;&gt;&gt; orders = pd.DataFrame({
            ...     &#39;a&#39;: [np.inf, 0, 0, 0, 0],
            ...     &#39;b&#39;: [1, 1, 1, 1, -np.inf],
            ...     &#39;c&#39;: [np.inf, -np.inf, np.inf, -np.inf, np.inf]
            ... }, index=index)
            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
            ...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

            &gt;&gt;&gt; print(portfolio.order_records)
                Column  Index        Size  Price      Fees  Side
            0      0.0    0.0   98.654463  1.001  1.246883   0.0
            1      1.0    0.0    1.000000  1.001  1.002502   0.0
            2      1.0    1.0    1.000000  2.002  1.005005   0.0
            3      1.0    2.0    1.000000  3.003  1.007507   0.0
            4      1.0    3.0    1.000000  2.002  1.005005   0.0
            5      1.0    4.0    4.000000  0.999  1.009990   1.0
            6      2.0    0.0   98.654463  1.001  1.246883   0.0
            7      2.0    1.0   98.654463  1.998  1.492779   1.0
            8      2.0    2.0   64.646521  3.003  1.485334   0.0
            9      2.0    3.0   64.646521  1.998  1.322909   1.0
            10     2.0    4.0  126.398131  1.001  1.316311   0.0
            &gt;&gt;&gt; print(portfolio.shares)
                                a    b           c
            2018-01-01  98.654463  1.0   98.654463
            2018-01-02  98.654463  2.0    0.000000
            2018-01-03  98.654463  3.0   64.646521
            2018-01-04  98.654463  4.0    0.000000
            2018-01-05  98.654463  0.0  126.398131
            &gt;&gt;&gt; print(portfolio.cash)
                          a          b             c
            2018-01-01  0.0  97.996498  0.000000e+00
            2018-01-02  0.0  94.989493  1.956188e+02
            2018-01-03  0.0  90.978985  2.842171e-14
            2018-01-04  0.0  87.971980  1.278408e+02
            2018-01-05  0.0  90.957990  0.000000e+00
            ```
        &#34;&#34;&#34;
        # Get defaults
        if order_price is None:
            order_price = price
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))

        # Broadcast inputs
        price, order_size, order_price, fees, fixed_fees, slippage = \
            reshape_fns.broadcast(price, order_size, order_price, fees, fixed_fees,
                                  slippage, **broadcast_kwargs, writeable=True)

        # Perform calculation
        order_records, cash, shares = nb.simulate_from_orders_nb(
            reshape_fns.to_2d(price, raw=True).shape,
            init_capital,
            reshape_fns.to_2d(order_size, raw=True),
            reshape_fns.to_2d(order_price, raw=True),
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(fixed_fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            is_target)

        # Bring to the same meta
        cash = price.vbt.wrap(cash)
        shares = price.vbt.wrap(shares)

        return cls(price, init_capital, order_records, cash, shares, **kwargs)

    @classmethod
    def from_order_func(cls, price, order_func_nb, *args, init_capital=None, **kwargs):
        &#34;&#34;&#34;Build portfolio from a custom order function.

        Starting with initial capital `init_capital`, iterates over shape `price.shape`, and for 
        each data point, generates an order using `order_func_nb`. This way, you can specify order 
        size, price and transaction costs dynamically (for example, based on the current balance).

        To iterate over a bigger shape than `price`, you should tile/repeat `price` to the desired shape.

        Args:
            price (pandas_like): Main price of the asset, such as close.

                Must be a pandas object.
            order_func_nb (function): Function that returns an order. 

                See `vectorbt.portfolio.enums.Order`.
            *args: Arguments passed to `order_func_nb`.
            init_capital (int or float): The initial capital.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        !!! note
            `order_func_nb` must be Numba-compiled.

        Example:
            Portfolio from buying daily:
            ```python-repl
            &gt;&gt;&gt; from vectorbt.portfolio.nb import Order

            &gt;&gt;&gt; @njit
            ... def order_func_nb(col, i, run_cash, run_shares, price):
            ...     return Order(10, price[i], fees=0.01, fixed_fees=1., slippage=0.01)

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
            ...     price, order_func_nb, price.values, init_capital=100)

            &gt;&gt;&gt; print(portfolio.order_records)
               Column  Index  Size  Price   Fees  Side
            0     0.0    0.0  10.0   1.01  1.101   0.0
            1     0.0    1.0  10.0   2.02  1.202   0.0
            2     0.0    2.0  10.0   3.03  1.303   0.0
            3     0.0    3.0  10.0   2.02  1.202   0.0
            4     0.0    4.0  10.0   1.01  1.101   0.0
            &gt;&gt;&gt; print(portfolio.shares)
            2018-01-01    10.0
            2018-01-02    20.0
            2018-01-03    30.0
            2018-01-04    40.0
            2018-01-05    50.0
            Name: a, dtype: float64
            &gt;&gt;&gt; print(portfolio.cash)
            2018-01-01    88.799
            2018-01-02    67.397
            2018-01-03    35.794
            2018-01-04    14.392
            2018-01-05     3.191
            Name: a, dtype: float64
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_numba_func(order_func_nb)

        # Perform calculation
        order_records, cash, shares = nb.simulate_nb(
            reshape_fns.to_2d(price, raw=True).shape,
            init_capital,
            order_func_nb,
            *args)

        # Bring to the same meta
        cash = price.vbt.wrap(cash)
        shares = price.vbt.wrap(shares)

        return cls(price, init_capital, order_records, cash, shares, **kwargs)

    # ############# Passed properties ############# #

    @property
    def init_capital(self):
        &#34;&#34;&#34;Initial capital.&#34;&#34;&#34;
        return self._init_capital

    @timeseries_property(&#39;Price&#39;)
    def price(self):
        &#34;&#34;&#34;Price per share at each time step.&#34;&#34;&#34;
        return self._price

    @timeseries_property(&#39;Cash&#39;)
    def cash(self):
        &#34;&#34;&#34;Cash held at each time step.&#34;&#34;&#34;
        return self._cash

    @timeseries_property(&#39;Shares&#39;)
    def shares(self):
        &#34;&#34;&#34;Shares held at each time step.&#34;&#34;&#34;
        return self._shares

    # ############# User-defined parameters ############# #

    @property
    def data_freq(self):
        &#34;&#34;&#34;Data frequency.&#34;&#34;&#34;
        return self._data_freq

    @property
    def year_freq(self):
        &#34;&#34;&#34;Year frequency.&#34;&#34;&#34;
        return self._year_freq

    @property
    def ann_factor(self):
        &#34;&#34;&#34;Annualization factor.&#34;&#34;&#34;
        return self._ann_factor

    @property
    def risk_free(self):
        &#34;&#34;&#34;Constant risk-free return throughout the period.&#34;&#34;&#34;
        return self._risk_free

    @property
    def required_return(self):
        &#34;&#34;&#34;Minimum acceptance return of the investor.&#34;&#34;&#34;
        return self._required_return

    @property
    def cutoff(self):
        &#34;&#34;&#34;Decimal representing the percentage cutoff for the bottom percentile of returns.&#34;&#34;&#34;
        return self._cutoff

    @property
    def factor_returns(self):
        &#34;&#34;&#34;Benchmark return to compare returns against.&#34;&#34;&#34;
        return self._factor_returns

    # ############# Orders ############# #

    @records_property(&#39;Order records&#39;)
    def order_records(self):
        &#34;&#34;&#34;Records of type `vectorbt.portfolio.enums.OrderRecord`.&#34;&#34;&#34;
        return self.wrapper.wrap_records(self._order_records, OrderRecord)

    @group_property(&#39;Orders&#39;, Orders)
    def orders(self):
        &#34;&#34;&#34;Time series and metrics based on order records.&#34;&#34;&#34;
        return Orders(self.wrapper, self._order_records)

    # ############# Trades ############# #

    @records_property(&#39;Trade records&#39;)
    def trade_records(self):
        &#34;&#34;&#34;Records of type `vectorbt.portfolio.enums.TradeRecord`.&#34;&#34;&#34;
        trade_records = nb.trade_records_nb(self.price.vbt.to_2d_array(), self._order_records)
        return self.wrapper.wrap_records(trade_records, TradeRecord)

    @group_property(&#39;Trades&#39;, Trades)
    def trades(self):
        &#34;&#34;&#34;Time series and metrics based on trade records.&#34;&#34;&#34;
        return Trades(self.wrapper, self.trade_records.vbt.to_array())

    # ############# Positions ############# #

    @records_property(&#39;Position records&#39;)
    def position_records(self):
        &#34;&#34;&#34;Records of type `vectorbt.portfolio.enums.PositionRecord`.&#34;&#34;&#34;
        position_records = nb.position_records_nb(self.price.vbt.to_2d_array(), self._order_records)
        return self.wrapper.wrap_records(position_records, PositionRecord)

    @group_property(&#39;Positions&#39;, Positions)
    def positions(self):
        &#34;&#34;&#34;Time series and metrics based on position records.&#34;&#34;&#34;
        return Positions(self.wrapper, self.position_records.vbt.to_array())

    # ############# Equity ############# #

    @timeseries_property(&#39;Equity&#39;)
    def equity(self):
        &#34;&#34;&#34;Equity.&#34;&#34;&#34;
        equity = self.cash.vbt.to_2d_array() + self.shares.vbt.to_2d_array() * self.price.vbt.to_2d_array()
        return self.wrapper.wrap(equity)

    @metric_property(&#39;Total profit&#39;)
    def total_profit(self):
        &#34;&#34;&#34;Total profit.&#34;&#34;&#34;
        total_profit = self.equity.vbt.to_2d_array()[-1, :] - self.init_capital
        return self.wrapper.wrap_reduced(total_profit)

    # ############# Returns ############# #

    @timeseries_property(&#39;Returns&#39;)
    def returns(self):
        &#34;&#34;&#34;Portfolio returns.&#34;&#34;&#34;
        returns = timeseries.nb.pct_change_nb(self.equity.vbt.to_2d_array())
        return self.wrapper.wrap(returns)

    @timeseries_property(&#39;Daily returns&#39;)
    def daily_returns(self):
        &#34;&#34;&#34;Daily returns.&#34;&#34;&#34;
        if self.returns.index.inferred_freq == &#39;D&#39;:
            return self.returns
        return self.returns.vbt.timeseries.resample_apply(&#39;D&#39;, nb.total_return_apply_func_nb)

    @timeseries_property(&#39;Annual returns&#39;)
    def annual_returns(self):
        &#34;&#34;&#34;Annual returns.&#34;&#34;&#34;
        if self.returns.index.inferred_freq == &#39;Y&#39;:
            return self.returns
        return self.returns.vbt.timeseries.resample_apply(&#39;Y&#39;, nb.total_return_apply_func_nb)

    @metric_property(&#39;Total return&#39;)
    def total_return(self):
        &#34;&#34;&#34;Total return.&#34;&#34;&#34;
        total_return = reshape_fns.to_1d(self.total_profit, raw=True) / self.init_capital
        return self.wrapper.wrap_reduced(total_return)

    # ############# Drawdown ############# #

    @timeseries_property(&#39;Drawdown&#39;)
    def drawdown(self):
        &#34;&#34;&#34;Relative decline from a peak.&#34;&#34;&#34;
        equity = self.equity.vbt.to_2d_array()
        drawdown = 1 - equity / timeseries.nb.expanding_max_nb(equity)
        return self.wrapper.wrap(drawdown)

    @metric_property(&#39;Max drawdown&#39;)
    def max_drawdown(self):
        &#34;&#34;&#34;Total maximum drawdown (MDD).&#34;&#34;&#34;
        max_drawdown = np.max(self.drawdown.vbt.to_2d_array(), axis=0)
        return self.wrapper.wrap_reduced(max_drawdown)

    # ############# Risk and performance metrics ############# #

    @timeseries_property(&#39;Cumulative returns&#39;)
    def cum_returns(self):
        &#34;&#34;&#34;Cumulative returns.&#34;&#34;&#34;
        return self.wrapper.wrap(nb.cum_returns_nb(self.returns.vbt.to_2d_array()))

    @metric_property(&#39;Annualized return&#39;)
    def annualized_return(self):
        &#34;&#34;&#34;Mean annual growth rate of returns. 

        This is equivilent to the compound annual growth rate.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.annualized_return_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Annualized volatility&#39;)
    def annualized_volatility(self):
        &#34;&#34;&#34;Annualized volatility of a strategy.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.annualized_volatility_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Calmar ratio&#39;)
    def calmar_ratio(self):
        &#34;&#34;&#34;Calmar ratio, or drawdown ratio, of a strategy.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.calmar_ratio_nb(
            self.returns.vbt.to_2d_array(),
            reshape_fns.to_1d(self.annualized_return, raw=True),
            reshape_fns.to_1d(self.max_drawdown, raw=True),
            self.ann_factor))

    @metric_property(&#39;Omega ratio&#39;)
    def omega_ratio(self):
        &#34;&#34;&#34;Omega ratio of a strategy.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.omega_ratio_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor,
            risk_free=self.risk_free,
            required_return=self.required_return))

    @metric_property(&#39;Sharpe ratio&#39;)
    def sharpe_ratio(self):
        &#34;&#34;&#34;Sharpe ratio of a strategy.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.sharpe_ratio_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor,
            risk_free=self.risk_free))

    @metric_property(&#39;Downside risk&#39;)
    def downside_risk(self):
        &#34;&#34;&#34;Downside deviation below a threshold.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.downside_risk_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor,
            required_return=self.required_return))

    @metric_property(&#39;Sortino ratio&#39;)
    def sortino_ratio(self):
        &#34;&#34;&#34;Sortino ratio of a strategy.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.sortino_ratio_nb(
            self.returns.vbt.to_2d_array(),
            reshape_fns.to_1d(self.downside_risk, raw=True),
            self.ann_factor,
            required_return=self.required_return))

    @metric_property(&#39;Information ratio&#39;)
    def information_ratio(self):
        &#34;&#34;&#34;Information ratio of a strategy.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrapper.wrap_reduced(nb.information_ratio_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array()))

    @metric_property(&#39;Beta&#39;)
    def beta(self):
        &#34;&#34;&#34;Beta.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrapper.wrap_reduced(nb.beta_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            risk_free=self.risk_free))

    @metric_property(&#39;Annualized alpha&#39;)
    def alpha(self):
        &#34;&#34;&#34;Annualized alpha.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrapper.wrap_reduced(nb.alpha_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            reshape_fns.to_1d(self.beta, raw=True),
            self.ann_factor,
            risk_free=self.risk_free))

    @metric_property(&#39;Tail ratio&#39;)
    def tail_ratio(self):
        &#34;&#34;&#34;Ratio between the right (95%) and left tail (5%).&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.tail_ratio_nb(self.returns.vbt.to_2d_array()))

    @metric_property(&#39;Value at risk&#39;)
    def value_at_risk(self):
        &#34;&#34;&#34;Value at risk (VaR) of a returns stream.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.value_at_risk_nb(
            self.returns.vbt.to_2d_array(),
            cutoff=self.cutoff))

    @metric_property(&#39;Conditional value at risk&#39;)
    def conditional_value_at_risk(self):
        &#34;&#34;&#34;Conditional value at risk (CVaR) of a returns stream.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.conditional_value_at_risk_nb(
            self.returns.vbt.to_2d_array(),
            cutoff=self.cutoff))

    @metric_property(&#39;Capture ratio&#39;)
    def capture(self):
        &#34;&#34;&#34;Capture ratio.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrapper.wrap_reduced(nb.capture_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Capture ratio (positive)&#39;)
    def up_capture(self):
        &#34;&#34;&#34;Capture ratio for periods when the benchmark return is positive.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrapper.wrap_reduced(nb.up_capture_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Capture ratio (negative)&#39;)
    def down_capture(self):
        &#34;&#34;&#34;Capture ratio for periods when the benchmark return is negative.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrapper.wrap_reduced(nb.down_capture_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Skewness&#39;)
    def skew(self):
        &#34;&#34;&#34;Skewness of returns.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(stats.skew(self.returns.vbt.to_2d_array(), axis=0, nan_policy=&#39;omit&#39;))

    @metric_property(&#39;Kurtosis&#39;)
    def kurtosis(self):
        &#34;&#34;&#34;Kurtosis of returns.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(stats.kurtosis(self.returns.vbt.to_2d_array(), axis=0, nan_policy=&#39;omit&#39;))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.portfolio.main.Portfolio"><code class="flex name class">
<span>class <span class="ident">Portfolio</span></span>
<span>(</span><span>price, init_capital, order_records, cash, shares, data_freq=None, year_freq=None, risk_free=None, required_return=None, cutoff=None, factor_returns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for building a portfolio and measuring its performance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Main price of the asset.</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The initial capital.</dd>
<dt><strong><code>order_records</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Records of type <code><a title="vectorbt.portfolio.enums.OrderRecord" href="enums.html#vectorbt.portfolio.enums.OrderRecord">OrderRecord</a></code>.</dd>
<dt><strong><code>cash</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Cash held at each time step.</dd>
<dt><strong><code>shares</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Shares held at each time step.</dd>
<dt><strong><code>data_freq</code></strong> :&ensp;<code>any</code></dt>
<dd>
<p>Data frequency in case <code>price.index</code> is not datetime-like. </p>
<p>Will be passed to <code>pandas.to_timedelta</code>.</p>
</dd>
<dt><strong><code>year_freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Year frequency. Will be passed to <code>pandas.to_timedelta</code>.</dd>
<dt><strong><code>risk_free</code></strong> :&ensp;<code>float</code></dt>
<dd>Constant risk-free return throughout the period.</dd>
<dt><strong><code>required_return</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum acceptance return of the investor.</dd>
<dt><strong><code>cutoff</code></strong> :&ensp;<code>float</code></dt>
<dd>Decimal representing the percentage cutoff for the bottom percentile of returns.</dd>
<dt><strong><code>factor_returns</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>
<p>Benchmark return to compare returns against. </p>
<p>If set, will be broadcasted to the shape of <code>price</code>.</p>
</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.defaults.portfolio" href="../defaults.html#vectorbt.defaults.portfolio">portfolio</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use class methods with <code>from_</code> prefix to build a portfolio.
The <code>__init__</code> method is reserved for indexing purposes.</p>
<p>All array objects must have the same metadata as <code>price</code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Portfolio(PropertyTraverser):
    &#34;&#34;&#34;Class for building a portfolio and measuring its performance.

    Args:
        price (pandas_like): Main price of the asset.
        init_capital (int or float): The initial capital.
        order_records (array_like): Records of type `vectorbt.portfolio.enums.OrderRecord`.
        cash (pandas_like): Cash held at each time step.
        shares (pandas_like): Shares held at each time step.
        data_freq (any): Data frequency in case `price.index` is not datetime-like. 

            Will be passed to `pandas.to_timedelta`.
        year_freq (any): Year frequency. Will be passed to `pandas.to_timedelta`.
        risk_free (float): Constant risk-free return throughout the period.
        required_return (float): Minimum acceptance return of the investor.
        cutoff (float): Decimal representing the percentage cutoff for the bottom percentile of returns.
        factor_returns (pandas_like): Benchmark return to compare returns against. 

            If set, will be broadcasted to the shape of `price`.

    For defaults, see `vectorbt.defaults.portfolio`.

    !!! note
        Use class methods with `from_` prefix to build a portfolio.
        The `__init__` method is reserved for indexing purposes.

        All array objects must have the same metadata as `price`.&#34;&#34;&#34;

    def __init__(self, price, init_capital, order_records, cash, shares, data_freq=None,
                 year_freq=None, risk_free=None, required_return=None, cutoff=None, factor_returns=None):
        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_type(order_records, np.ndarray)
        checks.assert_same_shape(order_records, OrderRecord, axis=(1, 0))
        checks.assert_same_meta(price, cash)
        checks.assert_same_meta(price, shares)

        # Main parameters
        self._price = price
        self._init_capital = init_capital
        self._order_records = order_records
        self._cash = cash
        self._shares = shares

        # Other parameters
        if data_freq is None:
            data_freq = price.vbt.timeseries.timedelta
        else:
            data_freq = pd.to_timedelta(data_freq)
        self._data_freq = data_freq
        year_freq = defaults.portfolio[&#39;year_freq&#39;] if year_freq is None else year_freq
        year_freq = pd.to_timedelta(year_freq)
        self._year_freq = year_freq
        self._ann_factor = year_freq / data_freq
        self._risk_free = defaults.portfolio[&#39;risk_free&#39;] if risk_free is None else risk_free
        self._required_return = defaults.portfolio[&#39;required_return&#39;] if required_return is None else required_return
        self._cutoff = defaults.portfolio[&#39;cutoff&#39;] if cutoff is None else cutoff
        if factor_returns is not None:
            factor_returns = reshape_fns.broadcast_to(factor_returns, price)
        self._factor_returns = factor_returns

        # Supercharge
        self.wrapper = TSRArrayWrapper.from_obj(price)

    # ############# Class methods ############# #

    @classmethod
    def from_signals(cls, price, entries, exits, size=np.inf, entry_price=None, exit_price=None, init_capital=None,
                     fees=None, fixed_fees=None, slippage=None, accumulate=False, broadcast_kwargs={}, **kwargs):
        &#34;&#34;&#34;Build portfolio from entry and exit signals.

        At each entry signal in `entries`, buys `size` of shares for `entry_price` to enter
        a position. At each exit signal in `exits`, sells everything for `exit_price` 
        to exit the position. Accumulation of orders is disabled by default.

        Args:
            price (pandas_like): Main price of the asset, such as close.
            entries (array_like): Boolean array of entry signals.
            exits (array_like): Boolean array of exit signals.
            size (int, float or array_like): The amount of shares to order. 

                To buy/sell everything, set the size to `numpy.inf`.
            entry_price (array_like): Entry price. Defaults to `price`.
            exit_price (array_like): Exit price. Defaults to `price`.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Fees in percentage of the order value.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order.
            slippage (float or array_like): Slippage in percentage of price.
            accumulate (bool): If `accumulate` is `True`, entering the market when already 
                in the market will be allowed to increase a position.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast` 
        with `broadcast_kwargs`. At the end, all array objects will have the same metadata.

        Example:
            Portfolio from various signal sequences:
            ```python-repl
            &gt;&gt;&gt; entries = pd.DataFrame({
            ...     &#39;a&#39;: [True, False, False, False, False],
            ...     &#39;b&#39;: [True, False, True, False, True],
            ...     &#39;c&#39;: [True, True, True, True, True]
            ... }, index=index)
            &gt;&gt;&gt; exits = pd.DataFrame({
            ...     &#39;a&#39;: [False, False, False, False, False],
            ...     &#39;b&#39;: [False, True, False, True, False],
            ...     &#39;c&#39;: [True, True, True, True, True]
            ... }, index=index)
            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
            ...     price, entries, exits, size=10,
            ...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

            &gt;&gt;&gt; print(portfolio.order_records)
               Column  Index  Size  Price      Fees  Side
            0     0.0    0.0  10.0  1.001  1.025025   0.0
            1     1.0    0.0  10.0  1.001  1.025025   0.0
            2     1.0    1.0  10.0  1.998  1.049950   1.0
            3     1.0    2.0  10.0  3.003  1.075075   0.0
            4     1.0    3.0  10.0  1.998  1.049950   1.0
            5     1.0    4.0  10.0  1.001  1.025025   0.0
            6     2.0    0.0  10.0  1.001  1.025025   0.0
            &gt;&gt;&gt; print(portfolio.shares)
                           a     b     c
            2018-01-01  10.0  10.0  10.0
            2018-01-02  10.0   0.0  10.0
            2018-01-03  10.0  10.0  10.0
            2018-01-04  10.0   0.0  10.0
            2018-01-05  10.0  10.0  10.0
            &gt;&gt;&gt; print(portfolio.cash)
                                a           b          c
            2018-01-01  88.964975   88.964975  88.964975
            2018-01-02  88.964975  107.895025  88.964975
            2018-01-03  88.964975   76.789950  88.964975
            2018-01-04  88.964975   95.720000  88.964975
            2018-01-05  88.964975   84.684975  88.964975
            ```
        &#34;&#34;&#34;
        # Get defaults
        if entry_price is None:
            entry_price = price
        if exit_price is None:
            exit_price = price
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_dtype(entries, np.bool_)
        checks.assert_dtype(exits, np.bool_)

        # Broadcast inputs
        price, entries, exits, size, entry_price, exit_price, fees, fixed_fees, slippage = \
            reshape_fns.broadcast(price, entries, exits, size, entry_price, exit_price, fees,
                                  fixed_fees, slippage, **broadcast_kwargs, writeable=True)

        # Perform calculation
        order_records, cash, shares = nb.simulate_from_signals_nb(
            reshape_fns.to_2d(price, raw=True).shape,
            init_capital,
            reshape_fns.to_2d(entries, raw=True),
            reshape_fns.to_2d(exits, raw=True),
            reshape_fns.to_2d(size, raw=True),
            reshape_fns.to_2d(entry_price, raw=True),
            reshape_fns.to_2d(exit_price, raw=True),
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(fixed_fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            accumulate)

        # Bring to the same meta
        cash = price.vbt.wrap(cash)
        shares = price.vbt.wrap(shares)

        return cls(price, init_capital, order_records, cash, shares, **kwargs)

    @classmethod
    def from_orders(cls, price, order_size, order_price=None, init_capital=None, fees=None, fixed_fees=None,
                    slippage=None, is_target=False, broadcast_kwargs={}, **kwargs):
        &#34;&#34;&#34;Build portfolio from orders.

        Starting with initial capital `init_capital`, at each time step, orders the number 
        of shares specified in `order_size` for `order_price`. 

        Args:
            price (pandas_like): Main price of the asset, such as close.
            order_size (int, float or array_like): The amount of shares to order. 

                If the size is positive, this is the number of shares to buy. 
                If the size is negative, this is the number of shares to sell.
                To buy/sell everything, set the size to `numpy.inf`.
            order_price (array_like): Order price. Defaults to `price`.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Fees in percentage of the order value.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order.
            slippage (float or array_like): Slippage in percentage of `order_price`.
            is_target (bool): If `True`, will order the difference between current and target size.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast` 
        with `broadcast_kwargs`. At the end, all array objects will have the same metadata.

        Example:
            Portfolio from various order sequences:
            ```python-repl
            &gt;&gt;&gt; orders = pd.DataFrame({
            ...     &#39;a&#39;: [np.inf, 0, 0, 0, 0],
            ...     &#39;b&#39;: [1, 1, 1, 1, -np.inf],
            ...     &#39;c&#39;: [np.inf, -np.inf, np.inf, -np.inf, np.inf]
            ... }, index=index)
            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
            ...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

            &gt;&gt;&gt; print(portfolio.order_records)
                Column  Index        Size  Price      Fees  Side
            0      0.0    0.0   98.654463  1.001  1.246883   0.0
            1      1.0    0.0    1.000000  1.001  1.002502   0.0
            2      1.0    1.0    1.000000  2.002  1.005005   0.0
            3      1.0    2.0    1.000000  3.003  1.007507   0.0
            4      1.0    3.0    1.000000  2.002  1.005005   0.0
            5      1.0    4.0    4.000000  0.999  1.009990   1.0
            6      2.0    0.0   98.654463  1.001  1.246883   0.0
            7      2.0    1.0   98.654463  1.998  1.492779   1.0
            8      2.0    2.0   64.646521  3.003  1.485334   0.0
            9      2.0    3.0   64.646521  1.998  1.322909   1.0
            10     2.0    4.0  126.398131  1.001  1.316311   0.0
            &gt;&gt;&gt; print(portfolio.shares)
                                a    b           c
            2018-01-01  98.654463  1.0   98.654463
            2018-01-02  98.654463  2.0    0.000000
            2018-01-03  98.654463  3.0   64.646521
            2018-01-04  98.654463  4.0    0.000000
            2018-01-05  98.654463  0.0  126.398131
            &gt;&gt;&gt; print(portfolio.cash)
                          a          b             c
            2018-01-01  0.0  97.996498  0.000000e+00
            2018-01-02  0.0  94.989493  1.956188e+02
            2018-01-03  0.0  90.978985  2.842171e-14
            2018-01-04  0.0  87.971980  1.278408e+02
            2018-01-05  0.0  90.957990  0.000000e+00
            ```
        &#34;&#34;&#34;
        # Get defaults
        if order_price is None:
            order_price = price
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))

        # Broadcast inputs
        price, order_size, order_price, fees, fixed_fees, slippage = \
            reshape_fns.broadcast(price, order_size, order_price, fees, fixed_fees,
                                  slippage, **broadcast_kwargs, writeable=True)

        # Perform calculation
        order_records, cash, shares = nb.simulate_from_orders_nb(
            reshape_fns.to_2d(price, raw=True).shape,
            init_capital,
            reshape_fns.to_2d(order_size, raw=True),
            reshape_fns.to_2d(order_price, raw=True),
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(fixed_fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            is_target)

        # Bring to the same meta
        cash = price.vbt.wrap(cash)
        shares = price.vbt.wrap(shares)

        return cls(price, init_capital, order_records, cash, shares, **kwargs)

    @classmethod
    def from_order_func(cls, price, order_func_nb, *args, init_capital=None, **kwargs):
        &#34;&#34;&#34;Build portfolio from a custom order function.

        Starting with initial capital `init_capital`, iterates over shape `price.shape`, and for 
        each data point, generates an order using `order_func_nb`. This way, you can specify order 
        size, price and transaction costs dynamically (for example, based on the current balance).

        To iterate over a bigger shape than `price`, you should tile/repeat `price` to the desired shape.

        Args:
            price (pandas_like): Main price of the asset, such as close.

                Must be a pandas object.
            order_func_nb (function): Function that returns an order. 

                See `vectorbt.portfolio.enums.Order`.
            *args: Arguments passed to `order_func_nb`.
            init_capital (int or float): The initial capital.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        !!! note
            `order_func_nb` must be Numba-compiled.

        Example:
            Portfolio from buying daily:
            ```python-repl
            &gt;&gt;&gt; from vectorbt.portfolio.nb import Order

            &gt;&gt;&gt; @njit
            ... def order_func_nb(col, i, run_cash, run_shares, price):
            ...     return Order(10, price[i], fees=0.01, fixed_fees=1., slippage=0.01)

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
            ...     price, order_func_nb, price.values, init_capital=100)

            &gt;&gt;&gt; print(portfolio.order_records)
               Column  Index  Size  Price   Fees  Side
            0     0.0    0.0  10.0   1.01  1.101   0.0
            1     0.0    1.0  10.0   2.02  1.202   0.0
            2     0.0    2.0  10.0   3.03  1.303   0.0
            3     0.0    3.0  10.0   2.02  1.202   0.0
            4     0.0    4.0  10.0   1.01  1.101   0.0
            &gt;&gt;&gt; print(portfolio.shares)
            2018-01-01    10.0
            2018-01-02    20.0
            2018-01-03    30.0
            2018-01-04    40.0
            2018-01-05    50.0
            Name: a, dtype: float64
            &gt;&gt;&gt; print(portfolio.cash)
            2018-01-01    88.799
            2018-01-02    67.397
            2018-01-03    35.794
            2018-01-04    14.392
            2018-01-05     3.191
            Name: a, dtype: float64
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_numba_func(order_func_nb)

        # Perform calculation
        order_records, cash, shares = nb.simulate_nb(
            reshape_fns.to_2d(price, raw=True).shape,
            init_capital,
            order_func_nb,
            *args)

        # Bring to the same meta
        cash = price.vbt.wrap(cash)
        shares = price.vbt.wrap(shares)

        return cls(price, init_capital, order_records, cash, shares, **kwargs)

    # ############# Passed properties ############# #

    @property
    def init_capital(self):
        &#34;&#34;&#34;Initial capital.&#34;&#34;&#34;
        return self._init_capital

    @timeseries_property(&#39;Price&#39;)
    def price(self):
        &#34;&#34;&#34;Price per share at each time step.&#34;&#34;&#34;
        return self._price

    @timeseries_property(&#39;Cash&#39;)
    def cash(self):
        &#34;&#34;&#34;Cash held at each time step.&#34;&#34;&#34;
        return self._cash

    @timeseries_property(&#39;Shares&#39;)
    def shares(self):
        &#34;&#34;&#34;Shares held at each time step.&#34;&#34;&#34;
        return self._shares

    # ############# User-defined parameters ############# #

    @property
    def data_freq(self):
        &#34;&#34;&#34;Data frequency.&#34;&#34;&#34;
        return self._data_freq

    @property
    def year_freq(self):
        &#34;&#34;&#34;Year frequency.&#34;&#34;&#34;
        return self._year_freq

    @property
    def ann_factor(self):
        &#34;&#34;&#34;Annualization factor.&#34;&#34;&#34;
        return self._ann_factor

    @property
    def risk_free(self):
        &#34;&#34;&#34;Constant risk-free return throughout the period.&#34;&#34;&#34;
        return self._risk_free

    @property
    def required_return(self):
        &#34;&#34;&#34;Minimum acceptance return of the investor.&#34;&#34;&#34;
        return self._required_return

    @property
    def cutoff(self):
        &#34;&#34;&#34;Decimal representing the percentage cutoff for the bottom percentile of returns.&#34;&#34;&#34;
        return self._cutoff

    @property
    def factor_returns(self):
        &#34;&#34;&#34;Benchmark return to compare returns against.&#34;&#34;&#34;
        return self._factor_returns

    # ############# Orders ############# #

    @records_property(&#39;Order records&#39;)
    def order_records(self):
        &#34;&#34;&#34;Records of type `vectorbt.portfolio.enums.OrderRecord`.&#34;&#34;&#34;
        return self.wrapper.wrap_records(self._order_records, OrderRecord)

    @group_property(&#39;Orders&#39;, Orders)
    def orders(self):
        &#34;&#34;&#34;Time series and metrics based on order records.&#34;&#34;&#34;
        return Orders(self.wrapper, self._order_records)

    # ############# Trades ############# #

    @records_property(&#39;Trade records&#39;)
    def trade_records(self):
        &#34;&#34;&#34;Records of type `vectorbt.portfolio.enums.TradeRecord`.&#34;&#34;&#34;
        trade_records = nb.trade_records_nb(self.price.vbt.to_2d_array(), self._order_records)
        return self.wrapper.wrap_records(trade_records, TradeRecord)

    @group_property(&#39;Trades&#39;, Trades)
    def trades(self):
        &#34;&#34;&#34;Time series and metrics based on trade records.&#34;&#34;&#34;
        return Trades(self.wrapper, self.trade_records.vbt.to_array())

    # ############# Positions ############# #

    @records_property(&#39;Position records&#39;)
    def position_records(self):
        &#34;&#34;&#34;Records of type `vectorbt.portfolio.enums.PositionRecord`.&#34;&#34;&#34;
        position_records = nb.position_records_nb(self.price.vbt.to_2d_array(), self._order_records)
        return self.wrapper.wrap_records(position_records, PositionRecord)

    @group_property(&#39;Positions&#39;, Positions)
    def positions(self):
        &#34;&#34;&#34;Time series and metrics based on position records.&#34;&#34;&#34;
        return Positions(self.wrapper, self.position_records.vbt.to_array())

    # ############# Equity ############# #

    @timeseries_property(&#39;Equity&#39;)
    def equity(self):
        &#34;&#34;&#34;Equity.&#34;&#34;&#34;
        equity = self.cash.vbt.to_2d_array() + self.shares.vbt.to_2d_array() * self.price.vbt.to_2d_array()
        return self.wrapper.wrap(equity)

    @metric_property(&#39;Total profit&#39;)
    def total_profit(self):
        &#34;&#34;&#34;Total profit.&#34;&#34;&#34;
        total_profit = self.equity.vbt.to_2d_array()[-1, :] - self.init_capital
        return self.wrapper.wrap_reduced(total_profit)

    # ############# Returns ############# #

    @timeseries_property(&#39;Returns&#39;)
    def returns(self):
        &#34;&#34;&#34;Portfolio returns.&#34;&#34;&#34;
        returns = timeseries.nb.pct_change_nb(self.equity.vbt.to_2d_array())
        return self.wrapper.wrap(returns)

    @timeseries_property(&#39;Daily returns&#39;)
    def daily_returns(self):
        &#34;&#34;&#34;Daily returns.&#34;&#34;&#34;
        if self.returns.index.inferred_freq == &#39;D&#39;:
            return self.returns
        return self.returns.vbt.timeseries.resample_apply(&#39;D&#39;, nb.total_return_apply_func_nb)

    @timeseries_property(&#39;Annual returns&#39;)
    def annual_returns(self):
        &#34;&#34;&#34;Annual returns.&#34;&#34;&#34;
        if self.returns.index.inferred_freq == &#39;Y&#39;:
            return self.returns
        return self.returns.vbt.timeseries.resample_apply(&#39;Y&#39;, nb.total_return_apply_func_nb)

    @metric_property(&#39;Total return&#39;)
    def total_return(self):
        &#34;&#34;&#34;Total return.&#34;&#34;&#34;
        total_return = reshape_fns.to_1d(self.total_profit, raw=True) / self.init_capital
        return self.wrapper.wrap_reduced(total_return)

    # ############# Drawdown ############# #

    @timeseries_property(&#39;Drawdown&#39;)
    def drawdown(self):
        &#34;&#34;&#34;Relative decline from a peak.&#34;&#34;&#34;
        equity = self.equity.vbt.to_2d_array()
        drawdown = 1 - equity / timeseries.nb.expanding_max_nb(equity)
        return self.wrapper.wrap(drawdown)

    @metric_property(&#39;Max drawdown&#39;)
    def max_drawdown(self):
        &#34;&#34;&#34;Total maximum drawdown (MDD).&#34;&#34;&#34;
        max_drawdown = np.max(self.drawdown.vbt.to_2d_array(), axis=0)
        return self.wrapper.wrap_reduced(max_drawdown)

    # ############# Risk and performance metrics ############# #

    @timeseries_property(&#39;Cumulative returns&#39;)
    def cum_returns(self):
        &#34;&#34;&#34;Cumulative returns.&#34;&#34;&#34;
        return self.wrapper.wrap(nb.cum_returns_nb(self.returns.vbt.to_2d_array()))

    @metric_property(&#39;Annualized return&#39;)
    def annualized_return(self):
        &#34;&#34;&#34;Mean annual growth rate of returns. 

        This is equivilent to the compound annual growth rate.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.annualized_return_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Annualized volatility&#39;)
    def annualized_volatility(self):
        &#34;&#34;&#34;Annualized volatility of a strategy.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.annualized_volatility_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Calmar ratio&#39;)
    def calmar_ratio(self):
        &#34;&#34;&#34;Calmar ratio, or drawdown ratio, of a strategy.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.calmar_ratio_nb(
            self.returns.vbt.to_2d_array(),
            reshape_fns.to_1d(self.annualized_return, raw=True),
            reshape_fns.to_1d(self.max_drawdown, raw=True),
            self.ann_factor))

    @metric_property(&#39;Omega ratio&#39;)
    def omega_ratio(self):
        &#34;&#34;&#34;Omega ratio of a strategy.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.omega_ratio_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor,
            risk_free=self.risk_free,
            required_return=self.required_return))

    @metric_property(&#39;Sharpe ratio&#39;)
    def sharpe_ratio(self):
        &#34;&#34;&#34;Sharpe ratio of a strategy.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.sharpe_ratio_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor,
            risk_free=self.risk_free))

    @metric_property(&#39;Downside risk&#39;)
    def downside_risk(self):
        &#34;&#34;&#34;Downside deviation below a threshold.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.downside_risk_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor,
            required_return=self.required_return))

    @metric_property(&#39;Sortino ratio&#39;)
    def sortino_ratio(self):
        &#34;&#34;&#34;Sortino ratio of a strategy.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.sortino_ratio_nb(
            self.returns.vbt.to_2d_array(),
            reshape_fns.to_1d(self.downside_risk, raw=True),
            self.ann_factor,
            required_return=self.required_return))

    @metric_property(&#39;Information ratio&#39;)
    def information_ratio(self):
        &#34;&#34;&#34;Information ratio of a strategy.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrapper.wrap_reduced(nb.information_ratio_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array()))

    @metric_property(&#39;Beta&#39;)
    def beta(self):
        &#34;&#34;&#34;Beta.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrapper.wrap_reduced(nb.beta_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            risk_free=self.risk_free))

    @metric_property(&#39;Annualized alpha&#39;)
    def alpha(self):
        &#34;&#34;&#34;Annualized alpha.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrapper.wrap_reduced(nb.alpha_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            reshape_fns.to_1d(self.beta, raw=True),
            self.ann_factor,
            risk_free=self.risk_free))

    @metric_property(&#39;Tail ratio&#39;)
    def tail_ratio(self):
        &#34;&#34;&#34;Ratio between the right (95%) and left tail (5%).&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.tail_ratio_nb(self.returns.vbt.to_2d_array()))

    @metric_property(&#39;Value at risk&#39;)
    def value_at_risk(self):
        &#34;&#34;&#34;Value at risk (VaR) of a returns stream.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.value_at_risk_nb(
            self.returns.vbt.to_2d_array(),
            cutoff=self.cutoff))

    @metric_property(&#39;Conditional value at risk&#39;)
    def conditional_value_at_risk(self):
        &#34;&#34;&#34;Conditional value at risk (CVaR) of a returns stream.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(nb.conditional_value_at_risk_nb(
            self.returns.vbt.to_2d_array(),
            cutoff=self.cutoff))

    @metric_property(&#39;Capture ratio&#39;)
    def capture(self):
        &#34;&#34;&#34;Capture ratio.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrapper.wrap_reduced(nb.capture_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Capture ratio (positive)&#39;)
    def up_capture(self):
        &#34;&#34;&#34;Capture ratio for periods when the benchmark return is positive.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrapper.wrap_reduced(nb.up_capture_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Capture ratio (negative)&#39;)
    def down_capture(self):
        &#34;&#34;&#34;Capture ratio for periods when the benchmark return is negative.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrapper.wrap_reduced(nb.down_capture_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Skewness&#39;)
    def skew(self):
        &#34;&#34;&#34;Skewness of returns.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(stats.skew(self.returns.vbt.to_2d_array(), axis=0, nan_policy=&#39;omit&#39;))

    @metric_property(&#39;Kurtosis&#39;)
    def kurtosis(self):
        &#34;&#34;&#34;Kurtosis of returns.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(stats.kurtosis(self.returns.vbt.to_2d_array(), axis=0, nan_policy=&#39;omit&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.common.PropertyTraverser" href="common.html#vectorbt.portfolio.common.PropertyTraverser">PropertyTraverser</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.portfolio.main.Portfolio.from_order_func"><code class="name flex">
<span>def <span class="ident">from_order_func</span></span>(<span>price, order_func_nb, *args, init_capital=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from a custom order function.</p>
<p>Starting with initial capital <code>init_capital</code>, iterates over shape <code>price.shape</code>, and for
each data point, generates an order using <code>order_func_nb</code>. This way, you can specify order
size, price and transaction costs dynamically (for example, based on the current balance).</p>
<p>To iterate over a bigger shape than <code>price</code>, you should tile/repeat <code>price</code> to the desired shape.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>
<p>Main price of the asset, such as close.</p>
<p>Must be a pandas object.</p>
</dd>
<dt><strong><code>order_func_nb</code></strong> :&ensp;<code>function</code></dt>
<dd>
<p>Function that returns an order. </p>
<p>See <code><a title="vectorbt.portfolio.enums.Order" href="enums.html#vectorbt.portfolio.enums.Order">Order</a></code>.</p>
</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>Arguments passed to <code>order_func_nb</code>.</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The initial capital.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.defaults.portfolio" href="../defaults.html#vectorbt.defaults.portfolio">portfolio</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>order_func_nb</code> must be Numba-compiled.</p>
</div>
<h2 id="example">Example</h2>
<p>Portfolio from buying daily:</p>
<pre><code class="python-repl">&gt;&gt;&gt; from vectorbt.portfolio.nb import Order

&gt;&gt;&gt; @njit
... def order_func_nb(col, i, run_cash, run_shares, price):
...     return Order(10, price[i], fees=0.01, fixed_fees=1., slippage=0.01)

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
...     price, order_func_nb, price.values, init_capital=100)

&gt;&gt;&gt; print(portfolio.order_records)
   Column  Index  Size  Price   Fees  Side
0     0.0    0.0  10.0   1.01  1.101   0.0
1     0.0    1.0  10.0   2.02  1.202   0.0
2     0.0    2.0  10.0   3.03  1.303   0.0
3     0.0    3.0  10.0   2.02  1.202   0.0
4     0.0    4.0  10.0   1.01  1.101   0.0
&gt;&gt;&gt; print(portfolio.shares)
2018-01-01    10.0
2018-01-02    20.0
2018-01-03    30.0
2018-01-04    40.0
2018-01-05    50.0
Name: a, dtype: float64
&gt;&gt;&gt; print(portfolio.cash)
2018-01-01    88.799
2018-01-02    67.397
2018-01-03    35.794
2018-01-04    14.392
2018-01-05     3.191
Name: a, dtype: float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_order_func(cls, price, order_func_nb, *args, init_capital=None, **kwargs):
    &#34;&#34;&#34;Build portfolio from a custom order function.

    Starting with initial capital `init_capital`, iterates over shape `price.shape`, and for 
    each data point, generates an order using `order_func_nb`. This way, you can specify order 
    size, price and transaction costs dynamically (for example, based on the current balance).

    To iterate over a bigger shape than `price`, you should tile/repeat `price` to the desired shape.

    Args:
        price (pandas_like): Main price of the asset, such as close.

            Must be a pandas object.
        order_func_nb (function): Function that returns an order. 

            See `vectorbt.portfolio.enums.Order`.
        *args: Arguments passed to `order_func_nb`.
        init_capital (int or float): The initial capital.
        **kwargs: Keyword arguments passed to the `__init__` method.

    For defaults, see `vectorbt.defaults.portfolio`.

    !!! note
        `order_func_nb` must be Numba-compiled.

    Example:
        Portfolio from buying daily:
        ```python-repl
        &gt;&gt;&gt; from vectorbt.portfolio.nb import Order

        &gt;&gt;&gt; @njit
        ... def order_func_nb(col, i, run_cash, run_shares, price):
        ...     return Order(10, price[i], fees=0.01, fixed_fees=1., slippage=0.01)

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
        ...     price, order_func_nb, price.values, init_capital=100)

        &gt;&gt;&gt; print(portfolio.order_records)
           Column  Index  Size  Price   Fees  Side
        0     0.0    0.0  10.0   1.01  1.101   0.0
        1     0.0    1.0  10.0   2.02  1.202   0.0
        2     0.0    2.0  10.0   3.03  1.303   0.0
        3     0.0    3.0  10.0   2.02  1.202   0.0
        4     0.0    4.0  10.0   1.01  1.101   0.0
        &gt;&gt;&gt; print(portfolio.shares)
        2018-01-01    10.0
        2018-01-02    20.0
        2018-01-03    30.0
        2018-01-04    40.0
        2018-01-05    50.0
        Name: a, dtype: float64
        &gt;&gt;&gt; print(portfolio.cash)
        2018-01-01    88.799
        2018-01-02    67.397
        2018-01-03    35.794
        2018-01-04    14.392
        2018-01-05     3.191
        Name: a, dtype: float64
        ```
    &#34;&#34;&#34;
    # Get defaults
    if init_capital is None:
        init_capital = defaults.portfolio[&#39;init_capital&#39;]
    init_capital = float(init_capital)

    # Perform checks
    checks.assert_type(price, (pd.Series, pd.DataFrame))
    checks.assert_numba_func(order_func_nb)

    # Perform calculation
    order_records, cash, shares = nb.simulate_nb(
        reshape_fns.to_2d(price, raw=True).shape,
        init_capital,
        order_func_nb,
        *args)

    # Bring to the same meta
    cash = price.vbt.wrap(cash)
    shares = price.vbt.wrap(shares)

    return cls(price, init_capital, order_records, cash, shares, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.from_orders"><code class="name flex">
<span>def <span class="ident">from_orders</span></span>(<span>price, order_size, order_price=None, init_capital=None, fees=None, fixed_fees=None, slippage=None, is_target=False, broadcast_kwargs={}, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from orders.</p>
<p>Starting with initial capital <code>init_capital</code>, at each time step, orders the number
of shares specified in <code>order_size</code> for <code>order_price</code>. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Main price of the asset, such as close.</dd>
<dt><strong><code>order_size</code></strong> :&ensp;<code>int, float</code> or <code>array_like</code></dt>
<dd>
<p>The amount of shares to order. </p>
<p>If the size is positive, this is the number of shares to buy.
If the size is negative, this is the number of shares to sell.
To buy/sell everything, set the size to <code>numpy.inf</code>.</p>
</dd>
<dt><strong><code>order_price</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Order price. Defaults to <code>price</code>.</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The initial capital.</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fees in percentage of the order value.</dd>
<dt><strong><code>fixed_fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fixed amount of fees to pay per order.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of <code>order_price</code>.</dd>
<dt><strong><code>is_target</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, will order the difference between current and target size.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.defaults.portfolio" href="../defaults.html#vectorbt.defaults.portfolio">portfolio</a></code>.</p>
<p>All array-like arguments will be broadcasted together using <code><a title="vectorbt.utils.reshape_fns.broadcast" href="../utils/reshape_fns.html#vectorbt.utils.reshape_fns.broadcast">broadcast()</a></code>
with <code>broadcast_kwargs</code>. At the end, all array objects will have the same metadata.</p>
<h2 id="example">Example</h2>
<p>Portfolio from various order sequences:</p>
<pre><code class="python-repl">&gt;&gt;&gt; orders = pd.DataFrame({
...     'a': [np.inf, 0, 0, 0, 0],
...     'b': [1, 1, 1, 1, -np.inf],
...     'c': [np.inf, -np.inf, np.inf, -np.inf, np.inf]
... }, index=index)
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

&gt;&gt;&gt; print(portfolio.order_records)
    Column  Index        Size  Price      Fees  Side
0      0.0    0.0   98.654463  1.001  1.246883   0.0
1      1.0    0.0    1.000000  1.001  1.002502   0.0
2      1.0    1.0    1.000000  2.002  1.005005   0.0
3      1.0    2.0    1.000000  3.003  1.007507   0.0
4      1.0    3.0    1.000000  2.002  1.005005   0.0
5      1.0    4.0    4.000000  0.999  1.009990   1.0
6      2.0    0.0   98.654463  1.001  1.246883   0.0
7      2.0    1.0   98.654463  1.998  1.492779   1.0
8      2.0    2.0   64.646521  3.003  1.485334   0.0
9      2.0    3.0   64.646521  1.998  1.322909   1.0
10     2.0    4.0  126.398131  1.001  1.316311   0.0
&gt;&gt;&gt; print(portfolio.shares)
                    a    b           c
2018-01-01  98.654463  1.0   98.654463
2018-01-02  98.654463  2.0    0.000000
2018-01-03  98.654463  3.0   64.646521
2018-01-04  98.654463  4.0    0.000000
2018-01-05  98.654463  0.0  126.398131
&gt;&gt;&gt; print(portfolio.cash)
              a          b             c
2018-01-01  0.0  97.996498  0.000000e+00
2018-01-02  0.0  94.989493  1.956188e+02
2018-01-03  0.0  90.978985  2.842171e-14
2018-01-04  0.0  87.971980  1.278408e+02
2018-01-05  0.0  90.957990  0.000000e+00
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_orders(cls, price, order_size, order_price=None, init_capital=None, fees=None, fixed_fees=None,
                slippage=None, is_target=False, broadcast_kwargs={}, **kwargs):
    &#34;&#34;&#34;Build portfolio from orders.

    Starting with initial capital `init_capital`, at each time step, orders the number 
    of shares specified in `order_size` for `order_price`. 

    Args:
        price (pandas_like): Main price of the asset, such as close.
        order_size (int, float or array_like): The amount of shares to order. 

            If the size is positive, this is the number of shares to buy. 
            If the size is negative, this is the number of shares to sell.
            To buy/sell everything, set the size to `numpy.inf`.
        order_price (array_like): Order price. Defaults to `price`.
        init_capital (int or float): The initial capital.
        fees (float or array_like): Fees in percentage of the order value.
        fixed_fees (float or array_like): Fixed amount of fees to pay per order.
        slippage (float or array_like): Slippage in percentage of `order_price`.
        is_target (bool): If `True`, will order the difference between current and target size.
        **kwargs: Keyword arguments passed to the `__init__` method.

    For defaults, see `vectorbt.defaults.portfolio`.

    All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast` 
    with `broadcast_kwargs`. At the end, all array objects will have the same metadata.

    Example:
        Portfolio from various order sequences:
        ```python-repl
        &gt;&gt;&gt; orders = pd.DataFrame({
        ...     &#39;a&#39;: [np.inf, 0, 0, 0, 0],
        ...     &#39;b&#39;: [1, 1, 1, 1, -np.inf],
        ...     &#39;c&#39;: [np.inf, -np.inf, np.inf, -np.inf, np.inf]
        ... }, index=index)
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
        ...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

        &gt;&gt;&gt; print(portfolio.order_records)
            Column  Index        Size  Price      Fees  Side
        0      0.0    0.0   98.654463  1.001  1.246883   0.0
        1      1.0    0.0    1.000000  1.001  1.002502   0.0
        2      1.0    1.0    1.000000  2.002  1.005005   0.0
        3      1.0    2.0    1.000000  3.003  1.007507   0.0
        4      1.0    3.0    1.000000  2.002  1.005005   0.0
        5      1.0    4.0    4.000000  0.999  1.009990   1.0
        6      2.0    0.0   98.654463  1.001  1.246883   0.0
        7      2.0    1.0   98.654463  1.998  1.492779   1.0
        8      2.0    2.0   64.646521  3.003  1.485334   0.0
        9      2.0    3.0   64.646521  1.998  1.322909   1.0
        10     2.0    4.0  126.398131  1.001  1.316311   0.0
        &gt;&gt;&gt; print(portfolio.shares)
                            a    b           c
        2018-01-01  98.654463  1.0   98.654463
        2018-01-02  98.654463  2.0    0.000000
        2018-01-03  98.654463  3.0   64.646521
        2018-01-04  98.654463  4.0    0.000000
        2018-01-05  98.654463  0.0  126.398131
        &gt;&gt;&gt; print(portfolio.cash)
                      a          b             c
        2018-01-01  0.0  97.996498  0.000000e+00
        2018-01-02  0.0  94.989493  1.956188e+02
        2018-01-03  0.0  90.978985  2.842171e-14
        2018-01-04  0.0  87.971980  1.278408e+02
        2018-01-05  0.0  90.957990  0.000000e+00
        ```
    &#34;&#34;&#34;
    # Get defaults
    if order_price is None:
        order_price = price
    if init_capital is None:
        init_capital = defaults.portfolio[&#39;init_capital&#39;]
    init_capital = float(init_capital)
    if fees is None:
        fees = defaults.portfolio[&#39;fees&#39;]
    if fixed_fees is None:
        fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
    if slippage is None:
        slippage = defaults.portfolio[&#39;slippage&#39;]

    # Perform checks
    checks.assert_type(price, (pd.Series, pd.DataFrame))

    # Broadcast inputs
    price, order_size, order_price, fees, fixed_fees, slippage = \
        reshape_fns.broadcast(price, order_size, order_price, fees, fixed_fees,
                              slippage, **broadcast_kwargs, writeable=True)

    # Perform calculation
    order_records, cash, shares = nb.simulate_from_orders_nb(
        reshape_fns.to_2d(price, raw=True).shape,
        init_capital,
        reshape_fns.to_2d(order_size, raw=True),
        reshape_fns.to_2d(order_price, raw=True),
        reshape_fns.to_2d(fees, raw=True),
        reshape_fns.to_2d(fixed_fees, raw=True),
        reshape_fns.to_2d(slippage, raw=True),
        is_target)

    # Bring to the same meta
    cash = price.vbt.wrap(cash)
    shares = price.vbt.wrap(shares)

    return cls(price, init_capital, order_records, cash, shares, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.from_signals"><code class="name flex">
<span>def <span class="ident">from_signals</span></span>(<span>price, entries, exits, size=inf, entry_price=None, exit_price=None, init_capital=None, fees=None, fixed_fees=None, slippage=None, accumulate=False, broadcast_kwargs={}, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from entry and exit signals.</p>
<p>At each entry signal in <code>entries</code>, buys <code>size</code> of shares for <code>entry_price</code> to enter
a position. At each exit signal in <code>exits</code>, sells everything for <code>exit_price</code>
to exit the position. Accumulation of orders is disabled by default.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Main price of the asset, such as close.</dd>
<dt><strong><code>entries</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Boolean array of entry signals.</dd>
<dt><strong><code>exits</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Boolean array of exit signals.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int, float</code> or <code>array_like</code></dt>
<dd>
<p>The amount of shares to order. </p>
<p>To buy/sell everything, set the size to <code>numpy.inf</code>.</p>
</dd>
<dt><strong><code>entry_price</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Entry price. Defaults to <code>price</code>.</dd>
<dt><strong><code>exit_price</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Exit price. Defaults to <code>price</code>.</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The initial capital.</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fees in percentage of the order value.</dd>
<dt><strong><code>fixed_fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fixed amount of fees to pay per order.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of price.</dd>
<dt><strong><code>accumulate</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>accumulate</code> is <code>True</code>, entering the market when already
in the market will be allowed to increase a position.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.defaults.portfolio" href="../defaults.html#vectorbt.defaults.portfolio">portfolio</a></code>.</p>
<p>All array-like arguments will be broadcasted together using <code><a title="vectorbt.utils.reshape_fns.broadcast" href="../utils/reshape_fns.html#vectorbt.utils.reshape_fns.broadcast">broadcast()</a></code>
with <code>broadcast_kwargs</code>. At the end, all array objects will have the same metadata.</p>
<h2 id="example">Example</h2>
<p>Portfolio from various signal sequences:</p>
<pre><code class="python-repl">&gt;&gt;&gt; entries = pd.DataFrame({
...     'a': [True, False, False, False, False],
...     'b': [True, False, True, False, True],
...     'c': [True, True, True, True, True]
... }, index=index)
&gt;&gt;&gt; exits = pd.DataFrame({
...     'a': [False, False, False, False, False],
...     'b': [False, True, False, True, False],
...     'c': [True, True, True, True, True]
... }, index=index)
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
...     price, entries, exits, size=10,
...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

&gt;&gt;&gt; print(portfolio.order_records)
   Column  Index  Size  Price      Fees  Side
0     0.0    0.0  10.0  1.001  1.025025   0.0
1     1.0    0.0  10.0  1.001  1.025025   0.0
2     1.0    1.0  10.0  1.998  1.049950   1.0
3     1.0    2.0  10.0  3.003  1.075075   0.0
4     1.0    3.0  10.0  1.998  1.049950   1.0
5     1.0    4.0  10.0  1.001  1.025025   0.0
6     2.0    0.0  10.0  1.001  1.025025   0.0
&gt;&gt;&gt; print(portfolio.shares)
               a     b     c
2018-01-01  10.0  10.0  10.0
2018-01-02  10.0   0.0  10.0
2018-01-03  10.0  10.0  10.0
2018-01-04  10.0   0.0  10.0
2018-01-05  10.0  10.0  10.0
&gt;&gt;&gt; print(portfolio.cash)
                    a           b          c
2018-01-01  88.964975   88.964975  88.964975
2018-01-02  88.964975  107.895025  88.964975
2018-01-03  88.964975   76.789950  88.964975
2018-01-04  88.964975   95.720000  88.964975
2018-01-05  88.964975   84.684975  88.964975
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_signals(cls, price, entries, exits, size=np.inf, entry_price=None, exit_price=None, init_capital=None,
                 fees=None, fixed_fees=None, slippage=None, accumulate=False, broadcast_kwargs={}, **kwargs):
    &#34;&#34;&#34;Build portfolio from entry and exit signals.

    At each entry signal in `entries`, buys `size` of shares for `entry_price` to enter
    a position. At each exit signal in `exits`, sells everything for `exit_price` 
    to exit the position. Accumulation of orders is disabled by default.

    Args:
        price (pandas_like): Main price of the asset, such as close.
        entries (array_like): Boolean array of entry signals.
        exits (array_like): Boolean array of exit signals.
        size (int, float or array_like): The amount of shares to order. 

            To buy/sell everything, set the size to `numpy.inf`.
        entry_price (array_like): Entry price. Defaults to `price`.
        exit_price (array_like): Exit price. Defaults to `price`.
        init_capital (int or float): The initial capital.
        fees (float or array_like): Fees in percentage of the order value.
        fixed_fees (float or array_like): Fixed amount of fees to pay per order.
        slippage (float or array_like): Slippage in percentage of price.
        accumulate (bool): If `accumulate` is `True`, entering the market when already 
            in the market will be allowed to increase a position.
        **kwargs: Keyword arguments passed to the `__init__` method.

    For defaults, see `vectorbt.defaults.portfolio`.

    All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast` 
    with `broadcast_kwargs`. At the end, all array objects will have the same metadata.

    Example:
        Portfolio from various signal sequences:
        ```python-repl
        &gt;&gt;&gt; entries = pd.DataFrame({
        ...     &#39;a&#39;: [True, False, False, False, False],
        ...     &#39;b&#39;: [True, False, True, False, True],
        ...     &#39;c&#39;: [True, True, True, True, True]
        ... }, index=index)
        &gt;&gt;&gt; exits = pd.DataFrame({
        ...     &#39;a&#39;: [False, False, False, False, False],
        ...     &#39;b&#39;: [False, True, False, True, False],
        ...     &#39;c&#39;: [True, True, True, True, True]
        ... }, index=index)
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     price, entries, exits, size=10,
        ...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

        &gt;&gt;&gt; print(portfolio.order_records)
           Column  Index  Size  Price      Fees  Side
        0     0.0    0.0  10.0  1.001  1.025025   0.0
        1     1.0    0.0  10.0  1.001  1.025025   0.0
        2     1.0    1.0  10.0  1.998  1.049950   1.0
        3     1.0    2.0  10.0  3.003  1.075075   0.0
        4     1.0    3.0  10.0  1.998  1.049950   1.0
        5     1.0    4.0  10.0  1.001  1.025025   0.0
        6     2.0    0.0  10.0  1.001  1.025025   0.0
        &gt;&gt;&gt; print(portfolio.shares)
                       a     b     c
        2018-01-01  10.0  10.0  10.0
        2018-01-02  10.0   0.0  10.0
        2018-01-03  10.0  10.0  10.0
        2018-01-04  10.0   0.0  10.0
        2018-01-05  10.0  10.0  10.0
        &gt;&gt;&gt; print(portfolio.cash)
                            a           b          c
        2018-01-01  88.964975   88.964975  88.964975
        2018-01-02  88.964975  107.895025  88.964975
        2018-01-03  88.964975   76.789950  88.964975
        2018-01-04  88.964975   95.720000  88.964975
        2018-01-05  88.964975   84.684975  88.964975
        ```
    &#34;&#34;&#34;
    # Get defaults
    if entry_price is None:
        entry_price = price
    if exit_price is None:
        exit_price = price
    if init_capital is None:
        init_capital = defaults.portfolio[&#39;init_capital&#39;]
    if fees is None:
        fees = defaults.portfolio[&#39;fees&#39;]
    if fixed_fees is None:
        fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
    if slippage is None:
        slippage = defaults.portfolio[&#39;slippage&#39;]

    # Perform checks
    checks.assert_type(price, (pd.Series, pd.DataFrame))
    checks.assert_dtype(entries, np.bool_)
    checks.assert_dtype(exits, np.bool_)

    # Broadcast inputs
    price, entries, exits, size, entry_price, exit_price, fees, fixed_fees, slippage = \
        reshape_fns.broadcast(price, entries, exits, size, entry_price, exit_price, fees,
                              fixed_fees, slippage, **broadcast_kwargs, writeable=True)

    # Perform calculation
    order_records, cash, shares = nb.simulate_from_signals_nb(
        reshape_fns.to_2d(price, raw=True).shape,
        init_capital,
        reshape_fns.to_2d(entries, raw=True),
        reshape_fns.to_2d(exits, raw=True),
        reshape_fns.to_2d(size, raw=True),
        reshape_fns.to_2d(entry_price, raw=True),
        reshape_fns.to_2d(exit_price, raw=True),
        reshape_fns.to_2d(fees, raw=True),
        reshape_fns.to_2d(fixed_fees, raw=True),
        reshape_fns.to_2d(slippage, raw=True),
        accumulate)

    # Bring to the same meta
    cash = price.vbt.wrap(cash)
    shares = price.vbt.wrap(shares)

    return cls(price, init_capital, order_records, cash, shares, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.main.Portfolio.alpha"><code class="name">var <span class="ident">alpha</span></code></dt>
<dd>
<div class="desc"><p>Annualized alpha.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>factor_returns</code> must be set.</p>
</div>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.ann_factor"><code class="name">var <span class="ident">ann_factor</span></code></dt>
<dd>
<div class="desc"><p>Annualization factor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ann_factor(self):
    &#34;&#34;&#34;Annualization factor.&#34;&#34;&#34;
    return self._ann_factor</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.annual_returns"><code class="name">var <span class="ident">annual_returns</span></code></dt>
<dd>
<div class="desc"><p>Annual returns.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.annualized_return"><code class="name">var <span class="ident">annualized_return</span></code></dt>
<dd>
<div class="desc"><p>Mean annual growth rate of returns. </p>
<p>This is equivilent to the compound annual growth rate.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.annualized_volatility"><code class="name">var <span class="ident">annualized_volatility</span></code></dt>
<dd>
<div class="desc"><p>Annualized volatility of a strategy.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.beta"><code class="name">var <span class="ident">beta</span></code></dt>
<dd>
<div class="desc"><p>Beta.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>factor_returns</code> must be set.</p>
</div>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.calmar_ratio"><code class="name">var <span class="ident">calmar_ratio</span></code></dt>
<dd>
<div class="desc"><p>Calmar ratio, or drawdown ratio, of a strategy.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.capture"><code class="name">var <span class="ident">capture</span></code></dt>
<dd>
<div class="desc"><p>Capture ratio.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>factor_returns</code> must be set.</p>
</div>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.cash"><code class="name">var <span class="ident">cash</span></code></dt>
<dd>
<div class="desc"><p>Cash held at each time step.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.conditional_value_at_risk"><code class="name">var <span class="ident">conditional_value_at_risk</span></code></dt>
<dd>
<div class="desc"><p>Conditional value at risk (CVaR) of a returns stream.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.cum_returns"><code class="name">var <span class="ident">cum_returns</span></code></dt>
<dd>
<div class="desc"><p>Cumulative returns.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.cutoff"><code class="name">var <span class="ident">cutoff</span></code></dt>
<dd>
<div class="desc"><p>Decimal representing the percentage cutoff for the bottom percentile of returns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cutoff(self):
    &#34;&#34;&#34;Decimal representing the percentage cutoff for the bottom percentile of returns.&#34;&#34;&#34;
    return self._cutoff</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.daily_returns"><code class="name">var <span class="ident">daily_returns</span></code></dt>
<dd>
<div class="desc"><p>Daily returns.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.data_freq"><code class="name">var <span class="ident">data_freq</span></code></dt>
<dd>
<div class="desc"><p>Data frequency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_freq(self):
    &#34;&#34;&#34;Data frequency.&#34;&#34;&#34;
    return self._data_freq</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.down_capture"><code class="name">var <span class="ident">down_capture</span></code></dt>
<dd>
<div class="desc"><p>Capture ratio for periods when the benchmark return is negative.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>factor_returns</code> must be set.</p>
</div>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.downside_risk"><code class="name">var <span class="ident">downside_risk</span></code></dt>
<dd>
<div class="desc"><p>Downside deviation below a threshold.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.drawdown"><code class="name">var <span class="ident">drawdown</span></code></dt>
<dd>
<div class="desc"><p>Relative decline from a peak.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.equity"><code class="name">var <span class="ident">equity</span></code></dt>
<dd>
<div class="desc"><p>Equity.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.factor_returns"><code class="name">var <span class="ident">factor_returns</span></code></dt>
<dd>
<div class="desc"><p>Benchmark return to compare returns against.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def factor_returns(self):
    &#34;&#34;&#34;Benchmark return to compare returns against.&#34;&#34;&#34;
    return self._factor_returns</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.information_ratio"><code class="name">var <span class="ident">information_ratio</span></code></dt>
<dd>
<div class="desc"><p>Information ratio of a strategy.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>factor_returns</code> must be set.</p>
</div>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.init_capital"><code class="name">var <span class="ident">init_capital</span></code></dt>
<dd>
<div class="desc"><p>Initial capital.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def init_capital(self):
    &#34;&#34;&#34;Initial capital.&#34;&#34;&#34;
    return self._init_capital</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.kurtosis"><code class="name">var <span class="ident">kurtosis</span></code></dt>
<dd>
<div class="desc"><p>Kurtosis of returns.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.max_drawdown"><code class="name">var <span class="ident">max_drawdown</span></code></dt>
<dd>
<div class="desc"><p>Total maximum drawdown (MDD).</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.omega_ratio"><code class="name">var <span class="ident">omega_ratio</span></code></dt>
<dd>
<div class="desc"><p>Omega ratio of a strategy.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.order_records"><code class="name">var <span class="ident">order_records</span></code></dt>
<dd>
<div class="desc"><p>Records of type <code><a title="vectorbt.portfolio.enums.OrderRecord" href="enums.html#vectorbt.portfolio.enums.OrderRecord">OrderRecord</a></code>.</p>
<p><span class="badge badge-pill badge-warning">records</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.orders"><code class="name">var <span class="ident">orders</span></code></dt>
<dd>
<div class="desc"><p>Time series and metrics based on order records.</p>
<p><span class="badge badge-pill badge-info">group</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.position_records"><code class="name">var <span class="ident">position_records</span></code></dt>
<dd>
<div class="desc"><p>Records of type <code><a title="vectorbt.portfolio.enums.PositionRecord" href="enums.html#vectorbt.portfolio.enums.PositionRecord">PositionRecord</a></code>.</p>
<p><span class="badge badge-pill badge-warning">records</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.positions"><code class="name">var <span class="ident">positions</span></code></dt>
<dd>
<div class="desc"><p>Time series and metrics based on position records.</p>
<p><span class="badge badge-pill badge-info">group</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.price"><code class="name">var <span class="ident">price</span></code></dt>
<dd>
<div class="desc"><p>Price per share at each time step.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.required_return"><code class="name">var <span class="ident">required_return</span></code></dt>
<dd>
<div class="desc"><p>Minimum acceptance return of the investor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def required_return(self):
    &#34;&#34;&#34;Minimum acceptance return of the investor.&#34;&#34;&#34;
    return self._required_return</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.returns"><code class="name">var <span class="ident">returns</span></code></dt>
<dd>
<div class="desc"><p>Portfolio returns.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.risk_free"><code class="name">var <span class="ident">risk_free</span></code></dt>
<dd>
<div class="desc"><p>Constant risk-free return throughout the period.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def risk_free(self):
    &#34;&#34;&#34;Constant risk-free return throughout the period.&#34;&#34;&#34;
    return self._risk_free</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.shares"><code class="name">var <span class="ident">shares</span></code></dt>
<dd>
<div class="desc"><p>Shares held at each time step.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.sharpe_ratio"><code class="name">var <span class="ident">sharpe_ratio</span></code></dt>
<dd>
<div class="desc"><p>Sharpe ratio of a strategy.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.skew"><code class="name">var <span class="ident">skew</span></code></dt>
<dd>
<div class="desc"><p>Skewness of returns.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.sortino_ratio"><code class="name">var <span class="ident">sortino_ratio</span></code></dt>
<dd>
<div class="desc"><p>Sortino ratio of a strategy.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.tail_ratio"><code class="name">var <span class="ident">tail_ratio</span></code></dt>
<dd>
<div class="desc"><p>Ratio between the right (95%) and left tail (5%).</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.total_profit"><code class="name">var <span class="ident">total_profit</span></code></dt>
<dd>
<div class="desc"><p>Total profit.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.total_return"><code class="name">var <span class="ident">total_return</span></code></dt>
<dd>
<div class="desc"><p>Total return.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.trade_records"><code class="name">var <span class="ident">trade_records</span></code></dt>
<dd>
<div class="desc"><p>Records of type <code><a title="vectorbt.portfolio.enums.TradeRecord" href="enums.html#vectorbt.portfolio.enums.TradeRecord">TradeRecord</a></code>.</p>
<p><span class="badge badge-pill badge-warning">records</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.trades"><code class="name">var <span class="ident">trades</span></code></dt>
<dd>
<div class="desc"><p>Time series and metrics based on trade records.</p>
<p><span class="badge badge-pill badge-info">group</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.up_capture"><code class="name">var <span class="ident">up_capture</span></code></dt>
<dd>
<div class="desc"><p>Capture ratio for periods when the benchmark return is positive.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>factor_returns</code> must be set.</p>
</div>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.value_at_risk"><code class="name">var <span class="ident">value_at_risk</span></code></dt>
<dd>
<div class="desc"><p>Value at risk (VaR) of a returns stream.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.main.Portfolio.year_freq"><code class="name">var <span class="ident">year_freq</span></code></dt>
<dd>
<div class="desc"><p>Year frequency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def year_freq(self):
    &#34;&#34;&#34;Year frequency.&#34;&#34;&#34;
    return self._year_freq</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.portfolio.common.PropertyTraverser" href="common.html#vectorbt.portfolio.common.PropertyTraverser">PropertyTraverser</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.portfolio.common.PropertyTraverser.traverse_metrics" href="common.html#vectorbt.portfolio.common.PropertyTraverser.traverse_metrics">traverse_metrics</a></code></li>
<li><code><a title="vectorbt.portfolio.common.PropertyTraverser.traverse_properties" href="common.html#vectorbt.portfolio.common.PropertyTraverser.traverse_properties">traverse_properties</a></code></li>
<li><code><a title="vectorbt.portfolio.common.PropertyTraverser.traverse_records" href="common.html#vectorbt.portfolio.common.PropertyTraverser.traverse_records">traverse_records</a></code></li>
<li><code><a title="vectorbt.portfolio.common.PropertyTraverser.traverse_timeseries" href="common.html#vectorbt.portfolio.common.PropertyTraverser.traverse_timeseries">traverse_timeseries</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="https://github.com/polakowo/vectorbt/blob/master/logo.png?raw=true" alt=""> vectorbt
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#workflow">Workflow</a></li>
<li><a href="#properties">Properties</a><ul>
<li><a href="#caching">Caching</a></li>
<li><a href="#property-hierarchy">Property hierarchy</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.portfolio" href="index.html">vectorbt.portfolio</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.portfolio.main.Portfolio" href="#vectorbt.portfolio.main.Portfolio">Portfolio</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.portfolio.main.Portfolio.alpha" href="#vectorbt.portfolio.main.Portfolio.alpha">alpha</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.ann_factor" href="#vectorbt.portfolio.main.Portfolio.ann_factor">ann_factor</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.annual_returns" href="#vectorbt.portfolio.main.Portfolio.annual_returns">annual_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.annualized_return" href="#vectorbt.portfolio.main.Portfolio.annualized_return">annualized_return</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.annualized_volatility" href="#vectorbt.portfolio.main.Portfolio.annualized_volatility">annualized_volatility</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.beta" href="#vectorbt.portfolio.main.Portfolio.beta">beta</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.calmar_ratio" href="#vectorbt.portfolio.main.Portfolio.calmar_ratio">calmar_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.capture" href="#vectorbt.portfolio.main.Portfolio.capture">capture</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.cash" href="#vectorbt.portfolio.main.Portfolio.cash">cash</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.conditional_value_at_risk" href="#vectorbt.portfolio.main.Portfolio.conditional_value_at_risk">conditional_value_at_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.cum_returns" href="#vectorbt.portfolio.main.Portfolio.cum_returns">cum_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.cutoff" href="#vectorbt.portfolio.main.Portfolio.cutoff">cutoff</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.daily_returns" href="#vectorbt.portfolio.main.Portfolio.daily_returns">daily_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.data_freq" href="#vectorbt.portfolio.main.Portfolio.data_freq">data_freq</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.down_capture" href="#vectorbt.portfolio.main.Portfolio.down_capture">down_capture</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.downside_risk" href="#vectorbt.portfolio.main.Portfolio.downside_risk">downside_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.drawdown" href="#vectorbt.portfolio.main.Portfolio.drawdown">drawdown</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.equity" href="#vectorbt.portfolio.main.Portfolio.equity">equity</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.factor_returns" href="#vectorbt.portfolio.main.Portfolio.factor_returns">factor_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.from_order_func" href="#vectorbt.portfolio.main.Portfolio.from_order_func">from_order_func</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.from_orders" href="#vectorbt.portfolio.main.Portfolio.from_orders">from_orders</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.from_signals" href="#vectorbt.portfolio.main.Portfolio.from_signals">from_signals</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.information_ratio" href="#vectorbt.portfolio.main.Portfolio.information_ratio">information_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.init_capital" href="#vectorbt.portfolio.main.Portfolio.init_capital">init_capital</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.kurtosis" href="#vectorbt.portfolio.main.Portfolio.kurtosis">kurtosis</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.max_drawdown" href="#vectorbt.portfolio.main.Portfolio.max_drawdown">max_drawdown</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.omega_ratio" href="#vectorbt.portfolio.main.Portfolio.omega_ratio">omega_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.order_records" href="#vectorbt.portfolio.main.Portfolio.order_records">order_records</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.orders" href="#vectorbt.portfolio.main.Portfolio.orders">orders</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.position_records" href="#vectorbt.portfolio.main.Portfolio.position_records">position_records</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.positions" href="#vectorbt.portfolio.main.Portfolio.positions">positions</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.price" href="#vectorbt.portfolio.main.Portfolio.price">price</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.required_return" href="#vectorbt.portfolio.main.Portfolio.required_return">required_return</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.returns" href="#vectorbt.portfolio.main.Portfolio.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.risk_free" href="#vectorbt.portfolio.main.Portfolio.risk_free">risk_free</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.shares" href="#vectorbt.portfolio.main.Portfolio.shares">shares</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.sharpe_ratio" href="#vectorbt.portfolio.main.Portfolio.sharpe_ratio">sharpe_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.skew" href="#vectorbt.portfolio.main.Portfolio.skew">skew</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.sortino_ratio" href="#vectorbt.portfolio.main.Portfolio.sortino_ratio">sortino_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.tail_ratio" href="#vectorbt.portfolio.main.Portfolio.tail_ratio">tail_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.total_profit" href="#vectorbt.portfolio.main.Portfolio.total_profit">total_profit</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.total_return" href="#vectorbt.portfolio.main.Portfolio.total_return">total_return</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.trade_records" href="#vectorbt.portfolio.main.Portfolio.trade_records">trade_records</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.trades" href="#vectorbt.portfolio.main.Portfolio.trades">trades</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.up_capture" href="#vectorbt.portfolio.main.Portfolio.up_capture">up_capture</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.value_at_risk" href="#vectorbt.portfolio.main.Portfolio.value_at_risk">value_at_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.main.Portfolio.year_freq" href="#vectorbt.portfolio.main.Portfolio.year_freq">year_freq</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>