<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.portfolio.portfolio API documentation</title>
<meta name="description" content="Class for building a portfolio and measuring its performance â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.portfolio.portfolio</code></h1>
</header>
<section id="section-intro">
<p>Class for building a portfolio and measuring its performance.</p>
<p>The job of the <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code> class is to create a series of positions allocated
against a cash component, produce an equity curve, incorporate basic transaction costs
and produce a set of statistics about its performance. In particular it outputs
position/profit metrics and drawdown information.</p>
<p>Depending upon the class method, it takes some input, and for each column in this input,
it calculates the portfolio value by tracking the price, the amount of cash held, the
amount of shares held, but also the costs spent at each time step. It then passes these
time series to the <code>__init__</code> method to create an instance of the <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code> class.</p>
<h2 id="properties">Properties</h2>
<p>The <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code> class offers numerous properties for measuring the performance of a strategy.
They can be categorized as follows:</p>
<ul>
<li>time series indexed by time, such as <code><a title="vectorbt.portfolio.portfolio.Portfolio.equity" href="#vectorbt.portfolio.portfolio.Portfolio.equity">Portfolio.equity</a></code></li>
<li>metrics indexed by columns, such as <code><a title="vectorbt.portfolio.portfolio.Portfolio.total_profit" href="#vectorbt.portfolio.portfolio.Portfolio.total_profit">Portfolio.total_profit</a></code></li>
<li>group objects with own time series and metrics, such as <code><a title="vectorbt.portfolio.portfolio.Portfolio.positions" href="#vectorbt.portfolio.portfolio.Portfolio.positions">Portfolio.positions</a></code></li>
</ul>
<h3 id="caching">Caching</h3>
<p>Each property is cached, thus properties can effectively build upon each other. </p>
<p>Take for example the <code><a title="vectorbt.portfolio.portfolio.Portfolio.max_drawdown" href="#vectorbt.portfolio.portfolio.Portfolio.max_drawdown">Portfolio.max_drawdown</a></code> property: it depends upon <code><a title="vectorbt.portfolio.portfolio.Portfolio.drawdown" href="#vectorbt.portfolio.portfolio.Portfolio.drawdown">Portfolio.drawdown</a></code>,
which in turn depends upon <code><a title="vectorbt.portfolio.portfolio.Portfolio.equity" href="#vectorbt.portfolio.portfolio.Portfolio.equity">Portfolio.equity</a></code>, and so on. Without caching, <code><a title="vectorbt.portfolio.portfolio.Portfolio.max_drawdown" href="#vectorbt.portfolio.portfolio.Portfolio.max_drawdown">Portfolio.max_drawdown</a></code>
would have re-calculated everything starting from equity, each time.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code> class is meant to be immutable due to caching, thus each public attribute is
marked as read-only. To change an attribute, you need to create a new Portfolio instance.</p>
</div>
<h3 id="property-hierarchy">Property hierarchy</h3>
<p>All those properties are building a hierarchy with time series and metrics as leafs, and group
objects as nodes. By implementing custom cachable property classes <code><a title="vectorbt.portfolio.common.timeseries_property" href="common.html#vectorbt.portfolio.common.timeseries_property">timeseries_property</a></code>
and <code><a title="vectorbt.portfolio.common.metric_property" href="common.html#vectorbt.portfolio.common.metric_property">metric_property</a></code>, we are also able to encode information into each property,
such as the full name of a metric and its display format. And by defining the group properties with
<code><a title="vectorbt.portfolio.common.group_property" href="common.html#vectorbt.portfolio.common.group_property">group_property</a></code>, we are able to define gateaway points that can be easily traversed.</p>
<pre><code class="plaintext">Portfolio
+-- @timeseries_property
+-- @metric_property
+-- @group_property
    +-- @timeseries_property
    +-- @metric_property
</code></pre>
<p>This way, the <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code> class acts as an extendable tree data structure for properties with
annotations. Instead of hard-coding the list of available time series and metrics with something
like <code>_PERFORMANCE_METRICS_PROPS</code>, we can call <code><a title="vectorbt.portfolio.common.traverse_timeseries" href="common.html#vectorbt.portfolio.common.traverse_timeseries">traverse_timeseries()</a></code>
and build the list on the fly.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Hierarchy and annotations are only visible when traversing the class, not the class instance.
To add a new attribute to the hierarchy, you need to subclass <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code> and define your
properties there. Each property must be a subclass of <code><a title="vectorbt.utils.decorators.custom_property" href="../utils/decorators.html#vectorbt.utils.decorators.custom_property">custom_property</a></code>.</p>
</div>
<h2 id="indexing">Indexing</h2>
<p>In addition, you can use pandas indexing on the <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code> class itself, which forwards
indexing operation to each <code>__init__</code> argument with pandas type (see <code>portfolio_indexing_func</code>):</p>
<pre><code class="python-repl">&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; index = pd.Index([
...     datetime(2018, 1, 1),
...     datetime(2018, 1, 2),
...     datetime(2018, 1, 3),
...     datetime(2018, 1, 4),
...     datetime(2018, 1, 5)
... ])
&gt;&gt;&gt; price = pd.Series([1, 2, 3, 2, 1], index=index, name='a')

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, price.diff(), init_capital=100)

&gt;&gt;&gt; print(portfolio.equity)
2018-01-01    100.0
2018-01-02    100.0
2018-01-03    101.0
2018-01-04     99.0
2018-01-05     98.0
Name: a, dtype: float64
&gt;&gt;&gt; print(portfolio.loc['2018-01-03':].equity)
2018-01-03    101.0
2018-01-04     99.0
2018-01-05     98.0
Name: a, dtype: float64
</code></pre>
<p>Note that for the new <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code> instance, date <code>'2018-01-03'</code> will be the new start date.</p>
<h2 id="addition">Addition</h2>
<p>You can also add multiple <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code> instances together to combine portfolios:</p>
<pre><code class="python-repl">&gt;&gt;&gt; portfolio1 = vbt.Portfolio.from_orders(price, price.diff(), init_capital=100)
&gt;&gt;&gt; portfolio2 = vbt.Portfolio.from_orders(price, price.diff()*2, init_capital=20)
&gt;&gt;&gt; portfolio = portfolio1 + portfolio2

&gt;&gt;&gt; print(portfolio.init_capital)
120.0
&gt;&gt;&gt; print(portfolio.equity)
2018-01-01    120.0
2018-01-02    120.0
2018-01-03    123.0
2018-01-04    117.0
2018-01-05    114.0
Name: a, dtype: float64
</code></pre>
<p>The only requirement is that both portfolios must have the same metadata.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Class for building a portfolio and measuring its performance.

The job of the `Portfolio` class is to create a series of positions allocated 
    against a cash component, produce an equity curve, incorporate basic transaction costs 
    and produce a set of statistics about its performance. In particular it outputs 
    position/profit metrics and drawdown information.

Depending upon the class method, it takes some input, and for each column in this input, 
it calculates the portfolio value by tracking the price, the amount of cash held, the 
amount of shares held, but also the costs spent at each time step. It then passes these 
time series to the `__init__` method to create an instance of the `Portfolio` class.

## Properties

The `Portfolio` class offers numerous properties for measuring the performance of a strategy. 
They can be categorized as follows:

* time series indexed by time, such as `Portfolio.equity`
* metrics indexed by columns, such as `Portfolio.total_profit`
* group objects with own time series and metrics, such as `Portfolio.positions`

### Caching

Each property is cached, thus properties can effectively build upon each other. 

Take for example the `Portfolio.max_drawdown` property: it depends upon `Portfolio.drawdown`,
which in turn depends upon `Portfolio.equity`, and so on. Without caching, `Portfolio.max_drawdown` 
would have re-calculated everything starting from equity, each time.

!!! note
    `Portfolio` class is meant to be immutable due to caching, thus each public attribute is
    marked as read-only. To change an attribute, you need to create a new Portfolio instance.

### Property hierarchy

All those properties are building a hierarchy with time series and metrics as leafs, and group 
objects as nodes. By implementing custom cachable property classes `vectorbt.portfolio.common.timeseries_property` 
and `vectorbt.portfolio.common.metric_property`, we are also able to encode information into each property, 
such as the full name of a metric and its display format. And by defining the group properties with 
`vectorbt.portfolio.common.group_property`, we are able to define gateaway points that can be easily traversed.

```plaintext
Portfolio
+-- @timeseries_property
+-- @metric_property
+-- @group_property
    +-- @timeseries_property
    +-- @metric_property
```

This way, the `Portfolio` class acts as an extendable tree data structure for properties with 
annotations. Instead of hard-coding the list of available time series and metrics with something 
like `_PERFORMANCE_METRICS_PROPS`, we can call `vectorbt.portfolio.common.traverse_timeseries` 
and build the list on the fly.

!!! note
    Hierarchy and annotations are only visible when traversing the class, not the class instance.
    To add a new attribute to the hierarchy, you need to subclass `Portfolio` and define your
    properties there. Each property must be a subclass of `vectorbt.utils.decorators.custom_property`.

## Indexing

In addition, you can use pandas indexing on the `Portfolio` class itself, which forwards
indexing operation to each `__init__` argument with pandas type (see `portfolio_indexing_func`):

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; index = pd.Index([
...     datetime(2018, 1, 1),
...     datetime(2018, 1, 2),
...     datetime(2018, 1, 3),
...     datetime(2018, 1, 4),
...     datetime(2018, 1, 5)
... ])
&gt;&gt;&gt; price = pd.Series([1, 2, 3, 2, 1], index=index, name=&#39;a&#39;)

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, price.diff(), init_capital=100)

&gt;&gt;&gt; print(portfolio.equity)
2018-01-01    100.0
2018-01-02    100.0
2018-01-03    101.0
2018-01-04     99.0
2018-01-05     98.0
Name: a, dtype: float64
&gt;&gt;&gt; print(portfolio.loc[&#39;2018-01-03&#39;:].equity)
2018-01-03    101.0
2018-01-04     99.0
2018-01-05     98.0
Name: a, dtype: float64
```

Note that for the new `Portfolio` instance, date `&#39;2018-01-03&#39;` will be the new start date.

## Addition

You can also add multiple `Portfolio` instances together to combine portfolios:

```python-repl
&gt;&gt;&gt; portfolio1 = vbt.Portfolio.from_orders(price, price.diff(), init_capital=100)
&gt;&gt;&gt; portfolio2 = vbt.Portfolio.from_orders(price, price.diff()*2, init_capital=20)
&gt;&gt;&gt; portfolio = portfolio1 + portfolio2

&gt;&gt;&gt; print(portfolio.init_capital)
120.0
&gt;&gt;&gt; print(portfolio.equity)
2018-01-01    120.0
2018-01-02    120.0
2018-01-03    123.0
2018-01-04    117.0
2018-01-05    114.0
Name: a, dtype: float64
```

The only requirement is that both portfolios must have the same metadata.&#34;&#34;&#34;

import numpy as np
import pandas as pd
from datetime import timedelta
from scipy import stats

from vectorbt import timeseries, accessors, defaults
from vectorbt.utils import indexing, checks, reshape_fns, common
from vectorbt.utils.common import list_module_keys
from vectorbt.portfolio import nb
from vectorbt.portfolio.positions import Positions
from vectorbt.portfolio.common import (
    ArrayWrapper,
    timeseries_property,
    metric_property,
    group_property,
    OutputFormat
)


def portfolio_indexing_func(obj, pd_indexing_func):
    &#34;&#34;&#34;Perform indexing on `Portfolio`. 

    See `vectorbt.utils.indexing.add_pd_indexing`.&#34;&#34;&#34;
    factor_returns = obj.factor_returns
    if factor_returns is not None:
        factor_returns = pd_indexing_func(obj.factor_returns)
    return obj.__class__(
        pd_indexing_func(obj.price),
        pd_indexing_func(obj.cash),
        pd_indexing_func(obj.shares),
        obj.init_capital,
        pd_indexing_func(obj.fees_paid),
        pd_indexing_func(obj.slippage_paid),
        data_freq=obj.data_freq,
        year_freq=obj.year_freq,
        risk_free=obj.risk_free,
        required_return=obj.required_return,
        cutoff=obj.cutoff,
        factor_returns=factor_returns
    )


@indexing.add_pd_indexing(portfolio_indexing_func)
class Portfolio(ArrayWrapper):
    &#34;&#34;&#34;Class for building a portfolio and measuring its performance.

    Args:
        price (pandas_like): Price of the asset.
        cash (pandas_like): Cash held at each time step. Must have the same metadata as `price`.
        shares (pandas_like): Shares held at each time step. Must have the same metadata as `price`.
        init_capital (int or float): The initial capital.
        fees_paid (pandas_like): Fees paid at each time step. Must have the same metadata as `price`.
        slippage_paid (pandas_like): Slippage paid at each time step. Must have the same metadata as `price`.
        data_freq (any): Data frequency in case `price.index` is not datetime-like. Will be passed to `pandas.to_timedelta`.
        year_freq (any): Year frequency. Will be passed to `pandas.to_timedelta`.
        risk_free (float): Constant risk-free return throughout the period.
        required_return (float): Minimum acceptance return of the investor.
        cutoff (float): Decimal representing the percentage cutoff for the bottom percentile of returns.
        factor_returns (pandas_like): Benchmark return to compare returns against. 
                If set, will be broadcasted to the shape of `price`.

    For defaults, see `vectorbt.defaults.portfolio`.

    !!! note
        Portfolio is only built by using class methods with `from_` prefix.
        The `__init__` method is reserved for indexing purposes.&#34;&#34;&#34;

    def __init__(self, price, cash, shares, init_capital, fees_paid, slippage_paid, data_freq=None,
                 year_freq=None, risk_free=None, required_return=None, cutoff=None, factor_returns=None):
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_same_meta(price, cash)
        checks.assert_same_meta(price, shares)
        checks.assert_same_meta(price, fees_paid)
        checks.assert_same_meta(price, slippage_paid)

        # Time series
        self._price = price
        self._cash = cash
        self._shares = shares
        self._fees_paid = fees_paid
        self._slippage_paid = slippage_paid

        # User-defined parameters
        self._init_capital = init_capital
        if data_freq is None:
            data_freq = price.vbt.timeseries.timedelta
        else:
            data_freq = pd.to_timedelta(data_freq)
        self._data_freq = data_freq
        year_freq = defaults.portfolio[&#39;year_freq&#39;] if year_freq is None else year_freq
        year_freq = pd.to_timedelta(year_freq)
        self._year_freq = year_freq
        self._ann_factor = year_freq / data_freq
        self._risk_free = defaults.portfolio[&#39;risk_free&#39;] if risk_free is None else risk_free
        self._required_return = defaults.portfolio[&#39;required_return&#39;] if required_return is None else required_return
        self._cutoff = defaults.portfolio[&#39;cutoff&#39;] if cutoff is None else cutoff
        if factor_returns is not None:
            factor_returns = reshape_fns.broadcast_to(factor_returns, price)
        self._factor_returns = factor_returns

        ArrayWrapper.__init__(self, self.price)

    # ############# Magic methods ############# #

    def __add__(self, other):
        checks.assert_type(other, self.__class__)
        checks.assert_same(self.price, other.price)
        checks.assert_same(self.data_freq, other.data_freq)
        checks.assert_same(self.year_freq, other.year_freq)
        checks.assert_same(self.risk_free, other.risk_free)
        checks.assert_same(self.required_return, other.required_return)
        checks.assert_same(self.cutoff, other.cutoff)
        checks.assert_same(self.factor_returns, other.factor_returns)

        return self.__class__(
            self.price,
            self.cash + other.cash,
            self.shares + other.shares,
            self.init_capital + other.init_capital,
            self.fees_paid + other.fees_paid,
            self.slippage_paid + other.slippage_paid,
            data_freq=self.data_freq,
            year_freq=self.year_freq,
            risk_free=self.risk_free,
            required_return=self.required_return,
            cutoff=self.cutoff,
            factor_returns=self.factor_returns
        )

    def __radd__(self, other):
        return Portfolio.__add__(self, other)

    # ############# Class methods ############# #

    @classmethod
    def from_signals(cls, price, entries, exits, amount=np.inf, init_capital=None,
                     fees=None, slippage=None, broadcast_kwargs={}, **kwargs):
        &#34;&#34;&#34;Build portfolio from entry and exit signals.

        Starting with initial capital `init_capital`, for each `True` in `entries`/`exits`, 
        orders the number of shares specified in `amount`. 

        Args:
            price (pandas_like): Price of the asset.
            entries (pandas_like): Boolean array of entry signals.
            exits (pandas_like): Boolean array of exit signals.
            amount (int, float or array_like): The amount of shares to order. 

                To buy/sell everything, set the amount to `numpy.inf`.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Trading fees in percentage of the value involved.
            slippage (float or array_like): Slippage in percentage of `price`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
        with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

        !!! note
            There is no mechanism implemented to prevent order accumulation, meaning multiple entry/exit 
            signals one after another may increase/decrease your position in the market. That&#39;s why we will
            later calculate P/L of positions instead of trades.

            To select at most one exit signal, use `vectorbt.signals.accessors.Signals_Accessor.first`. 

        Example:
            Portfolio value of various signal sequences:
            ```python-repl
            &gt;&gt;&gt; entries = pd.DataFrame({
            ...     &#39;a&#39;: [True, False, False, False, False],
            ...     &#39;b&#39;: [True, True, True, True, True],
            ...     &#39;c&#39;: [True, False, True, False, True]
            ... }, index=index)
            &gt;&gt;&gt; exits = pd.DataFrame({
            ...     &#39;a&#39;: [False, False, False, False, False],
            ...     &#39;b&#39;: [False, False, False, False, False],
            ...     &#39;c&#39;: [False, True, False, True, False]
            ... }, index=index)

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(price, entries, 
            ...     exits, amount=10, init_capital=100, fees=0.0025)

            &gt;&gt;&gt; print(portfolio.cash)
                             a       b        c
            2018-01-01  89.975  89.975   89.975
            2018-01-02  89.975  69.925  109.925
            2018-01-03  89.975  39.850   79.850
            2018-01-04  89.975  19.800   99.800
            2018-01-05  89.975   9.775   89.775
            &gt;&gt;&gt; print(portfolio.shares)
                           a     b     c
            2018-01-01  10.0  10.0  10.0
            2018-01-02  10.0  20.0   0.0
            2018-01-03  10.0  30.0  10.0
            2018-01-04  10.0  40.0   0.0
            2018-01-05  10.0  50.0  10.0
            &gt;&gt;&gt; print(portfolio.equity)
                              a        b        c
            2018-01-01   99.975   99.975   99.975
            2018-01-02  109.975  109.925  109.925
            2018-01-03  119.975  129.850  109.850
            2018-01-04  109.975   99.800   99.800
            2018-01-05   99.975   59.775   99.775
            &gt;&gt;&gt; print(portfolio.total_costs)
            a    0.025
            b    0.225
            c    0.225
            dtype: float64
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_type(entries, (pd.Series, pd.DataFrame))
        checks.assert_type(exits, (pd.Series, pd.DataFrame))
        entries.vbt.signals.validate()
        exits.vbt.signals.validate()

        # Broadcast inputs
        price, entries, exits, amount, fees, slippage = reshape_fns.broadcast(
            price, entries, exits, amount, fees, slippage, **broadcast_kwargs, writeable=True)

        # Perform calculation
        cash, shares, fees_paid, slippage_paid = nb.portfolio_nb(
            reshape_fns.to_2d(price, raw=True),
            init_capital,
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            nb.signals_order_func_nb,
            reshape_fns.to_2d(entries, raw=True),
            reshape_fns.to_2d(exits, raw=True),
            reshape_fns.to_2d(amount, raw=True))

        # Bring to the same meta
        cash = price.vbt.wrap_array(cash)
        shares = price.vbt.wrap_array(shares)
        fees_paid = price.vbt.wrap_array(fees_paid)
        slippage_paid = price.vbt.wrap_array(slippage_paid)

        return cls(price, cash, shares, init_capital, fees_paid, slippage_paid, **kwargs)

    @classmethod
    def from_orders(cls, price, orders, is_target=False, init_capital=None, fees=None,
                    slippage=None, broadcast_kwargs={}, **kwargs):
        &#34;&#34;&#34;Build portfolio from orders.

        Starting with initial capital `init_capital`, at each time step, orders the number 
        of shares specified in `orders`. 

        Args:
            price (pandas_like): Price of the asset.
            orders (int, float or array_like): The amount of shares to order. 

                If the amount is positive, this is the number of shares to buy. 
                If the amount is negative, this is the number of shares to sell.
                To buy/sell everything, set the amount to `numpy.inf`.
            is_target (bool): If `True`, will order the difference between current and target amount.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Trading fees in percentage of the value involved.
            slippage (float or array_like): Slippage in percentage of `price`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
        with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

        Example:
            Portfolio value of various order sequences:
            ```python-repl
            &gt;&gt;&gt; orders = pd.DataFrame({
            ...     &#39;a&#39;: [np.inf, 0, 0, 0, 0],
            ...     &#39;b&#39;: [1, 1, 1, 1, -np.inf],
            ...     &#39;c&#39;: [np.inf, -np.inf, np.inf, -np.inf, np.inf]
            ... }, index=index)

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
            ...     init_capital=100, fees=0.0025)

            &gt;&gt;&gt; print(portfolio.cash)
                          a        b           c
            2018-01-01  0.0  98.9975    0.000000
            2018-01-02  0.0  96.9925  199.002494
            2018-01-03  0.0  93.9850    0.000000
            2018-01-04  0.0  91.9800  132.006642
            2018-01-05  0.0  95.9700    0.000000
            &gt;&gt;&gt; print(portfolio.shares)
                                a    b           c
            2018-01-01  99.750623  1.0   99.750623
            2018-01-02  99.750623  2.0    0.000000
            2018-01-03  99.750623  3.0   66.168743
            2018-01-04  99.750623  4.0    0.000000
            2018-01-05  99.750623  0.0  131.677448
            &gt;&gt;&gt; print(portfolio.equity)
                                 a         b           c
            2018-01-01   99.750623   99.9975   99.750623
            2018-01-02  199.501247  100.9925  199.002494
            2018-01-03  299.251870  102.9850  198.506228
            2018-01-04  199.501247   99.9800  132.006642
            2018-01-05   99.750623   95.9700  131.677448
            &gt;&gt;&gt; print(portfolio.total_costs)
            a    0.249377
            b    0.030000
            c    1.904433
            dtype: float64
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_type(orders, (pd.Series, pd.DataFrame))

        # Broadcast inputs
        price, orders = reshape_fns.broadcast(price, orders, **broadcast_kwargs, writeable=True)
        fees = reshape_fns.broadcast_to(fees, price, to_pd=False, writeable=True)
        slippage = reshape_fns.broadcast_to(slippage, price, to_pd=False, writeable=True)

        # Perform calculation
        cash, shares, fees_paid, slippage_paid = nb.portfolio_nb(
            reshape_fns.to_2d(price, raw=True),
            init_capital,
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            nb.amount_order_func_nb,
            reshape_fns.to_2d(orders, raw=True),
            is_target)

        # Bring to the same meta
        cash = price.vbt.wrap_array(cash)
        shares = price.vbt.wrap_array(shares)
        fees_paid = price.vbt.wrap_array(fees_paid)
        slippage_paid = price.vbt.wrap_array(slippage_paid)

        return cls(price, cash, shares, init_capital, fees_paid, slippage_paid, **kwargs)

    @classmethod
    def from_order_func(cls, price, order_func_nb, *args, init_capital=None, fees=None, slippage=None, **kwargs):
        &#34;&#34;&#34;Build portfolio from a custom order function.

        Starting with initial capital `init_capital`, at each time step, orders the number 
        of shares returned by `order_func_nb`. 

        Args:
            price (pandas_like): Price of the asset.
            order_func_nb (function): Function that returns the amount of shares to order.

                See `vectorbt.portfolio.nb.portfolio_nb`.
            *args: Arguments passed to `order_func_nb`.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Trading fees in percentage of the value involved.
            slippage (float or array_like): Slippage in percentage of `price`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
        with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

        !!! note
            `order_func_nb` must be Numba-compiled.

        Example:
            Portfolio value of a simple buy-and-hold strategy:
            ```python-repl
            &gt;&gt;&gt; @njit
            ... def order_func_nb(col, i, run_cash, run_shares):
            ...     return 10 if i == 0 else 0

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(price, 
            ...     order_func_nb, init_capital=100, fees=0.0025)

            &gt;&gt;&gt; print(portfolio.cash)
            2018-01-01    89.975
            2018-01-02    89.975
            2018-01-03    89.975
            2018-01-04    89.975
            2018-01-05    89.975
            dtype: float64
            &gt;&gt;&gt; print(portfolio.shares)
            2018-01-01    10.0
            2018-01-02    10.0
            2018-01-03    10.0
            2018-01-04    10.0
            2018-01-05    10.0
            dtype: float64
            &gt;&gt;&gt; print(portfolio.equity)
            2018-01-01     99.975
            2018-01-02    109.975
            2018-01-03    119.975
            2018-01-04    109.975
            2018-01-05     99.975
            dtype: float64
            &gt;&gt;&gt; print(portfolio.total_costs)
            0.02499999999999858
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_numba_func(order_func_nb)

        # Broadcast inputs
        fees = reshape_fns.broadcast_to(fees, price, to_pd=False, writeable=True)
        slippage = reshape_fns.broadcast_to(slippage, price, to_pd=False, writeable=True)

        # Perform calculation
        cash, shares, fees_paid, slippage_paid = nb.portfolio_nb(
            reshape_fns.to_2d(price, raw=True),
            init_capital,
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            order_func_nb,
            *args)

        # Bring to the same meta
        cash = price.vbt.wrap_array(cash)
        shares = price.vbt.wrap_array(shares)
        fees_paid = price.vbt.wrap_array(fees_paid)
        slippage_paid = price.vbt.wrap_array(slippage_paid)

        return cls(price, cash, shares, init_capital, fees_paid, slippage_paid, **kwargs)

    # ############# Built-in time series ############# #

    @timeseries_property(&#39;Price&#39;, OutputFormat.CURRENCY)
    def price(self):
        &#34;&#34;&#34;Price per share at each time step.&#34;&#34;&#34;
        return self._price

    @timeseries_property(&#39;Cash&#39;, OutputFormat.CURRENCY)
    def cash(self):
        &#34;&#34;&#34;Cash held at each time step.&#34;&#34;&#34;
        return self._cash

    @timeseries_property(&#39;Shares&#39;, OutputFormat.NONE)
    def shares(self):
        &#34;&#34;&#34;Shares held at each time step.&#34;&#34;&#34;
        return self._shares

    @timeseries_property(&#39;Paid fees&#39;, OutputFormat.CURRENCY)
    def fees_paid(self):
        &#34;&#34;&#34;Paid fees at each time step.&#34;&#34;&#34;
        return self._fees_paid

    @timeseries_property(&#39;Paid slippage&#39;, OutputFormat.CURRENCY)
    def slippage_paid(self):
        &#34;&#34;&#34;Paid slippage at each time step.&#34;&#34;&#34;
        return self._slippage_paid

    # ############# User-defined parameters ############# #

    @property
    def init_capital(self):
        &#34;&#34;&#34;Initial capital.&#34;&#34;&#34;
        return self._init_capital

    @property
    def data_freq(self):
        &#34;&#34;&#34;Data frequency.&#34;&#34;&#34;
        return self._data_freq

    @property
    def year_freq(self):
        &#34;&#34;&#34;Year frequency.&#34;&#34;&#34;
        return self._year_freq

    @property
    def ann_factor(self):
        &#34;&#34;&#34;Annualization factor.&#34;&#34;&#34;
        return self._ann_factor

    @property
    def risk_free(self):
        &#34;&#34;&#34;Constant risk-free return throughout the period.&#34;&#34;&#34;
        return self._risk_free

    @property
    def required_return(self):
        &#34;&#34;&#34;Minimum acceptance return of the investor.&#34;&#34;&#34;
        return self._required_return

    @property
    def cutoff(self):
        &#34;&#34;&#34;Decimal representing the percentage cutoff for the bottom percentile of returns.&#34;&#34;&#34;
        return self._cutoff

    @property
    def factor_returns(self):
        &#34;&#34;&#34;Benchmark return to compare returns against.&#34;&#34;&#34;
        return self._factor_returns

    # ############# Positions ############# #

    @group_property(&#39;Positions&#39;, Positions)
    def positions(self):
        &#34;&#34;&#34;Positions of the portfolio.&#34;&#34;&#34;
        return Positions(self)

    # ############# Equity ############# #

    @timeseries_property(&#39;Equity&#39;, OutputFormat.CURRENCY)
    def equity(self):
        &#34;&#34;&#34;Portfolio value at each time step.&#34;&#34;&#34;
        equity = self.cash.vbt.to_2d_array() + self.shares.vbt.to_2d_array() * self.price.vbt.to_2d_array()
        return self.wrap_array(equity)

    @metric_property(&#39;Total profit&#39;, OutputFormat.CURRENCY)
    def total_profit(self):
        &#34;&#34;&#34;Total profit.&#34;&#34;&#34;
        total_profit = self.equity.vbt.to_2d_array()[-1, :] - self.init_capital
        return self.wrap_reduced_array(total_profit)

    # ############# Returns ############# #

    @timeseries_property(&#39;Returns&#39;, OutputFormat.PERCENT)
    def returns(self):
        &#34;&#34;&#34;Portfolio returns at each time step.&#34;&#34;&#34;
        returns = timeseries.nb.pct_change_nb(self.equity.vbt.to_2d_array())
        return self.wrap_array(returns)

    @timeseries_property(&#39;Daily returns&#39;, OutputFormat.PERCENT)
    def daily_returns(self):
        &#34;&#34;&#34;Daily returns.&#34;&#34;&#34;
        if self.returns.index.inferred_freq == &#39;D&#39;:
            return self.returns
        return self.returns.vbt.timeseries.resample_apply(&#39;D&#39;, nb.total_return_apply_func_nb)

    @timeseries_property(&#39;Annual returns&#39;, OutputFormat.PERCENT)
    def annual_returns(self):
        &#34;&#34;&#34;Annual returns.&#34;&#34;&#34;
        if self.returns.index.inferred_freq == &#39;Y&#39;:
            return self.returns
        return self.returns.vbt.timeseries.resample_apply(&#39;Y&#39;, nb.total_return_apply_func_nb)

    @metric_property(&#39;Total return&#39;, OutputFormat.PERCENT)
    def total_return(self):
        &#34;&#34;&#34;Total return.&#34;&#34;&#34;
        total_return = reshape_fns.to_1d(self.total_profit, raw=True) / self.init_capital
        return self.wrap_reduced_array(total_return)

    # ############# Trades ############# #

    @timeseries_property(&#39;Trades&#39;, OutputFormat.NONE)
    def trades(self):
        &#34;&#34;&#34;Amount of shares ordered at each time step.&#34;&#34;&#34;
        shares = self.shares.vbt.to_2d_array()
        trades = timeseries.nb.fillna_nb(timeseries.nb.diff_nb(shares), 0)
        trades[0, :] = shares[0, :]
        return self.wrap_array(trades)

    def plot_trades(self,
                    buy_trace_kwargs={},
                    sell_trace_kwargs={},
                    fig=None,
                    **layout_kwargs):
        &#34;&#34;&#34;Plot trades as markers.

        Args:
            buy_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Buy&#34; markers.
            sell_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Sell&#34; markers.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            vbt.Portfolio.from_orders(price, price.diff(), init_capital=100).plot_trades()
            ```

            ![](/vectorbt/docs/img/portfolio_plot_trades.png)&#34;&#34;&#34;
        checks.assert_type(self.price, pd.Series)
        checks.assert_type(self.trades, pd.Series)
        sell_mask = self.trades &lt; 0
        buy_mask = self.trades &gt; 0

        # Plot time series
        fig = self.price.vbt.timeseries.plot(fig=fig, **layout_kwargs)
        # Plot markers
        buy_trace_kwargs = common.merge_kwargs(dict(
            customdata=self.trades[buy_mask],
            hovertemplate=&#39;(%{x}, %{y})&lt;br&gt;%{customdata:.6g}&#39;,
            marker=dict(
                symbol=&#39;triangle-up&#39;,
                color=&#39;limegreen&#39;
            )
        ), buy_trace_kwargs)
        buy_mask.vbt.signals.plot_markers(
            self.price, name=&#39;Buy&#39;, trace_kwargs=buy_trace_kwargs, fig=fig, **layout_kwargs)
        sell_trace_kwargs = common.merge_kwargs(dict(
            customdata=self.trades[sell_mask],
            hovertemplate=&#39;(%{x}, %{y})&lt;br&gt;%{customdata:.6g}&#39;,
            marker=dict(
                symbol=&#39;triangle-down&#39;,
                color=&#39;orangered&#39;
            )
        ), sell_trace_kwargs)
        sell_mask.vbt.signals.plot_markers(
            self.price, name=&#39;Sell&#39;, trace_kwargs=sell_trace_kwargs, fig=fig, **layout_kwargs)
        return fig

    @metric_property(&#39;Trade count&#39;, OutputFormat.NONE)
    def trade_count(self):
        &#34;&#34;&#34;Number of trades.&#34;&#34;&#34;
        trade_count = (self.trades.vbt.to_2d_array() &gt; 0).sum(axis=0)
        return self.wrap_reduced_array(trade_count)

    # ############# Drawdown ############# #

    @timeseries_property(&#39;Drawdown&#39;, OutputFormat.PERCENT)
    def drawdown(self):
        &#34;&#34;&#34;Relative decline from a peak at each time step.&#34;&#34;&#34;
        equity = self.equity.vbt.to_2d_array()
        drawdown = 1 - equity / timeseries.nb.expanding_max_nb(equity)
        return self.wrap_array(drawdown)

    @metric_property(&#39;Max drawdown&#39;, OutputFormat.PERCENT)
    def max_drawdown(self):
        &#34;&#34;&#34;Total maximum drawdown (MDD).&#34;&#34;&#34;
        max_drawdown = np.max(self.drawdown.vbt.to_2d_array(), axis=0)
        return self.wrap_reduced_array(max_drawdown)

    # ############# Costs ############# #

    @metric_property(&#39;Total paid fees&#39;, OutputFormat.CURRENCY)
    def total_fees_paid(self):
        &#34;&#34;&#34;Total paid fees.&#34;&#34;&#34;
        total_fees_paid = np.sum(self.fees_paid.vbt.to_2d_array(), axis=0)
        return self.wrap_reduced_array(total_fees_paid)

    @metric_property(&#39;Total paid slippage&#39;, OutputFormat.CURRENCY)
    def total_slippage_paid(self):
        &#34;&#34;&#34;Total paid slippage.&#34;&#34;&#34;
        total_slippage_paid = np.sum(self.slippage_paid.vbt.to_2d_array(), axis=0)
        return self.wrap_reduced_array(total_slippage_paid)

    @metric_property(&#39;Total costs&#39;, OutputFormat.CURRENCY)
    def total_costs(self):
        &#34;&#34;&#34;Total costs.&#34;&#34;&#34;
        total_fees_paid = reshape_fns.to_1d(self.total_fees_paid, raw=True)
        total_slippage_paid = reshape_fns.to_1d(self.total_slippage_paid, raw=True)
        total_costs = total_fees_paid + total_slippage_paid
        return self.wrap_reduced_array(total_costs)

    # ############# Risk and performance metrics ############# #

    @timeseries_property(&#39;Cumulative returns&#39;, OutputFormat.PERCENT)
    def cum_returns(self):
        &#34;&#34;&#34;Cumulative returns at each time step.&#34;&#34;&#34;
        return self.wrap_array(nb.cum_returns_nb(self.returns.vbt.to_2d_array()))

    @metric_property(&#39;Annualized return&#39;, OutputFormat.PERCENT)
    def annualized_return(self):
        &#34;&#34;&#34;Mean annual growth rate of returns. 

        This is equivilent to the compound annual growth rate.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.annualized_return_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Annualized volatility&#39;, OutputFormat.PERCENT)
    def annualized_volatility(self):
        &#34;&#34;&#34;Annualized volatility of a strategy.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.annualized_volatility_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Calmar ratio&#39;, OutputFormat.PERCENT)
    def calmar_ratio(self):
        &#34;&#34;&#34;Calmar ratio, or drawdown ratio, of a strategy.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.calmar_ratio_nb(
            self.returns.vbt.to_2d_array(),
            reshape_fns.to_1d(self.annualized_return, raw=True),
            reshape_fns.to_1d(self.max_drawdown, raw=True),
            self.ann_factor))

    @metric_property(&#39;Omega ratio&#39;, OutputFormat.PERCENT)
    def omega_ratio(self):
        &#34;&#34;&#34;Omega ratio of a strategy.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.omega_ratio_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor,
            risk_free=self.risk_free,
            required_return=self.required_return))

    @metric_property(&#39;Sharpe ratio&#39;, OutputFormat.PERCENT)
    def sharpe_ratio(self):
        &#34;&#34;&#34;Sharpe ratio of a strategy.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.sharpe_ratio_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor,
            risk_free=self.risk_free))

    @metric_property(&#39;Downside risk&#39;, OutputFormat.PERCENT)
    def downside_risk(self):
        &#34;&#34;&#34;Downside deviation below a threshold.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.downside_risk_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor,
            required_return=self.required_return))

    @metric_property(&#39;Sortino ratio&#39;, OutputFormat.PERCENT)
    def sortino_ratio(self):
        &#34;&#34;&#34;Sortino ratio of a strategy.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.sortino_ratio_nb(
            self.returns.vbt.to_2d_array(),
            reshape_fns.to_1d(self.downside_risk, raw=True),
            self.ann_factor,
            required_return=self.required_return))

    @metric_property(&#39;Information ratio&#39;, OutputFormat.PERCENT)
    def information_ratio(self):
        &#34;&#34;&#34;Information ratio of a strategy.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrap_reduced_array(nb.information_ratio_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array()))

    @metric_property(&#39;Beta&#39;, OutputFormat.PERCENT)
    def beta(self):
        &#34;&#34;&#34;Beta.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrap_reduced_array(nb.beta_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            risk_free=self.risk_free))

    @metric_property(&#39;Annualized alpha&#39;, OutputFormat.PERCENT)
    def alpha(self):
        &#34;&#34;&#34;Annualized alpha.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrap_reduced_array(nb.alpha_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            reshape_fns.to_1d(self.beta, raw=True),
            self.ann_factor,
            risk_free=self.risk_free))

    @metric_property(&#39;Tail ratio&#39;, OutputFormat.PERCENT)
    def tail_ratio(self):
        &#34;&#34;&#34;Ratio between the right (95%) and left tail (5%).&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.tail_ratio_nb(self.returns.vbt.to_2d_array()))

    @metric_property(&#39;Value at risk&#39;, OutputFormat.CURRENCY)
    def value_at_risk(self):
        &#34;&#34;&#34;Value at risk (VaR) of a returns stream.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.value_at_risk_nb(
            self.returns.vbt.to_2d_array(),
            cutoff=self.cutoff))

    @metric_property(&#39;Conditional value at risk&#39;, OutputFormat.CURRENCY)
    def conditional_value_at_risk(self):
        &#34;&#34;&#34;Conditional value at risk (CVaR) of a returns stream.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.conditional_value_at_risk_nb(
            self.returns.vbt.to_2d_array(),
            cutoff=self.cutoff))

    @metric_property(&#39;Capture ratio&#39;, OutputFormat.PERCENT)
    def capture(self):
        &#34;&#34;&#34;Capture ratio.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrap_reduced_array(nb.capture_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Capture ratio (positive)&#39;, OutputFormat.PERCENT)
    def up_capture(self):
        &#34;&#34;&#34;Capture ratio for periods when the benchmark return is positive.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrap_reduced_array(nb.up_capture_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Capture ratio (negative)&#39;, OutputFormat.PERCENT)
    def down_capture(self):
        &#34;&#34;&#34;Capture ratio for periods when the benchmark return is negative.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrap_reduced_array(nb.down_capture_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Skewness&#39;, OutputFormat.NONE)
    def skew(self):
        &#34;&#34;&#34;Skewness of returns.&#34;&#34;&#34;
        return self.wrap_reduced_array(stats.skew(self.returns.vbt.to_2d_array(), axis=0, nan_policy=&#39;omit&#39;))

    @metric_property(&#39;Kurtosis&#39;, OutputFormat.NONE)
    def kurtosis(self):
        &#34;&#34;&#34;Kurtosis of returns.&#34;&#34;&#34;
        return self.wrap_reduced_array(stats.kurtosis(self.returns.vbt.to_2d_array(), axis=0, nan_policy=&#39;omit&#39;))


__all__ = list_module_keys(__name__, blacklist=[&#39;portfolio_indexing_func&#39;])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.portfolio.portfolio.Portfolio"><code class="flex name class">
<span>class <span class="ident">Portfolio</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for building a portfolio and measuring its performance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Price of the asset.</dd>
<dt><strong><code>cash</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Cash held at each time step. Must have the same metadata as <code>price</code>.</dd>
<dt><strong><code>shares</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Shares held at each time step. Must have the same metadata as <code>price</code>.</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The initial capital.</dd>
<dt><strong><code>fees_paid</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Fees paid at each time step. Must have the same metadata as <code>price</code>.</dd>
<dt><strong><code>slippage_paid</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Slippage paid at each time step. Must have the same metadata as <code>price</code>.</dd>
<dt><strong><code>data_freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Data frequency in case <code>price.index</code> is not datetime-like. Will be passed to <code>pandas.to_timedelta</code>.</dd>
<dt><strong><code>year_freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Year frequency. Will be passed to <code>pandas.to_timedelta</code>.</dd>
<dt><strong><code>risk_free</code></strong> :&ensp;<code>float</code></dt>
<dd>Constant risk-free return throughout the period.</dd>
<dt><strong><code>required_return</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum acceptance return of the investor.</dd>
<dt><strong><code>cutoff</code></strong> :&ensp;<code>float</code></dt>
<dd>Decimal representing the percentage cutoff for the bottom percentile of returns.</dd>
<dt><strong><code>factor_returns</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Benchmark return to compare returns against.
If set, will be broadcasted to the shape of <code>price</code>.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.defaults.portfolio" href="../defaults.html#vectorbt.defaults.portfolio">portfolio</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Portfolio is only built by using class methods with <code>from_</code> prefix.
The <code>__init__</code> method is reserved for indexing purposes.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Portfolio(ArrayWrapper):
    &#34;&#34;&#34;Class for building a portfolio and measuring its performance.

    Args:
        price (pandas_like): Price of the asset.
        cash (pandas_like): Cash held at each time step. Must have the same metadata as `price`.
        shares (pandas_like): Shares held at each time step. Must have the same metadata as `price`.
        init_capital (int or float): The initial capital.
        fees_paid (pandas_like): Fees paid at each time step. Must have the same metadata as `price`.
        slippage_paid (pandas_like): Slippage paid at each time step. Must have the same metadata as `price`.
        data_freq (any): Data frequency in case `price.index` is not datetime-like. Will be passed to `pandas.to_timedelta`.
        year_freq (any): Year frequency. Will be passed to `pandas.to_timedelta`.
        risk_free (float): Constant risk-free return throughout the period.
        required_return (float): Minimum acceptance return of the investor.
        cutoff (float): Decimal representing the percentage cutoff for the bottom percentile of returns.
        factor_returns (pandas_like): Benchmark return to compare returns against. 
                If set, will be broadcasted to the shape of `price`.

    For defaults, see `vectorbt.defaults.portfolio`.

    !!! note
        Portfolio is only built by using class methods with `from_` prefix.
        The `__init__` method is reserved for indexing purposes.&#34;&#34;&#34;

    def __init__(self, price, cash, shares, init_capital, fees_paid, slippage_paid, data_freq=None,
                 year_freq=None, risk_free=None, required_return=None, cutoff=None, factor_returns=None):
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_same_meta(price, cash)
        checks.assert_same_meta(price, shares)
        checks.assert_same_meta(price, fees_paid)
        checks.assert_same_meta(price, slippage_paid)

        # Time series
        self._price = price
        self._cash = cash
        self._shares = shares
        self._fees_paid = fees_paid
        self._slippage_paid = slippage_paid

        # User-defined parameters
        self._init_capital = init_capital
        if data_freq is None:
            data_freq = price.vbt.timeseries.timedelta
        else:
            data_freq = pd.to_timedelta(data_freq)
        self._data_freq = data_freq
        year_freq = defaults.portfolio[&#39;year_freq&#39;] if year_freq is None else year_freq
        year_freq = pd.to_timedelta(year_freq)
        self._year_freq = year_freq
        self._ann_factor = year_freq / data_freq
        self._risk_free = defaults.portfolio[&#39;risk_free&#39;] if risk_free is None else risk_free
        self._required_return = defaults.portfolio[&#39;required_return&#39;] if required_return is None else required_return
        self._cutoff = defaults.portfolio[&#39;cutoff&#39;] if cutoff is None else cutoff
        if factor_returns is not None:
            factor_returns = reshape_fns.broadcast_to(factor_returns, price)
        self._factor_returns = factor_returns

        ArrayWrapper.__init__(self, self.price)

    # ############# Magic methods ############# #

    def __add__(self, other):
        checks.assert_type(other, self.__class__)
        checks.assert_same(self.price, other.price)
        checks.assert_same(self.data_freq, other.data_freq)
        checks.assert_same(self.year_freq, other.year_freq)
        checks.assert_same(self.risk_free, other.risk_free)
        checks.assert_same(self.required_return, other.required_return)
        checks.assert_same(self.cutoff, other.cutoff)
        checks.assert_same(self.factor_returns, other.factor_returns)

        return self.__class__(
            self.price,
            self.cash + other.cash,
            self.shares + other.shares,
            self.init_capital + other.init_capital,
            self.fees_paid + other.fees_paid,
            self.slippage_paid + other.slippage_paid,
            data_freq=self.data_freq,
            year_freq=self.year_freq,
            risk_free=self.risk_free,
            required_return=self.required_return,
            cutoff=self.cutoff,
            factor_returns=self.factor_returns
        )

    def __radd__(self, other):
        return Portfolio.__add__(self, other)

    # ############# Class methods ############# #

    @classmethod
    def from_signals(cls, price, entries, exits, amount=np.inf, init_capital=None,
                     fees=None, slippage=None, broadcast_kwargs={}, **kwargs):
        &#34;&#34;&#34;Build portfolio from entry and exit signals.

        Starting with initial capital `init_capital`, for each `True` in `entries`/`exits`, 
        orders the number of shares specified in `amount`. 

        Args:
            price (pandas_like): Price of the asset.
            entries (pandas_like): Boolean array of entry signals.
            exits (pandas_like): Boolean array of exit signals.
            amount (int, float or array_like): The amount of shares to order. 

                To buy/sell everything, set the amount to `numpy.inf`.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Trading fees in percentage of the value involved.
            slippage (float or array_like): Slippage in percentage of `price`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
        with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

        !!! note
            There is no mechanism implemented to prevent order accumulation, meaning multiple entry/exit 
            signals one after another may increase/decrease your position in the market. That&#39;s why we will
            later calculate P/L of positions instead of trades.

            To select at most one exit signal, use `vectorbt.signals.accessors.Signals_Accessor.first`. 

        Example:
            Portfolio value of various signal sequences:
            ```python-repl
            &gt;&gt;&gt; entries = pd.DataFrame({
            ...     &#39;a&#39;: [True, False, False, False, False],
            ...     &#39;b&#39;: [True, True, True, True, True],
            ...     &#39;c&#39;: [True, False, True, False, True]
            ... }, index=index)
            &gt;&gt;&gt; exits = pd.DataFrame({
            ...     &#39;a&#39;: [False, False, False, False, False],
            ...     &#39;b&#39;: [False, False, False, False, False],
            ...     &#39;c&#39;: [False, True, False, True, False]
            ... }, index=index)

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(price, entries, 
            ...     exits, amount=10, init_capital=100, fees=0.0025)

            &gt;&gt;&gt; print(portfolio.cash)
                             a       b        c
            2018-01-01  89.975  89.975   89.975
            2018-01-02  89.975  69.925  109.925
            2018-01-03  89.975  39.850   79.850
            2018-01-04  89.975  19.800   99.800
            2018-01-05  89.975   9.775   89.775
            &gt;&gt;&gt; print(portfolio.shares)
                           a     b     c
            2018-01-01  10.0  10.0  10.0
            2018-01-02  10.0  20.0   0.0
            2018-01-03  10.0  30.0  10.0
            2018-01-04  10.0  40.0   0.0
            2018-01-05  10.0  50.0  10.0
            &gt;&gt;&gt; print(portfolio.equity)
                              a        b        c
            2018-01-01   99.975   99.975   99.975
            2018-01-02  109.975  109.925  109.925
            2018-01-03  119.975  129.850  109.850
            2018-01-04  109.975   99.800   99.800
            2018-01-05   99.975   59.775   99.775
            &gt;&gt;&gt; print(portfolio.total_costs)
            a    0.025
            b    0.225
            c    0.225
            dtype: float64
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_type(entries, (pd.Series, pd.DataFrame))
        checks.assert_type(exits, (pd.Series, pd.DataFrame))
        entries.vbt.signals.validate()
        exits.vbt.signals.validate()

        # Broadcast inputs
        price, entries, exits, amount, fees, slippage = reshape_fns.broadcast(
            price, entries, exits, amount, fees, slippage, **broadcast_kwargs, writeable=True)

        # Perform calculation
        cash, shares, fees_paid, slippage_paid = nb.portfolio_nb(
            reshape_fns.to_2d(price, raw=True),
            init_capital,
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            nb.signals_order_func_nb,
            reshape_fns.to_2d(entries, raw=True),
            reshape_fns.to_2d(exits, raw=True),
            reshape_fns.to_2d(amount, raw=True))

        # Bring to the same meta
        cash = price.vbt.wrap_array(cash)
        shares = price.vbt.wrap_array(shares)
        fees_paid = price.vbt.wrap_array(fees_paid)
        slippage_paid = price.vbt.wrap_array(slippage_paid)

        return cls(price, cash, shares, init_capital, fees_paid, slippage_paid, **kwargs)

    @classmethod
    def from_orders(cls, price, orders, is_target=False, init_capital=None, fees=None,
                    slippage=None, broadcast_kwargs={}, **kwargs):
        &#34;&#34;&#34;Build portfolio from orders.

        Starting with initial capital `init_capital`, at each time step, orders the number 
        of shares specified in `orders`. 

        Args:
            price (pandas_like): Price of the asset.
            orders (int, float or array_like): The amount of shares to order. 

                If the amount is positive, this is the number of shares to buy. 
                If the amount is negative, this is the number of shares to sell.
                To buy/sell everything, set the amount to `numpy.inf`.
            is_target (bool): If `True`, will order the difference between current and target amount.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Trading fees in percentage of the value involved.
            slippage (float or array_like): Slippage in percentage of `price`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
        with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

        Example:
            Portfolio value of various order sequences:
            ```python-repl
            &gt;&gt;&gt; orders = pd.DataFrame({
            ...     &#39;a&#39;: [np.inf, 0, 0, 0, 0],
            ...     &#39;b&#39;: [1, 1, 1, 1, -np.inf],
            ...     &#39;c&#39;: [np.inf, -np.inf, np.inf, -np.inf, np.inf]
            ... }, index=index)

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
            ...     init_capital=100, fees=0.0025)

            &gt;&gt;&gt; print(portfolio.cash)
                          a        b           c
            2018-01-01  0.0  98.9975    0.000000
            2018-01-02  0.0  96.9925  199.002494
            2018-01-03  0.0  93.9850    0.000000
            2018-01-04  0.0  91.9800  132.006642
            2018-01-05  0.0  95.9700    0.000000
            &gt;&gt;&gt; print(portfolio.shares)
                                a    b           c
            2018-01-01  99.750623  1.0   99.750623
            2018-01-02  99.750623  2.0    0.000000
            2018-01-03  99.750623  3.0   66.168743
            2018-01-04  99.750623  4.0    0.000000
            2018-01-05  99.750623  0.0  131.677448
            &gt;&gt;&gt; print(portfolio.equity)
                                 a         b           c
            2018-01-01   99.750623   99.9975   99.750623
            2018-01-02  199.501247  100.9925  199.002494
            2018-01-03  299.251870  102.9850  198.506228
            2018-01-04  199.501247   99.9800  132.006642
            2018-01-05   99.750623   95.9700  131.677448
            &gt;&gt;&gt; print(portfolio.total_costs)
            a    0.249377
            b    0.030000
            c    1.904433
            dtype: float64
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_type(orders, (pd.Series, pd.DataFrame))

        # Broadcast inputs
        price, orders = reshape_fns.broadcast(price, orders, **broadcast_kwargs, writeable=True)
        fees = reshape_fns.broadcast_to(fees, price, to_pd=False, writeable=True)
        slippage = reshape_fns.broadcast_to(slippage, price, to_pd=False, writeable=True)

        # Perform calculation
        cash, shares, fees_paid, slippage_paid = nb.portfolio_nb(
            reshape_fns.to_2d(price, raw=True),
            init_capital,
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            nb.amount_order_func_nb,
            reshape_fns.to_2d(orders, raw=True),
            is_target)

        # Bring to the same meta
        cash = price.vbt.wrap_array(cash)
        shares = price.vbt.wrap_array(shares)
        fees_paid = price.vbt.wrap_array(fees_paid)
        slippage_paid = price.vbt.wrap_array(slippage_paid)

        return cls(price, cash, shares, init_capital, fees_paid, slippage_paid, **kwargs)

    @classmethod
    def from_order_func(cls, price, order_func_nb, *args, init_capital=None, fees=None, slippage=None, **kwargs):
        &#34;&#34;&#34;Build portfolio from a custom order function.

        Starting with initial capital `init_capital`, at each time step, orders the number 
        of shares returned by `order_func_nb`. 

        Args:
            price (pandas_like): Price of the asset.
            order_func_nb (function): Function that returns the amount of shares to order.

                See `vectorbt.portfolio.nb.portfolio_nb`.
            *args: Arguments passed to `order_func_nb`.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Trading fees in percentage of the value involved.
            slippage (float or array_like): Slippage in percentage of `price`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
        with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

        !!! note
            `order_func_nb` must be Numba-compiled.

        Example:
            Portfolio value of a simple buy-and-hold strategy:
            ```python-repl
            &gt;&gt;&gt; @njit
            ... def order_func_nb(col, i, run_cash, run_shares):
            ...     return 10 if i == 0 else 0

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(price, 
            ...     order_func_nb, init_capital=100, fees=0.0025)

            &gt;&gt;&gt; print(portfolio.cash)
            2018-01-01    89.975
            2018-01-02    89.975
            2018-01-03    89.975
            2018-01-04    89.975
            2018-01-05    89.975
            dtype: float64
            &gt;&gt;&gt; print(portfolio.shares)
            2018-01-01    10.0
            2018-01-02    10.0
            2018-01-03    10.0
            2018-01-04    10.0
            2018-01-05    10.0
            dtype: float64
            &gt;&gt;&gt; print(portfolio.equity)
            2018-01-01     99.975
            2018-01-02    109.975
            2018-01-03    119.975
            2018-01-04    109.975
            2018-01-05     99.975
            dtype: float64
            &gt;&gt;&gt; print(portfolio.total_costs)
            0.02499999999999858
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_numba_func(order_func_nb)

        # Broadcast inputs
        fees = reshape_fns.broadcast_to(fees, price, to_pd=False, writeable=True)
        slippage = reshape_fns.broadcast_to(slippage, price, to_pd=False, writeable=True)

        # Perform calculation
        cash, shares, fees_paid, slippage_paid = nb.portfolio_nb(
            reshape_fns.to_2d(price, raw=True),
            init_capital,
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            order_func_nb,
            *args)

        # Bring to the same meta
        cash = price.vbt.wrap_array(cash)
        shares = price.vbt.wrap_array(shares)
        fees_paid = price.vbt.wrap_array(fees_paid)
        slippage_paid = price.vbt.wrap_array(slippage_paid)

        return cls(price, cash, shares, init_capital, fees_paid, slippage_paid, **kwargs)

    # ############# Built-in time series ############# #

    @timeseries_property(&#39;Price&#39;, OutputFormat.CURRENCY)
    def price(self):
        &#34;&#34;&#34;Price per share at each time step.&#34;&#34;&#34;
        return self._price

    @timeseries_property(&#39;Cash&#39;, OutputFormat.CURRENCY)
    def cash(self):
        &#34;&#34;&#34;Cash held at each time step.&#34;&#34;&#34;
        return self._cash

    @timeseries_property(&#39;Shares&#39;, OutputFormat.NONE)
    def shares(self):
        &#34;&#34;&#34;Shares held at each time step.&#34;&#34;&#34;
        return self._shares

    @timeseries_property(&#39;Paid fees&#39;, OutputFormat.CURRENCY)
    def fees_paid(self):
        &#34;&#34;&#34;Paid fees at each time step.&#34;&#34;&#34;
        return self._fees_paid

    @timeseries_property(&#39;Paid slippage&#39;, OutputFormat.CURRENCY)
    def slippage_paid(self):
        &#34;&#34;&#34;Paid slippage at each time step.&#34;&#34;&#34;
        return self._slippage_paid

    # ############# User-defined parameters ############# #

    @property
    def init_capital(self):
        &#34;&#34;&#34;Initial capital.&#34;&#34;&#34;
        return self._init_capital

    @property
    def data_freq(self):
        &#34;&#34;&#34;Data frequency.&#34;&#34;&#34;
        return self._data_freq

    @property
    def year_freq(self):
        &#34;&#34;&#34;Year frequency.&#34;&#34;&#34;
        return self._year_freq

    @property
    def ann_factor(self):
        &#34;&#34;&#34;Annualization factor.&#34;&#34;&#34;
        return self._ann_factor

    @property
    def risk_free(self):
        &#34;&#34;&#34;Constant risk-free return throughout the period.&#34;&#34;&#34;
        return self._risk_free

    @property
    def required_return(self):
        &#34;&#34;&#34;Minimum acceptance return of the investor.&#34;&#34;&#34;
        return self._required_return

    @property
    def cutoff(self):
        &#34;&#34;&#34;Decimal representing the percentage cutoff for the bottom percentile of returns.&#34;&#34;&#34;
        return self._cutoff

    @property
    def factor_returns(self):
        &#34;&#34;&#34;Benchmark return to compare returns against.&#34;&#34;&#34;
        return self._factor_returns

    # ############# Positions ############# #

    @group_property(&#39;Positions&#39;, Positions)
    def positions(self):
        &#34;&#34;&#34;Positions of the portfolio.&#34;&#34;&#34;
        return Positions(self)

    # ############# Equity ############# #

    @timeseries_property(&#39;Equity&#39;, OutputFormat.CURRENCY)
    def equity(self):
        &#34;&#34;&#34;Portfolio value at each time step.&#34;&#34;&#34;
        equity = self.cash.vbt.to_2d_array() + self.shares.vbt.to_2d_array() * self.price.vbt.to_2d_array()
        return self.wrap_array(equity)

    @metric_property(&#39;Total profit&#39;, OutputFormat.CURRENCY)
    def total_profit(self):
        &#34;&#34;&#34;Total profit.&#34;&#34;&#34;
        total_profit = self.equity.vbt.to_2d_array()[-1, :] - self.init_capital
        return self.wrap_reduced_array(total_profit)

    # ############# Returns ############# #

    @timeseries_property(&#39;Returns&#39;, OutputFormat.PERCENT)
    def returns(self):
        &#34;&#34;&#34;Portfolio returns at each time step.&#34;&#34;&#34;
        returns = timeseries.nb.pct_change_nb(self.equity.vbt.to_2d_array())
        return self.wrap_array(returns)

    @timeseries_property(&#39;Daily returns&#39;, OutputFormat.PERCENT)
    def daily_returns(self):
        &#34;&#34;&#34;Daily returns.&#34;&#34;&#34;
        if self.returns.index.inferred_freq == &#39;D&#39;:
            return self.returns
        return self.returns.vbt.timeseries.resample_apply(&#39;D&#39;, nb.total_return_apply_func_nb)

    @timeseries_property(&#39;Annual returns&#39;, OutputFormat.PERCENT)
    def annual_returns(self):
        &#34;&#34;&#34;Annual returns.&#34;&#34;&#34;
        if self.returns.index.inferred_freq == &#39;Y&#39;:
            return self.returns
        return self.returns.vbt.timeseries.resample_apply(&#39;Y&#39;, nb.total_return_apply_func_nb)

    @metric_property(&#39;Total return&#39;, OutputFormat.PERCENT)
    def total_return(self):
        &#34;&#34;&#34;Total return.&#34;&#34;&#34;
        total_return = reshape_fns.to_1d(self.total_profit, raw=True) / self.init_capital
        return self.wrap_reduced_array(total_return)

    # ############# Trades ############# #

    @timeseries_property(&#39;Trades&#39;, OutputFormat.NONE)
    def trades(self):
        &#34;&#34;&#34;Amount of shares ordered at each time step.&#34;&#34;&#34;
        shares = self.shares.vbt.to_2d_array()
        trades = timeseries.nb.fillna_nb(timeseries.nb.diff_nb(shares), 0)
        trades[0, :] = shares[0, :]
        return self.wrap_array(trades)

    def plot_trades(self,
                    buy_trace_kwargs={},
                    sell_trace_kwargs={},
                    fig=None,
                    **layout_kwargs):
        &#34;&#34;&#34;Plot trades as markers.

        Args:
            buy_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Buy&#34; markers.
            sell_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Sell&#34; markers.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            vbt.Portfolio.from_orders(price, price.diff(), init_capital=100).plot_trades()
            ```

            ![](/vectorbt/docs/img/portfolio_plot_trades.png)&#34;&#34;&#34;
        checks.assert_type(self.price, pd.Series)
        checks.assert_type(self.trades, pd.Series)
        sell_mask = self.trades &lt; 0
        buy_mask = self.trades &gt; 0

        # Plot time series
        fig = self.price.vbt.timeseries.plot(fig=fig, **layout_kwargs)
        # Plot markers
        buy_trace_kwargs = common.merge_kwargs(dict(
            customdata=self.trades[buy_mask],
            hovertemplate=&#39;(%{x}, %{y})&lt;br&gt;%{customdata:.6g}&#39;,
            marker=dict(
                symbol=&#39;triangle-up&#39;,
                color=&#39;limegreen&#39;
            )
        ), buy_trace_kwargs)
        buy_mask.vbt.signals.plot_markers(
            self.price, name=&#39;Buy&#39;, trace_kwargs=buy_trace_kwargs, fig=fig, **layout_kwargs)
        sell_trace_kwargs = common.merge_kwargs(dict(
            customdata=self.trades[sell_mask],
            hovertemplate=&#39;(%{x}, %{y})&lt;br&gt;%{customdata:.6g}&#39;,
            marker=dict(
                symbol=&#39;triangle-down&#39;,
                color=&#39;orangered&#39;
            )
        ), sell_trace_kwargs)
        sell_mask.vbt.signals.plot_markers(
            self.price, name=&#39;Sell&#39;, trace_kwargs=sell_trace_kwargs, fig=fig, **layout_kwargs)
        return fig

    @metric_property(&#39;Trade count&#39;, OutputFormat.NONE)
    def trade_count(self):
        &#34;&#34;&#34;Number of trades.&#34;&#34;&#34;
        trade_count = (self.trades.vbt.to_2d_array() &gt; 0).sum(axis=0)
        return self.wrap_reduced_array(trade_count)

    # ############# Drawdown ############# #

    @timeseries_property(&#39;Drawdown&#39;, OutputFormat.PERCENT)
    def drawdown(self):
        &#34;&#34;&#34;Relative decline from a peak at each time step.&#34;&#34;&#34;
        equity = self.equity.vbt.to_2d_array()
        drawdown = 1 - equity / timeseries.nb.expanding_max_nb(equity)
        return self.wrap_array(drawdown)

    @metric_property(&#39;Max drawdown&#39;, OutputFormat.PERCENT)
    def max_drawdown(self):
        &#34;&#34;&#34;Total maximum drawdown (MDD).&#34;&#34;&#34;
        max_drawdown = np.max(self.drawdown.vbt.to_2d_array(), axis=0)
        return self.wrap_reduced_array(max_drawdown)

    # ############# Costs ############# #

    @metric_property(&#39;Total paid fees&#39;, OutputFormat.CURRENCY)
    def total_fees_paid(self):
        &#34;&#34;&#34;Total paid fees.&#34;&#34;&#34;
        total_fees_paid = np.sum(self.fees_paid.vbt.to_2d_array(), axis=0)
        return self.wrap_reduced_array(total_fees_paid)

    @metric_property(&#39;Total paid slippage&#39;, OutputFormat.CURRENCY)
    def total_slippage_paid(self):
        &#34;&#34;&#34;Total paid slippage.&#34;&#34;&#34;
        total_slippage_paid = np.sum(self.slippage_paid.vbt.to_2d_array(), axis=0)
        return self.wrap_reduced_array(total_slippage_paid)

    @metric_property(&#39;Total costs&#39;, OutputFormat.CURRENCY)
    def total_costs(self):
        &#34;&#34;&#34;Total costs.&#34;&#34;&#34;
        total_fees_paid = reshape_fns.to_1d(self.total_fees_paid, raw=True)
        total_slippage_paid = reshape_fns.to_1d(self.total_slippage_paid, raw=True)
        total_costs = total_fees_paid + total_slippage_paid
        return self.wrap_reduced_array(total_costs)

    # ############# Risk and performance metrics ############# #

    @timeseries_property(&#39;Cumulative returns&#39;, OutputFormat.PERCENT)
    def cum_returns(self):
        &#34;&#34;&#34;Cumulative returns at each time step.&#34;&#34;&#34;
        return self.wrap_array(nb.cum_returns_nb(self.returns.vbt.to_2d_array()))

    @metric_property(&#39;Annualized return&#39;, OutputFormat.PERCENT)
    def annualized_return(self):
        &#34;&#34;&#34;Mean annual growth rate of returns. 

        This is equivilent to the compound annual growth rate.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.annualized_return_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Annualized volatility&#39;, OutputFormat.PERCENT)
    def annualized_volatility(self):
        &#34;&#34;&#34;Annualized volatility of a strategy.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.annualized_volatility_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Calmar ratio&#39;, OutputFormat.PERCENT)
    def calmar_ratio(self):
        &#34;&#34;&#34;Calmar ratio, or drawdown ratio, of a strategy.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.calmar_ratio_nb(
            self.returns.vbt.to_2d_array(),
            reshape_fns.to_1d(self.annualized_return, raw=True),
            reshape_fns.to_1d(self.max_drawdown, raw=True),
            self.ann_factor))

    @metric_property(&#39;Omega ratio&#39;, OutputFormat.PERCENT)
    def omega_ratio(self):
        &#34;&#34;&#34;Omega ratio of a strategy.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.omega_ratio_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor,
            risk_free=self.risk_free,
            required_return=self.required_return))

    @metric_property(&#39;Sharpe ratio&#39;, OutputFormat.PERCENT)
    def sharpe_ratio(self):
        &#34;&#34;&#34;Sharpe ratio of a strategy.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.sharpe_ratio_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor,
            risk_free=self.risk_free))

    @metric_property(&#39;Downside risk&#39;, OutputFormat.PERCENT)
    def downside_risk(self):
        &#34;&#34;&#34;Downside deviation below a threshold.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.downside_risk_nb(
            self.returns.vbt.to_2d_array(),
            self.ann_factor,
            required_return=self.required_return))

    @metric_property(&#39;Sortino ratio&#39;, OutputFormat.PERCENT)
    def sortino_ratio(self):
        &#34;&#34;&#34;Sortino ratio of a strategy.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.sortino_ratio_nb(
            self.returns.vbt.to_2d_array(),
            reshape_fns.to_1d(self.downside_risk, raw=True),
            self.ann_factor,
            required_return=self.required_return))

    @metric_property(&#39;Information ratio&#39;, OutputFormat.PERCENT)
    def information_ratio(self):
        &#34;&#34;&#34;Information ratio of a strategy.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrap_reduced_array(nb.information_ratio_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array()))

    @metric_property(&#39;Beta&#39;, OutputFormat.PERCENT)
    def beta(self):
        &#34;&#34;&#34;Beta.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrap_reduced_array(nb.beta_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            risk_free=self.risk_free))

    @metric_property(&#39;Annualized alpha&#39;, OutputFormat.PERCENT)
    def alpha(self):
        &#34;&#34;&#34;Annualized alpha.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrap_reduced_array(nb.alpha_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            reshape_fns.to_1d(self.beta, raw=True),
            self.ann_factor,
            risk_free=self.risk_free))

    @metric_property(&#39;Tail ratio&#39;, OutputFormat.PERCENT)
    def tail_ratio(self):
        &#34;&#34;&#34;Ratio between the right (95%) and left tail (5%).&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.tail_ratio_nb(self.returns.vbt.to_2d_array()))

    @metric_property(&#39;Value at risk&#39;, OutputFormat.CURRENCY)
    def value_at_risk(self):
        &#34;&#34;&#34;Value at risk (VaR) of a returns stream.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.value_at_risk_nb(
            self.returns.vbt.to_2d_array(),
            cutoff=self.cutoff))

    @metric_property(&#39;Conditional value at risk&#39;, OutputFormat.CURRENCY)
    def conditional_value_at_risk(self):
        &#34;&#34;&#34;Conditional value at risk (CVaR) of a returns stream.&#34;&#34;&#34;
        return self.wrap_reduced_array(nb.conditional_value_at_risk_nb(
            self.returns.vbt.to_2d_array(),
            cutoff=self.cutoff))

    @metric_property(&#39;Capture ratio&#39;, OutputFormat.PERCENT)
    def capture(self):
        &#34;&#34;&#34;Capture ratio.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrap_reduced_array(nb.capture_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Capture ratio (positive)&#39;, OutputFormat.PERCENT)
    def up_capture(self):
        &#34;&#34;&#34;Capture ratio for periods when the benchmark return is positive.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrap_reduced_array(nb.up_capture_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Capture ratio (negative)&#39;, OutputFormat.PERCENT)
    def down_capture(self):
        &#34;&#34;&#34;Capture ratio for periods when the benchmark return is negative.

        !!! note
            `factor_returns` must be set.&#34;&#34;&#34;
        checks.assert_not_none(self.factor_returns)

        return self.wrap_reduced_array(nb.down_capture_nb(
            self.returns.vbt.to_2d_array(),
            self.factor_returns.vbt.to_2d_array(),
            self.ann_factor))

    @metric_property(&#39;Skewness&#39;, OutputFormat.NONE)
    def skew(self):
        &#34;&#34;&#34;Skewness of returns.&#34;&#34;&#34;
        return self.wrap_reduced_array(stats.skew(self.returns.vbt.to_2d_array(), axis=0, nan_policy=&#39;omit&#39;))

    @metric_property(&#39;Kurtosis&#39;, OutputFormat.NONE)
    def kurtosis(self):
        &#34;&#34;&#34;Kurtosis of returns.&#34;&#34;&#34;
        return self.wrap_reduced_array(stats.kurtosis(self.returns.vbt.to_2d_array(), axis=0, nan_policy=&#39;omit&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.common.ArrayWrapper" href="common.html#vectorbt.portfolio.common.ArrayWrapper">ArrayWrapper</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.portfolio.portfolio.Portfolio.from_order_func"><code class="name flex">
<span>def <span class="ident">from_order_func</span></span>(<span>price, order_func_nb, *args, init_capital=None, fees=None, slippage=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from a custom order function.</p>
<p>Starting with initial capital <code>init_capital</code>, at each time step, orders the number
of shares returned by <code>order_func_nb</code>. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Price of the asset.</dd>
<dt><strong><code>order_func_nb</code></strong> :&ensp;<code>function</code></dt>
<dd>
<p>Function that returns the amount of shares to order.</p>
<p>See <code><a title="vectorbt.portfolio.nb.portfolio_nb" href="nb.html#vectorbt.portfolio.nb.portfolio_nb">portfolio_nb()</a></code>.</p>
</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>Arguments passed to <code>order_func_nb</code>.</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The initial capital.</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Trading fees in percentage of the value involved.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of <code>price</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.defaults.portfolio" href="../defaults.html#vectorbt.defaults.portfolio">portfolio</a></code>.</p>
<p>All array-like arguments will be broadcasted together using <code><a title="vectorbt.utils.reshape_fns.broadcast" href="../utils/reshape_fns.html#vectorbt.utils.reshape_fns.broadcast">broadcast()</a></code>
with <code>broadcast_kwargs</code>. At the end, each time series object will have the same metadata.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>order_func_nb</code> must be Numba-compiled.</p>
</div>
<h2 id="example">Example</h2>
<p>Portfolio value of a simple buy-and-hold strategy:</p>
<pre><code class="python-repl">&gt;&gt;&gt; @njit
... def order_func_nb(col, i, run_cash, run_shares):
...     return 10 if i == 0 else 0

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(price, 
...     order_func_nb, init_capital=100, fees=0.0025)

&gt;&gt;&gt; print(portfolio.cash)
2018-01-01    89.975
2018-01-02    89.975
2018-01-03    89.975
2018-01-04    89.975
2018-01-05    89.975
dtype: float64
&gt;&gt;&gt; print(portfolio.shares)
2018-01-01    10.0
2018-01-02    10.0
2018-01-03    10.0
2018-01-04    10.0
2018-01-05    10.0
dtype: float64
&gt;&gt;&gt; print(portfolio.equity)
2018-01-01     99.975
2018-01-02    109.975
2018-01-03    119.975
2018-01-04    109.975
2018-01-05     99.975
dtype: float64
&gt;&gt;&gt; print(portfolio.total_costs)
0.02499999999999858
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_order_func(cls, price, order_func_nb, *args, init_capital=None, fees=None, slippage=None, **kwargs):
    &#34;&#34;&#34;Build portfolio from a custom order function.

    Starting with initial capital `init_capital`, at each time step, orders the number 
    of shares returned by `order_func_nb`. 

    Args:
        price (pandas_like): Price of the asset.
        order_func_nb (function): Function that returns the amount of shares to order.

            See `vectorbt.portfolio.nb.portfolio_nb`.
        *args: Arguments passed to `order_func_nb`.
        init_capital (int or float): The initial capital.
        fees (float or array_like): Trading fees in percentage of the value involved.
        slippage (float or array_like): Slippage in percentage of `price`.
        **kwargs: Keyword arguments passed to the `__init__` method.

    For defaults, see `vectorbt.defaults.portfolio`.

    All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
    with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

    !!! note
        `order_func_nb` must be Numba-compiled.

    Example:
        Portfolio value of a simple buy-and-hold strategy:
        ```python-repl
        &gt;&gt;&gt; @njit
        ... def order_func_nb(col, i, run_cash, run_shares):
        ...     return 10 if i == 0 else 0

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(price, 
        ...     order_func_nb, init_capital=100, fees=0.0025)

        &gt;&gt;&gt; print(portfolio.cash)
        2018-01-01    89.975
        2018-01-02    89.975
        2018-01-03    89.975
        2018-01-04    89.975
        2018-01-05    89.975
        dtype: float64
        &gt;&gt;&gt; print(portfolio.shares)
        2018-01-01    10.0
        2018-01-02    10.0
        2018-01-03    10.0
        2018-01-04    10.0
        2018-01-05    10.0
        dtype: float64
        &gt;&gt;&gt; print(portfolio.equity)
        2018-01-01     99.975
        2018-01-02    109.975
        2018-01-03    119.975
        2018-01-04    109.975
        2018-01-05     99.975
        dtype: float64
        &gt;&gt;&gt; print(portfolio.total_costs)
        0.02499999999999858
        ```
    &#34;&#34;&#34;
    # Get defaults
    if init_capital is None:
        init_capital = defaults.portfolio[&#39;init_capital&#39;]
    init_capital = float(init_capital)
    if fees is None:
        fees = defaults.portfolio[&#39;fees&#39;]
    if slippage is None:
        slippage = defaults.portfolio[&#39;slippage&#39;]

    # Perform checks
    checks.assert_type(price, (pd.Series, pd.DataFrame))
    checks.assert_numba_func(order_func_nb)

    # Broadcast inputs
    fees = reshape_fns.broadcast_to(fees, price, to_pd=False, writeable=True)
    slippage = reshape_fns.broadcast_to(slippage, price, to_pd=False, writeable=True)

    # Perform calculation
    cash, shares, fees_paid, slippage_paid = nb.portfolio_nb(
        reshape_fns.to_2d(price, raw=True),
        init_capital,
        reshape_fns.to_2d(fees, raw=True),
        reshape_fns.to_2d(slippage, raw=True),
        order_func_nb,
        *args)

    # Bring to the same meta
    cash = price.vbt.wrap_array(cash)
    shares = price.vbt.wrap_array(shares)
    fees_paid = price.vbt.wrap_array(fees_paid)
    slippage_paid = price.vbt.wrap_array(slippage_paid)

    return cls(price, cash, shares, init_capital, fees_paid, slippage_paid, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.from_orders"><code class="name flex">
<span>def <span class="ident">from_orders</span></span>(<span>price, orders, is_target=False, init_capital=None, fees=None, slippage=None, broadcast_kwargs={}, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from orders.</p>
<p>Starting with initial capital <code>init_capital</code>, at each time step, orders the number
of shares specified in <code>orders</code>. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Price of the asset.</dd>
<dt><strong><code>orders</code></strong> :&ensp;<code>int, float</code> or <code>array_like</code></dt>
<dd>
<p>The amount of shares to order. </p>
<p>If the amount is positive, this is the number of shares to buy.
If the amount is negative, this is the number of shares to sell.
To buy/sell everything, set the amount to <code>numpy.inf</code>.</p>
</dd>
<dt><strong><code>is_target</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, will order the difference between current and target amount.</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The initial capital.</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Trading fees in percentage of the value involved.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of <code>price</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.defaults.portfolio" href="../defaults.html#vectorbt.defaults.portfolio">portfolio</a></code>.</p>
<p>All array-like arguments will be broadcasted together using <code><a title="vectorbt.utils.reshape_fns.broadcast" href="../utils/reshape_fns.html#vectorbt.utils.reshape_fns.broadcast">broadcast()</a></code>
with <code>broadcast_kwargs</code>. At the end, each time series object will have the same metadata.</p>
<h2 id="example">Example</h2>
<p>Portfolio value of various order sequences:</p>
<pre><code class="python-repl">&gt;&gt;&gt; orders = pd.DataFrame({
...     'a': [np.inf, 0, 0, 0, 0],
...     'b': [1, 1, 1, 1, -np.inf],
...     'c': [np.inf, -np.inf, np.inf, -np.inf, np.inf]
... }, index=index)

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
...     init_capital=100, fees=0.0025)

&gt;&gt;&gt; print(portfolio.cash)
              a        b           c
2018-01-01  0.0  98.9975    0.000000
2018-01-02  0.0  96.9925  199.002494
2018-01-03  0.0  93.9850    0.000000
2018-01-04  0.0  91.9800  132.006642
2018-01-05  0.0  95.9700    0.000000
&gt;&gt;&gt; print(portfolio.shares)
                    a    b           c
2018-01-01  99.750623  1.0   99.750623
2018-01-02  99.750623  2.0    0.000000
2018-01-03  99.750623  3.0   66.168743
2018-01-04  99.750623  4.0    0.000000
2018-01-05  99.750623  0.0  131.677448
&gt;&gt;&gt; print(portfolio.equity)
                     a         b           c
2018-01-01   99.750623   99.9975   99.750623
2018-01-02  199.501247  100.9925  199.002494
2018-01-03  299.251870  102.9850  198.506228
2018-01-04  199.501247   99.9800  132.006642
2018-01-05   99.750623   95.9700  131.677448
&gt;&gt;&gt; print(portfolio.total_costs)
a    0.249377
b    0.030000
c    1.904433
dtype: float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_orders(cls, price, orders, is_target=False, init_capital=None, fees=None,
                slippage=None, broadcast_kwargs={}, **kwargs):
    &#34;&#34;&#34;Build portfolio from orders.

    Starting with initial capital `init_capital`, at each time step, orders the number 
    of shares specified in `orders`. 

    Args:
        price (pandas_like): Price of the asset.
        orders (int, float or array_like): The amount of shares to order. 

            If the amount is positive, this is the number of shares to buy. 
            If the amount is negative, this is the number of shares to sell.
            To buy/sell everything, set the amount to `numpy.inf`.
        is_target (bool): If `True`, will order the difference between current and target amount.
        init_capital (int or float): The initial capital.
        fees (float or array_like): Trading fees in percentage of the value involved.
        slippage (float or array_like): Slippage in percentage of `price`.
        **kwargs: Keyword arguments passed to the `__init__` method.

    For defaults, see `vectorbt.defaults.portfolio`.

    All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
    with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

    Example:
        Portfolio value of various order sequences:
        ```python-repl
        &gt;&gt;&gt; orders = pd.DataFrame({
        ...     &#39;a&#39;: [np.inf, 0, 0, 0, 0],
        ...     &#39;b&#39;: [1, 1, 1, 1, -np.inf],
        ...     &#39;c&#39;: [np.inf, -np.inf, np.inf, -np.inf, np.inf]
        ... }, index=index)

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
        ...     init_capital=100, fees=0.0025)

        &gt;&gt;&gt; print(portfolio.cash)
                      a        b           c
        2018-01-01  0.0  98.9975    0.000000
        2018-01-02  0.0  96.9925  199.002494
        2018-01-03  0.0  93.9850    0.000000
        2018-01-04  0.0  91.9800  132.006642
        2018-01-05  0.0  95.9700    0.000000
        &gt;&gt;&gt; print(portfolio.shares)
                            a    b           c
        2018-01-01  99.750623  1.0   99.750623
        2018-01-02  99.750623  2.0    0.000000
        2018-01-03  99.750623  3.0   66.168743
        2018-01-04  99.750623  4.0    0.000000
        2018-01-05  99.750623  0.0  131.677448
        &gt;&gt;&gt; print(portfolio.equity)
                             a         b           c
        2018-01-01   99.750623   99.9975   99.750623
        2018-01-02  199.501247  100.9925  199.002494
        2018-01-03  299.251870  102.9850  198.506228
        2018-01-04  199.501247   99.9800  132.006642
        2018-01-05   99.750623   95.9700  131.677448
        &gt;&gt;&gt; print(portfolio.total_costs)
        a    0.249377
        b    0.030000
        c    1.904433
        dtype: float64
        ```
    &#34;&#34;&#34;
    # Get defaults
    if init_capital is None:
        init_capital = defaults.portfolio[&#39;init_capital&#39;]
    init_capital = float(init_capital)
    if fees is None:
        fees = defaults.portfolio[&#39;fees&#39;]
    if slippage is None:
        slippage = defaults.portfolio[&#39;slippage&#39;]

    # Perform checks
    checks.assert_type(price, (pd.Series, pd.DataFrame))
    checks.assert_type(orders, (pd.Series, pd.DataFrame))

    # Broadcast inputs
    price, orders = reshape_fns.broadcast(price, orders, **broadcast_kwargs, writeable=True)
    fees = reshape_fns.broadcast_to(fees, price, to_pd=False, writeable=True)
    slippage = reshape_fns.broadcast_to(slippage, price, to_pd=False, writeable=True)

    # Perform calculation
    cash, shares, fees_paid, slippage_paid = nb.portfolio_nb(
        reshape_fns.to_2d(price, raw=True),
        init_capital,
        reshape_fns.to_2d(fees, raw=True),
        reshape_fns.to_2d(slippage, raw=True),
        nb.amount_order_func_nb,
        reshape_fns.to_2d(orders, raw=True),
        is_target)

    # Bring to the same meta
    cash = price.vbt.wrap_array(cash)
    shares = price.vbt.wrap_array(shares)
    fees_paid = price.vbt.wrap_array(fees_paid)
    slippage_paid = price.vbt.wrap_array(slippage_paid)

    return cls(price, cash, shares, init_capital, fees_paid, slippage_paid, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.from_signals"><code class="name flex">
<span>def <span class="ident">from_signals</span></span>(<span>price, entries, exits, amount=inf, init_capital=None, fees=None, slippage=None, broadcast_kwargs={}, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from entry and exit signals.</p>
<p>Starting with initial capital <code>init_capital</code>, for each <code>True</code> in <code>entries</code>/<code>exits</code>,
orders the number of shares specified in <code>amount</code>. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Price of the asset.</dd>
<dt><strong><code>entries</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Boolean array of entry signals.</dd>
<dt><strong><code>exits</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Boolean array of exit signals.</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>int, float</code> or <code>array_like</code></dt>
<dd>
<p>The amount of shares to order. </p>
<p>To buy/sell everything, set the amount to <code>numpy.inf</code>.</p>
</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The initial capital.</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Trading fees in percentage of the value involved.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of <code>price</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.defaults.portfolio" href="../defaults.html#vectorbt.defaults.portfolio">portfolio</a></code>.</p>
<p>All array-like arguments will be broadcasted together using <code><a title="vectorbt.utils.reshape_fns.broadcast" href="../utils/reshape_fns.html#vectorbt.utils.reshape_fns.broadcast">broadcast()</a></code>
with <code>broadcast_kwargs</code>. At the end, each time series object will have the same metadata.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no mechanism implemented to prevent order accumulation, meaning multiple entry/exit
signals one after another may increase/decrease your position in the market. That's why we will
later calculate P/L of positions instead of trades.</p>
<p>To select at most one exit signal, use <code><a title="vectorbt.signals.accessors.Signals_Accessor.first" href="../signals/accessors.html#vectorbt.signals.accessors.Signals_Accessor.first">Signals_Accessor.first()</a></code>. </p>
</div>
<h2 id="example">Example</h2>
<p>Portfolio value of various signal sequences:</p>
<pre><code class="python-repl">&gt;&gt;&gt; entries = pd.DataFrame({
...     'a': [True, False, False, False, False],
...     'b': [True, True, True, True, True],
...     'c': [True, False, True, False, True]
... }, index=index)
&gt;&gt;&gt; exits = pd.DataFrame({
...     'a': [False, False, False, False, False],
...     'b': [False, False, False, False, False],
...     'c': [False, True, False, True, False]
... }, index=index)

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(price, entries, 
...     exits, amount=10, init_capital=100, fees=0.0025)

&gt;&gt;&gt; print(portfolio.cash)
                 a       b        c
2018-01-01  89.975  89.975   89.975
2018-01-02  89.975  69.925  109.925
2018-01-03  89.975  39.850   79.850
2018-01-04  89.975  19.800   99.800
2018-01-05  89.975   9.775   89.775
&gt;&gt;&gt; print(portfolio.shares)
               a     b     c
2018-01-01  10.0  10.0  10.0
2018-01-02  10.0  20.0   0.0
2018-01-03  10.0  30.0  10.0
2018-01-04  10.0  40.0   0.0
2018-01-05  10.0  50.0  10.0
&gt;&gt;&gt; print(portfolio.equity)
                  a        b        c
2018-01-01   99.975   99.975   99.975
2018-01-02  109.975  109.925  109.925
2018-01-03  119.975  129.850  109.850
2018-01-04  109.975   99.800   99.800
2018-01-05   99.975   59.775   99.775
&gt;&gt;&gt; print(portfolio.total_costs)
a    0.025
b    0.225
c    0.225
dtype: float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_signals(cls, price, entries, exits, amount=np.inf, init_capital=None,
                 fees=None, slippage=None, broadcast_kwargs={}, **kwargs):
    &#34;&#34;&#34;Build portfolio from entry and exit signals.

    Starting with initial capital `init_capital`, for each `True` in `entries`/`exits`, 
    orders the number of shares specified in `amount`. 

    Args:
        price (pandas_like): Price of the asset.
        entries (pandas_like): Boolean array of entry signals.
        exits (pandas_like): Boolean array of exit signals.
        amount (int, float or array_like): The amount of shares to order. 

            To buy/sell everything, set the amount to `numpy.inf`.
        init_capital (int or float): The initial capital.
        fees (float or array_like): Trading fees in percentage of the value involved.
        slippage (float or array_like): Slippage in percentage of `price`.
        **kwargs: Keyword arguments passed to the `__init__` method.

    For defaults, see `vectorbt.defaults.portfolio`.

    All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
    with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

    !!! note
        There is no mechanism implemented to prevent order accumulation, meaning multiple entry/exit 
        signals one after another may increase/decrease your position in the market. That&#39;s why we will
        later calculate P/L of positions instead of trades.

        To select at most one exit signal, use `vectorbt.signals.accessors.Signals_Accessor.first`. 

    Example:
        Portfolio value of various signal sequences:
        ```python-repl
        &gt;&gt;&gt; entries = pd.DataFrame({
        ...     &#39;a&#39;: [True, False, False, False, False],
        ...     &#39;b&#39;: [True, True, True, True, True],
        ...     &#39;c&#39;: [True, False, True, False, True]
        ... }, index=index)
        &gt;&gt;&gt; exits = pd.DataFrame({
        ...     &#39;a&#39;: [False, False, False, False, False],
        ...     &#39;b&#39;: [False, False, False, False, False],
        ...     &#39;c&#39;: [False, True, False, True, False]
        ... }, index=index)

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(price, entries, 
        ...     exits, amount=10, init_capital=100, fees=0.0025)

        &gt;&gt;&gt; print(portfolio.cash)
                         a       b        c
        2018-01-01  89.975  89.975   89.975
        2018-01-02  89.975  69.925  109.925
        2018-01-03  89.975  39.850   79.850
        2018-01-04  89.975  19.800   99.800
        2018-01-05  89.975   9.775   89.775
        &gt;&gt;&gt; print(portfolio.shares)
                       a     b     c
        2018-01-01  10.0  10.0  10.0
        2018-01-02  10.0  20.0   0.0
        2018-01-03  10.0  30.0  10.0
        2018-01-04  10.0  40.0   0.0
        2018-01-05  10.0  50.0  10.0
        &gt;&gt;&gt; print(portfolio.equity)
                          a        b        c
        2018-01-01   99.975   99.975   99.975
        2018-01-02  109.975  109.925  109.925
        2018-01-03  119.975  129.850  109.850
        2018-01-04  109.975   99.800   99.800
        2018-01-05   99.975   59.775   99.775
        &gt;&gt;&gt; print(portfolio.total_costs)
        a    0.025
        b    0.225
        c    0.225
        dtype: float64
        ```
    &#34;&#34;&#34;
    # Get defaults
    if init_capital is None:
        init_capital = defaults.portfolio[&#39;init_capital&#39;]
    init_capital = float(init_capital)
    if fees is None:
        fees = defaults.portfolio[&#39;fees&#39;]
    if slippage is None:
        slippage = defaults.portfolio[&#39;slippage&#39;]

    # Perform checks
    checks.assert_type(price, (pd.Series, pd.DataFrame))
    checks.assert_type(entries, (pd.Series, pd.DataFrame))
    checks.assert_type(exits, (pd.Series, pd.DataFrame))
    entries.vbt.signals.validate()
    exits.vbt.signals.validate()

    # Broadcast inputs
    price, entries, exits, amount, fees, slippage = reshape_fns.broadcast(
        price, entries, exits, amount, fees, slippage, **broadcast_kwargs, writeable=True)

    # Perform calculation
    cash, shares, fees_paid, slippage_paid = nb.portfolio_nb(
        reshape_fns.to_2d(price, raw=True),
        init_capital,
        reshape_fns.to_2d(fees, raw=True),
        reshape_fns.to_2d(slippage, raw=True),
        nb.signals_order_func_nb,
        reshape_fns.to_2d(entries, raw=True),
        reshape_fns.to_2d(exits, raw=True),
        reshape_fns.to_2d(amount, raw=True))

    # Bring to the same meta
    cash = price.vbt.wrap_array(cash)
    shares = price.vbt.wrap_array(shares)
    fees_paid = price.vbt.wrap_array(fees_paid)
    slippage_paid = price.vbt.wrap_array(slippage_paid)

    return cls(price, cash, shares, init_capital, fees_paid, slippage_paid, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.portfolio.Portfolio.alpha"><code class="name">var <span class="ident">alpha</span></code></dt>
<dd>
<div class="desc"><p>Annualized alpha.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>factor_returns</code> must be set.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.ann_factor"><code class="name">var <span class="ident">ann_factor</span></code></dt>
<dd>
<div class="desc"><p>Annualization factor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ann_factor(self):
    &#34;&#34;&#34;Annualization factor.&#34;&#34;&#34;
    return self._ann_factor</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.annual_returns"><code class="name">var <span class="ident">annual_returns</span></code></dt>
<dd>
<div class="desc"><p>Annual returns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.annualized_return"><code class="name">var <span class="ident">annualized_return</span></code></dt>
<dd>
<div class="desc"><p>Mean annual growth rate of returns. </p>
<p>This is equivilent to the compound annual growth rate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.annualized_volatility"><code class="name">var <span class="ident">annualized_volatility</span></code></dt>
<dd>
<div class="desc"><p>Annualized volatility of a strategy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.beta"><code class="name">var <span class="ident">beta</span></code></dt>
<dd>
<div class="desc"><p>Beta.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>factor_returns</code> must be set.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.calmar_ratio"><code class="name">var <span class="ident">calmar_ratio</span></code></dt>
<dd>
<div class="desc"><p>Calmar ratio, or drawdown ratio, of a strategy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.capture"><code class="name">var <span class="ident">capture</span></code></dt>
<dd>
<div class="desc"><p>Capture ratio.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>factor_returns</code> must be set.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.cash"><code class="name">var <span class="ident">cash</span></code></dt>
<dd>
<div class="desc"><p>Cash held at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.conditional_value_at_risk"><code class="name">var <span class="ident">conditional_value_at_risk</span></code></dt>
<dd>
<div class="desc"><p>Conditional value at risk (CVaR) of a returns stream.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.cum_returns"><code class="name">var <span class="ident">cum_returns</span></code></dt>
<dd>
<div class="desc"><p>Cumulative returns at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.cutoff"><code class="name">var <span class="ident">cutoff</span></code></dt>
<dd>
<div class="desc"><p>Decimal representing the percentage cutoff for the bottom percentile of returns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cutoff(self):
    &#34;&#34;&#34;Decimal representing the percentage cutoff for the bottom percentile of returns.&#34;&#34;&#34;
    return self._cutoff</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.daily_returns"><code class="name">var <span class="ident">daily_returns</span></code></dt>
<dd>
<div class="desc"><p>Daily returns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.data_freq"><code class="name">var <span class="ident">data_freq</span></code></dt>
<dd>
<div class="desc"><p>Data frequency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_freq(self):
    &#34;&#34;&#34;Data frequency.&#34;&#34;&#34;
    return self._data_freq</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.down_capture"><code class="name">var <span class="ident">down_capture</span></code></dt>
<dd>
<div class="desc"><p>Capture ratio for periods when the benchmark return is negative.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>factor_returns</code> must be set.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.downside_risk"><code class="name">var <span class="ident">downside_risk</span></code></dt>
<dd>
<div class="desc"><p>Downside deviation below a threshold.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.drawdown"><code class="name">var <span class="ident">drawdown</span></code></dt>
<dd>
<div class="desc"><p>Relative decline from a peak at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.equity"><code class="name">var <span class="ident">equity</span></code></dt>
<dd>
<div class="desc"><p>Portfolio value at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.factor_returns"><code class="name">var <span class="ident">factor_returns</span></code></dt>
<dd>
<div class="desc"><p>Benchmark return to compare returns against.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def factor_returns(self):
    &#34;&#34;&#34;Benchmark return to compare returns against.&#34;&#34;&#34;
    return self._factor_returns</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.fees_paid"><code class="name">var <span class="ident">fees_paid</span></code></dt>
<dd>
<div class="desc"><p>Paid fees at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <code>pandas.Series.iloc</code>/<code>pandas.DataFrame.iloc</code>
operation to each Series/DataFrame and returns a new instance of <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.information_ratio"><code class="name">var <span class="ident">information_ratio</span></code></dt>
<dd>
<div class="desc"><p>Information ratio of a strategy.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>factor_returns</code> must be set.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.init_capital"><code class="name">var <span class="ident">init_capital</span></code></dt>
<dd>
<div class="desc"><p>Initial capital.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def init_capital(self):
    &#34;&#34;&#34;Initial capital.&#34;&#34;&#34;
    return self._init_capital</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.kurtosis"><code class="name">var <span class="ident">kurtosis</span></code></dt>
<dd>
<div class="desc"><p>Kurtosis of returns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <code>pandas.Series.loc</code>/<code>pandas.DataFrame.loc</code>
operation to each Series/DataFrame and returns a new instance of <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.max_drawdown"><code class="name">var <span class="ident">max_drawdown</span></code></dt>
<dd>
<div class="desc"><p>Total maximum drawdown (MDD).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.omega_ratio"><code class="name">var <span class="ident">omega_ratio</span></code></dt>
<dd>
<div class="desc"><p>Omega ratio of a strategy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.positions"><code class="name">var <span class="ident">positions</span></code></dt>
<dd>
<div class="desc"><p>Positions of the portfolio.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.price"><code class="name">var <span class="ident">price</span></code></dt>
<dd>
<div class="desc"><p>Price per share at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.required_return"><code class="name">var <span class="ident">required_return</span></code></dt>
<dd>
<div class="desc"><p>Minimum acceptance return of the investor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def required_return(self):
    &#34;&#34;&#34;Minimum acceptance return of the investor.&#34;&#34;&#34;
    return self._required_return</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.returns"><code class="name">var <span class="ident">returns</span></code></dt>
<dd>
<div class="desc"><p>Portfolio returns at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.risk_free"><code class="name">var <span class="ident">risk_free</span></code></dt>
<dd>
<div class="desc"><p>Constant risk-free return throughout the period.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def risk_free(self):
    &#34;&#34;&#34;Constant risk-free return throughout the period.&#34;&#34;&#34;
    return self._risk_free</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.shares"><code class="name">var <span class="ident">shares</span></code></dt>
<dd>
<div class="desc"><p>Shares held at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.sharpe_ratio"><code class="name">var <span class="ident">sharpe_ratio</span></code></dt>
<dd>
<div class="desc"><p>Sharpe ratio of a strategy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.skew"><code class="name">var <span class="ident">skew</span></code></dt>
<dd>
<div class="desc"><p>Skewness of returns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.slippage_paid"><code class="name">var <span class="ident">slippage_paid</span></code></dt>
<dd>
<div class="desc"><p>Paid slippage at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.sortino_ratio"><code class="name">var <span class="ident">sortino_ratio</span></code></dt>
<dd>
<div class="desc"><p>Sortino ratio of a strategy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.tail_ratio"><code class="name">var <span class="ident">tail_ratio</span></code></dt>
<dd>
<div class="desc"><p>Ratio between the right (95%) and left tail (5%).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.total_costs"><code class="name">var <span class="ident">total_costs</span></code></dt>
<dd>
<div class="desc"><p>Total costs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.total_fees_paid"><code class="name">var <span class="ident">total_fees_paid</span></code></dt>
<dd>
<div class="desc"><p>Total paid fees.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.total_profit"><code class="name">var <span class="ident">total_profit</span></code></dt>
<dd>
<div class="desc"><p>Total profit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.total_return"><code class="name">var <span class="ident">total_return</span></code></dt>
<dd>
<div class="desc"><p>Total return.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.total_slippage_paid"><code class="name">var <span class="ident">total_slippage_paid</span></code></dt>
<dd>
<div class="desc"><p>Total paid slippage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.trade_count"><code class="name">var <span class="ident">trade_count</span></code></dt>
<dd>
<div class="desc"><p>Number of trades.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.trades"><code class="name">var <span class="ident">trades</span></code></dt>
<dd>
<div class="desc"><p>Amount of shares ordered at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.up_capture"><code class="name">var <span class="ident">up_capture</span></code></dt>
<dd>
<div class="desc"><p>Capture ratio for periods when the benchmark return is positive.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>factor_returns</code> must be set.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.value_at_risk"><code class="name">var <span class="ident">value_at_risk</span></code></dt>
<dd>
<div class="desc"><p>Value at risk (VaR) of a returns stream.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.year_freq"><code class="name">var <span class="ident">year_freq</span></code></dt>
<dd>
<div class="desc"><p>Year frequency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def year_freq(self):
    &#34;&#34;&#34;Year frequency.&#34;&#34;&#34;
    return self._year_freq</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.portfolio.portfolio.Portfolio.plot_trades"><code class="name flex">
<span>def <span class="ident">plot_trades</span></span>(<span>self, buy_trace_kwargs={}, sell_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot trades as markers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>buy_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for "Buy" markers.</dd>
<dt><strong><code>sell_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for "Sell" markers.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="py">vbt.Portfolio.from_orders(price, price.diff(), init_capital=100).plot_trades()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/portfolio_plot_trades.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_trades(self,
                buy_trace_kwargs={},
                sell_trace_kwargs={},
                fig=None,
                **layout_kwargs):
    &#34;&#34;&#34;Plot trades as markers.

    Args:
        buy_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Buy&#34; markers.
        sell_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Sell&#34; markers.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Example:
        ```py
        vbt.Portfolio.from_orders(price, price.diff(), init_capital=100).plot_trades()
        ```

        ![](/vectorbt/docs/img/portfolio_plot_trades.png)&#34;&#34;&#34;
    checks.assert_type(self.price, pd.Series)
    checks.assert_type(self.trades, pd.Series)
    sell_mask = self.trades &lt; 0
    buy_mask = self.trades &gt; 0

    # Plot time series
    fig = self.price.vbt.timeseries.plot(fig=fig, **layout_kwargs)
    # Plot markers
    buy_trace_kwargs = common.merge_kwargs(dict(
        customdata=self.trades[buy_mask],
        hovertemplate=&#39;(%{x}, %{y})&lt;br&gt;%{customdata:.6g}&#39;,
        marker=dict(
            symbol=&#39;triangle-up&#39;,
            color=&#39;limegreen&#39;
        )
    ), buy_trace_kwargs)
    buy_mask.vbt.signals.plot_markers(
        self.price, name=&#39;Buy&#39;, trace_kwargs=buy_trace_kwargs, fig=fig, **layout_kwargs)
    sell_trace_kwargs = common.merge_kwargs(dict(
        customdata=self.trades[sell_mask],
        hovertemplate=&#39;(%{x}, %{y})&lt;br&gt;%{customdata:.6g}&#39;,
        marker=dict(
            symbol=&#39;triangle-down&#39;,
            color=&#39;orangered&#39;
        )
    ), sell_trace_kwargs)
    sell_mask.vbt.signals.plot_markers(
        self.price, name=&#39;Sell&#39;, trace_kwargs=sell_trace_kwargs, fig=fig, **layout_kwargs)
    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <code>pandas.Series.xs</code>/<code>pandas.DataFrame.xs</code>
operation to each Series/DataFrame and returns a new instance of <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.portfolio.common.ArrayWrapper" href="common.html#vectorbt.portfolio.common.ArrayWrapper">ArrayWrapper</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.portfolio.common.ArrayWrapper.wrap_array" href="common.html#vectorbt.portfolio.common.ArrayWrapper.wrap_array">wrap_array</a></code></li>
<li><code><a title="vectorbt.portfolio.common.ArrayWrapper.wrap_reduced_array" href="common.html#vectorbt.portfolio.common.ArrayWrapper.wrap_reduced_array">wrap_reduced_array</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#properties">Properties</a><ul>
<li><a href="#caching">Caching</a></li>
<li><a href="#property-hierarchy">Property hierarchy</a></li>
</ul>
</li>
<li><a href="#indexing">Indexing</a></li>
<li><a href="#addition">Addition</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.portfolio" href="index.html">vectorbt.portfolio</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.alpha" href="#vectorbt.portfolio.portfolio.Portfolio.alpha">alpha</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.ann_factor" href="#vectorbt.portfolio.portfolio.Portfolio.ann_factor">ann_factor</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.annual_returns" href="#vectorbt.portfolio.portfolio.Portfolio.annual_returns">annual_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.annualized_return" href="#vectorbt.portfolio.portfolio.Portfolio.annualized_return">annualized_return</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.annualized_volatility" href="#vectorbt.portfolio.portfolio.Portfolio.annualized_volatility">annualized_volatility</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.beta" href="#vectorbt.portfolio.portfolio.Portfolio.beta">beta</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.calmar_ratio" href="#vectorbt.portfolio.portfolio.Portfolio.calmar_ratio">calmar_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.capture" href="#vectorbt.portfolio.portfolio.Portfolio.capture">capture</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.cash" href="#vectorbt.portfolio.portfolio.Portfolio.cash">cash</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.conditional_value_at_risk" href="#vectorbt.portfolio.portfolio.Portfolio.conditional_value_at_risk">conditional_value_at_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.cum_returns" href="#vectorbt.portfolio.portfolio.Portfolio.cum_returns">cum_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.cutoff" href="#vectorbt.portfolio.portfolio.Portfolio.cutoff">cutoff</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.daily_returns" href="#vectorbt.portfolio.portfolio.Portfolio.daily_returns">daily_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.data_freq" href="#vectorbt.portfolio.portfolio.Portfolio.data_freq">data_freq</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.down_capture" href="#vectorbt.portfolio.portfolio.Portfolio.down_capture">down_capture</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.downside_risk" href="#vectorbt.portfolio.portfolio.Portfolio.downside_risk">downside_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.drawdown" href="#vectorbt.portfolio.portfolio.Portfolio.drawdown">drawdown</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.equity" href="#vectorbt.portfolio.portfolio.Portfolio.equity">equity</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.factor_returns" href="#vectorbt.portfolio.portfolio.Portfolio.factor_returns">factor_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.fees_paid" href="#vectorbt.portfolio.portfolio.Portfolio.fees_paid">fees_paid</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.from_order_func" href="#vectorbt.portfolio.portfolio.Portfolio.from_order_func">from_order_func</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.from_orders" href="#vectorbt.portfolio.portfolio.Portfolio.from_orders">from_orders</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.from_signals" href="#vectorbt.portfolio.portfolio.Portfolio.from_signals">from_signals</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.iloc" href="#vectorbt.portfolio.portfolio.Portfolio.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.information_ratio" href="#vectorbt.portfolio.portfolio.Portfolio.information_ratio">information_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.init_capital" href="#vectorbt.portfolio.portfolio.Portfolio.init_capital">init_capital</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.kurtosis" href="#vectorbt.portfolio.portfolio.Portfolio.kurtosis">kurtosis</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.loc" href="#vectorbt.portfolio.portfolio.Portfolio.loc">loc</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.max_drawdown" href="#vectorbt.portfolio.portfolio.Portfolio.max_drawdown">max_drawdown</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.omega_ratio" href="#vectorbt.portfolio.portfolio.Portfolio.omega_ratio">omega_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.plot_trades" href="#vectorbt.portfolio.portfolio.Portfolio.plot_trades">plot_trades</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.positions" href="#vectorbt.portfolio.portfolio.Portfolio.positions">positions</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.price" href="#vectorbt.portfolio.portfolio.Portfolio.price">price</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.required_return" href="#vectorbt.portfolio.portfolio.Portfolio.required_return">required_return</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.returns" href="#vectorbt.portfolio.portfolio.Portfolio.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.risk_free" href="#vectorbt.portfolio.portfolio.Portfolio.risk_free">risk_free</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.shares" href="#vectorbt.portfolio.portfolio.Portfolio.shares">shares</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.sharpe_ratio" href="#vectorbt.portfolio.portfolio.Portfolio.sharpe_ratio">sharpe_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.skew" href="#vectorbt.portfolio.portfolio.Portfolio.skew">skew</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.slippage_paid" href="#vectorbt.portfolio.portfolio.Portfolio.slippage_paid">slippage_paid</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.sortino_ratio" href="#vectorbt.portfolio.portfolio.Portfolio.sortino_ratio">sortino_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.tail_ratio" href="#vectorbt.portfolio.portfolio.Portfolio.tail_ratio">tail_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.total_costs" href="#vectorbt.portfolio.portfolio.Portfolio.total_costs">total_costs</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.total_fees_paid" href="#vectorbt.portfolio.portfolio.Portfolio.total_fees_paid">total_fees_paid</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.total_profit" href="#vectorbt.portfolio.portfolio.Portfolio.total_profit">total_profit</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.total_return" href="#vectorbt.portfolio.portfolio.Portfolio.total_return">total_return</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.total_slippage_paid" href="#vectorbt.portfolio.portfolio.Portfolio.total_slippage_paid">total_slippage_paid</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.trade_count" href="#vectorbt.portfolio.portfolio.Portfolio.trade_count">trade_count</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.trades" href="#vectorbt.portfolio.portfolio.Portfolio.trades">trades</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.up_capture" href="#vectorbt.portfolio.portfolio.Portfolio.up_capture">up_capture</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.value_at_risk" href="#vectorbt.portfolio.portfolio.Portfolio.value_at_risk">value_at_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.xs" href="#vectorbt.portfolio.portfolio.Portfolio.xs">xs</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.year_freq" href="#vectorbt.portfolio.portfolio.Portfolio.year_freq">year_freq</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>