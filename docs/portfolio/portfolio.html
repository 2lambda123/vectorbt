<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.portfolio.portfolio API documentation</title>
<meta name="description" content="Classes for building portfolios and measuring their performance â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.portfolio.portfolio</code></h1>
</header>
<section id="section-intro">
<p>Classes for building portfolios and measuring their performance.</p>
<p>Before running the examples:</p>
<pre><code class="py">import vectorbt as vbt
import numpy as np
import pandas as pd
from numba import njit
from datetime import datetime

index = pd.Index([
    datetime(2018, 1, 1),
    datetime(2018, 1, 2),
    datetime(2018, 1, 3),
    datetime(2018, 1, 4),
    datetime(2018, 1, 5)
])
price = pd.Series([1, 2, 3, 2, 1], index=index, name='a')
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Classes for building portfolios and measuring their performance.
    
Before running the examples:
```py
import vectorbt as vbt
import numpy as np
import pandas as pd
from numba import njit
from datetime import datetime

index = pd.Index([
    datetime(2018, 1, 1),
    datetime(2018, 1, 2),
    datetime(2018, 1, 3),
    datetime(2018, 1, 4),
    datetime(2018, 1, 5)
])
price = pd.Series([1, 2, 3, 2, 1], index=index, name=&#39;a&#39;)
```&#34;&#34;&#34;

import numpy as np
import pandas as pd
import plotly.graph_objects as go
from datetime import timedelta
from inspect import isfunction

from vectorbt import timeseries, accessors, defaults
from vectorbt.utils import indexing, checks, reshape_fns, common
from vectorbt.utils.common import cached_property
from vectorbt.portfolio import nb
from vectorbt.widgets import DefaultFigureWidget


class ArrayWrapper():
    &#34;&#34;&#34;Provides methods for wrapping NumPy arrays.&#34;&#34;&#34;
    def __init__(self, portfolio):
        self.portfolio = portfolio

    def wrap_array(self, a):
        &#34;&#34;&#34;Wrap output array to the time series format of this portfolio.&#34;&#34;&#34;
        return self.portfolio.price.vbt.wrap_array(a)

    def wrap_reduced_array(self, a, **kwargs):
        &#34;&#34;&#34;Wrap output array to the metric format of this portfolio.&#34;&#34;&#34;
        return self.portfolio.price.vbt.timeseries.wrap_reduced_array(a, **kwargs)


class BasePositions(ArrayWrapper):
    &#34;&#34;&#34;Exposes a range of attributes on top of positions in a `Portfolio` instance.
    
    This class doesn&#39;t hold any data, but creates a read-only view over position data.

    Args:
        pos_status (int): Can be any of: 
        
            * `vectorbt.portfolio.nb.OPEN` for open positions only,
            * `vectorbt.portfolio.nb.CLOSED` for closed positions only, or 
            * `None` for positions of any type.
        pos_filters (list or tuple): Can be used to further filter positions.

            Each element must be either: 
            
            * a Numba-compiled function, or 
            * a tuple of a Numba-compiled function and its (unpacked) arguments.

            !!! note
                Each `filter_func_nb` must be Numba-compiled.

    Example:
        Get the average P/L of closed positions with duration over 2 days:
        ```
        &gt;&gt;&gt; from vectorbt.portfolio import CLOSED, BasePositions

        &gt;&gt;&gt; orders = pd.Series([1, -1, 1, 0, -1], index=index)
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, init_capital=100)
        &gt;&gt;&gt; print(portfolio.positions.avg_pnl)
        -0.5

        &gt;&gt;&gt; @njit
        ... def duration_filter_func_nb(col, i, map_result, duration):
        ...     return duration[i, col] &gt;= 2

        &gt;&gt;&gt; positions = BasePositions(
        ...     portfolio, 
        ...     pos_status=CLOSED, 
        ...     pos_filters=[(
        ...         duration_filter_func_nb, 
        ...         portfolio.positions.duration.vbt.to_2d_array()
        ...     )])
        &gt;&gt;&gt; print(positions.avg_pnl)
        -2.0
        ```&#34;&#34;&#34;
    def __init__(self, portfolio, pos_status=None, pos_filters=[]):
        ArrayWrapper.__init__(self, portfolio)

        self.portfolio = portfolio
        self.pos_status = pos_status
        self.pos_filters = pos_filters

    def apply_mapper(self, map_func_nb, *args):
        &#34;&#34;&#34;Apply `map_func_nb` on each position using `vectorbt.portfolio.nb.map_positions_nb` 
        and filter the results with `pos_filters`.
        
        This way, all time series created on top of positions will be automatically filtered.&#34;&#34;&#34;
        checks.assert_numba_func(map_func_nb)

        # Apply map
        result = nb.map_positions_nb(
            self.portfolio.shares.vbt.to_2d_array(),
            self.pos_status,
            map_func_nb,
            *args)
        result = self.wrap_array(result)

        # Apply passed filters
        for pos_filter in self.pos_filters:
            if isfunction(pos_filter):
                filter_func_nb = pos_filter
                args = ()
            else:
                filter_func_nb = pos_filter[0]
                if len(pos_filter) &gt; 1:
                    args = pos_filter[1:]
                else:
                    args = ()
            checks.assert_numba_func(filter_func_nb)
            result = result.vbt.timeseries.filter(filter_func_nb, *args)

        return result

    # ############# Status ############# #

    @cached_property
    def status(self):
        &#34;&#34;&#34;Position status (open/closed) at the end of each position.&#34;&#34;&#34;
        return self.apply_mapper(nb.status_map_func_nb)

    @cached_property
    def count(self):
        &#34;&#34;&#34;Total position count of each column.&#34;&#34;&#34;
        return self.status.vbt.timeseries.count()

    # ############# Duration ############# #

    @cached_property
    def duration(self):
        &#34;&#34;&#34;Position duration at the end of each position.&#34;&#34;&#34;
        return self.apply_mapper(nb.duration_map_func_nb, self.portfolio.price.shape)

    @cached_property
    def min_duration(self):
        &#34;&#34;&#34;Minimum position duration of each column.&#34;&#34;&#34;
        return self.duration.vbt.timeseries.min(time_units=True)

    @cached_property
    def max_duration(self):
        &#34;&#34;&#34;Maximum position duration of each column.&#34;&#34;&#34;
        return self.duration.vbt.timeseries.max(time_units=True)

    @cached_property
    def total_duration(self):
        &#34;&#34;&#34;Total position duration of each column.&#34;&#34;&#34;
        return self.duration.vbt.timeseries.sum(time_units=True)

    @cached_property
    def avg_duration(self):
        &#34;&#34;&#34;Average position duration of each column.&#34;&#34;&#34;
        return self.duration.vbt.timeseries.mean(time_units=True)

    # ############# PnL ############# #

    @cached_property
    def pnl(self):
        &#34;&#34;&#34;Position P/L at the end of each position.&#34;&#34;&#34;
        return self.apply_mapper(
            nb.pnl_map_func_nb,
            self.portfolio.price.vbt.to_2d_array(),
            self.portfolio.cash.vbt.to_2d_array(),
            self.portfolio.shares.vbt.to_2d_array(),
            self.portfolio.init_capital)

    def plot_pnl(self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs):
        &#34;&#34;&#34;Plot position P/L as markers.

        Args:
            profit_trace_kwargs (dict): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for &#34;Profit&#34; markers.
            loss_trace_kwargs (dict): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for &#34;Loss&#34; markers.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            portfolio = vbt.Portfolio.from_orders(price, price.diff(), init_capital=100)
            portfolio.positions.plot_pnl()
            ```

            ![](/vectorbt/docs/img/positions_plot_pnl.png)&#34;&#34;&#34;
        checks.assert_type(self.pnl, pd.Series)

        above_trace_kwargs = {**dict(name=&#39;Profit&#39;), **profit_trace_kwargs}
        below_trace_kwargs = {**dict(name=&#39;Loss&#39;), **loss_trace_kwargs}
        return self.pnl.vbt.timeseries.plot_against(0, above_trace_kwargs=above_trace_kwargs, below_trace_kwargs=below_trace_kwargs)

    @cached_property
    def min_pnl(self):
        &#34;&#34;&#34;Minimum position P/L of each column.&#34;&#34;&#34;
        return self.pnl.vbt.timeseries.min()

    @cached_property
    def max_pnl(self):
        &#34;&#34;&#34;Maximum position P/L of each column.&#34;&#34;&#34;
        return self.pnl.vbt.timeseries.max()

    @cached_property
    def total_pnl(self):
        &#34;&#34;&#34;Total position P/L of each column.&#34;&#34;&#34;
        return self.pnl.vbt.timeseries.sum()

    @cached_property
    def avg_pnl(self):
        &#34;&#34;&#34;Average position P/L of each column.&#34;&#34;&#34;
        return self.pnl.vbt.timeseries.mean()

    # ############# Returns ############# #

    @cached_property
    def returns(self):
        &#34;&#34;&#34;Position returns at the end of each position.&#34;&#34;&#34;
        return self.apply_mapper(
            nb.returns_map_func_nb,
            self.portfolio.price.vbt.to_2d_array(),
            self.portfolio.cash.vbt.to_2d_array(),
            self.portfolio.shares.vbt.to_2d_array(),
            self.portfolio.init_capital)

    def plot_returns(self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs):
        &#34;&#34;&#34;Plot position returns as markers.

        See `BasePositions.plot_pnl`.&#34;&#34;&#34;
        checks.assert_type(self.pnl, pd.Series)

        above_trace_kwargs = {**dict(name=&#39;Profit&#39;), **profit_trace_kwargs}
        below_trace_kwargs = {**dict(name=&#39;Loss&#39;), **loss_trace_kwargs}
        return self.returns.vbt.timeseries.plot_against(0, above_trace_kwargs=above_trace_kwargs, below_trace_kwargs=below_trace_kwargs)

    @cached_property
    def min_return(self):
        &#34;&#34;&#34;Minimum position return of each column.&#34;&#34;&#34;
        return self.returns.vbt.timeseries.min()

    @cached_property
    def max_return(self):
        &#34;&#34;&#34;Maximum position return of each column.&#34;&#34;&#34;
        return self.returns.vbt.timeseries.max()

    @cached_property
    def avg_return(self):
        &#34;&#34;&#34;Average position return of each column.&#34;&#34;&#34;
        return self.returns.vbt.timeseries.mean()


class Positions(BasePositions):
    &#34;&#34;&#34;Extends `BasePositions` by combining various profit/loss metrics.&#34;&#34;&#34;

    @property
    def winning(self):
        &#34;&#34;&#34;Winning positions of class `BasePositions`.&#34;&#34;&#34;
        if not hasattr(self, &#39;_winning&#39;):
            self._winning = BasePositions(
                self.portfolio,
                pos_status=self.pos_status,
                pos_filters=[*self.pos_filters, (nb.winning_filter_func_nb, self.pnl.vbt.to_2d_array())])
        return self._winning

    @property
    def losing(self):
        &#34;&#34;&#34;Losing positions of class `BasePositions`.&#34;&#34;&#34;
        if not hasattr(self, &#39;_losing&#39;):
            self._losing = BasePositions(
                self.portfolio,
                pos_status=self.pos_status,
                pos_filters=[*self.pos_filters, (nb.losing_filter_func_nb, self.pnl.vbt.to_2d_array())])
        return self._losing

    @cached_property
    def win_rate(self):
        &#34;&#34;&#34;How many positions won in each column.&#34;&#34;&#34;
        winning_count = reshape_fns.to_1d(self.winning.count, raw=True)
        count = reshape_fns.to_1d(self.count, raw=True)

        win_rate = winning_count / count
        return self.wrap_reduced_array(win_rate)

    @cached_property
    def loss_rate(self):
        &#34;&#34;&#34;How many positions lost in each column.&#34;&#34;&#34;
        losing_count = reshape_fns.to_1d(self.losing.count, raw=True)
        count = reshape_fns.to_1d(self.count, raw=True)

        loss_rate = losing_count / count
        return self.wrap_reduced_array(loss_rate)

    @cached_property
    def profit_factor(self):
        &#34;&#34;&#34;Profit factor of each column.&#34;&#34;&#34;
        total_win = reshape_fns.to_1d(self.winning.total_pnl, raw=True)
        total_loss = reshape_fns.to_1d(self.losing.total_pnl, raw=True)

        # Otherwise columns with only wins or losses will become NaNs
        has_trades = reshape_fns.to_1d(self.portfolio.has_trades, raw=True)
        total_win[np.isnan(total_win) &amp; has_trades] = 0.
        total_loss[np.isnan(total_loss) &amp; has_trades] = 0.

        profit_factor = total_win / np.abs(total_loss)
        return self.wrap_reduced_array(profit_factor)

    @cached_property
    def expectancy(self):
        &#34;&#34;&#34;Average profitability per trade (APPT) of each column.&#34;&#34;&#34;
        win_rate = reshape_fns.to_1d(self.win_rate, raw=True)
        loss_rate = reshape_fns.to_1d(self.loss_rate, raw=True)
        avg_win = reshape_fns.to_1d(self.winning.avg_pnl, raw=True)
        avg_loss = reshape_fns.to_1d(self.losing.avg_pnl, raw=True)

        # Otherwise columns with only wins or losses will become NaNs
        has_trades = reshape_fns.to_1d(self.portfolio.has_trades, raw=True)
        avg_win[np.isnan(avg_win) &amp; has_trades] = 0.
        avg_loss[np.isnan(avg_loss) &amp; has_trades] = 0.

        expectancy = win_rate * avg_win - loss_rate * np.abs(avg_loss)
        return self.wrap_reduced_array(expectancy)


def portfolio_indexing_func(obj, pd_indexing_func):
    &#34;&#34;&#34;Perform indexing on `Portfolio`. 
    
    See `vectorbt.utils.indexing.add_pd_indexing`.&#34;&#34;&#34;
    return obj.__class__(
        pd_indexing_func(obj.price),
        pd_indexing_func(obj.cash),
        pd_indexing_func(obj.shares),
        obj.init_capital,
        pd_indexing_func(obj.paid_fees),
        pd_indexing_func(obj.paid_slippage)
    )


@indexing.add_pd_indexing(portfolio_indexing_func)
class Portfolio(ArrayWrapper):
    &#34;&#34;&#34;The job of the `Portfolio` class is to create a series of positions allocated 
    against a cash component, produce an equity curve, incorporate basic transaction costs 
    and produce a set of statistics about its performance. In particular it outputs 
    position/profit metrics and drawdown information.

    !!! note
        Portfolio is only built by using class methods with `from_` prefix.
        The `__init__` method is reserved for indexing purposes.

    It produces two types of objects:
    
    * time series such as `Portfolio.equity`, and
    * various metrics such as `Portfolio.total_profit`.
    
    The former are indexed by time, the latter are indexed by columns.

    ## Indexing

    In addition, you can use pandas indexing on the `Portfolio` class itself, which forwards
    indexing operation to each attribute with pandas type (see `portfolio_indexing_func`):
    
    ```python-repl
    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, price.diff(), init_capital=100)

    &gt;&gt;&gt; print(portfolio.equity)
    2018-01-01    100.0
    2018-01-02    100.0
    2018-01-03    101.0
    2018-01-04     99.0
    2018-01-05     98.0
    Name: a, dtype: float64
    &gt;&gt;&gt; print(portfolio.loc[&#39;2018-01-03&#39;:].equity)
    2018-01-03    101.0
    2018-01-04     99.0
    2018-01-05     98.0
    Name: a, dtype: float64
    ```

    Note that for the new `Portfolio` instance, date `&#39;2018-01-03&#39;` will be the new start date.

    ## Addition

    You can also add multiple `Portfolio` instances together to combine portfolios:

    ```python-repl
    &gt;&gt;&gt; portfolio1 = vbt.Portfolio.from_orders(price, price.diff(), init_capital=100)
    &gt;&gt;&gt; portfolio2 = vbt.Portfolio.from_orders(price, price.diff()*2, init_capital=20)
    &gt;&gt;&gt; portfolio = portfolio1 + portfolio2

    &gt;&gt;&gt; print(portfolio.init_capital)
    120.0
    &gt;&gt;&gt; print(portfolio.equity)
    2018-01-01    120.0
    2018-01-02    120.0
    2018-01-03    123.0
    2018-01-04    117.0
    2018-01-05    114.0
    Name: a, dtype: float64
    ```

    The only requirement is that pandas objects of both portfolios must have the same metadata.&#34;&#34;&#34;

    def __init__(self, price, cash, shares, init_capital, paid_fees, paid_slippage):
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_same_meta(price, cash)
        checks.assert_same_meta(price, shares)

        self.price = price
        self.cash = cash
        self.shares = shares
        self.init_capital = init_capital
        self.paid_fees = paid_fees
        self.paid_slippage = paid_slippage

        ArrayWrapper.__init__(self, self)

    # ############# Magic methods ############# #

    def __add__(self, other):
        checks.assert_type(other, self.__class__)
        checks.assert_same(self.price, other.price)

        return self.__class__(
            self.price,
            self.cash + other.cash,
            self.shares + other.shares,
            self.init_capital + other.init_capital,
            self.paid_fees + other.paid_fees,
            self.paid_slippage + other.paid_slippage
        )

    def __radd__(self, other):
        return Portfolio.__add__(self, other)

    # ############# Class methods ############# #

    @classmethod
    def from_signals(cls, price, entries, exits, amount=np.inf, init_capital=None,
                     fees=None, slippage=None, broadcast_kwargs={}):
        &#34;&#34;&#34;Build portfolio from entry and exit signals.

        Starting with initial capital `init_capital`, for each `True` in `entries`/`exits`, 
        orders the number of shares specified in `amount`. 

        Args:
            price (pandas_like): Price of the asset.
            entries (pandas_like): Boolean array of entry signals.
            exits (pandas_like): Boolean array of exit signals.
            amount (int, float or array_like): The amount of shares to order. 

                To buy/sell everything, set the amount to `numpy.inf`.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Trading fees in percentage of the value involved.
            slippage (float or array_like): Slippage in percentage of `price`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
        with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

        !!! note
            There is no mechanism implemented to prevent order accumulation, meaning multiple entry/exit 
            signals one after another may increase/decrease your position in the market. That&#39;s why we will
            later calculate P/L of positions instead of trades.

            To select at most one exit signal, use `vectorbt.signals.accessors.Signals_Accessor.first`. 

        Example:
            Portfolio value of various signal sequences:
            ```python-repl
            &gt;&gt;&gt; entries = pd.DataFrame({
            ...     &#39;a&#39;: [True, False, False, False, False],
            ...     &#39;b&#39;: [True, True, True, True, True],
            ...     &#39;c&#39;: [True, False, True, False, True]
            ... }, index=index)
            &gt;&gt;&gt; exits = pd.DataFrame({
            ...     &#39;a&#39;: [False, False, False, False, False],
            ...     &#39;b&#39;: [False, False, False, False, False],
            ...     &#39;c&#39;: [False, True, False, True, False]
            ... }, index=index)

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(price, entries, 
            ...     exits, amount=10, init_capital=100, fees=0.0025)

            &gt;&gt;&gt; print(portfolio.cash)
                             a       b        c
            2018-01-01  89.975  89.975   89.975
            2018-01-02  89.975  69.925  109.925
            2018-01-03  89.975  39.850   79.850
            2018-01-04  89.975  19.800   99.800
            2018-01-05  89.975   9.775   89.775
            &gt;&gt;&gt; print(portfolio.shares)
                           a     b     c
            2018-01-01  10.0  10.0  10.0
            2018-01-02  10.0  20.0   0.0
            2018-01-03  10.0  30.0  10.0
            2018-01-04  10.0  40.0   0.0
            2018-01-05  10.0  50.0  10.0
            &gt;&gt;&gt; print(portfolio.equity)
                              a        b        c
            2018-01-01   99.975   99.975   99.975
            2018-01-02  109.975  109.925  109.925
            2018-01-03  119.975  129.850  109.850
            2018-01-04  109.975   99.800   99.800
            2018-01-05   99.975   59.775   99.775
            &gt;&gt;&gt; print(portfolio.total_costs)
            a    0.025
            b    0.225
            c    0.225
            dtype: float64
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_type(entries, (pd.Series, pd.DataFrame))
        checks.assert_type(exits, (pd.Series, pd.DataFrame))
        entries.vbt.signals.validate()
        exits.vbt.signals.validate()

        # Broadcast inputs
        price, entries, exits, amount, fees, slippage = reshape_fns.broadcast(
            price, entries, exits, amount, fees, slippage, **broadcast_kwargs, writeable=True)

        # Perform calculation
        cash, shares, paid_fees, paid_slippage = nb.portfolio_nb(
            reshape_fns.to_2d(price, raw=True),
            init_capital,
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            nb.signals_order_func_nb,
            reshape_fns.to_2d(entries, raw=True),
            reshape_fns.to_2d(exits, raw=True),
            reshape_fns.to_2d(amount, raw=True))

        # Bring to the same meta
        cash = price.vbt.wrap_array(cash)
        shares = price.vbt.wrap_array(shares)
        paid_fees = price.vbt.wrap_array(paid_fees)
        paid_slippage = price.vbt.wrap_array(paid_slippage)

        return cls(price, cash, shares, init_capital, paid_fees, paid_slippage)

    @classmethod
    def from_orders(cls, price, orders, is_target=False, init_capital=None, fees=None,
                    slippage=None, broadcast_kwargs={}):
        &#34;&#34;&#34;Build portfolio from orders.

        Starting with initial capital `init_capital`, at each time step, orders the number 
        of shares specified in `orders`. 

        Args:
            price (pandas_like): Price of the asset.
            orders (int, float or array_like): The amount of shares to order. 

                If the amount is positive, this is the number of shares to buy. 
                If the amount is negative, this is the number of shares to sell.
                To buy/sell everything, set the amount to `numpy.inf`.
            is_target (bool): If `True`, will order the difference between current and target amount.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Trading fees in percentage of the value involved.
            slippage (float or array_like): Slippage in percentage of `price`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
        with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

        Example:
            Portfolio value of various order sequences:
            ```python-repl
            &gt;&gt;&gt; orders = pd.DataFrame({
            ...     &#39;a&#39;: [np.inf, 0, 0, 0, 0],
            ...     &#39;b&#39;: [1, 1, 1, 1, -np.inf],
            ...     &#39;c&#39;: [np.inf, -np.inf, np.inf, -np.inf, np.inf]
            ... }, index=index)

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
            ...     init_capital=100, fees=0.0025)

            &gt;&gt;&gt; print(portfolio.cash)
                          a        b           c
            2018-01-01  0.0  98.9975    0.000000
            2018-01-02  0.0  96.9925  199.002494
            2018-01-03  0.0  93.9850    0.000000
            2018-01-04  0.0  91.9800  132.006642
            2018-01-05  0.0  95.9700    0.000000
            &gt;&gt;&gt; print(portfolio.shares)
                                a    b           c
            2018-01-01  99.750623  1.0   99.750623
            2018-01-02  99.750623  2.0    0.000000
            2018-01-03  99.750623  3.0   66.168743
            2018-01-04  99.750623  4.0    0.000000
            2018-01-05  99.750623  0.0  131.677448
            &gt;&gt;&gt; print(portfolio.equity)
                                 a         b           c
            2018-01-01   99.750623   99.9975   99.750623
            2018-01-02  199.501247  100.9925  199.002494
            2018-01-03  299.251870  102.9850  198.506228
            2018-01-04  199.501247   99.9800  132.006642
            2018-01-05   99.750623   95.9700  131.677448
            &gt;&gt;&gt; print(portfolio.total_costs)
            a    0.249377
            b    0.030000
            c    1.904433
            dtype: float64
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_type(orders, (pd.Series, pd.DataFrame))

        # Broadcast inputs
        price, orders = reshape_fns.broadcast(price, orders, **broadcast_kwargs, writeable=True)
        fees = reshape_fns.broadcast_to(fees, price, to_pd=False, writeable=True)
        slippage = reshape_fns.broadcast_to(slippage, price, to_pd=False, writeable=True)

        # Perform calculation
        cash, shares, paid_fees, paid_slippage = nb.portfolio_nb(
            reshape_fns.to_2d(price, raw=True),
            init_capital,
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            nb.amount_order_func_nb,
            reshape_fns.to_2d(orders, raw=True),
            is_target)

        # Bring to the same meta
        cash = price.vbt.wrap_array(cash)
        shares = price.vbt.wrap_array(shares)
        paid_fees = price.vbt.wrap_array(paid_fees)
        paid_slippage = price.vbt.wrap_array(paid_slippage)

        return cls(price, cash, shares, init_capital, paid_fees, paid_slippage)

    @classmethod
    def from_order_func(cls, price, order_func_nb, *args, init_capital=None, fees=None, slippage=None):
        &#34;&#34;&#34;Build portfolio from a custom order function.

        Starting with initial capital `init_capital`, at each time step, orders the number 
        of shares returned by `order_func_nb`. 

        Args:
            price (pandas_like): Price of the asset.
            order_func_nb (function): Function that returns the amount of shares to order.

                See `vectorbt.portfolio.nb.portfolio_nb`.
            *args: Arguments passed to `order_func_nb`.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Trading fees in percentage of the value involved.
            slippage (float or array_like): Slippage in percentage of `price`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
        with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

        !!! note
            `order_func_nb` must be Numba-compiled.

        Example:
            Portfolio value of a simple buy-and-hold strategy:
            ```python-repl
            &gt;&gt;&gt; @njit
            ... def order_func_nb(col, i, run_cash, run_shares):
            ...     return 10 if i == 0 else 0

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(price, 
            ...     order_func_nb, init_capital=100, fees=0.0025)

            &gt;&gt;&gt; print(portfolio.cash)
            2018-01-01    89.975
            2018-01-02    89.975
            2018-01-03    89.975
            2018-01-04    89.975
            2018-01-05    89.975
            dtype: float64
            &gt;&gt;&gt; print(portfolio.shares)
            2018-01-01    10.0
            2018-01-02    10.0
            2018-01-03    10.0
            2018-01-04    10.0
            2018-01-05    10.0
            dtype: float64
            &gt;&gt;&gt; print(portfolio.equity)
            2018-01-01     99.975
            2018-01-02    109.975
            2018-01-03    119.975
            2018-01-04    109.975
            2018-01-05     99.975
            dtype: float64
            &gt;&gt;&gt; print(portfolio.total_costs)
            0.02499999999999858
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_numba_func(order_func_nb)

        # Broadcast inputs
        fees = reshape_fns.broadcast_to(fees, price, to_pd=False, writeable=True)
        slippage = reshape_fns.broadcast_to(slippage, price, to_pd=False, writeable=True)

        # Perform calculation
        cash, shares, paid_fees, paid_slippage = nb.portfolio_nb(
            reshape_fns.to_2d(price, raw=True),
            init_capital,
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            order_func_nb,
            *args)

        # Bring to the same meta
        cash = price.vbt.wrap_array(cash)
        shares = price.vbt.wrap_array(shares)
        paid_fees = price.vbt.wrap_array(paid_fees)
        paid_slippage = price.vbt.wrap_array(paid_slippage)

        return cls(price, cash, shares, init_capital, paid_fees, paid_slippage)

    # ############# Time series ############# #

    @cached_property
    def equity(self):
        &#34;&#34;&#34;Portfolio value at each time step.&#34;&#34;&#34;
        equity = self.cash.vbt.to_2d_array() + self.shares.vbt.to_2d_array() * self.price.vbt.to_2d_array()
        return self.wrap_array(equity)

    @cached_property
    def returns(self):
        &#34;&#34;&#34;Portfolio returns at each time step.&#34;&#34;&#34;
        returns = timeseries.nb.pct_change_nb(self.equity.vbt.to_2d_array())
        return self.wrap_array(returns)

    @cached_property
    def trades(self):
        &#34;&#34;&#34;Amount of shares ordered at each time step.&#34;&#34;&#34;
        shares = self.shares.vbt.to_2d_array()
        trades = timeseries.nb.fillna_nb(timeseries.nb.diff_nb(shares), 0)
        trades[0, :] = shares[0, :]
        return self.wrap_array(trades)

    @cached_property
    def has_trades(self):
        &#34;&#34;&#34;Whether any trades happened in each column.&#34;&#34;&#34;
        has_trades = (self.trades.vbt.to_2d_array() &gt; 0).any(axis=0)
        return self.wrap_reduced_array(has_trades)

    def plot_trades(self,
                    buy_trace_kwargs={},
                    sell_trace_kwargs={},
                    fig=None,
                    **layout_kwargs):
        &#34;&#34;&#34;Plot trades as markers.

        Args:
            buy_trace_kwargs (dict): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for &#34;Buy&#34; markers.
            sell_trace_kwargs (dict): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for &#34;Sell&#34; markers.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            vbt.Portfolio.from_orders(price, price.diff(), init_capital=100).plot_trades()
            ```

            ![](/vectorbt/docs/img/portfolio_plot_trades.png)&#34;&#34;&#34;
        checks.assert_type(self.price, pd.Series)
        checks.assert_type(self.trades, pd.Series)
        sell_mask = self.trades &lt; 0
        buy_mask = self.trades &gt; 0

        # Plot time series
        fig = self.price.vbt.timeseries.plot(fig=fig, **layout_kwargs)
        # Plot markers
        buy_trace_kwargs = common.merge_kwargs(dict(
            customdata=self.trades[buy_mask],
            hovertemplate=&#39;(%{x}, %{y})&lt;br&gt;%{customdata:.6g}&#39;,
            marker=dict(
                symbol=&#39;triangle-up&#39;,
                color=&#39;limegreen&#39;
            )
        ), buy_trace_kwargs)
        buy_mask.vbt.signals.plot_markers(
            self.price, name=&#39;Buy&#39;, trace_kwargs=buy_trace_kwargs, fig=fig, **layout_kwargs)
        sell_trace_kwargs = common.merge_kwargs(dict(
            customdata=self.trades[sell_mask],
            hovertemplate=&#39;(%{x}, %{y})&lt;br&gt;%{customdata:.6g}&#39;,
            marker=dict(
                symbol=&#39;triangle-down&#39;,
                color=&#39;orangered&#39;
            )
        ), sell_trace_kwargs)
        sell_mask.vbt.signals.plot_markers(
            self.price, name=&#39;Sell&#39;, trace_kwargs=sell_trace_kwargs, fig=fig, **layout_kwargs)
        return fig

    @cached_property
    def drawdown(self):
        &#34;&#34;&#34;Relative decline from a peak at each time step.&#34;&#34;&#34;
        equity = self.equity.vbt.to_2d_array()
        drawdown = 1 - equity / timeseries.nb.expanding_max_nb(equity)
        return self.wrap_array(drawdown)

    # ############# Costs ############# #

    @cached_property
    def total_paid_fees(self):
        &#34;&#34;&#34;Total paid fees of each column.&#34;&#34;&#34;
        total_paid_fees = np.sum(self.paid_fees.vbt.to_2d_array(), axis=0)
        return self.wrap_reduced_array(total_paid_fees)

    @cached_property
    def total_paid_slippage(self):
        &#34;&#34;&#34;Total paid slippage of each column.&#34;&#34;&#34;
        total_paid_slippage = np.sum(self.paid_slippage.vbt.to_2d_array(), axis=0)
        return self.wrap_reduced_array(total_paid_slippage)

    @cached_property
    def total_costs(self):
        &#34;&#34;&#34;Total costs of each column.&#34;&#34;&#34;
        total_paid_fees = reshape_fns.to_1d(self.total_paid_fees, raw=True)
        total_paid_slippage = reshape_fns.to_1d(self.total_paid_slippage, raw=True)
        total_costs = total_paid_fees + total_paid_slippage
        return self.wrap_reduced_array(total_costs)

    # ############# Positions ############# #

    @property
    def positions(self):
        &#34;&#34;&#34;Open and closed positions of class `Positions`.&#34;&#34;&#34;
        if not hasattr(self, &#39;_positions&#39;):
            self._positions = Positions(self, pos_status=None)
        return self._positions

    @property
    def open_positions(self):
        &#34;&#34;&#34;Open positions of class `Positions`.&#34;&#34;&#34;
        if not hasattr(self, &#39;_open_positions&#39;):
            self._open_positions = Positions(self, pos_status=nb.OPEN)
        return self._open_positions

    @property
    def closed_positions(self):
        &#34;&#34;&#34;Closed positions of class `Positions`.&#34;&#34;&#34;
        if not hasattr(self, &#39;_closed_positions&#39;):
            self._closed_positions = Positions(self, pos_status=nb.CLOSED)
        return self._closed_positions

    # ############# Performance ############# #

    @cached_property
    def total_profit(self):
        &#34;&#34;&#34;Total profit of each column.&#34;&#34;&#34;
        total_profit = self.equity.vbt.to_2d_array()[-1, :] - self.init_capital
        return self.wrap_reduced_array(total_profit)

    @cached_property
    def total_return(self):
        &#34;&#34;&#34;Total return of each column.&#34;&#34;&#34;
        total_return = reshape_fns.to_1d(self.total_profit, raw=True) / self.init_capital
        return self.wrap_reduced_array(total_return)

    @cached_property
    def daily_return(self):
        &#34;&#34;&#34;Total daily return of each column.&#34;&#34;&#34;
        return self.returns.vbt.timeseries.resample_apply(&#39;D&#39;, nb.total_return_apply_func_nb)

    @cached_property
    def annual_return(self):
        &#34;&#34;&#34;Total annual return of each column.&#34;&#34;&#34;
        return self.returns.vbt.timeseries.resample_apply(&#39;Y&#39;, nb.total_return_apply_func_nb)

    @cached_property
    def max_drawdown(self):
        &#34;&#34;&#34;Total maximum drawdown (MDD) of each column.&#34;&#34;&#34;
        max_drawdown = np.max(self.drawdown.vbt.to_2d_array(), axis=0)
        return self.wrap_reduced_array(max_drawdown)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.portfolio.portfolio.portfolio_indexing_func"><code class="name flex">
<span>def <span class="ident">portfolio_indexing_func</span></span>(<span>obj, pd_indexing_func)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform indexing on <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code>. </p>
<p>See <code><a title="vectorbt.utils.indexing.add_pd_indexing" href="../utils/indexing.html#vectorbt.utils.indexing.add_pd_indexing">add_pd_indexing()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def portfolio_indexing_func(obj, pd_indexing_func):
    &#34;&#34;&#34;Perform indexing on `Portfolio`. 
    
    See `vectorbt.utils.indexing.add_pd_indexing`.&#34;&#34;&#34;
    return obj.__class__(
        pd_indexing_func(obj.price),
        pd_indexing_func(obj.cash),
        pd_indexing_func(obj.shares),
        obj.init_capital,
        pd_indexing_func(obj.paid_fees),
        pd_indexing_func(obj.paid_slippage)
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.portfolio.portfolio.ArrayWrapper"><code class="flex name class">
<span>class <span class="ident">ArrayWrapper</span></span>
<span>(</span><span>portfolio)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides methods for wrapping NumPy arrays.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArrayWrapper():
    &#34;&#34;&#34;Provides methods for wrapping NumPy arrays.&#34;&#34;&#34;
    def __init__(self, portfolio):
        self.portfolio = portfolio

    def wrap_array(self, a):
        &#34;&#34;&#34;Wrap output array to the time series format of this portfolio.&#34;&#34;&#34;
        return self.portfolio.price.vbt.wrap_array(a)

    def wrap_reduced_array(self, a, **kwargs):
        &#34;&#34;&#34;Wrap output array to the metric format of this portfolio.&#34;&#34;&#34;
        return self.portfolio.price.vbt.timeseries.wrap_reduced_array(a, **kwargs)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.portfolio.BasePositions" href="#vectorbt.portfolio.portfolio.BasePositions">BasePositions</a></li>
<li><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.portfolio.portfolio.ArrayWrapper.wrap_array"><code class="name flex">
<span>def <span class="ident">wrap_array</span></span>(<span>self, a)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrap output array to the time series format of this portfolio.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_array(self, a):
    &#34;&#34;&#34;Wrap output array to the time series format of this portfolio.&#34;&#34;&#34;
    return self.portfolio.price.vbt.wrap_array(a)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.ArrayWrapper.wrap_reduced_array"><code class="name flex">
<span>def <span class="ident">wrap_reduced_array</span></span>(<span>self, a, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrap output array to the metric format of this portfolio.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_reduced_array(self, a, **kwargs):
    &#34;&#34;&#34;Wrap output array to the metric format of this portfolio.&#34;&#34;&#34;
    return self.portfolio.price.vbt.timeseries.wrap_reduced_array(a, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions"><code class="flex name class">
<span>class <span class="ident">BasePositions</span></span>
<span>(</span><span>portfolio, pos_status=None, pos_filters=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Exposes a range of attributes on top of positions in a <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code> instance.</p>
<p>This class doesn't hold any data, but creates a read-only view over position data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos_status</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Can be any of: </p>
<ul>
<li><code><a title="vectorbt.portfolio.nb.OPEN" href="nb.html#vectorbt.portfolio.nb.OPEN">OPEN</a></code> for open positions only,</li>
<li><code><a title="vectorbt.portfolio.nb.CLOSED" href="nb.html#vectorbt.portfolio.nb.CLOSED">CLOSED</a></code> for closed positions only, or </li>
<li><code>None</code> for positions of any type.</li>
</ul>
</dd>
<dt><strong><code>pos_filters</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>
<p>Can be used to further filter positions.</p>
<p>Each element must be either: </p>
<ul>
<li>a Numba-compiled function, or </li>
<li>a tuple of a Numba-compiled function and its (unpacked) arguments.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Each <code>filter_func_nb</code> must be Numba-compiled.</p>
</div>
</dd>
</dl>
<h2 id="example">Example</h2>
<p>Get the average P/L of closed positions with duration over 2 days:</p>
<pre><code>&gt;&gt;&gt; from vectorbt.portfolio import CLOSED, BasePositions

&gt;&gt;&gt; orders = pd.Series([1, -1, 1, 0, -1], index=index)
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, init_capital=100)
&gt;&gt;&gt; print(portfolio.positions.avg_pnl)
-0.5

&gt;&gt;&gt; @njit
... def duration_filter_func_nb(col, i, map_result, duration):
...     return duration[i, col] &gt;= 2

&gt;&gt;&gt; positions = BasePositions(
...     portfolio, 
...     pos_status=CLOSED, 
...     pos_filters=[(
...         duration_filter_func_nb, 
...         portfolio.positions.duration.vbt.to_2d_array()
...     )])
&gt;&gt;&gt; print(positions.avg_pnl)
-2.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BasePositions(ArrayWrapper):
    &#34;&#34;&#34;Exposes a range of attributes on top of positions in a `Portfolio` instance.
    
    This class doesn&#39;t hold any data, but creates a read-only view over position data.

    Args:
        pos_status (int): Can be any of: 
        
            * `vectorbt.portfolio.nb.OPEN` for open positions only,
            * `vectorbt.portfolio.nb.CLOSED` for closed positions only, or 
            * `None` for positions of any type.
        pos_filters (list or tuple): Can be used to further filter positions.

            Each element must be either: 
            
            * a Numba-compiled function, or 
            * a tuple of a Numba-compiled function and its (unpacked) arguments.

            !!! note
                Each `filter_func_nb` must be Numba-compiled.

    Example:
        Get the average P/L of closed positions with duration over 2 days:
        ```
        &gt;&gt;&gt; from vectorbt.portfolio import CLOSED, BasePositions

        &gt;&gt;&gt; orders = pd.Series([1, -1, 1, 0, -1], index=index)
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, init_capital=100)
        &gt;&gt;&gt; print(portfolio.positions.avg_pnl)
        -0.5

        &gt;&gt;&gt; @njit
        ... def duration_filter_func_nb(col, i, map_result, duration):
        ...     return duration[i, col] &gt;= 2

        &gt;&gt;&gt; positions = BasePositions(
        ...     portfolio, 
        ...     pos_status=CLOSED, 
        ...     pos_filters=[(
        ...         duration_filter_func_nb, 
        ...         portfolio.positions.duration.vbt.to_2d_array()
        ...     )])
        &gt;&gt;&gt; print(positions.avg_pnl)
        -2.0
        ```&#34;&#34;&#34;
    def __init__(self, portfolio, pos_status=None, pos_filters=[]):
        ArrayWrapper.__init__(self, portfolio)

        self.portfolio = portfolio
        self.pos_status = pos_status
        self.pos_filters = pos_filters

    def apply_mapper(self, map_func_nb, *args):
        &#34;&#34;&#34;Apply `map_func_nb` on each position using `vectorbt.portfolio.nb.map_positions_nb` 
        and filter the results with `pos_filters`.
        
        This way, all time series created on top of positions will be automatically filtered.&#34;&#34;&#34;
        checks.assert_numba_func(map_func_nb)

        # Apply map
        result = nb.map_positions_nb(
            self.portfolio.shares.vbt.to_2d_array(),
            self.pos_status,
            map_func_nb,
            *args)
        result = self.wrap_array(result)

        # Apply passed filters
        for pos_filter in self.pos_filters:
            if isfunction(pos_filter):
                filter_func_nb = pos_filter
                args = ()
            else:
                filter_func_nb = pos_filter[0]
                if len(pos_filter) &gt; 1:
                    args = pos_filter[1:]
                else:
                    args = ()
            checks.assert_numba_func(filter_func_nb)
            result = result.vbt.timeseries.filter(filter_func_nb, *args)

        return result

    # ############# Status ############# #

    @cached_property
    def status(self):
        &#34;&#34;&#34;Position status (open/closed) at the end of each position.&#34;&#34;&#34;
        return self.apply_mapper(nb.status_map_func_nb)

    @cached_property
    def count(self):
        &#34;&#34;&#34;Total position count of each column.&#34;&#34;&#34;
        return self.status.vbt.timeseries.count()

    # ############# Duration ############# #

    @cached_property
    def duration(self):
        &#34;&#34;&#34;Position duration at the end of each position.&#34;&#34;&#34;
        return self.apply_mapper(nb.duration_map_func_nb, self.portfolio.price.shape)

    @cached_property
    def min_duration(self):
        &#34;&#34;&#34;Minimum position duration of each column.&#34;&#34;&#34;
        return self.duration.vbt.timeseries.min(time_units=True)

    @cached_property
    def max_duration(self):
        &#34;&#34;&#34;Maximum position duration of each column.&#34;&#34;&#34;
        return self.duration.vbt.timeseries.max(time_units=True)

    @cached_property
    def total_duration(self):
        &#34;&#34;&#34;Total position duration of each column.&#34;&#34;&#34;
        return self.duration.vbt.timeseries.sum(time_units=True)

    @cached_property
    def avg_duration(self):
        &#34;&#34;&#34;Average position duration of each column.&#34;&#34;&#34;
        return self.duration.vbt.timeseries.mean(time_units=True)

    # ############# PnL ############# #

    @cached_property
    def pnl(self):
        &#34;&#34;&#34;Position P/L at the end of each position.&#34;&#34;&#34;
        return self.apply_mapper(
            nb.pnl_map_func_nb,
            self.portfolio.price.vbt.to_2d_array(),
            self.portfolio.cash.vbt.to_2d_array(),
            self.portfolio.shares.vbt.to_2d_array(),
            self.portfolio.init_capital)

    def plot_pnl(self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs):
        &#34;&#34;&#34;Plot position P/L as markers.

        Args:
            profit_trace_kwargs (dict): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for &#34;Profit&#34; markers.
            loss_trace_kwargs (dict): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for &#34;Loss&#34; markers.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            portfolio = vbt.Portfolio.from_orders(price, price.diff(), init_capital=100)
            portfolio.positions.plot_pnl()
            ```

            ![](/vectorbt/docs/img/positions_plot_pnl.png)&#34;&#34;&#34;
        checks.assert_type(self.pnl, pd.Series)

        above_trace_kwargs = {**dict(name=&#39;Profit&#39;), **profit_trace_kwargs}
        below_trace_kwargs = {**dict(name=&#39;Loss&#39;), **loss_trace_kwargs}
        return self.pnl.vbt.timeseries.plot_against(0, above_trace_kwargs=above_trace_kwargs, below_trace_kwargs=below_trace_kwargs)

    @cached_property
    def min_pnl(self):
        &#34;&#34;&#34;Minimum position P/L of each column.&#34;&#34;&#34;
        return self.pnl.vbt.timeseries.min()

    @cached_property
    def max_pnl(self):
        &#34;&#34;&#34;Maximum position P/L of each column.&#34;&#34;&#34;
        return self.pnl.vbt.timeseries.max()

    @cached_property
    def total_pnl(self):
        &#34;&#34;&#34;Total position P/L of each column.&#34;&#34;&#34;
        return self.pnl.vbt.timeseries.sum()

    @cached_property
    def avg_pnl(self):
        &#34;&#34;&#34;Average position P/L of each column.&#34;&#34;&#34;
        return self.pnl.vbt.timeseries.mean()

    # ############# Returns ############# #

    @cached_property
    def returns(self):
        &#34;&#34;&#34;Position returns at the end of each position.&#34;&#34;&#34;
        return self.apply_mapper(
            nb.returns_map_func_nb,
            self.portfolio.price.vbt.to_2d_array(),
            self.portfolio.cash.vbt.to_2d_array(),
            self.portfolio.shares.vbt.to_2d_array(),
            self.portfolio.init_capital)

    def plot_returns(self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs):
        &#34;&#34;&#34;Plot position returns as markers.

        See `BasePositions.plot_pnl`.&#34;&#34;&#34;
        checks.assert_type(self.pnl, pd.Series)

        above_trace_kwargs = {**dict(name=&#39;Profit&#39;), **profit_trace_kwargs}
        below_trace_kwargs = {**dict(name=&#39;Loss&#39;), **loss_trace_kwargs}
        return self.returns.vbt.timeseries.plot_against(0, above_trace_kwargs=above_trace_kwargs, below_trace_kwargs=below_trace_kwargs)

    @cached_property
    def min_return(self):
        &#34;&#34;&#34;Minimum position return of each column.&#34;&#34;&#34;
        return self.returns.vbt.timeseries.min()

    @cached_property
    def max_return(self):
        &#34;&#34;&#34;Maximum position return of each column.&#34;&#34;&#34;
        return self.returns.vbt.timeseries.max()

    @cached_property
    def avg_return(self):
        &#34;&#34;&#34;Average position return of each column.&#34;&#34;&#34;
        return self.returns.vbt.timeseries.mean()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.portfolio.ArrayWrapper" href="#vectorbt.portfolio.portfolio.ArrayWrapper">ArrayWrapper</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.portfolio.Positions" href="#vectorbt.portfolio.portfolio.Positions">Positions</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.portfolio.BasePositions.avg_duration"><code class="name">var <span class="ident">avg_duration</span></code></dt>
<dd>
<div class="desc"><p>Average position duration of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def avg_duration(self):
    &#34;&#34;&#34;Average position duration of each column.&#34;&#34;&#34;
    return self.duration.vbt.timeseries.mean(time_units=True)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.avg_pnl"><code class="name">var <span class="ident">avg_pnl</span></code></dt>
<dd>
<div class="desc"><p>Average position P/L of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def avg_pnl(self):
    &#34;&#34;&#34;Average position P/L of each column.&#34;&#34;&#34;
    return self.pnl.vbt.timeseries.mean()</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.avg_return"><code class="name">var <span class="ident">avg_return</span></code></dt>
<dd>
<div class="desc"><p>Average position return of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def avg_return(self):
    &#34;&#34;&#34;Average position return of each column.&#34;&#34;&#34;
    return self.returns.vbt.timeseries.mean()</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.count"><code class="name">var <span class="ident">count</span></code></dt>
<dd>
<div class="desc"><p>Total position count of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def count(self):
    &#34;&#34;&#34;Total position count of each column.&#34;&#34;&#34;
    return self.status.vbt.timeseries.count()</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.duration"><code class="name">var <span class="ident">duration</span></code></dt>
<dd>
<div class="desc"><p>Position duration at the end of each position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def duration(self):
    &#34;&#34;&#34;Position duration at the end of each position.&#34;&#34;&#34;
    return self.apply_mapper(nb.duration_map_func_nb, self.portfolio.price.shape)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.max_duration"><code class="name">var <span class="ident">max_duration</span></code></dt>
<dd>
<div class="desc"><p>Maximum position duration of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def max_duration(self):
    &#34;&#34;&#34;Maximum position duration of each column.&#34;&#34;&#34;
    return self.duration.vbt.timeseries.max(time_units=True)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.max_pnl"><code class="name">var <span class="ident">max_pnl</span></code></dt>
<dd>
<div class="desc"><p>Maximum position P/L of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def max_pnl(self):
    &#34;&#34;&#34;Maximum position P/L of each column.&#34;&#34;&#34;
    return self.pnl.vbt.timeseries.max()</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.max_return"><code class="name">var <span class="ident">max_return</span></code></dt>
<dd>
<div class="desc"><p>Maximum position return of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def max_return(self):
    &#34;&#34;&#34;Maximum position return of each column.&#34;&#34;&#34;
    return self.returns.vbt.timeseries.max()</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.min_duration"><code class="name">var <span class="ident">min_duration</span></code></dt>
<dd>
<div class="desc"><p>Minimum position duration of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def min_duration(self):
    &#34;&#34;&#34;Minimum position duration of each column.&#34;&#34;&#34;
    return self.duration.vbt.timeseries.min(time_units=True)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.min_pnl"><code class="name">var <span class="ident">min_pnl</span></code></dt>
<dd>
<div class="desc"><p>Minimum position P/L of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def min_pnl(self):
    &#34;&#34;&#34;Minimum position P/L of each column.&#34;&#34;&#34;
    return self.pnl.vbt.timeseries.min()</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.min_return"><code class="name">var <span class="ident">min_return</span></code></dt>
<dd>
<div class="desc"><p>Minimum position return of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def min_return(self):
    &#34;&#34;&#34;Minimum position return of each column.&#34;&#34;&#34;
    return self.returns.vbt.timeseries.min()</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.pnl"><code class="name">var <span class="ident">pnl</span></code></dt>
<dd>
<div class="desc"><p>Position P/L at the end of each position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def pnl(self):
    &#34;&#34;&#34;Position P/L at the end of each position.&#34;&#34;&#34;
    return self.apply_mapper(
        nb.pnl_map_func_nb,
        self.portfolio.price.vbt.to_2d_array(),
        self.portfolio.cash.vbt.to_2d_array(),
        self.portfolio.shares.vbt.to_2d_array(),
        self.portfolio.init_capital)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.returns"><code class="name">var <span class="ident">returns</span></code></dt>
<dd>
<div class="desc"><p>Position returns at the end of each position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def returns(self):
    &#34;&#34;&#34;Position returns at the end of each position.&#34;&#34;&#34;
    return self.apply_mapper(
        nb.returns_map_func_nb,
        self.portfolio.price.vbt.to_2d_array(),
        self.portfolio.cash.vbt.to_2d_array(),
        self.portfolio.shares.vbt.to_2d_array(),
        self.portfolio.init_capital)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.status"><code class="name">var <span class="ident">status</span></code></dt>
<dd>
<div class="desc"><p>Position status (open/closed) at the end of each position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def status(self):
    &#34;&#34;&#34;Position status (open/closed) at the end of each position.&#34;&#34;&#34;
    return self.apply_mapper(nb.status_map_func_nb)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.total_duration"><code class="name">var <span class="ident">total_duration</span></code></dt>
<dd>
<div class="desc"><p>Total position duration of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def total_duration(self):
    &#34;&#34;&#34;Total position duration of each column.&#34;&#34;&#34;
    return self.duration.vbt.timeseries.sum(time_units=True)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.total_pnl"><code class="name">var <span class="ident">total_pnl</span></code></dt>
<dd>
<div class="desc"><p>Total position P/L of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def total_pnl(self):
    &#34;&#34;&#34;Total position P/L of each column.&#34;&#34;&#34;
    return self.pnl.vbt.timeseries.sum()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.portfolio.portfolio.BasePositions.apply_mapper"><code class="name flex">
<span>def <span class="ident">apply_mapper</span></span>(<span>self, map_func_nb, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply <code>map_func_nb</code> on each position using <code><a title="vectorbt.portfolio.nb.map_positions_nb" href="nb.html#vectorbt.portfolio.nb.map_positions_nb">map_positions_nb()</a></code>
and filter the results with <code>pos_filters</code>.</p>
<p>This way, all time series created on top of positions will be automatically filtered.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_mapper(self, map_func_nb, *args):
    &#34;&#34;&#34;Apply `map_func_nb` on each position using `vectorbt.portfolio.nb.map_positions_nb` 
    and filter the results with `pos_filters`.
    
    This way, all time series created on top of positions will be automatically filtered.&#34;&#34;&#34;
    checks.assert_numba_func(map_func_nb)

    # Apply map
    result = nb.map_positions_nb(
        self.portfolio.shares.vbt.to_2d_array(),
        self.pos_status,
        map_func_nb,
        *args)
    result = self.wrap_array(result)

    # Apply passed filters
    for pos_filter in self.pos_filters:
        if isfunction(pos_filter):
            filter_func_nb = pos_filter
            args = ()
        else:
            filter_func_nb = pos_filter[0]
            if len(pos_filter) &gt; 1:
                args = pos_filter[1:]
            else:
                args = ()
        checks.assert_numba_func(filter_func_nb)
        result = result.vbt.timeseries.filter(filter_func_nb, *args)

    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.plot_pnl"><code class="name flex">
<span>def <span class="ident">plot_pnl</span></span>(<span>self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot position P/L as markers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>profit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> for "Profit" markers.</dd>
<dt><strong><code>loss_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> for "Loss" markers.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="py">portfolio = vbt.Portfolio.from_orders(price, price.diff(), init_capital=100)
portfolio.positions.plot_pnl()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/positions_plot_pnl.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_pnl(self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs):
    &#34;&#34;&#34;Plot position P/L as markers.

    Args:
        profit_trace_kwargs (dict): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for &#34;Profit&#34; markers.
        loss_trace_kwargs (dict): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for &#34;Loss&#34; markers.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Example:
        ```py
        portfolio = vbt.Portfolio.from_orders(price, price.diff(), init_capital=100)
        portfolio.positions.plot_pnl()
        ```

        ![](/vectorbt/docs/img/positions_plot_pnl.png)&#34;&#34;&#34;
    checks.assert_type(self.pnl, pd.Series)

    above_trace_kwargs = {**dict(name=&#39;Profit&#39;), **profit_trace_kwargs}
    below_trace_kwargs = {**dict(name=&#39;Loss&#39;), **loss_trace_kwargs}
    return self.pnl.vbt.timeseries.plot_against(0, above_trace_kwargs=above_trace_kwargs, below_trace_kwargs=below_trace_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.BasePositions.plot_returns"><code class="name flex">
<span>def <span class="ident">plot_returns</span></span>(<span>self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot position returns as markers.</p>
<p>See <code><a title="vectorbt.portfolio.portfolio.BasePositions.plot_pnl" href="#vectorbt.portfolio.portfolio.BasePositions.plot_pnl">BasePositions.plot_pnl()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_returns(self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs):
    &#34;&#34;&#34;Plot position returns as markers.

    See `BasePositions.plot_pnl`.&#34;&#34;&#34;
    checks.assert_type(self.pnl, pd.Series)

    above_trace_kwargs = {**dict(name=&#39;Profit&#39;), **profit_trace_kwargs}
    below_trace_kwargs = {**dict(name=&#39;Loss&#39;), **loss_trace_kwargs}
    return self.returns.vbt.timeseries.plot_against(0, above_trace_kwargs=above_trace_kwargs, below_trace_kwargs=below_trace_kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.portfolio.portfolio.ArrayWrapper" href="#vectorbt.portfolio.portfolio.ArrayWrapper">ArrayWrapper</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.portfolio.portfolio.ArrayWrapper.wrap_array" href="#vectorbt.portfolio.portfolio.ArrayWrapper.wrap_array">wrap_array</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.ArrayWrapper.wrap_reduced_array" href="#vectorbt.portfolio.portfolio.ArrayWrapper.wrap_reduced_array">wrap_reduced_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio"><code class="flex name class">
<span>class <span class="ident">Portfolio</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The job of the <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code> class is to create a series of positions allocated
against a cash component, produce an equity curve, incorporate basic transaction costs
and produce a set of statistics about its performance. In particular it outputs
position/profit metrics and drawdown information.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Portfolio is only built by using class methods with <code>from_</code> prefix.
The <code>__init__</code> method is reserved for indexing purposes.</p>
</div>
<p>It produces two types of objects:</p>
<ul>
<li>time series such as <code><a title="vectorbt.portfolio.portfolio.Portfolio.equity" href="#vectorbt.portfolio.portfolio.Portfolio.equity">Portfolio.equity</a></code>, and</li>
<li>various metrics such as <code><a title="vectorbt.portfolio.portfolio.Portfolio.total_profit" href="#vectorbt.portfolio.portfolio.Portfolio.total_profit">Portfolio.total_profit</a></code>.</li>
</ul>
<p>The former are indexed by time, the latter are indexed by columns.</p>
<h2 id="indexing">Indexing</h2>
<p>In addition, you can use pandas indexing on the <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code> class itself, which forwards
indexing operation to each attribute with pandas type (see <code><a title="vectorbt.portfolio.portfolio.portfolio_indexing_func" href="#vectorbt.portfolio.portfolio.portfolio_indexing_func">portfolio_indexing_func()</a></code>):</p>
<pre><code class="python-repl">&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, price.diff(), init_capital=100)

&gt;&gt;&gt; print(portfolio.equity)
2018-01-01    100.0
2018-01-02    100.0
2018-01-03    101.0
2018-01-04     99.0
2018-01-05     98.0
Name: a, dtype: float64
&gt;&gt;&gt; print(portfolio.loc['2018-01-03':].equity)
2018-01-03    101.0
2018-01-04     99.0
2018-01-05     98.0
Name: a, dtype: float64
</code></pre>
<p>Note that for the new <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code> instance, date <code>'2018-01-03'</code> will be the new start date.</p>
<h2 id="addition">Addition</h2>
<p>You can also add multiple <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code> instances together to combine portfolios:</p>
<pre><code class="python-repl">&gt;&gt;&gt; portfolio1 = vbt.Portfolio.from_orders(price, price.diff(), init_capital=100)
&gt;&gt;&gt; portfolio2 = vbt.Portfolio.from_orders(price, price.diff()*2, init_capital=20)
&gt;&gt;&gt; portfolio = portfolio1 + portfolio2

&gt;&gt;&gt; print(portfolio.init_capital)
120.0
&gt;&gt;&gt; print(portfolio.equity)
2018-01-01    120.0
2018-01-02    120.0
2018-01-03    123.0
2018-01-04    117.0
2018-01-05    114.0
Name: a, dtype: float64
</code></pre>
<p>The only requirement is that pandas objects of both portfolios must have the same metadata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Portfolio(ArrayWrapper):
    &#34;&#34;&#34;The job of the `Portfolio` class is to create a series of positions allocated 
    against a cash component, produce an equity curve, incorporate basic transaction costs 
    and produce a set of statistics about its performance. In particular it outputs 
    position/profit metrics and drawdown information.

    !!! note
        Portfolio is only built by using class methods with `from_` prefix.
        The `__init__` method is reserved for indexing purposes.

    It produces two types of objects:
    
    * time series such as `Portfolio.equity`, and
    * various metrics such as `Portfolio.total_profit`.
    
    The former are indexed by time, the latter are indexed by columns.

    ## Indexing

    In addition, you can use pandas indexing on the `Portfolio` class itself, which forwards
    indexing operation to each attribute with pandas type (see `portfolio_indexing_func`):
    
    ```python-repl
    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, price.diff(), init_capital=100)

    &gt;&gt;&gt; print(portfolio.equity)
    2018-01-01    100.0
    2018-01-02    100.0
    2018-01-03    101.0
    2018-01-04     99.0
    2018-01-05     98.0
    Name: a, dtype: float64
    &gt;&gt;&gt; print(portfolio.loc[&#39;2018-01-03&#39;:].equity)
    2018-01-03    101.0
    2018-01-04     99.0
    2018-01-05     98.0
    Name: a, dtype: float64
    ```

    Note that for the new `Portfolio` instance, date `&#39;2018-01-03&#39;` will be the new start date.

    ## Addition

    You can also add multiple `Portfolio` instances together to combine portfolios:

    ```python-repl
    &gt;&gt;&gt; portfolio1 = vbt.Portfolio.from_orders(price, price.diff(), init_capital=100)
    &gt;&gt;&gt; portfolio2 = vbt.Portfolio.from_orders(price, price.diff()*2, init_capital=20)
    &gt;&gt;&gt; portfolio = portfolio1 + portfolio2

    &gt;&gt;&gt; print(portfolio.init_capital)
    120.0
    &gt;&gt;&gt; print(portfolio.equity)
    2018-01-01    120.0
    2018-01-02    120.0
    2018-01-03    123.0
    2018-01-04    117.0
    2018-01-05    114.0
    Name: a, dtype: float64
    ```

    The only requirement is that pandas objects of both portfolios must have the same metadata.&#34;&#34;&#34;

    def __init__(self, price, cash, shares, init_capital, paid_fees, paid_slippage):
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_same_meta(price, cash)
        checks.assert_same_meta(price, shares)

        self.price = price
        self.cash = cash
        self.shares = shares
        self.init_capital = init_capital
        self.paid_fees = paid_fees
        self.paid_slippage = paid_slippage

        ArrayWrapper.__init__(self, self)

    # ############# Magic methods ############# #

    def __add__(self, other):
        checks.assert_type(other, self.__class__)
        checks.assert_same(self.price, other.price)

        return self.__class__(
            self.price,
            self.cash + other.cash,
            self.shares + other.shares,
            self.init_capital + other.init_capital,
            self.paid_fees + other.paid_fees,
            self.paid_slippage + other.paid_slippage
        )

    def __radd__(self, other):
        return Portfolio.__add__(self, other)

    # ############# Class methods ############# #

    @classmethod
    def from_signals(cls, price, entries, exits, amount=np.inf, init_capital=None,
                     fees=None, slippage=None, broadcast_kwargs={}):
        &#34;&#34;&#34;Build portfolio from entry and exit signals.

        Starting with initial capital `init_capital`, for each `True` in `entries`/`exits`, 
        orders the number of shares specified in `amount`. 

        Args:
            price (pandas_like): Price of the asset.
            entries (pandas_like): Boolean array of entry signals.
            exits (pandas_like): Boolean array of exit signals.
            amount (int, float or array_like): The amount of shares to order. 

                To buy/sell everything, set the amount to `numpy.inf`.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Trading fees in percentage of the value involved.
            slippage (float or array_like): Slippage in percentage of `price`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
        with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

        !!! note
            There is no mechanism implemented to prevent order accumulation, meaning multiple entry/exit 
            signals one after another may increase/decrease your position in the market. That&#39;s why we will
            later calculate P/L of positions instead of trades.

            To select at most one exit signal, use `vectorbt.signals.accessors.Signals_Accessor.first`. 

        Example:
            Portfolio value of various signal sequences:
            ```python-repl
            &gt;&gt;&gt; entries = pd.DataFrame({
            ...     &#39;a&#39;: [True, False, False, False, False],
            ...     &#39;b&#39;: [True, True, True, True, True],
            ...     &#39;c&#39;: [True, False, True, False, True]
            ... }, index=index)
            &gt;&gt;&gt; exits = pd.DataFrame({
            ...     &#39;a&#39;: [False, False, False, False, False],
            ...     &#39;b&#39;: [False, False, False, False, False],
            ...     &#39;c&#39;: [False, True, False, True, False]
            ... }, index=index)

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(price, entries, 
            ...     exits, amount=10, init_capital=100, fees=0.0025)

            &gt;&gt;&gt; print(portfolio.cash)
                             a       b        c
            2018-01-01  89.975  89.975   89.975
            2018-01-02  89.975  69.925  109.925
            2018-01-03  89.975  39.850   79.850
            2018-01-04  89.975  19.800   99.800
            2018-01-05  89.975   9.775   89.775
            &gt;&gt;&gt; print(portfolio.shares)
                           a     b     c
            2018-01-01  10.0  10.0  10.0
            2018-01-02  10.0  20.0   0.0
            2018-01-03  10.0  30.0  10.0
            2018-01-04  10.0  40.0   0.0
            2018-01-05  10.0  50.0  10.0
            &gt;&gt;&gt; print(portfolio.equity)
                              a        b        c
            2018-01-01   99.975   99.975   99.975
            2018-01-02  109.975  109.925  109.925
            2018-01-03  119.975  129.850  109.850
            2018-01-04  109.975   99.800   99.800
            2018-01-05   99.975   59.775   99.775
            &gt;&gt;&gt; print(portfolio.total_costs)
            a    0.025
            b    0.225
            c    0.225
            dtype: float64
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_type(entries, (pd.Series, pd.DataFrame))
        checks.assert_type(exits, (pd.Series, pd.DataFrame))
        entries.vbt.signals.validate()
        exits.vbt.signals.validate()

        # Broadcast inputs
        price, entries, exits, amount, fees, slippage = reshape_fns.broadcast(
            price, entries, exits, amount, fees, slippage, **broadcast_kwargs, writeable=True)

        # Perform calculation
        cash, shares, paid_fees, paid_slippage = nb.portfolio_nb(
            reshape_fns.to_2d(price, raw=True),
            init_capital,
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            nb.signals_order_func_nb,
            reshape_fns.to_2d(entries, raw=True),
            reshape_fns.to_2d(exits, raw=True),
            reshape_fns.to_2d(amount, raw=True))

        # Bring to the same meta
        cash = price.vbt.wrap_array(cash)
        shares = price.vbt.wrap_array(shares)
        paid_fees = price.vbt.wrap_array(paid_fees)
        paid_slippage = price.vbt.wrap_array(paid_slippage)

        return cls(price, cash, shares, init_capital, paid_fees, paid_slippage)

    @classmethod
    def from_orders(cls, price, orders, is_target=False, init_capital=None, fees=None,
                    slippage=None, broadcast_kwargs={}):
        &#34;&#34;&#34;Build portfolio from orders.

        Starting with initial capital `init_capital`, at each time step, orders the number 
        of shares specified in `orders`. 

        Args:
            price (pandas_like): Price of the asset.
            orders (int, float or array_like): The amount of shares to order. 

                If the amount is positive, this is the number of shares to buy. 
                If the amount is negative, this is the number of shares to sell.
                To buy/sell everything, set the amount to `numpy.inf`.
            is_target (bool): If `True`, will order the difference between current and target amount.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Trading fees in percentage of the value involved.
            slippage (float or array_like): Slippage in percentage of `price`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
        with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

        Example:
            Portfolio value of various order sequences:
            ```python-repl
            &gt;&gt;&gt; orders = pd.DataFrame({
            ...     &#39;a&#39;: [np.inf, 0, 0, 0, 0],
            ...     &#39;b&#39;: [1, 1, 1, 1, -np.inf],
            ...     &#39;c&#39;: [np.inf, -np.inf, np.inf, -np.inf, np.inf]
            ... }, index=index)

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
            ...     init_capital=100, fees=0.0025)

            &gt;&gt;&gt; print(portfolio.cash)
                          a        b           c
            2018-01-01  0.0  98.9975    0.000000
            2018-01-02  0.0  96.9925  199.002494
            2018-01-03  0.0  93.9850    0.000000
            2018-01-04  0.0  91.9800  132.006642
            2018-01-05  0.0  95.9700    0.000000
            &gt;&gt;&gt; print(portfolio.shares)
                                a    b           c
            2018-01-01  99.750623  1.0   99.750623
            2018-01-02  99.750623  2.0    0.000000
            2018-01-03  99.750623  3.0   66.168743
            2018-01-04  99.750623  4.0    0.000000
            2018-01-05  99.750623  0.0  131.677448
            &gt;&gt;&gt; print(portfolio.equity)
                                 a         b           c
            2018-01-01   99.750623   99.9975   99.750623
            2018-01-02  199.501247  100.9925  199.002494
            2018-01-03  299.251870  102.9850  198.506228
            2018-01-04  199.501247   99.9800  132.006642
            2018-01-05   99.750623   95.9700  131.677448
            &gt;&gt;&gt; print(portfolio.total_costs)
            a    0.249377
            b    0.030000
            c    1.904433
            dtype: float64
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_type(orders, (pd.Series, pd.DataFrame))

        # Broadcast inputs
        price, orders = reshape_fns.broadcast(price, orders, **broadcast_kwargs, writeable=True)
        fees = reshape_fns.broadcast_to(fees, price, to_pd=False, writeable=True)
        slippage = reshape_fns.broadcast_to(slippage, price, to_pd=False, writeable=True)

        # Perform calculation
        cash, shares, paid_fees, paid_slippage = nb.portfolio_nb(
            reshape_fns.to_2d(price, raw=True),
            init_capital,
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            nb.amount_order_func_nb,
            reshape_fns.to_2d(orders, raw=True),
            is_target)

        # Bring to the same meta
        cash = price.vbt.wrap_array(cash)
        shares = price.vbt.wrap_array(shares)
        paid_fees = price.vbt.wrap_array(paid_fees)
        paid_slippage = price.vbt.wrap_array(paid_slippage)

        return cls(price, cash, shares, init_capital, paid_fees, paid_slippage)

    @classmethod
    def from_order_func(cls, price, order_func_nb, *args, init_capital=None, fees=None, slippage=None):
        &#34;&#34;&#34;Build portfolio from a custom order function.

        Starting with initial capital `init_capital`, at each time step, orders the number 
        of shares returned by `order_func_nb`. 

        Args:
            price (pandas_like): Price of the asset.
            order_func_nb (function): Function that returns the amount of shares to order.

                See `vectorbt.portfolio.nb.portfolio_nb`.
            *args: Arguments passed to `order_func_nb`.
            init_capital (int or float): The initial capital.
            fees (float or array_like): Trading fees in percentage of the value involved.
            slippage (float or array_like): Slippage in percentage of `price`.

        All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
        with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

        !!! note
            `order_func_nb` must be Numba-compiled.

        Example:
            Portfolio value of a simple buy-and-hold strategy:
            ```python-repl
            &gt;&gt;&gt; @njit
            ... def order_func_nb(col, i, run_cash, run_shares):
            ...     return 10 if i == 0 else 0

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(price, 
            ...     order_func_nb, init_capital=100, fees=0.0025)

            &gt;&gt;&gt; print(portfolio.cash)
            2018-01-01    89.975
            2018-01-02    89.975
            2018-01-03    89.975
            2018-01-04    89.975
            2018-01-05    89.975
            dtype: float64
            &gt;&gt;&gt; print(portfolio.shares)
            2018-01-01    10.0
            2018-01-02    10.0
            2018-01-03    10.0
            2018-01-04    10.0
            2018-01-05    10.0
            dtype: float64
            &gt;&gt;&gt; print(portfolio.equity)
            2018-01-01     99.975
            2018-01-02    109.975
            2018-01-03    119.975
            2018-01-04    109.975
            2018-01-05     99.975
            dtype: float64
            &gt;&gt;&gt; print(portfolio.total_costs)
            0.02499999999999858
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        init_capital = float(init_capital)
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(price, (pd.Series, pd.DataFrame))
        checks.assert_numba_func(order_func_nb)

        # Broadcast inputs
        fees = reshape_fns.broadcast_to(fees, price, to_pd=False, writeable=True)
        slippage = reshape_fns.broadcast_to(slippage, price, to_pd=False, writeable=True)

        # Perform calculation
        cash, shares, paid_fees, paid_slippage = nb.portfolio_nb(
            reshape_fns.to_2d(price, raw=True),
            init_capital,
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            order_func_nb,
            *args)

        # Bring to the same meta
        cash = price.vbt.wrap_array(cash)
        shares = price.vbt.wrap_array(shares)
        paid_fees = price.vbt.wrap_array(paid_fees)
        paid_slippage = price.vbt.wrap_array(paid_slippage)

        return cls(price, cash, shares, init_capital, paid_fees, paid_slippage)

    # ############# Time series ############# #

    @cached_property
    def equity(self):
        &#34;&#34;&#34;Portfolio value at each time step.&#34;&#34;&#34;
        equity = self.cash.vbt.to_2d_array() + self.shares.vbt.to_2d_array() * self.price.vbt.to_2d_array()
        return self.wrap_array(equity)

    @cached_property
    def returns(self):
        &#34;&#34;&#34;Portfolio returns at each time step.&#34;&#34;&#34;
        returns = timeseries.nb.pct_change_nb(self.equity.vbt.to_2d_array())
        return self.wrap_array(returns)

    @cached_property
    def trades(self):
        &#34;&#34;&#34;Amount of shares ordered at each time step.&#34;&#34;&#34;
        shares = self.shares.vbt.to_2d_array()
        trades = timeseries.nb.fillna_nb(timeseries.nb.diff_nb(shares), 0)
        trades[0, :] = shares[0, :]
        return self.wrap_array(trades)

    @cached_property
    def has_trades(self):
        &#34;&#34;&#34;Whether any trades happened in each column.&#34;&#34;&#34;
        has_trades = (self.trades.vbt.to_2d_array() &gt; 0).any(axis=0)
        return self.wrap_reduced_array(has_trades)

    def plot_trades(self,
                    buy_trace_kwargs={},
                    sell_trace_kwargs={},
                    fig=None,
                    **layout_kwargs):
        &#34;&#34;&#34;Plot trades as markers.

        Args:
            buy_trace_kwargs (dict): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for &#34;Buy&#34; markers.
            sell_trace_kwargs (dict): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for &#34;Sell&#34; markers.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Example:
            ```py
            vbt.Portfolio.from_orders(price, price.diff(), init_capital=100).plot_trades()
            ```

            ![](/vectorbt/docs/img/portfolio_plot_trades.png)&#34;&#34;&#34;
        checks.assert_type(self.price, pd.Series)
        checks.assert_type(self.trades, pd.Series)
        sell_mask = self.trades &lt; 0
        buy_mask = self.trades &gt; 0

        # Plot time series
        fig = self.price.vbt.timeseries.plot(fig=fig, **layout_kwargs)
        # Plot markers
        buy_trace_kwargs = common.merge_kwargs(dict(
            customdata=self.trades[buy_mask],
            hovertemplate=&#39;(%{x}, %{y})&lt;br&gt;%{customdata:.6g}&#39;,
            marker=dict(
                symbol=&#39;triangle-up&#39;,
                color=&#39;limegreen&#39;
            )
        ), buy_trace_kwargs)
        buy_mask.vbt.signals.plot_markers(
            self.price, name=&#39;Buy&#39;, trace_kwargs=buy_trace_kwargs, fig=fig, **layout_kwargs)
        sell_trace_kwargs = common.merge_kwargs(dict(
            customdata=self.trades[sell_mask],
            hovertemplate=&#39;(%{x}, %{y})&lt;br&gt;%{customdata:.6g}&#39;,
            marker=dict(
                symbol=&#39;triangle-down&#39;,
                color=&#39;orangered&#39;
            )
        ), sell_trace_kwargs)
        sell_mask.vbt.signals.plot_markers(
            self.price, name=&#39;Sell&#39;, trace_kwargs=sell_trace_kwargs, fig=fig, **layout_kwargs)
        return fig

    @cached_property
    def drawdown(self):
        &#34;&#34;&#34;Relative decline from a peak at each time step.&#34;&#34;&#34;
        equity = self.equity.vbt.to_2d_array()
        drawdown = 1 - equity / timeseries.nb.expanding_max_nb(equity)
        return self.wrap_array(drawdown)

    # ############# Costs ############# #

    @cached_property
    def total_paid_fees(self):
        &#34;&#34;&#34;Total paid fees of each column.&#34;&#34;&#34;
        total_paid_fees = np.sum(self.paid_fees.vbt.to_2d_array(), axis=0)
        return self.wrap_reduced_array(total_paid_fees)

    @cached_property
    def total_paid_slippage(self):
        &#34;&#34;&#34;Total paid slippage of each column.&#34;&#34;&#34;
        total_paid_slippage = np.sum(self.paid_slippage.vbt.to_2d_array(), axis=0)
        return self.wrap_reduced_array(total_paid_slippage)

    @cached_property
    def total_costs(self):
        &#34;&#34;&#34;Total costs of each column.&#34;&#34;&#34;
        total_paid_fees = reshape_fns.to_1d(self.total_paid_fees, raw=True)
        total_paid_slippage = reshape_fns.to_1d(self.total_paid_slippage, raw=True)
        total_costs = total_paid_fees + total_paid_slippage
        return self.wrap_reduced_array(total_costs)

    # ############# Positions ############# #

    @property
    def positions(self):
        &#34;&#34;&#34;Open and closed positions of class `Positions`.&#34;&#34;&#34;
        if not hasattr(self, &#39;_positions&#39;):
            self._positions = Positions(self, pos_status=None)
        return self._positions

    @property
    def open_positions(self):
        &#34;&#34;&#34;Open positions of class `Positions`.&#34;&#34;&#34;
        if not hasattr(self, &#39;_open_positions&#39;):
            self._open_positions = Positions(self, pos_status=nb.OPEN)
        return self._open_positions

    @property
    def closed_positions(self):
        &#34;&#34;&#34;Closed positions of class `Positions`.&#34;&#34;&#34;
        if not hasattr(self, &#39;_closed_positions&#39;):
            self._closed_positions = Positions(self, pos_status=nb.CLOSED)
        return self._closed_positions

    # ############# Performance ############# #

    @cached_property
    def total_profit(self):
        &#34;&#34;&#34;Total profit of each column.&#34;&#34;&#34;
        total_profit = self.equity.vbt.to_2d_array()[-1, :] - self.init_capital
        return self.wrap_reduced_array(total_profit)

    @cached_property
    def total_return(self):
        &#34;&#34;&#34;Total return of each column.&#34;&#34;&#34;
        total_return = reshape_fns.to_1d(self.total_profit, raw=True) / self.init_capital
        return self.wrap_reduced_array(total_return)

    @cached_property
    def daily_return(self):
        &#34;&#34;&#34;Total daily return of each column.&#34;&#34;&#34;
        return self.returns.vbt.timeseries.resample_apply(&#39;D&#39;, nb.total_return_apply_func_nb)

    @cached_property
    def annual_return(self):
        &#34;&#34;&#34;Total annual return of each column.&#34;&#34;&#34;
        return self.returns.vbt.timeseries.resample_apply(&#39;Y&#39;, nb.total_return_apply_func_nb)

    @cached_property
    def max_drawdown(self):
        &#34;&#34;&#34;Total maximum drawdown (MDD) of each column.&#34;&#34;&#34;
        max_drawdown = np.max(self.drawdown.vbt.to_2d_array(), axis=0)
        return self.wrap_reduced_array(max_drawdown)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.portfolio.ArrayWrapper" href="#vectorbt.portfolio.portfolio.ArrayWrapper">ArrayWrapper</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.portfolio.portfolio.Portfolio.from_order_func"><code class="name flex">
<span>def <span class="ident">from_order_func</span></span>(<span>price, order_func_nb, *args, init_capital=None, fees=None, slippage=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from a custom order function.</p>
<p>Starting with initial capital <code>init_capital</code>, at each time step, orders the number
of shares returned by <code>order_func_nb</code>. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Price of the asset.</dd>
<dt><strong><code>order_func_nb</code></strong> :&ensp;<code>function</code></dt>
<dd>
<p>Function that returns the amount of shares to order.</p>
<p>See <code><a title="vectorbt.portfolio.nb.portfolio_nb" href="nb.html#vectorbt.portfolio.nb.portfolio_nb">portfolio_nb()</a></code>.</p>
</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>Arguments passed to <code>order_func_nb</code>.</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The initial capital.</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Trading fees in percentage of the value involved.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of <code>price</code>.</dd>
</dl>
<p>All array-like arguments will be broadcasted together using <code><a title="vectorbt.utils.reshape_fns.broadcast" href="../utils/reshape_fns.html#vectorbt.utils.reshape_fns.broadcast">broadcast()</a></code>
with <code>broadcast_kwargs</code>. At the end, each time series object will have the same metadata.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>order_func_nb</code> must be Numba-compiled.</p>
</div>
<h2 id="example">Example</h2>
<p>Portfolio value of a simple buy-and-hold strategy:</p>
<pre><code class="python-repl">&gt;&gt;&gt; @njit
... def order_func_nb(col, i, run_cash, run_shares):
...     return 10 if i == 0 else 0

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(price, 
...     order_func_nb, init_capital=100, fees=0.0025)

&gt;&gt;&gt; print(portfolio.cash)
2018-01-01    89.975
2018-01-02    89.975
2018-01-03    89.975
2018-01-04    89.975
2018-01-05    89.975
dtype: float64
&gt;&gt;&gt; print(portfolio.shares)
2018-01-01    10.0
2018-01-02    10.0
2018-01-03    10.0
2018-01-04    10.0
2018-01-05    10.0
dtype: float64
&gt;&gt;&gt; print(portfolio.equity)
2018-01-01     99.975
2018-01-02    109.975
2018-01-03    119.975
2018-01-04    109.975
2018-01-05     99.975
dtype: float64
&gt;&gt;&gt; print(portfolio.total_costs)
0.02499999999999858
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_order_func(cls, price, order_func_nb, *args, init_capital=None, fees=None, slippage=None):
    &#34;&#34;&#34;Build portfolio from a custom order function.

    Starting with initial capital `init_capital`, at each time step, orders the number 
    of shares returned by `order_func_nb`. 

    Args:
        price (pandas_like): Price of the asset.
        order_func_nb (function): Function that returns the amount of shares to order.

            See `vectorbt.portfolio.nb.portfolio_nb`.
        *args: Arguments passed to `order_func_nb`.
        init_capital (int or float): The initial capital.
        fees (float or array_like): Trading fees in percentage of the value involved.
        slippage (float or array_like): Slippage in percentage of `price`.

    All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
    with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

    !!! note
        `order_func_nb` must be Numba-compiled.

    Example:
        Portfolio value of a simple buy-and-hold strategy:
        ```python-repl
        &gt;&gt;&gt; @njit
        ... def order_func_nb(col, i, run_cash, run_shares):
        ...     return 10 if i == 0 else 0

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(price, 
        ...     order_func_nb, init_capital=100, fees=0.0025)

        &gt;&gt;&gt; print(portfolio.cash)
        2018-01-01    89.975
        2018-01-02    89.975
        2018-01-03    89.975
        2018-01-04    89.975
        2018-01-05    89.975
        dtype: float64
        &gt;&gt;&gt; print(portfolio.shares)
        2018-01-01    10.0
        2018-01-02    10.0
        2018-01-03    10.0
        2018-01-04    10.0
        2018-01-05    10.0
        dtype: float64
        &gt;&gt;&gt; print(portfolio.equity)
        2018-01-01     99.975
        2018-01-02    109.975
        2018-01-03    119.975
        2018-01-04    109.975
        2018-01-05     99.975
        dtype: float64
        &gt;&gt;&gt; print(portfolio.total_costs)
        0.02499999999999858
        ```
    &#34;&#34;&#34;
    # Get defaults
    if init_capital is None:
        init_capital = defaults.portfolio[&#39;init_capital&#39;]
    init_capital = float(init_capital)
    if fees is None:
        fees = defaults.portfolio[&#39;fees&#39;]
    if slippage is None:
        slippage = defaults.portfolio[&#39;slippage&#39;]

    # Perform checks
    checks.assert_type(price, (pd.Series, pd.DataFrame))
    checks.assert_numba_func(order_func_nb)

    # Broadcast inputs
    fees = reshape_fns.broadcast_to(fees, price, to_pd=False, writeable=True)
    slippage = reshape_fns.broadcast_to(slippage, price, to_pd=False, writeable=True)

    # Perform calculation
    cash, shares, paid_fees, paid_slippage = nb.portfolio_nb(
        reshape_fns.to_2d(price, raw=True),
        init_capital,
        reshape_fns.to_2d(fees, raw=True),
        reshape_fns.to_2d(slippage, raw=True),
        order_func_nb,
        *args)

    # Bring to the same meta
    cash = price.vbt.wrap_array(cash)
    shares = price.vbt.wrap_array(shares)
    paid_fees = price.vbt.wrap_array(paid_fees)
    paid_slippage = price.vbt.wrap_array(paid_slippage)

    return cls(price, cash, shares, init_capital, paid_fees, paid_slippage)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.from_orders"><code class="name flex">
<span>def <span class="ident">from_orders</span></span>(<span>price, orders, is_target=False, init_capital=None, fees=None, slippage=None, broadcast_kwargs={})</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from orders.</p>
<p>Starting with initial capital <code>init_capital</code>, at each time step, orders the number
of shares specified in <code>orders</code>. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Price of the asset.</dd>
<dt><strong><code>orders</code></strong> :&ensp;<code>int, float</code> or <code>array_like</code></dt>
<dd>
<p>The amount of shares to order. </p>
<p>If the amount is positive, this is the number of shares to buy.
If the amount is negative, this is the number of shares to sell.
To buy/sell everything, set the amount to <code>numpy.inf</code>.</p>
</dd>
<dt><strong><code>is_target</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, will order the difference between current and target amount.</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The initial capital.</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Trading fees in percentage of the value involved.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of <code>price</code>.</dd>
</dl>
<p>All array-like arguments will be broadcasted together using <code><a title="vectorbt.utils.reshape_fns.broadcast" href="../utils/reshape_fns.html#vectorbt.utils.reshape_fns.broadcast">broadcast()</a></code>
with <code>broadcast_kwargs</code>. At the end, each time series object will have the same metadata.</p>
<h2 id="example">Example</h2>
<p>Portfolio value of various order sequences:</p>
<pre><code class="python-repl">&gt;&gt;&gt; orders = pd.DataFrame({
...     'a': [np.inf, 0, 0, 0, 0],
...     'b': [1, 1, 1, 1, -np.inf],
...     'c': [np.inf, -np.inf, np.inf, -np.inf, np.inf]
... }, index=index)

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
...     init_capital=100, fees=0.0025)

&gt;&gt;&gt; print(portfolio.cash)
              a        b           c
2018-01-01  0.0  98.9975    0.000000
2018-01-02  0.0  96.9925  199.002494
2018-01-03  0.0  93.9850    0.000000
2018-01-04  0.0  91.9800  132.006642
2018-01-05  0.0  95.9700    0.000000
&gt;&gt;&gt; print(portfolio.shares)
                    a    b           c
2018-01-01  99.750623  1.0   99.750623
2018-01-02  99.750623  2.0    0.000000
2018-01-03  99.750623  3.0   66.168743
2018-01-04  99.750623  4.0    0.000000
2018-01-05  99.750623  0.0  131.677448
&gt;&gt;&gt; print(portfolio.equity)
                     a         b           c
2018-01-01   99.750623   99.9975   99.750623
2018-01-02  199.501247  100.9925  199.002494
2018-01-03  299.251870  102.9850  198.506228
2018-01-04  199.501247   99.9800  132.006642
2018-01-05   99.750623   95.9700  131.677448
&gt;&gt;&gt; print(portfolio.total_costs)
a    0.249377
b    0.030000
c    1.904433
dtype: float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_orders(cls, price, orders, is_target=False, init_capital=None, fees=None,
                slippage=None, broadcast_kwargs={}):
    &#34;&#34;&#34;Build portfolio from orders.

    Starting with initial capital `init_capital`, at each time step, orders the number 
    of shares specified in `orders`. 

    Args:
        price (pandas_like): Price of the asset.
        orders (int, float or array_like): The amount of shares to order. 

            If the amount is positive, this is the number of shares to buy. 
            If the amount is negative, this is the number of shares to sell.
            To buy/sell everything, set the amount to `numpy.inf`.
        is_target (bool): If `True`, will order the difference between current and target amount.
        init_capital (int or float): The initial capital.
        fees (float or array_like): Trading fees in percentage of the value involved.
        slippage (float or array_like): Slippage in percentage of `price`.

    All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
    with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

    Example:
        Portfolio value of various order sequences:
        ```python-repl
        &gt;&gt;&gt; orders = pd.DataFrame({
        ...     &#39;a&#39;: [np.inf, 0, 0, 0, 0],
        ...     &#39;b&#39;: [1, 1, 1, 1, -np.inf],
        ...     &#39;c&#39;: [np.inf, -np.inf, np.inf, -np.inf, np.inf]
        ... }, index=index)

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
        ...     init_capital=100, fees=0.0025)

        &gt;&gt;&gt; print(portfolio.cash)
                      a        b           c
        2018-01-01  0.0  98.9975    0.000000
        2018-01-02  0.0  96.9925  199.002494
        2018-01-03  0.0  93.9850    0.000000
        2018-01-04  0.0  91.9800  132.006642
        2018-01-05  0.0  95.9700    0.000000
        &gt;&gt;&gt; print(portfolio.shares)
                            a    b           c
        2018-01-01  99.750623  1.0   99.750623
        2018-01-02  99.750623  2.0    0.000000
        2018-01-03  99.750623  3.0   66.168743
        2018-01-04  99.750623  4.0    0.000000
        2018-01-05  99.750623  0.0  131.677448
        &gt;&gt;&gt; print(portfolio.equity)
                             a         b           c
        2018-01-01   99.750623   99.9975   99.750623
        2018-01-02  199.501247  100.9925  199.002494
        2018-01-03  299.251870  102.9850  198.506228
        2018-01-04  199.501247   99.9800  132.006642
        2018-01-05   99.750623   95.9700  131.677448
        &gt;&gt;&gt; print(portfolio.total_costs)
        a    0.249377
        b    0.030000
        c    1.904433
        dtype: float64
        ```
    &#34;&#34;&#34;
    # Get defaults
    if init_capital is None:
        init_capital = defaults.portfolio[&#39;init_capital&#39;]
    init_capital = float(init_capital)
    if fees is None:
        fees = defaults.portfolio[&#39;fees&#39;]
    if slippage is None:
        slippage = defaults.portfolio[&#39;slippage&#39;]

    # Perform checks
    checks.assert_type(price, (pd.Series, pd.DataFrame))
    checks.assert_type(orders, (pd.Series, pd.DataFrame))

    # Broadcast inputs
    price, orders = reshape_fns.broadcast(price, orders, **broadcast_kwargs, writeable=True)
    fees = reshape_fns.broadcast_to(fees, price, to_pd=False, writeable=True)
    slippage = reshape_fns.broadcast_to(slippage, price, to_pd=False, writeable=True)

    # Perform calculation
    cash, shares, paid_fees, paid_slippage = nb.portfolio_nb(
        reshape_fns.to_2d(price, raw=True),
        init_capital,
        reshape_fns.to_2d(fees, raw=True),
        reshape_fns.to_2d(slippage, raw=True),
        nb.amount_order_func_nb,
        reshape_fns.to_2d(orders, raw=True),
        is_target)

    # Bring to the same meta
    cash = price.vbt.wrap_array(cash)
    shares = price.vbt.wrap_array(shares)
    paid_fees = price.vbt.wrap_array(paid_fees)
    paid_slippage = price.vbt.wrap_array(paid_slippage)

    return cls(price, cash, shares, init_capital, paid_fees, paid_slippage)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.from_signals"><code class="name flex">
<span>def <span class="ident">from_signals</span></span>(<span>price, entries, exits, amount=inf, init_capital=None, fees=None, slippage=None, broadcast_kwargs={})</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from entry and exit signals.</p>
<p>Starting with initial capital <code>init_capital</code>, for each <code>True</code> in <code>entries</code>/<code>exits</code>,
orders the number of shares specified in <code>amount</code>. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Price of the asset.</dd>
<dt><strong><code>entries</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Boolean array of entry signals.</dd>
<dt><strong><code>exits</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Boolean array of exit signals.</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>int, float</code> or <code>array_like</code></dt>
<dd>
<p>The amount of shares to order. </p>
<p>To buy/sell everything, set the amount to <code>numpy.inf</code>.</p>
</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The initial capital.</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Trading fees in percentage of the value involved.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of <code>price</code>.</dd>
</dl>
<p>All array-like arguments will be broadcasted together using <code><a title="vectorbt.utils.reshape_fns.broadcast" href="../utils/reshape_fns.html#vectorbt.utils.reshape_fns.broadcast">broadcast()</a></code>
with <code>broadcast_kwargs</code>. At the end, each time series object will have the same metadata.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no mechanism implemented to prevent order accumulation, meaning multiple entry/exit
signals one after another may increase/decrease your position in the market. That's why we will
later calculate P/L of positions instead of trades.</p>
<p>To select at most one exit signal, use <code><a title="vectorbt.signals.accessors.Signals_Accessor.first" href="../signals/accessors.html#vectorbt.signals.accessors.Signals_Accessor.first">Signals_Accessor.first()</a></code>. </p>
</div>
<h2 id="example">Example</h2>
<p>Portfolio value of various signal sequences:</p>
<pre><code class="python-repl">&gt;&gt;&gt; entries = pd.DataFrame({
...     'a': [True, False, False, False, False],
...     'b': [True, True, True, True, True],
...     'c': [True, False, True, False, True]
... }, index=index)
&gt;&gt;&gt; exits = pd.DataFrame({
...     'a': [False, False, False, False, False],
...     'b': [False, False, False, False, False],
...     'c': [False, True, False, True, False]
... }, index=index)

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(price, entries, 
...     exits, amount=10, init_capital=100, fees=0.0025)

&gt;&gt;&gt; print(portfolio.cash)
                 a       b        c
2018-01-01  89.975  89.975   89.975
2018-01-02  89.975  69.925  109.925
2018-01-03  89.975  39.850   79.850
2018-01-04  89.975  19.800   99.800
2018-01-05  89.975   9.775   89.775
&gt;&gt;&gt; print(portfolio.shares)
               a     b     c
2018-01-01  10.0  10.0  10.0
2018-01-02  10.0  20.0   0.0
2018-01-03  10.0  30.0  10.0
2018-01-04  10.0  40.0   0.0
2018-01-05  10.0  50.0  10.0
&gt;&gt;&gt; print(portfolio.equity)
                  a        b        c
2018-01-01   99.975   99.975   99.975
2018-01-02  109.975  109.925  109.925
2018-01-03  119.975  129.850  109.850
2018-01-04  109.975   99.800   99.800
2018-01-05   99.975   59.775   99.775
&gt;&gt;&gt; print(portfolio.total_costs)
a    0.025
b    0.225
c    0.225
dtype: float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_signals(cls, price, entries, exits, amount=np.inf, init_capital=None,
                 fees=None, slippage=None, broadcast_kwargs={}):
    &#34;&#34;&#34;Build portfolio from entry and exit signals.

    Starting with initial capital `init_capital`, for each `True` in `entries`/`exits`, 
    orders the number of shares specified in `amount`. 

    Args:
        price (pandas_like): Price of the asset.
        entries (pandas_like): Boolean array of entry signals.
        exits (pandas_like): Boolean array of exit signals.
        amount (int, float or array_like): The amount of shares to order. 

            To buy/sell everything, set the amount to `numpy.inf`.
        init_capital (int or float): The initial capital.
        fees (float or array_like): Trading fees in percentage of the value involved.
        slippage (float or array_like): Slippage in percentage of `price`.

    All array-like arguments will be broadcasted together using `vectorbt.utils.reshape_fns.broadcast`
    with `broadcast_kwargs`. At the end, each time series object will have the same metadata.

    !!! note
        There is no mechanism implemented to prevent order accumulation, meaning multiple entry/exit 
        signals one after another may increase/decrease your position in the market. That&#39;s why we will
        later calculate P/L of positions instead of trades.

        To select at most one exit signal, use `vectorbt.signals.accessors.Signals_Accessor.first`. 

    Example:
        Portfolio value of various signal sequences:
        ```python-repl
        &gt;&gt;&gt; entries = pd.DataFrame({
        ...     &#39;a&#39;: [True, False, False, False, False],
        ...     &#39;b&#39;: [True, True, True, True, True],
        ...     &#39;c&#39;: [True, False, True, False, True]
        ... }, index=index)
        &gt;&gt;&gt; exits = pd.DataFrame({
        ...     &#39;a&#39;: [False, False, False, False, False],
        ...     &#39;b&#39;: [False, False, False, False, False],
        ...     &#39;c&#39;: [False, True, False, True, False]
        ... }, index=index)

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(price, entries, 
        ...     exits, amount=10, init_capital=100, fees=0.0025)

        &gt;&gt;&gt; print(portfolio.cash)
                         a       b        c
        2018-01-01  89.975  89.975   89.975
        2018-01-02  89.975  69.925  109.925
        2018-01-03  89.975  39.850   79.850
        2018-01-04  89.975  19.800   99.800
        2018-01-05  89.975   9.775   89.775
        &gt;&gt;&gt; print(portfolio.shares)
                       a     b     c
        2018-01-01  10.0  10.0  10.0
        2018-01-02  10.0  20.0   0.0
        2018-01-03  10.0  30.0  10.0
        2018-01-04  10.0  40.0   0.0
        2018-01-05  10.0  50.0  10.0
        &gt;&gt;&gt; print(portfolio.equity)
                          a        b        c
        2018-01-01   99.975   99.975   99.975
        2018-01-02  109.975  109.925  109.925
        2018-01-03  119.975  129.850  109.850
        2018-01-04  109.975   99.800   99.800
        2018-01-05   99.975   59.775   99.775
        &gt;&gt;&gt; print(portfolio.total_costs)
        a    0.025
        b    0.225
        c    0.225
        dtype: float64
        ```
    &#34;&#34;&#34;
    # Get defaults
    if init_capital is None:
        init_capital = defaults.portfolio[&#39;init_capital&#39;]
    init_capital = float(init_capital)
    if fees is None:
        fees = defaults.portfolio[&#39;fees&#39;]
    if slippage is None:
        slippage = defaults.portfolio[&#39;slippage&#39;]

    # Perform checks
    checks.assert_type(price, (pd.Series, pd.DataFrame))
    checks.assert_type(entries, (pd.Series, pd.DataFrame))
    checks.assert_type(exits, (pd.Series, pd.DataFrame))
    entries.vbt.signals.validate()
    exits.vbt.signals.validate()

    # Broadcast inputs
    price, entries, exits, amount, fees, slippage = reshape_fns.broadcast(
        price, entries, exits, amount, fees, slippage, **broadcast_kwargs, writeable=True)

    # Perform calculation
    cash, shares, paid_fees, paid_slippage = nb.portfolio_nb(
        reshape_fns.to_2d(price, raw=True),
        init_capital,
        reshape_fns.to_2d(fees, raw=True),
        reshape_fns.to_2d(slippage, raw=True),
        nb.signals_order_func_nb,
        reshape_fns.to_2d(entries, raw=True),
        reshape_fns.to_2d(exits, raw=True),
        reshape_fns.to_2d(amount, raw=True))

    # Bring to the same meta
    cash = price.vbt.wrap_array(cash)
    shares = price.vbt.wrap_array(shares)
    paid_fees = price.vbt.wrap_array(paid_fees)
    paid_slippage = price.vbt.wrap_array(paid_slippage)

    return cls(price, cash, shares, init_capital, paid_fees, paid_slippage)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.portfolio.Portfolio.annual_return"><code class="name">var <span class="ident">annual_return</span></code></dt>
<dd>
<div class="desc"><p>Total annual return of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def annual_return(self):
    &#34;&#34;&#34;Total annual return of each column.&#34;&#34;&#34;
    return self.returns.vbt.timeseries.resample_apply(&#39;Y&#39;, nb.total_return_apply_func_nb)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.closed_positions"><code class="name">var <span class="ident">closed_positions</span></code></dt>
<dd>
<div class="desc"><p>Closed positions of class <code><a title="vectorbt.portfolio.portfolio.Positions" href="#vectorbt.portfolio.portfolio.Positions">Positions</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def closed_positions(self):
    &#34;&#34;&#34;Closed positions of class `Positions`.&#34;&#34;&#34;
    if not hasattr(self, &#39;_closed_positions&#39;):
        self._closed_positions = Positions(self, pos_status=nb.CLOSED)
    return self._closed_positions</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.daily_return"><code class="name">var <span class="ident">daily_return</span></code></dt>
<dd>
<div class="desc"><p>Total daily return of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def daily_return(self):
    &#34;&#34;&#34;Total daily return of each column.&#34;&#34;&#34;
    return self.returns.vbt.timeseries.resample_apply(&#39;D&#39;, nb.total_return_apply_func_nb)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.drawdown"><code class="name">var <span class="ident">drawdown</span></code></dt>
<dd>
<div class="desc"><p>Relative decline from a peak at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def drawdown(self):
    &#34;&#34;&#34;Relative decline from a peak at each time step.&#34;&#34;&#34;
    equity = self.equity.vbt.to_2d_array()
    drawdown = 1 - equity / timeseries.nb.expanding_max_nb(equity)
    return self.wrap_array(drawdown)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.equity"><code class="name">var <span class="ident">equity</span></code></dt>
<dd>
<div class="desc"><p>Portfolio value at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def equity(self):
    &#34;&#34;&#34;Portfolio value at each time step.&#34;&#34;&#34;
    equity = self.cash.vbt.to_2d_array() + self.shares.vbt.to_2d_array() * self.price.vbt.to_2d_array()
    return self.wrap_array(equity)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.has_trades"><code class="name">var <span class="ident">has_trades</span></code></dt>
<dd>
<div class="desc"><p>Whether any trades happened in each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def has_trades(self):
    &#34;&#34;&#34;Whether any trades happened in each column.&#34;&#34;&#34;
    has_trades = (self.trades.vbt.to_2d_array() &gt; 0).any(axis=0)
    return self.wrap_reduced_array(has_trades)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.max_drawdown"><code class="name">var <span class="ident">max_drawdown</span></code></dt>
<dd>
<div class="desc"><p>Total maximum drawdown (MDD) of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def max_drawdown(self):
    &#34;&#34;&#34;Total maximum drawdown (MDD) of each column.&#34;&#34;&#34;
    max_drawdown = np.max(self.drawdown.vbt.to_2d_array(), axis=0)
    return self.wrap_reduced_array(max_drawdown)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.open_positions"><code class="name">var <span class="ident">open_positions</span></code></dt>
<dd>
<div class="desc"><p>Open positions of class <code><a title="vectorbt.portfolio.portfolio.Positions" href="#vectorbt.portfolio.portfolio.Positions">Positions</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def open_positions(self):
    &#34;&#34;&#34;Open positions of class `Positions`.&#34;&#34;&#34;
    if not hasattr(self, &#39;_open_positions&#39;):
        self._open_positions = Positions(self, pos_status=nb.OPEN)
    return self._open_positions</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.positions"><code class="name">var <span class="ident">positions</span></code></dt>
<dd>
<div class="desc"><p>Open and closed positions of class <code><a title="vectorbt.portfolio.portfolio.Positions" href="#vectorbt.portfolio.portfolio.Positions">Positions</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def positions(self):
    &#34;&#34;&#34;Open and closed positions of class `Positions`.&#34;&#34;&#34;
    if not hasattr(self, &#39;_positions&#39;):
        self._positions = Positions(self, pos_status=None)
    return self._positions</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.returns"><code class="name">var <span class="ident">returns</span></code></dt>
<dd>
<div class="desc"><p>Portfolio returns at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def returns(self):
    &#34;&#34;&#34;Portfolio returns at each time step.&#34;&#34;&#34;
    returns = timeseries.nb.pct_change_nb(self.equity.vbt.to_2d_array())
    return self.wrap_array(returns)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.total_costs"><code class="name">var <span class="ident">total_costs</span></code></dt>
<dd>
<div class="desc"><p>Total costs of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def total_costs(self):
    &#34;&#34;&#34;Total costs of each column.&#34;&#34;&#34;
    total_paid_fees = reshape_fns.to_1d(self.total_paid_fees, raw=True)
    total_paid_slippage = reshape_fns.to_1d(self.total_paid_slippage, raw=True)
    total_costs = total_paid_fees + total_paid_slippage
    return self.wrap_reduced_array(total_costs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.total_paid_fees"><code class="name">var <span class="ident">total_paid_fees</span></code></dt>
<dd>
<div class="desc"><p>Total paid fees of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def total_paid_fees(self):
    &#34;&#34;&#34;Total paid fees of each column.&#34;&#34;&#34;
    total_paid_fees = np.sum(self.paid_fees.vbt.to_2d_array(), axis=0)
    return self.wrap_reduced_array(total_paid_fees)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.total_paid_slippage"><code class="name">var <span class="ident">total_paid_slippage</span></code></dt>
<dd>
<div class="desc"><p>Total paid slippage of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def total_paid_slippage(self):
    &#34;&#34;&#34;Total paid slippage of each column.&#34;&#34;&#34;
    total_paid_slippage = np.sum(self.paid_slippage.vbt.to_2d_array(), axis=0)
    return self.wrap_reduced_array(total_paid_slippage)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.total_profit"><code class="name">var <span class="ident">total_profit</span></code></dt>
<dd>
<div class="desc"><p>Total profit of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def total_profit(self):
    &#34;&#34;&#34;Total profit of each column.&#34;&#34;&#34;
    total_profit = self.equity.vbt.to_2d_array()[-1, :] - self.init_capital
    return self.wrap_reduced_array(total_profit)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.total_return"><code class="name">var <span class="ident">total_return</span></code></dt>
<dd>
<div class="desc"><p>Total return of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def total_return(self):
    &#34;&#34;&#34;Total return of each column.&#34;&#34;&#34;
    total_return = reshape_fns.to_1d(self.total_profit, raw=True) / self.init_capital
    return self.wrap_reduced_array(total_return)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.trades"><code class="name">var <span class="ident">trades</span></code></dt>
<dd>
<div class="desc"><p>Amount of shares ordered at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def trades(self):
    &#34;&#34;&#34;Amount of shares ordered at each time step.&#34;&#34;&#34;
    shares = self.shares.vbt.to_2d_array()
    trades = timeseries.nb.fillna_nb(timeseries.nb.diff_nb(shares), 0)
    trades[0, :] = shares[0, :]
    return self.wrap_array(trades)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.portfolio.portfolio.Portfolio.plot_trades"><code class="name flex">
<span>def <span class="ident">plot_trades</span></span>(<span>self, buy_trace_kwargs={}, sell_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot trades as markers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>buy_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> for "Buy" markers.</dd>
<dt><strong><code>sell_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <a href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html"><code>plotly.graph_objects.Scatter</code></a> for "Sell" markers.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="py">vbt.Portfolio.from_orders(price, price.diff(), init_capital=100).plot_trades()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/portfolio_plot_trades.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_trades(self,
                buy_trace_kwargs={},
                sell_trace_kwargs={},
                fig=None,
                **layout_kwargs):
    &#34;&#34;&#34;Plot trades as markers.

    Args:
        buy_trace_kwargs (dict): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for &#34;Buy&#34; markers.
        sell_trace_kwargs (dict): Keyword arguments passed to [`plotly.graph_objects.Scatter`](https://plotly.com/python-api-reference/generated/plotly.graph_objects.Scatter.html) for &#34;Sell&#34; markers.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Example:
        ```py
        vbt.Portfolio.from_orders(price, price.diff(), init_capital=100).plot_trades()
        ```

        ![](/vectorbt/docs/img/portfolio_plot_trades.png)&#34;&#34;&#34;
    checks.assert_type(self.price, pd.Series)
    checks.assert_type(self.trades, pd.Series)
    sell_mask = self.trades &lt; 0
    buy_mask = self.trades &gt; 0

    # Plot time series
    fig = self.price.vbt.timeseries.plot(fig=fig, **layout_kwargs)
    # Plot markers
    buy_trace_kwargs = common.merge_kwargs(dict(
        customdata=self.trades[buy_mask],
        hovertemplate=&#39;(%{x}, %{y})&lt;br&gt;%{customdata:.6g}&#39;,
        marker=dict(
            symbol=&#39;triangle-up&#39;,
            color=&#39;limegreen&#39;
        )
    ), buy_trace_kwargs)
    buy_mask.vbt.signals.plot_markers(
        self.price, name=&#39;Buy&#39;, trace_kwargs=buy_trace_kwargs, fig=fig, **layout_kwargs)
    sell_trace_kwargs = common.merge_kwargs(dict(
        customdata=self.trades[sell_mask],
        hovertemplate=&#39;(%{x}, %{y})&lt;br&gt;%{customdata:.6g}&#39;,
        marker=dict(
            symbol=&#39;triangle-down&#39;,
            color=&#39;orangered&#39;
        )
    ), sell_trace_kwargs)
    sell_mask.vbt.signals.plot_markers(
        self.price, name=&#39;Sell&#39;, trace_kwargs=sell_trace_kwargs, fig=fig, **layout_kwargs)
    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Portfolio.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.portfolio.portfolio.ArrayWrapper" href="#vectorbt.portfolio.portfolio.ArrayWrapper">ArrayWrapper</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.portfolio.portfolio.ArrayWrapper.wrap_array" href="#vectorbt.portfolio.portfolio.ArrayWrapper.wrap_array">wrap_array</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.ArrayWrapper.wrap_reduced_array" href="#vectorbt.portfolio.portfolio.ArrayWrapper.wrap_reduced_array">wrap_reduced_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.portfolio.portfolio.Positions"><code class="flex name class">
<span>class <span class="ident">Positions</span></span>
<span>(</span><span>portfolio, pos_status=None, pos_filters=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code><a title="vectorbt.portfolio.portfolio.BasePositions" href="#vectorbt.portfolio.portfolio.BasePositions">BasePositions</a></code> by combining various profit/loss metrics.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Positions(BasePositions):
    &#34;&#34;&#34;Extends `BasePositions` by combining various profit/loss metrics.&#34;&#34;&#34;

    @property
    def winning(self):
        &#34;&#34;&#34;Winning positions of class `BasePositions`.&#34;&#34;&#34;
        if not hasattr(self, &#39;_winning&#39;):
            self._winning = BasePositions(
                self.portfolio,
                pos_status=self.pos_status,
                pos_filters=[*self.pos_filters, (nb.winning_filter_func_nb, self.pnl.vbt.to_2d_array())])
        return self._winning

    @property
    def losing(self):
        &#34;&#34;&#34;Losing positions of class `BasePositions`.&#34;&#34;&#34;
        if not hasattr(self, &#39;_losing&#39;):
            self._losing = BasePositions(
                self.portfolio,
                pos_status=self.pos_status,
                pos_filters=[*self.pos_filters, (nb.losing_filter_func_nb, self.pnl.vbt.to_2d_array())])
        return self._losing

    @cached_property
    def win_rate(self):
        &#34;&#34;&#34;How many positions won in each column.&#34;&#34;&#34;
        winning_count = reshape_fns.to_1d(self.winning.count, raw=True)
        count = reshape_fns.to_1d(self.count, raw=True)

        win_rate = winning_count / count
        return self.wrap_reduced_array(win_rate)

    @cached_property
    def loss_rate(self):
        &#34;&#34;&#34;How many positions lost in each column.&#34;&#34;&#34;
        losing_count = reshape_fns.to_1d(self.losing.count, raw=True)
        count = reshape_fns.to_1d(self.count, raw=True)

        loss_rate = losing_count / count
        return self.wrap_reduced_array(loss_rate)

    @cached_property
    def profit_factor(self):
        &#34;&#34;&#34;Profit factor of each column.&#34;&#34;&#34;
        total_win = reshape_fns.to_1d(self.winning.total_pnl, raw=True)
        total_loss = reshape_fns.to_1d(self.losing.total_pnl, raw=True)

        # Otherwise columns with only wins or losses will become NaNs
        has_trades = reshape_fns.to_1d(self.portfolio.has_trades, raw=True)
        total_win[np.isnan(total_win) &amp; has_trades] = 0.
        total_loss[np.isnan(total_loss) &amp; has_trades] = 0.

        profit_factor = total_win / np.abs(total_loss)
        return self.wrap_reduced_array(profit_factor)

    @cached_property
    def expectancy(self):
        &#34;&#34;&#34;Average profitability per trade (APPT) of each column.&#34;&#34;&#34;
        win_rate = reshape_fns.to_1d(self.win_rate, raw=True)
        loss_rate = reshape_fns.to_1d(self.loss_rate, raw=True)
        avg_win = reshape_fns.to_1d(self.winning.avg_pnl, raw=True)
        avg_loss = reshape_fns.to_1d(self.losing.avg_pnl, raw=True)

        # Otherwise columns with only wins or losses will become NaNs
        has_trades = reshape_fns.to_1d(self.portfolio.has_trades, raw=True)
        avg_win[np.isnan(avg_win) &amp; has_trades] = 0.
        avg_loss[np.isnan(avg_loss) &amp; has_trades] = 0.

        expectancy = win_rate * avg_win - loss_rate * np.abs(avg_loss)
        return self.wrap_reduced_array(expectancy)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.portfolio.BasePositions" href="#vectorbt.portfolio.portfolio.BasePositions">BasePositions</a></li>
<li><a title="vectorbt.portfolio.portfolio.ArrayWrapper" href="#vectorbt.portfolio.portfolio.ArrayWrapper">ArrayWrapper</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.portfolio.Positions.expectancy"><code class="name">var <span class="ident">expectancy</span></code></dt>
<dd>
<div class="desc"><p>Average profitability per trade (APPT) of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def expectancy(self):
    &#34;&#34;&#34;Average profitability per trade (APPT) of each column.&#34;&#34;&#34;
    win_rate = reshape_fns.to_1d(self.win_rate, raw=True)
    loss_rate = reshape_fns.to_1d(self.loss_rate, raw=True)
    avg_win = reshape_fns.to_1d(self.winning.avg_pnl, raw=True)
    avg_loss = reshape_fns.to_1d(self.losing.avg_pnl, raw=True)

    # Otherwise columns with only wins or losses will become NaNs
    has_trades = reshape_fns.to_1d(self.portfolio.has_trades, raw=True)
    avg_win[np.isnan(avg_win) &amp; has_trades] = 0.
    avg_loss[np.isnan(avg_loss) &amp; has_trades] = 0.

    expectancy = win_rate * avg_win - loss_rate * np.abs(avg_loss)
    return self.wrap_reduced_array(expectancy)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Positions.losing"><code class="name">var <span class="ident">losing</span></code></dt>
<dd>
<div class="desc"><p>Losing positions of class <code><a title="vectorbt.portfolio.portfolio.BasePositions" href="#vectorbt.portfolio.portfolio.BasePositions">BasePositions</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def losing(self):
    &#34;&#34;&#34;Losing positions of class `BasePositions`.&#34;&#34;&#34;
    if not hasattr(self, &#39;_losing&#39;):
        self._losing = BasePositions(
            self.portfolio,
            pos_status=self.pos_status,
            pos_filters=[*self.pos_filters, (nb.losing_filter_func_nb, self.pnl.vbt.to_2d_array())])
    return self._losing</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Positions.loss_rate"><code class="name">var <span class="ident">loss_rate</span></code></dt>
<dd>
<div class="desc"><p>How many positions lost in each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def loss_rate(self):
    &#34;&#34;&#34;How many positions lost in each column.&#34;&#34;&#34;
    losing_count = reshape_fns.to_1d(self.losing.count, raw=True)
    count = reshape_fns.to_1d(self.count, raw=True)

    loss_rate = losing_count / count
    return self.wrap_reduced_array(loss_rate)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Positions.profit_factor"><code class="name">var <span class="ident">profit_factor</span></code></dt>
<dd>
<div class="desc"><p>Profit factor of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def profit_factor(self):
    &#34;&#34;&#34;Profit factor of each column.&#34;&#34;&#34;
    total_win = reshape_fns.to_1d(self.winning.total_pnl, raw=True)
    total_loss = reshape_fns.to_1d(self.losing.total_pnl, raw=True)

    # Otherwise columns with only wins or losses will become NaNs
    has_trades = reshape_fns.to_1d(self.portfolio.has_trades, raw=True)
    total_win[np.isnan(total_win) &amp; has_trades] = 0.
    total_loss[np.isnan(total_loss) &amp; has_trades] = 0.

    profit_factor = total_win / np.abs(total_loss)
    return self.wrap_reduced_array(profit_factor)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Positions.win_rate"><code class="name">var <span class="ident">win_rate</span></code></dt>
<dd>
<div class="desc"><p>How many positions won in each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def win_rate(self):
    &#34;&#34;&#34;How many positions won in each column.&#34;&#34;&#34;
    winning_count = reshape_fns.to_1d(self.winning.count, raw=True)
    count = reshape_fns.to_1d(self.count, raw=True)

    win_rate = winning_count / count
    return self.wrap_reduced_array(win_rate)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.portfolio.Positions.winning"><code class="name">var <span class="ident">winning</span></code></dt>
<dd>
<div class="desc"><p>Winning positions of class <code><a title="vectorbt.portfolio.portfolio.BasePositions" href="#vectorbt.portfolio.portfolio.BasePositions">BasePositions</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def winning(self):
    &#34;&#34;&#34;Winning positions of class `BasePositions`.&#34;&#34;&#34;
    if not hasattr(self, &#39;_winning&#39;):
        self._winning = BasePositions(
            self.portfolio,
            pos_status=self.pos_status,
            pos_filters=[*self.pos_filters, (nb.winning_filter_func_nb, self.pnl.vbt.to_2d_array())])
    return self._winning</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.portfolio.portfolio.BasePositions" href="#vectorbt.portfolio.portfolio.BasePositions">BasePositions</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.apply_mapper" href="#vectorbt.portfolio.portfolio.BasePositions.apply_mapper">apply_mapper</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.avg_duration" href="#vectorbt.portfolio.portfolio.BasePositions.avg_duration">avg_duration</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.avg_pnl" href="#vectorbt.portfolio.portfolio.BasePositions.avg_pnl">avg_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.avg_return" href="#vectorbt.portfolio.portfolio.BasePositions.avg_return">avg_return</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.count" href="#vectorbt.portfolio.portfolio.BasePositions.count">count</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.duration" href="#vectorbt.portfolio.portfolio.BasePositions.duration">duration</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.max_duration" href="#vectorbt.portfolio.portfolio.BasePositions.max_duration">max_duration</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.max_pnl" href="#vectorbt.portfolio.portfolio.BasePositions.max_pnl">max_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.max_return" href="#vectorbt.portfolio.portfolio.BasePositions.max_return">max_return</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.min_duration" href="#vectorbt.portfolio.portfolio.BasePositions.min_duration">min_duration</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.min_pnl" href="#vectorbt.portfolio.portfolio.BasePositions.min_pnl">min_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.min_return" href="#vectorbt.portfolio.portfolio.BasePositions.min_return">min_return</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.plot_pnl" href="#vectorbt.portfolio.portfolio.BasePositions.plot_pnl">plot_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.plot_returns" href="#vectorbt.portfolio.portfolio.BasePositions.plot_returns">plot_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.pnl" href="#vectorbt.portfolio.portfolio.BasePositions.pnl">pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.returns" href="#vectorbt.portfolio.portfolio.BasePositions.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.status" href="#vectorbt.portfolio.portfolio.BasePositions.status">status</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.total_duration" href="#vectorbt.portfolio.portfolio.BasePositions.total_duration">total_duration</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.total_pnl" href="#vectorbt.portfolio.portfolio.BasePositions.total_pnl">total_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.wrap_array" href="#vectorbt.portfolio.portfolio.ArrayWrapper.wrap_array">wrap_array</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.wrap_reduced_array" href="#vectorbt.portfolio.portfolio.ArrayWrapper.wrap_reduced_array">wrap_reduced_array</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.portfolio" href="index.html">vectorbt.portfolio</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.portfolio.portfolio.portfolio_indexing_func" href="#vectorbt.portfolio.portfolio.portfolio_indexing_func">portfolio_indexing_func</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.portfolio.portfolio.ArrayWrapper" href="#vectorbt.portfolio.portfolio.ArrayWrapper">ArrayWrapper</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.portfolio.portfolio.ArrayWrapper.wrap_array" href="#vectorbt.portfolio.portfolio.ArrayWrapper.wrap_array">wrap_array</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.ArrayWrapper.wrap_reduced_array" href="#vectorbt.portfolio.portfolio.ArrayWrapper.wrap_reduced_array">wrap_reduced_array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.portfolio.portfolio.BasePositions" href="#vectorbt.portfolio.portfolio.BasePositions">BasePositions</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.apply_mapper" href="#vectorbt.portfolio.portfolio.BasePositions.apply_mapper">apply_mapper</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.avg_duration" href="#vectorbt.portfolio.portfolio.BasePositions.avg_duration">avg_duration</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.avg_pnl" href="#vectorbt.portfolio.portfolio.BasePositions.avg_pnl">avg_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.avg_return" href="#vectorbt.portfolio.portfolio.BasePositions.avg_return">avg_return</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.count" href="#vectorbt.portfolio.portfolio.BasePositions.count">count</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.duration" href="#vectorbt.portfolio.portfolio.BasePositions.duration">duration</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.max_duration" href="#vectorbt.portfolio.portfolio.BasePositions.max_duration">max_duration</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.max_pnl" href="#vectorbt.portfolio.portfolio.BasePositions.max_pnl">max_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.max_return" href="#vectorbt.portfolio.portfolio.BasePositions.max_return">max_return</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.min_duration" href="#vectorbt.portfolio.portfolio.BasePositions.min_duration">min_duration</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.min_pnl" href="#vectorbt.portfolio.portfolio.BasePositions.min_pnl">min_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.min_return" href="#vectorbt.portfolio.portfolio.BasePositions.min_return">min_return</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.plot_pnl" href="#vectorbt.portfolio.portfolio.BasePositions.plot_pnl">plot_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.plot_returns" href="#vectorbt.portfolio.portfolio.BasePositions.plot_returns">plot_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.pnl" href="#vectorbt.portfolio.portfolio.BasePositions.pnl">pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.returns" href="#vectorbt.portfolio.portfolio.BasePositions.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.status" href="#vectorbt.portfolio.portfolio.BasePositions.status">status</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.total_duration" href="#vectorbt.portfolio.portfolio.BasePositions.total_duration">total_duration</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.BasePositions.total_pnl" href="#vectorbt.portfolio.portfolio.BasePositions.total_pnl">total_pnl</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.portfolio.portfolio.Portfolio" href="#vectorbt.portfolio.portfolio.Portfolio">Portfolio</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.annual_return" href="#vectorbt.portfolio.portfolio.Portfolio.annual_return">annual_return</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.closed_positions" href="#vectorbt.portfolio.portfolio.Portfolio.closed_positions">closed_positions</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.daily_return" href="#vectorbt.portfolio.portfolio.Portfolio.daily_return">daily_return</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.drawdown" href="#vectorbt.portfolio.portfolio.Portfolio.drawdown">drawdown</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.equity" href="#vectorbt.portfolio.portfolio.Portfolio.equity">equity</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.from_order_func" href="#vectorbt.portfolio.portfolio.Portfolio.from_order_func">from_order_func</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.from_orders" href="#vectorbt.portfolio.portfolio.Portfolio.from_orders">from_orders</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.from_signals" href="#vectorbt.portfolio.portfolio.Portfolio.from_signals">from_signals</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.has_trades" href="#vectorbt.portfolio.portfolio.Portfolio.has_trades">has_trades</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.iloc" href="#vectorbt.portfolio.portfolio.Portfolio.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.loc" href="#vectorbt.portfolio.portfolio.Portfolio.loc">loc</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.max_drawdown" href="#vectorbt.portfolio.portfolio.Portfolio.max_drawdown">max_drawdown</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.open_positions" href="#vectorbt.portfolio.portfolio.Portfolio.open_positions">open_positions</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.plot_trades" href="#vectorbt.portfolio.portfolio.Portfolio.plot_trades">plot_trades</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.positions" href="#vectorbt.portfolio.portfolio.Portfolio.positions">positions</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.returns" href="#vectorbt.portfolio.portfolio.Portfolio.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.total_costs" href="#vectorbt.portfolio.portfolio.Portfolio.total_costs">total_costs</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.total_paid_fees" href="#vectorbt.portfolio.portfolio.Portfolio.total_paid_fees">total_paid_fees</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.total_paid_slippage" href="#vectorbt.portfolio.portfolio.Portfolio.total_paid_slippage">total_paid_slippage</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.total_profit" href="#vectorbt.portfolio.portfolio.Portfolio.total_profit">total_profit</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.total_return" href="#vectorbt.portfolio.portfolio.Portfolio.total_return">total_return</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.trades" href="#vectorbt.portfolio.portfolio.Portfolio.trades">trades</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Portfolio.xs" href="#vectorbt.portfolio.portfolio.Portfolio.xs">xs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.portfolio.portfolio.Positions" href="#vectorbt.portfolio.portfolio.Positions">Positions</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.portfolio.portfolio.Positions.expectancy" href="#vectorbt.portfolio.portfolio.Positions.expectancy">expectancy</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Positions.losing" href="#vectorbt.portfolio.portfolio.Positions.losing">losing</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Positions.loss_rate" href="#vectorbt.portfolio.portfolio.Positions.loss_rate">loss_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Positions.profit_factor" href="#vectorbt.portfolio.portfolio.Positions.profit_factor">profit_factor</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Positions.win_rate" href="#vectorbt.portfolio.portfolio.Positions.win_rate">win_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.portfolio.Positions.winning" href="#vectorbt.portfolio.portfolio.Positions.winning">winning</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>