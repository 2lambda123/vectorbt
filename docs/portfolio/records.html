<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.portfolio.records API documentation</title>
<meta name="description" content="Classes for working with records â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://github.com/polakowo/vectorbt/blob/master/logo.png?raw=true">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.portfolio.records</code></h1>
</header>
<section id="section-intro">
<p>Classes for working with records.</p>
<p>Information on orders, trades and positions can be quite rich. For example, each position has
size, opening and closing price, PnL, return, and more. Instead of creating a bunch of
large matrices to hold this information (with most elements being NaN anyway), we will store
this information as records.</p>
<p>Records is just an array of arrays of fixed schema (= 2-dim NumPy array) holding some information.
You can imagine records being a DataFrame, where each row represents a record and each
column represents a specific type of information. For example, <code><a title="vectorbt.portfolio.enums.OrderRecord" href="enums.html#vectorbt.portfolio.enums.OrderRecord">OrderRecord</a></code>
defines the layout for order records, that is, shows at which column index to find what kind of
information:</p>
<pre><code class="plaintext">OrderRecord(Column=0, Index=1, Size=2, Price=3, Fees=4, Side=5)
          +
[[0. 0. 1. 1. 0. 0.]
 [0. 1. 1. 2. 0. 0.]
 [0. 2. 1. 3. 0. 0.]
 [0. 3. 1. 2. 0. 0.]
 [0. 4. 1. 1. 0. 1.]]
          |
          v
   Column  Index  Size  Price  Fees  Side
0     0.0    0.0   1.0    1.0   0.0   0.0
1     0.0    1.0   1.0    2.0   0.0   0.0
2     0.0    2.0   1.0    3.0   0.0   0.0
3     0.0    3.0   1.0    2.0   0.0   0.0
4     0.0    4.0   1.0    1.0   0.0   1.0
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since records are stored as a single NumPy array, all columns are casted to a single
data type - mostly <code>numpy.float64</code>.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Classes for working with records.

Information on orders, trades and positions can be quite rich. For example, each position has
size, opening and closing price, PnL, return, and more. Instead of creating a bunch of
large matrices to hold this information (with most elements being NaN anyway), we will store 
this information as records.

Records is just an array of arrays of fixed schema (= 2-dim NumPy array) holding some information.
You can imagine records being a DataFrame, where each row represents a record and each 
column represents a specific type of information. For example, `vectorbt.portfolio.enums.OrderRecord` 
defines the layout for order records, that is, shows at which column index to find what kind of
information:

```plaintext
OrderRecord(Column=0, Index=1, Size=2, Price=3, Fees=4, Side=5)
          +
[[0. 0. 1. 1. 0. 0.]
 [0. 1. 1. 2. 0. 0.]
 [0. 2. 1. 3. 0. 0.]
 [0. 3. 1. 2. 0. 0.]
 [0. 4. 1. 1. 0. 1.]]
          |
          v
   Column  Index  Size  Price  Fees  Side
0     0.0    0.0   1.0    1.0   0.0   0.0
1     0.0    1.0   1.0    2.0   0.0   0.0
2     0.0    2.0   1.0    3.0   0.0   0.0
3     0.0    3.0   1.0    2.0   0.0   0.0
4     0.0    4.0   1.0    1.0   0.0   1.0
```

!!! note
    Since records are stored as a single NumPy array, all columns are casted to a single 
    data type - mostly `numpy.float64`.&#34;&#34;&#34;

import numpy as np
import pandas as pd

from vectorbt.utils import checks, reshape_fns
from vectorbt import timeseries
from vectorbt.portfolio import nb
from vectorbt.portfolio.common import (
    TSRArrayWrapper,
    timeseries_property, 
    metric_property, 
    records_property,
    group_property
)
from vectorbt.portfolio.enums import (
    OrderRecord, 
    OrderSide, 
    EventRecord, 
    TradeRecord, 
    PositionRecord, 
    PositionStatus
)

class Records():
    &#34;&#34;&#34;Exposes methods and properties for working with any records.

    This class doesn&#39;t hold any data, but creates a read-only view over records.
    Except that all time series and metric properties are cached.

    Args:
        wrapper (TSRArrayWrapper): Array wrapper of type `vectorbt.portfolio.common.TSRArrayWrapper`.
        records (np.ndarray): An array of records.
        layout: An instance of a `namedtuple` class that acts as a layout for the records.
        col_field (int): Field index representing a column index.
        row_field (int): Field index representing a row index.&#34;&#34;&#34;

    def __init__(self, wrapper, records, layout, col_field, row_field):
        checks.assert_type(records, np.ndarray)
        checks.assert_same_shape(records, layout, axis=(1, 0))

        self.wrapper = wrapper
        self._records = records
        self.layout = layout
        self.col_field = col_field
        self.row_field = row_field

    @records_property(&#39;Records&#39;)
    def records(self):
        &#34;&#34;&#34;Records.&#34;&#34;&#34;
        return self.wrapper.wrap_records(self._records, self.layout)

    def map_records_to_matrix(self, map_func_nb, *args):
        &#34;&#34;&#34;Map each record to a value that is then stored in a matrix.
        
        See `vectorbt.portfolio.nb.map_records_to_matrix_nb`.&#34;&#34;&#34;
        checks.assert_numba_func(map_func_nb)

        return self.wrapper.wrap(
            nb.map_records_to_matrix_nb(
                self._records,
                (len(self.wrapper.index), len(self.wrapper.columns)),
                self.col_field,
                self.row_field,
                map_func_nb,
                *args))

    def reduce_records(self, reduce_func_nb, *args):
        &#34;&#34;&#34;Perform a reducing operation over the records of each column.
        
        See `vectorbt.portfolio.nb.reduce_records_nb`.&#34;&#34;&#34;
        checks.assert_numba_func(reduce_func_nb)

        return self.wrapper.wrap_reduced(
            nb.reduce_records_nb(
                self._records,
                len(self.wrapper.columns),
                self.col_field,
                reduce_func_nb,
                *args))

    @metric_property(&#39;Total count&#39;)
    def count(self):
        &#34;&#34;&#34;Total count of all events.&#34;&#34;&#34;
        return self.reduce_records(nb.count_reduce_func_nb)


class BaseEvents(Records):
    &#34;&#34;&#34;Extends `Records` for working with event records.&#34;&#34;&#34;

    def __init__(self, wrapper, records, layout=EventRecord):
        checks.assert_same(EventRecord._fields, layout._fields[:len(EventRecord)])  # subtype of EventRecord

        super().__init__(wrapper, records, layout, EventRecord.Column, EventRecord.CloseAt)

    # ############# Duration ############# #

    @timeseries_property(&#39;Duration&#39;)
    def duration(self):
        &#34;&#34;&#34;Duration of each event (in raw format).&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.duration_map_func_nb)

    @metric_property(&#39;Average duration&#39;)
    def avg_duration(self):
        &#34;&#34;&#34;Average duration of an event (in time units).&#34;&#34;&#34;
        return self.duration.vbt.timeseries.mean(time_units=True)

    # ############# PnL ############# #

    @timeseries_property(&#39;PnL&#39;)
    def pnl(self):
        &#34;&#34;&#34;PnL of each event.&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.field_map_func_nb, EventRecord.PnL)

    @metric_property(&#39;Total PnL&#39;)
    def total_pnl(self):
        &#34;&#34;&#34;Total PnL of all events.&#34;&#34;&#34;
        return self.pnl.vbt.timeseries.sum()

    @metric_property(&#39;Average PnL&#39;)
    def avg_pnl(self):
        &#34;&#34;&#34;Average PnL of an event.&#34;&#34;&#34;
        return self.pnl.vbt.timeseries.mean()

    def plot_pnl(self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs):
        &#34;&#34;&#34;Plot PnL of each event as markers.

        Args:
            profit_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Profit&#34; markers.
            loss_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Loss&#34; markers.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.&#34;&#34;&#34;
        checks.assert_type(self.pnl, pd.Series)

        above_trace_kwargs = {**dict(name=&#39;Profit&#39;), **profit_trace_kwargs}
        below_trace_kwargs = {**dict(name=&#39;Loss&#39;), **loss_trace_kwargs}
        return self.pnl.vbt.timeseries.plot_against(0, above_trace_kwargs=above_trace_kwargs, below_trace_kwargs=below_trace_kwargs)

    # ############# Returns ############# #

    @timeseries_property(&#39;Returns&#39;)
    def returns(self):
        &#34;&#34;&#34;Return of each event.&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.field_map_func_nb, EventRecord.Return)

    @metric_property(&#39;Average return&#39;)
    def avg_return(self):
        &#34;&#34;&#34;Average return of an event.&#34;&#34;&#34;
        return self.returns.vbt.timeseries.mean()

    def plot_returns(self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs):
        &#34;&#34;&#34;Plot return of each event as a marker.

        See `BaseEvents.plot_pnl`.&#34;&#34;&#34;
        checks.assert_type(self.pnl, pd.Series)

        above_trace_kwargs = {**dict(name=&#39;Profit&#39;), **profit_trace_kwargs}
        below_trace_kwargs = {**dict(name=&#39;Loss&#39;), **loss_trace_kwargs}
        return self.returns.vbt.timeseries.plot_against(0, above_trace_kwargs=above_trace_kwargs, below_trace_kwargs=below_trace_kwargs)


class Events(BaseEvents):
    &#34;&#34;&#34;Extends `BaseEvents` by further dividing events into winning and losing.&#34;&#34;&#34;

    @group_property(&#39;Winning&#39;, BaseEvents)
    def winning(self):
        &#34;&#34;&#34;Winning events of type `BaseEvents`.&#34;&#34;&#34;
        filter_mask = self._records[:, EventRecord.PnL] &gt; 0.
        return BaseEvents(self.wrapper, self._records[filter_mask, :], layout=self.layout)

    @group_property(&#39;Losing&#39;, BaseEvents)
    def losing(self):
        &#34;&#34;&#34;Losing events of type `BaseEvents`.&#34;&#34;&#34;
        filter_mask = self._records[:, EventRecord.PnL] &lt; 0.
        return BaseEvents(self.wrapper, self._records[filter_mask, :], layout=self.layout)

    @metric_property(&#39;Win rate&#39;)
    def win_rate(self):
        &#34;&#34;&#34;Rate of profitable events.&#34;&#34;&#34;
        winning_count = reshape_fns.to_1d(self.winning.count, raw=True)
        count = reshape_fns.to_1d(self.count, raw=True)

        win_rate = winning_count / count
        return self.wrapper.wrap_reduced(win_rate)

    @metric_property(&#39;Profit factor&#39;)
    def profit_factor(self):
        &#34;&#34;&#34;Profit factor.&#34;&#34;&#34;
        total_win = reshape_fns.to_1d(self.winning.total_pnl, raw=True)
        total_loss = reshape_fns.to_1d(self.losing.total_pnl, raw=True)

        # Otherwise columns with only wins or losses will become NaNs
        has_values = reshape_fns.to_1d(self.count, raw=True) &gt; 0
        total_win[np.isnan(total_win) &amp; has_values] = 0.
        total_loss[np.isnan(total_loss) &amp; has_values] = 0.

        profit_factor = total_win / np.abs(total_loss)
        return self.wrapper.wrap_reduced(profit_factor)

    @metric_property(&#39;Expectancy&#39;)
    def expectancy(self):
        &#34;&#34;&#34;Average profitability.&#34;&#34;&#34;
        win_rate = reshape_fns.to_1d(self.win_rate, raw=True)
        avg_win = reshape_fns.to_1d(self.winning.avg_pnl, raw=True)
        avg_loss = reshape_fns.to_1d(self.losing.avg_pnl, raw=True)

        # Otherwise columns with only wins or losses will become NaNs
        has_values = reshape_fns.to_1d(self.count, raw=True) &gt; 0
        avg_win[np.isnan(avg_win) &amp; has_values] = 0.
        avg_loss[np.isnan(avg_loss) &amp; has_values] = 0.

        expectancy = win_rate * avg_win - (1 - win_rate) * np.abs(avg_loss)
        return self.wrapper.wrap_reduced(expectancy)


class BaseOrders(Records):
    &#34;&#34;&#34;Extends `Records` for working with order records.

    Requires records of type `vectorbt.portfolio.enums.OrderRecord`.
    
    Example:
        Get the total number of buy and sell operations:
        ```python-repl
        &gt;&gt;&gt; import vectorbt as vbt
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.portfolio.records import Orders
        &gt;&gt;&gt; from vectorbt.portfolio.enums import OrderSide, OrderRecord as OR

        &gt;&gt;&gt; price = pd.Series([1, 2, 3, 2, 1])
        &gt;&gt;&gt; orders = pd.Series([1, 1, 1, 1, -1])
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
        ...      init_capital=100, data_freq=&#39;1D&#39;)

        &gt;&gt;&gt; print(portfolio.orders.buy.count)
        4.0
        &gt;&gt;&gt; print(portfolio.orders.sell.count)
        1.0
        ```&#34;&#34;&#34;
    def __init__(self, wrapper, records):
        super().__init__(wrapper, records, OrderRecord, OrderRecord.Column, OrderRecord.Index)

    @timeseries_property(&#39;Size&#39;)
    def size(self):
        &#34;&#34;&#34;Size of each order.&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.field_map_func_nb, OrderRecord.Size)

    @timeseries_property(&#39;Price&#39;)
    def price(self):
        &#34;&#34;&#34;Price of each order.&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.field_map_func_nb, OrderRecord.Price)

    @timeseries_property(&#39;Fees&#39;)
    def fees(self):
        &#34;&#34;&#34;Fees of each order.&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.field_map_func_nb, OrderRecord.Fees)

    @metric_property(&#39;Total fees&#39;)
    def total_fees(self):
        &#34;&#34;&#34;Total fees of all orders.&#34;&#34;&#34;
        return self.fees.vbt.timeseries.sum()


class Orders(BaseOrders):
    &#34;&#34;&#34;Extends `BaseOrders` by further dividing orders into buy and sell orders.&#34;&#34;&#34;

    @timeseries_property(&#39;Side&#39;)
    def side(self):
        &#34;&#34;&#34;Side of each order.
        
        See `vectorbt.portfolio.enums.OrderSide`.&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.field_map_func_nb, OrderRecord.Side)

    @group_property(&#39;Buy&#39;, BaseOrders)
    def buy(self):
        &#34;&#34;&#34;Buy operations of type `BaseOrders`.&#34;&#34;&#34;
        filter_mask = self._records[:, OrderRecord.Side] == OrderSide.Buy
        return BaseOrders(self.wrapper, self._records[filter_mask, :])

    @group_property(&#39;Sell&#39;, BaseOrders)
    def sell(self):
        &#34;&#34;&#34;Sell operations of type `BaseOrders`.&#34;&#34;&#34;
        filter_mask = self._records[:, OrderRecord.Side] == OrderSide.Sell
        return BaseOrders(self.wrapper, self._records[filter_mask, :])



class Trades(Events):
    &#34;&#34;&#34;Extends `Events` for working with trade records.

    Requires records of type `vectorbt.portfolio.enums.TradeRecord`.
    Such records can be created by using `vectorbt.portfolio.nb.trade_records_nb`.
    
    Example:
        Get the average PnL of trades with duration over 2 days:
        ```python-repl
        &gt;&gt;&gt; import vectorbt as vbt
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.portfolio.records import Trades
        &gt;&gt;&gt; from vectorbt.portfolio.enums import TradeRecord as TR

        &gt;&gt;&gt; price = pd.Series([1, 2, 3, 2, 1])
        &gt;&gt;&gt; orders = pd.Series([1, -1, 1, 0, -1])
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
        ...      init_capital=100, data_freq=&#39;1D&#39;)
        &gt;&gt;&gt; print(portfolio.trades.avg_pnl)
        -0.5

        &gt;&gt;&gt; records = portfolio.trade_records.values
        &gt;&gt;&gt; duration_mask = (records[:, TR.CloseAt] - records[:, TR.OpenAt]) &gt;= 2.
        &gt;&gt;&gt; filtered_records = records[duration_mask, :]
        &gt;&gt;&gt; trades = Trades(portfolio.wrapper, filtered_records)
        &gt;&gt;&gt; print(trades.avg_pnl)
        -2.0
        ```
        
        The same can be done by using `BaseEvents.reduce_records`, 
        which skips the step of transforming records into a matrix and thus saves memory.
        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from numba import njit

        &gt;&gt;&gt; @njit
        ... def reduce_func_nb(col_rs):
        ...     duration_mask = col_rs[:, TR.CloseAt] - col_rs[:, TR.OpenAt] &gt;= 2.
        ...     return np.nanmean(col_rs[duration_mask, TR.PnL])

        &gt;&gt;&gt; portfolio.trades.reduce_records(reduce_func_nb)
        -2.0
        ```&#34;&#34;&#34;

    def __init__(self, wrapper, records):
        super().__init__(wrapper, records, layout=TradeRecord)


class Positions(Events):
    &#34;&#34;&#34;Extends `Events` for working with position records.

    Requires records of type `vectorbt.portfolio.enums.PositionRecord`.
    Such records can be created by using `vectorbt.portfolio.nb.position_records_nb`.

    Example:
        Get the average PnL of closed positions with duration over 2 days:
        ```python-repl
        &gt;&gt;&gt; import vectorbt as vbt
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.portfolio.records import Positions
        &gt;&gt;&gt; from vectorbt.portfolio.enums import PositionStatus, PositionRecord as PR

        &gt;&gt;&gt; price = pd.Series([1, 2, 3, 2, 1])
        &gt;&gt;&gt; orders = pd.Series([1, -1, 1, 0, -1])
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
        ...      init_capital=100, data_freq=&#39;1D&#39;)
        &gt;&gt;&gt; print(portfolio.positions.avg_pnl)
        -0.5
        
        &gt;&gt;&gt; records = portfolio.position_records.values
        &gt;&gt;&gt; closed_mask = records[:, PR.Status] == PositionStatus.Closed
        &gt;&gt;&gt; duration_mask = (records[:, PR.CloseAt] - records[:, PR.OpenAt]) &gt;= 2.
        &gt;&gt;&gt; filtered_records = records[closed_mask &amp; duration_mask, :]
        &gt;&gt;&gt; positions = Positions(portfolio.wrapper, filtered_records)
        &gt;&gt;&gt; print(positions.avg_pnl)
        -2.0
        ```&#34;&#34;&#34;

    def __init__(self, wrapper, records):
        super().__init__(wrapper, records, layout=PositionRecord)

    @timeseries_property(&#39;Status&#39;)
    def status(self):
        &#34;&#34;&#34;See `vectorbt.portfolio.enums.PositionStatus`.&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.field_map_func_nb, PositionRecord.Status)

    @group_property(&#39;Open&#39;, Events)
    def open(self):
        &#34;&#34;&#34;Open positions of type `Events`.&#34;&#34;&#34;
        filter_mask = self._records[:, PositionRecord.Status] == PositionStatus.Open
        return Events(self.wrapper, self._records[filter_mask, :], layout=self.layout)

    @group_property(&#39;Closed&#39;, Events)
    def closed(self):
        &#34;&#34;&#34;Closed positions of type `Events`.&#34;&#34;&#34;
        filter_mask = self._records[:, PositionRecord.Status] == PositionStatus.Closed
        return Events(self.wrapper, self._records[filter_mask, :], layout=self.layout)

    @metric_property(&#39;Closed rate&#39;)
    def closed_rate(self):
        &#34;&#34;&#34;Rate of closed positions.&#34;&#34;&#34;
        closed_count = reshape_fns.to_1d(self.closed.count, raw=True)
        count = reshape_fns.to_1d(self.count, raw=True)

        closed_rate = closed_count / count
        return self.wrapper.wrap_reduced(closed_rate)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.portfolio.records.BaseEvents"><code class="flex name class">
<span>class <span class="ident">BaseEvents</span></span>
<span>(</span><span>wrapper, records, layout=EventRecord(Column=0, Size=1, OpenAt=2, OpenPrice=3, OpenFees=4, CloseAt=5, ClosePrice=6, CloseFees=7, PnL=8, Return=9))</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code><a title="vectorbt.portfolio.records.Records" href="#vectorbt.portfolio.records.Records">Records</a></code> for working with event records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseEvents(Records):
    &#34;&#34;&#34;Extends `Records` for working with event records.&#34;&#34;&#34;

    def __init__(self, wrapper, records, layout=EventRecord):
        checks.assert_same(EventRecord._fields, layout._fields[:len(EventRecord)])  # subtype of EventRecord

        super().__init__(wrapper, records, layout, EventRecord.Column, EventRecord.CloseAt)

    # ############# Duration ############# #

    @timeseries_property(&#39;Duration&#39;)
    def duration(self):
        &#34;&#34;&#34;Duration of each event (in raw format).&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.duration_map_func_nb)

    @metric_property(&#39;Average duration&#39;)
    def avg_duration(self):
        &#34;&#34;&#34;Average duration of an event (in time units).&#34;&#34;&#34;
        return self.duration.vbt.timeseries.mean(time_units=True)

    # ############# PnL ############# #

    @timeseries_property(&#39;PnL&#39;)
    def pnl(self):
        &#34;&#34;&#34;PnL of each event.&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.field_map_func_nb, EventRecord.PnL)

    @metric_property(&#39;Total PnL&#39;)
    def total_pnl(self):
        &#34;&#34;&#34;Total PnL of all events.&#34;&#34;&#34;
        return self.pnl.vbt.timeseries.sum()

    @metric_property(&#39;Average PnL&#39;)
    def avg_pnl(self):
        &#34;&#34;&#34;Average PnL of an event.&#34;&#34;&#34;
        return self.pnl.vbt.timeseries.mean()

    def plot_pnl(self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs):
        &#34;&#34;&#34;Plot PnL of each event as markers.

        Args:
            profit_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Profit&#34; markers.
            loss_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Loss&#34; markers.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.&#34;&#34;&#34;
        checks.assert_type(self.pnl, pd.Series)

        above_trace_kwargs = {**dict(name=&#39;Profit&#39;), **profit_trace_kwargs}
        below_trace_kwargs = {**dict(name=&#39;Loss&#39;), **loss_trace_kwargs}
        return self.pnl.vbt.timeseries.plot_against(0, above_trace_kwargs=above_trace_kwargs, below_trace_kwargs=below_trace_kwargs)

    # ############# Returns ############# #

    @timeseries_property(&#39;Returns&#39;)
    def returns(self):
        &#34;&#34;&#34;Return of each event.&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.field_map_func_nb, EventRecord.Return)

    @metric_property(&#39;Average return&#39;)
    def avg_return(self):
        &#34;&#34;&#34;Average return of an event.&#34;&#34;&#34;
        return self.returns.vbt.timeseries.mean()

    def plot_returns(self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs):
        &#34;&#34;&#34;Plot return of each event as a marker.

        See `BaseEvents.plot_pnl`.&#34;&#34;&#34;
        checks.assert_type(self.pnl, pd.Series)

        above_trace_kwargs = {**dict(name=&#39;Profit&#39;), **profit_trace_kwargs}
        below_trace_kwargs = {**dict(name=&#39;Loss&#39;), **loss_trace_kwargs}
        return self.returns.vbt.timeseries.plot_against(0, above_trace_kwargs=above_trace_kwargs, below_trace_kwargs=below_trace_kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.records.Records" href="#vectorbt.portfolio.records.Records">Records</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.records.Events" href="#vectorbt.portfolio.records.Events">Events</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.records.BaseEvents.avg_duration"><code class="name">var <span class="ident">avg_duration</span></code></dt>
<dd>
<div class="desc"><p>Average duration of an event (in time units).</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.BaseEvents.avg_pnl"><code class="name">var <span class="ident">avg_pnl</span></code></dt>
<dd>
<div class="desc"><p>Average PnL of an event.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.BaseEvents.avg_return"><code class="name">var <span class="ident">avg_return</span></code></dt>
<dd>
<div class="desc"><p>Average return of an event.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.BaseEvents.duration"><code class="name">var <span class="ident">duration</span></code></dt>
<dd>
<div class="desc"><p>Duration of each event (in raw format).</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.BaseEvents.pnl"><code class="name">var <span class="ident">pnl</span></code></dt>
<dd>
<div class="desc"><p>PnL of each event.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.BaseEvents.returns"><code class="name">var <span class="ident">returns</span></code></dt>
<dd>
<div class="desc"><p>Return of each event.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.BaseEvents.total_pnl"><code class="name">var <span class="ident">total_pnl</span></code></dt>
<dd>
<div class="desc"><p>Total PnL of all events.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.portfolio.records.BaseEvents.plot_pnl"><code class="name flex">
<span>def <span class="ident">plot_pnl</span></span>(<span>self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot PnL of each event as markers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>profit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for "Profit" markers.</dd>
<dt><strong><code>loss_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for "Loss" markers.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_pnl(self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs):
    &#34;&#34;&#34;Plot PnL of each event as markers.

    Args:
        profit_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Profit&#34; markers.
        loss_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for &#34;Loss&#34; markers.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.&#34;&#34;&#34;
    checks.assert_type(self.pnl, pd.Series)

    above_trace_kwargs = {**dict(name=&#39;Profit&#39;), **profit_trace_kwargs}
    below_trace_kwargs = {**dict(name=&#39;Loss&#39;), **loss_trace_kwargs}
    return self.pnl.vbt.timeseries.plot_against(0, above_trace_kwargs=above_trace_kwargs, below_trace_kwargs=below_trace_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.BaseEvents.plot_returns"><code class="name flex">
<span>def <span class="ident">plot_returns</span></span>(<span>self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot return of each event as a marker.</p>
<p>See <code><a title="vectorbt.portfolio.records.BaseEvents.plot_pnl" href="#vectorbt.portfolio.records.BaseEvents.plot_pnl">BaseEvents.plot_pnl()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_returns(self, profit_trace_kwargs={}, loss_trace_kwargs={}, fig=None, **layout_kwargs):
    &#34;&#34;&#34;Plot return of each event as a marker.

    See `BaseEvents.plot_pnl`.&#34;&#34;&#34;
    checks.assert_type(self.pnl, pd.Series)

    above_trace_kwargs = {**dict(name=&#39;Profit&#39;), **profit_trace_kwargs}
    below_trace_kwargs = {**dict(name=&#39;Loss&#39;), **loss_trace_kwargs}
    return self.returns.vbt.timeseries.plot_against(0, above_trace_kwargs=above_trace_kwargs, below_trace_kwargs=below_trace_kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.portfolio.records.Records" href="#vectorbt.portfolio.records.Records">Records</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.portfolio.records.Records.count" href="#vectorbt.portfolio.records.Records.count">count</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Records.map_records_to_matrix" href="#vectorbt.portfolio.records.Records.map_records_to_matrix">map_records_to_matrix</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Records.records" href="#vectorbt.portfolio.records.Records.records">records</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Records.reduce_records" href="#vectorbt.portfolio.records.Records.reduce_records">reduce_records</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.portfolio.records.BaseOrders"><code class="flex name class">
<span>class <span class="ident">BaseOrders</span></span>
<span>(</span><span>wrapper, records)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code><a title="vectorbt.portfolio.records.Records" href="#vectorbt.portfolio.records.Records">Records</a></code> for working with order records.</p>
<p>Requires records of type <code><a title="vectorbt.portfolio.enums.OrderRecord" href="enums.html#vectorbt.portfolio.enums.OrderRecord">OrderRecord</a></code>.</p>
<h2 id="example">Example</h2>
<p>Get the total number of buy and sell operations:</p>
<pre><code class="python-repl">&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from vectorbt.portfolio.records import Orders
&gt;&gt;&gt; from vectorbt.portfolio.enums import OrderSide, OrderRecord as OR

&gt;&gt;&gt; price = pd.Series([1, 2, 3, 2, 1])
&gt;&gt;&gt; orders = pd.Series([1, 1, 1, 1, -1])
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
...      init_capital=100, data_freq='1D')

&gt;&gt;&gt; print(portfolio.orders.buy.count)
4.0
&gt;&gt;&gt; print(portfolio.orders.sell.count)
1.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseOrders(Records):
    &#34;&#34;&#34;Extends `Records` for working with order records.

    Requires records of type `vectorbt.portfolio.enums.OrderRecord`.
    
    Example:
        Get the total number of buy and sell operations:
        ```python-repl
        &gt;&gt;&gt; import vectorbt as vbt
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.portfolio.records import Orders
        &gt;&gt;&gt; from vectorbt.portfolio.enums import OrderSide, OrderRecord as OR

        &gt;&gt;&gt; price = pd.Series([1, 2, 3, 2, 1])
        &gt;&gt;&gt; orders = pd.Series([1, 1, 1, 1, -1])
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
        ...      init_capital=100, data_freq=&#39;1D&#39;)

        &gt;&gt;&gt; print(portfolio.orders.buy.count)
        4.0
        &gt;&gt;&gt; print(portfolio.orders.sell.count)
        1.0
        ```&#34;&#34;&#34;
    def __init__(self, wrapper, records):
        super().__init__(wrapper, records, OrderRecord, OrderRecord.Column, OrderRecord.Index)

    @timeseries_property(&#39;Size&#39;)
    def size(self):
        &#34;&#34;&#34;Size of each order.&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.field_map_func_nb, OrderRecord.Size)

    @timeseries_property(&#39;Price&#39;)
    def price(self):
        &#34;&#34;&#34;Price of each order.&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.field_map_func_nb, OrderRecord.Price)

    @timeseries_property(&#39;Fees&#39;)
    def fees(self):
        &#34;&#34;&#34;Fees of each order.&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.field_map_func_nb, OrderRecord.Fees)

    @metric_property(&#39;Total fees&#39;)
    def total_fees(self):
        &#34;&#34;&#34;Total fees of all orders.&#34;&#34;&#34;
        return self.fees.vbt.timeseries.sum()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.records.Records" href="#vectorbt.portfolio.records.Records">Records</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.records.Orders" href="#vectorbt.portfolio.records.Orders">Orders</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.records.BaseOrders.fees"><code class="name">var <span class="ident">fees</span></code></dt>
<dd>
<div class="desc"><p>Fees of each order.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.BaseOrders.price"><code class="name">var <span class="ident">price</span></code></dt>
<dd>
<div class="desc"><p>Price of each order.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.BaseOrders.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><p>Size of each order.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.BaseOrders.total_fees"><code class="name">var <span class="ident">total_fees</span></code></dt>
<dd>
<div class="desc"><p>Total fees of all orders.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.portfolio.records.Records" href="#vectorbt.portfolio.records.Records">Records</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.portfolio.records.Records.count" href="#vectorbt.portfolio.records.Records.count">count</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Records.map_records_to_matrix" href="#vectorbt.portfolio.records.Records.map_records_to_matrix">map_records_to_matrix</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Records.records" href="#vectorbt.portfolio.records.Records.records">records</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Records.reduce_records" href="#vectorbt.portfolio.records.Records.reduce_records">reduce_records</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.portfolio.records.Events"><code class="flex name class">
<span>class <span class="ident">Events</span></span>
<span>(</span><span>wrapper, records, layout=EventRecord(Column=0, Size=1, OpenAt=2, OpenPrice=3, OpenFees=4, CloseAt=5, ClosePrice=6, CloseFees=7, PnL=8, Return=9))</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code><a title="vectorbt.portfolio.records.BaseEvents" href="#vectorbt.portfolio.records.BaseEvents">BaseEvents</a></code> by further dividing events into winning and losing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Events(BaseEvents):
    &#34;&#34;&#34;Extends `BaseEvents` by further dividing events into winning and losing.&#34;&#34;&#34;

    @group_property(&#39;Winning&#39;, BaseEvents)
    def winning(self):
        &#34;&#34;&#34;Winning events of type `BaseEvents`.&#34;&#34;&#34;
        filter_mask = self._records[:, EventRecord.PnL] &gt; 0.
        return BaseEvents(self.wrapper, self._records[filter_mask, :], layout=self.layout)

    @group_property(&#39;Losing&#39;, BaseEvents)
    def losing(self):
        &#34;&#34;&#34;Losing events of type `BaseEvents`.&#34;&#34;&#34;
        filter_mask = self._records[:, EventRecord.PnL] &lt; 0.
        return BaseEvents(self.wrapper, self._records[filter_mask, :], layout=self.layout)

    @metric_property(&#39;Win rate&#39;)
    def win_rate(self):
        &#34;&#34;&#34;Rate of profitable events.&#34;&#34;&#34;
        winning_count = reshape_fns.to_1d(self.winning.count, raw=True)
        count = reshape_fns.to_1d(self.count, raw=True)

        win_rate = winning_count / count
        return self.wrapper.wrap_reduced(win_rate)

    @metric_property(&#39;Profit factor&#39;)
    def profit_factor(self):
        &#34;&#34;&#34;Profit factor.&#34;&#34;&#34;
        total_win = reshape_fns.to_1d(self.winning.total_pnl, raw=True)
        total_loss = reshape_fns.to_1d(self.losing.total_pnl, raw=True)

        # Otherwise columns with only wins or losses will become NaNs
        has_values = reshape_fns.to_1d(self.count, raw=True) &gt; 0
        total_win[np.isnan(total_win) &amp; has_values] = 0.
        total_loss[np.isnan(total_loss) &amp; has_values] = 0.

        profit_factor = total_win / np.abs(total_loss)
        return self.wrapper.wrap_reduced(profit_factor)

    @metric_property(&#39;Expectancy&#39;)
    def expectancy(self):
        &#34;&#34;&#34;Average profitability.&#34;&#34;&#34;
        win_rate = reshape_fns.to_1d(self.win_rate, raw=True)
        avg_win = reshape_fns.to_1d(self.winning.avg_pnl, raw=True)
        avg_loss = reshape_fns.to_1d(self.losing.avg_pnl, raw=True)

        # Otherwise columns with only wins or losses will become NaNs
        has_values = reshape_fns.to_1d(self.count, raw=True) &gt; 0
        avg_win[np.isnan(avg_win) &amp; has_values] = 0.
        avg_loss[np.isnan(avg_loss) &amp; has_values] = 0.

        expectancy = win_rate * avg_win - (1 - win_rate) * np.abs(avg_loss)
        return self.wrapper.wrap_reduced(expectancy)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.records.BaseEvents" href="#vectorbt.portfolio.records.BaseEvents">BaseEvents</a></li>
<li><a title="vectorbt.portfolio.records.Records" href="#vectorbt.portfolio.records.Records">Records</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.records.Positions" href="#vectorbt.portfolio.records.Positions">Positions</a></li>
<li><a title="vectorbt.portfolio.records.Trades" href="#vectorbt.portfolio.records.Trades">Trades</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.records.Events.expectancy"><code class="name">var <span class="ident">expectancy</span></code></dt>
<dd>
<div class="desc"><p>Average profitability.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.Events.losing"><code class="name">var <span class="ident">losing</span></code></dt>
<dd>
<div class="desc"><p>Losing events of type <code><a title="vectorbt.portfolio.records.BaseEvents" href="#vectorbt.portfolio.records.BaseEvents">BaseEvents</a></code>.</p>
<p><span class="badge badge-pill badge-info">group</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.Events.profit_factor"><code class="name">var <span class="ident">profit_factor</span></code></dt>
<dd>
<div class="desc"><p>Profit factor.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.Events.win_rate"><code class="name">var <span class="ident">win_rate</span></code></dt>
<dd>
<div class="desc"><p>Rate of profitable events.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.Events.winning"><code class="name">var <span class="ident">winning</span></code></dt>
<dd>
<div class="desc"><p>Winning events of type <code><a title="vectorbt.portfolio.records.BaseEvents" href="#vectorbt.portfolio.records.BaseEvents">BaseEvents</a></code>.</p>
<p><span class="badge badge-pill badge-info">group</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.portfolio.records.BaseEvents" href="#vectorbt.portfolio.records.BaseEvents">BaseEvents</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.portfolio.records.BaseEvents.avg_duration" href="#vectorbt.portfolio.records.BaseEvents.avg_duration">avg_duration</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.avg_pnl" href="#vectorbt.portfolio.records.BaseEvents.avg_pnl">avg_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.avg_return" href="#vectorbt.portfolio.records.BaseEvents.avg_return">avg_return</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.count" href="#vectorbt.portfolio.records.Records.count">count</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.duration" href="#vectorbt.portfolio.records.BaseEvents.duration">duration</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.map_records_to_matrix" href="#vectorbt.portfolio.records.Records.map_records_to_matrix">map_records_to_matrix</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.plot_pnl" href="#vectorbt.portfolio.records.BaseEvents.plot_pnl">plot_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.plot_returns" href="#vectorbt.portfolio.records.BaseEvents.plot_returns">plot_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.pnl" href="#vectorbt.portfolio.records.BaseEvents.pnl">pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.records" href="#vectorbt.portfolio.records.Records.records">records</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.reduce_records" href="#vectorbt.portfolio.records.Records.reduce_records">reduce_records</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.returns" href="#vectorbt.portfolio.records.BaseEvents.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.total_pnl" href="#vectorbt.portfolio.records.BaseEvents.total_pnl">total_pnl</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.portfolio.records.Orders"><code class="flex name class">
<span>class <span class="ident">Orders</span></span>
<span>(</span><span>wrapper, records)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code><a title="vectorbt.portfolio.records.BaseOrders" href="#vectorbt.portfolio.records.BaseOrders">BaseOrders</a></code> by further dividing orders into buy and sell orders.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Orders(BaseOrders):
    &#34;&#34;&#34;Extends `BaseOrders` by further dividing orders into buy and sell orders.&#34;&#34;&#34;

    @timeseries_property(&#39;Side&#39;)
    def side(self):
        &#34;&#34;&#34;Side of each order.
        
        See `vectorbt.portfolio.enums.OrderSide`.&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.field_map_func_nb, OrderRecord.Side)

    @group_property(&#39;Buy&#39;, BaseOrders)
    def buy(self):
        &#34;&#34;&#34;Buy operations of type `BaseOrders`.&#34;&#34;&#34;
        filter_mask = self._records[:, OrderRecord.Side] == OrderSide.Buy
        return BaseOrders(self.wrapper, self._records[filter_mask, :])

    @group_property(&#39;Sell&#39;, BaseOrders)
    def sell(self):
        &#34;&#34;&#34;Sell operations of type `BaseOrders`.&#34;&#34;&#34;
        filter_mask = self._records[:, OrderRecord.Side] == OrderSide.Sell
        return BaseOrders(self.wrapper, self._records[filter_mask, :])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.records.BaseOrders" href="#vectorbt.portfolio.records.BaseOrders">BaseOrders</a></li>
<li><a title="vectorbt.portfolio.records.Records" href="#vectorbt.portfolio.records.Records">Records</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.records.Orders.buy"><code class="name">var <span class="ident">buy</span></code></dt>
<dd>
<div class="desc"><p>Buy operations of type <code><a title="vectorbt.portfolio.records.BaseOrders" href="#vectorbt.portfolio.records.BaseOrders">BaseOrders</a></code>.</p>
<p><span class="badge badge-pill badge-info">group</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.Orders.sell"><code class="name">var <span class="ident">sell</span></code></dt>
<dd>
<div class="desc"><p>Sell operations of type <code><a title="vectorbt.portfolio.records.BaseOrders" href="#vectorbt.portfolio.records.BaseOrders">BaseOrders</a></code>.</p>
<p><span class="badge badge-pill badge-info">group</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.Orders.side"><code class="name">var <span class="ident">side</span></code></dt>
<dd>
<div class="desc"><p>Side of each order.</p>
<p>See <code><a title="vectorbt.portfolio.enums.OrderSide" href="enums.html#vectorbt.portfolio.enums.OrderSide">OrderSide</a></code>.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.portfolio.records.BaseOrders" href="#vectorbt.portfolio.records.BaseOrders">BaseOrders</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.portfolio.records.BaseOrders.count" href="#vectorbt.portfolio.records.Records.count">count</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseOrders.fees" href="#vectorbt.portfolio.records.BaseOrders.fees">fees</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseOrders.map_records_to_matrix" href="#vectorbt.portfolio.records.Records.map_records_to_matrix">map_records_to_matrix</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseOrders.price" href="#vectorbt.portfolio.records.BaseOrders.price">price</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseOrders.records" href="#vectorbt.portfolio.records.Records.records">records</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseOrders.reduce_records" href="#vectorbt.portfolio.records.Records.reduce_records">reduce_records</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseOrders.size" href="#vectorbt.portfolio.records.BaseOrders.size">size</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseOrders.total_fees" href="#vectorbt.portfolio.records.BaseOrders.total_fees">total_fees</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.portfolio.records.Positions"><code class="flex name class">
<span>class <span class="ident">Positions</span></span>
<span>(</span><span>wrapper, records)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code><a title="vectorbt.portfolio.records.Events" href="#vectorbt.portfolio.records.Events">Events</a></code> for working with position records.</p>
<p>Requires records of type <code><a title="vectorbt.portfolio.enums.PositionRecord" href="enums.html#vectorbt.portfolio.enums.PositionRecord">PositionRecord</a></code>.
Such records can be created by using <code><a title="vectorbt.portfolio.nb.position_records_nb" href="nb.html#vectorbt.portfolio.nb.position_records_nb">position_records_nb()</a></code>.</p>
<h2 id="example">Example</h2>
<p>Get the average PnL of closed positions with duration over 2 days:</p>
<pre><code class="python-repl">&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from vectorbt.portfolio.records import Positions
&gt;&gt;&gt; from vectorbt.portfolio.enums import PositionStatus, PositionRecord as PR

&gt;&gt;&gt; price = pd.Series([1, 2, 3, 2, 1])
&gt;&gt;&gt; orders = pd.Series([1, -1, 1, 0, -1])
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
...      init_capital=100, data_freq='1D')
&gt;&gt;&gt; print(portfolio.positions.avg_pnl)
-0.5

&gt;&gt;&gt; records = portfolio.position_records.values
&gt;&gt;&gt; closed_mask = records[:, PR.Status] == PositionStatus.Closed
&gt;&gt;&gt; duration_mask = (records[:, PR.CloseAt] - records[:, PR.OpenAt]) &gt;= 2.
&gt;&gt;&gt; filtered_records = records[closed_mask &amp; duration_mask, :]
&gt;&gt;&gt; positions = Positions(portfolio.wrapper, filtered_records)
&gt;&gt;&gt; print(positions.avg_pnl)
-2.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Positions(Events):
    &#34;&#34;&#34;Extends `Events` for working with position records.

    Requires records of type `vectorbt.portfolio.enums.PositionRecord`.
    Such records can be created by using `vectorbt.portfolio.nb.position_records_nb`.

    Example:
        Get the average PnL of closed positions with duration over 2 days:
        ```python-repl
        &gt;&gt;&gt; import vectorbt as vbt
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.portfolio.records import Positions
        &gt;&gt;&gt; from vectorbt.portfolio.enums import PositionStatus, PositionRecord as PR

        &gt;&gt;&gt; price = pd.Series([1, 2, 3, 2, 1])
        &gt;&gt;&gt; orders = pd.Series([1, -1, 1, 0, -1])
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
        ...      init_capital=100, data_freq=&#39;1D&#39;)
        &gt;&gt;&gt; print(portfolio.positions.avg_pnl)
        -0.5
        
        &gt;&gt;&gt; records = portfolio.position_records.values
        &gt;&gt;&gt; closed_mask = records[:, PR.Status] == PositionStatus.Closed
        &gt;&gt;&gt; duration_mask = (records[:, PR.CloseAt] - records[:, PR.OpenAt]) &gt;= 2.
        &gt;&gt;&gt; filtered_records = records[closed_mask &amp; duration_mask, :]
        &gt;&gt;&gt; positions = Positions(portfolio.wrapper, filtered_records)
        &gt;&gt;&gt; print(positions.avg_pnl)
        -2.0
        ```&#34;&#34;&#34;

    def __init__(self, wrapper, records):
        super().__init__(wrapper, records, layout=PositionRecord)

    @timeseries_property(&#39;Status&#39;)
    def status(self):
        &#34;&#34;&#34;See `vectorbt.portfolio.enums.PositionStatus`.&#34;&#34;&#34;
        return self.map_records_to_matrix(nb.field_map_func_nb, PositionRecord.Status)

    @group_property(&#39;Open&#39;, Events)
    def open(self):
        &#34;&#34;&#34;Open positions of type `Events`.&#34;&#34;&#34;
        filter_mask = self._records[:, PositionRecord.Status] == PositionStatus.Open
        return Events(self.wrapper, self._records[filter_mask, :], layout=self.layout)

    @group_property(&#39;Closed&#39;, Events)
    def closed(self):
        &#34;&#34;&#34;Closed positions of type `Events`.&#34;&#34;&#34;
        filter_mask = self._records[:, PositionRecord.Status] == PositionStatus.Closed
        return Events(self.wrapper, self._records[filter_mask, :], layout=self.layout)

    @metric_property(&#39;Closed rate&#39;)
    def closed_rate(self):
        &#34;&#34;&#34;Rate of closed positions.&#34;&#34;&#34;
        closed_count = reshape_fns.to_1d(self.closed.count, raw=True)
        count = reshape_fns.to_1d(self.count, raw=True)

        closed_rate = closed_count / count
        return self.wrapper.wrap_reduced(closed_rate)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.records.Events" href="#vectorbt.portfolio.records.Events">Events</a></li>
<li><a title="vectorbt.portfolio.records.BaseEvents" href="#vectorbt.portfolio.records.BaseEvents">BaseEvents</a></li>
<li><a title="vectorbt.portfolio.records.Records" href="#vectorbt.portfolio.records.Records">Records</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.records.Positions.closed"><code class="name">var <span class="ident">closed</span></code></dt>
<dd>
<div class="desc"><p>Closed positions of type <code><a title="vectorbt.portfolio.records.Events" href="#vectorbt.portfolio.records.Events">Events</a></code>.</p>
<p><span class="badge badge-pill badge-info">group</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.Positions.closed_rate"><code class="name">var <span class="ident">closed_rate</span></code></dt>
<dd>
<div class="desc"><p>Rate of closed positions.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.Positions.open"><code class="name">var <span class="ident">open</span></code></dt>
<dd>
<div class="desc"><p>Open positions of type <code><a title="vectorbt.portfolio.records.Events" href="#vectorbt.portfolio.records.Events">Events</a></code>.</p>
<p><span class="badge badge-pill badge-info">group</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.Positions.status"><code class="name">var <span class="ident">status</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.portfolio.enums.PositionStatus" href="enums.html#vectorbt.portfolio.enums.PositionStatus">PositionStatus</a></code>.</p>
<p><span class="badge badge-pill badge-primary">timeseries</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.portfolio.records.Events" href="#vectorbt.portfolio.records.Events">Events</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.portfolio.records.Events.avg_duration" href="#vectorbt.portfolio.records.BaseEvents.avg_duration">avg_duration</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.avg_pnl" href="#vectorbt.portfolio.records.BaseEvents.avg_pnl">avg_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.avg_return" href="#vectorbt.portfolio.records.BaseEvents.avg_return">avg_return</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.count" href="#vectorbt.portfolio.records.Records.count">count</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.duration" href="#vectorbt.portfolio.records.BaseEvents.duration">duration</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.expectancy" href="#vectorbt.portfolio.records.Events.expectancy">expectancy</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.losing" href="#vectorbt.portfolio.records.Events.losing">losing</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.map_records_to_matrix" href="#vectorbt.portfolio.records.Records.map_records_to_matrix">map_records_to_matrix</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.plot_pnl" href="#vectorbt.portfolio.records.BaseEvents.plot_pnl">plot_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.plot_returns" href="#vectorbt.portfolio.records.BaseEvents.plot_returns">plot_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.pnl" href="#vectorbt.portfolio.records.BaseEvents.pnl">pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.profit_factor" href="#vectorbt.portfolio.records.Events.profit_factor">profit_factor</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.records" href="#vectorbt.portfolio.records.Records.records">records</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.reduce_records" href="#vectorbt.portfolio.records.Records.reduce_records">reduce_records</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.returns" href="#vectorbt.portfolio.records.BaseEvents.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.total_pnl" href="#vectorbt.portfolio.records.BaseEvents.total_pnl">total_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.win_rate" href="#vectorbt.portfolio.records.Events.win_rate">win_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.winning" href="#vectorbt.portfolio.records.Events.winning">winning</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.portfolio.records.Records"><code class="flex name class">
<span>class <span class="ident">Records</span></span>
<span>(</span><span>wrapper, records, layout, col_field, row_field)</span>
</code></dt>
<dd>
<div class="desc"><p>Exposes methods and properties for working with any records.</p>
<p>This class doesn't hold any data, but creates a read-only view over records.
Except that all time series and metric properties are cached.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrapper</code></strong> :&ensp;<code>TSRArrayWrapper</code></dt>
<dd>Array wrapper of type <code><a title="vectorbt.portfolio.common.TSRArrayWrapper" href="common.html#vectorbt.portfolio.common.TSRArrayWrapper">TSRArrayWrapper</a></code>.</dd>
<dt><strong><code>records</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>An array of records.</dd>
<dt><strong><code>layout</code></strong></dt>
<dd>An instance of a <code>namedtuple</code> class that acts as a layout for the records.</dd>
<dt><strong><code>col_field</code></strong> :&ensp;<code>int</code></dt>
<dd>Field index representing a column index.</dd>
<dt><strong><code>row_field</code></strong> :&ensp;<code>int</code></dt>
<dd>Field index representing a row index.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Records():
    &#34;&#34;&#34;Exposes methods and properties for working with any records.

    This class doesn&#39;t hold any data, but creates a read-only view over records.
    Except that all time series and metric properties are cached.

    Args:
        wrapper (TSRArrayWrapper): Array wrapper of type `vectorbt.portfolio.common.TSRArrayWrapper`.
        records (np.ndarray): An array of records.
        layout: An instance of a `namedtuple` class that acts as a layout for the records.
        col_field (int): Field index representing a column index.
        row_field (int): Field index representing a row index.&#34;&#34;&#34;

    def __init__(self, wrapper, records, layout, col_field, row_field):
        checks.assert_type(records, np.ndarray)
        checks.assert_same_shape(records, layout, axis=(1, 0))

        self.wrapper = wrapper
        self._records = records
        self.layout = layout
        self.col_field = col_field
        self.row_field = row_field

    @records_property(&#39;Records&#39;)
    def records(self):
        &#34;&#34;&#34;Records.&#34;&#34;&#34;
        return self.wrapper.wrap_records(self._records, self.layout)

    def map_records_to_matrix(self, map_func_nb, *args):
        &#34;&#34;&#34;Map each record to a value that is then stored in a matrix.
        
        See `vectorbt.portfolio.nb.map_records_to_matrix_nb`.&#34;&#34;&#34;
        checks.assert_numba_func(map_func_nb)

        return self.wrapper.wrap(
            nb.map_records_to_matrix_nb(
                self._records,
                (len(self.wrapper.index), len(self.wrapper.columns)),
                self.col_field,
                self.row_field,
                map_func_nb,
                *args))

    def reduce_records(self, reduce_func_nb, *args):
        &#34;&#34;&#34;Perform a reducing operation over the records of each column.
        
        See `vectorbt.portfolio.nb.reduce_records_nb`.&#34;&#34;&#34;
        checks.assert_numba_func(reduce_func_nb)

        return self.wrapper.wrap_reduced(
            nb.reduce_records_nb(
                self._records,
                len(self.wrapper.columns),
                self.col_field,
                reduce_func_nb,
                *args))

    @metric_property(&#39;Total count&#39;)
    def count(self):
        &#34;&#34;&#34;Total count of all events.&#34;&#34;&#34;
        return self.reduce_records(nb.count_reduce_func_nb)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.records.BaseEvents" href="#vectorbt.portfolio.records.BaseEvents">BaseEvents</a></li>
<li><a title="vectorbt.portfolio.records.BaseOrders" href="#vectorbt.portfolio.records.BaseOrders">BaseOrders</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.records.Records.count"><code class="name">var <span class="ident">count</span></code></dt>
<dd>
<div class="desc"><p>Total count of all events.</p>
<p><span class="badge badge-pill badge-success">metric</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.Records.records"><code class="name">var <span class="ident">records</span></code></dt>
<dd>
<div class="desc"><p>Records.</p>
<p><span class="badge badge-pill badge-warning">records</span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled: # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.portfolio.records.Records.map_records_to_matrix"><code class="name flex">
<span>def <span class="ident">map_records_to_matrix</span></span>(<span>self, map_func_nb, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Map each record to a value that is then stored in a matrix.</p>
<p>See <code><a title="vectorbt.portfolio.nb.map_records_to_matrix_nb" href="nb.html#vectorbt.portfolio.nb.map_records_to_matrix_nb">map_records_to_matrix_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_records_to_matrix(self, map_func_nb, *args):
    &#34;&#34;&#34;Map each record to a value that is then stored in a matrix.
    
    See `vectorbt.portfolio.nb.map_records_to_matrix_nb`.&#34;&#34;&#34;
    checks.assert_numba_func(map_func_nb)

    return self.wrapper.wrap(
        nb.map_records_to_matrix_nb(
            self._records,
            (len(self.wrapper.index), len(self.wrapper.columns)),
            self.col_field,
            self.row_field,
            map_func_nb,
            *args))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.records.Records.reduce_records"><code class="name flex">
<span>def <span class="ident">reduce_records</span></span>(<span>self, reduce_func_nb, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a reducing operation over the records of each column.</p>
<p>See <code><a title="vectorbt.portfolio.nb.reduce_records_nb" href="nb.html#vectorbt.portfolio.nb.reduce_records_nb">reduce_records_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_records(self, reduce_func_nb, *args):
    &#34;&#34;&#34;Perform a reducing operation over the records of each column.
    
    See `vectorbt.portfolio.nb.reduce_records_nb`.&#34;&#34;&#34;
    checks.assert_numba_func(reduce_func_nb)

    return self.wrapper.wrap_reduced(
        nb.reduce_records_nb(
            self._records,
            len(self.wrapper.columns),
            self.col_field,
            reduce_func_nb,
            *args))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.portfolio.records.Trades"><code class="flex name class">
<span>class <span class="ident">Trades</span></span>
<span>(</span><span>wrapper, records)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code><a title="vectorbt.portfolio.records.Events" href="#vectorbt.portfolio.records.Events">Events</a></code> for working with trade records.</p>
<p>Requires records of type <code><a title="vectorbt.portfolio.enums.TradeRecord" href="enums.html#vectorbt.portfolio.enums.TradeRecord">TradeRecord</a></code>.
Such records can be created by using <code><a title="vectorbt.portfolio.nb.trade_records_nb" href="nb.html#vectorbt.portfolio.nb.trade_records_nb">trade_records_nb()</a></code>.</p>
<h2 id="example">Example</h2>
<p>Get the average PnL of trades with duration over 2 days:</p>
<pre><code class="python-repl">&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from vectorbt.portfolio.records import Trades
&gt;&gt;&gt; from vectorbt.portfolio.enums import TradeRecord as TR

&gt;&gt;&gt; price = pd.Series([1, 2, 3, 2, 1])
&gt;&gt;&gt; orders = pd.Series([1, -1, 1, 0, -1])
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
...      init_capital=100, data_freq='1D')
&gt;&gt;&gt; print(portfolio.trades.avg_pnl)
-0.5

&gt;&gt;&gt; records = portfolio.trade_records.values
&gt;&gt;&gt; duration_mask = (records[:, TR.CloseAt] - records[:, TR.OpenAt]) &gt;= 2.
&gt;&gt;&gt; filtered_records = records[duration_mask, :]
&gt;&gt;&gt; trades = Trades(portfolio.wrapper, filtered_records)
&gt;&gt;&gt; print(trades.avg_pnl)
-2.0
</code></pre>
<p>The same can be done by using <code><a title="vectorbt.portfolio.records.BaseEvents.reduce_records" href="#vectorbt.portfolio.records.Records.reduce_records">Records.reduce_records()</a></code>,
which skips the step of transforming records into a matrix and thus saves memory.</p>
<pre><code class="python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from numba import njit

&gt;&gt;&gt; @njit
... def reduce_func_nb(col_rs):
...     duration_mask = col_rs[:, TR.CloseAt] - col_rs[:, TR.OpenAt] &gt;= 2.
...     return np.nanmean(col_rs[duration_mask, TR.PnL])

&gt;&gt;&gt; portfolio.trades.reduce_records(reduce_func_nb)
-2.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trades(Events):
    &#34;&#34;&#34;Extends `Events` for working with trade records.

    Requires records of type `vectorbt.portfolio.enums.TradeRecord`.
    Such records can be created by using `vectorbt.portfolio.nb.trade_records_nb`.
    
    Example:
        Get the average PnL of trades with duration over 2 days:
        ```python-repl
        &gt;&gt;&gt; import vectorbt as vbt
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from vectorbt.portfolio.records import Trades
        &gt;&gt;&gt; from vectorbt.portfolio.enums import TradeRecord as TR

        &gt;&gt;&gt; price = pd.Series([1, 2, 3, 2, 1])
        &gt;&gt;&gt; orders = pd.Series([1, -1, 1, 0, -1])
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, 
        ...      init_capital=100, data_freq=&#39;1D&#39;)
        &gt;&gt;&gt; print(portfolio.trades.avg_pnl)
        -0.5

        &gt;&gt;&gt; records = portfolio.trade_records.values
        &gt;&gt;&gt; duration_mask = (records[:, TR.CloseAt] - records[:, TR.OpenAt]) &gt;= 2.
        &gt;&gt;&gt; filtered_records = records[duration_mask, :]
        &gt;&gt;&gt; trades = Trades(portfolio.wrapper, filtered_records)
        &gt;&gt;&gt; print(trades.avg_pnl)
        -2.0
        ```
        
        The same can be done by using `BaseEvents.reduce_records`, 
        which skips the step of transforming records into a matrix and thus saves memory.
        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from numba import njit

        &gt;&gt;&gt; @njit
        ... def reduce_func_nb(col_rs):
        ...     duration_mask = col_rs[:, TR.CloseAt] - col_rs[:, TR.OpenAt] &gt;= 2.
        ...     return np.nanmean(col_rs[duration_mask, TR.PnL])

        &gt;&gt;&gt; portfolio.trades.reduce_records(reduce_func_nb)
        -2.0
        ```&#34;&#34;&#34;

    def __init__(self, wrapper, records):
        super().__init__(wrapper, records, layout=TradeRecord)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.portfolio.records.Events" href="#vectorbt.portfolio.records.Events">Events</a></li>
<li><a title="vectorbt.portfolio.records.BaseEvents" href="#vectorbt.portfolio.records.BaseEvents">BaseEvents</a></li>
<li><a title="vectorbt.portfolio.records.Records" href="#vectorbt.portfolio.records.Records">Records</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.portfolio.records.Events" href="#vectorbt.portfolio.records.Events">Events</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.portfolio.records.Events.avg_duration" href="#vectorbt.portfolio.records.BaseEvents.avg_duration">avg_duration</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.avg_pnl" href="#vectorbt.portfolio.records.BaseEvents.avg_pnl">avg_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.avg_return" href="#vectorbt.portfolio.records.BaseEvents.avg_return">avg_return</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.count" href="#vectorbt.portfolio.records.Records.count">count</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.duration" href="#vectorbt.portfolio.records.BaseEvents.duration">duration</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.expectancy" href="#vectorbt.portfolio.records.Events.expectancy">expectancy</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.losing" href="#vectorbt.portfolio.records.Events.losing">losing</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.map_records_to_matrix" href="#vectorbt.portfolio.records.Records.map_records_to_matrix">map_records_to_matrix</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.plot_pnl" href="#vectorbt.portfolio.records.BaseEvents.plot_pnl">plot_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.plot_returns" href="#vectorbt.portfolio.records.BaseEvents.plot_returns">plot_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.pnl" href="#vectorbt.portfolio.records.BaseEvents.pnl">pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.profit_factor" href="#vectorbt.portfolio.records.Events.profit_factor">profit_factor</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.records" href="#vectorbt.portfolio.records.Records.records">records</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.reduce_records" href="#vectorbt.portfolio.records.Records.reduce_records">reduce_records</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.returns" href="#vectorbt.portfolio.records.BaseEvents.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.total_pnl" href="#vectorbt.portfolio.records.BaseEvents.total_pnl">total_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.win_rate" href="#vectorbt.portfolio.records.Events.win_rate">win_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.winning" href="#vectorbt.portfolio.records.Events.winning">winning</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="https://github.com/polakowo/vectorbt/blob/master/logo.png?raw=true" alt=""> vectorbt
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.portfolio" href="index.html">vectorbt.portfolio</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.portfolio.records.BaseEvents" href="#vectorbt.portfolio.records.BaseEvents">BaseEvents</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.portfolio.records.BaseEvents.avg_duration" href="#vectorbt.portfolio.records.BaseEvents.avg_duration">avg_duration</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.avg_pnl" href="#vectorbt.portfolio.records.BaseEvents.avg_pnl">avg_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.avg_return" href="#vectorbt.portfolio.records.BaseEvents.avg_return">avg_return</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.duration" href="#vectorbt.portfolio.records.BaseEvents.duration">duration</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.plot_pnl" href="#vectorbt.portfolio.records.BaseEvents.plot_pnl">plot_pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.plot_returns" href="#vectorbt.portfolio.records.BaseEvents.plot_returns">plot_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.pnl" href="#vectorbt.portfolio.records.BaseEvents.pnl">pnl</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.returns" href="#vectorbt.portfolio.records.BaseEvents.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseEvents.total_pnl" href="#vectorbt.portfolio.records.BaseEvents.total_pnl">total_pnl</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.portfolio.records.BaseOrders" href="#vectorbt.portfolio.records.BaseOrders">BaseOrders</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.portfolio.records.BaseOrders.fees" href="#vectorbt.portfolio.records.BaseOrders.fees">fees</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseOrders.price" href="#vectorbt.portfolio.records.BaseOrders.price">price</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseOrders.size" href="#vectorbt.portfolio.records.BaseOrders.size">size</a></code></li>
<li><code><a title="vectorbt.portfolio.records.BaseOrders.total_fees" href="#vectorbt.portfolio.records.BaseOrders.total_fees">total_fees</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.portfolio.records.Events" href="#vectorbt.portfolio.records.Events">Events</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.portfolio.records.Events.expectancy" href="#vectorbt.portfolio.records.Events.expectancy">expectancy</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.losing" href="#vectorbt.portfolio.records.Events.losing">losing</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.profit_factor" href="#vectorbt.portfolio.records.Events.profit_factor">profit_factor</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.win_rate" href="#vectorbt.portfolio.records.Events.win_rate">win_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Events.winning" href="#vectorbt.portfolio.records.Events.winning">winning</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.portfolio.records.Orders" href="#vectorbt.portfolio.records.Orders">Orders</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.portfolio.records.Orders.buy" href="#vectorbt.portfolio.records.Orders.buy">buy</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Orders.sell" href="#vectorbt.portfolio.records.Orders.sell">sell</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Orders.side" href="#vectorbt.portfolio.records.Orders.side">side</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.portfolio.records.Positions" href="#vectorbt.portfolio.records.Positions">Positions</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.portfolio.records.Positions.closed" href="#vectorbt.portfolio.records.Positions.closed">closed</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Positions.closed_rate" href="#vectorbt.portfolio.records.Positions.closed_rate">closed_rate</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Positions.open" href="#vectorbt.portfolio.records.Positions.open">open</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Positions.status" href="#vectorbt.portfolio.records.Positions.status">status</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.portfolio.records.Records" href="#vectorbt.portfolio.records.Records">Records</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.portfolio.records.Records.count" href="#vectorbt.portfolio.records.Records.count">count</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Records.map_records_to_matrix" href="#vectorbt.portfolio.records.Records.map_records_to_matrix">map_records_to_matrix</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Records.records" href="#vectorbt.portfolio.records.Records.records">records</a></code></li>
<li><code><a title="vectorbt.portfolio.records.Records.reduce_records" href="#vectorbt.portfolio.records.Records.reduce_records">reduce_records</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.portfolio.records.Trades" href="#vectorbt.portfolio.records.Trades">Trades</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>