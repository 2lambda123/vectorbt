<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.portfolio.base API documentation</title>
<meta name="description" content="Base class for modeling portfolio and measuring its performance â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:rgba(0,0,0,.2);border:none;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3A4D6B}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.portfolio.base</code></h1>
</header>
<section id="section-intro">
<p>Base class for modeling portfolio and measuring its performance.</p>
<p>The job of the <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> class is to create a series of positions allocated
against a cash component, produce an equity curve, incorporate basic transaction costs
and produce a set of statistics about its performance. In particular it outputs
position/profit metrics and drawdown information.</p>
<h2 id="workflow">Workflow</h2>
<p>The workflow of <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> is simple:</p>
<ol>
<li>Receives a set of inputs, such as entry and exit signals</li>
<li>Uses them to generate and fill orders in form of records (simulation part)</li>
<li>Calculates a broad range of risk &amp; performance metrics based on these records (analysis part)</li>
</ol>
<p>It basically builds upon the <code><a title="vectorbt.records.orders.Orders" href="../records/orders.html#vectorbt.records.orders.Orders">Orders</a></code> class. To simplify creation of order
records and keep track of balances, it exposes several convenience methods with prefix <code>from_</code>.
For example, you can use <code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">Portfolio.from_signals()</a></code> method to generate orders from entry and exit signals.
Alternatively, you can use <code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">Portfolio.from_order_func()</a></code> to run a custom order function on each tick.
The results are then automatically passed to the constructor method of <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> and you will
receive a portfolio instance ready to be used for performance analysis.</p>
<p>This way, one can simulate and analyze his/her strategy in a couple of lines.</p>
<h3 id="example">Example</h3>
<p>The following example does something crazy: it checks candlestick data of 6 major cryptocurrencies
in 2020 against every single pattern found in TA-Lib, and translates them into orders:</p>
<pre><code class="python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; import yfinance as yf
&gt;&gt;&gt; import talib
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; from vectorbt.portfolio.enums import InitCashMode

&gt;&gt;&gt; # Fetch price history
&gt;&gt;&gt; pairs = ['BTC-USD', 'ETH-USD', 'XRP-USD', 'BNB-USD', 'BCH-USD', 'LTC-USD']
&gt;&gt;&gt; start = datetime(2020, 1, 1)
&gt;&gt;&gt; end = datetime(2020, 9, 1)
&gt;&gt;&gt; pair_history = {p: yf.Ticker(p).history(start=start, end=end) for p in pairs}

&gt;&gt;&gt; # Put assets into a single dataframe by price type
&gt;&gt;&gt; price = {}
&gt;&gt;&gt; for pt in ['Open', 'High', 'Low', 'Close']:
...     price[pt] = pd.DataFrame({p: df[pt] for p, df in pair_history.items()})

&gt;&gt;&gt; price['Open'].head()
            BTC-USD  ETH-USD  XRP-USD  BNB-USD  BCH-USD  LTC-USD
Date
2019-12-31  7294.44   132.61   0.1945    13.95   209.30    42.77
2020-01-01  7194.89   129.63   0.1929    13.73   204.67    41.33
2020-01-02  7202.55   130.82   0.1927    13.70   204.35    42.02
2020-01-03  6984.43   127.41   0.1879    13.04   196.01    39.86
2020-01-04  7345.38   134.17   0.1935    13.67   222.54    42.38

&gt;&gt;&gt; # Run every single pattern recognition indicator and combine results
&gt;&gt;&gt; result = pd.DataFrame.vbt.empty_like(price['Open'], fill_value=0.)
&gt;&gt;&gt; for pattern in talib.get_function_groups()['Pattern Recognition']:
...     PRecognizer = vbt.IndicatorFactory.from_talib(pattern)
...     pr = PRecognizer.run(price['Open'], price['High'], price['Low'], price['Close'])
...     result = result + pr.integer

&gt;&gt;&gt; # Don't look into future
&gt;&gt;&gt; result = result.vbt.fshift(1)

&gt;&gt;&gt; # Treat each number as order value in USD
&gt;&gt;&gt; order_size = result / price['Open']

&gt;&gt;&gt; # Simulate portfolio
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
...     price['Close'], order_size, order_price=price['Open'],
...     init_cash=InitCashMode.AutoAlign, fees=0.001, slippage=0.001
... )

&gt;&gt;&gt; # Visualize portfolio value
&gt;&gt;&gt; portfolio.value().vbt.plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/portfolio_value.png"></p>
<h2 id="features">Features</h2>
<h3 id="broadcasting">Broadcasting</h3>
<p><code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> is very flexible towards inputs:</p>
<ul>
<li>Accepts both Series and DataFrames as inputs</li>
<li>Broadcasts inputs to the same shape using vectorbt's own broadcasting rules</li>
<li>Many inputs (such as <code>fees</code>) can be passed as a single value, value per column/row, or as a matrix</li>
<li>Implements flexible broadcasting wherever possible to save memory</li>
</ul>
<h3 id="grouping">Grouping</h3>
<p>One of the key features of <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> is the ability to group columns. Groups can be specified by
<code>group_by</code>, which can be anything from positions or names of column levels, to a NumPy array with
actual groups. Groups can be formed to share capital between columns or to compute metrics
for a combined portfolio of multiple independent columns.</p>
<p>For example, let's divide our portfolio into two groups sharing the same cash:</p>
<pre><code class="python-repl">&gt;&gt;&gt; # Simulate combined portfolio
&gt;&gt;&gt; group_by = pd.Index([
...     'first', 'first', 'first',
...     'second', 'second', 'second'
... ], name='group')
&gt;&gt;&gt; comb_portfolio = vbt.Portfolio.from_orders(
...     price['Close'], order_size, order_price=price['Open'],
...     init_cash=InitCashMode.AutoAlign, fees=0.001, slippage=0.001,
...     group_by=group_by, cash_sharing=True
... )

&gt;&gt;&gt; # Get total profit per group
&gt;&gt;&gt; comb_portfolio.total_profit()
group
first     21793.882832
second     8333.660493
dtype: float64
</code></pre>
<p>Not only can you analyze each group, but also each column in the group:</p>
<pre><code class="python-repl">&gt;&gt;&gt; # Get total profit per column
&gt;&gt;&gt; comb_portfolio.total_profit(group_by=False)
BTC-USD     5166.373585
ETH-USD    13098.913381
XRP-USD     3528.595867
BNB-USD     5345.521391
BCH-USD     -235.128582
LTC-USD     3223.267684
dtype: float64
</code></pre>
<p>In the same way, you can introduce new grouping to the method itself:</p>
<pre><code class="python-repl">&gt;&gt;&gt; # Get total profit per group
&gt;&gt;&gt; portfolio.total_profit(group_by=group_by)
group
first     21793.882832
second     8333.660493
dtype: float64
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If cash sharing is enabled, grouping can be disabled but cannot be modified.</p>
</div>
<h3 id="indexing">Indexing</h3>
<p>In addition, you can use pandas indexing on the <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> class itself, which forwards
indexing operation to each argument with index:</p>
<pre><code class="python-repl">&gt;&gt;&gt; portfolio['BTC-USD']
&lt;vectorbt.portfolio.base.Portfolio at 0x7fac7517ac88&gt;

&gt;&gt;&gt; portfolio['BTC-USD'].total_profit()
5166.373584618163
</code></pre>
<p>Combined portfolio is indexed by group:</p>
<pre><code class="python-repl">&gt;&gt;&gt; comb_portfolio['first']
&lt;vectorbt.portfolio.base.Portfolio at 0x7fac5756b828&gt;

&gt;&gt;&gt; comb_portfolio['first'].total_profit()
21793.882832230272
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Changing index (time axis) is not supported. The object should be treated as a Series
rather than a DataFrame; for example, use <code>portfolio.iloc[0]</code> instead of <code>portfolio.iloc[:, 0]</code>.</p>
<p>Indexing behavior depends solely upon <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.
For example, if <code>group_select</code> is enabled indexing will be performed on groups,
otherwise on single columns. You can pass wrapper arguments with <code>wrapper_kwargs</code>.</p>
</div>
<h3 id="caching">Caching</h3>
<p>This class supports caching. If a method or a property requires heavy computation, it's wrapped
with <code><a title="vectorbt.utils.decorators.cached_method" href="../utils/decorators.html#vectorbt.utils.decorators.cached_method">cached_method()</a></code> and <code><a title="vectorbt.utils.decorators.cached_property" href="../utils/decorators.html#vectorbt.utils.decorators.cached_property">cached_property</a></code> respectively.
Caching can be disabled globally via <code><a title="vectorbt.defaults" href="../defaults.html">vectorbt.defaults</a></code> or locally via the method/property.
There is currently no way to disable caching for an entire class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because of caching, this class is meant to be immutable and all properties are read-only.
To change any attribute, use the <code>copy</code> method and pass the attribute as keyword argument.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Make sure to disable caching when working with large arrays. Note that methods in <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code>
heavily depend upon each other, and a single call may trigger a chain of caching operations.
For example, calling <code><a title="vectorbt.portfolio.base.Portfolio.total_return" href="#vectorbt.portfolio.base.Portfolio.total_return">Portfolio.total_return()</a></code> caches 7 different time series of the same shape
as the reference price.</p>
<p>If caching is disabled, make sure to store most important time series manually. For example,
if you're interested in Sharpe ratio or other metrics based on returns, run and save
<code><a title="vectorbt.portfolio.base.Portfolio.returns" href="#vectorbt.portfolio.base.Portfolio.returns">Portfolio.returns()</a></code> and then use the <code><a title="vectorbt.returns.accessors.Returns_Accessor" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor">Returns_Accessor</a></code> to analyze them.
Do not use methods akin to <code><a title="vectorbt.portfolio.base.Portfolio.sharpe_ratio" href="#vectorbt.portfolio.base.Portfolio.sharpe_ratio">Portfolio.sharpe_ratio()</a></code> because they will re-calculate returns each time.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Base class for modeling portfolio and measuring its performance.

The job of the `Portfolio` class is to create a series of positions allocated 
against a cash component, produce an equity curve, incorporate basic transaction costs
and produce a set of statistics about its performance. In particular it outputs
position/profit metrics and drawdown information.

## Workflow

The workflow of `Portfolio` is simple:

1. Receives a set of inputs, such as entry and exit signals
2. Uses them to generate and fill orders in form of records (simulation part)
3. Calculates a broad range of risk &amp; performance metrics based on these records (analysis part)

It basically builds upon the `vectorbt.records.orders.Orders` class. To simplify creation of order
records and keep track of balances, it exposes several convenience methods with prefix `from_`.
For example, you can use `Portfolio.from_signals` method to generate orders from entry and exit signals.
Alternatively, you can use `Portfolio.from_order_func` to run a custom order function on each tick.
The results are then automatically passed to the constructor method of `Portfolio` and you will
receive a portfolio instance ready to be used for performance analysis.

This way, one can simulate and analyze his/her strategy in a couple of lines.

### Example

The following example does something crazy: it checks candlestick data of 6 major cryptocurrencies
in 2020 against every single pattern found in TA-Lib, and translates them into orders:

```python-repl
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; import yfinance as yf
&gt;&gt;&gt; import talib
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; from vectorbt.portfolio.enums import InitCashMode

&gt;&gt;&gt; # Fetch price history
&gt;&gt;&gt; pairs = [&#39;BTC-USD&#39;, &#39;ETH-USD&#39;, &#39;XRP-USD&#39;, &#39;BNB-USD&#39;, &#39;BCH-USD&#39;, &#39;LTC-USD&#39;]
&gt;&gt;&gt; start = datetime(2020, 1, 1)
&gt;&gt;&gt; end = datetime(2020, 9, 1)
&gt;&gt;&gt; pair_history = {p: yf.Ticker(p).history(start=start, end=end) for p in pairs}

&gt;&gt;&gt; # Put assets into a single dataframe by price type
&gt;&gt;&gt; price = {}
&gt;&gt;&gt; for pt in [&#39;Open&#39;, &#39;High&#39;, &#39;Low&#39;, &#39;Close&#39;]:
...     price[pt] = pd.DataFrame({p: df[pt] for p, df in pair_history.items()})

&gt;&gt;&gt; price[&#39;Open&#39;].head()
            BTC-USD  ETH-USD  XRP-USD  BNB-USD  BCH-USD  LTC-USD
Date
2019-12-31  7294.44   132.61   0.1945    13.95   209.30    42.77
2020-01-01  7194.89   129.63   0.1929    13.73   204.67    41.33
2020-01-02  7202.55   130.82   0.1927    13.70   204.35    42.02
2020-01-03  6984.43   127.41   0.1879    13.04   196.01    39.86
2020-01-04  7345.38   134.17   0.1935    13.67   222.54    42.38

&gt;&gt;&gt; # Run every single pattern recognition indicator and combine results
&gt;&gt;&gt; result = pd.DataFrame.vbt.empty_like(price[&#39;Open&#39;], fill_value=0.)
&gt;&gt;&gt; for pattern in talib.get_function_groups()[&#39;Pattern Recognition&#39;]:
...     PRecognizer = vbt.IndicatorFactory.from_talib(pattern)
...     pr = PRecognizer.run(price[&#39;Open&#39;], price[&#39;High&#39;], price[&#39;Low&#39;], price[&#39;Close&#39;])
...     result = result + pr.integer

&gt;&gt;&gt; # Don&#39;t look into future
&gt;&gt;&gt; result = result.vbt.fshift(1)

&gt;&gt;&gt; # Treat each number as order value in USD
&gt;&gt;&gt; order_size = result / price[&#39;Open&#39;]

&gt;&gt;&gt; # Simulate portfolio
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
...     price[&#39;Close&#39;], order_size, order_price=price[&#39;Open&#39;],
...     init_cash=InitCashMode.AutoAlign, fees=0.001, slippage=0.001
... )

&gt;&gt;&gt; # Visualize portfolio value
&gt;&gt;&gt; portfolio.value().vbt.plot()
```

![](/vectorbt/docs/img/portfolio_value.png)

## Features

### Broadcasting

`Portfolio` is very flexible towards inputs:

* Accepts both Series and DataFrames as inputs
* Broadcasts inputs to the same shape using vectorbt&#39;s own broadcasting rules
* Many inputs (such as `fees`) can be passed as a single value, value per column/row, or as a matrix
* Implements flexible broadcasting wherever possible to save memory

### Grouping

One of the key features of `Portfolio` is the ability to group columns. Groups can be specified by
`group_by`, which can be anything from positions or names of column levels, to a NumPy array with
actual groups. Groups can be formed to share capital between columns or to compute metrics
for a combined portfolio of multiple independent columns.

For example, let&#39;s divide our portfolio into two groups sharing the same cash:

```python-repl
&gt;&gt;&gt; # Simulate combined portfolio
&gt;&gt;&gt; group_by = pd.Index([
...     &#39;first&#39;, &#39;first&#39;, &#39;first&#39;,
...     &#39;second&#39;, &#39;second&#39;, &#39;second&#39;
... ], name=&#39;group&#39;)
&gt;&gt;&gt; comb_portfolio = vbt.Portfolio.from_orders(
...     price[&#39;Close&#39;], order_size, order_price=price[&#39;Open&#39;],
...     init_cash=InitCashMode.AutoAlign, fees=0.001, slippage=0.001,
...     group_by=group_by, cash_sharing=True
... )

&gt;&gt;&gt; # Get total profit per group
&gt;&gt;&gt; comb_portfolio.total_profit()
group
first     21793.882832
second     8333.660493
dtype: float64
```

Not only can you analyze each group, but also each column in the group:

```python-repl
&gt;&gt;&gt; # Get total profit per column
&gt;&gt;&gt; comb_portfolio.total_profit(group_by=False)
BTC-USD     5166.373585
ETH-USD    13098.913381
XRP-USD     3528.595867
BNB-USD     5345.521391
BCH-USD     -235.128582
LTC-USD     3223.267684
dtype: float64
```

In the same way, you can introduce new grouping to the method itself:

```python-repl
&gt;&gt;&gt; # Get total profit per group
&gt;&gt;&gt; portfolio.total_profit(group_by=group_by)
group
first     21793.882832
second     8333.660493
dtype: float64
```

!!! note
    If cash sharing is enabled, grouping can be disabled but cannot be modified.

### Indexing

In addition, you can use pandas indexing on the `Portfolio` class itself, which forwards
indexing operation to each argument with index:

```python-repl
&gt;&gt;&gt; portfolio[&#39;BTC-USD&#39;]
&lt;vectorbt.portfolio.base.Portfolio at 0x7fac7517ac88&gt;

&gt;&gt;&gt; portfolio[&#39;BTC-USD&#39;].total_profit()
5166.373584618163
```

Combined portfolio is indexed by group:

```python-repl
&gt;&gt;&gt; comb_portfolio[&#39;first&#39;]
&lt;vectorbt.portfolio.base.Portfolio at 0x7fac5756b828&gt;

&gt;&gt;&gt; comb_portfolio[&#39;first&#39;].total_profit()
21793.882832230272
```

!!! note
    Changing index (time axis) is not supported. The object should be treated as a Series
    rather than a DataFrame; for example, use `portfolio.iloc[0]` instead of `portfolio.iloc[:, 0]`.

    Indexing behavior depends solely upon `vectorbt.base.array_wrapper.ArrayWrapper`.
    For example, if `group_select` is enabled indexing will be performed on groups,
    otherwise on single columns. You can pass wrapper arguments with `wrapper_kwargs`.

### Caching

This class supports caching. If a method or a property requires heavy computation, it&#39;s wrapped
with `vectorbt.utils.decorators.cached_method` and `vectorbt.utils.decorators.cached_property` respectively.
Caching can be disabled globally via `vectorbt.defaults` or locally via the method/property.
There is currently no way to disable caching for an entire class.

!!! note
    Because of caching, this class is meant to be immutable and all properties are read-only.
    To change any attribute, use the `copy` method and pass the attribute as keyword argument.

!!! warning
    Make sure to disable caching when working with large arrays. Note that methods in `Portfolio`
    heavily depend upon each other, and a single call may trigger a chain of caching operations.
    For example, calling `Portfolio.total_return` caches 7 different time series of the same shape
    as the reference price.

    If caching is disabled, make sure to store most important time series manually. For example,
    if you&#39;re interested in Sharpe ratio or other metrics based on returns, run and save
    `Portfolio.returns` and then use the `vectorbt.returns.accessors.Returns_Accessor` to analyze them.
    Do not use methods akin to `Portfolio.sharpe_ratio` because they will re-calculate returns each time.&#34;&#34;&#34;

import numpy as np
import pandas as pd
from inspect import signature

from vectorbt import defaults
from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_method
from vectorbt.utils.config import Configured, merge_kwargs
from vectorbt.utils.random import set_seed
from vectorbt.base.reshape_fns import to_1d, to_2d, broadcast
from vectorbt.base.indexing import PandasIndexer
from vectorbt.base.array_wrapper import ArrayWrapper
from vectorbt.generic import nb as generic_nb
from vectorbt.portfolio import nb
from vectorbt.portfolio.enums import (
    SizeType,
    AccumulateExitMode,
    ConflictMode,
    CallSeqType,
    InitCashMode
)
from vectorbt.records import Orders, Trades, Positions, Drawdowns
from vectorbt.records.orders import indexing_on_orders_meta


def _indexing_func(obj, pd_indexing_func):
    &#34;&#34;&#34;Perform indexing on `Portfolio`.&#34;&#34;&#34;
    new_orders, group_idxs, col_idxs = indexing_on_orders_meta(obj.orders, pd_indexing_func)
    if obj.wrapper.grouper.group_by is None:
        # Grouping disabled
        new_init_cash = obj.init_cash.values[col_idxs]
    else:
        # Grouping enabled
        new_init_cash = obj.init_cash.values[group_idxs if obj.cash_sharing else col_idxs]
    new_call_seq = obj.call_seq.values[:, col_idxs]

    return obj.copy(
        orders=new_orders,
        init_cash=new_init_cash,
        call_seq=new_call_seq
    )


def add_returns_methods(func_names):
    &#34;&#34;&#34;Class decorator to add `vectorbt.returns.accessors.Returns_Accessor` methods to `Portfolio`.&#34;&#34;&#34;

    def wrapper(cls):
        for func_name in func_names:
            if isinstance(func_name, tuple):
                ret_func_name = func_name[0]
            else:
                ret_func_name = func_name

            def returns_method(
                    self,
                    *args,
                    group_by=None,
                    year_freq=None,
                    ret_func_name=ret_func_name,
                    active_returns=False,
                    reuse_returns=None,
                    **kwargs):
                if reuse_returns is not None:
                    returns = reuse_returns
                else:
                    if active_returns:
                        returns = self.active_returns(group_by=group_by)
                    else:
                        returns = self.returns(group_by=group_by)
                returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
                # Select only those arguments in kwargs that are also in the method&#39;s signature
                # This is done for Portfolio.stats which passes the same kwargs to multiple methods
                method = getattr(returns_acc, ret_func_name)
                sig = signature(method)
                arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
                new_kwargs = {}
                for arg_name in arg_names:
                    if arg_name in kwargs:
                        new_kwargs[arg_name] = kwargs[arg_name]
                return method(*args, **new_kwargs)

            if isinstance(func_name, tuple):
                func_name = func_name[1]
            returns_method.__name__ = func_name
            returns_method.__qualname__ = f&#34;Portfolio.{func_name}&#34;
            returns_method.__doc__ = f&#34;See `vectorbt.returns.accessors.Returns_Accessor.{ret_func_name}`.&#34;
            setattr(cls, func_name, cached_method(returns_method))
        return cls

    return wrapper


@add_returns_methods([
    (&#39;daily&#39;, &#39;daily_returns&#39;),
    (&#39;annual&#39;, &#39;annual_returns&#39;),
    (&#39;cumulative&#39;, &#39;cumulative_returns&#39;),
    (&#39;annualized&#39;, &#39;annualized_return&#39;),
    &#39;annualized_volatility&#39;,
    &#39;calmar_ratio&#39;,
    &#39;omega_ratio&#39;,
    &#39;sharpe_ratio&#39;,
    &#39;deflated_sharpe_ratio&#39;,
    &#39;downside_risk&#39;,
    &#39;sortino_ratio&#39;,
    &#39;information_ratio&#39;,
    &#39;beta&#39;,
    &#39;alpha&#39;,
    &#39;tail_ratio&#39;,
    &#39;value_at_risk&#39;,
    &#39;conditional_value_at_risk&#39;,
    &#39;capture&#39;,
    &#39;up_capture&#39;,
    &#39;down_capture&#39;,
    &#39;drawdown&#39;,
    &#39;max_drawdown&#39;
])
class Portfolio(Configured, PandasIndexer):
    &#34;&#34;&#34;Class for modeling portfolio and measuring its performance.

    Args:
        orders (Orders): Order records.
        init_cash (float or array_like): Initial capital.
        cash_sharing (bool): Whether to share cash within the same group.
        call_seq (array_like of int): Sequence of calls per row and group.
        init_cash_mode (InitCashMode or None): Initial cash mode.
        incl_unrealized (bool): Whether to include unrealized P&amp;L in statistics.

    !!! note
        Use class methods with `from_` prefix to build a portfolio.
        The `__init__` method is reserved for indexing purposes.

    !!! note
        This class is meant to be immutable. To change any attribute, use `Portfolio.copy`.&#34;&#34;&#34;

    def __init__(self, orders, init_cash, cash_sharing, call_seq, init_cash_mode=None, incl_unrealized=None):
        Configured.__init__(
            self,
            orders=orders,
            init_cash=init_cash,
            cash_sharing=cash_sharing,
            call_seq=call_seq,
            init_cash_mode=init_cash_mode,
            incl_unrealized=incl_unrealized
        )
        # Get defaults
        if incl_unrealized is None:
            incl_unrealized = defaults.portfolio[&#39;incl_unrealized&#39;]

        # Perform checks
        checks.assert_type(orders, Orders)

        # Store passed arguments
        self._ref_price = orders.close
        self._orders = orders
        self._init_cash = init_cash
        self._cash_sharing = cash_sharing
        self._call_seq = call_seq
        self._init_cash_mode = init_cash_mode
        self._incl_unrealized = incl_unrealized

        # Supercharge
        PandasIndexer.__init__(self, _indexing_func)

    # ############# Class methods ############# #

    @classmethod
    def from_signals(cls, close, entries, exits, size=None, entry_price=None, exit_price=None,
                     fees=None, fixed_fees=None, slippage=None, reject_prob=None, min_size=None,
                     init_cash=None, cash_sharing=None, call_seq=None, accumulate=None,
                     accumulate_exit_mode=None, conflict_mode=None, seed=None, freq=None, group_by=None,
                     broadcast_kwargs=None, wrapper_kwargs=None, **kwargs):
        &#34;&#34;&#34;Simulate portfolio from entry and exit signals.

        Starting with initial cash `init_cash`, for each signal in `entries`, enters a position
        by buying `size` of shares for `entry_price`. For each signal in `exits`, closes the position
        by selling all shares for `exit_price`. When accumulation is enabled, each entry signal will
        increase the position, and optionally each exit signal will decrease the position. When both
        entry and exit signals are present, ignores them by default. When grouping is enabled with
        `group_by`, will compute performance for the entire group. When, additionally, `cash_sharing`
        is enabled, will share the cash among all columns in the group.

        Args:
            close (pandas_like): Reference price, such as close. Will broadcast.

                Will be used for calculating unrealized P&amp;L and portfolio value.
            entries (array_like of bool): Boolean array of entry signals. Will broadcast.
            exits (array_like of bool): Boolean array of exit signals. Will broadcast.
            size (float or array_like): Size to order. Will broadcast.

                * Set to positive/negative to buy/sell.
                * Set to `np.inf`/`-np.inf` to buy/sell everything.
                * Set to `np.nan` or zero to skip.
            entry_price (array_like of float): Entry price. Defaults to `close`. Will broadcast.

                !!! note
                    Setting order price to close is risky.
            exit_price (array_like of float): Exit price. Defaults to `close`. Will broadcast.

                !!! note
                    Setting order price to close is risky.
            fees (float or array_like): Fees in percentage of the order value. Will broadcast.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order. Will broadcast.
            slippage (float or array_like): Slippage in percentage of price. Will broadcast.
            reject_prob (float or array_like): Order rejection probability. Will broadcast.
            min_size (float or array_like): Minimum size for an order to be accepted.

                Will broadcast to the number of columns.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                By default, will broadcast to the number of columns.
                If cash sharing is enabled, will broadcast to the number of groups.
                See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

                !!! note
                    Make sure that `init_cash` is a floating number if not using `InitCashMode`.
            cash_sharing (bool): Whether to share cash within the same group.

                !!! warning
                    Order execution cannot be considered parallel anymore.

                    This method presumes that in a group of assets that share the same capital all
                    orders will be executed within the same tick and retain their price regardless
                    of their position in the queue, even though they depend upon each other and thus
                    cannot be executed in parallel. This behavior is risky.
            call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

                * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
                * Set to array to specify custom sequence. Will not broadcast.
            accumulate (bool): If `accumulate` is `True`, entering the market when already
                in the market will be allowed to increase the position.
            accumulate_exit_mode (AccumulateExitMode): See `vectorbt.portfolio.enums.AccumulateExitMode`.
            conflict_mode (ConflictMode): See `vectorbt.portfolio.enums.ConflictMode`.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            freq (any): Index frequency in case `close.index` is not datetime-like.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        All time series will be broadcast together using `vectorbt.base.reshape_fns.broadcast`.
        At the end, they will have the same metadata.

        For defaults, see `vectorbt.defaults.portfolio`.

        !!! note
            Only `SizeType.Shares` is supported. Other modes such as target percentage are not
            compatible with signals since their logic may contradict the direction the user has
            specified for the order.

            With cash sharing enabled, at each timestamp, processing of the assets in a group
            goes strictly in order defined in `call_seq`. This order can&#39;t be changed dynamically.

        !!! hint
            If you generated signals using close price, don&#39;t forget to shift your signals by one tick
            forward, for example, with `signals.vbt.fshift(1)`. In general, make sure to use a price
            that comes after the signal.

        Example:
            Different ways of how signals are interpreted:

            ```python-repl
            &gt;&gt;&gt; import numpy as np
            &gt;&gt;&gt; import pandas as pd
            &gt;&gt;&gt; from datetime import datetime
            &gt;&gt;&gt; import vectorbt as vbt
            &gt;&gt;&gt; from vectorbt.portfolio.enums import AccumulateExitMode, ConflictMode

            &gt;&gt;&gt; price = pd.Series([1., 2., 3., 4., 5.], index=pd.Index([
            ...     datetime(2020, 1, 1),
            ...     datetime(2020, 1, 2),
            ...     datetime(2020, 1, 3),
            ...     datetime(2020, 1, 4),
            ...     datetime(2020, 1, 5)
            ... ]))
            &gt;&gt;&gt; entries = pd.Series([True, True, True, False, False])
            &gt;&gt;&gt; exits = pd.Series([False, False, True, True, True])

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
            ...     price, entries, exits, size=1.)
            &gt;&gt;&gt; portfolio.share_flow()
            2020-01-01    1.0
            2020-01-02    0.0
            2020-01-03    0.0
            2020-01-04   -1.0
            2020-01-05    0.0
            dtype: float64

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
            ...     price, entries, exits, size=1.,
            ...     conflict_mode=ConflictMode.Exit)
            &gt;&gt;&gt; portfolio.share_flow()
            2020-01-01    1.0
            2020-01-02    0.0
            2020-01-03   -1.0
            2020-01-04    0.0
            2020-01-05    0.0
            dtype: float64

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
            ...     price, entries, exits, size=1.,
            ...     accumulate=True)
            &gt;&gt;&gt; portfolio.share_flow()
            2020-01-01    1.0
            2020-01-02    1.0
            2020-01-03    0.0
            2020-01-04   -2.0
            2020-01-05    0.0
            dtype: float64

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
            ...     price, entries, exits, size=1.,
            ...     accumulate=True,
            ...     accumulate_exit_mode=AccumulateExitMode.Reduce)
            &gt;&gt;&gt; portfolio.share_flow()  # same as using from_orders
            2020-01-01    1.0
            2020-01-02    1.0
            2020-01-03    0.0
            2020-01-04   -1.0
            2020-01-05   -1.0
            dtype: float64
            ```
        &#34;&#34;&#34;
        # Get defaults
        if size is None:
            size = defaults.portfolio[&#39;size&#39;]
        if entry_price is None:
            entry_price = close
        if exit_price is None:
            exit_price = close
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]
        if reject_prob is None:
            reject_prob = defaults.portfolio[&#39;reject_prob&#39;]
        if min_size is None:
            min_size = defaults.portfolio[&#39;min_size&#39;]
        if init_cash is None:
            init_cash = defaults.portfolio[&#39;init_cash&#39;]
            if isinstance(init_cash, str):
                init_cash = getattr(InitCashMode, init_cash)
        if isinstance(init_cash, int):
            checks.assert_in(init_cash, InitCashMode)
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = defaults.portfolio[&#39;cash_sharing&#39;]
        if call_seq is None:
            call_seq = defaults.portfolio[&#39;call_seq&#39;]
            if isinstance(call_seq, str):
                call_seq = getattr(CallSeqType, call_seq)
        if isinstance(call_seq, int):
            checks.assert_in(call_seq, CallSeqType)
            if call_seq == CallSeqType.Auto:
                raise ValueError(&#34;This method doesn&#39;t support CallSeqType.Auto&#34;)
        if accumulate is None:
            accumulate = defaults.portfolio[&#39;accumulate&#39;]
        if accumulate_exit_mode is None:
            accumulate_exit_mode = defaults.portfolio[&#39;accumulate_exit_mode&#39;]
            if isinstance(accumulate_exit_mode, str):
                accumulate_exit_mode = getattr(AccumulateExitMode, accumulate_exit_mode)
        checks.assert_in(accumulate_exit_mode, AccumulateExitMode)
        if conflict_mode is None:
            conflict_mode = defaults.portfolio[&#39;conflict_mode&#39;]
            if isinstance(conflict_mode, str):
                conflict_mode = getattr(ConflictMode, conflict_mode)
        checks.assert_in(conflict_mode, ConflictMode)
        if seed is None:
            seed = defaults.portfolio[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = defaults.portfolio[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Perform checks
        checks.assert_type(close, (pd.Series, pd.DataFrame))
        checks.assert_subdtype(close, np.floating)
        checks.assert_dtype(entries, np.bool)
        checks.assert_dtype(exits, np.bool)
        checks.assert_subdtype(size, np.floating)
        checks.assert_subdtype(entry_price, np.floating)
        checks.assert_subdtype(exit_price, np.floating)
        checks.assert_subdtype(fees, np.floating)
        checks.assert_subdtype(fixed_fees, np.floating)
        checks.assert_subdtype(slippage, np.floating)
        checks.assert_subdtype(reject_prob, np.floating)
        checks.assert_subdtype(min_size, np.floating)
        checks.assert_subdtype(init_cash, np.floating)
        checks.assert_subdtype(call_seq, np.integer)

        # Broadcast inputs
        # Only close is broadcast, others can remain unchanged thanks to flexible indexing
        keep_raw = (False, True, True, True, True, True, True, True, True, True, True)
        broadcast_kwargs = merge_kwargs(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
        close, entries, exits, size, entry_price, exit_price, fees, fixed_fees, slippage, reject_prob = \
            broadcast(close, entries, exits, size, entry_price, exit_price, fees, fixed_fees,
                slippage, reject_prob, **broadcast_kwargs, keep_raw=keep_raw)
        target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
        min_size = np.require(np.broadcast_to(min_size, (target_shape_2d[1],)), requirements=&#39;W&#39;)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_counts = wrapper.grouper.get_group_counts(group_by=cash_sharing)
        init_cash = np.broadcast_to(init_cash, (len(cs_group_counts),))
        group_counts = wrapper.grouper.get_group_counts(group_by=group_by)
        if checks.is_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_counts, call_seq_type=call_seq)

        # Perform calculation
        order_records = nb.simulate_from_signals_nb(
            target_shape_2d,
            cs_group_counts,  # group only if cash sharing is enabled to speed up
            init_cash,
            call_seq,
            entries,
            exits,
            size,
            entry_price,
            exit_price,
            fees,
            fixed_fees,
            slippage,
            reject_prob,
            min_size,
            accumulate,
            accumulate_exit_mode,
            conflict_mode,
            close.ndim == 2
        )

        # Create an instance
        orders = Orders(wrapper, order_records, close)
        return cls(
            orders,
            init_cash,
            cash_sharing,
            call_seq,
            init_cash_mode=init_cash_mode,
            **kwargs
        )

    @classmethod
    def from_orders(cls, close, order_size, size_type=None, order_price=None, fees=None, fixed_fees=None,
                    slippage=None, reject_prob=None, min_size=None, init_cash=None, cash_sharing=None,
                    call_seq=None, val_price=None, freq=None, seed=None, group_by=None, broadcast_kwargs=None,
                    wrapper_kwargs=None, **kwargs):
        &#34;&#34;&#34;Simulate portfolio from orders.

        Starting with initial cash `init_cash`, orders the number of shares specified in `order_size`
        for `order_price`.

        Args:
            close (pandas_like): Reference price, such as close. Will broadcast.

                Will be used for calculating unrealized P&amp;L and portfolio value.
            order_size (float or array_like): Size to order. Will broadcast.

                For any size type:

                * Set to `np.nan` to skip.
                * Set to `np.inf`/`-np.inf` to buy/sell everything.

                For `SizeType.Shares`:

                * Set to positive/negative to buy/sell.
                * Set to zero to skip.

                For target size, the final size will depend upon current holdings.
            size_type (SizeType or array_like): See `vectorbt.portfolio.enums.SizeType`.
            order_price (array_like of float): Order price. Defaults to `close`. Will broadcast.

                !!! note
                    Setting order price to close is risky.
            fees (float or array_like): Fees in percentage of the order value. Will broadcast.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order. Will broadcast.
            slippage (float or array_like): Slippage in percentage of price. Will broadcast.
            reject_prob (float or array_like): Order rejection probability. Will broadcast.
            min_size (float or array_like): Minimum size for an order to be accepted.

                Will broadcast to the number of columns.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                By default, will broadcast to the number of columns.
                If cash sharing is enabled, will broadcast to the number of groups.
                See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

                !!! note
                    Make sure that `init_cash` is a floating number if not using `InitCashMode`.
            cash_sharing (bool): Whether to share cash within the same group.

                !!! warning
                    Order execution cannot be considered parallel anymore.

                    This method presumes that in a group of assets that share the same capital all
                    orders will be executed within the same tick and retain their price regardless
                    of their position in the queue, even though they depend upon each other and thus
                    cannot be executed in parallel. This behavior is risky.
            call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

                * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
                * Set to array to specify custom sequence. Will not broadcast.

                If `CallSeqType.Auto` selected, rearranges calls dynamically based on order value.
                Calculates value of all orders per row and group, and sorts them by this value.
                Sell orders will be executed first to release funds for buy orders.

                !!! warning
                    `CallSeqType.Auto` should be used with caution:

                    * It not only presumes that order prices are known beforehand, but also that
                        orders can be executed in arbitrary order and still retain their price.
                        In reality, this is hardly the case: after processing one asset, some time
                        has passed and the price for other assets might have already changed.
                    * Even if you&#39;re able to specify a slippage large enough to compensate for
                        this behavior, slippage itself should depend upon execution order.
                        This method doesn&#39;t let you do that.
                    * If one order is rejected, it still will execute next orders and possibly
                        leave them without funds that could have been released by the first order.

                    For more control, use `Portfolio.from_order_func`.
            val_price (array_like of float): Size valuation price. Defaults to previous `close`.
                Will broadcast.

                Used to calculate `SizeType.TargetPercent` and `SizeType.TargetValue`.

                !!! note
                    Make sure to use timestamp for `val_price` that comes before timestamps of all orders
                    in the group with cash sharing, otherwise you&#39;re cheating yourself.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            freq (any): Index frequency in case `close.index` is not datetime-like.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.

        All time series will be broadcast together using `vectorbt.base.reshape_fns.broadcast`.
        At the end, they will have the same metadata.

        For defaults, see `vectorbt.defaults.portfolio`.

        !!! note
            When `call_seq` is not `CallSeqType.Auto`, at each timestamp, processing of the assets in
            a group goes strictly in order defined in `call_seq`. This order can&#39;t be changed dynamically.

            This has one big implication for this particular method: the last asset in the call stack
            cannot be processed until other assets are processed. This is the reason why rebalancing
            cannot work properly in this setting: one has to specify percentages for all assets beforehand
            and then tweak the processing order to sell to-be-sold assets first in order to release funds
            for to-be-bought assets. This can be automatically done by using `CallSeqType.Auto`.

        Example:
            The same equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb`.
            It&#39;s more compact but has no control over how order of execution impacts order price.

            ```python-repl
            &gt;&gt;&gt; import numpy as np
            &gt;&gt;&gt; import pandas as pd
            &gt;&gt;&gt; import vectorbt as vbt
            &gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, CallSeqType

            &gt;&gt;&gt; np.random.seed(42)
            &gt;&gt;&gt; price = pd.DataFrame(np.random.uniform(1, 10, size=(5, 3)))
            &gt;&gt;&gt; orders = pd.DataFrame(np.full((5, 3), 1.) / 3)  # each column 33.3%
            &gt;&gt;&gt; orders[1::2] = np.nan  # skip every second tick

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
            ...     price,  # reference price for portfolio value
            ...     orders,
            ...     order_price=price,  # order price
            ...     size_type=SizeType.TargetPercent,
            ...     val_price=price,  # order price known beforehand (don&#39;t do it)
            ...     call_seq=CallSeqType.Auto,  # first sell then buy
            ...     group_by=np.array([0, 0, 0]),
            ...     cash_sharing=True,
            ...     fees=0.001, fixed_fees=1., slippage=0.001
            ... )

            &gt;&gt;&gt; portfolio.holding_value(group_by=False)
                       0          1          2
            0  33.333333  33.333333  30.139624
            1  48.716002   8.385865   9.548589
            2  19.546625  22.584433  22.584433
            3  94.638155   3.043394  34.278783
            4  41.923304  38.661499  41.923304
            ```
        &#34;&#34;&#34;
        # Get defaults
        if order_size is None:
            order_size = defaults.portfolio[&#39;order_size&#39;]
        if size_type is None:
            size_type = defaults.portfolio[&#39;size_type&#39;]
            if isinstance(size_type, str):
                size_type = getattr(SizeType, size_type)
        if order_price is None:
            order_price = close
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]
        if reject_prob is None:
            reject_prob = defaults.portfolio[&#39;reject_prob&#39;]
        if min_size is None:
            min_size = defaults.portfolio[&#39;min_size&#39;]
        if init_cash is None:
            init_cash = defaults.portfolio[&#39;init_cash&#39;]
            if isinstance(init_cash, str):
                init_cash = getattr(InitCashMode, init_cash)
        if isinstance(init_cash, int):
            checks.assert_in(init_cash, InitCashMode)
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = defaults.portfolio[&#39;cash_sharing&#39;]
        if call_seq is None:
            call_seq = defaults.portfolio[&#39;call_seq&#39;]
            if isinstance(call_seq, str):
                call_seq = getattr(CallSeqType, call_seq)
        auto_call_seq = False
        if isinstance(call_seq, int):
            checks.assert_in(call_seq, CallSeqType)
            if call_seq == CallSeqType.Auto:
                call_seq = CallSeqType.Default
                auto_call_seq = True
        if val_price is None:
            val_price = close.vbt.fshift(1)
        if seed is None:
            seed = defaults.portfolio[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = defaults.portfolio[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Perform checks
        checks.assert_type(close, (pd.Series, pd.DataFrame))
        checks.assert_subdtype(close, np.floating)
        checks.assert_subdtype(order_size, np.floating)
        checks.assert_subdtype(size_type, np.integer)
        checks.assert_subdtype(order_price, np.floating)
        checks.assert_subdtype(fees, np.floating)
        checks.assert_subdtype(fixed_fees, np.floating)
        checks.assert_subdtype(slippage, np.floating)
        checks.assert_subdtype(reject_prob, np.floating)
        checks.assert_subdtype(min_size, np.floating)
        checks.assert_subdtype(init_cash, np.floating)
        checks.assert_subdtype(call_seq, np.integer)
        checks.assert_subdtype(val_price, np.floating)

        # Broadcast inputs
        # Only close is broadcast, others can remain unchanged thanks to flexible indexing
        keep_raw = (False, True, True, True, True, True, True, True, True, True)
        broadcast_kwargs = merge_kwargs(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
        close, order_size, size_type, order_price, fees, fixed_fees, slippage, reject_prob, val_price = \
            broadcast(close, order_size, size_type, order_price, fees, fixed_fees, slippage,
                      reject_prob, val_price, **broadcast_kwargs, keep_raw=keep_raw)
        target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
        min_size = np.require(np.broadcast_to(min_size, (target_shape_2d[1],)), requirements=&#39;W&#39;)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_counts = wrapper.grouper.get_group_counts(group_by=cash_sharing)
        init_cash = np.broadcast_to(init_cash, (len(cs_group_counts),))
        group_counts = wrapper.grouper.get_group_counts(group_by=group_by)
        if checks.is_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_counts, call_seq_type=call_seq)

        # Perform calculation
        order_records = nb.simulate_from_orders_nb(
            target_shape_2d,
            cs_group_counts,  # group only if cash sharing is enabled to speed up
            init_cash,
            call_seq,
            order_size,
            size_type,
            order_price,
            fees,
            fixed_fees,
            slippage,
            reject_prob,
            min_size,
            val_price,
            auto_call_seq,
            close.ndim == 2
        )

        # Create an instance
        orders = Orders(wrapper, order_records, close)
        return cls(
            orders,
            init_cash,
            cash_sharing,
            call_seq,
            init_cash_mode=init_cash_mode,
            **kwargs
        )

    @classmethod
    def from_order_func(cls, close, order_func_nb, *order_args, target_shape=None, keys=None,
                        init_cash=None, cash_sharing=None, call_seq=None, active_mask=None, min_size=None,
                        prep_func_nb=None, prep_args=None, group_prep_func_nb=None, group_prep_args=None,
                        row_prep_func_nb=None, row_prep_args=None, segment_prep_func_nb=None,
                        segment_prep_args=None, row_wise=None, seed=None, freq=None, group_by=None,
                        broadcast_kwargs=None, wrapper_kwargs=None, **kwargs):
        &#34;&#34;&#34;Build portfolio from a custom order function.

        For details, see `vectorbt.portfolio.nb.simulate_nb`.

        if `row_wise` is `True`, also see `vectorbt.portfolio.nb.simulate_row_wise_nb`.

        Args:
            close (pandas_like): Reference price, such as close. Will broadcast to `target_shape`.

                Will be used for calculating unrealized P&amp;L and portfolio value.

                Previous `close` will also be used for valuating assets/groups during the simulation.
            order_func_nb (callable): Order generation function.
            *order_args: Arguments passed to `order_func_nb`.
            target_shape (tuple): Target shape to iterate over. Defaults to `close.shape`.
            keys (sequence): Outermost column level.

                Each element should correspond to one iteration over columns in `close`.
                Should be set only if `target_shape` is bigger than `close.shape`.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                By default, will broadcast to the number of columns.
                If cash sharing is enabled, will broadcast to the number of groups.
                See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

                !!! note
                    Make sure that `init_cash` is a floating number if not using `InitCashMode`.
            cash_sharing (bool): Whether to share cash within the same group.

                !!! warning
                    Order execution cannot be considered parallel anymore.
            call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

                * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
                * Set to array to specify custom sequence. Will not broadcast.
            active_mask (bool or array_like): Mask of whether a particular segment should be executed.

                By default, will broadcast to the number of rows and groups.
            min_size (float or array_like): Minimum size for an order to be accepted.

                Will broadcast to the number of columns.
            prep_func_nb (callable): Simulation preparation function.
            prep_args (tuple): Packed arguments passed to `prep_func_nb`.

                Defaults to `()`.
            group_prep_func_nb (callable): Group preparation function.

                Called only if `row_wise` is `False`.
            group_prep_args (tuple): Packed arguments passed to `group_prep_func_nb`.

                Defaults to `()`.
            row_prep_func_nb (callable): Row preparation function.

                Called only if `row_wise` is `True`.
            row_prep_args (tuple): Packed arguments passed to `row_prep_func_nb`.

                Defaults to `()`.
            segment_prep_func_nb (callable): Segment preparation function.
            segment_prep_args (tuple): Packed arguments passed to `segment_prep_func_nb`.

                Defaults to `()`.
            row_wise (bool): Whether to iterate over rows rather than columns/groups.

                See `vectorbt.portfolio.nb.simulate_row_wise_nb`.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            freq (any): Index frequency in case `close.index` is not datetime-like.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        !!! note
            All passed functions should be Numba-compiled.

            Objects passed as arguments to both functions will not broadcast to `target_shape`
            as their purpose is unknown. You should broadcast manually or use flexible indexing.

            Also see notes on `Portfolio.from_orders`.
        &#34;&#34;&#34;
        # Get defaults
        if target_shape is None:
            target_shape = close.shape
        if init_cash is None:
            init_cash = defaults.portfolio[&#39;init_cash&#39;]
            if isinstance(init_cash, str):
                init_cash = getattr(InitCashMode, init_cash)
        if isinstance(init_cash, int):
            checks.assert_in(init_cash, InitCashMode)
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = defaults.portfolio[&#39;cash_sharing&#39;]
        if call_seq is None:
            call_seq = defaults.portfolio[&#39;call_seq&#39;]
            if isinstance(call_seq, str):
                call_seq = getattr(CallSeqType, call_seq)
        if isinstance(call_seq, int):
            checks.assert_in(call_seq, CallSeqType)
            if call_seq == CallSeqType.Auto:
                raise ValueError(&#34;CallSeqType.Auto should be implemented manually.&#34;
                                 &#34;Use auto_call_seq_ctx_nb in segment_prep_func_nb.&#34;)
        if active_mask is None:
            active_mask = True
        if min_size is None:
            min_size = defaults.portfolio[&#39;min_size&#39;]
        if row_wise is None:
            row_wise = defaults.portfolio[&#39;row_wise&#39;]
        if seed is None:
            seed = defaults.portfolio[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = defaults.portfolio[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        require_kwargs = dict(require_kwargs=dict(requirements=&#39;W&#39;))
        broadcast_kwargs = merge_kwargs(require_kwargs, broadcast_kwargs)
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Perform checks
        checks.assert_type(close, (pd.Series, pd.DataFrame))
        checks.assert_subdtype(close, np.floating)
        checks.assert_subdtype(init_cash, np.floating)
        checks.assert_subdtype(call_seq, np.integer)

        # Broadcast inputs
        target_shape_2d = (target_shape[0], target_shape[1] if len(target_shape) &gt; 1 else 1)
        if close.shape != target_shape:
            if len(close.vbt.columns) &lt;= target_shape_2d[1]:
                if target_shape_2d[1] % len(close.vbt.columns) != 0:
                    raise ValueError(&#34;Cannot broadcast close to target_shape&#34;)
                if keys is None:
                    keys = pd.Index(np.arange(target_shape_2d[1]), name=&#39;iteration_idx&#39;)
                tile_times = target_shape_2d[1] // len(close.vbt.columns)
                close = close.vbt.tile(tile_times, keys=keys)
        close = broadcast(close, to_shape=target_shape, **broadcast_kwargs)
        min_size = np.require(np.broadcast_to(min_size, (target_shape_2d[1],)), requirements=&#39;W&#39;)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_counts = wrapper.grouper.get_group_counts(group_by=cash_sharing)
        init_cash = np.broadcast_to(init_cash, (len(cs_group_counts),))
        group_counts = wrapper.grouper.get_group_counts(group_by=group_by)
        active_mask = broadcast(
            active_mask,
            to_shape=(target_shape_2d[0], len(group_counts)),
            to_pd=False,
            **require_kwargs
        )
        if checks.is_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_counts, call_seq_type=call_seq)

        # Prepare arguments
        if prep_func_nb is None:
            prep_func_nb = nb.empty_prep_nb
        if prep_args is None:
            prep_args = ()
        if group_prep_func_nb is None:
            group_prep_func_nb = nb.empty_prep_nb
        if group_prep_args is None:
            group_prep_args = ()
        if row_prep_func_nb is None:
            row_prep_func_nb = nb.empty_prep_nb
        if row_prep_args is None:
            row_prep_args = ()
        if segment_prep_func_nb is None:
            segment_prep_func_nb = nb.empty_prep_nb
        if segment_prep_args is None:
            segment_prep_args = ()

        prep_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in prep_args])
        group_prep_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in group_prep_args])
        row_prep_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in row_prep_args])
        segment_prep_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in segment_prep_args])
        order_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in order_args])

        # Perform calculation
        if row_wise:
            order_records = nb.simulate_row_wise_nb(
                target_shape_2d,
                to_2d(close, raw=True),
                group_counts,
                init_cash,
                cash_sharing,
                call_seq,
                active_mask,
                min_size,
                prep_func_nb,
                prep_args,
                row_prep_func_nb,
                row_prep_args,
                segment_prep_func_nb,
                segment_prep_args,
                order_func_nb,
                order_args
            )
        else:
            order_records = nb.simulate_nb(
                target_shape_2d,
                to_2d(close, raw=True),
                group_counts,
                init_cash,
                cash_sharing,
                call_seq,
                active_mask,
                min_size,
                prep_func_nb,
                prep_args,
                group_prep_func_nb,
                group_prep_args,
                segment_prep_func_nb,
                segment_prep_args,
                order_func_nb,
                order_args
            )

        # Create an instance
        orders = Orders(wrapper, order_records, close)
        return cls(
            orders,
            init_cash,
            cash_sharing,
            call_seq,
            init_cash_mode=init_cash_mode,
            **kwargs
        )

    # ############# Properties ############# #

    @property
    def wrapper(self):
        &#34;&#34;&#34;Array wrapper.&#34;&#34;&#34;
        # Wrapper in orders and here can be different
        wrapper = self.orders.wrapper
        if self.cash_sharing and wrapper.grouper.allow_modify:
            # Cannot change groups if columns within them are dependent
            return wrapper.copy(allow_modify=False)
        return wrapper.copy()

    @property
    def cash_sharing(self):
        &#34;&#34;&#34;Whether to share cash within the same group.&#34;&#34;&#34;
        return self._cash_sharing

    @property
    def call_seq(self):
        &#34;&#34;&#34;Sequence of calls per row and group.&#34;&#34;&#34;
        return self.wrapper.wrap(self._call_seq, group_by=False)

    @property
    def init_cash_mode(self):
        &#34;&#34;&#34;Initial cash mode.&#34;&#34;&#34;
        return self._init_cash_mode

    @property
    def incl_unrealized(self):
        &#34;&#34;&#34;Whether to include unrealized trade P&amp;L in statistics.&#34;&#34;&#34;
        return self._incl_unrealized

    # ############# Regrouping ############# #

    def regroup(self, group_by):
        &#34;&#34;&#34;Regroup this object.&#34;&#34;&#34;
        if self.cash_sharing:
            raise ValueError(&#34;Cannot change grouping globally when cash sharing is enabled&#34;)
        if self.wrapper.grouper.is_grouping_changed(group_by=group_by):
            self.wrapper.grouper.check_group_by(group_by=group_by)
            return self.copy(orders=self.orders.regroup(group_by=group_by))
        return self

    # ############# Reference price ############# #

    @property
    def close(self):
        &#34;&#34;&#34;Price per share series.&#34;&#34;&#34;
        return self._ref_price

    @cached_method
    def fill_close(self, ffill=True, bfill=True):
        &#34;&#34;&#34;Fill NaN values of `Portfolio.close`.

        Use `ffill` and `bfill` to fill forwards and backwards respectively.&#34;&#34;&#34;
        close = to_2d(self.close, raw=True)
        if ffill and np.any(np.isnan(close[-1, :])):
            close = generic_nb.ffill_nb(close)
        if bfill and np.any(np.isnan(close[0, :])):
            close = generic_nb.ffill_nb(close[::-1, :])[::-1, :]
        return self.wrapper.wrap(close, group_by=False)

    # ############# Cash ############# #

    @property
    def init_cash(self):
        &#34;&#34;&#34;Initial amount of cash per column/group.

        Returns value per group if `cash_sharing` is `True`.&#34;&#34;&#34;
        if self.init_cash_mode is None:
            init_cash = self._init_cash
        else:
            cash_flow = to_2d(self.cash_flow(group_by=self.cash_sharing), raw=True)
            init_cash = -np.min(np.cumsum(cash_flow, axis=0), axis=0)
            if self.init_cash_mode == InitCashMode.AutoAlign:
                init_cash = np.full(init_cash.shape, np.max(init_cash))
        return self.wrapper.wrap_reduced(init_cash, group_by=self.cash_sharing)

    @cached_method
    def init_cash_regrouped(self, group_by=None):
        &#34;&#34;&#34;Get cash flow series per column/group.&#34;&#34;&#34;
        init_cash = to_1d(self.init_cash, raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
            init_cash_regrouped = nb.init_cash_grouped_nb(init_cash, group_counts, self.cash_sharing)
        else:
            group_counts = self.wrapper.grouper.get_group_counts()
            init_cash_regrouped = nb.init_cash_ungrouped_nb(init_cash, group_counts, self.cash_sharing)
        return self.wrapper.wrap_reduced(init_cash_regrouped, group_by=group_by)

    @cached_method
    def cash_flow(self, group_by=None):
        &#34;&#34;&#34;Get cash flow series per column/group.&#34;&#34;&#34;
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            cash_flow_ungrouped = to_2d(self.cash_flow(group_by=False), raw=True)
            group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
            cash_flow = nb.cash_flow_grouped_nb(cash_flow_ungrouped, group_counts)
        else:
            cash_flow = nb.cash_flow_ungrouped_nb(self.wrapper.shape_2d, self.orders.records_arr)
        return self.wrapper.wrap(cash_flow, group_by=group_by)

    @cached_method
    def cash(self, group_by=None, in_sim_order=False):
        &#34;&#34;&#34;Get cash series per column/group.&#34;&#34;&#34;
        if in_sim_order and not self.cash_sharing:
            raise ValueError(&#34;in_sim_order requires enabled cash sharing&#34;)

        cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            init_cash_grouped = to_1d(self.init_cash_regrouped(group_by=group_by), raw=True)
            group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
            cash = nb.cash_grouped_nb(
                self.wrapper.shape_2d,
                cash_flow,
                group_counts,
                init_cash_grouped
            )
        else:
            init_cash = to_1d(self.init_cash, raw=True)
            group_counts = self.wrapper.grouper.get_group_counts()
            call_seq = to_2d(self.call_seq, raw=True)
            cash = nb.cash_ungrouped_nb(
                cash_flow,
                group_counts,
                init_cash,
                self.cash_sharing,
                call_seq,
                in_sim_order
            )
        return self.wrapper.wrap(cash, group_by=group_by)

    # ############# Shares ############# #

    @cached_method
    def share_flow(self):
        &#34;&#34;&#34;Get share flow series per column.&#34;&#34;&#34;
        share_flow = nb.share_flow_nb(self.wrapper.shape_2d, self.orders.records_arr)
        return self.wrapper.wrap(share_flow, group_by=False)

    @cached_method
    def shares(self):
        &#34;&#34;&#34;Get share series per column.&#34;&#34;&#34;
        share_flow = to_2d(self.share_flow(), raw=True)
        shares = nb.shares_nb(share_flow)
        return self.wrapper.wrap(shares, group_by=False)

    # ############# Records ############# #

    @property
    def orders(self):
        &#34;&#34;&#34;Order records.

        See `vectorbt.records.orders.Orders`.&#34;&#34;&#34;
        return self._orders

    @cached_method
    def orders_regrouped(self, group_by=None):
        &#34;&#34;&#34;Regroup order records.

        See `vectorbt.records.orders.Orders`.&#34;&#34;&#34;
        return self._orders.regroup(group_by=group_by)

    @cached_method
    def trades(self, group_by=None, incl_unrealized=None):
        &#34;&#34;&#34;Get trade records from orders.

        See `vectorbt.records.events.Trades`.&#34;&#34;&#34;
        trades = Trades.from_orders(self.orders_regrouped(group_by=group_by))
        if incl_unrealized is None:
            incl_unrealized = self.incl_unrealized
        if incl_unrealized:
            return trades
        return trades.closed

    @cached_method
    def positions(self, group_by=None, incl_unrealized=None):
        &#34;&#34;&#34;Get position records from orders.

        See `vectorbt.records.events.Positions`.&#34;&#34;&#34;
        positions = Positions.from_orders(self.orders_regrouped(group_by=group_by))
        if incl_unrealized is None:
            incl_unrealized = self.incl_unrealized
        if incl_unrealized:
            return positions
        return positions.closed

    @cached_method
    def drawdowns(self, **kwargs):
        &#34;&#34;&#34;Get drawdown records from `Portfolio.value`.

        See `vectorbt.records.drawdowns.Drawdowns`.&#34;&#34;&#34;
        return Drawdowns.from_ts(self.value(**kwargs), freq=self.wrapper.freq)

    # ############# Performance ############# #

    @cached_method
    def holding_value(self, group_by=None):
        &#34;&#34;&#34;Get holding value series per column/group.&#34;&#34;&#34;
        close = to_2d(self.close, raw=True).copy()
        shares = to_2d(self.shares(), raw=True)
        close[shares == 0.] = 0.  # for price being NaN
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
            holding_value = nb.holding_value_grouped_nb(close, shares, group_counts)
        else:
            holding_value = nb.holding_value_ungrouped_nb(close, shares)
        return self.wrapper.wrap(holding_value, group_by=group_by)

    @cached_method
    def value(self, group_by=None, in_sim_order=False):
        &#34;&#34;&#34;Get portfolio value series per column/group.

        By default, will generate portfolio value for each asset based on cash flows and thus
        independent from other assets, with initial cash and shares being that of the entire group.
        Useful for generating returns and comparing assets within the same group.

        When `group_by` is `False` and `in_sim_order` is `True`, returns value generated in
        simulation order (see [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
        This value cannot be used for generating returns as-is. Useful to analyze how value
        evolved throughout simulation.&#34;&#34;&#34;
        cash = to_2d(self.cash(group_by=group_by, in_sim_order=in_sim_order), raw=True)
        holding_value = to_2d(self.holding_value(group_by=group_by), raw=True)
        if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
            group_counts = self.wrapper.grouper.get_group_counts()
            call_seq = to_2d(self.call_seq, raw=True)
            value = nb.value_in_sim_order_nb(cash, holding_value, group_counts, call_seq)
            # price of NaN is already addressed by ungrouped_value_nb
        else:
            value = nb.value_nb(cash, holding_value)
        return self.wrapper.wrap(value, group_by=group_by)

    @cached_method
    def final_value(self, group_by=None):
        &#34;&#34;&#34;Get final portfolio value per column/group.

        Calculated directly from order records. Very fast.&#34;&#34;&#34;
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            final_value_ungrouped = to_1d(self.final_value(group_by=False), raw=True)
            init_cash = to_1d(self.init_cash, raw=True)
            group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
            final_value = nb.final_value_grouped_nb(
                final_value_ungrouped,
                init_cash,
                group_counts,
                self.cash_sharing
            )
        else:
            close = to_2d(self.fill_close(), raw=True)
            init_cash_ungrouped = to_1d(self.init_cash_regrouped(group_by=False), raw=True)
            final_value = nb.final_value_ungrouped_nb(
                self.wrapper.shape_2d,
                close,
                self.orders.records_arr,
                init_cash_ungrouped
            )
        return self.wrapper.wrap_reduced(final_value, group_by=group_by)

    @cached_method
    def total_profit(self, group_by=None):
        &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
        init_cash_regrouped = to_1d(self.init_cash_regrouped(group_by=group_by), raw=True)
        final_value = to_1d(self.final_value(group_by=group_by), raw=True)
        total_profit = nb.total_profit_nb(init_cash_regrouped, final_value)
        return self.wrapper.wrap_reduced(total_profit, group_by=group_by)

    @cached_method
    def total_return(self, group_by=None):
        &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
        init_cash_regrouped = to_1d(self.init_cash_regrouped(group_by=group_by), raw=True)
        final_value = to_1d(self.final_value(group_by=group_by), raw=True)
        total_return = nb.total_return_nb(init_cash_regrouped, final_value)
        return self.wrapper.wrap_reduced(total_return, group_by=group_by)

    @cached_method
    def buy_and_hold_return(self, group_by=None):
        &#34;&#34;&#34;Get total return of buy-and-hold.

        If grouped, invests same amount of cash into each asset and returns the total
        return of the entire group.

        !!! note
            Does not take into account fees and slippage. For this, create a separate portfolio.&#34;&#34;&#34;
        ref_price_filled = to_2d(self.fill_close(), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
            total_return = nb.buy_and_hold_return_grouped_nb(ref_price_filled, group_counts)
        else:
            total_return = nb.buy_and_hold_return_ungrouped_nb(ref_price_filled)
        return self.wrapper.wrap_reduced(total_return, group_by=group_by)

    @cached_method
    def active_returns(self, group_by=None):
        &#34;&#34;&#34;Get active return series per column/group.

        This type of returns is based solely on cash flows and holding value rather than portfolio value.
        It ignores passive cash and thus it will return the same numbers irrespective of the amount of
        cash currently available, even `np.inf`. The scale of returns is comparable to that of going
        all in and keeping available cash at zero.&#34;&#34;&#34;
        cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
        holding_value = to_2d(self.holding_value(group_by=group_by), raw=True)
        active_returns = nb.active_returns_nb(cash_flow, holding_value)
        return self.wrapper.wrap(active_returns, group_by=group_by)

    @cached_method
    def returns(self, group_by=None, in_sim_order=False):
        &#34;&#34;&#34;Get return series per column/group based on portfolio value.&#34;&#34;&#34;
        value = to_2d(self.value(group_by=group_by, in_sim_order=in_sim_order), raw=True)
        if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
            group_counts = self.wrapper.grouper.get_group_counts()
            init_cash = to_1d(self.init_cash, raw=True)
            call_seq = to_2d(self.call_seq, raw=True)
            returns = nb.returns_in_sim_order_nb(value, group_counts, init_cash, call_seq)
        else:
            init_cash_regrouped = to_1d(self.init_cash_regrouped(group_by=group_by), raw=True)
            returns = nb.returns_nb(value, init_cash_regrouped)
        return self.wrapper.wrap(returns, group_by=group_by)

    @cached_method
    def stats(self, column=None, group_by=None, incl_unrealized=None, active_returns=False,
              agg_func=np.mean, **kwargs):
        &#34;&#34;&#34;Compute various statistics on this portfolio.

        `kwargs` will be passed to each `vectorbt.returns.accessors.Returns_Accessor` method.

        Can either return aggregated statistics by reducing metrics of all columns with
        `agg_func` (mean by default) or return statistics for a single column if `column`
        was specified or portfolio contains only one column of data. To display rich data types
        such as durations correctly, use an aggregation function that can be applied on `pd.Series`.

        !!! note
            Use `column` only if caching is enabled, otherwise it may re-compute the same
            objects multiple times.&#34;&#34;&#34;
        def _reduce(obj):
            if checks.is_series(obj):
                if column is not None:
                    return obj[column]
                return agg_func(obj)
            return obj

        # Pre-calculate
        positions = self.positions(group_by=group_by, incl_unrealized=incl_unrealized)
        trades = self.trades(group_by=group_by, incl_unrealized=incl_unrealized)
        drawdowns = self.drawdowns(group_by=group_by)
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)

        name = column
        if name is None:
            if self.wrapper.grouper.is_grouped(group_by=group_by):
                if self.wrapper.grouped_ndim == 1:
                    name = self.wrapper.grouper.get_columns(group_by=group_by)[0]
                else:
                    name = agg_func.__name__
            else:
                if self.wrapper.ndim == 1:
                    name = self.wrapper.name
                else:
                    name = agg_func.__name__
        return pd.Series({
            &#39;Start&#39;: self.wrapper.index[0],
            &#39;End&#39;: self.wrapper.index[-1],
            &#39;Duration&#39;: self.wrapper.shape[0] * self.wrapper.freq,
            &#39;Holding Duration [%]&#39;: _reduce(positions.coverage() * 100),
            &#39;Total Profit&#39;: _reduce(self.total_profit(group_by=group_by)),
            &#39;Total Return [%]&#39;: _reduce(self.total_return(group_by=group_by) * 100),
            &#39;Buy &amp; Hold Return [%]&#39;: _reduce(self.buy_and_hold_return(group_by=group_by) * 100),
            &#39;Max. Drawdown [%]&#39;: _reduce(-drawdowns.max_drawdown() * 100),
            &#39;Avg. Drawdown [%]&#39;: _reduce(-drawdowns.avg_drawdown() * 100),
            &#39;Max. Drawdown Duration&#39;: _reduce(drawdowns.max_duration()),
            &#39;Avg. Drawdown Duration&#39;: _reduce(drawdowns.avg_duration()),
            &#39;Num. Trades&#39;: _reduce(trades.count()),
            &#39;Win Rate [%]&#39;: _reduce(trades.win_rate() * 100),
            &#39;Best Trade [%]&#39;: _reduce(trades.returns.max() * 100),
            &#39;Worst Trade [%]&#39;: _reduce(trades.returns.min() * 100),
            &#39;Avg. Trade [%]&#39;: _reduce(trades.returns.mean() * 100),
            &#39;Max. Trade Duration&#39;: _reduce(trades.duration.max(time_units=True)),
            &#39;Avg. Trade Duration&#39;: _reduce(trades.duration.mean(time_units=True)),
            &#39;Expectancy&#39;: _reduce(trades.expectancy()),
            &#39;SQN&#39;: _reduce(trades.sqn()),
            &#39;Sharpe Ratio&#39;: _reduce(self.sharpe_ratio(reuse_returns=returns, **kwargs)),
            &#39;Sortino Ratio&#39;: _reduce(self.sortino_ratio(reuse_returns=returns, **kwargs)),
            &#39;Calmar Ratio&#39;: _reduce(self.calmar_ratio(reuse_returns=returns, **kwargs))
        }, name=name)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.portfolio.base.add_returns_methods"><code class="name flex">
<span>def <span class="ident fname">add_returns_methods</span></span>(<span>func_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Class decorator to add <code><a title="vectorbt.returns.accessors.Returns_Accessor" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor">Returns_Accessor</a></code> methods to <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_returns_methods(func_names):
    &#34;&#34;&#34;Class decorator to add `vectorbt.returns.accessors.Returns_Accessor` methods to `Portfolio`.&#34;&#34;&#34;

    def wrapper(cls):
        for func_name in func_names:
            if isinstance(func_name, tuple):
                ret_func_name = func_name[0]
            else:
                ret_func_name = func_name

            def returns_method(
                    self,
                    *args,
                    group_by=None,
                    year_freq=None,
                    ret_func_name=ret_func_name,
                    active_returns=False,
                    reuse_returns=None,
                    **kwargs):
                if reuse_returns is not None:
                    returns = reuse_returns
                else:
                    if active_returns:
                        returns = self.active_returns(group_by=group_by)
                    else:
                        returns = self.returns(group_by=group_by)
                returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
                # Select only those arguments in kwargs that are also in the method&#39;s signature
                # This is done for Portfolio.stats which passes the same kwargs to multiple methods
                method = getattr(returns_acc, ret_func_name)
                sig = signature(method)
                arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
                new_kwargs = {}
                for arg_name in arg_names:
                    if arg_name in kwargs:
                        new_kwargs[arg_name] = kwargs[arg_name]
                return method(*args, **new_kwargs)

            if isinstance(func_name, tuple):
                func_name = func_name[1]
            returns_method.__name__ = func_name
            returns_method.__qualname__ = f&#34;Portfolio.{func_name}&#34;
            returns_method.__doc__ = f&#34;See `vectorbt.returns.accessors.Returns_Accessor.{ret_func_name}`.&#34;
            setattr(cls, func_name, cached_method(returns_method))
        return cls

    return wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio"><code class="flex name class">
<span>class <span class="ident parent-fname">Portfolio</span></span>
<span>(</span><span>orders, init_cash, cash_sharing, call_seq, init_cash_mode=None, incl_unrealized=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for modeling portfolio and measuring its performance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>orders</code></strong> :&ensp;<code>Orders</code></dt>
<dd>Order records.</dd>
<dt><strong><code>init_cash</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Initial capital.</dd>
<dt><strong><code>cash_sharing</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to share cash within the same group.</dd>
<dt><strong><code>call_seq</code></strong> :&ensp;<code>array_like</code> of <code>int</code></dt>
<dd>Sequence of calls per row and group.</dd>
<dt><strong><code>init_cash_mode</code></strong> :&ensp;<code>InitCashMode</code> or <code>None</code></dt>
<dd>Initial cash mode.</dd>
<dt><strong><code>incl_unrealized</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to include unrealized P&amp;L in statistics.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use class methods with <code>from_</code> prefix to build a portfolio.
The <code>__init__</code> method is reserved for indexing purposes.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is meant to be immutable. To change any attribute, use <code><a title="vectorbt.portfolio.base.Portfolio.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">Configured.copy()</a></code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Portfolio(Configured, PandasIndexer):
    &#34;&#34;&#34;Class for modeling portfolio and measuring its performance.

    Args:
        orders (Orders): Order records.
        init_cash (float or array_like): Initial capital.
        cash_sharing (bool): Whether to share cash within the same group.
        call_seq (array_like of int): Sequence of calls per row and group.
        init_cash_mode (InitCashMode or None): Initial cash mode.
        incl_unrealized (bool): Whether to include unrealized P&amp;L in statistics.

    !!! note
        Use class methods with `from_` prefix to build a portfolio.
        The `__init__` method is reserved for indexing purposes.

    !!! note
        This class is meant to be immutable. To change any attribute, use `Portfolio.copy`.&#34;&#34;&#34;

    def __init__(self, orders, init_cash, cash_sharing, call_seq, init_cash_mode=None, incl_unrealized=None):
        Configured.__init__(
            self,
            orders=orders,
            init_cash=init_cash,
            cash_sharing=cash_sharing,
            call_seq=call_seq,
            init_cash_mode=init_cash_mode,
            incl_unrealized=incl_unrealized
        )
        # Get defaults
        if incl_unrealized is None:
            incl_unrealized = defaults.portfolio[&#39;incl_unrealized&#39;]

        # Perform checks
        checks.assert_type(orders, Orders)

        # Store passed arguments
        self._ref_price = orders.close
        self._orders = orders
        self._init_cash = init_cash
        self._cash_sharing = cash_sharing
        self._call_seq = call_seq
        self._init_cash_mode = init_cash_mode
        self._incl_unrealized = incl_unrealized

        # Supercharge
        PandasIndexer.__init__(self, _indexing_func)

    # ############# Class methods ############# #

    @classmethod
    def from_signals(cls, close, entries, exits, size=None, entry_price=None, exit_price=None,
                     fees=None, fixed_fees=None, slippage=None, reject_prob=None, min_size=None,
                     init_cash=None, cash_sharing=None, call_seq=None, accumulate=None,
                     accumulate_exit_mode=None, conflict_mode=None, seed=None, freq=None, group_by=None,
                     broadcast_kwargs=None, wrapper_kwargs=None, **kwargs):
        &#34;&#34;&#34;Simulate portfolio from entry and exit signals.

        Starting with initial cash `init_cash`, for each signal in `entries`, enters a position
        by buying `size` of shares for `entry_price`. For each signal in `exits`, closes the position
        by selling all shares for `exit_price`. When accumulation is enabled, each entry signal will
        increase the position, and optionally each exit signal will decrease the position. When both
        entry and exit signals are present, ignores them by default. When grouping is enabled with
        `group_by`, will compute performance for the entire group. When, additionally, `cash_sharing`
        is enabled, will share the cash among all columns in the group.

        Args:
            close (pandas_like): Reference price, such as close. Will broadcast.

                Will be used for calculating unrealized P&amp;L and portfolio value.
            entries (array_like of bool): Boolean array of entry signals. Will broadcast.
            exits (array_like of bool): Boolean array of exit signals. Will broadcast.
            size (float or array_like): Size to order. Will broadcast.

                * Set to positive/negative to buy/sell.
                * Set to `np.inf`/`-np.inf` to buy/sell everything.
                * Set to `np.nan` or zero to skip.
            entry_price (array_like of float): Entry price. Defaults to `close`. Will broadcast.

                !!! note
                    Setting order price to close is risky.
            exit_price (array_like of float): Exit price. Defaults to `close`. Will broadcast.

                !!! note
                    Setting order price to close is risky.
            fees (float or array_like): Fees in percentage of the order value. Will broadcast.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order. Will broadcast.
            slippage (float or array_like): Slippage in percentage of price. Will broadcast.
            reject_prob (float or array_like): Order rejection probability. Will broadcast.
            min_size (float or array_like): Minimum size for an order to be accepted.

                Will broadcast to the number of columns.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                By default, will broadcast to the number of columns.
                If cash sharing is enabled, will broadcast to the number of groups.
                See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

                !!! note
                    Make sure that `init_cash` is a floating number if not using `InitCashMode`.
            cash_sharing (bool): Whether to share cash within the same group.

                !!! warning
                    Order execution cannot be considered parallel anymore.

                    This method presumes that in a group of assets that share the same capital all
                    orders will be executed within the same tick and retain their price regardless
                    of their position in the queue, even though they depend upon each other and thus
                    cannot be executed in parallel. This behavior is risky.
            call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

                * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
                * Set to array to specify custom sequence. Will not broadcast.
            accumulate (bool): If `accumulate` is `True`, entering the market when already
                in the market will be allowed to increase the position.
            accumulate_exit_mode (AccumulateExitMode): See `vectorbt.portfolio.enums.AccumulateExitMode`.
            conflict_mode (ConflictMode): See `vectorbt.portfolio.enums.ConflictMode`.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            freq (any): Index frequency in case `close.index` is not datetime-like.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        All time series will be broadcast together using `vectorbt.base.reshape_fns.broadcast`.
        At the end, they will have the same metadata.

        For defaults, see `vectorbt.defaults.portfolio`.

        !!! note
            Only `SizeType.Shares` is supported. Other modes such as target percentage are not
            compatible with signals since their logic may contradict the direction the user has
            specified for the order.

            With cash sharing enabled, at each timestamp, processing of the assets in a group
            goes strictly in order defined in `call_seq`. This order can&#39;t be changed dynamically.

        !!! hint
            If you generated signals using close price, don&#39;t forget to shift your signals by one tick
            forward, for example, with `signals.vbt.fshift(1)`. In general, make sure to use a price
            that comes after the signal.

        Example:
            Different ways of how signals are interpreted:

            ```python-repl
            &gt;&gt;&gt; import numpy as np
            &gt;&gt;&gt; import pandas as pd
            &gt;&gt;&gt; from datetime import datetime
            &gt;&gt;&gt; import vectorbt as vbt
            &gt;&gt;&gt; from vectorbt.portfolio.enums import AccumulateExitMode, ConflictMode

            &gt;&gt;&gt; price = pd.Series([1., 2., 3., 4., 5.], index=pd.Index([
            ...     datetime(2020, 1, 1),
            ...     datetime(2020, 1, 2),
            ...     datetime(2020, 1, 3),
            ...     datetime(2020, 1, 4),
            ...     datetime(2020, 1, 5)
            ... ]))
            &gt;&gt;&gt; entries = pd.Series([True, True, True, False, False])
            &gt;&gt;&gt; exits = pd.Series([False, False, True, True, True])

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
            ...     price, entries, exits, size=1.)
            &gt;&gt;&gt; portfolio.share_flow()
            2020-01-01    1.0
            2020-01-02    0.0
            2020-01-03    0.0
            2020-01-04   -1.0
            2020-01-05    0.0
            dtype: float64

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
            ...     price, entries, exits, size=1.,
            ...     conflict_mode=ConflictMode.Exit)
            &gt;&gt;&gt; portfolio.share_flow()
            2020-01-01    1.0
            2020-01-02    0.0
            2020-01-03   -1.0
            2020-01-04    0.0
            2020-01-05    0.0
            dtype: float64

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
            ...     price, entries, exits, size=1.,
            ...     accumulate=True)
            &gt;&gt;&gt; portfolio.share_flow()
            2020-01-01    1.0
            2020-01-02    1.0
            2020-01-03    0.0
            2020-01-04   -2.0
            2020-01-05    0.0
            dtype: float64

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
            ...     price, entries, exits, size=1.,
            ...     accumulate=True,
            ...     accumulate_exit_mode=AccumulateExitMode.Reduce)
            &gt;&gt;&gt; portfolio.share_flow()  # same as using from_orders
            2020-01-01    1.0
            2020-01-02    1.0
            2020-01-03    0.0
            2020-01-04   -1.0
            2020-01-05   -1.0
            dtype: float64
            ```
        &#34;&#34;&#34;
        # Get defaults
        if size is None:
            size = defaults.portfolio[&#39;size&#39;]
        if entry_price is None:
            entry_price = close
        if exit_price is None:
            exit_price = close
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]
        if reject_prob is None:
            reject_prob = defaults.portfolio[&#39;reject_prob&#39;]
        if min_size is None:
            min_size = defaults.portfolio[&#39;min_size&#39;]
        if init_cash is None:
            init_cash = defaults.portfolio[&#39;init_cash&#39;]
            if isinstance(init_cash, str):
                init_cash = getattr(InitCashMode, init_cash)
        if isinstance(init_cash, int):
            checks.assert_in(init_cash, InitCashMode)
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = defaults.portfolio[&#39;cash_sharing&#39;]
        if call_seq is None:
            call_seq = defaults.portfolio[&#39;call_seq&#39;]
            if isinstance(call_seq, str):
                call_seq = getattr(CallSeqType, call_seq)
        if isinstance(call_seq, int):
            checks.assert_in(call_seq, CallSeqType)
            if call_seq == CallSeqType.Auto:
                raise ValueError(&#34;This method doesn&#39;t support CallSeqType.Auto&#34;)
        if accumulate is None:
            accumulate = defaults.portfolio[&#39;accumulate&#39;]
        if accumulate_exit_mode is None:
            accumulate_exit_mode = defaults.portfolio[&#39;accumulate_exit_mode&#39;]
            if isinstance(accumulate_exit_mode, str):
                accumulate_exit_mode = getattr(AccumulateExitMode, accumulate_exit_mode)
        checks.assert_in(accumulate_exit_mode, AccumulateExitMode)
        if conflict_mode is None:
            conflict_mode = defaults.portfolio[&#39;conflict_mode&#39;]
            if isinstance(conflict_mode, str):
                conflict_mode = getattr(ConflictMode, conflict_mode)
        checks.assert_in(conflict_mode, ConflictMode)
        if seed is None:
            seed = defaults.portfolio[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = defaults.portfolio[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Perform checks
        checks.assert_type(close, (pd.Series, pd.DataFrame))
        checks.assert_subdtype(close, np.floating)
        checks.assert_dtype(entries, np.bool)
        checks.assert_dtype(exits, np.bool)
        checks.assert_subdtype(size, np.floating)
        checks.assert_subdtype(entry_price, np.floating)
        checks.assert_subdtype(exit_price, np.floating)
        checks.assert_subdtype(fees, np.floating)
        checks.assert_subdtype(fixed_fees, np.floating)
        checks.assert_subdtype(slippage, np.floating)
        checks.assert_subdtype(reject_prob, np.floating)
        checks.assert_subdtype(min_size, np.floating)
        checks.assert_subdtype(init_cash, np.floating)
        checks.assert_subdtype(call_seq, np.integer)

        # Broadcast inputs
        # Only close is broadcast, others can remain unchanged thanks to flexible indexing
        keep_raw = (False, True, True, True, True, True, True, True, True, True, True)
        broadcast_kwargs = merge_kwargs(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
        close, entries, exits, size, entry_price, exit_price, fees, fixed_fees, slippage, reject_prob = \
            broadcast(close, entries, exits, size, entry_price, exit_price, fees, fixed_fees,
                slippage, reject_prob, **broadcast_kwargs, keep_raw=keep_raw)
        target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
        min_size = np.require(np.broadcast_to(min_size, (target_shape_2d[1],)), requirements=&#39;W&#39;)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_counts = wrapper.grouper.get_group_counts(group_by=cash_sharing)
        init_cash = np.broadcast_to(init_cash, (len(cs_group_counts),))
        group_counts = wrapper.grouper.get_group_counts(group_by=group_by)
        if checks.is_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_counts, call_seq_type=call_seq)

        # Perform calculation
        order_records = nb.simulate_from_signals_nb(
            target_shape_2d,
            cs_group_counts,  # group only if cash sharing is enabled to speed up
            init_cash,
            call_seq,
            entries,
            exits,
            size,
            entry_price,
            exit_price,
            fees,
            fixed_fees,
            slippage,
            reject_prob,
            min_size,
            accumulate,
            accumulate_exit_mode,
            conflict_mode,
            close.ndim == 2
        )

        # Create an instance
        orders = Orders(wrapper, order_records, close)
        return cls(
            orders,
            init_cash,
            cash_sharing,
            call_seq,
            init_cash_mode=init_cash_mode,
            **kwargs
        )

    @classmethod
    def from_orders(cls, close, order_size, size_type=None, order_price=None, fees=None, fixed_fees=None,
                    slippage=None, reject_prob=None, min_size=None, init_cash=None, cash_sharing=None,
                    call_seq=None, val_price=None, freq=None, seed=None, group_by=None, broadcast_kwargs=None,
                    wrapper_kwargs=None, **kwargs):
        &#34;&#34;&#34;Simulate portfolio from orders.

        Starting with initial cash `init_cash`, orders the number of shares specified in `order_size`
        for `order_price`.

        Args:
            close (pandas_like): Reference price, such as close. Will broadcast.

                Will be used for calculating unrealized P&amp;L and portfolio value.
            order_size (float or array_like): Size to order. Will broadcast.

                For any size type:

                * Set to `np.nan` to skip.
                * Set to `np.inf`/`-np.inf` to buy/sell everything.

                For `SizeType.Shares`:

                * Set to positive/negative to buy/sell.
                * Set to zero to skip.

                For target size, the final size will depend upon current holdings.
            size_type (SizeType or array_like): See `vectorbt.portfolio.enums.SizeType`.
            order_price (array_like of float): Order price. Defaults to `close`. Will broadcast.

                !!! note
                    Setting order price to close is risky.
            fees (float or array_like): Fees in percentage of the order value. Will broadcast.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order. Will broadcast.
            slippage (float or array_like): Slippage in percentage of price. Will broadcast.
            reject_prob (float or array_like): Order rejection probability. Will broadcast.
            min_size (float or array_like): Minimum size for an order to be accepted.

                Will broadcast to the number of columns.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                By default, will broadcast to the number of columns.
                If cash sharing is enabled, will broadcast to the number of groups.
                See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

                !!! note
                    Make sure that `init_cash` is a floating number if not using `InitCashMode`.
            cash_sharing (bool): Whether to share cash within the same group.

                !!! warning
                    Order execution cannot be considered parallel anymore.

                    This method presumes that in a group of assets that share the same capital all
                    orders will be executed within the same tick and retain their price regardless
                    of their position in the queue, even though they depend upon each other and thus
                    cannot be executed in parallel. This behavior is risky.
            call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

                * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
                * Set to array to specify custom sequence. Will not broadcast.

                If `CallSeqType.Auto` selected, rearranges calls dynamically based on order value.
                Calculates value of all orders per row and group, and sorts them by this value.
                Sell orders will be executed first to release funds for buy orders.

                !!! warning
                    `CallSeqType.Auto` should be used with caution:

                    * It not only presumes that order prices are known beforehand, but also that
                        orders can be executed in arbitrary order and still retain their price.
                        In reality, this is hardly the case: after processing one asset, some time
                        has passed and the price for other assets might have already changed.
                    * Even if you&#39;re able to specify a slippage large enough to compensate for
                        this behavior, slippage itself should depend upon execution order.
                        This method doesn&#39;t let you do that.
                    * If one order is rejected, it still will execute next orders and possibly
                        leave them without funds that could have been released by the first order.

                    For more control, use `Portfolio.from_order_func`.
            val_price (array_like of float): Size valuation price. Defaults to previous `close`.
                Will broadcast.

                Used to calculate `SizeType.TargetPercent` and `SizeType.TargetValue`.

                !!! note
                    Make sure to use timestamp for `val_price` that comes before timestamps of all orders
                    in the group with cash sharing, otherwise you&#39;re cheating yourself.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            freq (any): Index frequency in case `close.index` is not datetime-like.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.

        All time series will be broadcast together using `vectorbt.base.reshape_fns.broadcast`.
        At the end, they will have the same metadata.

        For defaults, see `vectorbt.defaults.portfolio`.

        !!! note
            When `call_seq` is not `CallSeqType.Auto`, at each timestamp, processing of the assets in
            a group goes strictly in order defined in `call_seq`. This order can&#39;t be changed dynamically.

            This has one big implication for this particular method: the last asset in the call stack
            cannot be processed until other assets are processed. This is the reason why rebalancing
            cannot work properly in this setting: one has to specify percentages for all assets beforehand
            and then tweak the processing order to sell to-be-sold assets first in order to release funds
            for to-be-bought assets. This can be automatically done by using `CallSeqType.Auto`.

        Example:
            The same equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb`.
            It&#39;s more compact but has no control over how order of execution impacts order price.

            ```python-repl
            &gt;&gt;&gt; import numpy as np
            &gt;&gt;&gt; import pandas as pd
            &gt;&gt;&gt; import vectorbt as vbt
            &gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, CallSeqType

            &gt;&gt;&gt; np.random.seed(42)
            &gt;&gt;&gt; price = pd.DataFrame(np.random.uniform(1, 10, size=(5, 3)))
            &gt;&gt;&gt; orders = pd.DataFrame(np.full((5, 3), 1.) / 3)  # each column 33.3%
            &gt;&gt;&gt; orders[1::2] = np.nan  # skip every second tick

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
            ...     price,  # reference price for portfolio value
            ...     orders,
            ...     order_price=price,  # order price
            ...     size_type=SizeType.TargetPercent,
            ...     val_price=price,  # order price known beforehand (don&#39;t do it)
            ...     call_seq=CallSeqType.Auto,  # first sell then buy
            ...     group_by=np.array([0, 0, 0]),
            ...     cash_sharing=True,
            ...     fees=0.001, fixed_fees=1., slippage=0.001
            ... )

            &gt;&gt;&gt; portfolio.holding_value(group_by=False)
                       0          1          2
            0  33.333333  33.333333  30.139624
            1  48.716002   8.385865   9.548589
            2  19.546625  22.584433  22.584433
            3  94.638155   3.043394  34.278783
            4  41.923304  38.661499  41.923304
            ```
        &#34;&#34;&#34;
        # Get defaults
        if order_size is None:
            order_size = defaults.portfolio[&#39;order_size&#39;]
        if size_type is None:
            size_type = defaults.portfolio[&#39;size_type&#39;]
            if isinstance(size_type, str):
                size_type = getattr(SizeType, size_type)
        if order_price is None:
            order_price = close
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]
        if reject_prob is None:
            reject_prob = defaults.portfolio[&#39;reject_prob&#39;]
        if min_size is None:
            min_size = defaults.portfolio[&#39;min_size&#39;]
        if init_cash is None:
            init_cash = defaults.portfolio[&#39;init_cash&#39;]
            if isinstance(init_cash, str):
                init_cash = getattr(InitCashMode, init_cash)
        if isinstance(init_cash, int):
            checks.assert_in(init_cash, InitCashMode)
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = defaults.portfolio[&#39;cash_sharing&#39;]
        if call_seq is None:
            call_seq = defaults.portfolio[&#39;call_seq&#39;]
            if isinstance(call_seq, str):
                call_seq = getattr(CallSeqType, call_seq)
        auto_call_seq = False
        if isinstance(call_seq, int):
            checks.assert_in(call_seq, CallSeqType)
            if call_seq == CallSeqType.Auto:
                call_seq = CallSeqType.Default
                auto_call_seq = True
        if val_price is None:
            val_price = close.vbt.fshift(1)
        if seed is None:
            seed = defaults.portfolio[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = defaults.portfolio[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Perform checks
        checks.assert_type(close, (pd.Series, pd.DataFrame))
        checks.assert_subdtype(close, np.floating)
        checks.assert_subdtype(order_size, np.floating)
        checks.assert_subdtype(size_type, np.integer)
        checks.assert_subdtype(order_price, np.floating)
        checks.assert_subdtype(fees, np.floating)
        checks.assert_subdtype(fixed_fees, np.floating)
        checks.assert_subdtype(slippage, np.floating)
        checks.assert_subdtype(reject_prob, np.floating)
        checks.assert_subdtype(min_size, np.floating)
        checks.assert_subdtype(init_cash, np.floating)
        checks.assert_subdtype(call_seq, np.integer)
        checks.assert_subdtype(val_price, np.floating)

        # Broadcast inputs
        # Only close is broadcast, others can remain unchanged thanks to flexible indexing
        keep_raw = (False, True, True, True, True, True, True, True, True, True)
        broadcast_kwargs = merge_kwargs(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
        close, order_size, size_type, order_price, fees, fixed_fees, slippage, reject_prob, val_price = \
            broadcast(close, order_size, size_type, order_price, fees, fixed_fees, slippage,
                      reject_prob, val_price, **broadcast_kwargs, keep_raw=keep_raw)
        target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
        min_size = np.require(np.broadcast_to(min_size, (target_shape_2d[1],)), requirements=&#39;W&#39;)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_counts = wrapper.grouper.get_group_counts(group_by=cash_sharing)
        init_cash = np.broadcast_to(init_cash, (len(cs_group_counts),))
        group_counts = wrapper.grouper.get_group_counts(group_by=group_by)
        if checks.is_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_counts, call_seq_type=call_seq)

        # Perform calculation
        order_records = nb.simulate_from_orders_nb(
            target_shape_2d,
            cs_group_counts,  # group only if cash sharing is enabled to speed up
            init_cash,
            call_seq,
            order_size,
            size_type,
            order_price,
            fees,
            fixed_fees,
            slippage,
            reject_prob,
            min_size,
            val_price,
            auto_call_seq,
            close.ndim == 2
        )

        # Create an instance
        orders = Orders(wrapper, order_records, close)
        return cls(
            orders,
            init_cash,
            cash_sharing,
            call_seq,
            init_cash_mode=init_cash_mode,
            **kwargs
        )

    @classmethod
    def from_order_func(cls, close, order_func_nb, *order_args, target_shape=None, keys=None,
                        init_cash=None, cash_sharing=None, call_seq=None, active_mask=None, min_size=None,
                        prep_func_nb=None, prep_args=None, group_prep_func_nb=None, group_prep_args=None,
                        row_prep_func_nb=None, row_prep_args=None, segment_prep_func_nb=None,
                        segment_prep_args=None, row_wise=None, seed=None, freq=None, group_by=None,
                        broadcast_kwargs=None, wrapper_kwargs=None, **kwargs):
        &#34;&#34;&#34;Build portfolio from a custom order function.

        For details, see `vectorbt.portfolio.nb.simulate_nb`.

        if `row_wise` is `True`, also see `vectorbt.portfolio.nb.simulate_row_wise_nb`.

        Args:
            close (pandas_like): Reference price, such as close. Will broadcast to `target_shape`.

                Will be used for calculating unrealized P&amp;L and portfolio value.

                Previous `close` will also be used for valuating assets/groups during the simulation.
            order_func_nb (callable): Order generation function.
            *order_args: Arguments passed to `order_func_nb`.
            target_shape (tuple): Target shape to iterate over. Defaults to `close.shape`.
            keys (sequence): Outermost column level.

                Each element should correspond to one iteration over columns in `close`.
                Should be set only if `target_shape` is bigger than `close.shape`.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                By default, will broadcast to the number of columns.
                If cash sharing is enabled, will broadcast to the number of groups.
                See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

                !!! note
                    Make sure that `init_cash` is a floating number if not using `InitCashMode`.
            cash_sharing (bool): Whether to share cash within the same group.

                !!! warning
                    Order execution cannot be considered parallel anymore.
            call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

                * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
                * Set to array to specify custom sequence. Will not broadcast.
            active_mask (bool or array_like): Mask of whether a particular segment should be executed.

                By default, will broadcast to the number of rows and groups.
            min_size (float or array_like): Minimum size for an order to be accepted.

                Will broadcast to the number of columns.
            prep_func_nb (callable): Simulation preparation function.
            prep_args (tuple): Packed arguments passed to `prep_func_nb`.

                Defaults to `()`.
            group_prep_func_nb (callable): Group preparation function.

                Called only if `row_wise` is `False`.
            group_prep_args (tuple): Packed arguments passed to `group_prep_func_nb`.

                Defaults to `()`.
            row_prep_func_nb (callable): Row preparation function.

                Called only if `row_wise` is `True`.
            row_prep_args (tuple): Packed arguments passed to `row_prep_func_nb`.

                Defaults to `()`.
            segment_prep_func_nb (callable): Segment preparation function.
            segment_prep_args (tuple): Packed arguments passed to `segment_prep_func_nb`.

                Defaults to `()`.
            row_wise (bool): Whether to iterate over rows rather than columns/groups.

                See `vectorbt.portfolio.nb.simulate_row_wise_nb`.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            freq (any): Index frequency in case `close.index` is not datetime-like.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        !!! note
            All passed functions should be Numba-compiled.

            Objects passed as arguments to both functions will not broadcast to `target_shape`
            as their purpose is unknown. You should broadcast manually or use flexible indexing.

            Also see notes on `Portfolio.from_orders`.
        &#34;&#34;&#34;
        # Get defaults
        if target_shape is None:
            target_shape = close.shape
        if init_cash is None:
            init_cash = defaults.portfolio[&#39;init_cash&#39;]
            if isinstance(init_cash, str):
                init_cash = getattr(InitCashMode, init_cash)
        if isinstance(init_cash, int):
            checks.assert_in(init_cash, InitCashMode)
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = defaults.portfolio[&#39;cash_sharing&#39;]
        if call_seq is None:
            call_seq = defaults.portfolio[&#39;call_seq&#39;]
            if isinstance(call_seq, str):
                call_seq = getattr(CallSeqType, call_seq)
        if isinstance(call_seq, int):
            checks.assert_in(call_seq, CallSeqType)
            if call_seq == CallSeqType.Auto:
                raise ValueError(&#34;CallSeqType.Auto should be implemented manually.&#34;
                                 &#34;Use auto_call_seq_ctx_nb in segment_prep_func_nb.&#34;)
        if active_mask is None:
            active_mask = True
        if min_size is None:
            min_size = defaults.portfolio[&#39;min_size&#39;]
        if row_wise is None:
            row_wise = defaults.portfolio[&#39;row_wise&#39;]
        if seed is None:
            seed = defaults.portfolio[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = defaults.portfolio[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        require_kwargs = dict(require_kwargs=dict(requirements=&#39;W&#39;))
        broadcast_kwargs = merge_kwargs(require_kwargs, broadcast_kwargs)
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Perform checks
        checks.assert_type(close, (pd.Series, pd.DataFrame))
        checks.assert_subdtype(close, np.floating)
        checks.assert_subdtype(init_cash, np.floating)
        checks.assert_subdtype(call_seq, np.integer)

        # Broadcast inputs
        target_shape_2d = (target_shape[0], target_shape[1] if len(target_shape) &gt; 1 else 1)
        if close.shape != target_shape:
            if len(close.vbt.columns) &lt;= target_shape_2d[1]:
                if target_shape_2d[1] % len(close.vbt.columns) != 0:
                    raise ValueError(&#34;Cannot broadcast close to target_shape&#34;)
                if keys is None:
                    keys = pd.Index(np.arange(target_shape_2d[1]), name=&#39;iteration_idx&#39;)
                tile_times = target_shape_2d[1] // len(close.vbt.columns)
                close = close.vbt.tile(tile_times, keys=keys)
        close = broadcast(close, to_shape=target_shape, **broadcast_kwargs)
        min_size = np.require(np.broadcast_to(min_size, (target_shape_2d[1],)), requirements=&#39;W&#39;)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_counts = wrapper.grouper.get_group_counts(group_by=cash_sharing)
        init_cash = np.broadcast_to(init_cash, (len(cs_group_counts),))
        group_counts = wrapper.grouper.get_group_counts(group_by=group_by)
        active_mask = broadcast(
            active_mask,
            to_shape=(target_shape_2d[0], len(group_counts)),
            to_pd=False,
            **require_kwargs
        )
        if checks.is_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_counts, call_seq_type=call_seq)

        # Prepare arguments
        if prep_func_nb is None:
            prep_func_nb = nb.empty_prep_nb
        if prep_args is None:
            prep_args = ()
        if group_prep_func_nb is None:
            group_prep_func_nb = nb.empty_prep_nb
        if group_prep_args is None:
            group_prep_args = ()
        if row_prep_func_nb is None:
            row_prep_func_nb = nb.empty_prep_nb
        if row_prep_args is None:
            row_prep_args = ()
        if segment_prep_func_nb is None:
            segment_prep_func_nb = nb.empty_prep_nb
        if segment_prep_args is None:
            segment_prep_args = ()

        prep_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in prep_args])
        group_prep_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in group_prep_args])
        row_prep_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in row_prep_args])
        segment_prep_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in segment_prep_args])
        order_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in order_args])

        # Perform calculation
        if row_wise:
            order_records = nb.simulate_row_wise_nb(
                target_shape_2d,
                to_2d(close, raw=True),
                group_counts,
                init_cash,
                cash_sharing,
                call_seq,
                active_mask,
                min_size,
                prep_func_nb,
                prep_args,
                row_prep_func_nb,
                row_prep_args,
                segment_prep_func_nb,
                segment_prep_args,
                order_func_nb,
                order_args
            )
        else:
            order_records = nb.simulate_nb(
                target_shape_2d,
                to_2d(close, raw=True),
                group_counts,
                init_cash,
                cash_sharing,
                call_seq,
                active_mask,
                min_size,
                prep_func_nb,
                prep_args,
                group_prep_func_nb,
                group_prep_args,
                segment_prep_func_nb,
                segment_prep_args,
                order_func_nb,
                order_args
            )

        # Create an instance
        orders = Orders(wrapper, order_records, close)
        return cls(
            orders,
            init_cash,
            cash_sharing,
            call_seq,
            init_cash_mode=init_cash_mode,
            **kwargs
        )

    # ############# Properties ############# #

    @property
    def wrapper(self):
        &#34;&#34;&#34;Array wrapper.&#34;&#34;&#34;
        # Wrapper in orders and here can be different
        wrapper = self.orders.wrapper
        if self.cash_sharing and wrapper.grouper.allow_modify:
            # Cannot change groups if columns within them are dependent
            return wrapper.copy(allow_modify=False)
        return wrapper.copy()

    @property
    def cash_sharing(self):
        &#34;&#34;&#34;Whether to share cash within the same group.&#34;&#34;&#34;
        return self._cash_sharing

    @property
    def call_seq(self):
        &#34;&#34;&#34;Sequence of calls per row and group.&#34;&#34;&#34;
        return self.wrapper.wrap(self._call_seq, group_by=False)

    @property
    def init_cash_mode(self):
        &#34;&#34;&#34;Initial cash mode.&#34;&#34;&#34;
        return self._init_cash_mode

    @property
    def incl_unrealized(self):
        &#34;&#34;&#34;Whether to include unrealized trade P&amp;L in statistics.&#34;&#34;&#34;
        return self._incl_unrealized

    # ############# Regrouping ############# #

    def regroup(self, group_by):
        &#34;&#34;&#34;Regroup this object.&#34;&#34;&#34;
        if self.cash_sharing:
            raise ValueError(&#34;Cannot change grouping globally when cash sharing is enabled&#34;)
        if self.wrapper.grouper.is_grouping_changed(group_by=group_by):
            self.wrapper.grouper.check_group_by(group_by=group_by)
            return self.copy(orders=self.orders.regroup(group_by=group_by))
        return self

    # ############# Reference price ############# #

    @property
    def close(self):
        &#34;&#34;&#34;Price per share series.&#34;&#34;&#34;
        return self._ref_price

    @cached_method
    def fill_close(self, ffill=True, bfill=True):
        &#34;&#34;&#34;Fill NaN values of `Portfolio.close`.

        Use `ffill` and `bfill` to fill forwards and backwards respectively.&#34;&#34;&#34;
        close = to_2d(self.close, raw=True)
        if ffill and np.any(np.isnan(close[-1, :])):
            close = generic_nb.ffill_nb(close)
        if bfill and np.any(np.isnan(close[0, :])):
            close = generic_nb.ffill_nb(close[::-1, :])[::-1, :]
        return self.wrapper.wrap(close, group_by=False)

    # ############# Cash ############# #

    @property
    def init_cash(self):
        &#34;&#34;&#34;Initial amount of cash per column/group.

        Returns value per group if `cash_sharing` is `True`.&#34;&#34;&#34;
        if self.init_cash_mode is None:
            init_cash = self._init_cash
        else:
            cash_flow = to_2d(self.cash_flow(group_by=self.cash_sharing), raw=True)
            init_cash = -np.min(np.cumsum(cash_flow, axis=0), axis=0)
            if self.init_cash_mode == InitCashMode.AutoAlign:
                init_cash = np.full(init_cash.shape, np.max(init_cash))
        return self.wrapper.wrap_reduced(init_cash, group_by=self.cash_sharing)

    @cached_method
    def init_cash_regrouped(self, group_by=None):
        &#34;&#34;&#34;Get cash flow series per column/group.&#34;&#34;&#34;
        init_cash = to_1d(self.init_cash, raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
            init_cash_regrouped = nb.init_cash_grouped_nb(init_cash, group_counts, self.cash_sharing)
        else:
            group_counts = self.wrapper.grouper.get_group_counts()
            init_cash_regrouped = nb.init_cash_ungrouped_nb(init_cash, group_counts, self.cash_sharing)
        return self.wrapper.wrap_reduced(init_cash_regrouped, group_by=group_by)

    @cached_method
    def cash_flow(self, group_by=None):
        &#34;&#34;&#34;Get cash flow series per column/group.&#34;&#34;&#34;
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            cash_flow_ungrouped = to_2d(self.cash_flow(group_by=False), raw=True)
            group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
            cash_flow = nb.cash_flow_grouped_nb(cash_flow_ungrouped, group_counts)
        else:
            cash_flow = nb.cash_flow_ungrouped_nb(self.wrapper.shape_2d, self.orders.records_arr)
        return self.wrapper.wrap(cash_flow, group_by=group_by)

    @cached_method
    def cash(self, group_by=None, in_sim_order=False):
        &#34;&#34;&#34;Get cash series per column/group.&#34;&#34;&#34;
        if in_sim_order and not self.cash_sharing:
            raise ValueError(&#34;in_sim_order requires enabled cash sharing&#34;)

        cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            init_cash_grouped = to_1d(self.init_cash_regrouped(group_by=group_by), raw=True)
            group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
            cash = nb.cash_grouped_nb(
                self.wrapper.shape_2d,
                cash_flow,
                group_counts,
                init_cash_grouped
            )
        else:
            init_cash = to_1d(self.init_cash, raw=True)
            group_counts = self.wrapper.grouper.get_group_counts()
            call_seq = to_2d(self.call_seq, raw=True)
            cash = nb.cash_ungrouped_nb(
                cash_flow,
                group_counts,
                init_cash,
                self.cash_sharing,
                call_seq,
                in_sim_order
            )
        return self.wrapper.wrap(cash, group_by=group_by)

    # ############# Shares ############# #

    @cached_method
    def share_flow(self):
        &#34;&#34;&#34;Get share flow series per column.&#34;&#34;&#34;
        share_flow = nb.share_flow_nb(self.wrapper.shape_2d, self.orders.records_arr)
        return self.wrapper.wrap(share_flow, group_by=False)

    @cached_method
    def shares(self):
        &#34;&#34;&#34;Get share series per column.&#34;&#34;&#34;
        share_flow = to_2d(self.share_flow(), raw=True)
        shares = nb.shares_nb(share_flow)
        return self.wrapper.wrap(shares, group_by=False)

    # ############# Records ############# #

    @property
    def orders(self):
        &#34;&#34;&#34;Order records.

        See `vectorbt.records.orders.Orders`.&#34;&#34;&#34;
        return self._orders

    @cached_method
    def orders_regrouped(self, group_by=None):
        &#34;&#34;&#34;Regroup order records.

        See `vectorbt.records.orders.Orders`.&#34;&#34;&#34;
        return self._orders.regroup(group_by=group_by)

    @cached_method
    def trades(self, group_by=None, incl_unrealized=None):
        &#34;&#34;&#34;Get trade records from orders.

        See `vectorbt.records.events.Trades`.&#34;&#34;&#34;
        trades = Trades.from_orders(self.orders_regrouped(group_by=group_by))
        if incl_unrealized is None:
            incl_unrealized = self.incl_unrealized
        if incl_unrealized:
            return trades
        return trades.closed

    @cached_method
    def positions(self, group_by=None, incl_unrealized=None):
        &#34;&#34;&#34;Get position records from orders.

        See `vectorbt.records.events.Positions`.&#34;&#34;&#34;
        positions = Positions.from_orders(self.orders_regrouped(group_by=group_by))
        if incl_unrealized is None:
            incl_unrealized = self.incl_unrealized
        if incl_unrealized:
            return positions
        return positions.closed

    @cached_method
    def drawdowns(self, **kwargs):
        &#34;&#34;&#34;Get drawdown records from `Portfolio.value`.

        See `vectorbt.records.drawdowns.Drawdowns`.&#34;&#34;&#34;
        return Drawdowns.from_ts(self.value(**kwargs), freq=self.wrapper.freq)

    # ############# Performance ############# #

    @cached_method
    def holding_value(self, group_by=None):
        &#34;&#34;&#34;Get holding value series per column/group.&#34;&#34;&#34;
        close = to_2d(self.close, raw=True).copy()
        shares = to_2d(self.shares(), raw=True)
        close[shares == 0.] = 0.  # for price being NaN
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
            holding_value = nb.holding_value_grouped_nb(close, shares, group_counts)
        else:
            holding_value = nb.holding_value_ungrouped_nb(close, shares)
        return self.wrapper.wrap(holding_value, group_by=group_by)

    @cached_method
    def value(self, group_by=None, in_sim_order=False):
        &#34;&#34;&#34;Get portfolio value series per column/group.

        By default, will generate portfolio value for each asset based on cash flows and thus
        independent from other assets, with initial cash and shares being that of the entire group.
        Useful for generating returns and comparing assets within the same group.

        When `group_by` is `False` and `in_sim_order` is `True`, returns value generated in
        simulation order (see [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
        This value cannot be used for generating returns as-is. Useful to analyze how value
        evolved throughout simulation.&#34;&#34;&#34;
        cash = to_2d(self.cash(group_by=group_by, in_sim_order=in_sim_order), raw=True)
        holding_value = to_2d(self.holding_value(group_by=group_by), raw=True)
        if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
            group_counts = self.wrapper.grouper.get_group_counts()
            call_seq = to_2d(self.call_seq, raw=True)
            value = nb.value_in_sim_order_nb(cash, holding_value, group_counts, call_seq)
            # price of NaN is already addressed by ungrouped_value_nb
        else:
            value = nb.value_nb(cash, holding_value)
        return self.wrapper.wrap(value, group_by=group_by)

    @cached_method
    def final_value(self, group_by=None):
        &#34;&#34;&#34;Get final portfolio value per column/group.

        Calculated directly from order records. Very fast.&#34;&#34;&#34;
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            final_value_ungrouped = to_1d(self.final_value(group_by=False), raw=True)
            init_cash = to_1d(self.init_cash, raw=True)
            group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
            final_value = nb.final_value_grouped_nb(
                final_value_ungrouped,
                init_cash,
                group_counts,
                self.cash_sharing
            )
        else:
            close = to_2d(self.fill_close(), raw=True)
            init_cash_ungrouped = to_1d(self.init_cash_regrouped(group_by=False), raw=True)
            final_value = nb.final_value_ungrouped_nb(
                self.wrapper.shape_2d,
                close,
                self.orders.records_arr,
                init_cash_ungrouped
            )
        return self.wrapper.wrap_reduced(final_value, group_by=group_by)

    @cached_method
    def total_profit(self, group_by=None):
        &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
        init_cash_regrouped = to_1d(self.init_cash_regrouped(group_by=group_by), raw=True)
        final_value = to_1d(self.final_value(group_by=group_by), raw=True)
        total_profit = nb.total_profit_nb(init_cash_regrouped, final_value)
        return self.wrapper.wrap_reduced(total_profit, group_by=group_by)

    @cached_method
    def total_return(self, group_by=None):
        &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
        init_cash_regrouped = to_1d(self.init_cash_regrouped(group_by=group_by), raw=True)
        final_value = to_1d(self.final_value(group_by=group_by), raw=True)
        total_return = nb.total_return_nb(init_cash_regrouped, final_value)
        return self.wrapper.wrap_reduced(total_return, group_by=group_by)

    @cached_method
    def buy_and_hold_return(self, group_by=None):
        &#34;&#34;&#34;Get total return of buy-and-hold.

        If grouped, invests same amount of cash into each asset and returns the total
        return of the entire group.

        !!! note
            Does not take into account fees and slippage. For this, create a separate portfolio.&#34;&#34;&#34;
        ref_price_filled = to_2d(self.fill_close(), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
            total_return = nb.buy_and_hold_return_grouped_nb(ref_price_filled, group_counts)
        else:
            total_return = nb.buy_and_hold_return_ungrouped_nb(ref_price_filled)
        return self.wrapper.wrap_reduced(total_return, group_by=group_by)

    @cached_method
    def active_returns(self, group_by=None):
        &#34;&#34;&#34;Get active return series per column/group.

        This type of returns is based solely on cash flows and holding value rather than portfolio value.
        It ignores passive cash and thus it will return the same numbers irrespective of the amount of
        cash currently available, even `np.inf`. The scale of returns is comparable to that of going
        all in and keeping available cash at zero.&#34;&#34;&#34;
        cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
        holding_value = to_2d(self.holding_value(group_by=group_by), raw=True)
        active_returns = nb.active_returns_nb(cash_flow, holding_value)
        return self.wrapper.wrap(active_returns, group_by=group_by)

    @cached_method
    def returns(self, group_by=None, in_sim_order=False):
        &#34;&#34;&#34;Get return series per column/group based on portfolio value.&#34;&#34;&#34;
        value = to_2d(self.value(group_by=group_by, in_sim_order=in_sim_order), raw=True)
        if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
            group_counts = self.wrapper.grouper.get_group_counts()
            init_cash = to_1d(self.init_cash, raw=True)
            call_seq = to_2d(self.call_seq, raw=True)
            returns = nb.returns_in_sim_order_nb(value, group_counts, init_cash, call_seq)
        else:
            init_cash_regrouped = to_1d(self.init_cash_regrouped(group_by=group_by), raw=True)
            returns = nb.returns_nb(value, init_cash_regrouped)
        return self.wrapper.wrap(returns, group_by=group_by)

    @cached_method
    def stats(self, column=None, group_by=None, incl_unrealized=None, active_returns=False,
              agg_func=np.mean, **kwargs):
        &#34;&#34;&#34;Compute various statistics on this portfolio.

        `kwargs` will be passed to each `vectorbt.returns.accessors.Returns_Accessor` method.

        Can either return aggregated statistics by reducing metrics of all columns with
        `agg_func` (mean by default) or return statistics for a single column if `column`
        was specified or portfolio contains only one column of data. To display rich data types
        such as durations correctly, use an aggregation function that can be applied on `pd.Series`.

        !!! note
            Use `column` only if caching is enabled, otherwise it may re-compute the same
            objects multiple times.&#34;&#34;&#34;
        def _reduce(obj):
            if checks.is_series(obj):
                if column is not None:
                    return obj[column]
                return agg_func(obj)
            return obj

        # Pre-calculate
        positions = self.positions(group_by=group_by, incl_unrealized=incl_unrealized)
        trades = self.trades(group_by=group_by, incl_unrealized=incl_unrealized)
        drawdowns = self.drawdowns(group_by=group_by)
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)

        name = column
        if name is None:
            if self.wrapper.grouper.is_grouped(group_by=group_by):
                if self.wrapper.grouped_ndim == 1:
                    name = self.wrapper.grouper.get_columns(group_by=group_by)[0]
                else:
                    name = agg_func.__name__
            else:
                if self.wrapper.ndim == 1:
                    name = self.wrapper.name
                else:
                    name = agg_func.__name__
        return pd.Series({
            &#39;Start&#39;: self.wrapper.index[0],
            &#39;End&#39;: self.wrapper.index[-1],
            &#39;Duration&#39;: self.wrapper.shape[0] * self.wrapper.freq,
            &#39;Holding Duration [%]&#39;: _reduce(positions.coverage() * 100),
            &#39;Total Profit&#39;: _reduce(self.total_profit(group_by=group_by)),
            &#39;Total Return [%]&#39;: _reduce(self.total_return(group_by=group_by) * 100),
            &#39;Buy &amp; Hold Return [%]&#39;: _reduce(self.buy_and_hold_return(group_by=group_by) * 100),
            &#39;Max. Drawdown [%]&#39;: _reduce(-drawdowns.max_drawdown() * 100),
            &#39;Avg. Drawdown [%]&#39;: _reduce(-drawdowns.avg_drawdown() * 100),
            &#39;Max. Drawdown Duration&#39;: _reduce(drawdowns.max_duration()),
            &#39;Avg. Drawdown Duration&#39;: _reduce(drawdowns.avg_duration()),
            &#39;Num. Trades&#39;: _reduce(trades.count()),
            &#39;Win Rate [%]&#39;: _reduce(trades.win_rate() * 100),
            &#39;Best Trade [%]&#39;: _reduce(trades.returns.max() * 100),
            &#39;Worst Trade [%]&#39;: _reduce(trades.returns.min() * 100),
            &#39;Avg. Trade [%]&#39;: _reduce(trades.returns.mean() * 100),
            &#39;Max. Trade Duration&#39;: _reduce(trades.duration.max(time_units=True)),
            &#39;Avg. Trade Duration&#39;: _reduce(trades.duration.mean(time_units=True)),
            &#39;Expectancy&#39;: _reduce(trades.expectancy()),
            &#39;SQN&#39;: _reduce(trades.sqn()),
            &#39;Sharpe Ratio&#39;: _reduce(self.sharpe_ratio(reuse_returns=returns, **kwargs)),
            &#39;Sortino Ratio&#39;: _reduce(self.sortino_ratio(reuse_returns=returns, **kwargs)),
            &#39;Calmar Ratio&#39;: _reduce(self.calmar_ratio(reuse_returns=returns, **kwargs))
        }, name=name)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio.from_order_func"><code class="name flex">
<span>def <span class="ident fname">from_order_func</span></span>(<span>close, order_func_nb, *order_args, target_shape=None, keys=None, init_cash=None, cash_sharing=None, call_seq=None, active_mask=None, min_size=None, prep_func_nb=None, prep_args=None, group_prep_func_nb=None, group_prep_args=None, row_prep_func_nb=None, row_prep_args=None, segment_prep_func_nb=None, segment_prep_args=None, row_wise=None, seed=None, freq=None, group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from a custom order function.</p>
<p>For details, see <code><a title="vectorbt.portfolio.nb.simulate_nb" href="nb.html#vectorbt.portfolio.nb.simulate_nb">simulate_nb()</a></code>.</p>
<p>if <code>row_wise</code> is <code>True</code>, also see <code><a title="vectorbt.portfolio.nb.simulate_row_wise_nb" href="nb.html#vectorbt.portfolio.nb.simulate_row_wise_nb">simulate_row_wise_nb()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>close</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>
<p>Reference price, such as close. Will broadcast to <code>target_shape</code>.</p>
<p>Will be used for calculating unrealized P&amp;L and portfolio value.</p>
<p>Previous <code>close</code> will also be used for valuating assets/groups during the simulation.</p>
</dd>
<dt><strong><code>order_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>Order generation function.</dd>
<dt><strong><code>*order_args</code></strong></dt>
<dd>Arguments passed to <code>order_func_nb</code>.</dd>
<dt><strong><code>target_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Target shape to iterate over. Defaults to <code>close.shape</code>.</dd>
<dt><strong><code>keys</code></strong> :&ensp;<code>sequence</code></dt>
<dd>
<p>Outermost column level.</p>
<p>Each element should correspond to one iteration over columns in <code>close</code>.
Should be set only if <code>target_shape</code> is bigger than <code>close.shape</code>.</p>
</dd>
<dt><strong><code>init_cash</code></strong> :&ensp;<code>InitCashMode, float</code> or <code>array_like</code> of <code>float</code></dt>
<dd>
<p>Initial capital.</p>
<p>By default, will broadcast to the number of columns.
If cash sharing is enabled, will broadcast to the number of groups.
See <code><a title="vectorbt.portfolio.enums.InitCashMode" href="enums.html#vectorbt.portfolio.enums.InitCashMode">InitCashMode</a></code> to find optimal initial cash.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Make sure that <code>init_cash</code> is a floating number if not using <code>InitCashMode</code>.</p>
</div>
</dd>
<dt><strong><code>cash_sharing</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to share cash within the same group.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Order execution cannot be considered parallel anymore.</p>
</div>
</dd>
<dt><strong><code>call_seq</code></strong> :&ensp;<code>CallSeqType</code> or <code>array_like</code> of <code>int</code></dt>
<dd>
<p>Default sequence of calls per row and group.</p>
<ul>
<li>Use <code><a title="vectorbt.portfolio.enums.CallSeqType" href="enums.html#vectorbt.portfolio.enums.CallSeqType">CallSeqType</a></code> to select a sequence type.</li>
<li>Set to array to specify custom sequence. Will not broadcast.</li>
</ul>
</dd>
<dt><strong><code>active_mask</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>
<p>Mask of whether a particular segment should be executed.</p>
<p>By default, will broadcast to the number of rows and groups.</p>
</dd>
<dt><strong><code>min_size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>
<p>Minimum size for an order to be accepted.</p>
<p>Will broadcast to the number of columns.</p>
</dd>
<dt><strong><code>prep_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>Simulation preparation function.</dd>
<dt><strong><code>prep_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>
<p>Packed arguments passed to <code>prep_func_nb</code>.</p>
<p>Defaults to <code>()</code>.</p>
</dd>
<dt><strong><code>group_prep_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>
<p>Group preparation function.</p>
<p>Called only if <code>row_wise</code> is <code>False</code>.</p>
</dd>
<dt><strong><code>group_prep_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>
<p>Packed arguments passed to <code>group_prep_func_nb</code>.</p>
<p>Defaults to <code>()</code>.</p>
</dd>
<dt><strong><code>row_prep_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>
<p>Row preparation function.</p>
<p>Called only if <code>row_wise</code> is <code>True</code>.</p>
</dd>
<dt><strong><code>row_prep_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>
<p>Packed arguments passed to <code>row_prep_func_nb</code>.</p>
<p>Defaults to <code>()</code>.</p>
</dd>
<dt><strong><code>segment_prep_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>Segment preparation function.</dd>
<dt><strong><code>segment_prep_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>
<p>Packed arguments passed to <code>segment_prep_func_nb</code>.</p>
<p>Defaults to <code>()</code>.</p>
</dd>
<dt><strong><code>row_wise</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to iterate over rows rather than columns/groups.</p>
<p>See <code><a title="vectorbt.portfolio.nb.simulate_row_wise_nb" href="nb.html#vectorbt.portfolio.nb.simulate_row_wise_nb">simulate_row_wise_nb()</a></code>.</p>
</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Seed to be set for both <code>call_seq</code> and at the beginning of the simulation.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Index frequency in case <code>close.index</code> is not datetime-like.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>broadcast_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.</dd>
<dt><strong><code>wrapper_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.defaults.portfolio" href="../defaults.html#vectorbt.defaults.portfolio">portfolio</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All passed functions should be Numba-compiled.</p>
<p>Objects passed as arguments to both functions will not broadcast to <code>target_shape</code>
as their purpose is unknown. You should broadcast manually or use flexible indexing.</p>
<p>Also see notes on <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_order_func(cls, close, order_func_nb, *order_args, target_shape=None, keys=None,
                    init_cash=None, cash_sharing=None, call_seq=None, active_mask=None, min_size=None,
                    prep_func_nb=None, prep_args=None, group_prep_func_nb=None, group_prep_args=None,
                    row_prep_func_nb=None, row_prep_args=None, segment_prep_func_nb=None,
                    segment_prep_args=None, row_wise=None, seed=None, freq=None, group_by=None,
                    broadcast_kwargs=None, wrapper_kwargs=None, **kwargs):
    &#34;&#34;&#34;Build portfolio from a custom order function.

    For details, see `vectorbt.portfolio.nb.simulate_nb`.

    if `row_wise` is `True`, also see `vectorbt.portfolio.nb.simulate_row_wise_nb`.

    Args:
        close (pandas_like): Reference price, such as close. Will broadcast to `target_shape`.

            Will be used for calculating unrealized P&amp;L and portfolio value.

            Previous `close` will also be used for valuating assets/groups during the simulation.
        order_func_nb (callable): Order generation function.
        *order_args: Arguments passed to `order_func_nb`.
        target_shape (tuple): Target shape to iterate over. Defaults to `close.shape`.
        keys (sequence): Outermost column level.

            Each element should correspond to one iteration over columns in `close`.
            Should be set only if `target_shape` is bigger than `close.shape`.
        init_cash (InitCashMode, float or array_like of float): Initial capital.

            By default, will broadcast to the number of columns.
            If cash sharing is enabled, will broadcast to the number of groups.
            See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

            !!! note
                Make sure that `init_cash` is a floating number if not using `InitCashMode`.
        cash_sharing (bool): Whether to share cash within the same group.

            !!! warning
                Order execution cannot be considered parallel anymore.
        call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

            * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
            * Set to array to specify custom sequence. Will not broadcast.
        active_mask (bool or array_like): Mask of whether a particular segment should be executed.

            By default, will broadcast to the number of rows and groups.
        min_size (float or array_like): Minimum size for an order to be accepted.

            Will broadcast to the number of columns.
        prep_func_nb (callable): Simulation preparation function.
        prep_args (tuple): Packed arguments passed to `prep_func_nb`.

            Defaults to `()`.
        group_prep_func_nb (callable): Group preparation function.

            Called only if `row_wise` is `False`.
        group_prep_args (tuple): Packed arguments passed to `group_prep_func_nb`.

            Defaults to `()`.
        row_prep_func_nb (callable): Row preparation function.

            Called only if `row_wise` is `True`.
        row_prep_args (tuple): Packed arguments passed to `row_prep_func_nb`.

            Defaults to `()`.
        segment_prep_func_nb (callable): Segment preparation function.
        segment_prep_args (tuple): Packed arguments passed to `segment_prep_func_nb`.

            Defaults to `()`.
        row_wise (bool): Whether to iterate over rows rather than columns/groups.

            See `vectorbt.portfolio.nb.simulate_row_wise_nb`.
        seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
        freq (any): Index frequency in case `close.index` is not datetime-like.
        group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
        wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
        **kwargs: Keyword arguments passed to the `__init__` method.

    For defaults, see `vectorbt.defaults.portfolio`.

    !!! note
        All passed functions should be Numba-compiled.

        Objects passed as arguments to both functions will not broadcast to `target_shape`
        as their purpose is unknown. You should broadcast manually or use flexible indexing.

        Also see notes on `Portfolio.from_orders`.
    &#34;&#34;&#34;
    # Get defaults
    if target_shape is None:
        target_shape = close.shape
    if init_cash is None:
        init_cash = defaults.portfolio[&#39;init_cash&#39;]
        if isinstance(init_cash, str):
            init_cash = getattr(InitCashMode, init_cash)
    if isinstance(init_cash, int):
        checks.assert_in(init_cash, InitCashMode)
        init_cash_mode = init_cash
        init_cash = np.inf
    else:
        init_cash_mode = None
    if cash_sharing is None:
        cash_sharing = defaults.portfolio[&#39;cash_sharing&#39;]
    if call_seq is None:
        call_seq = defaults.portfolio[&#39;call_seq&#39;]
        if isinstance(call_seq, str):
            call_seq = getattr(CallSeqType, call_seq)
    if isinstance(call_seq, int):
        checks.assert_in(call_seq, CallSeqType)
        if call_seq == CallSeqType.Auto:
            raise ValueError(&#34;CallSeqType.Auto should be implemented manually.&#34;
                             &#34;Use auto_call_seq_ctx_nb in segment_prep_func_nb.&#34;)
    if active_mask is None:
        active_mask = True
    if min_size is None:
        min_size = defaults.portfolio[&#39;min_size&#39;]
    if row_wise is None:
        row_wise = defaults.portfolio[&#39;row_wise&#39;]
    if seed is None:
        seed = defaults.portfolio[&#39;seed&#39;]
    if seed is not None:
        set_seed(seed)
    if freq is None:
        freq = defaults.portfolio[&#39;freq&#39;]
    if broadcast_kwargs is None:
        broadcast_kwargs = {}
    require_kwargs = dict(require_kwargs=dict(requirements=&#39;W&#39;))
    broadcast_kwargs = merge_kwargs(require_kwargs, broadcast_kwargs)
    if wrapper_kwargs is None:
        wrapper_kwargs = {}
    if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
        raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

    # Perform checks
    checks.assert_type(close, (pd.Series, pd.DataFrame))
    checks.assert_subdtype(close, np.floating)
    checks.assert_subdtype(init_cash, np.floating)
    checks.assert_subdtype(call_seq, np.integer)

    # Broadcast inputs
    target_shape_2d = (target_shape[0], target_shape[1] if len(target_shape) &gt; 1 else 1)
    if close.shape != target_shape:
        if len(close.vbt.columns) &lt;= target_shape_2d[1]:
            if target_shape_2d[1] % len(close.vbt.columns) != 0:
                raise ValueError(&#34;Cannot broadcast close to target_shape&#34;)
            if keys is None:
                keys = pd.Index(np.arange(target_shape_2d[1]), name=&#39;iteration_idx&#39;)
            tile_times = target_shape_2d[1] // len(close.vbt.columns)
            close = close.vbt.tile(tile_times, keys=keys)
    close = broadcast(close, to_shape=target_shape, **broadcast_kwargs)
    min_size = np.require(np.broadcast_to(min_size, (target_shape_2d[1],)), requirements=&#39;W&#39;)
    wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
    cs_group_counts = wrapper.grouper.get_group_counts(group_by=cash_sharing)
    init_cash = np.broadcast_to(init_cash, (len(cs_group_counts),))
    group_counts = wrapper.grouper.get_group_counts(group_by=group_by)
    active_mask = broadcast(
        active_mask,
        to_shape=(target_shape_2d[0], len(group_counts)),
        to_pd=False,
        **require_kwargs
    )
    if checks.is_array(call_seq):
        call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
    else:
        call_seq = nb.build_call_seq(target_shape_2d, group_counts, call_seq_type=call_seq)

    # Prepare arguments
    if prep_func_nb is None:
        prep_func_nb = nb.empty_prep_nb
    if prep_args is None:
        prep_args = ()
    if group_prep_func_nb is None:
        group_prep_func_nb = nb.empty_prep_nb
    if group_prep_args is None:
        group_prep_args = ()
    if row_prep_func_nb is None:
        row_prep_func_nb = nb.empty_prep_nb
    if row_prep_args is None:
        row_prep_args = ()
    if segment_prep_func_nb is None:
        segment_prep_func_nb = nb.empty_prep_nb
    if segment_prep_args is None:
        segment_prep_args = ()

    prep_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in prep_args])
    group_prep_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in group_prep_args])
    row_prep_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in row_prep_args])
    segment_prep_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in segment_prep_args])
    order_args = tuple([arg.values if checks.is_pandas(arg) else arg for arg in order_args])

    # Perform calculation
    if row_wise:
        order_records = nb.simulate_row_wise_nb(
            target_shape_2d,
            to_2d(close, raw=True),
            group_counts,
            init_cash,
            cash_sharing,
            call_seq,
            active_mask,
            min_size,
            prep_func_nb,
            prep_args,
            row_prep_func_nb,
            row_prep_args,
            segment_prep_func_nb,
            segment_prep_args,
            order_func_nb,
            order_args
        )
    else:
        order_records = nb.simulate_nb(
            target_shape_2d,
            to_2d(close, raw=True),
            group_counts,
            init_cash,
            cash_sharing,
            call_seq,
            active_mask,
            min_size,
            prep_func_nb,
            prep_args,
            group_prep_func_nb,
            group_prep_args,
            segment_prep_func_nb,
            segment_prep_args,
            order_func_nb,
            order_args
        )

    # Create an instance
    orders = Orders(wrapper, order_records, close)
    return cls(
        orders,
        init_cash,
        cash_sharing,
        call_seq,
        init_cash_mode=init_cash_mode,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.from_orders"><code class="name flex">
<span>def <span class="ident fname">from_orders</span></span>(<span>close, order_size, size_type=None, order_price=None, fees=None, fixed_fees=None, slippage=None, reject_prob=None, min_size=None, init_cash=None, cash_sharing=None, call_seq=None, val_price=None, freq=None, seed=None, group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate portfolio from orders.</p>
<p>Starting with initial cash <code>init_cash</code>, orders the number of shares specified in <code>order_size</code>
for <code>order_price</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>close</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>
<p>Reference price, such as close. Will broadcast.</p>
<p>Will be used for calculating unrealized P&amp;L and portfolio value.</p>
</dd>
<dt><strong><code>order_size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>
<p>Size to order. Will broadcast.</p>
<p>For any size type:</p>
<ul>
<li>Set to <code>np.nan</code> to skip.</li>
<li>Set to <code>np.inf</code>/<code>-np.inf</code> to buy/sell everything.</li>
</ul>
<p>For <code>SizeType.Shares</code>:</p>
<ul>
<li>Set to positive/negative to buy/sell.</li>
<li>Set to zero to skip.</li>
</ul>
<p>For target size, the final size will depend upon current holdings.</p>
</dd>
<dt><strong><code>size_type</code></strong> :&ensp;<code>SizeType</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.enums.SizeType" href="enums.html#vectorbt.portfolio.enums.SizeType">SizeType</a></code>.</dd>
<dt><strong><code>order_price</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>
<p>Order price. Defaults to <code>close</code>. Will broadcast.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Setting order price to close is risky.</p>
</div>
</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fees in percentage of the order value. Will broadcast.</dd>
<dt><strong><code>fixed_fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fixed amount of fees to pay per order. Will broadcast.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of price. Will broadcast.</dd>
<dt><strong><code>reject_prob</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Order rejection probability. Will broadcast.</dd>
<dt><strong><code>min_size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>
<p>Minimum size for an order to be accepted.</p>
<p>Will broadcast to the number of columns.</p>
</dd>
<dt><strong><code>init_cash</code></strong> :&ensp;<code>InitCashMode, float</code> or <code>array_like</code> of <code>float</code></dt>
<dd>
<p>Initial capital.</p>
<p>By default, will broadcast to the number of columns.
If cash sharing is enabled, will broadcast to the number of groups.
See <code><a title="vectorbt.portfolio.enums.InitCashMode" href="enums.html#vectorbt.portfolio.enums.InitCashMode">InitCashMode</a></code> to find optimal initial cash.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Make sure that <code>init_cash</code> is a floating number if not using <code>InitCashMode</code>.</p>
</div>
</dd>
<dt><strong><code>cash_sharing</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to share cash within the same group.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Order execution cannot be considered parallel anymore.</p>
<p>This method presumes that in a group of assets that share the same capital all
orders will be executed within the same tick and retain their price regardless
of their position in the queue, even though they depend upon each other and thus
cannot be executed in parallel. This behavior is risky.</p>
</div>
</dd>
<dt><strong><code>call_seq</code></strong> :&ensp;<code>CallSeqType</code> or <code>array_like</code> of <code>int</code></dt>
<dd>
<p>Default sequence of calls per row and group.</p>
<ul>
<li>Use <code><a title="vectorbt.portfolio.enums.CallSeqType" href="enums.html#vectorbt.portfolio.enums.CallSeqType">CallSeqType</a></code> to select a sequence type.</li>
<li>Set to array to specify custom sequence. Will not broadcast.</li>
</ul>
<p>If <code>CallSeqType.Auto</code> selected, rearranges calls dynamically based on order value.
Calculates value of all orders per row and group, and sorts them by this value.
Sell orders will be executed first to release funds for buy orders.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code>CallSeqType.Auto</code> should be used with caution:</p>
<ul>
<li>It not only presumes that order prices are known beforehand, but also that
orders can be executed in arbitrary order and still retain their price.
In reality, this is hardly the case: after processing one asset, some time
has passed and the price for other assets might have already changed.</li>
<li>Even if you're able to specify a slippage large enough to compensate for
this behavior, slippage itself should depend upon execution order.
This method doesn't let you do that.</li>
<li>If one order is rejected, it still will execute next orders and possibly
leave them without funds that could have been released by the first order.</li>
</ul>
<p>For more control, use <code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">Portfolio.from_order_func()</a></code>.</p>
</div>
</dd>
<dt><strong><code>val_price</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>
<p>Size valuation price. Defaults to previous <code>close</code>.
Will broadcast.</p>
<p>Used to calculate <code>SizeType.TargetPercent</code> and <code>SizeType.TargetValue</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Make sure to use timestamp for <code>val_price</code> that comes before timestamps of all orders
in the group with cash sharing, otherwise you're cheating yourself.</p>
</div>
</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Seed to be set for both <code>call_seq</code> and at the beginning of the simulation.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Index frequency in case <code>close.index</code> is not datetime-like.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>broadcast_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.</dd>
<dt><strong><code>wrapper_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</dd>
</dl>
<p>All time series will be broadcast together using <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.
At the end, they will have the same metadata.</p>
<p>For defaults, see <code><a title="vectorbt.defaults.portfolio" href="../defaults.html#vectorbt.defaults.portfolio">portfolio</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When <code>call_seq</code> is not <code>CallSeqType.Auto</code>, at each timestamp, processing of the assets in
a group goes strictly in order defined in <code>call_seq</code>. This order can't be changed dynamically.</p>
<p>This has one big implication for this particular method: the last asset in the call stack
cannot be processed until other assets are processed. This is the reason why rebalancing
cannot work properly in this setting: one has to specify percentages for all assets beforehand
and then tweak the processing order to sell to-be-sold assets first in order to release funds
for to-be-bought assets. This can be automatically done by using <code>CallSeqType.Auto</code>.</p>
</div>
<h2 id="example">Example</h2>
<p>The same equal-weighted portfolio as in <code><a title="vectorbt.portfolio.nb.simulate_nb" href="nb.html#vectorbt.portfolio.nb.simulate_nb">simulate_nb()</a></code>.
It's more compact but has no control over how order of execution impacts order price.</p>
<pre><code class="python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, CallSeqType

&gt;&gt;&gt; np.random.seed(42)
&gt;&gt;&gt; price = pd.DataFrame(np.random.uniform(1, 10, size=(5, 3)))
&gt;&gt;&gt; orders = pd.DataFrame(np.full((5, 3), 1.) / 3)  # each column 33.3%
&gt;&gt;&gt; orders[1::2] = np.nan  # skip every second tick

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
...     price,  # reference price for portfolio value
...     orders,
...     order_price=price,  # order price
...     size_type=SizeType.TargetPercent,
...     val_price=price,  # order price known beforehand (don't do it)
...     call_seq=CallSeqType.Auto,  # first sell then buy
...     group_by=np.array([0, 0, 0]),
...     cash_sharing=True,
...     fees=0.001, fixed_fees=1., slippage=0.001
... )

&gt;&gt;&gt; portfolio.holding_value(group_by=False)
           0          1          2
0  33.333333  33.333333  30.139624
1  48.716002   8.385865   9.548589
2  19.546625  22.584433  22.584433
3  94.638155   3.043394  34.278783
4  41.923304  38.661499  41.923304
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_orders(cls, close, order_size, size_type=None, order_price=None, fees=None, fixed_fees=None,
                slippage=None, reject_prob=None, min_size=None, init_cash=None, cash_sharing=None,
                call_seq=None, val_price=None, freq=None, seed=None, group_by=None, broadcast_kwargs=None,
                wrapper_kwargs=None, **kwargs):
    &#34;&#34;&#34;Simulate portfolio from orders.

    Starting with initial cash `init_cash`, orders the number of shares specified in `order_size`
    for `order_price`.

    Args:
        close (pandas_like): Reference price, such as close. Will broadcast.

            Will be used for calculating unrealized P&amp;L and portfolio value.
        order_size (float or array_like): Size to order. Will broadcast.

            For any size type:

            * Set to `np.nan` to skip.
            * Set to `np.inf`/`-np.inf` to buy/sell everything.

            For `SizeType.Shares`:

            * Set to positive/negative to buy/sell.
            * Set to zero to skip.

            For target size, the final size will depend upon current holdings.
        size_type (SizeType or array_like): See `vectorbt.portfolio.enums.SizeType`.
        order_price (array_like of float): Order price. Defaults to `close`. Will broadcast.

            !!! note
                Setting order price to close is risky.
        fees (float or array_like): Fees in percentage of the order value. Will broadcast.
        fixed_fees (float or array_like): Fixed amount of fees to pay per order. Will broadcast.
        slippage (float or array_like): Slippage in percentage of price. Will broadcast.
        reject_prob (float or array_like): Order rejection probability. Will broadcast.
        min_size (float or array_like): Minimum size for an order to be accepted.

            Will broadcast to the number of columns.
        init_cash (InitCashMode, float or array_like of float): Initial capital.

            By default, will broadcast to the number of columns.
            If cash sharing is enabled, will broadcast to the number of groups.
            See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

            !!! note
                Make sure that `init_cash` is a floating number if not using `InitCashMode`.
        cash_sharing (bool): Whether to share cash within the same group.

            !!! warning
                Order execution cannot be considered parallel anymore.

                This method presumes that in a group of assets that share the same capital all
                orders will be executed within the same tick and retain their price regardless
                of their position in the queue, even though they depend upon each other and thus
                cannot be executed in parallel. This behavior is risky.
        call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

            * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
            * Set to array to specify custom sequence. Will not broadcast.

            If `CallSeqType.Auto` selected, rearranges calls dynamically based on order value.
            Calculates value of all orders per row and group, and sorts them by this value.
            Sell orders will be executed first to release funds for buy orders.

            !!! warning
                `CallSeqType.Auto` should be used with caution:

                * It not only presumes that order prices are known beforehand, but also that
                    orders can be executed in arbitrary order and still retain their price.
                    In reality, this is hardly the case: after processing one asset, some time
                    has passed and the price for other assets might have already changed.
                * Even if you&#39;re able to specify a slippage large enough to compensate for
                    this behavior, slippage itself should depend upon execution order.
                    This method doesn&#39;t let you do that.
                * If one order is rejected, it still will execute next orders and possibly
                    leave them without funds that could have been released by the first order.

                For more control, use `Portfolio.from_order_func`.
        val_price (array_like of float): Size valuation price. Defaults to previous `close`.
            Will broadcast.

            Used to calculate `SizeType.TargetPercent` and `SizeType.TargetValue`.

            !!! note
                Make sure to use timestamp for `val_price` that comes before timestamps of all orders
                in the group with cash sharing, otherwise you&#39;re cheating yourself.
        seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
        freq (any): Index frequency in case `close.index` is not datetime-like.
        group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
        wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.

    All time series will be broadcast together using `vectorbt.base.reshape_fns.broadcast`.
    At the end, they will have the same metadata.

    For defaults, see `vectorbt.defaults.portfolio`.

    !!! note
        When `call_seq` is not `CallSeqType.Auto`, at each timestamp, processing of the assets in
        a group goes strictly in order defined in `call_seq`. This order can&#39;t be changed dynamically.

        This has one big implication for this particular method: the last asset in the call stack
        cannot be processed until other assets are processed. This is the reason why rebalancing
        cannot work properly in this setting: one has to specify percentages for all assets beforehand
        and then tweak the processing order to sell to-be-sold assets first in order to release funds
        for to-be-bought assets. This can be automatically done by using `CallSeqType.Auto`.

    Example:
        The same equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb`.
        It&#39;s more compact but has no control over how order of execution impacts order price.

        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; import vectorbt as vbt
        &gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, CallSeqType

        &gt;&gt;&gt; np.random.seed(42)
        &gt;&gt;&gt; price = pd.DataFrame(np.random.uniform(1, 10, size=(5, 3)))
        &gt;&gt;&gt; orders = pd.DataFrame(np.full((5, 3), 1.) / 3)  # each column 33.3%
        &gt;&gt;&gt; orders[1::2] = np.nan  # skip every second tick

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
        ...     price,  # reference price for portfolio value
        ...     orders,
        ...     order_price=price,  # order price
        ...     size_type=SizeType.TargetPercent,
        ...     val_price=price,  # order price known beforehand (don&#39;t do it)
        ...     call_seq=CallSeqType.Auto,  # first sell then buy
        ...     group_by=np.array([0, 0, 0]),
        ...     cash_sharing=True,
        ...     fees=0.001, fixed_fees=1., slippage=0.001
        ... )

        &gt;&gt;&gt; portfolio.holding_value(group_by=False)
                   0          1          2
        0  33.333333  33.333333  30.139624
        1  48.716002   8.385865   9.548589
        2  19.546625  22.584433  22.584433
        3  94.638155   3.043394  34.278783
        4  41.923304  38.661499  41.923304
        ```
    &#34;&#34;&#34;
    # Get defaults
    if order_size is None:
        order_size = defaults.portfolio[&#39;order_size&#39;]
    if size_type is None:
        size_type = defaults.portfolio[&#39;size_type&#39;]
        if isinstance(size_type, str):
            size_type = getattr(SizeType, size_type)
    if order_price is None:
        order_price = close
    if fees is None:
        fees = defaults.portfolio[&#39;fees&#39;]
    if fixed_fees is None:
        fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
    if slippage is None:
        slippage = defaults.portfolio[&#39;slippage&#39;]
    if reject_prob is None:
        reject_prob = defaults.portfolio[&#39;reject_prob&#39;]
    if min_size is None:
        min_size = defaults.portfolio[&#39;min_size&#39;]
    if init_cash is None:
        init_cash = defaults.portfolio[&#39;init_cash&#39;]
        if isinstance(init_cash, str):
            init_cash = getattr(InitCashMode, init_cash)
    if isinstance(init_cash, int):
        checks.assert_in(init_cash, InitCashMode)
        init_cash_mode = init_cash
        init_cash = np.inf
    else:
        init_cash_mode = None
    if cash_sharing is None:
        cash_sharing = defaults.portfolio[&#39;cash_sharing&#39;]
    if call_seq is None:
        call_seq = defaults.portfolio[&#39;call_seq&#39;]
        if isinstance(call_seq, str):
            call_seq = getattr(CallSeqType, call_seq)
    auto_call_seq = False
    if isinstance(call_seq, int):
        checks.assert_in(call_seq, CallSeqType)
        if call_seq == CallSeqType.Auto:
            call_seq = CallSeqType.Default
            auto_call_seq = True
    if val_price is None:
        val_price = close.vbt.fshift(1)
    if seed is None:
        seed = defaults.portfolio[&#39;seed&#39;]
    if seed is not None:
        set_seed(seed)
    if freq is None:
        freq = defaults.portfolio[&#39;freq&#39;]
    if broadcast_kwargs is None:
        broadcast_kwargs = {}
    if wrapper_kwargs is None:
        wrapper_kwargs = {}
    if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
        raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

    # Perform checks
    checks.assert_type(close, (pd.Series, pd.DataFrame))
    checks.assert_subdtype(close, np.floating)
    checks.assert_subdtype(order_size, np.floating)
    checks.assert_subdtype(size_type, np.integer)
    checks.assert_subdtype(order_price, np.floating)
    checks.assert_subdtype(fees, np.floating)
    checks.assert_subdtype(fixed_fees, np.floating)
    checks.assert_subdtype(slippage, np.floating)
    checks.assert_subdtype(reject_prob, np.floating)
    checks.assert_subdtype(min_size, np.floating)
    checks.assert_subdtype(init_cash, np.floating)
    checks.assert_subdtype(call_seq, np.integer)
    checks.assert_subdtype(val_price, np.floating)

    # Broadcast inputs
    # Only close is broadcast, others can remain unchanged thanks to flexible indexing
    keep_raw = (False, True, True, True, True, True, True, True, True, True)
    broadcast_kwargs = merge_kwargs(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
    close, order_size, size_type, order_price, fees, fixed_fees, slippage, reject_prob, val_price = \
        broadcast(close, order_size, size_type, order_price, fees, fixed_fees, slippage,
                  reject_prob, val_price, **broadcast_kwargs, keep_raw=keep_raw)
    target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
    min_size = np.require(np.broadcast_to(min_size, (target_shape_2d[1],)), requirements=&#39;W&#39;)
    wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
    cs_group_counts = wrapper.grouper.get_group_counts(group_by=cash_sharing)
    init_cash = np.broadcast_to(init_cash, (len(cs_group_counts),))
    group_counts = wrapper.grouper.get_group_counts(group_by=group_by)
    if checks.is_array(call_seq):
        call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
    else:
        call_seq = nb.build_call_seq(target_shape_2d, group_counts, call_seq_type=call_seq)

    # Perform calculation
    order_records = nb.simulate_from_orders_nb(
        target_shape_2d,
        cs_group_counts,  # group only if cash sharing is enabled to speed up
        init_cash,
        call_seq,
        order_size,
        size_type,
        order_price,
        fees,
        fixed_fees,
        slippage,
        reject_prob,
        min_size,
        val_price,
        auto_call_seq,
        close.ndim == 2
    )

    # Create an instance
    orders = Orders(wrapper, order_records, close)
    return cls(
        orders,
        init_cash,
        cash_sharing,
        call_seq,
        init_cash_mode=init_cash_mode,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.from_signals"><code class="name flex">
<span>def <span class="ident fname">from_signals</span></span>(<span>close, entries, exits, size=None, entry_price=None, exit_price=None, fees=None, fixed_fees=None, slippage=None, reject_prob=None, min_size=None, init_cash=None, cash_sharing=None, call_seq=None, accumulate=None, accumulate_exit_mode=None, conflict_mode=None, seed=None, freq=None, group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate portfolio from entry and exit signals.</p>
<p>Starting with initial cash <code>init_cash</code>, for each signal in <code>entries</code>, enters a position
by buying <code>size</code> of shares for <code>entry_price</code>. For each signal in <code>exits</code>, closes the position
by selling all shares for <code>exit_price</code>. When accumulation is enabled, each entry signal will
increase the position, and optionally each exit signal will decrease the position. When both
entry and exit signals are present, ignores them by default. When grouping is enabled with
<code>group_by</code>, will compute performance for the entire group. When, additionally, <code>cash_sharing</code>
is enabled, will share the cash among all columns in the group.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>close</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>
<p>Reference price, such as close. Will broadcast.</p>
<p>Will be used for calculating unrealized P&amp;L and portfolio value.</p>
</dd>
<dt><strong><code>entries</code></strong> :&ensp;<code>array_like</code> of <code>bool</code></dt>
<dd>Boolean array of entry signals. Will broadcast.</dd>
<dt><strong><code>exits</code></strong> :&ensp;<code>array_like</code> of <code>bool</code></dt>
<dd>Boolean array of exit signals. Will broadcast.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>
<p>Size to order. Will broadcast.</p>
<ul>
<li>Set to positive/negative to buy/sell.</li>
<li>Set to <code>np.inf</code>/<code>-np.inf</code> to buy/sell everything.</li>
<li>Set to <code>np.nan</code> or zero to skip.</li>
</ul>
</dd>
<dt><strong><code>entry_price</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>
<p>Entry price. Defaults to <code>close</code>. Will broadcast.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Setting order price to close is risky.</p>
</div>
</dd>
<dt><strong><code>exit_price</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>
<p>Exit price. Defaults to <code>close</code>. Will broadcast.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Setting order price to close is risky.</p>
</div>
</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fees in percentage of the order value. Will broadcast.</dd>
<dt><strong><code>fixed_fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fixed amount of fees to pay per order. Will broadcast.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of price. Will broadcast.</dd>
<dt><strong><code>reject_prob</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Order rejection probability. Will broadcast.</dd>
<dt><strong><code>min_size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>
<p>Minimum size for an order to be accepted.</p>
<p>Will broadcast to the number of columns.</p>
</dd>
<dt><strong><code>init_cash</code></strong> :&ensp;<code>InitCashMode, float</code> or <code>array_like</code> of <code>float</code></dt>
<dd>
<p>Initial capital.</p>
<p>By default, will broadcast to the number of columns.
If cash sharing is enabled, will broadcast to the number of groups.
See <code><a title="vectorbt.portfolio.enums.InitCashMode" href="enums.html#vectorbt.portfolio.enums.InitCashMode">InitCashMode</a></code> to find optimal initial cash.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Make sure that <code>init_cash</code> is a floating number if not using <code>InitCashMode</code>.</p>
</div>
</dd>
<dt><strong><code>cash_sharing</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to share cash within the same group.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Order execution cannot be considered parallel anymore.</p>
<p>This method presumes that in a group of assets that share the same capital all
orders will be executed within the same tick and retain their price regardless
of their position in the queue, even though they depend upon each other and thus
cannot be executed in parallel. This behavior is risky.</p>
</div>
</dd>
<dt><strong><code>call_seq</code></strong> :&ensp;<code>CallSeqType</code> or <code>array_like</code> of <code>int</code></dt>
<dd>
<p>Default sequence of calls per row and group.</p>
<ul>
<li>Use <code><a title="vectorbt.portfolio.enums.CallSeqType" href="enums.html#vectorbt.portfolio.enums.CallSeqType">CallSeqType</a></code> to select a sequence type.</li>
<li>Set to array to specify custom sequence. Will not broadcast.</li>
</ul>
</dd>
<dt><strong><code>accumulate</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>accumulate</code> is <code>True</code>, entering the market when already
in the market will be allowed to increase the position.</dd>
<dt><strong><code>accumulate_exit_mode</code></strong> :&ensp;<code>AccumulateExitMode</code></dt>
<dd>See <code><a title="vectorbt.portfolio.enums.AccumulateExitMode" href="enums.html#vectorbt.portfolio.enums.AccumulateExitMode">AccumulateExitMode</a></code>.</dd>
<dt><strong><code>conflict_mode</code></strong> :&ensp;<code>ConflictMode</code></dt>
<dd>See <code><a title="vectorbt.portfolio.enums.ConflictMode" href="enums.html#vectorbt.portfolio.enums.ConflictMode">ConflictMode</a></code>.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Seed to be set for both <code>call_seq</code> and at the beginning of the simulation.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Index frequency in case <code>close.index</code> is not datetime-like.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>broadcast_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.</dd>
<dt><strong><code>wrapper_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>All time series will be broadcast together using <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.
At the end, they will have the same metadata.</p>
<p>For defaults, see <code><a title="vectorbt.defaults.portfolio" href="../defaults.html#vectorbt.defaults.portfolio">portfolio</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only <code>SizeType.Shares</code> is supported. Other modes such as target percentage are not
compatible with signals since their logic may contradict the direction the user has
specified for the order.</p>
<p>With cash sharing enabled, at each timestamp, processing of the assets in a group
goes strictly in order defined in <code>call_seq</code>. This order can't be changed dynamically.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>If you generated signals using close price, don't forget to shift your signals by one tick
forward, for example, with <code>signals.vbt.fshift(1)</code>. In general, make sure to use a price
that comes after the signal.</p>
</div>
<h2 id="example">Example</h2>
<p>Different ways of how signals are interpreted:</p>
<pre><code class="python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; from vectorbt.portfolio.enums import AccumulateExitMode, ConflictMode

&gt;&gt;&gt; price = pd.Series([1., 2., 3., 4., 5.], index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5)
... ]))
&gt;&gt;&gt; entries = pd.Series([True, True, True, False, False])
&gt;&gt;&gt; exits = pd.Series([False, False, True, True, True])

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
...     price, entries, exits, size=1.)
&gt;&gt;&gt; portfolio.share_flow()
2020-01-01    1.0
2020-01-02    0.0
2020-01-03    0.0
2020-01-04   -1.0
2020-01-05    0.0
dtype: float64

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
...     price, entries, exits, size=1.,
...     conflict_mode=ConflictMode.Exit)
&gt;&gt;&gt; portfolio.share_flow()
2020-01-01    1.0
2020-01-02    0.0
2020-01-03   -1.0
2020-01-04    0.0
2020-01-05    0.0
dtype: float64

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
...     price, entries, exits, size=1.,
...     accumulate=True)
&gt;&gt;&gt; portfolio.share_flow()
2020-01-01    1.0
2020-01-02    1.0
2020-01-03    0.0
2020-01-04   -2.0
2020-01-05    0.0
dtype: float64

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
...     price, entries, exits, size=1.,
...     accumulate=True,
...     accumulate_exit_mode=AccumulateExitMode.Reduce)
&gt;&gt;&gt; portfolio.share_flow()  # same as using from_orders
2020-01-01    1.0
2020-01-02    1.0
2020-01-03    0.0
2020-01-04   -1.0
2020-01-05   -1.0
dtype: float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_signals(cls, close, entries, exits, size=None, entry_price=None, exit_price=None,
                 fees=None, fixed_fees=None, slippage=None, reject_prob=None, min_size=None,
                 init_cash=None, cash_sharing=None, call_seq=None, accumulate=None,
                 accumulate_exit_mode=None, conflict_mode=None, seed=None, freq=None, group_by=None,
                 broadcast_kwargs=None, wrapper_kwargs=None, **kwargs):
    &#34;&#34;&#34;Simulate portfolio from entry and exit signals.

    Starting with initial cash `init_cash`, for each signal in `entries`, enters a position
    by buying `size` of shares for `entry_price`. For each signal in `exits`, closes the position
    by selling all shares for `exit_price`. When accumulation is enabled, each entry signal will
    increase the position, and optionally each exit signal will decrease the position. When both
    entry and exit signals are present, ignores them by default. When grouping is enabled with
    `group_by`, will compute performance for the entire group. When, additionally, `cash_sharing`
    is enabled, will share the cash among all columns in the group.

    Args:
        close (pandas_like): Reference price, such as close. Will broadcast.

            Will be used for calculating unrealized P&amp;L and portfolio value.
        entries (array_like of bool): Boolean array of entry signals. Will broadcast.
        exits (array_like of bool): Boolean array of exit signals. Will broadcast.
        size (float or array_like): Size to order. Will broadcast.

            * Set to positive/negative to buy/sell.
            * Set to `np.inf`/`-np.inf` to buy/sell everything.
            * Set to `np.nan` or zero to skip.
        entry_price (array_like of float): Entry price. Defaults to `close`. Will broadcast.

            !!! note
                Setting order price to close is risky.
        exit_price (array_like of float): Exit price. Defaults to `close`. Will broadcast.

            !!! note
                Setting order price to close is risky.
        fees (float or array_like): Fees in percentage of the order value. Will broadcast.
        fixed_fees (float or array_like): Fixed amount of fees to pay per order. Will broadcast.
        slippage (float or array_like): Slippage in percentage of price. Will broadcast.
        reject_prob (float or array_like): Order rejection probability. Will broadcast.
        min_size (float or array_like): Minimum size for an order to be accepted.

            Will broadcast to the number of columns.
        init_cash (InitCashMode, float or array_like of float): Initial capital.

            By default, will broadcast to the number of columns.
            If cash sharing is enabled, will broadcast to the number of groups.
            See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

            !!! note
                Make sure that `init_cash` is a floating number if not using `InitCashMode`.
        cash_sharing (bool): Whether to share cash within the same group.

            !!! warning
                Order execution cannot be considered parallel anymore.

                This method presumes that in a group of assets that share the same capital all
                orders will be executed within the same tick and retain their price regardless
                of their position in the queue, even though they depend upon each other and thus
                cannot be executed in parallel. This behavior is risky.
        call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

            * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
            * Set to array to specify custom sequence. Will not broadcast.
        accumulate (bool): If `accumulate` is `True`, entering the market when already
            in the market will be allowed to increase the position.
        accumulate_exit_mode (AccumulateExitMode): See `vectorbt.portfolio.enums.AccumulateExitMode`.
        conflict_mode (ConflictMode): See `vectorbt.portfolio.enums.ConflictMode`.
        seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
        freq (any): Index frequency in case `close.index` is not datetime-like.
        group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
        wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
        **kwargs: Keyword arguments passed to the `__init__` method.

    All time series will be broadcast together using `vectorbt.base.reshape_fns.broadcast`.
    At the end, they will have the same metadata.

    For defaults, see `vectorbt.defaults.portfolio`.

    !!! note
        Only `SizeType.Shares` is supported. Other modes such as target percentage are not
        compatible with signals since their logic may contradict the direction the user has
        specified for the order.

        With cash sharing enabled, at each timestamp, processing of the assets in a group
        goes strictly in order defined in `call_seq`. This order can&#39;t be changed dynamically.

    !!! hint
        If you generated signals using close price, don&#39;t forget to shift your signals by one tick
        forward, for example, with `signals.vbt.fshift(1)`. In general, make sure to use a price
        that comes after the signal.

    Example:
        Different ways of how signals are interpreted:

        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from datetime import datetime
        &gt;&gt;&gt; import vectorbt as vbt
        &gt;&gt;&gt; from vectorbt.portfolio.enums import AccumulateExitMode, ConflictMode

        &gt;&gt;&gt; price = pd.Series([1., 2., 3., 4., 5.], index=pd.Index([
        ...     datetime(2020, 1, 1),
        ...     datetime(2020, 1, 2),
        ...     datetime(2020, 1, 3),
        ...     datetime(2020, 1, 4),
        ...     datetime(2020, 1, 5)
        ... ]))
        &gt;&gt;&gt; entries = pd.Series([True, True, True, False, False])
        &gt;&gt;&gt; exits = pd.Series([False, False, True, True, True])

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     price, entries, exits, size=1.)
        &gt;&gt;&gt; portfolio.share_flow()
        2020-01-01    1.0
        2020-01-02    0.0
        2020-01-03    0.0
        2020-01-04   -1.0
        2020-01-05    0.0
        dtype: float64

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     price, entries, exits, size=1.,
        ...     conflict_mode=ConflictMode.Exit)
        &gt;&gt;&gt; portfolio.share_flow()
        2020-01-01    1.0
        2020-01-02    0.0
        2020-01-03   -1.0
        2020-01-04    0.0
        2020-01-05    0.0
        dtype: float64

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     price, entries, exits, size=1.,
        ...     accumulate=True)
        &gt;&gt;&gt; portfolio.share_flow()
        2020-01-01    1.0
        2020-01-02    1.0
        2020-01-03    0.0
        2020-01-04   -2.0
        2020-01-05    0.0
        dtype: float64

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     price, entries, exits, size=1.,
        ...     accumulate=True,
        ...     accumulate_exit_mode=AccumulateExitMode.Reduce)
        &gt;&gt;&gt; portfolio.share_flow()  # same as using from_orders
        2020-01-01    1.0
        2020-01-02    1.0
        2020-01-03    0.0
        2020-01-04   -1.0
        2020-01-05   -1.0
        dtype: float64
        ```
    &#34;&#34;&#34;
    # Get defaults
    if size is None:
        size = defaults.portfolio[&#39;size&#39;]
    if entry_price is None:
        entry_price = close
    if exit_price is None:
        exit_price = close
    if fees is None:
        fees = defaults.portfolio[&#39;fees&#39;]
    if fixed_fees is None:
        fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
    if slippage is None:
        slippage = defaults.portfolio[&#39;slippage&#39;]
    if reject_prob is None:
        reject_prob = defaults.portfolio[&#39;reject_prob&#39;]
    if min_size is None:
        min_size = defaults.portfolio[&#39;min_size&#39;]
    if init_cash is None:
        init_cash = defaults.portfolio[&#39;init_cash&#39;]
        if isinstance(init_cash, str):
            init_cash = getattr(InitCashMode, init_cash)
    if isinstance(init_cash, int):
        checks.assert_in(init_cash, InitCashMode)
        init_cash_mode = init_cash
        init_cash = np.inf
    else:
        init_cash_mode = None
    if cash_sharing is None:
        cash_sharing = defaults.portfolio[&#39;cash_sharing&#39;]
    if call_seq is None:
        call_seq = defaults.portfolio[&#39;call_seq&#39;]
        if isinstance(call_seq, str):
            call_seq = getattr(CallSeqType, call_seq)
    if isinstance(call_seq, int):
        checks.assert_in(call_seq, CallSeqType)
        if call_seq == CallSeqType.Auto:
            raise ValueError(&#34;This method doesn&#39;t support CallSeqType.Auto&#34;)
    if accumulate is None:
        accumulate = defaults.portfolio[&#39;accumulate&#39;]
    if accumulate_exit_mode is None:
        accumulate_exit_mode = defaults.portfolio[&#39;accumulate_exit_mode&#39;]
        if isinstance(accumulate_exit_mode, str):
            accumulate_exit_mode = getattr(AccumulateExitMode, accumulate_exit_mode)
    checks.assert_in(accumulate_exit_mode, AccumulateExitMode)
    if conflict_mode is None:
        conflict_mode = defaults.portfolio[&#39;conflict_mode&#39;]
        if isinstance(conflict_mode, str):
            conflict_mode = getattr(ConflictMode, conflict_mode)
    checks.assert_in(conflict_mode, ConflictMode)
    if seed is None:
        seed = defaults.portfolio[&#39;seed&#39;]
    if seed is not None:
        set_seed(seed)
    if freq is None:
        freq = defaults.portfolio[&#39;freq&#39;]
    if broadcast_kwargs is None:
        broadcast_kwargs = {}
    if wrapper_kwargs is None:
        wrapper_kwargs = {}
    if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
        raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

    # Perform checks
    checks.assert_type(close, (pd.Series, pd.DataFrame))
    checks.assert_subdtype(close, np.floating)
    checks.assert_dtype(entries, np.bool)
    checks.assert_dtype(exits, np.bool)
    checks.assert_subdtype(size, np.floating)
    checks.assert_subdtype(entry_price, np.floating)
    checks.assert_subdtype(exit_price, np.floating)
    checks.assert_subdtype(fees, np.floating)
    checks.assert_subdtype(fixed_fees, np.floating)
    checks.assert_subdtype(slippage, np.floating)
    checks.assert_subdtype(reject_prob, np.floating)
    checks.assert_subdtype(min_size, np.floating)
    checks.assert_subdtype(init_cash, np.floating)
    checks.assert_subdtype(call_seq, np.integer)

    # Broadcast inputs
    # Only close is broadcast, others can remain unchanged thanks to flexible indexing
    keep_raw = (False, True, True, True, True, True, True, True, True, True, True)
    broadcast_kwargs = merge_kwargs(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
    close, entries, exits, size, entry_price, exit_price, fees, fixed_fees, slippage, reject_prob = \
        broadcast(close, entries, exits, size, entry_price, exit_price, fees, fixed_fees,
            slippage, reject_prob, **broadcast_kwargs, keep_raw=keep_raw)
    target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
    min_size = np.require(np.broadcast_to(min_size, (target_shape_2d[1],)), requirements=&#39;W&#39;)
    wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
    cs_group_counts = wrapper.grouper.get_group_counts(group_by=cash_sharing)
    init_cash = np.broadcast_to(init_cash, (len(cs_group_counts),))
    group_counts = wrapper.grouper.get_group_counts(group_by=group_by)
    if checks.is_array(call_seq):
        call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
    else:
        call_seq = nb.build_call_seq(target_shape_2d, group_counts, call_seq_type=call_seq)

    # Perform calculation
    order_records = nb.simulate_from_signals_nb(
        target_shape_2d,
        cs_group_counts,  # group only if cash sharing is enabled to speed up
        init_cash,
        call_seq,
        entries,
        exits,
        size,
        entry_price,
        exit_price,
        fees,
        fixed_fees,
        slippage,
        reject_prob,
        min_size,
        accumulate,
        accumulate_exit_mode,
        conflict_mode,
        close.ndim == 2
    )

    # Create an instance
    orders = Orders(wrapper, order_records, close)
    return cls(
        orders,
        init_cash,
        cash_sharing,
        call_seq,
        init_cash_mode=init_cash_mode,
        **kwargs
    )</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio.call_seq"><code class="name">var <span class="ident fname">call_seq</span></code></dt>
<dd>
<div class="desc"><p>Sequence of calls per row and group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def call_seq(self):
    &#34;&#34;&#34;Sequence of calls per row and group.&#34;&#34;&#34;
    return self.wrapper.wrap(self._call_seq, group_by=False)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cash_sharing"><code class="name">var <span class="ident fname">cash_sharing</span></code></dt>
<dd>
<div class="desc"><p>Whether to share cash within the same group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cash_sharing(self):
    &#34;&#34;&#34;Whether to share cash within the same group.&#34;&#34;&#34;
    return self._cash_sharing</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Price per share series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def close(self):
    &#34;&#34;&#34;Price per share series.&#34;&#34;&#34;
    return self._ref_price</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.incl_unrealized"><code class="name">var <span class="ident fname">incl_unrealized</span></code></dt>
<dd>
<div class="desc"><p>Whether to include unrealized trade P&amp;L in statistics.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def incl_unrealized(self):
    &#34;&#34;&#34;Whether to include unrealized trade P&amp;L in statistics.&#34;&#34;&#34;
    return self._incl_unrealized</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.init_cash"><code class="name">var <span class="ident fname">init_cash</span></code></dt>
<dd>
<div class="desc"><p>Initial amount of cash per column/group.</p>
<p>Returns value per group if <code>cash_sharing</code> is <code>True</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def init_cash(self):
    &#34;&#34;&#34;Initial amount of cash per column/group.

    Returns value per group if `cash_sharing` is `True`.&#34;&#34;&#34;
    if self.init_cash_mode is None:
        init_cash = self._init_cash
    else:
        cash_flow = to_2d(self.cash_flow(group_by=self.cash_sharing), raw=True)
        init_cash = -np.min(np.cumsum(cash_flow, axis=0), axis=0)
        if self.init_cash_mode == InitCashMode.AutoAlign:
            init_cash = np.full(init_cash.shape, np.max(init_cash))
    return self.wrapper.wrap_reduced(init_cash, group_by=self.cash_sharing)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.init_cash_mode"><code class="name">var <span class="ident fname">init_cash_mode</span></code></dt>
<dd>
<div class="desc"><p>Initial cash mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def init_cash_mode(self):
    &#34;&#34;&#34;Initial cash mode.&#34;&#34;&#34;
    return self._init_cash_mode</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.orders"><code class="name">var <span class="ident fname">orders</span></code></dt>
<dd>
<div class="desc"><p>Order records.</p>
<p>See <code><a title="vectorbt.records.orders.Orders" href="../records/orders.html#vectorbt.records.orders.Orders">Orders</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def orders(self):
    &#34;&#34;&#34;Order records.

    See `vectorbt.records.orders.Orders`.&#34;&#34;&#34;
    return self._orders</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.wrapper"><code class="name">var <span class="ident fname">wrapper</span></code></dt>
<dd>
<div class="desc"><p>Array wrapper.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def wrapper(self):
    &#34;&#34;&#34;Array wrapper.&#34;&#34;&#34;
    # Wrapper in orders and here can be different
    wrapper = self.orders.wrapper
    if self.cash_sharing and wrapper.grouper.allow_modify:
        # Cannot change groups if columns within them are dependent
        return wrapper.copy(allow_modify=False)
    return wrapper.copy()</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio.active_returns"><code class="name flex">
<span>def <span class="ident fname">active_returns</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get active return series per column/group.</p>
<p>This type of returns is based solely on cash flows and holding value rather than portfolio value.
It ignores passive cash and thus it will return the same numbers irrespective of the amount of
cash currently available, even <code>np.inf</code>. The scale of returns is comparable to that of going
all in and keeping available cash at zero.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def active_returns(self, group_by=None):
    &#34;&#34;&#34;Get active return series per column/group.

    This type of returns is based solely on cash flows and holding value rather than portfolio value.
    It ignores passive cash and thus it will return the same numbers irrespective of the amount of
    cash currently available, even `np.inf`. The scale of returns is comparable to that of going
    all in and keeping available cash at zero.&#34;&#34;&#34;
    cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
    holding_value = to_2d(self.holding_value(group_by=group_by), raw=True)
    active_returns = nb.active_returns_nb(cash_flow, holding_value)
    return self.wrapper.wrap(active_returns, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.alpha"><code class="name flex">
<span>def <span class="ident fname">alpha</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='alpha', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.alpha" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.alpha">Returns_Accessor.alpha()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.annual_returns"><code class="name flex">
<span>def <span class="ident fname">annual_returns</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='annual', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.annual" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.annual">Returns_Accessor.annual()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.annualized_return"><code class="name flex">
<span>def <span class="ident fname">annualized_return</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='annualized', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.annualized" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.annualized">Returns_Accessor.annualized()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.annualized_volatility"><code class="name flex">
<span>def <span class="ident fname">annualized_volatility</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='annualized_volatility', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.annualized_volatility" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.annualized_volatility">Returns_Accessor.annualized_volatility()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.beta"><code class="name flex">
<span>def <span class="ident fname">beta</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='beta', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.beta" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.beta">Returns_Accessor.beta()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.buy_and_hold_return"><code class="name flex">
<span>def <span class="ident fname">buy_and_hold_return</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get total return of buy-and-hold.</p>
<p>If grouped, invests same amount of cash into each asset and returns the total
return of the entire group.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Does not take into account fees and slippage. For this, create a separate portfolio.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def buy_and_hold_return(self, group_by=None):
    &#34;&#34;&#34;Get total return of buy-and-hold.

    If grouped, invests same amount of cash into each asset and returns the total
    return of the entire group.

    !!! note
        Does not take into account fees and slippage. For this, create a separate portfolio.&#34;&#34;&#34;
    ref_price_filled = to_2d(self.fill_close(), raw=True)
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
        total_return = nb.buy_and_hold_return_grouped_nb(ref_price_filled, group_counts)
    else:
        total_return = nb.buy_and_hold_return_ungrouped_nb(ref_price_filled)
    return self.wrapper.wrap_reduced(total_return, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.calmar_ratio"><code class="name flex">
<span>def <span class="ident fname">calmar_ratio</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='calmar_ratio', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.calmar_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.calmar_ratio">Returns_Accessor.calmar_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.capture"><code class="name flex">
<span>def <span class="ident fname">capture</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='capture', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.capture" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.capture">Returns_Accessor.capture()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cash"><code class="name flex">
<span>def <span class="ident fname">cash</span></span>(<span>self, group_by=None, in_sim_order=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get cash series per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def cash(self, group_by=None, in_sim_order=False):
    &#34;&#34;&#34;Get cash series per column/group.&#34;&#34;&#34;
    if in_sim_order and not self.cash_sharing:
        raise ValueError(&#34;in_sim_order requires enabled cash sharing&#34;)

    cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        init_cash_grouped = to_1d(self.init_cash_regrouped(group_by=group_by), raw=True)
        group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
        cash = nb.cash_grouped_nb(
            self.wrapper.shape_2d,
            cash_flow,
            group_counts,
            init_cash_grouped
        )
    else:
        init_cash = to_1d(self.init_cash, raw=True)
        group_counts = self.wrapper.grouper.get_group_counts()
        call_seq = to_2d(self.call_seq, raw=True)
        cash = nb.cash_ungrouped_nb(
            cash_flow,
            group_counts,
            init_cash,
            self.cash_sharing,
            call_seq,
            in_sim_order
        )
    return self.wrapper.wrap(cash, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cash_flow"><code class="name flex">
<span>def <span class="ident fname">cash_flow</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get cash flow series per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def cash_flow(self, group_by=None):
    &#34;&#34;&#34;Get cash flow series per column/group.&#34;&#34;&#34;
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        cash_flow_ungrouped = to_2d(self.cash_flow(group_by=False), raw=True)
        group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
        cash_flow = nb.cash_flow_grouped_nb(cash_flow_ungrouped, group_counts)
    else:
        cash_flow = nb.cash_flow_ungrouped_nb(self.wrapper.shape_2d, self.orders.records_arr)
    return self.wrapper.wrap(cash_flow, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.conditional_value_at_risk"><code class="name flex">
<span>def <span class="ident fname">conditional_value_at_risk</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='conditional_value_at_risk', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.conditional_value_at_risk" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.conditional_value_at_risk">Returns_Accessor.conditional_value_at_risk()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cumulative_returns"><code class="name flex">
<span>def <span class="ident fname">cumulative_returns</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='cumulative', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.cumulative" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.cumulative">Returns_Accessor.cumulative()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.daily_returns"><code class="name flex">
<span>def <span class="ident fname">daily_returns</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='daily', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.daily" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.daily">Returns_Accessor.daily()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.deflated_sharpe_ratio"><code class="name flex">
<span>def <span class="ident fname">deflated_sharpe_ratio</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='deflated_sharpe_ratio', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.deflated_sharpe_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.deflated_sharpe_ratio">Returns_Accessor.deflated_sharpe_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.down_capture"><code class="name flex">
<span>def <span class="ident fname">down_capture</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='down_capture', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.down_capture" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.down_capture">Returns_Accessor.down_capture()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.downside_risk"><code class="name flex">
<span>def <span class="ident fname">downside_risk</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='downside_risk', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.downside_risk" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.downside_risk">Returns_Accessor.downside_risk()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.drawdown"><code class="name flex">
<span>def <span class="ident fname">drawdown</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='drawdown', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.drawdown" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.drawdown">Returns_Accessor.drawdown()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.drawdowns"><code class="name flex">
<span>def <span class="ident fname">drawdowns</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get drawdown records from <code><a title="vectorbt.portfolio.base.Portfolio.value" href="#vectorbt.portfolio.base.Portfolio.value">Portfolio.value()</a></code>.</p>
<p>See <code><a title="vectorbt.records.drawdowns.Drawdowns" href="../records/drawdowns.html#vectorbt.records.drawdowns.Drawdowns">Drawdowns</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def drawdowns(self, **kwargs):
    &#34;&#34;&#34;Get drawdown records from `Portfolio.value`.

    See `vectorbt.records.drawdowns.Drawdowns`.&#34;&#34;&#34;
    return Drawdowns.from_ts(self.value(**kwargs), freq=self.wrapper.freq)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.fill_close"><code class="name flex">
<span>def <span class="ident fname">fill_close</span></span>(<span>self, ffill=True, bfill=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill NaN values of <code><a title="vectorbt.portfolio.base.Portfolio.close" href="#vectorbt.portfolio.base.Portfolio.close">Portfolio.close</a></code>.</p>
<p>Use <code>ffill</code> and <code>bfill</code> to fill forwards and backwards respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def fill_close(self, ffill=True, bfill=True):
    &#34;&#34;&#34;Fill NaN values of `Portfolio.close`.

    Use `ffill` and `bfill` to fill forwards and backwards respectively.&#34;&#34;&#34;
    close = to_2d(self.close, raw=True)
    if ffill and np.any(np.isnan(close[-1, :])):
        close = generic_nb.ffill_nb(close)
    if bfill and np.any(np.isnan(close[0, :])):
        close = generic_nb.ffill_nb(close[::-1, :])[::-1, :]
    return self.wrapper.wrap(close, group_by=False)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.final_value"><code class="name flex">
<span>def <span class="ident fname">final_value</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get final portfolio value per column/group.</p>
<p>Calculated directly from order records. Very fast.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def final_value(self, group_by=None):
    &#34;&#34;&#34;Get final portfolio value per column/group.

    Calculated directly from order records. Very fast.&#34;&#34;&#34;
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        final_value_ungrouped = to_1d(self.final_value(group_by=False), raw=True)
        init_cash = to_1d(self.init_cash, raw=True)
        group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
        final_value = nb.final_value_grouped_nb(
            final_value_ungrouped,
            init_cash,
            group_counts,
            self.cash_sharing
        )
    else:
        close = to_2d(self.fill_close(), raw=True)
        init_cash_ungrouped = to_1d(self.init_cash_regrouped(group_by=False), raw=True)
        final_value = nb.final_value_ungrouped_nb(
            self.wrapper.shape_2d,
            close,
            self.orders.records_arr,
            init_cash_ungrouped
        )
    return self.wrapper.wrap_reduced(final_value, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.holding_value"><code class="name flex">
<span>def <span class="ident fname">holding_value</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get holding value series per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def holding_value(self, group_by=None):
    &#34;&#34;&#34;Get holding value series per column/group.&#34;&#34;&#34;
    close = to_2d(self.close, raw=True).copy()
    shares = to_2d(self.shares(), raw=True)
    close[shares == 0.] = 0.  # for price being NaN
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
        holding_value = nb.holding_value_grouped_nb(close, shares, group_counts)
    else:
        holding_value = nb.holding_value_ungrouped_nb(close, shares)
    return self.wrapper.wrap(holding_value, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.information_ratio"><code class="name flex">
<span>def <span class="ident fname">information_ratio</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='information_ratio', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.information_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.information_ratio">Returns_Accessor.information_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.init_cash_regrouped"><code class="name flex">
<span>def <span class="ident fname">init_cash_regrouped</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get cash flow series per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def init_cash_regrouped(self, group_by=None):
    &#34;&#34;&#34;Get cash flow series per column/group.&#34;&#34;&#34;
    init_cash = to_1d(self.init_cash, raw=True)
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        group_counts = self.wrapper.grouper.get_group_counts(group_by=group_by)
        init_cash_regrouped = nb.init_cash_grouped_nb(init_cash, group_counts, self.cash_sharing)
    else:
        group_counts = self.wrapper.grouper.get_group_counts()
        init_cash_regrouped = nb.init_cash_ungrouped_nb(init_cash, group_counts, self.cash_sharing)
    return self.wrapper.wrap_reduced(init_cash_regrouped, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.max_drawdown"><code class="name flex">
<span>def <span class="ident fname">max_drawdown</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='max_drawdown', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.max_drawdown" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.max_drawdown">Returns_Accessor.max_drawdown()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.omega_ratio"><code class="name flex">
<span>def <span class="ident fname">omega_ratio</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='omega_ratio', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.omega_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.omega_ratio">Returns_Accessor.omega_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.orders_regrouped"><code class="name flex">
<span>def <span class="ident fname">orders_regrouped</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Regroup order records.</p>
<p>See <code><a title="vectorbt.records.orders.Orders" href="../records/orders.html#vectorbt.records.orders.Orders">Orders</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def orders_regrouped(self, group_by=None):
    &#34;&#34;&#34;Regroup order records.

    See `vectorbt.records.orders.Orders`.&#34;&#34;&#34;
    return self._orders.regroup(group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.positions"><code class="name flex">
<span>def <span class="ident fname">positions</span></span>(<span>self, group_by=None, incl_unrealized=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get position records from orders.</p>
<p>See <code><a title="vectorbt.records.events.Positions" href="../records/events.html#vectorbt.records.events.Positions">Positions</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def positions(self, group_by=None, incl_unrealized=None):
    &#34;&#34;&#34;Get position records from orders.

    See `vectorbt.records.events.Positions`.&#34;&#34;&#34;
    positions = Positions.from_orders(self.orders_regrouped(group_by=group_by))
    if incl_unrealized is None:
        incl_unrealized = self.incl_unrealized
    if incl_unrealized:
        return positions
    return positions.closed</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.regroup"><code class="name flex">
<span>def <span class="ident fname">regroup</span></span>(<span>self, group_by)</span>
</code></dt>
<dd>
<div class="desc"><p>Regroup this object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regroup(self, group_by):
    &#34;&#34;&#34;Regroup this object.&#34;&#34;&#34;
    if self.cash_sharing:
        raise ValueError(&#34;Cannot change grouping globally when cash sharing is enabled&#34;)
    if self.wrapper.grouper.is_grouping_changed(group_by=group_by):
        self.wrapper.grouper.check_group_by(group_by=group_by)
        return self.copy(orders=self.orders.regroup(group_by=group_by))
    return self</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.returns"><code class="name flex">
<span>def <span class="ident fname">returns</span></span>(<span>self, group_by=None, in_sim_order=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get return series per column/group based on portfolio value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def returns(self, group_by=None, in_sim_order=False):
    &#34;&#34;&#34;Get return series per column/group based on portfolio value.&#34;&#34;&#34;
    value = to_2d(self.value(group_by=group_by, in_sim_order=in_sim_order), raw=True)
    if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
        group_counts = self.wrapper.grouper.get_group_counts()
        init_cash = to_1d(self.init_cash, raw=True)
        call_seq = to_2d(self.call_seq, raw=True)
        returns = nb.returns_in_sim_order_nb(value, group_counts, init_cash, call_seq)
    else:
        init_cash_regrouped = to_1d(self.init_cash_regrouped(group_by=group_by), raw=True)
        returns = nb.returns_nb(value, init_cash_regrouped)
    return self.wrapper.wrap(returns, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.share_flow"><code class="name flex">
<span>def <span class="ident fname">share_flow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get share flow series per column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def share_flow(self):
    &#34;&#34;&#34;Get share flow series per column.&#34;&#34;&#34;
    share_flow = nb.share_flow_nb(self.wrapper.shape_2d, self.orders.records_arr)
    return self.wrapper.wrap(share_flow, group_by=False)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.shares"><code class="name flex">
<span>def <span class="ident fname">shares</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get share series per column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def shares(self):
    &#34;&#34;&#34;Get share series per column.&#34;&#34;&#34;
    share_flow = to_2d(self.share_flow(), raw=True)
    shares = nb.shares_nb(share_flow)
    return self.wrapper.wrap(shares, group_by=False)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.sharpe_ratio"><code class="name flex">
<span>def <span class="ident fname">sharpe_ratio</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='sharpe_ratio', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.sharpe_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.sharpe_ratio">Returns_Accessor.sharpe_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.sortino_ratio"><code class="name flex">
<span>def <span class="ident fname">sortino_ratio</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='sortino_ratio', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.sortino_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.sortino_ratio">Returns_Accessor.sortino_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.stats"><code class="name flex">
<span>def <span class="ident fname">stats</span></span>(<span>self, column=None, group_by=None, incl_unrealized=None, active_returns=False, agg_func=&lt;function mean&gt;, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute various statistics on this portfolio.</p>
<p><code>kwargs</code> will be passed to each <code><a title="vectorbt.returns.accessors.Returns_Accessor" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor">Returns_Accessor</a></code> method.</p>
<p>Can either return aggregated statistics by reducing metrics of all columns with
<code>agg_func</code> (mean by default) or return statistics for a single column if <code>column</code>
was specified or portfolio contains only one column of data. To display rich data types
such as durations correctly, use an aggregation function that can be applied on <code>pd.Series</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use <code>column</code> only if caching is enabled, otherwise it may re-compute the same
objects multiple times.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def stats(self, column=None, group_by=None, incl_unrealized=None, active_returns=False,
          agg_func=np.mean, **kwargs):
    &#34;&#34;&#34;Compute various statistics on this portfolio.

    `kwargs` will be passed to each `vectorbt.returns.accessors.Returns_Accessor` method.

    Can either return aggregated statistics by reducing metrics of all columns with
    `agg_func` (mean by default) or return statistics for a single column if `column`
    was specified or portfolio contains only one column of data. To display rich data types
    such as durations correctly, use an aggregation function that can be applied on `pd.Series`.

    !!! note
        Use `column` only if caching is enabled, otherwise it may re-compute the same
        objects multiple times.&#34;&#34;&#34;
    def _reduce(obj):
        if checks.is_series(obj):
            if column is not None:
                return obj[column]
            return agg_func(obj)
        return obj

    # Pre-calculate
    positions = self.positions(group_by=group_by, incl_unrealized=incl_unrealized)
    trades = self.trades(group_by=group_by, incl_unrealized=incl_unrealized)
    drawdowns = self.drawdowns(group_by=group_by)
    if active_returns:
        returns = self.active_returns(group_by=group_by)
    else:
        returns = self.returns(group_by=group_by)

    name = column
    if name is None:
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            if self.wrapper.grouped_ndim == 1:
                name = self.wrapper.grouper.get_columns(group_by=group_by)[0]
            else:
                name = agg_func.__name__
        else:
            if self.wrapper.ndim == 1:
                name = self.wrapper.name
            else:
                name = agg_func.__name__
    return pd.Series({
        &#39;Start&#39;: self.wrapper.index[0],
        &#39;End&#39;: self.wrapper.index[-1],
        &#39;Duration&#39;: self.wrapper.shape[0] * self.wrapper.freq,
        &#39;Holding Duration [%]&#39;: _reduce(positions.coverage() * 100),
        &#39;Total Profit&#39;: _reduce(self.total_profit(group_by=group_by)),
        &#39;Total Return [%]&#39;: _reduce(self.total_return(group_by=group_by) * 100),
        &#39;Buy &amp; Hold Return [%]&#39;: _reduce(self.buy_and_hold_return(group_by=group_by) * 100),
        &#39;Max. Drawdown [%]&#39;: _reduce(-drawdowns.max_drawdown() * 100),
        &#39;Avg. Drawdown [%]&#39;: _reduce(-drawdowns.avg_drawdown() * 100),
        &#39;Max. Drawdown Duration&#39;: _reduce(drawdowns.max_duration()),
        &#39;Avg. Drawdown Duration&#39;: _reduce(drawdowns.avg_duration()),
        &#39;Num. Trades&#39;: _reduce(trades.count()),
        &#39;Win Rate [%]&#39;: _reduce(trades.win_rate() * 100),
        &#39;Best Trade [%]&#39;: _reduce(trades.returns.max() * 100),
        &#39;Worst Trade [%]&#39;: _reduce(trades.returns.min() * 100),
        &#39;Avg. Trade [%]&#39;: _reduce(trades.returns.mean() * 100),
        &#39;Max. Trade Duration&#39;: _reduce(trades.duration.max(time_units=True)),
        &#39;Avg. Trade Duration&#39;: _reduce(trades.duration.mean(time_units=True)),
        &#39;Expectancy&#39;: _reduce(trades.expectancy()),
        &#39;SQN&#39;: _reduce(trades.sqn()),
        &#39;Sharpe Ratio&#39;: _reduce(self.sharpe_ratio(reuse_returns=returns, **kwargs)),
        &#39;Sortino Ratio&#39;: _reduce(self.sortino_ratio(reuse_returns=returns, **kwargs)),
        &#39;Calmar Ratio&#39;: _reduce(self.calmar_ratio(reuse_returns=returns, **kwargs))
    }, name=name)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.tail_ratio"><code class="name flex">
<span>def <span class="ident fname">tail_ratio</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='tail_ratio', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.tail_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.tail_ratio">Returns_Accessor.tail_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.total_profit"><code class="name flex">
<span>def <span class="ident fname">total_profit</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get total profit per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def total_profit(self, group_by=None):
    &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
    init_cash_regrouped = to_1d(self.init_cash_regrouped(group_by=group_by), raw=True)
    final_value = to_1d(self.final_value(group_by=group_by), raw=True)
    total_profit = nb.total_profit_nb(init_cash_regrouped, final_value)
    return self.wrapper.wrap_reduced(total_profit, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.total_return"><code class="name flex">
<span>def <span class="ident fname">total_return</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get total profit per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def total_return(self, group_by=None):
    &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
    init_cash_regrouped = to_1d(self.init_cash_regrouped(group_by=group_by), raw=True)
    final_value = to_1d(self.final_value(group_by=group_by), raw=True)
    total_return = nb.total_return_nb(init_cash_regrouped, final_value)
    return self.wrapper.wrap_reduced(total_return, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.trades"><code class="name flex">
<span>def <span class="ident fname">trades</span></span>(<span>self, group_by=None, incl_unrealized=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get trade records from orders.</p>
<p>See <code><a title="vectorbt.records.events.Trades" href="../records/events.html#vectorbt.records.events.Trades">Trades</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def trades(self, group_by=None, incl_unrealized=None):
    &#34;&#34;&#34;Get trade records from orders.

    See `vectorbt.records.events.Trades`.&#34;&#34;&#34;
    trades = Trades.from_orders(self.orders_regrouped(group_by=group_by))
    if incl_unrealized is None:
        incl_unrealized = self.incl_unrealized
    if incl_unrealized:
        return trades
    return trades.closed</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.up_capture"><code class="name flex">
<span>def <span class="ident fname">up_capture</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='up_capture', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.up_capture" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.up_capture">Returns_Accessor.up_capture()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.value"><code class="name flex">
<span>def <span class="ident fname">value</span></span>(<span>self, group_by=None, in_sim_order=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get portfolio value series per column/group.</p>
<p>By default, will generate portfolio value for each asset based on cash flows and thus
independent from other assets, with initial cash and shares being that of the entire group.
Useful for generating returns and comparing assets within the same group.</p>
<p>When <code>group_by</code> is <code>False</code> and <code>in_sim_order</code> is <code>True</code>, returns value generated in
simulation order (see <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">row-major order</a>.
This value cannot be used for generating returns as-is. Useful to analyze how value
evolved throughout simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def value(self, group_by=None, in_sim_order=False):
    &#34;&#34;&#34;Get portfolio value series per column/group.

    By default, will generate portfolio value for each asset based on cash flows and thus
    independent from other assets, with initial cash and shares being that of the entire group.
    Useful for generating returns and comparing assets within the same group.

    When `group_by` is `False` and `in_sim_order` is `True`, returns value generated in
    simulation order (see [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
    This value cannot be used for generating returns as-is. Useful to analyze how value
    evolved throughout simulation.&#34;&#34;&#34;
    cash = to_2d(self.cash(group_by=group_by, in_sim_order=in_sim_order), raw=True)
    holding_value = to_2d(self.holding_value(group_by=group_by), raw=True)
    if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
        group_counts = self.wrapper.grouper.get_group_counts()
        call_seq = to_2d(self.call_seq, raw=True)
        value = nb.value_in_sim_order_nb(cash, holding_value, group_counts, call_seq)
        # price of NaN is already addressed by ungrouped_value_nb
    else:
        value = nb.value_nb(cash, holding_value)
    return self.wrapper.wrap(value, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.value_at_risk"><code class="name flex">
<span>def <span class="ident fname">value_at_risk</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='value_at_risk', active_returns=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.value_at_risk" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.value_at_risk">Returns_Accessor.value_at_risk()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.utils.config.Configured.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.utils.config.Configured.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
</ul>
</li>
<li><code><b><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.indexing.PandasIndexer.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAACXBIWXMAACcQAAAnEAGUaVEZAAAGuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDggNzkuMTY0MDM2LCAyMDE5LzA4LzEzLTAxOjA2OjU3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjEuMCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjAtMDYtMjVUMjM6MzU6MTMrMDI6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjAtMDYtMjZUMTQ6MTA6MzgrMDI6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIwLTA2LTI2VDE0OjEwOjM4KzAyOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNzE0MGFiYi05Mjk1LTQ3MDYtYTNhZi1lMDg2OTFkOTk3NjQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NzZmN2Y4NjAtMThmMi00ZDgxLTg5NjUtNDU5ZjY1NDY2ZGZlIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NzZmN2Y4NjAtMThmMi00ZDgxLTg5NjUtNDU5ZjY1NDY2ZGZlIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjc2ZjdmODYwLTE4ZjItNGQ4MS04OTY1LTQ1OWY2NTQ2NmRmZSIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNVQyMzozNToxMyswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2NjI2MGIzLTY0ZmUtNGJiYy1iMTNiLWZkMDU3NDI3NjIyNCIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNlQxMzoyMTo1NSswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjA3MTQwYWJiLTkyOTUtNDcwNi1hM2FmLWUwODY5MWQ5OTc2NCIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNlQxNDoxMDozOCswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Qc/+aQAAAa5JREFUeJzt3cFJA0EYgFEjgj3FGmIjsQexByuxB4vy5kHwELJhCRPekP3eMYdl4Ms/y84Gstsfjg9xHvUCtq4AWAGwAmAFwAqAFQArAFYArABYAbACYAXACoAVACsAVgCsAFgBsAJgBcAKgBUAexp1oe+vz7Ofv7y+dZ0LmgCsAFgBsAJgBcAKgBUAKwBWAKwAWAGwAmAFwAqAFQAb9j5glFHn7KPcej1NAFYAzG9BP+/n3/ld9vwx1051tSYA8xPwZ/03+rqJmVYTgBUAm2UL+re0w6i7br8LunMFwAqAFQArAFYArADYdM8Bd3PKtlITgBUAm2ULurMzzvWaAMxPwNbuuieaAKwAmN+CTtz6/H02TQBWAKwAWAGwAmAFwAqAFQArAFYArABYAbACYAXACoANex8w23n9bOtZ0gRgBcAKgBUAKwBWAKwA2HT/HzDKbOtZ0gRgBcAKgBUAKwBWAKwAWAGwAmAFwAqAFQArAFYArADYbn846jVsWhOAFQArAFYArABYAbACYAXACoAVACsAVgCsAFgBsAJgBcAKgBUAKwBWAKwAWAGwAmC/7uUrwcQVST8AAAAASUVORK5CYII="/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul>
<li><a href="#workflow">Workflow</a><ul>
<li><a href="#example">Example</a></li>
</ul>
</li>
<li><a href="#features">Features</a><ul>
<li><a href="#broadcasting">Broadcasting</a></li>
<li><a href="#grouping">Grouping</a></li>
<li><a href="#indexing">Indexing</a></li>
<li><a href="#caching">Caching</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.portfolio" href="index.html">vectorbt.portfolio</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.portfolio.base.add_returns_methods" href="#vectorbt.portfolio.base.add_returns_methods">add_returns_methods</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.portfolio.base.Portfolio.active_returns" href="#vectorbt.portfolio.base.Portfolio.active_returns">active_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.alpha" href="#vectorbt.portfolio.base.Portfolio.alpha">alpha</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.annual_returns" href="#vectorbt.portfolio.base.Portfolio.annual_returns">annual_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.annualized_return" href="#vectorbt.portfolio.base.Portfolio.annualized_return">annualized_return</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.annualized_volatility" href="#vectorbt.portfolio.base.Portfolio.annualized_volatility">annualized_volatility</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.beta" href="#vectorbt.portfolio.base.Portfolio.beta">beta</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.buy_and_hold_return" href="#vectorbt.portfolio.base.Portfolio.buy_and_hold_return">buy_and_hold_return</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.call_seq" href="#vectorbt.portfolio.base.Portfolio.call_seq">call_seq</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.calmar_ratio" href="#vectorbt.portfolio.base.Portfolio.calmar_ratio">calmar_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.capture" href="#vectorbt.portfolio.base.Portfolio.capture">capture</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cash" href="#vectorbt.portfolio.base.Portfolio.cash">cash</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cash_flow" href="#vectorbt.portfolio.base.Portfolio.cash_flow">cash_flow</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cash_sharing" href="#vectorbt.portfolio.base.Portfolio.cash_sharing">cash_sharing</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.close" href="#vectorbt.portfolio.base.Portfolio.close">close</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.conditional_value_at_risk" href="#vectorbt.portfolio.base.Portfolio.conditional_value_at_risk">conditional_value_at_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cumulative_returns" href="#vectorbt.portfolio.base.Portfolio.cumulative_returns">cumulative_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.daily_returns" href="#vectorbt.portfolio.base.Portfolio.daily_returns">daily_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.deflated_sharpe_ratio" href="#vectorbt.portfolio.base.Portfolio.deflated_sharpe_ratio">deflated_sharpe_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.down_capture" href="#vectorbt.portfolio.base.Portfolio.down_capture">down_capture</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.downside_risk" href="#vectorbt.portfolio.base.Portfolio.downside_risk">downside_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.drawdown" href="#vectorbt.portfolio.base.Portfolio.drawdown">drawdown</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.drawdowns" href="#vectorbt.portfolio.base.Portfolio.drawdowns">drawdowns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.fill_close" href="#vectorbt.portfolio.base.Portfolio.fill_close">fill_close</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.final_value" href="#vectorbt.portfolio.base.Portfolio.final_value">final_value</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">from_order_func</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">from_orders</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">from_signals</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.holding_value" href="#vectorbt.portfolio.base.Portfolio.holding_value">holding_value</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.incl_unrealized" href="#vectorbt.portfolio.base.Portfolio.incl_unrealized">incl_unrealized</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.information_ratio" href="#vectorbt.portfolio.base.Portfolio.information_ratio">information_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.init_cash" href="#vectorbt.portfolio.base.Portfolio.init_cash">init_cash</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.init_cash_mode" href="#vectorbt.portfolio.base.Portfolio.init_cash_mode">init_cash_mode</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.init_cash_regrouped" href="#vectorbt.portfolio.base.Portfolio.init_cash_regrouped">init_cash_regrouped</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.max_drawdown" href="#vectorbt.portfolio.base.Portfolio.max_drawdown">max_drawdown</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.omega_ratio" href="#vectorbt.portfolio.base.Portfolio.omega_ratio">omega_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.orders" href="#vectorbt.portfolio.base.Portfolio.orders">orders</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.orders_regrouped" href="#vectorbt.portfolio.base.Portfolio.orders_regrouped">orders_regrouped</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.positions" href="#vectorbt.portfolio.base.Portfolio.positions">positions</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.regroup" href="#vectorbt.portfolio.base.Portfolio.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.returns" href="#vectorbt.portfolio.base.Portfolio.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.share_flow" href="#vectorbt.portfolio.base.Portfolio.share_flow">share_flow</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.shares" href="#vectorbt.portfolio.base.Portfolio.shares">shares</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.sharpe_ratio" href="#vectorbt.portfolio.base.Portfolio.sharpe_ratio">sharpe_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.sortino_ratio" href="#vectorbt.portfolio.base.Portfolio.sortino_ratio">sortino_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.stats" href="#vectorbt.portfolio.base.Portfolio.stats">stats</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.tail_ratio" href="#vectorbt.portfolio.base.Portfolio.tail_ratio">tail_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.total_profit" href="#vectorbt.portfolio.base.Portfolio.total_profit">total_profit</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.total_return" href="#vectorbt.portfolio.base.Portfolio.total_return">total_return</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.trades" href="#vectorbt.portfolio.base.Portfolio.trades">trades</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.up_capture" href="#vectorbt.portfolio.base.Portfolio.up_capture">up_capture</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.value" href="#vectorbt.portfolio.base.Portfolio.value">value</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.value_at_risk" href="#vectorbt.portfolio.base.Portfolio.value_at_risk">value_at_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.wrapper" href="#vectorbt.portfolio.base.Portfolio.wrapper">wrapper</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>