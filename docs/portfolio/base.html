<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.portfolio.base API documentation</title>
<meta name="description" content="Base class for modeling portfolio and measuring its performance â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3B4556}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="mask-icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.portfolio.base</code></h1>
</header>
<section id="section-intro">
<p>Base class for modeling portfolio and measuring its performance.</p>
<p>The job of the <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> class is to create a series of positions allocated
against a cash component, produce an equity curve, incorporate basic transaction costs
and produce a set of statistics about its performance. In particular it outputs
position/profit metrics and drawdown information.</p>
<h2 id="workflow">Workflow</h2>
<p>The workflow of <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> is simple:</p>
<ol>
<li>Receives a set of inputs, such as entry and exit signals</li>
<li>Uses them to generate and fill orders in form of records (simulation part)</li>
<li>Calculates a broad range of risk &amp; performance metrics based on these records (analysis part)</li>
</ol>
<p>It basically builds upon the <code><a title="vectorbt.portfolio.orders.Orders" href="orders.html#vectorbt.portfolio.orders.Orders">Orders</a></code> class. To simplify creation of order
records and keep track of balances, it exposes several convenience methods with prefix <code>from_</code>.
For example, you can use <code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">Portfolio.from_signals()</a></code> method to generate orders from entry and exit signals.
Alternatively, you can use <code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">Portfolio.from_order_func()</a></code> to run a custom order function on each tick.
The results are then automatically passed to the constructor method of <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> and you will
receive a portfolio instance ready to be used for performance analysis.</p>
<p>This way, one can simulate and analyze his/her strategy in a couple of lines.</p>
<h3 id="example">Example</h3>
<p>The following example does something crazy: it checks candlestick data of 6 major cryptocurrencies
in 2020 against every single pattern found in TA-Lib, and translates them into signals:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; import talib
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; # Fetch price history
&gt;&gt;&gt; symbols = ['BTC-USD', 'ETH-USD', 'XRP-USD', 'BNB-USD', 'BCH-USD', 'LTC-USD']
&gt;&gt;&gt; start = datetime(2020, 1, 1)
&gt;&gt;&gt; end = datetime(2020, 9, 1)
&gt;&gt;&gt; ohlcv_by_symbol = vbt.utils.data.download(symbols, start=start, end=end)

&gt;&gt;&gt; # Put assets into a single dataframe by price type
&gt;&gt;&gt; ohlcv = vbt.utils.data.concat_symbols(ohlcv_by_symbol)

&gt;&gt;&gt; ohlcv['Open'].head()
symbol          BTC-USD     ETH-USD   XRP-USD    BNB-USD     BCH-USD  Date
2019-12-31  7294.438965  132.612274  0.194518  13.952087  209.301987
2020-01-01  7194.892090  129.630661  0.192912  13.730962  204.671295
2020-01-02  7202.551270  130.820038  0.192708  13.698126  204.354538
2020-01-03  6984.428711  127.411263  0.187948  13.035329  196.007690
2020-01-04  7345.375488  134.168518  0.193521  13.667442  222.536560

symbol        LTC-USD
Date
2019-12-31  42.766113
2020-01-01  41.326534
2020-01-02  42.018085
2020-01-03  39.863129
2020-01-04  42.383526

&gt;&gt;&gt; # Run every single pattern recognition indicator and combine results
&gt;&gt;&gt; result = pd.DataFrame.vbt.empty_like(ohlcv['Open'], fill_value=0.)
&gt;&gt;&gt; for pattern in talib.get_function_groups()['Pattern Recognition']:
...     PRecognizer = vbt.IndicatorFactory.from_talib(pattern)
...     pr = PRecognizer.run(ohlcv['Open'], ohlcv['High'], ohlcv['Low'], ohlcv['Close'])
...     result = result + pr.integer

&gt;&gt;&gt; # Don't look into future
&gt;&gt;&gt; result = result.vbt.fshift(1)

&gt;&gt;&gt; # Treat each number as order value in USD
&gt;&gt;&gt; size = result / ohlcv['Open']

&gt;&gt;&gt; # Simulate portfolio
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
...     ohlcv['Close'], size, price=ohlcv['Open'],
...     init_cash='autoalign', fees=0.001, slippage=0.001)

&gt;&gt;&gt; # Visualize portfolio value
&gt;&gt;&gt; portfolio.value().vbt.plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/portfolio_value.png"></p>
<h2 id="broadcasting">Broadcasting</h2>
<p><code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> is very flexible towards inputs:</p>
<ul>
<li>Accepts both Series and DataFrames as inputs</li>
<li>Broadcasts inputs to the same shape using vectorbt's own broadcasting rules</li>
<li>Many inputs (such as <code>fees</code>) can be passed as a single value, value per column/row, or as a matrix</li>
<li>Implements flexible indexing wherever possible to save memory</li>
</ul>
<h2 id="grouping">Grouping</h2>
<p>One of the key features of <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> is the ability to group columns. Groups can be specified by
<code>group_by</code>, which can be anything from positions or names of column levels, to a NumPy array with
actual groups. Groups can be formed to share capital between columns or to compute metrics
for a combined portfolio of multiple independent columns.</p>
<p>For example, let's divide our portfolio into two groups sharing the same cash:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Simulate combined portfolio
&gt;&gt;&gt; group_by = pd.Index([
...     'first', 'first', 'first',
...     'second', 'second', 'second'
... ], name='group')
&gt;&gt;&gt; comb_portfolio = vbt.Portfolio.from_orders(
...     ohlcv['Close'], size, price=ohlcv['Open'],
...     init_cash='autoalign', fees=0.001, slippage=0.001,
...     group_by=group_by, cash_sharing=True)

&gt;&gt;&gt; # Get total profit per group
&gt;&gt;&gt; comb_portfolio.total_profit()
group
first     21891.431061
second     7575.676246
dtype: float64
</code></pre>
<p>Not only can you analyze each group, but also each column in the group:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Get total profit per column
&gt;&gt;&gt; comb_portfolio.total_profit(group_by=False)
symbol
BTC-USD     5163.844396
ETH-USD    13368.521326
XRP-USD     3359.065339
BNB-USD     4724.565229
BCH-USD     -259.592709
LTC-USD     3110.703726
dtype: float64
</code></pre>
<p>In the same way, you can introduce new grouping to the method itself:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Get total profit per group
&gt;&gt;&gt; portfolio.total_profit(group_by=group_by)
group
first     21891.431061
second     7575.676246
dtype: float64
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If cash sharing is enabled, grouping can be disabled but cannot be modified.</p>
</div>
<h2 id="indexing">Indexing</h2>
<p>In addition, you can use pandas indexing on the <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> class itself, which forwards
indexing operation to each argument with index:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; portfolio['BTC-USD']
&lt;vectorbt.portfolio.base.Portfolio at 0x7fac7517ac88&gt;

&gt;&gt;&gt; portfolio['BTC-USD'].total_profit()
5163.844396244112
</code></pre>
<p>Combined portfolio is indexed by group:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; comb_portfolio['first']
&lt;vectorbt.portfolio.base.Portfolio at 0x7fac5756b828&gt;

&gt;&gt;&gt; comb_portfolio['first'].total_profit()
21891.43106080097
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Changing index (time axis) is not supported. The object should be treated as a Series
rather than a DataFrame; for example, use <code>portfolio.iloc[0]</code> instead of <code>portfolio.iloc[:, 0]</code>.</p>
<p>Indexing behavior depends solely upon <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.
For example, if <code>group_select</code> is enabled indexing will be performed on groups,
otherwise on single columns. You can pass wrapper arguments with <code>wrapper_kwargs</code>.</p>
</div>
<h2 id="logging">Logging</h2>
<p>To collect more information on how a specific order was processed or to be able to track the whole
simulation from the beginning to the end, you can turn on logging.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Simulate portfolio with logging
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
...     ohlcv['Close'], size, price=ohlcv['Open'],
...     init_cash='autoalign', fees=0.001, slippage=0.001, log=True)

&gt;&gt;&gt; portfolio.logs.records
        id  idx  col  group  cash_now  shares_now  val_price_now  value_now  0        0    0    0      0       inf    0.000000    7294.438965        inf
...    ...  ...  ...    ...       ...         ...            ...        ...
1463  1463  243    5      5       inf  271.629075      62.844059        inf

          size  size_type  ...   log  new_cash  new_shares  res_size  0          NaN          0  ...  True       inf    0.000000       NaN
...        ...        ...  ...   ...       ...         ...       ...
1463  7.956202          0  ...  True       inf  279.585277  7.956202

        res_price  res_fees  res_side  res_status  res_status_info  order_id
0             NaN       NaN        -1           1                0        -1
...           ...       ...       ...         ...              ...       ...
1463    62.906903    0.5005         0           0               -1      1075

[1464 rows x 30 columns]
</code></pre>
<p>Just as orders, logs are also records and thus can be easily analyzed:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from vectorbt.portfolio.enums import OrderStatus

&gt;&gt;&gt; portfolio.logs.map_field('res_status', value_map=OrderStatus).value_counts()
symbol   BTC-USD  ETH-USD  XRP-USD  BNB-USD  BCH-USD  LTC-USD
Ignored       59       72       66       66       66       59
Filled       185      172      178      178      178      185
</code></pre>
<p>Logging can also be turned on just for one order, row, or column, since as many other
variables it's specified per order and can broadcast automatically.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Logging can slow down simulation.</p>
</div>
<h2 id="caching">Caching</h2>
<p><code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> heavily relies upon caching. If a method or a property requires heavy computation,
it's wrapped with <code><a title="vectorbt.utils.decorators.cached_method" href="../utils/decorators.html#vectorbt.utils.decorators.cached_method">cached_method()</a></code> and <code><a title="vectorbt.utils.decorators.cached_property" href="../utils/decorators.html#vectorbt.utils.decorators.cached_property">cached_property</a></code>
respectively. Caching can be disabled globally via <code><a title="vectorbt.settings" href="../settings.html">vectorbt.settings</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because of caching, class is meant to be immutable and all properties are read-only.
To change any attribute, use the <code>copy</code> method and pass the attribute as keyword argument.</p>
</div>
<p>If you're running out of memory when working with large arrays, make sure to disable caching
and then store most important time series manually. For example, if you're interested in Sharpe
ratio or other metrics based on returns, run and save <code><a title="vectorbt.portfolio.base.Portfolio.returns" href="#vectorbt.portfolio.base.Portfolio.returns">Portfolio.returns()</a></code> and then use the
<code><a title="vectorbt.returns.accessors.ReturnsAccessor" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor">ReturnsAccessor</a></code> to analyze them. Do not use methods akin to
<code><a title="vectorbt.portfolio.base.Portfolio.sharpe_ratio" href="#vectorbt.portfolio.base.Portfolio.sharpe_ratio">Portfolio.sharpe_ratio()</a></code> because they will re-calculate returns each time.</p>
<p>Alternatively, you can precisely point at attributes and methods that should or shouldn't
be cached. For example, you can blacklist the entire <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> class except a few most called
methods such as <code><a title="vectorbt.portfolio.base.Portfolio.cash_flow" href="#vectorbt.portfolio.base.Portfolio.cash_flow">Portfolio.cash_flow()</a></code> and <code><a title="vectorbt.portfolio.base.Portfolio.share_flow" href="#vectorbt.portfolio.base.Portfolio.share_flow">Portfolio.share_flow()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.settings.caching['blacklist'].append('Portfolio')
&gt;&gt;&gt; vbt.settings.caching['whitelist'].extend([
...     'Portfolio.cash_flow',
...     'Portfolio.share_flow'
... ])
</code></pre>
<p>Define rules for one instance of <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.settings.caching['blacklist'].append(portfolio)
&gt;&gt;&gt; vbt.settings.caching['whitelist'].extend([
...     portfolio.cash_flow,
...     portfolio.share_flow
... ])
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that the above approach doesn't work for cached properties.
Use tuples of the instance and the property name instead, such as <code>(portfolio, 'orders')</code>.</p>
</div>
<p>To reset caching:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.settings.caching.reset()
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Base class for modeling portfolio and measuring its performance.

The job of the `Portfolio` class is to create a series of positions allocated 
against a cash component, produce an equity curve, incorporate basic transaction costs
and produce a set of statistics about its performance. In particular it outputs
position/profit metrics and drawdown information.

## Workflow

The workflow of `Portfolio` is simple:

1. Receives a set of inputs, such as entry and exit signals
2. Uses them to generate and fill orders in form of records (simulation part)
3. Calculates a broad range of risk &amp; performance metrics based on these records (analysis part)

It basically builds upon the `vectorbt.portfolio.orders.Orders` class. To simplify creation of order
records and keep track of balances, it exposes several convenience methods with prefix `from_`.
For example, you can use `Portfolio.from_signals` method to generate orders from entry and exit signals.
Alternatively, you can use `Portfolio.from_order_func` to run a custom order function on each tick.
The results are then automatically passed to the constructor method of `Portfolio` and you will
receive a portfolio instance ready to be used for performance analysis.

This way, one can simulate and analyze his/her strategy in a couple of lines.

### Example

The following example does something crazy: it checks candlestick data of 6 major cryptocurrencies
in 2020 against every single pattern found in TA-Lib, and translates them into signals:

```python-repl
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; import talib
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; # Fetch price history
&gt;&gt;&gt; symbols = [&#39;BTC-USD&#39;, &#39;ETH-USD&#39;, &#39;XRP-USD&#39;, &#39;BNB-USD&#39;, &#39;BCH-USD&#39;, &#39;LTC-USD&#39;]
&gt;&gt;&gt; start = datetime(2020, 1, 1)
&gt;&gt;&gt; end = datetime(2020, 9, 1)
&gt;&gt;&gt; ohlcv_by_symbol = vbt.utils.data.download(symbols, start=start, end=end)

&gt;&gt;&gt; # Put assets into a single dataframe by price type
&gt;&gt;&gt; ohlcv = vbt.utils.data.concat_symbols(ohlcv_by_symbol)

&gt;&gt;&gt; ohlcv[&#39;Open&#39;].head()
symbol          BTC-USD     ETH-USD   XRP-USD    BNB-USD     BCH-USD  \
Date
2019-12-31  7294.438965  132.612274  0.194518  13.952087  209.301987
2020-01-01  7194.892090  129.630661  0.192912  13.730962  204.671295
2020-01-02  7202.551270  130.820038  0.192708  13.698126  204.354538
2020-01-03  6984.428711  127.411263  0.187948  13.035329  196.007690
2020-01-04  7345.375488  134.168518  0.193521  13.667442  222.536560

symbol        LTC-USD
Date
2019-12-31  42.766113
2020-01-01  41.326534
2020-01-02  42.018085
2020-01-03  39.863129
2020-01-04  42.383526

&gt;&gt;&gt; # Run every single pattern recognition indicator and combine results
&gt;&gt;&gt; result = pd.DataFrame.vbt.empty_like(ohlcv[&#39;Open&#39;], fill_value=0.)
&gt;&gt;&gt; for pattern in talib.get_function_groups()[&#39;Pattern Recognition&#39;]:
...     PRecognizer = vbt.IndicatorFactory.from_talib(pattern)
...     pr = PRecognizer.run(ohlcv[&#39;Open&#39;], ohlcv[&#39;High&#39;], ohlcv[&#39;Low&#39;], ohlcv[&#39;Close&#39;])
...     result = result + pr.integer

&gt;&gt;&gt; # Don&#39;t look into future
&gt;&gt;&gt; result = result.vbt.fshift(1)

&gt;&gt;&gt; # Treat each number as order value in USD
&gt;&gt;&gt; size = result / ohlcv[&#39;Open&#39;]

&gt;&gt;&gt; # Simulate portfolio
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
...     ohlcv[&#39;Close&#39;], size, price=ohlcv[&#39;Open&#39;],
...     init_cash=&#39;autoalign&#39;, fees=0.001, slippage=0.001)

&gt;&gt;&gt; # Visualize portfolio value
&gt;&gt;&gt; portfolio.value().vbt.plot()
```

![](/vectorbt/docs/img/portfolio_value.png)

## Broadcasting

`Portfolio` is very flexible towards inputs:

* Accepts both Series and DataFrames as inputs
* Broadcasts inputs to the same shape using vectorbt&#39;s own broadcasting rules
* Many inputs (such as `fees`) can be passed as a single value, value per column/row, or as a matrix
* Implements flexible indexing wherever possible to save memory

## Grouping

One of the key features of `Portfolio` is the ability to group columns. Groups can be specified by
`group_by`, which can be anything from positions or names of column levels, to a NumPy array with
actual groups. Groups can be formed to share capital between columns or to compute metrics
for a combined portfolio of multiple independent columns.

For example, let&#39;s divide our portfolio into two groups sharing the same cash:

```python-repl
&gt;&gt;&gt; # Simulate combined portfolio
&gt;&gt;&gt; group_by = pd.Index([
...     &#39;first&#39;, &#39;first&#39;, &#39;first&#39;,
...     &#39;second&#39;, &#39;second&#39;, &#39;second&#39;
... ], name=&#39;group&#39;)
&gt;&gt;&gt; comb_portfolio = vbt.Portfolio.from_orders(
...     ohlcv[&#39;Close&#39;], size, price=ohlcv[&#39;Open&#39;],
...     init_cash=&#39;autoalign&#39;, fees=0.001, slippage=0.001,
...     group_by=group_by, cash_sharing=True)

&gt;&gt;&gt; # Get total profit per group
&gt;&gt;&gt; comb_portfolio.total_profit()
group
first     21891.431061
second     7575.676246
dtype: float64
```

Not only can you analyze each group, but also each column in the group:

```python-repl
&gt;&gt;&gt; # Get total profit per column
&gt;&gt;&gt; comb_portfolio.total_profit(group_by=False)
symbol
BTC-USD     5163.844396
ETH-USD    13368.521326
XRP-USD     3359.065339
BNB-USD     4724.565229
BCH-USD     -259.592709
LTC-USD     3110.703726
dtype: float64
```

In the same way, you can introduce new grouping to the method itself:

```python-repl
&gt;&gt;&gt; # Get total profit per group
&gt;&gt;&gt; portfolio.total_profit(group_by=group_by)
group
first     21891.431061
second     7575.676246
dtype: float64
```

!!! note
    If cash sharing is enabled, grouping can be disabled but cannot be modified.

## Indexing

In addition, you can use pandas indexing on the `Portfolio` class itself, which forwards
indexing operation to each argument with index:

```python-repl
&gt;&gt;&gt; portfolio[&#39;BTC-USD&#39;]
&lt;vectorbt.portfolio.base.Portfolio at 0x7fac7517ac88&gt;

&gt;&gt;&gt; portfolio[&#39;BTC-USD&#39;].total_profit()
5163.844396244112
```

Combined portfolio is indexed by group:

```python-repl
&gt;&gt;&gt; comb_portfolio[&#39;first&#39;]
&lt;vectorbt.portfolio.base.Portfolio at 0x7fac5756b828&gt;

&gt;&gt;&gt; comb_portfolio[&#39;first&#39;].total_profit()
21891.43106080097
```

!!! note
    Changing index (time axis) is not supported. The object should be treated as a Series
    rather than a DataFrame; for example, use `portfolio.iloc[0]` instead of `portfolio.iloc[:, 0]`.

    Indexing behavior depends solely upon `vectorbt.base.array_wrapper.ArrayWrapper`.
    For example, if `group_select` is enabled indexing will be performed on groups,
    otherwise on single columns. You can pass wrapper arguments with `wrapper_kwargs`.

## Logging

To collect more information on how a specific order was processed or to be able to track the whole
simulation from the beginning to the end, you can turn on logging.

```python-repl
&gt;&gt;&gt; # Simulate portfolio with logging
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
...     ohlcv[&#39;Close&#39;], size, price=ohlcv[&#39;Open&#39;],
...     init_cash=&#39;autoalign&#39;, fees=0.001, slippage=0.001, log=True)

&gt;&gt;&gt; portfolio.logs.records
        id  idx  col  group  cash_now  shares_now  val_price_now  value_now  \
0        0    0    0      0       inf    0.000000    7294.438965        inf
...    ...  ...  ...    ...       ...         ...            ...        ...
1463  1463  243    5      5       inf  271.629075      62.844059        inf

          size  size_type  ...   log  new_cash  new_shares  res_size  \
0          NaN          0  ...  True       inf    0.000000       NaN
...        ...        ...  ...   ...       ...         ...       ...
1463  7.956202          0  ...  True       inf  279.585277  7.956202

        res_price  res_fees  res_side  res_status  res_status_info  order_id
0             NaN       NaN        -1           1                0        -1
...           ...       ...       ...         ...              ...       ...
1463    62.906903    0.5005         0           0               -1      1075

[1464 rows x 30 columns]
```

Just as orders, logs are also records and thus can be easily analyzed:

```python-repl
&gt;&gt;&gt; from vectorbt.portfolio.enums import OrderStatus

&gt;&gt;&gt; portfolio.logs.map_field(&#39;res_status&#39;, value_map=OrderStatus).value_counts()
symbol   BTC-USD  ETH-USD  XRP-USD  BNB-USD  BCH-USD  LTC-USD
Ignored       59       72       66       66       66       59
Filled       185      172      178      178      178      185
```

Logging can also be turned on just for one order, row, or column, since as many other
variables it&#39;s specified per order and can broadcast automatically.

!!! note
    Logging can slow down simulation.

## Caching

`Portfolio` heavily relies upon caching. If a method or a property requires heavy computation,
it&#39;s wrapped with `vectorbt.utils.decorators.cached_method` and `vectorbt.utils.decorators.cached_property`
respectively. Caching can be disabled globally via `vectorbt.settings`.

!!! note
    Because of caching, class is meant to be immutable and all properties are read-only.
    To change any attribute, use the `copy` method and pass the attribute as keyword argument.

If you&#39;re running out of memory when working with large arrays, make sure to disable caching
and then store most important time series manually. For example, if you&#39;re interested in Sharpe
ratio or other metrics based on returns, run and save `Portfolio.returns` and then use the
`vectorbt.returns.accessors.ReturnsAccessor` to analyze them. Do not use methods akin to
`Portfolio.sharpe_ratio` because they will re-calculate returns each time.

Alternatively, you can precisely point at attributes and methods that should or shouldn&#39;t
be cached. For example, you can blacklist the entire `Portfolio` class except a few most called
methods such as `Portfolio.cash_flow` and `Portfolio.share_flow`:

```python-repl
&gt;&gt;&gt; vbt.settings.caching[&#39;blacklist&#39;].append(&#39;Portfolio&#39;)
&gt;&gt;&gt; vbt.settings.caching[&#39;whitelist&#39;].extend([
...     &#39;Portfolio.cash_flow&#39;,
...     &#39;Portfolio.share_flow&#39;
... ])
```

Define rules for one instance of `Portfolio`:

```python-repl
&gt;&gt;&gt; vbt.settings.caching[&#39;blacklist&#39;].append(portfolio)
&gt;&gt;&gt; vbt.settings.caching[&#39;whitelist&#39;].extend([
...     portfolio.cash_flow,
...     portfolio.share_flow
... ])
```

!!! note
    Note that the above approach doesn&#39;t work for cached properties.
    Use tuples of the instance and the property name instead, such as `(portfolio, &#39;orders&#39;)`.

To reset caching:

```python-repl
&gt;&gt;&gt; vbt.settings.caching.reset()
```
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from inspect import signature
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property, cached_method
from vectorbt.utils.enum import convert_str_enum_value
from vectorbt.utils.config import merge_dicts
from vectorbt.utils.random import set_seed
from vectorbt.utils.colors import adjust_opacity
from vectorbt.utils.widgets import make_subplots
from vectorbt.base.reshape_fns import to_1d, to_2d, broadcast, broadcast_to
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.drawdowns import Drawdowns
from vectorbt.signals.basic import RAND, RPROB
from vectorbt.portfolio import nb
from vectorbt.portfolio.orders import Orders
from vectorbt.portfolio.trades import Trades, Positions
from vectorbt.portfolio.logs import Logs
from vectorbt.portfolio.enums import (
    InitCashMode,
    CallSeqType,
    SizeType,
    ConflictMode,
    Direction
)


def add_returns_methods(func_names):
    &#34;&#34;&#34;Class decorator to add `vectorbt.returns.accessors.ReturnsAccessor` methods to `Portfolio`.&#34;&#34;&#34;

    def wrapper(cls):
        for func_name in func_names:
            if isinstance(func_name, tuple):
                ret_func_name = func_name[0]
            else:
                ret_func_name = func_name

            def returns_method(
                    self,
                    *args,
                    group_by=None,
                    year_freq=None,
                    ret_func_name=ret_func_name,
                    active_returns=False,
                    in_sim_order=False,
                    reuse_returns=None,
                    **kwargs):
                if reuse_returns is not None:
                    returns = reuse_returns
                else:
                    if active_returns:
                        returns = self.active_returns(group_by=group_by)
                    else:
                        returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
                returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
                # Select only those arguments in kwargs that are also in the method&#39;s signature
                # This is done for Portfolio.stats which passes the same kwargs to multiple methods
                method = getattr(returns_acc, ret_func_name)
                sig = signature(method)
                arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
                new_kwargs = {}
                for arg_name in arg_names:
                    if arg_name in kwargs:
                        new_kwargs[arg_name] = kwargs[arg_name]
                return method(*args, **new_kwargs)

            if isinstance(func_name, tuple):
                func_name = func_name[1]
            returns_method.__name__ = func_name
            returns_method.__qualname__ = f&#34;Portfolio.{func_name}&#34;
            returns_method.__doc__ = f&#34;See `vectorbt.returns.accessors.ReturnsAccessor.{ret_func_name}`.&#34;
            setattr(cls, func_name, cached_method(returns_method))
        return cls

    return wrapper


@add_returns_methods([
    (&#39;daily&#39;, &#39;daily_returns&#39;),
    (&#39;annual&#39;, &#39;annual_returns&#39;),
    (&#39;cumulative&#39;, &#39;cumulative_returns&#39;),
    (&#39;annualized&#39;, &#39;annualized_return&#39;),
    &#39;annualized_volatility&#39;,
    &#39;calmar_ratio&#39;,
    &#39;omega_ratio&#39;,
    &#39;sharpe_ratio&#39;,
    &#39;deflated_sharpe_ratio&#39;,
    &#39;downside_risk&#39;,
    &#39;sortino_ratio&#39;,
    &#39;information_ratio&#39;,
    &#39;beta&#39;,
    &#39;alpha&#39;,
    &#39;tail_ratio&#39;,
    &#39;value_at_risk&#39;,
    &#39;conditional_value_at_risk&#39;,
    &#39;capture&#39;,
    &#39;up_capture&#39;,
    &#39;down_capture&#39;,
    &#39;drawdown&#39;,
    &#39;max_drawdown&#39;
])
class Portfolio(Wrapping):
    &#34;&#34;&#34;Class for modeling portfolio and measuring its performance.

    Args:
        wrapper (ArrayWrapper): Array wrapper.

            See `vectorbt.base.array_wrapper.ArrayWrapper`.
        close (array_like): Reference price, such as close.
        order_records (array_like): A structured NumPy array of order records.
        log_records (array_like): A structured NumPy array of log records.
        init_cash (InitCashMode, float or array_like of float): Initial capital.
        cash_sharing (bool): Whether to share cash within the same group.
        call_seq (array_like of int): Sequence of calls per row and group.
        incl_unrealized (bool): Whether to include unrealized P&amp;L in statistics.
        use_filled_close (bool): Whether to forward-backward fill NaN values in `close`.

            Doesn&#39;t affect simulation and only used for total profit and market value.

            See `Portfolio.fill_close`.

    !!! note
        Use class methods with `from_` prefix to build a portfolio.
        The `__init__` method is reserved for indexing purposes.

    !!! note
        This class is meant to be immutable. To change any attribute, use `Portfolio.copy`.&#34;&#34;&#34;

    def __init__(self, wrapper, close, order_records, log_records, init_cash,
                 cash_sharing, call_seq, incl_unrealized=None, use_filled_close=None):
        Wrapping.__init__(
            self,
            wrapper,
            close=close,
            order_records=order_records,
            log_records=log_records,
            init_cash=init_cash,
            cash_sharing=cash_sharing,
            call_seq=call_seq,
            incl_unrealized=incl_unrealized,
            use_filled_close=use_filled_close
        )
        # Get defaults
        from vectorbt import settings

        if incl_unrealized is None:
            incl_unrealized = settings.portfolio[&#39;incl_unrealized&#39;]
        if use_filled_close is None:
            use_filled_close = settings.portfolio[&#39;use_filled_close&#39;]

        # Store passed arguments
        self._close = broadcast_to(close, wrapper.dummy(group_by=False))
        self._order_records = order_records
        self._log_records = log_records
        self._init_cash = init_cash
        self._cash_sharing = cash_sharing
        self._call_seq = call_seq
        self._incl_unrealized = incl_unrealized
        self._use_filled_close = use_filled_close

    def _indexing_func(self, pd_indexing_func):
        &#34;&#34;&#34;Perform indexing on `Portfolio`.&#34;&#34;&#34;
        new_wrapper, _, group_idxs, col_idxs = \
            self.wrapper._indexing_func_meta(pd_indexing_func, column_only_select=True)
        new_close = new_wrapper.wrap(to_2d(self.close, raw=True)[:, col_idxs], group_by=False)
        new_order_records = self.orders._col_idxs_records(col_idxs)
        new_log_records = self.logs._col_idxs_records(col_idxs)
        if isinstance(self._init_cash, int):
            new_init_cash = self._init_cash
        else:
            new_init_cash = to_1d(self._init_cash, raw=True)[group_idxs if self.cash_sharing else col_idxs]
        new_call_seq = self.call_seq.values[:, col_idxs]

        return self.copy(
            wrapper=new_wrapper,
            close=new_close,
            order_records=new_order_records,
            log_records=new_log_records,
            init_cash=new_init_cash,
            call_seq=new_call_seq
        )

    # ############# Class methods ############# #

    @classmethod
    def from_holding(cls, close, **kwargs):
        &#34;&#34;&#34;Simulate portfolio from holding.

        Based on `Portfolio.from_signals`.&#34;&#34;&#34;
        return cls.from_signals(close, True, False, accumulate=False, **kwargs)

    @classmethod
    def from_random(cls, close, n=None, prob=None, entry_prob=None, exit_prob=None,
                    param_product=False, seed=None, **kwargs):
        &#34;&#34;&#34;Simulate portfolio from random entry and exit signals.

        Generates signals based either on the number of signals `n` or the probability
        of encountering a signal `prob`.

        If `n` is set, see `vectorbt.signals.basic.RAND`.
        If `prob` is set, see `vectorbt.signals.basic.RPROB`.

        Based on `Portfolio.from_signals`.&#34;&#34;&#34;
        from vectorbt import settings

        if entry_prob is None:
            entry_prob = prob
        if exit_prob is None:
            exit_prob = prob
        if seed is None:
            seed = settings.portfolio[&#39;seed&#39;]

        if n is not None and (entry_prob is not None or exit_prob is not None):
            raise ValueError(&#34;Either n or entry_prob and exit_prob should be set&#34;)
        if n is not None:
            rand = RAND.run(
                n=n,
                input_shape=close.shape,
                input_index=close.vbt.wrapper.index,
                input_columns=close.vbt.wrapper.columns,
                seed=seed
            )
            entries = rand.entries
            exits = rand.exits
        elif entry_prob is not None and exit_prob is not None:
            rprob = RPROB.run(
                entry_prob=entry_prob,
                exit_prob=exit_prob,
                param_product=param_product,
                input_shape=close.shape,
                input_index=close.vbt.wrapper.index,
                input_columns=close.vbt.wrapper.columns,
                seed=seed
            )
            entries = rprob.entries
            exits = rprob.exits
        else:
            raise ValueError(&#34;At least n or entry_prob and exit_prob should be set&#34;)

        return cls.from_signals(close, entries, exits, seed=seed, **kwargs)

    @classmethod
    def from_signals(cls, close, entries, exits, size=None, size_type=None, direction=None, price=None,
                     fees=None, fixed_fees=None, slippage=None, min_size=None, max_size=None,
                     reject_prob=None, allow_partial=None, raise_reject=None, accumulate=None, log=None,
                     conflict_mode=None, close_first=None, val_price=None, init_cash=None, cash_sharing=None,
                     call_seq=None, max_orders=None, max_logs=None, seed=None, group_by=None,
                     broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs):
        &#34;&#34;&#34;Simulate portfolio from entry and exit signals.

        Starting with initial cash `init_cash`, for each signal in `entries`, enters a long/short position
        by buying/selling `size` of shares. For each signal in `exits`, closes the position by
        selling/buying shares. Depending upon accumulation, each entry signal may increase
        the position and each exit signal may decrease the position. When both entry and exit signals
        are present, ignores them by default. When grouping is enabled with `group_by`, will compute
        the performance of the entire group. When `cash_sharing` is enabled, will share the cash among
        all columns in the group.

        Args:
            close (array_like): Reference price, such as close.
                Will broadcast.

                Will be used for calculating unrealized P&amp;L and portfolio value.
            entries (array_like of bool): Boolean array of entry signals.
                Will broadcast.

                Becomes a long signal if `direction` is `all` or `longonly`, otherwise short.
            exits (array_like of bool): Boolean array of exit signals.
                Will broadcast.

                Becomes a short signal if `direction` is `all` or `longonly`, otherwise long.
            size (float or array_like): Size to order.
                Will broadcast.

                * Set to any number to buy/sell some fixed amount of shares.
                    Longs are limited by cash in the account, while shorts are unlimited.
                * Set to `np.inf` to buy shares for all cash, or `-np.inf` to sell shares for
                    initial margin of 100%. If `direction` is not `all`, `-np.inf` will close the position.
                * Set to `np.nan` or 0 to skip.

                !!! note
                    Sign will be ignored.
            size_type (SizeType or array_like): See `vectorbt.portfolio.enums.SizeType`.
                Will broadcast.

                Only `SizeType.Shares` and `SizeType.Percent` are supported.
                Other modes such as target percentage are not compatible with signals since
                their logic may contradict the direction of the signal.

                !!! note
                    `SizeType.Percent` does not support position reversal. Switch to a single
                    direction or use `close_first`.

                See warning on `size_type` in `Portfolio.from_orders`.
            direction (Direction or array_like): See `vectorbt.portfolio.enums.Direction`.
                Will broadcast.
            price (array_like of float): Order price.
                Defaults to `close`. Will broadcast.
            fees (float or array_like): Fees in percentage of the order value.
                Will broadcast. Note that 0.01 = 1%.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order.
                Will broadcast.
            slippage (float or array_like): Slippage in percentage of price.
                Will broadcast. Note that 0.01 = 1%.
            min_size (float or array_like): Minimum size for an order to be accepted.
                Will broadcast.
            max_size (float or array_like): Maximum size for an order.
                Will broadcast.

                Will be partially filled if exceeded. You might not be able to properly close
                the position if accumulation is enabled and `max_size` is too low.
            reject_prob (float or array_like): Order rejection probability.
                Will broadcast.
            allow_partial (bool or array_like): Whether to allow partial fills.
                Will broadcast.

                Does not apply when size is `np.inf`.
            raise_reject (bool or array_like): Whether to raise an exception if order gets rejected.
                Will broadcast.
            log (bool or array_like): Whether to log orders.
                Will broadcast.
            accumulate (bool or array_like): Whether to accumulate signals.
                Will broadcast.

                Behaves similarly to `Portfolio.from_orders`.
            conflict_mode (ConflictMode or array_like): See `vectorbt.portfolio.enums.ConflictMode`.
                Will broadcast.
            close_first (bool or array_like): Whether to close the position first before reversal.
                Will broadcast.

                Otherwise reverses the position with a single order and within the same tick.
                Takes only effect under `Direction.All`. Requires a second signal to enter
                the opposite position. This allows to define parameters such as `fixed_fees` for long
                and short positions separately.
            val_price (array_like of float): Asset valuation price.
                Defaults to `price` if set, otherwise to previous `close`.

                See `val_price` in `Portfolio.from_orders`.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                See `init_cash` in `Portfolio.from_order_func`.
            cash_sharing (bool): Whether to share cash within the same group.

                See `cash_sharing` in `Portfolio.from_orders`.
            call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

                See `call_seq` in `Portfolio.from_orders`.
            max_orders (int): Size of the order records array.
                Defaults to the number of elements in the broadcasted shape.

                Set to a lower number if you run out of memory.
            max_logs (int): Size of the log records array.
                Defaults to the number of elements in the broadcasted shape if any of the `log` is True,
                otherwise to 1.

                Set to a lower number if you run out of memory.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            freq (any): Index frequency in case `close.index` is not datetime-like.
            **kwargs: Keyword arguments passed to the `__init__` method.

        All broadcastable arguments will be broadcast using `vectorbt.base.reshape_fns.broadcast`
        but keep original shape to utilize flexible indexing and to save memory.

        For defaults, see `vectorbt.settings.portfolio`.

        !!! hint
            If you generated signals using close price, don&#39;t forget to shift your signals by one tick
            forward, for example, with `signals.vbt.fshift(1)`. In general, make sure to use a price
            that comes after the signal.

        Also see notes and hints for `Portfolio.from_orders`.

        ## Example

        Some of the ways of how signals are interpreted:

        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; entries = pd.Series([True, True, True, False, False])
        &gt;&gt;&gt; exits = pd.Series([False, False, True, True, True])

        &gt;&gt;&gt; # Entry opens long, exit closes long
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;longonly&#39;)
        &gt;&gt;&gt; portfolio.share_flow()
        0    1.0
        1    0.0
        2    0.0
        3   -1.0
        4    0.0
        dtype: float64

        &gt;&gt;&gt; # Entry opens short, exit closes short
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;shortonly&#39;)
        &gt;&gt;&gt; portfolio.share_flow()
        0   -1.0
        1    0.0
        2    0.0
        3    1.0
        4    0.0
        dtype: float64

        &gt;&gt;&gt; # Entry opens long and closes short, exit closes long and opens short
        &gt;&gt;&gt; # Reversal within one tick
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;)
        &gt;&gt;&gt; portfolio.share_flow()
        0    1.0
        1    0.0
        2    0.0
        3   -2.0
        4    0.0
        dtype: float64

        &gt;&gt;&gt; # Reversal within two ticks
        &gt;&gt;&gt; # First signal closes position, second signal opens the opposite one
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;,
        ...     close_first=True)
        &gt;&gt;&gt; portfolio.share_flow()
        0    1.0
        1    0.0
        2    0.0
        3   -1.0
        4   -1.0
        dtype: float64

        &gt;&gt;&gt; # If entry and exit, chooses exit
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;,
        ...     close_first=True, conflict_mode=&#39;exit&#39;)
        &gt;&gt;&gt; portfolio.share_flow()
        0    1.0
        1    0.0
        2   -1.0
        3   -1.0
        4    0.0
        dtype: float64

        &gt;&gt;&gt; # Entry means long order, exit means short order
        &gt;&gt;&gt; # Acts similar to `from_orders`
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;,
        ...     accumulate=True)
        &gt;&gt;&gt; portfolio.share_flow()
        0    1.0
        1    1.0
        2    0.0
        3   -1.0
        4   -1.0
        dtype: float64

        &gt;&gt;&gt; # Testing multiple parameters (via broadcasting)
        &gt;&gt;&gt; from vectorbt.portfolio.enums import Direction

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     close, entries, exits, direction=[list(Direction)],
        ...     broadcast_kwargs=dict(columns_from=Direction._fields))
        &gt;&gt;&gt; portfolio.share_flow()
            Long  Short    All
        0  100.0 -100.0  100.0
        1    0.0    0.0    0.0
        2    0.0    0.0    0.0
        3 -100.0   50.0 -200.0
        4    0.0    0.0    0.0
        ```
        &#34;&#34;&#34;
        # Get defaults
        from vectorbt import settings

        if size is None:
            size = settings.portfolio[&#39;size&#39;]
        if size_type is None:
            size_type = settings.portfolio[&#39;signal_size_type&#39;]
        size_type = convert_str_enum_value(SizeType, size_type)
        if direction is None:
            direction = settings.portfolio[&#39;signal_direction&#39;]
        direction = convert_str_enum_value(Direction, direction)
        if price is None:
            price = close
        if fees is None:
            fees = settings.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = settings.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = settings.portfolio[&#39;slippage&#39;]
        if min_size is None:
            min_size = settings.portfolio[&#39;min_size&#39;]
        if max_size is None:
            max_size = settings.portfolio[&#39;max_size&#39;]
        if reject_prob is None:
            reject_prob = settings.portfolio[&#39;reject_prob&#39;]
        if allow_partial is None:
            allow_partial = settings.portfolio[&#39;allow_partial&#39;]
        if raise_reject is None:
            raise_reject = settings.portfolio[&#39;raise_reject&#39;]
        if log is None:
            log = settings.portfolio[&#39;log&#39;]
        if accumulate is None:
            accumulate = settings.portfolio[&#39;accumulate&#39;]
        if conflict_mode is None:
            conflict_mode = settings.portfolio[&#39;conflict_mode&#39;]
        conflict_mode = convert_str_enum_value(ConflictMode, conflict_mode)
        if close_first is None:
            close_first = settings.portfolio[&#39;close_first&#39;]
        if val_price is None:
            if price is None:
                if checks.is_pandas(close):
                    val_price = close.vbt.fshift(1)
                else:
                    val_price = np.require(close, dtype=np.float_)
                    val_price = np.roll(val_price, 1, axis=0)
                    val_price[0] = np.nan
            else:
                val_price = price
        if init_cash is None:
            init_cash = settings.portfolio[&#39;init_cash&#39;]
        init_cash = convert_str_enum_value(InitCashMode, init_cash)
        if isinstance(init_cash, int) and init_cash in InitCashMode:
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = settings.portfolio[&#39;cash_sharing&#39;]
        if call_seq is None:
            call_seq = settings.portfolio[&#39;call_seq&#39;]
        call_seq = convert_str_enum_value(CallSeqType, call_seq)
        auto_call_seq = False
        if isinstance(call_seq, int):
            if call_seq == CallSeqType.Auto:
                call_seq = CallSeqType.Default
                auto_call_seq = True
        if seed is None:
            seed = settings.portfolio[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = settings.portfolio[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Broadcast inputs
        # Only close is broadcast, others can remain unchanged thanks to flexible indexing
        broadcastable_args = (
            close,
            entries,
            exits,
            size,
            size_type,
            direction,
            price,
            fees,
            fixed_fees,
            slippage,
            min_size,
            max_size,
            reject_prob,
            allow_partial,
            raise_reject,
            accumulate,
            log,
            conflict_mode,
            close_first,
            val_price
        )
        keep_raw = [False] + [True] * (len(broadcastable_args) - 1)
        broadcast_kwargs = merge_dicts(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
        broadcasted_args = broadcast(*broadcastable_args, **broadcast_kwargs, keep_raw=keep_raw)
        close = broadcasted_args[0]
        if not checks.is_pandas(close):
            close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
        target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
        init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
        group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
        if checks.is_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
        if max_orders is None:
            max_orders = target_shape_2d[0] * target_shape_2d[1]
        if max_logs is None:
            max_logs = target_shape_2d[0] * target_shape_2d[1]
        if not np.any(log):
            max_logs = 1

        # Perform calculation
        order_records, log_records = nb.simulate_from_signals_nb(
            target_shape_2d,
            cs_group_lens,  # group only if cash sharing is enabled to speed up
            init_cash,
            call_seq,
            auto_call_seq,
            *broadcasted_args[1:],
            max_orders,
            max_logs,
            close.ndim == 2
        )

        # Create an instance
        return cls(
            wrapper,
            close,
            order_records,
            log_records,
            init_cash if init_cash_mode is None else init_cash_mode,
            cash_sharing,
            call_seq,
            **kwargs
        )

    @classmethod
    def from_orders(cls, close, size, size_type=None, direction=None, price=None, fees=None,
                    fixed_fees=None, slippage=None, min_size=None, max_size=None, reject_prob=None,
                    allow_partial=None, raise_reject=None, log=None, val_price=None, init_cash=None,
                    cash_sharing=None, call_seq=None, max_orders=None, max_logs=None, seed=None,
                    group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs):
        &#34;&#34;&#34;Simulate portfolio from orders.

        Starting with initial cash `init_cash`, orders the number of shares specified in `size`
        for `price`.

        Args:
            close (array_like): Reference price, such as close.
                Will broadcast.

                Will be used for calculating unrealized P&amp;L and portfolio value.
            size (float or array_like): Size to order.
                Will broadcast.

                Behavior depends upon `size_type` and `direction`. For `SizeType.Shares`:

                * Set to any number to buy/sell some fixed amount of shares.
                    Longs are limited by cash in the account, while shorts are unlimited.
                * Set to `np.inf` to buy shares for all cash, or `-np.inf` to sell shares for
                    initial margin of 100%. If `direction` is not `all`, `-np.inf` will close the position.
                * Set to `np.nan` or 0 to skip.

                For any target size:

                * Set to any number to buy/sell amount of shares relative to current holdings or value.
                * Set to 0 to close the current position.
                * Set to `np.nan` to skip.
            size_type (SizeType or array_like): See `vectorbt.portfolio.enums.SizeType`.
                Will broadcast.

                !!! note
                    `SizeType.Percent` does not support position reversal. Switch to a single direction.

                !!! warning
                    Be cautious using `SizeType.Percent` with `call_seq` set to &#39;auto&#39;.
                    To execute sell orders before buy orders, the value of each order in the group
                    needs to be approximated in advance. But since `SizeType.Percent` depends
                    upon cash balance, which cannot be calculated in advance, the latest cash balance
                    is used. This can yield wrong call sequence for buy orders.
            direction (Direction or array_like): See `vectorbt.portfolio.enums.Direction`.
                Will broadcast.
            price (array_like of float): Order price.
                Defaults to `close`. Will broadcast.
            fees (float or array_like): Fees in percentage of the order value.
                Will broadcast. Note that 0.01 = 1%.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order.
                Will broadcast.
            slippage (float or array_like): Slippage in percentage of price.
                Will broadcast. Note that 0.01 = 1%.
            min_size (float or array_like): Minimum size for an order to be accepted.
                Will broadcast.
            max_size (float or array_like): Maximum size for an order.
                Will broadcast.

                Will be partially filled if exceeded.
            reject_prob (float or array_like): Order rejection probability.
                Will broadcast.
            allow_partial (bool or array_like): Whether to allow partial fills.
                Will broadcast.

                Does not apply when size is `np.inf`.
            raise_reject (bool or array_like): Whether to raise an exception if order gets rejected.
                Will broadcast.
            log (bool or array_like): Whether to log orders.
                Will broadcast.
            val_price (array_like of float): Asset valuation price.
                Defaults to `price`. Will broadcast.

                Used at the time of decision making to calculate value of each asset in the group,
                for example, to convert target value into target shares.

                !!! note
                    Make sure to use timestamp for `val_price` that comes before timestamps of
                    all orders in the group with cash sharing (previous `close` for example),
                    otherwise you&#39;re cheating yourself.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                See `init_cash` in `Portfolio.from_order_func`.
            cash_sharing (bool): Whether to share cash within the same group.

                !!! warning
                    Introduces cross-asset dependencies.

                    This method presumes that in a group of assets that share the same capital all
                    orders will be executed within the same tick and retain their price regardless
                    of their position in the queue, even though they depend upon each other and thus
                    cannot be executed in parallel.
            call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

                Each value in this sequence should indicate the position of column in the group to
                call next. Processing of `call_seq` goes always from left to right.
                For example, `[2, 0, 1]` would first call column &#39;c&#39;, then &#39;a&#39;, and finally &#39;b&#39;.

                * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
                * Set to array to specify custom sequence. Will not broadcast.

                If `CallSeqType.Auto` selected, rearranges calls dynamically based on order value.
                Calculates value of all orders per row and group, and sorts them by this value.
                Sell orders will be executed first to release funds for buy orders.

                !!! warning
                    `CallSeqType.Auto` should be used with caution:

                    * It not only presumes that order prices are known beforehand, but also that
                        orders can be executed in arbitrary order and still retain their price.
                        In reality, this is hardly the case: after processing one asset, some time
                        has passed and the price for other assets might have already changed.
                    * Even if you&#39;re able to specify a slippage large enough to compensate for
                        this behavior, slippage itself should depend upon execution order.
                        This method doesn&#39;t let you do that.
                    * If one order is rejected, it still may execute next orders and possibly
                        leave them without required funds.

                    For more control, use `Portfolio.from_order_func`.
            max_orders (int): Size of the order records array.
                Defaults to the number of elements in the broadcasted shape.

                Set to a lower number if you run out of memory.
            max_logs (int): Size of the log records array.
                Defaults to the number of elements in the broadcasted shape if any of the `log` is True,
                otherwise to 1.

                Set to a lower number if you run out of memory.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            freq (any): Index frequency in case `close.index` is not datetime-like.
            **kwargs: Keyword arguments passed to the `__init__` method.

        All broadcastable arguments will be broadcast using `vectorbt.base.reshape_fns.broadcast`
        but keep original shape to utilize flexible indexing and to save memory.

        For defaults, see `vectorbt.settings.portfolio`.

        !!! note
            When `call_seq` is not `CallSeqType.Auto`, at each timestamp, processing of the assets in
            a group goes strictly in order defined in `call_seq`. This order can&#39;t be changed dynamically.

            This has one big implication for this particular method: the last asset in the call stack
            cannot be processed until other assets are processed. This is the reason why rebalancing
            cannot work properly in this setting: one has to specify percentages for all assets beforehand
            and then tweak the processing order to sell to-be-sold assets first in order to release funds
            for to-be-bought assets. This can be automatically done by using `CallSeqType.Auto`.

        !!! hint
            All broadcastable arguments can be set per frame, series, row, column, or element.

        ## Example

        Buy 10 shares each tick:
        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(close, 10)

        &gt;&gt;&gt; portfolio.shares()
        0    10.0
        1    20.0
        2    30.0
        3    40.0
        4    40.0
        dtype: float64
        &gt;&gt;&gt; portfolio.cash()
        0    90.0
        1    70.0
        2    40.0
        3     0.0
        4     0.0
        dtype: float64
        ```

        Reverse each position by first closing it:
        ```python-repl
        &gt;&gt;&gt; size = [1, 0, -1, 0, 1]
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(close, size, size_type=&#39;targetpercent&#39;)

        &gt;&gt;&gt; portfolio.shares()
        0    100.000000
        1      0.000000
        2    -66.666667
        3      0.000000
        4     26.666667
        dtype: float64
        &gt;&gt;&gt; portfolio.cash()
        0      0.000000
        1    200.000000
        2    400.000000
        3    133.333333
        4      0.000000
        dtype: float64
        ```

        Equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb` example:
        It&#39;s more compact but has less control over execution:

        ```python-repl
        &gt;&gt;&gt; import numpy as np

        &gt;&gt;&gt; np.random.seed(42)
        &gt;&gt;&gt; close = pd.DataFrame(np.random.uniform(1, 10, size=(5, 3)))
        &gt;&gt;&gt; size = pd.Series(np.full(5, 1/3))  # each column 33.3%
        &gt;&gt;&gt; size[1::2] = np.nan  # skip every second tick

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
        ...     close,  # acts both as reference and order price here
        ...     size,
        ...     size_type=&#39;targetpercent&#39;,
        ...     call_seq=&#39;auto&#39;,  # first sell then buy
        ...     group_by=True,  # one group
        ...     cash_sharing=True,  # assets share the same cash
        ...     fees=0.001, fixed_fees=1., slippage=0.001  # costs
        ... )

        &gt;&gt;&gt; portfolio.holding_value(group_by=False).vbt.plot()
        ```

        ![](/vectorbt/docs/img/simulate_nb.png)
        &#34;&#34;&#34;
        # Get defaults
        from vectorbt import settings

        if size is None:
            size = settings.portfolio[&#39;size&#39;]
        if size_type is None:
            size_type = settings.portfolio[&#39;size_type&#39;]
        size_type = convert_str_enum_value(SizeType, size_type)
        if direction is None:
            direction = settings.portfolio[&#39;order_direction&#39;]
        direction = convert_str_enum_value(Direction, direction)
        if price is None:
            price = close
        if fees is None:
            fees = settings.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = settings.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = settings.portfolio[&#39;slippage&#39;]
        if min_size is None:
            min_size = settings.portfolio[&#39;min_size&#39;]
        if max_size is None:
            max_size = settings.portfolio[&#39;max_size&#39;]
        if reject_prob is None:
            reject_prob = settings.portfolio[&#39;reject_prob&#39;]
        if allow_partial is None:
            allow_partial = settings.portfolio[&#39;allow_partial&#39;]
        if raise_reject is None:
            raise_reject = settings.portfolio[&#39;raise_reject&#39;]
        if log is None:
            log = settings.portfolio[&#39;log&#39;]
        if val_price is None:
            val_price = price
        if init_cash is None:
            init_cash = settings.portfolio[&#39;init_cash&#39;]
        init_cash = convert_str_enum_value(InitCashMode, init_cash)
        if isinstance(init_cash, int) and init_cash in InitCashMode:
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = settings.portfolio[&#39;cash_sharing&#39;]
        if call_seq is None:
            call_seq = settings.portfolio[&#39;call_seq&#39;]
        call_seq = convert_str_enum_value(CallSeqType, call_seq)
        auto_call_seq = False
        if isinstance(call_seq, int):
            if call_seq == CallSeqType.Auto:
                call_seq = CallSeqType.Default
                auto_call_seq = True
        if seed is None:
            seed = settings.portfolio[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = settings.portfolio[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Broadcast inputs
        # Only close is broadcast, others can remain unchanged thanks to flexible indexing
        broadcastable_args = (
            close,
            size,
            size_type,
            direction,
            price,
            fees,
            fixed_fees,
            slippage,
            min_size,
            max_size,
            reject_prob,
            allow_partial,
            raise_reject,
            log,
            val_price
        )
        keep_raw = [False] + [True] * (len(broadcastable_args) - 1)
        broadcast_kwargs = merge_dicts(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
        broadcasted_args = broadcast(*broadcastable_args, **broadcast_kwargs, keep_raw=keep_raw)
        close = broadcasted_args[0]
        if not checks.is_pandas(close):
            close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
        target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
        init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
        group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
        if checks.is_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
        if max_orders is None:
            max_orders = target_shape_2d[0] * target_shape_2d[1]
        if max_logs is None:
            max_logs = target_shape_2d[0] * target_shape_2d[1]
        if not np.any(log):
            max_logs = 1

        # Perform calculation
        order_records, log_records = nb.simulate_from_orders_nb(
            target_shape_2d,
            cs_group_lens,  # group only if cash sharing is enabled to speed up
            init_cash,
            call_seq,
            auto_call_seq,
            *broadcasted_args[1:],
            max_orders,
            max_logs,
            close.ndim == 2
        )

        # Create an instance
        return cls(
            wrapper,
            close,
            order_records,
            log_records,
            init_cash if init_cash_mode is None else init_cash_mode,
            cash_sharing,
            call_seq,
            **kwargs
        )

    @classmethod
    def from_order_func(cls, close, order_func_nb, *order_args, target_shape=None, keys=None,
                        init_cash=None, cash_sharing=None, call_seq=None, active_mask=None,
                        prep_func_nb=None, prep_args=None, group_prep_func_nb=None, group_prep_args=None,
                        row_prep_func_nb=None, row_prep_args=None, segment_prep_func_nb=None,
                        segment_prep_args=None, row_wise=None, max_orders=None, max_logs=None,
                        seed=None, group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs):
        &#34;&#34;&#34;Build portfolio from a custom order function.

        For details, see `vectorbt.portfolio.nb.simulate_nb`.

        if `row_wise` is True, also see `vectorbt.portfolio.nb.simulate_row_wise_nb`.

        Args:
            close (array_like): Reference price, such as close.
                Will broadcast to `target_shape`.

                Will be used for calculating unrealized P&amp;L and portfolio value.
            order_func_nb (callable): Order generation function.
            *order_args: Arguments passed to `order_func_nb`.
            target_shape (tuple): Target shape to iterate over. Defaults to `close.shape`.
            keys (sequence): Outermost column level.

                Each element should correspond to one iteration over columns in `close`.
                Should be set only if `target_shape` is bigger than `close.shape`.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                By default, will broadcast to the number of columns.
                If cash sharing is enabled, will broadcast to the number of groups.
                See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

                !!! note
                    Mode `InitCashMode.AutoAlign` is applied after the portfolio is initialized
                    to set the same initial cash for all columns/groups. Changing grouping
                    will change the initial cash, so be aware when indexing.
            cash_sharing (bool): Whether to share cash within the same group.

                !!! warning
                    Introduces cross-asset dependencies.
            call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

                * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
                * Set to array to specify custom sequence. Will not broadcast.

                !!! note
                    CallSeqType.Auto should be implemented manually.
                    Use `auto_call_seq_ctx_nb` in `segment_prep_func_nb`.
            active_mask (int or array_like of bool): Mask of whether a particular segment should be executed.

                Supplying an integer will activate every n-th row (just for convenience).
                Supplying a boolean will broadcast to the number of rows and groups.
            prep_func_nb (callable): Simulation preparation function.
            prep_args (tuple): Packed arguments passed to `prep_func_nb`.

                Defaults to `()`.
            group_prep_func_nb (callable): Group preparation function.

                Called only if `row_wise` is False.
            group_prep_args (tuple): Packed arguments passed to `group_prep_func_nb`.

                Defaults to `()`.
            row_prep_func_nb (callable): Row preparation function.

                Called only if `row_wise` is True.
            row_prep_args (tuple): Packed arguments passed to `row_prep_func_nb`.

                Defaults to `()`.
            segment_prep_func_nb (callable): Segment preparation function.
            segment_prep_args (tuple): Packed arguments passed to `segment_prep_func_nb`.

                Defaults to `()`.
            row_wise (bool): Whether to iterate over rows rather than columns/groups.

                See `vectorbt.portfolio.nb.simulate_row_wise_nb`.
            max_orders (int): Size of the order records array.
                Defaults to the number of elements in the broadcasted shape.

                Set to a lower number if you run out of memory.
            max_logs (int): Size of the log records array.
                Defaults to the number of elements in the broadcasted shape.

                Set to a lower number if you run out of memory.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            freq (any): Index frequency in case `close.index` is not datetime-like.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.settings.portfolio`.

        !!! note
            All passed functions should be Numba-compiled.

            Objects passed as arguments to both functions will not broadcast to `target_shape`
            as their purpose is unknown. You should broadcast manually or use flexible indexing.

            Also see notes on `Portfolio.from_orders`.

        !!! note
            In contrast to other methods, the valuation price is previous `close`
            instead of order price, since the price of an order is unknown before call.
            You can still set valuation price explicitly in `segment_prep_func_nb`.

        ## Example

        Buy 10 shares each tick:
        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from numba import njit
        &gt;&gt;&gt; import vectorbt as vbt
        &gt;&gt;&gt; from vectorbt.portfolio.nb import create_order_nb

        &gt;&gt;&gt; @njit
        ... def order_func_nb(oc, size):
        ...     return create_order_nb(size=size, price=oc.close[oc.i, oc.col])

        &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(close, order_func_nb, 10)

        &gt;&gt;&gt; portfolio.shares()
        0    10.0
        1    20.0
        2    30.0
        3    40.0
        4    40.0
        dtype: float64
        &gt;&gt;&gt; portfolio.cash()
        0    90.0
        1    70.0
        2    40.0
        3     0.0
        4     0.0
        dtype: float64
        ```

        Reverse each position by first closing it. Keep state of last position to determine
        which position to open next (just as an example, there are easier ways to do this):
        ```python-repl
        &gt;&gt;&gt; import numpy as np

        &gt;&gt;&gt; @njit
        ... def group_prep_func_nb(gc):
        ...     last_pos_state = np.array([-1])
        ...     return (last_pos_state,)

        &gt;&gt;&gt; @njit
        ... def order_func_nb(oc, last_pos_state):
        ...     if oc.shares_now &gt; 0:
        ...         size = -oc.shares_now  # close long
        ...     elif oc.shares_now &lt; 0:
        ...         size = -oc.shares_now  # close short
        ...     else:
        ...         if last_pos_state[0] == 1:
        ...             size = -np.inf  # open short
        ...             last_pos_state[0] = -1
        ...         else:
        ...             size = np.inf  # open long
        ...             last_pos_state[0] = 1
        ...
        ...     return create_order_nb(size=size, price=oc.close[oc.i, oc.col])

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
        ...     close, order_func_nb, group_prep_func_nb=group_prep_func_nb)

        &gt;&gt;&gt; portfolio.shares()
        0    100.0
        1      0.0
        2   -100.0
        3      0.0
        4     20.0
        dtype: float64
        &gt;&gt;&gt; portfolio.cash()
        0      0.0
        1    200.0
        2    500.0
        3    100.0
        4      0.0
        dtype: float64
        ```

        Equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb` example:
        ```python-repl
        &gt;&gt;&gt; from vectorbt.portfolio.nb import auto_call_seq_ctx_nb
        &gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, Direction

        &gt;&gt;&gt; @njit
        ... def group_prep_func_nb(gc):
        ...     &#39;&#39;&#39;Define empty arrays for each group.&#39;&#39;&#39;
        ...     size = np.empty(gc.group_len, dtype=np.float_)
        ...     size_type = np.empty(gc.group_len, dtype=np.int_)
        ...     direction = np.empty(gc.group_len, dtype=np.int_)
        ...     temp_float_arr = np.empty(gc.group_len, dtype=np.float_)
        ...     return size, size_type, direction, temp_float_arr

        &gt;&gt;&gt; @njit
        ... def segment_prep_func_nb(sc, size, size_type, direction, temp_float_arr):
        ...     &#39;&#39;&#39;Perform rebalancing at each segment.&#39;&#39;&#39;
        ...     for k in range(sc.group_len):
        ...         col = sc.from_col + k
        ...         size[k] = 1 / sc.group_len
        ...         size_type[k] = SizeType.TargetPercent
        ...         direction[k] = Direction.LongOnly
        ...         sc.last_val_price[col] = sc.close[sc.i, col]
        ...     auto_call_seq_ctx_nb(sc, size, size_type, direction, temp_float_arr)
        ...     return size, size_type, direction

        &gt;&gt;&gt; @njit
        ... def order_func_nb(oc, size, size_type, direction, fees, fixed_fees, slippage):
        ...     &#39;&#39;&#39;Place an order.&#39;&#39;&#39;
        ...     col_i = oc.call_seq_now[oc.call_idx]
        ...     return create_order_nb(
        ...         size=size[col_i],
        ...         size_type=size_type[col_i],
        ...         price=oc.close[oc.i, oc.col],
        ...         fees=fees, fixed_fees=fixed_fees, slippage=slippage,
        ...         direction=direction[col_i]
        ...     )

        &gt;&gt;&gt; np.random.seed(42)
        &gt;&gt;&gt; close = np.random.uniform(1, 10, size=(5, 3))
        &gt;&gt;&gt; fees = 0.001
        &gt;&gt;&gt; fixed_fees = 1.
        &gt;&gt;&gt; slippage = 0.001

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
        ...     close,  # acts both as reference and order price here
        ...     order_func_nb, fees, fixed_fees, slippage,  # order_args as *args
        ...     active_mask=2,  # rebalance every second tick
        ...     group_prep_func_nb=group_prep_func_nb,
        ...     segment_prep_func_nb=segment_prep_func_nb,
        ...     cash_sharing=True, group_by=True,  # one group with cash sharing
        ... )

        &gt;&gt;&gt; portfolio.holding_value(group_by=False).vbt.plot()
        ```

        ![](/vectorbt/docs/img/simulate_nb.png)
        &#34;&#34;&#34;
        # Get defaults
        from vectorbt import settings

        if not checks.is_pandas(close):
            if not checks.is_array(close):
                close = np.asarray(close)
            close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
        if target_shape is None:
            target_shape = close.shape
        if init_cash is None:
            init_cash = settings.portfolio[&#39;init_cash&#39;]
        init_cash = convert_str_enum_value(InitCashMode, init_cash)
        if isinstance(init_cash, int) and init_cash in InitCashMode:
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = settings.portfolio[&#39;cash_sharing&#39;]
        if call_seq is None:
            call_seq = settings.portfolio[&#39;call_seq&#39;]
        call_seq = convert_str_enum_value(CallSeqType, call_seq)
        if isinstance(call_seq, int):
            if call_seq == CallSeqType.Auto:
                raise ValueError(&#34;CallSeqType.Auto should be implemented manually. &#34;
                                 &#34;Use auto_call_seq_ctx_nb in segment_prep_func_nb.&#34;)
        if active_mask is None:
            active_mask = True
        if row_wise is None:
            row_wise = settings.portfolio[&#39;row_wise&#39;]
        if seed is None:
            seed = settings.portfolio[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = settings.portfolio[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        require_kwargs = dict(require_kwargs=dict(requirements=&#39;W&#39;))
        broadcast_kwargs = merge_dicts(require_kwargs, broadcast_kwargs)
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Broadcast inputs
        target_shape_2d = (target_shape[0], target_shape[1] if len(target_shape) &gt; 1 else 1)
        if close.shape != target_shape:
            if len(close.vbt.wrapper.columns) &lt;= target_shape_2d[1]:
                if target_shape_2d[1] % len(close.vbt.wrapper.columns) != 0:
                    raise ValueError(&#34;Cannot broadcast close to target_shape&#34;)
                if keys is None:
                    keys = pd.Index(np.arange(target_shape_2d[1]), name=&#39;iteration_idx&#39;)
                tile_times = target_shape_2d[1] // len(close.vbt.wrapper.columns)
                close = close.vbt.tile(tile_times, keys=keys)
        close = broadcast(close, to_shape=target_shape, **broadcast_kwargs)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
        init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
        group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
        if isinstance(active_mask, int):
            _active_mask = np.full((target_shape_2d[0], len(group_lens)), False)
            _active_mask[0::active_mask] = True
            active_mask = _active_mask
        else:
            active_mask = broadcast(
                active_mask,
                to_shape=(target_shape_2d[0], len(group_lens)),
                to_pd=False,
                **require_kwargs
            )
        if checks.is_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
        if max_orders is None:
            max_orders = target_shape_2d[0] * target_shape_2d[1]
        if max_logs is None:
            max_logs = target_shape_2d[0] * target_shape_2d[1]

        # Prepare arguments
        if prep_func_nb is None:
            prep_func_nb = nb.empty_prep_nb
        if prep_args is None:
            prep_args = ()
        if group_prep_func_nb is None:
            group_prep_func_nb = nb.empty_prep_nb
        if group_prep_args is None:
            group_prep_args = ()
        if row_prep_func_nb is None:
            row_prep_func_nb = nb.empty_prep_nb
        if row_prep_args is None:
            row_prep_args = ()
        if segment_prep_func_nb is None:
            segment_prep_func_nb = nb.empty_prep_nb
        if segment_prep_args is None:
            segment_prep_args = ()

        # Perform calculation
        if row_wise:
            order_records, log_records = nb.simulate_row_wise_nb(
                target_shape_2d,
                to_2d(close, raw=True),
                group_lens,
                init_cash,
                cash_sharing,
                call_seq,
                active_mask,
                prep_func_nb,
                prep_args,
                row_prep_func_nb,
                row_prep_args,
                segment_prep_func_nb,
                segment_prep_args,
                order_func_nb,
                order_args,
                max_orders,
                max_logs
            )
        else:
            order_records, log_records = nb.simulate_nb(
                target_shape_2d,
                to_2d(close, raw=True),
                group_lens,
                init_cash,
                cash_sharing,
                call_seq,
                active_mask,
                prep_func_nb,
                prep_args,
                group_prep_func_nb,
                group_prep_args,
                segment_prep_func_nb,
                segment_prep_args,
                order_func_nb,
                order_args,
                max_orders,
                max_logs
            )

        # Create an instance
        return cls(
            wrapper,
            close,
            order_records,
            log_records,
            init_cash if init_cash_mode is None else init_cash_mode,
            cash_sharing,
            call_seq,
            **kwargs
        )

    # ############# Properties ############# #

    @property
    def wrapper(self):
        &#34;&#34;&#34;Array wrapper.&#34;&#34;&#34;
        if self.cash_sharing:
            # Allow only disabling grouping when needed (but not globally, see regroup)
            return self._wrapper.copy(
                allow_enable=False,
                allow_modify=False
            )
        return self._wrapper

    def regroup(self, group_by, **kwargs):
        &#34;&#34;&#34;Regroup this object.

        See `vectorbt.base.array_wrapper.Wrapping.regroup`.&#34;&#34;&#34;
        if self.cash_sharing:
            if self.wrapper.grouper.is_grouping_modified(group_by=group_by):
                raise ValueError(&#34;Cannot modify grouping globally when cash_sharing=True&#34;)
        return Wrapping.regroup(self, group_by, **kwargs)

    @property
    def cash_sharing(self):
        &#34;&#34;&#34;Whether to share cash within the same group.&#34;&#34;&#34;
        return self._cash_sharing

    @property
    def call_seq(self):
        &#34;&#34;&#34;Sequence of calls per row and group.&#34;&#34;&#34;
        return self.wrapper.wrap(self._call_seq, group_by=False)

    @property
    def incl_unrealized(self):
        &#34;&#34;&#34;Whether to include unrealized trade P&amp;L in statistics.&#34;&#34;&#34;
        return self._incl_unrealized

    @property
    def use_filled_close(self):
        &#34;&#34;&#34;Whether to forward-backward fill NaN values in `Portfolio.close`.&#34;&#34;&#34;
        return self._use_filled_close

    # ############# Reference price ############# #

    @property
    def close(self):
        &#34;&#34;&#34;Price per share series.&#34;&#34;&#34;
        return self._close

    @cached_method
    def fill_close(self, ffill=True, bfill=True):
        &#34;&#34;&#34;Fill NaN values of `Portfolio.close`.
        Use `ffill` and `bfill` to fill forwards and backwards respectively.&#34;&#34;&#34;
        close = to_2d(self.close, raw=True)
        if ffill and np.any(np.isnan(close[-1, :])):
            close = generic_nb.ffill_nb(close)
        if bfill and np.any(np.isnan(close[0, :])):
            close = generic_nb.ffill_nb(close[::-1, :])[::-1, :]
        return self.wrapper.wrap(close, group_by=False)

    # ############# Records ############# #

    @property
    def order_records(self):
        &#34;&#34;&#34;A structured NumPy array of order records.&#34;&#34;&#34;
        return self._order_records

    @cached_property
    def orders(self):
        &#34;&#34;&#34;`Portfolio.get_orders` with default arguments.&#34;&#34;&#34;
        return Orders(self.wrapper, self.order_records, self.close)

    def get_orders(self, group_by=None):
        &#34;&#34;&#34;Get order records.

        See `vectorbt.portfolio.orders.Orders`.&#34;&#34;&#34;
        return self.orders.regroup(group_by=group_by)

    @property
    def log_records(self):
        &#34;&#34;&#34;A structured NumPy array of log records.&#34;&#34;&#34;
        return self._log_records

    @cached_property
    def logs(self):
        &#34;&#34;&#34;`Portfolio.get_logs` with default arguments.&#34;&#34;&#34;
        return Logs(self.wrapper, self.log_records)

    def get_logs(self, group_by=None):
        &#34;&#34;&#34;Get log records.

        See `vectorbt.portfolio.logs.Logs`.&#34;&#34;&#34;
        return self.logs.regroup(group_by=group_by)

    @cached_property
    def trades(self):
        &#34;&#34;&#34;`Portfolio.get_trades` with default arguments.&#34;&#34;&#34;
        return Trades.from_orders(self.orders)

    def get_trades(self, group_by=None):
        &#34;&#34;&#34;Get trade records.

        See `vectorbt.portfolio.trades.Trades`.&#34;&#34;&#34;
        return self.trades.regroup(group_by=group_by)

    @cached_property
    def positions(self):
        &#34;&#34;&#34;`Portfolio.get_positions` with default arguments.&#34;&#34;&#34;
        return Positions.from_trades(self.trades)

    def get_positions(self, group_by=None):
        &#34;&#34;&#34;Get position records.

        See `vectorbt.portfolio.trades.Positions`.&#34;&#34;&#34;
        return self.positions.regroup(group_by=group_by)

    @cached_property
    def drawdowns(self):
        &#34;&#34;&#34;`Portfolio.get_drawdowns` with default arguments.&#34;&#34;&#34;
        return self.get_drawdowns()

    @cached_method
    def get_drawdowns(self, **kwargs):
        &#34;&#34;&#34;Get drawdown records from `Portfolio.value`.

        See `vectorbt.generic.drawdowns.Drawdowns`.

        `**kwargs` are passed to `Portfolio.value`.&#34;&#34;&#34;
        return Drawdowns.from_ts(self.value(**kwargs), freq=self.wrapper.freq)

    # ############# Shares ############# #

    @cached_method
    def share_flow(self, direction=&#39;all&#39;):
        &#34;&#34;&#34;Get share flow series per column.&#34;&#34;&#34;
        direction = convert_str_enum_value(Direction, direction)
        share_flow = nb.share_flow_nb(
            self.wrapper.shape_2d,
            self.orders.values,
            self.orders.col_mapper.col_map,
            direction
        )
        return self.wrapper.wrap(share_flow, group_by=False)

    @cached_method
    def shares(self, direction=&#39;all&#39;):
        &#34;&#34;&#34;Get share series per column.&#34;&#34;&#34;
        direction = convert_str_enum_value(Direction, direction)
        share_flow = to_2d(self.share_flow(direction=&#39;all&#39;), raw=True)
        shares = nb.shares_nb(share_flow)
        if direction == Direction.LongOnly:
            shares = np.where(shares &gt; 0, shares, 0.)
        if direction == Direction.ShortOnly:
            shares = np.where(shares &lt; 0, -shares, 0.)
        return self.wrapper.wrap(shares, group_by=False)

    @cached_method
    def pos_mask(self, direction=&#39;all&#39;, group_by=None):
        &#34;&#34;&#34;Get position mask per column/group.&#34;&#34;&#34;
        direction = convert_str_enum_value(Direction, direction)
        shares = to_2d(self.shares(direction=direction), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            pos_mask = to_2d(self.pos_mask(direction=direction, group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            pos_mask = nb.pos_mask_grouped_nb(pos_mask, group_lens)
        else:
            pos_mask = shares != 0
        return self.wrapper.wrap(pos_mask, group_by=group_by)

    @cached_method
    def pos_coverage(self, direction=&#39;all&#39;, group_by=None):
        &#34;&#34;&#34;Get position coverage per column/group.&#34;&#34;&#34;
        direction = convert_str_enum_value(Direction, direction)
        shares = to_2d(self.shares(direction=direction), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            pos_mask = to_2d(self.pos_mask(direction=direction, group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            pos_coverage = nb.pos_coverage_grouped_nb(pos_mask, group_lens)
        else:
            pos_coverage = np.mean(shares != 0, axis=0)
        return self.wrapper.wrap_reduced(pos_coverage, group_by=group_by)

    # ############# Cash ############# #

    @cached_method
    def cash_flow(self, group_by=None, short_cash=True):
        &#34;&#34;&#34;Get cash flow series per column/group.

        When `short_cash` is set to False, cash never goes above the initial level,
        because an operation always costs money.&#34;&#34;&#34;
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            cash_flow = to_2d(self.cash_flow(group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            cash_flow = nb.cash_flow_grouped_nb(cash_flow, group_lens)
        else:
            cash_flow = nb.cash_flow_nb(
                self.wrapper.shape_2d,
                self.orders.values,
                self.orders.col_mapper.col_map,
                short_cash
            )
        return self.wrapper.wrap(cash_flow, group_by=group_by)

    @cached_property
    def init_cash(self):
        &#34;&#34;&#34;`Portfolio.get_init_cash` with default arguments.&#34;&#34;&#34;
        return self.get_init_cash()

    @cached_method
    def get_init_cash(self, group_by=None):
        &#34;&#34;&#34;Initial amount of cash per column/group with default arguments.

        !!! note
            If initial cash is found automatically and no own cash is used throughout simulation
            (for example, when shorting), initial cash will be set to 1 instead of 0 to
            enable smooth calculation of returns.&#34;&#34;&#34;
        if isinstance(self._init_cash, int):
            cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
            cash_min = np.min(np.cumsum(cash_flow, axis=0), axis=0)
            init_cash = np.where(cash_min &lt; 0, np.abs(cash_min), 1.)
            if self._init_cash == InitCashMode.AutoAlign:
                init_cash = np.full(init_cash.shape, np.max(init_cash))
        else:
            init_cash = to_1d(self._init_cash, raw=True)
            if self.wrapper.grouper.is_grouped(group_by=group_by):
                group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
                init_cash = nb.init_cash_grouped_nb(init_cash, group_lens, self.cash_sharing)
            else:
                group_lens = self.wrapper.grouper.get_group_lens()
                init_cash = nb.init_cash_nb(init_cash, group_lens, self.cash_sharing)
        return self.wrapper.wrap_reduced(init_cash, group_by=group_by)

    @cached_method
    def cash(self, group_by=None, in_sim_order=False, short_cash=True):
        &#34;&#34;&#34;Get cash balance series per column/group.&#34;&#34;&#34;
        if in_sim_order and not self.cash_sharing:
            raise ValueError(&#34;Cash sharing must be enabled for in_sim_order=True&#34;)

        cash_flow = to_2d(self.cash_flow(group_by=group_by, short_cash=short_cash), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
            cash = nb.cash_grouped_nb(
                self.wrapper.shape_2d,
                cash_flow,
                group_lens,
                init_cash
            )
        else:
            group_lens = self.wrapper.grouper.get_group_lens()
            if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
                init_cash = to_1d(self.init_cash, raw=True)
                call_seq = to_2d(self.call_seq, raw=True)
                cash = nb.cash_in_sim_order_nb(cash_flow, group_lens, init_cash, call_seq)
            else:
                init_cash = to_1d(self.get_init_cash(group_by=False), raw=True)
                cash = nb.cash_nb(cash_flow, group_lens, init_cash)
        return self.wrapper.wrap(cash, group_by=group_by)

    # ############# Performance ############# #

    @cached_method
    def holding_value(self, direction=&#39;all&#39;, group_by=None):
        &#34;&#34;&#34;Get holding value series per column/group.&#34;&#34;&#34;
        direction = convert_str_enum_value(Direction, direction)
        close = to_2d(self.close, raw=True).copy()
        shares = to_2d(self.shares(direction=direction), raw=True)
        close[shares == 0] = 0.  # for price being NaN
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            holding_value = to_2d(self.holding_value(direction=direction, group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            holding_value = nb.holding_value_grouped_nb(holding_value, group_lens)
        else:
            holding_value = nb.holding_value_nb(close, shares)
        return self.wrapper.wrap(holding_value, group_by=group_by)

    @cached_method
    def gross_exposure(self, direction=&#39;all&#39;, group_by=None):
        &#34;&#34;&#34;Get gross exposure.&#34;&#34;&#34;
        holding_value = to_2d(self.holding_value(group_by=group_by, direction=direction), raw=True)
        cash = to_2d(self.cash(group_by=group_by, short_cash=False), raw=True)
        gross_exposure = nb.gross_exposure_nb(holding_value, cash)
        return self.wrapper.wrap(gross_exposure, group_by=group_by)

    @cached_method
    def net_exposure(self, group_by=None):
        &#34;&#34;&#34;Get net exposure.&#34;&#34;&#34;
        long_exposure = to_2d(self.gross_exposure(direction=&#39;longonly&#39;, group_by=group_by), raw=True)
        short_exposure = to_2d(self.gross_exposure(direction=&#39;shortonly&#39;, group_by=group_by), raw=True)
        net_exposure = long_exposure - short_exposure
        return self.wrapper.wrap(net_exposure, group_by=group_by)

    @cached_method
    def value(self, group_by=None, in_sim_order=False):
        &#34;&#34;&#34;Get portfolio value series per column/group.

        By default, will generate portfolio value for each asset based on cash flows and thus
        independent from other assets, with initial cash and shares being that of the entire group.
        Useful for generating returns and comparing assets within the same group.

        When `group_by` is False and `in_sim_order` is True, returns value generated in
        simulation order (see [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
        This value cannot be used for generating returns as-is. Useful to analyze how value
        evolved throughout simulation.&#34;&#34;&#34;
        cash = to_2d(self.cash(group_by=group_by, in_sim_order=in_sim_order), raw=True)
        holding_value = to_2d(self.holding_value(group_by=group_by), raw=True)
        if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
            group_lens = self.wrapper.grouper.get_group_lens()
            call_seq = to_2d(self.call_seq, raw=True)
            value = nb.value_in_sim_order_nb(cash, holding_value, group_lens, call_seq)
            # price of NaN is already addressed by ungrouped_value_nb
        else:
            value = nb.value_nb(cash, holding_value)
        return self.wrapper.wrap(value, group_by=group_by)

    @cached_method
    def total_profit(self, group_by=None):
        &#34;&#34;&#34;Get total profit per column/group.

        Calculated directly from order records (fast).

        Uses filled close if `Portfolio.use_filled_close` is True.&#34;&#34;&#34;
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            total_profit = to_1d(self.total_profit(group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            total_profit = nb.total_profit_grouped_nb(
                total_profit,
                group_lens
            )
        else:
            if self.use_filled_close:
                close = to_2d(self.fill_close(), raw=True)
            else:
                close = to_2d(self.close, raw=True)
            total_profit = nb.total_profit_nb(
                self.wrapper.shape_2d,
                close,
                self.orders.values,
                self.orders.col_mapper.col_map
            )
        return self.wrapper.wrap_reduced(total_profit, group_by=group_by)

    @cached_method
    def final_value(self, group_by=None):
        &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        total_profit = to_1d(self.total_profit(group_by=group_by), raw=True)
        final_value = nb.final_value_nb(total_profit, init_cash)
        return self.wrapper.wrap_reduced(final_value, group_by=group_by)

    @cached_method
    def total_return(self, group_by=None):
        &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        total_profit = to_1d(self.total_profit(group_by=group_by), raw=True)
        total_return = nb.total_return_nb(total_profit, init_cash)
        return self.wrapper.wrap_reduced(total_return, group_by=group_by)

    @cached_method
    def returns(self, group_by=None, in_sim_order=False):
        &#34;&#34;&#34;Get return series per column/group based on portfolio value.&#34;&#34;&#34;
        value = to_2d(self.value(group_by=group_by, in_sim_order=in_sim_order), raw=True)
        if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
            group_lens = self.wrapper.grouper.get_group_lens()
            init_cash_grouped = to_1d(self.init_cash, raw=True)
            call_seq = to_2d(self.call_seq, raw=True)
            returns = nb.returns_in_sim_order_nb(value, group_lens, init_cash_grouped, call_seq)
        else:
            init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
            returns = nb.returns_nb(value, init_cash)
        return self.wrapper.wrap(returns, group_by=group_by)

    @cached_method
    def active_returns(self, group_by=None):
        &#34;&#34;&#34;Get active return series per column/group.

        This type of returns is based solely on cash flows and holding value rather than portfolio value.
        It ignores passive cash and thus it will return the same numbers irrespective of the amount of
        cash currently available, even `np.inf`. The scale of returns is comparable to that of going
        all in and keeping available cash at zero.&#34;&#34;&#34;
        cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
        holding_value = to_2d(self.holding_value(group_by=group_by), raw=True)
        active_returns = nb.active_returns_nb(cash_flow, holding_value)
        return self.wrapper.wrap(active_returns, group_by=group_by)

    @cached_method
    def market_value(self, group_by=None):
        &#34;&#34;&#34;Get market (benchmark) value series per column/group.

        If grouped, evenly distributes initial cash among assets in the group.

        Uses filled close if `Portfolio.use_filled_close` is True.

        !!! note
            Does not take into account fees and slippage. For this, create a separate portfolio.&#34;&#34;&#34;
        if self.use_filled_close:
            close = to_2d(self.fill_close(), raw=True)
        else:
            close = to_2d(self.close, raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            init_cash_grouped = to_1d(self.get_init_cash(group_by=group_by), raw=True)
            market_value = nb.market_value_grouped_nb(close, group_lens, init_cash_grouped)
        else:
            init_cash = to_1d(self.get_init_cash(group_by=False), raw=True)
            market_value = nb.market_value_nb(close, init_cash)
        return self.wrapper.wrap(market_value, group_by=group_by)

    @cached_method
    def market_returns(self, group_by=None):
        &#34;&#34;&#34;Get return series per column/group based on market (benchmark) value.&#34;&#34;&#34;
        market_value = to_2d(self.market_value(group_by=group_by), raw=True)
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        market_returns = nb.returns_nb(market_value, init_cash)
        return self.wrapper.wrap(market_returns, group_by=group_by)

    @cached_method
    def total_market_return(self, group_by=None):
        &#34;&#34;&#34;Get total market (benchmark) return.&#34;&#34;&#34;
        market_value = to_2d(self.market_value(group_by=group_by), raw=True)
        total_market_return = nb.total_market_return_nb(market_value)
        return self.wrapper.wrap_reduced(total_market_return, group_by=group_by)

    @cached_method
    def stats(self, column=None, group_by=None, incl_unrealized=None, active_returns=False,
              in_sim_order=False, agg_func=lambda x: x.mean(axis=0), **kwargs):
        &#34;&#34;&#34;Compute various statistics on this portfolio.

        `kwargs` will be passed to each `vectorbt.returns.accessors.ReturnsAccessor` method.

        Can either return aggregated statistics by reducing metrics of all columns with
        `agg_func` (mean by default) or return statistics for a single column if `column`
        was specified or portfolio contains only one column of data. To display rich data types
        such as durations correctly, use an aggregation function that can be applied on `pd.Series`.

        !!! note
            Use `column` only if caching is enabled, otherwise it may re-compute the same
            objects multiple times.&#34;&#34;&#34;
        # Pre-calculate
        trades = self.get_trades(group_by=group_by)
        if incl_unrealized is None:
            incl_unrealized = self.incl_unrealized
        if not incl_unrealized:
            trades = trades.closed
        drawdowns = self.get_drawdowns(group_by=group_by)
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)

        # Run stats
        stats_df = pd.DataFrame({
            &#39;Start&#39;: self.wrapper.index[0],
            &#39;End&#39;: self.wrapper.index[-1],
            &#39;Duration&#39;: self.wrapper.shape[0] * self.wrapper.freq,
            &#39;Init. Cash&#39;: self.get_init_cash(group_by=group_by),
            &#39;Total Profit&#39;: self.total_profit(group_by=group_by),
            &#39;Total Return [%]&#39;: self.total_return(group_by=group_by) * 100,
            &#39;Benchmark Return [%]&#39;: self.total_market_return(group_by=group_by) * 100,
            &#39;Position Coverage [%]&#39;: self.pos_coverage(group_by=group_by) * 100,
            &#39;Max. Drawdown [%]&#39;: -drawdowns.max_drawdown() * 100,
            &#39;Avg. Drawdown [%]&#39;: -drawdowns.avg_drawdown() * 100,
            &#39;Max. Drawdown Duration&#39;: drawdowns.max_duration(),
            &#39;Avg. Drawdown Duration&#39;: drawdowns.avg_duration(),
            &#39;Num. Trades&#39;: trades.count(),
            &#39;Win Rate [%]&#39;: trades.win_rate() * 100,
            &#39;Best Trade [%]&#39;: trades.returns.max() * 100,
            &#39;Worst Trade [%]&#39;: trades.returns.min() * 100,
            &#39;Avg. Trade [%]&#39;: trades.returns.mean() * 100,
            &#39;Max. Trade Duration&#39;: trades.duration.max(time_units=True),
            &#39;Avg. Trade Duration&#39;: trades.duration.mean(time_units=True),
            &#39;Expectancy&#39;: trades.expectancy(),
            &#39;SQN&#39;: trades.sqn(),
            &#39;Gross Exposure&#39;: self.gross_exposure(group_by=group_by).mean(),
            &#39;Sharpe Ratio&#39;: self.sharpe_ratio(reuse_returns=returns, **kwargs),
            &#39;Sortino Ratio&#39;: self.sortino_ratio(reuse_returns=returns, **kwargs),
            &#39;Calmar Ratio&#39;: self.calmar_ratio(reuse_returns=returns, **kwargs)
        }, index=self.wrapper.grouper.get_columns(group_by=group_by))

        # Select columns or reduce
        if stats_df.shape[0] == 1:
            return self.wrapper.wrap_reduced(stats_df.iloc[0], index=stats_df.columns)
        if column is not None:
            return stats_df.loc[column]
        if agg_func is not None:
            agg_stats_sr = pd.Series(index=stats_df.columns, name=agg_func.__name__)
            agg_stats_sr.iloc[:3] = stats_df.iloc[0, :3]
            agg_stats_sr.iloc[3:] = agg_func(stats_df.iloc[:, 3:])
            return agg_stats_sr
        return stats_df

    def returns_stats(self, column=None, group_by=None, active_returns=False, in_sim_order=False,
                      agg_func=lambda x: x.mean(axis=0), year_freq=None, **kwargs):
        &#34;&#34;&#34;Compute various statistics on returns of this portfolio.

        For keyword arguments and notes, see `Portfolio.stats`.

        `kwargs` will be passed to `vectorbt.returns.accessors.ReturnsAccessor.stats` method.
        If `benchmark_rets` is not set, uses `Portfolio.market_returns`.&#34;&#34;&#34;
        # Pre-calculate
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)

        # Run stats
        if &#39;benchmark_rets&#39; not in kwargs:
            kwargs[&#39;benchmark_rets&#39;] = self.market_returns(group_by=group_by)
        stats_obj = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq).stats(**kwargs)

        # Select columns or reduce
        if checks.is_series(stats_obj):
            return stats_obj
        if column is not None:
            return stats_obj.loc[column]
        if agg_func is not None:
            agg_stats_sr = pd.Series(index=stats_obj.columns, name=agg_func.__name__)
            agg_stats_sr.iloc[:3] = stats_obj.iloc[0, :3]
            agg_stats_sr.iloc[3:] = agg_func(stats_obj.iloc[:, 3:])
            return agg_stats_sr
        return stats_obj

    # ############# Plotting ############# #

    subplot_settings = OrderedDict(
        orders=dict(
            title=&#34;Orders&#34;,
            can_plot_groups=False
        ),
        trades=dict(
            title=&#34;Trades&#34;,
            can_plot_groups=False
        ),
        positions=dict(
            title=&#34;Positions&#34;,
            can_plot_groups=False
        ),
        trade_pnl=dict(
            title=&#34;Trade PnL&#34;,
            can_plot_groups=False
        ),
        position_pnl=dict(
            title=&#34;Position PnL&#34;,
            can_plot_groups=False
        ),
        cum_returns=dict(
            title=&#34;Cumulative Returns&#34;
        ),
        share_flow=dict(
            title=&#34;Share Flow&#34;,
            can_plot_groups=False
        ),
        cash_flow=dict(
            title=&#34;Cash Flow&#34;
        ),
        shares=dict(
            title=&#34;Shares&#34;,
            can_plot_groups=False
        ),
        cash=dict(
            title=&#34;Cash&#34;
        ),
        holding_value=dict(
            title=&#34;Holding Value&#34;
        ),
        value=dict(
            title=&#34;Value&#34;
        ),
        drawdowns=dict(
            title=&#34;Drawdowns&#34;
        ),
        underwater=dict(
            title=&#34;Underwater&#34;
        ),
        gross_exposure=dict(
            title=&#34;Gross Exposure&#34;
        ),
        net_exposure=dict(
            title=&#34;Net Exposure&#34;
        )
    )
    &#34;&#34;&#34;Settings of subplots supported by `Portfolio.plot`.&#34;&#34;&#34;

    def plot(self, *,
             column=None,
             subplots=None,
             group_by=None,
             show_titles=True,
             hide_id_labels=True,
             group_id_labels=True,
             hline_shape_kwargs=None,
             make_subplots_kwargs=None,
             **kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot various parts of this portfolio.

        Args:
            subplots (list of str or list of tuple): List of subplots to plot.

                Each element can be either:

                * a subplot name, as listed in `Portfolio.subplot_settings`
                * a tuple of a subplot name and a dict as in `Portfolio.subplot_settings` but with an
                    additional optional key `plot_func`. The plot function should accept current portfolio
                    object (with column already selected) and optionally other keyword arguments.
                    Will pass `row`, `col`, and other subplot-dependent arguments if they can be found
                    in the function&#39;s signature.
            column (str): Name of the column/group to plot.

                Takes effect if portfolio contains multiple columns.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.

                Used to select `group`.
            show_titles (bool): Whether to show the title in the top left corner of each subplot.
            hide_id_labels (bool): Whether to hide identical legend labels.

                Two labels are identical if their name, marker style and line style match.
            group_id_labels (bool): Whether to group identical legend labels.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for horizontal lines.
            make_subplots_kwargs (dict): Keyword arguments passed to `plotly.subplots.make_subplots`.
            **kwargs: Additional keyword arguments.

                Can contain keyword arguments for each subplot, each specified as `{subplot_name}_kwargs`.
                Other keyword arguments are used to update layout of the figure.

        ## Example

        Plot portfolio of a random strategy:
        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from datetime import datetime
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; start = datetime(2020, 1, 1)
        &gt;&gt;&gt; end = datetime(2020, 9, 1)
        &gt;&gt;&gt; close = vbt.utils.data.download(&#34;BTC-USD&#34;, start=start, end=end)[&#39;Close&#39;]

        &gt;&gt;&gt; np.random.seed(42)
        &gt;&gt;&gt; size = pd.Series.vbt.empty_like(close, fill_value=0.)
        &gt;&gt;&gt; n_orders = 20
        &gt;&gt;&gt; rand_idxs = np.random.randint(0, len(size), size=n_orders)
        &gt;&gt;&gt; size.iloc[rand_idxs] = np.random.uniform(-1, 1, size=n_orders)
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
        ...     close, size, direction=&#39;longonly&#39;,
        ...     init_cash=&#39;auto&#39;, freq=&#39;1D&#39;)
        &gt;&gt;&gt; portfolio.plot()
        ```

        ![](/vectorbt/docs/img/portfolio_plot.png)

        You can choose any of the subplots in `Portfolio.subplot_settings`, in any order:

        ```python-repl
        &gt;&gt;&gt; from vectorbt.utils.colors import adjust_opacity

        &gt;&gt;&gt; portfolio.plot(
        ...     subplots=[&#39;drawdowns&#39;, &#39;underwater&#39;],
        ...     drawdowns_kwargs=dict(top_n=3),
        ...     underwater_kwargs=dict(
        ...         trace_kwargs=dict(
        ...             line_color=&#39;#FF6F00&#39;,
        ...             fillcolor=adjust_opacity(&#39;#FF6F00&#39;, 0.3)
        ...         )
        ...     )
        ... )
        ```

        ![](/vectorbt/docs/img/portfolio_plot_drawdowns.png)

        You can also create a custom subplot, either by providing a function or
        by creating a placeholder that can be written later:

        ```python-repl
        &gt;&gt;&gt; fig = portfolio.plot(subplots=[
        ...     &#39;orders&#39;,
        ...     (&#39;order_size&#39;, dict(
        ...         title=&#39;Order Size&#39;,
        ...         can_plot_groups=False
        ...     ))  # placeholder
        ... ])

        &gt;&gt;&gt; size.rename(&#39;Order Size&#39;).vbt.plot(add_trace_kwargs=dict(row=2, col=1), fig=fig)
        ```

        ![](/vectorbt/docs/img/portfolio_plot_custom.png)
        &#34;&#34;&#34;
        from vectorbt.settings import color_schema, layout

        # Select one column/group
        self_col = self.select_series(column=column, group_by=group_by)

        if subplots is None:
            if self_col.wrapper.grouper.is_grouped():
                subplots = [&#39;cum_returns&#39;]
            else:
                subplots = [&#39;orders&#39;, &#39;trade_pnl&#39;, &#39;cum_returns&#39;]
        elif subplots == &#39;all&#39;:
            if self_col.wrapper.grouper.is_grouped():
                supported_subplots = filter(lambda x: x[1].get(&#39;can_plot_groups&#39;, True), self.subplot_settings.items())
            else:
                supported_subplots = self.subplot_settings.items()
            subplots = list(list(zip(*supported_subplots))[0])
        if not isinstance(subplots, list):
            subplots = [subplots]
        if len(subplots) == 0:
            raise ValueError(&#34;You must select at least one subplot&#34;)
        if hline_shape_kwargs is None:
            hline_shape_kwargs = {}
        hline_shape_kwargs = merge_dicts(
            dict(
                type=&#39;line&#39;,
                line=dict(
                    color=&#39;gray&#39;,
                    dash=&#34;dash&#34;,
                )
            ),
            hline_shape_kwargs
        )
        if make_subplots_kwargs is None:
            make_subplots_kwargs = {}

        # Set up figure
        rows = make_subplots_kwargs.pop(&#39;rows&#39;, len(subplots))
        cols = make_subplots_kwargs.pop(&#39;cols&#39;, 1)
        width = kwargs.get(&#39;width&#39;, layout[&#39;width&#39;] + 50)
        height = kwargs.get(&#39;height&#39;, (layout[&#39;height&#39;] - 50) * rows if rows &gt; 1 else layout[&#39;height&#39;])
        specs = make_subplots_kwargs.pop(&#39;specs&#39;, [[{} for _ in range(cols)] for _ in range(rows)])
        row_col_tuples = []
        for row, row_spec in enumerate(specs):
            for col, col_spec in enumerate(row_spec):
                if col_spec is not None:
                    row_col_tuples.append((row + 1, col + 1))
        shared_xaxes = make_subplots_kwargs.pop(&#39;shared_xaxes&#39;, True)
        shared_yaxes = make_subplots_kwargs.pop(&#39;shared_yaxes&#39;, False)
        if height is not None:
            vertical_spacing = make_subplots_kwargs.pop(&#39;vertical_spacing&#39;, 40)
            if vertical_spacing is not None and vertical_spacing &gt; 1:
                vertical_spacing /= height
        else:
            vertical_spacing = make_subplots_kwargs.pop(&#39;vertical_spacing&#39;, None)
        horizontal_spacing = make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;, None)
        if width is not None:
            if horizontal_spacing is not None and horizontal_spacing &gt; 1:
                horizontal_spacing /= width
        if show_titles:
            _subplot_titles = []
            for name in subplots:
                if isinstance(name, tuple):
                    _subplot_titles.append(name[1].get(&#39;title&#39;, None))
                else:
                    _subplot_titles.append(self_col.subplot_settings[name][&#39;title&#39;])
        else:
            _subplot_titles = None
        fig = make_subplots(
            rows=rows,
            cols=cols,
            specs=specs,
            shared_xaxes=shared_xaxes,
            shared_yaxes=shared_yaxes,
            subplot_titles=_subplot_titles,
            vertical_spacing=vertical_spacing,
            horizontal_spacing=horizontal_spacing,
            **make_subplots_kwargs
        )
        default_layout = dict(
            autosize=True,
            width=width,
            height=height,
            legend=dict(
                orientation=&#34;h&#34;,
                yanchor=&#34;bottom&#34;,
                y=(1 + 30 / height) if height is not None else 1.02,
                xanchor=&#34;right&#34;,
                x=1,
                traceorder=&#39;normal&#39;
            )
        )
        fig.update_layout(default_layout)

        def _add_hline(value, x_domain, yref):
            fig.add_shape(**merge_dicts(dict(
                xref=&#34;paper&#34;,
                yref=yref,
                x0=x_domain[0],
                y0=value,
                x1=x_domain[1],
                y1=value
            ), hline_shape_kwargs))

        def _get_arg_names(method):
            sig = signature(method)
            arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
            return arg_names

        def _extract_method_kwargs(method, kwargs):
            arg_names = _get_arg_names(method)
            method_kwargs = {}
            for name in arg_names:
                if name in kwargs:
                    method_kwargs[name] = kwargs.pop(name)
            return method_kwargs

        # Show subplots
        for i, name in enumerate(subplots):
            row, col = row_col_tuples[i]
            xref = &#39;x&#39; if i == 0 else &#39;x&#39; + str(i + 1)
            yref = &#39;y&#39; if i == 0 else &#39;y&#39; + str(i + 1)
            xaxis = &#39;xaxis&#39; if i == 0 else &#39;xaxis&#39; + str(i + 1)
            yaxis = &#39;yaxis&#39; if i == 0 else &#39;yaxis&#39; + str(i + 1)
            x_domain = fig.layout[xaxis][&#39;domain&#39;]
            y_domain = fig.layout[yaxis][&#39;domain&#39;]

            if isinstance(name, tuple):
                _name, settings = name
                can_plot_groups = settings.get(&#39;can_plot_groups&#39;, True)
                if self_col.wrapper.grouper.is_grouped() and not can_plot_groups:
                    raise TypeError(f&#34;Group is not supported by custom subplot with name &#39;{_name}&#39;&#34;)
                plot_func = settings.get(&#39;plot_func&#39;, None)

                if plot_func is not None:
                    arg_names = _get_arg_names(plot_func)
                    custom_kwargs = dict()
                    if &#39;add_trace_kwargs&#39; in arg_names:
                        custom_kwargs[&#39;add_trace_kwargs&#39;] = dict(row=row, col=col)
                    if &#39;xref&#39; in arg_names:
                        custom_kwargs[&#39;xref&#39;] = xref
                    if &#39;yref&#39; in arg_names:
                        custom_kwargs[&#39;yref&#39;] = yref
                    if &#39;xaxis&#39; in arg_names:
                        custom_kwargs[&#39;xaxis&#39;] = xaxis
                    if &#39;yaxis&#39; in arg_names:
                        custom_kwargs[&#39;yaxis&#39;] = yaxis
                    if &#39;x_domain&#39; in arg_names:
                        custom_kwargs[&#39;x_domain&#39;] = x_domain
                    if &#39;y_domain&#39; in arg_names:
                        custom_kwargs[&#39;y_domain&#39;] = y_domain
                    custom_kwargs = merge_dicts(custom_kwargs, kwargs.pop(f&#39;{_name}_kwargs&#39;, {}))
                    plot_func(self_col, **custom_kwargs, fig=fig)

                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = settings.get(&#39;title&#39;, None)
                    
            else:
                settings = self.subplot_settings[name]
                can_plot_groups = settings.get(&#39;can_plot_groups&#39;, True)
                if self_col.wrapper.grouper.is_grouped() and not can_plot_groups:
                    raise TypeError(f&#34;Group is not supported by subplot with name &#39;{name}&#39;&#34;)

                if name == &#39;orders&#39;:
                    orders_kwargs = kwargs.pop(&#39;orders_kwargs&#39;, {})
                    method_kwargs = _extract_method_kwargs(self_col.get_orders, orders_kwargs)
                    self_col.get_orders(**method_kwargs).plot(
                        **orders_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Price&#39;
    
                elif name == &#39;trades&#39;:
                    trades_kwargs = kwargs.pop(&#39;trades_kwargs&#39;, {})
                    method_kwargs = _extract_method_kwargs(self_col.get_trades, trades_kwargs)
                    self_col.get_trades(**method_kwargs).plot(
                        **trades_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Price&#39;
    
                elif name == &#39;positions&#39;:
                    positions_kwargs = kwargs.pop(&#39;positions_kwargs&#39;, {})
                    method_kwargs = _extract_method_kwargs(self_col.get_positions, positions_kwargs)
                    self_col.get_positions(**method_kwargs).plot(
                        **positions_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Price&#39;
    
                elif name == &#39;trade_pnl&#39;:
                    trade_pnl_kwargs = merge_dicts(dict(
                        hline_shape_kwargs=hline_shape_kwargs
                    ), kwargs.pop(&#39;trade_pnl_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.get_trades, trade_pnl_kwargs)
                    self_col.get_trades(**method_kwargs).plot_pnl(
                        **trade_pnl_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;PnL&#39;
    
                elif name == &#39;position_pnl&#39;:
                    position_pnl_kwargs = kwargs.pop(&#39;position_pnl_kwargs&#39;, {})
                    method_kwargs = _extract_method_kwargs(self_col.get_positions, position_pnl_kwargs)
                    self_col.get_positions(**method_kwargs).plot_pnl(
                        **position_pnl_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;PnL&#39;
    
                elif name == &#39;cum_returns&#39;:
                    cum_returns_kwargs = merge_dicts(dict(
                        benchmark_rets=self_col.market_returns(),
                        main_kwargs=dict(
                            trace_kwargs=dict(
                                line_color=color_schema[&#39;purple&#39;],
                                name=&#39;Value&#39;
                            )
                        ),
                        hline_shape_kwargs=hline_shape_kwargs
                    ), kwargs.pop(&#39;cum_returns_kwargs&#39;, {}))
                    active_returns = cum_returns_kwargs.pop(&#39;active_returns&#39;, False)
                    in_sim_order = cum_returns_kwargs.pop(&#39;in_sim_order&#39;, False)
                    if active_returns:
                        returns = self_col.active_returns()
                    else:
                        returns = self_col.returns(in_sim_order=in_sim_order)
                    returns.vbt.returns.plot_cum_returns(
                        **cum_returns_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Cumulative Returns&#39;
    
                elif name == &#39;drawdowns&#39;:
                    drawdowns_kwargs = merge_dicts(dict(
                        ts_trace_kwargs=dict(
                            line_color=color_schema[&#39;purple&#39;],
                            name=&#39;Value&#39;
                        )
                    ), kwargs.pop(&#39;drawdowns_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.get_drawdowns, drawdowns_kwargs)
                    self_col.get_drawdowns(**method_kwargs).plot(
                        **drawdowns_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Value&#39;
    
                elif name == &#39;underwater&#39;:
                    underwater_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;red&#39;],
                            fillcolor=adjust_opacity(color_schema[&#39;red&#39;], 0.3),
                            fill=&#39;tozeroy&#39;,
                            name=&#39;Drawdown&#39;
                        )
                    ), kwargs.pop(&#39;underwater_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.drawdown, underwater_kwargs)
                    self_col.drawdown(**method_kwargs).vbt.plot(
                        **underwater_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(0, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Drawdown&#39;
                    fig.layout[yaxis][&#39;tickformat&#39;] = &#39;%&#39;
    
                elif name == &#39;share_flow&#39;:
                    share_flow_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;brown&#39;],
                            name=&#39;Shares&#39;
                        )
                    ), kwargs.pop(&#39;share_flow_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.share_flow, share_flow_kwargs)
                    self_col.share_flow(**method_kwargs).vbt.plot(
                        **share_flow_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(0, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Share Flow&#39;
    
                elif name == &#39;cash_flow&#39;:
                    cash_flow_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;green&#39;],
                            name=&#39;Cash&#39;
                        )
                    ), kwargs.pop(&#39;cash_flow_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.cash_flow, cash_flow_kwargs)
                    self_col.cash_flow(**method_kwargs).vbt.plot(
                        **cash_flow_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(0, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Cash Flow&#39;
    
                elif name == &#39;shares&#39;:
                    shares_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;brown&#39;],
                            name=&#39;Shares&#39;
                        ),
                        pos_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;brown&#39;], 0.3)
                        ),
                        neg_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;orange&#39;], 0.3)
                        ),
                        other_trace_kwargs=&#39;hidden&#39;
                    ), kwargs.pop(&#39;shares_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.shares, shares_kwargs)
                    self_col.shares(**method_kwargs).vbt.plot_against(
                        0, **shares_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(0, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Shares&#39;
    
                elif name == &#39;cash&#39;:
                    cash_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;green&#39;],
                            name=&#39;Cash&#39;
                        ),
                        pos_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;green&#39;], 0.3)
                        ),
                        neg_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;red&#39;], 0.3)
                        ),
                        other_trace_kwargs=&#39;hidden&#39;
                    ), kwargs.pop(&#39;cash_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.cash, cash_kwargs)
                    self_col.cash(**method_kwargs).vbt.plot_against(
                        0, **cash_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(self_col.init_cash, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Cash&#39;
    
                elif name == &#39;holding_value&#39;:
                    holding_value_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;cyan&#39;],
                            name=&#39;Holding Value&#39;
                        ),
                        pos_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;cyan&#39;], 0.3)
                        ),
                        neg_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;orange&#39;], 0.3)
                        ),
                        other_trace_kwargs=&#39;hidden&#39;
                    ), kwargs.pop(&#39;holding_value_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.holding_value, holding_value_kwargs)
                    self_col.holding_value(**method_kwargs).vbt.plot_against(
                        0, **holding_value_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(0, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Holding Value&#39;
    
                elif name == &#39;value&#39;:
                    value_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;purple&#39;],
                            name=&#39;Value&#39;
                        ),
                        other_trace_kwargs=&#39;hidden&#39;
                    ), kwargs.pop(&#39;value_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.value, value_kwargs)
                    self_col.value(**method_kwargs).vbt.plot_against(
                        self_col.init_cash, **value_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(self_col.init_cash, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Value&#39;
    
                elif name == &#39;gross_exposure&#39;:
                    gross_exposure_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;pink&#39;],
                            name=&#39;Exposure&#39;
                        ),
                        pos_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;orange&#39;], 0.3)
                        ),
                        neg_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;pink&#39;], 0.3)
                        ),
                        other_trace_kwargs=&#39;hidden&#39;
                    ), kwargs.pop(&#39;gross_exposure_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.gross_exposure, gross_exposure_kwargs)
                    self_col.gross_exposure(**method_kwargs).vbt.plot_against(
                        1, **gross_exposure_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(1, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Gross Exposure&#39;
    
                elif name == &#39;net_exposure&#39;:
                    net_exposure_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;pink&#39;],
                            name=&#39;Exposure&#39;
                        ),
                        pos_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;pink&#39;], 0.3)
                        ),
                        neg_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;orange&#39;], 0.3)
                        ),
                        other_trace_kwargs=&#39;hidden&#39;
                    ), kwargs.pop(&#39;net_exposure_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.net_exposure, net_exposure_kwargs)
                    self_col.net_exposure(**method_kwargs).vbt.plot_against(
                        0, **net_exposure_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(0, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Net Exposure&#39;

        # Remove duplicate legend labels
        found_ids = dict()
        unique_idx = 0
        for trace in fig.data:
            if &#39;name&#39; in trace:
                name = trace[&#39;name&#39;]
            else:
                name = None
            if &#39;marker&#39; in trace:
                marker = trace[&#39;marker&#39;]
            else:
                marker = {}
            if &#39;symbol&#39; in marker:
                marker_symbol = marker[&#39;symbol&#39;]
            else:
                marker_symbol = None
            if &#39;color&#39; in marker:
                marker_color = marker[&#39;color&#39;]
            else:
                marker_color = None
            if &#39;line&#39; in trace:
                line = trace[&#39;line&#39;]
            else:
                line = {}
            if &#39;dash&#39; in line:
                line_dash = line[&#39;dash&#39;]
            else:
                line_dash = None
            if &#39;color&#39; in line:
                line_color = line[&#39;color&#39;]
            else:
                line_color = None

            id = (name, marker_symbol, marker_color, line_dash, line_color)
            if id in found_ids:
                if hide_id_labels:
                    trace[&#39;showlegend&#39;] = False
                if group_id_labels:
                    trace[&#39;legendgroup&#39;] = found_ids[id]
            else:
                if group_id_labels:
                    trace[&#39;legendgroup&#39;] = unique_idx
                found_ids[id] = unique_idx
                unique_idx += 1

        # Remove all except the last title if sharing the same axis
        if shared_xaxes:
            i = 0
            for row in range(rows):
                for col in range(cols):
                    if specs[row][col] is not None:
                        xaxis = &#39;xaxis&#39; if i == 0 else &#39;xaxis&#39; + str(i + 1)
                        if row &lt; rows - 1:
                            fig.layout[xaxis][&#39;title&#39;] = None
                        i += 1
        if shared_yaxes:
            i = 0
            for row in range(rows):
                for col in range(cols):
                    if specs[row][col] is not None:
                        yaxis = &#39;yaxis&#39; if i == 0 else &#39;yaxis&#39; + str(i + 1)
                        if col &gt; 0:
                            fig.layout[yaxis][&#39;title&#39;] = None
                        i += 1

        fig.update_layout(kwargs)
        return fig</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.portfolio.base.add_returns_methods"><code class="name flex">
<span>def <span class="ident fname">add_returns_methods</span></span>(<span>func_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Class decorator to add <code><a title="vectorbt.returns.accessors.ReturnsAccessor" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor">ReturnsAccessor</a></code> methods to <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_returns_methods(func_names):
    &#34;&#34;&#34;Class decorator to add `vectorbt.returns.accessors.ReturnsAccessor` methods to `Portfolio`.&#34;&#34;&#34;

    def wrapper(cls):
        for func_name in func_names:
            if isinstance(func_name, tuple):
                ret_func_name = func_name[0]
            else:
                ret_func_name = func_name

            def returns_method(
                    self,
                    *args,
                    group_by=None,
                    year_freq=None,
                    ret_func_name=ret_func_name,
                    active_returns=False,
                    in_sim_order=False,
                    reuse_returns=None,
                    **kwargs):
                if reuse_returns is not None:
                    returns = reuse_returns
                else:
                    if active_returns:
                        returns = self.active_returns(group_by=group_by)
                    else:
                        returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
                returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
                # Select only those arguments in kwargs that are also in the method&#39;s signature
                # This is done for Portfolio.stats which passes the same kwargs to multiple methods
                method = getattr(returns_acc, ret_func_name)
                sig = signature(method)
                arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
                new_kwargs = {}
                for arg_name in arg_names:
                    if arg_name in kwargs:
                        new_kwargs[arg_name] = kwargs[arg_name]
                return method(*args, **new_kwargs)

            if isinstance(func_name, tuple):
                func_name = func_name[1]
            returns_method.__name__ = func_name
            returns_method.__qualname__ = f&#34;Portfolio.{func_name}&#34;
            returns_method.__doc__ = f&#34;See `vectorbt.returns.accessors.ReturnsAccessor.{ret_func_name}`.&#34;
            setattr(cls, func_name, cached_method(returns_method))
        return cls

    return wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio"><code class="flex name class">
<span>class <span class="ident parent-fname">Portfolio</span></span>
<span>(</span><span>wrapper, close, order_records, log_records, init_cash, cash_sharing, call_seq, incl_unrealized=None, use_filled_close=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for modeling portfolio and measuring its performance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrapper</code></strong> :&ensp;<code>ArrayWrapper</code></dt>
<dd>
<p>Array wrapper.</p>
<p>See <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</p>
</dd>
<dt><strong><code>close</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Reference price, such as close.</dd>
<dt><strong><code>order_records</code></strong> :&ensp;<code>array_like</code></dt>
<dd>A structured NumPy array of order records.</dd>
<dt><strong><code>log_records</code></strong> :&ensp;<code>array_like</code></dt>
<dd>A structured NumPy array of log records.</dd>
<dt><strong><code>init_cash</code></strong> :&ensp;<code>InitCashMode, float</code> or <code>array_like</code> of <code>float</code></dt>
<dd>Initial capital.</dd>
<dt><strong><code>cash_sharing</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to share cash within the same group.</dd>
<dt><strong><code>call_seq</code></strong> :&ensp;<code>array_like</code> of <code>int</code></dt>
<dd>Sequence of calls per row and group.</dd>
<dt><strong><code>incl_unrealized</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to include unrealized P&amp;L in statistics.</dd>
<dt><strong><code>use_filled_close</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to forward-backward fill NaN values in <code>close</code>.</p>
<p>Doesn't affect simulation and only used for total profit and market value.</p>
<p>See <code><a title="vectorbt.portfolio.base.Portfolio.fill_close" href="#vectorbt.portfolio.base.Portfolio.fill_close">Portfolio.fill_close()</a></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use class methods with <code>from_</code> prefix to build a portfolio.
The <code>__init__</code> method is reserved for indexing purposes.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is meant to be immutable. To change any attribute, use <code><a title="vectorbt.portfolio.base.Portfolio.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">Configured.copy()</a></code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Portfolio(Wrapping):
    &#34;&#34;&#34;Class for modeling portfolio and measuring its performance.

    Args:
        wrapper (ArrayWrapper): Array wrapper.

            See `vectorbt.base.array_wrapper.ArrayWrapper`.
        close (array_like): Reference price, such as close.
        order_records (array_like): A structured NumPy array of order records.
        log_records (array_like): A structured NumPy array of log records.
        init_cash (InitCashMode, float or array_like of float): Initial capital.
        cash_sharing (bool): Whether to share cash within the same group.
        call_seq (array_like of int): Sequence of calls per row and group.
        incl_unrealized (bool): Whether to include unrealized P&amp;L in statistics.
        use_filled_close (bool): Whether to forward-backward fill NaN values in `close`.

            Doesn&#39;t affect simulation and only used for total profit and market value.

            See `Portfolio.fill_close`.

    !!! note
        Use class methods with `from_` prefix to build a portfolio.
        The `__init__` method is reserved for indexing purposes.

    !!! note
        This class is meant to be immutable. To change any attribute, use `Portfolio.copy`.&#34;&#34;&#34;

    def __init__(self, wrapper, close, order_records, log_records, init_cash,
                 cash_sharing, call_seq, incl_unrealized=None, use_filled_close=None):
        Wrapping.__init__(
            self,
            wrapper,
            close=close,
            order_records=order_records,
            log_records=log_records,
            init_cash=init_cash,
            cash_sharing=cash_sharing,
            call_seq=call_seq,
            incl_unrealized=incl_unrealized,
            use_filled_close=use_filled_close
        )
        # Get defaults
        from vectorbt import settings

        if incl_unrealized is None:
            incl_unrealized = settings.portfolio[&#39;incl_unrealized&#39;]
        if use_filled_close is None:
            use_filled_close = settings.portfolio[&#39;use_filled_close&#39;]

        # Store passed arguments
        self._close = broadcast_to(close, wrapper.dummy(group_by=False))
        self._order_records = order_records
        self._log_records = log_records
        self._init_cash = init_cash
        self._cash_sharing = cash_sharing
        self._call_seq = call_seq
        self._incl_unrealized = incl_unrealized
        self._use_filled_close = use_filled_close

    def _indexing_func(self, pd_indexing_func):
        &#34;&#34;&#34;Perform indexing on `Portfolio`.&#34;&#34;&#34;
        new_wrapper, _, group_idxs, col_idxs = \
            self.wrapper._indexing_func_meta(pd_indexing_func, column_only_select=True)
        new_close = new_wrapper.wrap(to_2d(self.close, raw=True)[:, col_idxs], group_by=False)
        new_order_records = self.orders._col_idxs_records(col_idxs)
        new_log_records = self.logs._col_idxs_records(col_idxs)
        if isinstance(self._init_cash, int):
            new_init_cash = self._init_cash
        else:
            new_init_cash = to_1d(self._init_cash, raw=True)[group_idxs if self.cash_sharing else col_idxs]
        new_call_seq = self.call_seq.values[:, col_idxs]

        return self.copy(
            wrapper=new_wrapper,
            close=new_close,
            order_records=new_order_records,
            log_records=new_log_records,
            init_cash=new_init_cash,
            call_seq=new_call_seq
        )

    # ############# Class methods ############# #

    @classmethod
    def from_holding(cls, close, **kwargs):
        &#34;&#34;&#34;Simulate portfolio from holding.

        Based on `Portfolio.from_signals`.&#34;&#34;&#34;
        return cls.from_signals(close, True, False, accumulate=False, **kwargs)

    @classmethod
    def from_random(cls, close, n=None, prob=None, entry_prob=None, exit_prob=None,
                    param_product=False, seed=None, **kwargs):
        &#34;&#34;&#34;Simulate portfolio from random entry and exit signals.

        Generates signals based either on the number of signals `n` or the probability
        of encountering a signal `prob`.

        If `n` is set, see `vectorbt.signals.basic.RAND`.
        If `prob` is set, see `vectorbt.signals.basic.RPROB`.

        Based on `Portfolio.from_signals`.&#34;&#34;&#34;
        from vectorbt import settings

        if entry_prob is None:
            entry_prob = prob
        if exit_prob is None:
            exit_prob = prob
        if seed is None:
            seed = settings.portfolio[&#39;seed&#39;]

        if n is not None and (entry_prob is not None or exit_prob is not None):
            raise ValueError(&#34;Either n or entry_prob and exit_prob should be set&#34;)
        if n is not None:
            rand = RAND.run(
                n=n,
                input_shape=close.shape,
                input_index=close.vbt.wrapper.index,
                input_columns=close.vbt.wrapper.columns,
                seed=seed
            )
            entries = rand.entries
            exits = rand.exits
        elif entry_prob is not None and exit_prob is not None:
            rprob = RPROB.run(
                entry_prob=entry_prob,
                exit_prob=exit_prob,
                param_product=param_product,
                input_shape=close.shape,
                input_index=close.vbt.wrapper.index,
                input_columns=close.vbt.wrapper.columns,
                seed=seed
            )
            entries = rprob.entries
            exits = rprob.exits
        else:
            raise ValueError(&#34;At least n or entry_prob and exit_prob should be set&#34;)

        return cls.from_signals(close, entries, exits, seed=seed, **kwargs)

    @classmethod
    def from_signals(cls, close, entries, exits, size=None, size_type=None, direction=None, price=None,
                     fees=None, fixed_fees=None, slippage=None, min_size=None, max_size=None,
                     reject_prob=None, allow_partial=None, raise_reject=None, accumulate=None, log=None,
                     conflict_mode=None, close_first=None, val_price=None, init_cash=None, cash_sharing=None,
                     call_seq=None, max_orders=None, max_logs=None, seed=None, group_by=None,
                     broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs):
        &#34;&#34;&#34;Simulate portfolio from entry and exit signals.

        Starting with initial cash `init_cash`, for each signal in `entries`, enters a long/short position
        by buying/selling `size` of shares. For each signal in `exits`, closes the position by
        selling/buying shares. Depending upon accumulation, each entry signal may increase
        the position and each exit signal may decrease the position. When both entry and exit signals
        are present, ignores them by default. When grouping is enabled with `group_by`, will compute
        the performance of the entire group. When `cash_sharing` is enabled, will share the cash among
        all columns in the group.

        Args:
            close (array_like): Reference price, such as close.
                Will broadcast.

                Will be used for calculating unrealized P&amp;L and portfolio value.
            entries (array_like of bool): Boolean array of entry signals.
                Will broadcast.

                Becomes a long signal if `direction` is `all` or `longonly`, otherwise short.
            exits (array_like of bool): Boolean array of exit signals.
                Will broadcast.

                Becomes a short signal if `direction` is `all` or `longonly`, otherwise long.
            size (float or array_like): Size to order.
                Will broadcast.

                * Set to any number to buy/sell some fixed amount of shares.
                    Longs are limited by cash in the account, while shorts are unlimited.
                * Set to `np.inf` to buy shares for all cash, or `-np.inf` to sell shares for
                    initial margin of 100%. If `direction` is not `all`, `-np.inf` will close the position.
                * Set to `np.nan` or 0 to skip.

                !!! note
                    Sign will be ignored.
            size_type (SizeType or array_like): See `vectorbt.portfolio.enums.SizeType`.
                Will broadcast.

                Only `SizeType.Shares` and `SizeType.Percent` are supported.
                Other modes such as target percentage are not compatible with signals since
                their logic may contradict the direction of the signal.

                !!! note
                    `SizeType.Percent` does not support position reversal. Switch to a single
                    direction or use `close_first`.

                See warning on `size_type` in `Portfolio.from_orders`.
            direction (Direction or array_like): See `vectorbt.portfolio.enums.Direction`.
                Will broadcast.
            price (array_like of float): Order price.
                Defaults to `close`. Will broadcast.
            fees (float or array_like): Fees in percentage of the order value.
                Will broadcast. Note that 0.01 = 1%.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order.
                Will broadcast.
            slippage (float or array_like): Slippage in percentage of price.
                Will broadcast. Note that 0.01 = 1%.
            min_size (float or array_like): Minimum size for an order to be accepted.
                Will broadcast.
            max_size (float or array_like): Maximum size for an order.
                Will broadcast.

                Will be partially filled if exceeded. You might not be able to properly close
                the position if accumulation is enabled and `max_size` is too low.
            reject_prob (float or array_like): Order rejection probability.
                Will broadcast.
            allow_partial (bool or array_like): Whether to allow partial fills.
                Will broadcast.

                Does not apply when size is `np.inf`.
            raise_reject (bool or array_like): Whether to raise an exception if order gets rejected.
                Will broadcast.
            log (bool or array_like): Whether to log orders.
                Will broadcast.
            accumulate (bool or array_like): Whether to accumulate signals.
                Will broadcast.

                Behaves similarly to `Portfolio.from_orders`.
            conflict_mode (ConflictMode or array_like): See `vectorbt.portfolio.enums.ConflictMode`.
                Will broadcast.
            close_first (bool or array_like): Whether to close the position first before reversal.
                Will broadcast.

                Otherwise reverses the position with a single order and within the same tick.
                Takes only effect under `Direction.All`. Requires a second signal to enter
                the opposite position. This allows to define parameters such as `fixed_fees` for long
                and short positions separately.
            val_price (array_like of float): Asset valuation price.
                Defaults to `price` if set, otherwise to previous `close`.

                See `val_price` in `Portfolio.from_orders`.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                See `init_cash` in `Portfolio.from_order_func`.
            cash_sharing (bool): Whether to share cash within the same group.

                See `cash_sharing` in `Portfolio.from_orders`.
            call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

                See `call_seq` in `Portfolio.from_orders`.
            max_orders (int): Size of the order records array.
                Defaults to the number of elements in the broadcasted shape.

                Set to a lower number if you run out of memory.
            max_logs (int): Size of the log records array.
                Defaults to the number of elements in the broadcasted shape if any of the `log` is True,
                otherwise to 1.

                Set to a lower number if you run out of memory.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            freq (any): Index frequency in case `close.index` is not datetime-like.
            **kwargs: Keyword arguments passed to the `__init__` method.

        All broadcastable arguments will be broadcast using `vectorbt.base.reshape_fns.broadcast`
        but keep original shape to utilize flexible indexing and to save memory.

        For defaults, see `vectorbt.settings.portfolio`.

        !!! hint
            If you generated signals using close price, don&#39;t forget to shift your signals by one tick
            forward, for example, with `signals.vbt.fshift(1)`. In general, make sure to use a price
            that comes after the signal.

        Also see notes and hints for `Portfolio.from_orders`.

        ## Example

        Some of the ways of how signals are interpreted:

        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; entries = pd.Series([True, True, True, False, False])
        &gt;&gt;&gt; exits = pd.Series([False, False, True, True, True])

        &gt;&gt;&gt; # Entry opens long, exit closes long
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;longonly&#39;)
        &gt;&gt;&gt; portfolio.share_flow()
        0    1.0
        1    0.0
        2    0.0
        3   -1.0
        4    0.0
        dtype: float64

        &gt;&gt;&gt; # Entry opens short, exit closes short
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;shortonly&#39;)
        &gt;&gt;&gt; portfolio.share_flow()
        0   -1.0
        1    0.0
        2    0.0
        3    1.0
        4    0.0
        dtype: float64

        &gt;&gt;&gt; # Entry opens long and closes short, exit closes long and opens short
        &gt;&gt;&gt; # Reversal within one tick
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;)
        &gt;&gt;&gt; portfolio.share_flow()
        0    1.0
        1    0.0
        2    0.0
        3   -2.0
        4    0.0
        dtype: float64

        &gt;&gt;&gt; # Reversal within two ticks
        &gt;&gt;&gt; # First signal closes position, second signal opens the opposite one
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;,
        ...     close_first=True)
        &gt;&gt;&gt; portfolio.share_flow()
        0    1.0
        1    0.0
        2    0.0
        3   -1.0
        4   -1.0
        dtype: float64

        &gt;&gt;&gt; # If entry and exit, chooses exit
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;,
        ...     close_first=True, conflict_mode=&#39;exit&#39;)
        &gt;&gt;&gt; portfolio.share_flow()
        0    1.0
        1    0.0
        2   -1.0
        3   -1.0
        4    0.0
        dtype: float64

        &gt;&gt;&gt; # Entry means long order, exit means short order
        &gt;&gt;&gt; # Acts similar to `from_orders`
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;,
        ...     accumulate=True)
        &gt;&gt;&gt; portfolio.share_flow()
        0    1.0
        1    1.0
        2    0.0
        3   -1.0
        4   -1.0
        dtype: float64

        &gt;&gt;&gt; # Testing multiple parameters (via broadcasting)
        &gt;&gt;&gt; from vectorbt.portfolio.enums import Direction

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     close, entries, exits, direction=[list(Direction)],
        ...     broadcast_kwargs=dict(columns_from=Direction._fields))
        &gt;&gt;&gt; portfolio.share_flow()
            Long  Short    All
        0  100.0 -100.0  100.0
        1    0.0    0.0    0.0
        2    0.0    0.0    0.0
        3 -100.0   50.0 -200.0
        4    0.0    0.0    0.0
        ```
        &#34;&#34;&#34;
        # Get defaults
        from vectorbt import settings

        if size is None:
            size = settings.portfolio[&#39;size&#39;]
        if size_type is None:
            size_type = settings.portfolio[&#39;signal_size_type&#39;]
        size_type = convert_str_enum_value(SizeType, size_type)
        if direction is None:
            direction = settings.portfolio[&#39;signal_direction&#39;]
        direction = convert_str_enum_value(Direction, direction)
        if price is None:
            price = close
        if fees is None:
            fees = settings.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = settings.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = settings.portfolio[&#39;slippage&#39;]
        if min_size is None:
            min_size = settings.portfolio[&#39;min_size&#39;]
        if max_size is None:
            max_size = settings.portfolio[&#39;max_size&#39;]
        if reject_prob is None:
            reject_prob = settings.portfolio[&#39;reject_prob&#39;]
        if allow_partial is None:
            allow_partial = settings.portfolio[&#39;allow_partial&#39;]
        if raise_reject is None:
            raise_reject = settings.portfolio[&#39;raise_reject&#39;]
        if log is None:
            log = settings.portfolio[&#39;log&#39;]
        if accumulate is None:
            accumulate = settings.portfolio[&#39;accumulate&#39;]
        if conflict_mode is None:
            conflict_mode = settings.portfolio[&#39;conflict_mode&#39;]
        conflict_mode = convert_str_enum_value(ConflictMode, conflict_mode)
        if close_first is None:
            close_first = settings.portfolio[&#39;close_first&#39;]
        if val_price is None:
            if price is None:
                if checks.is_pandas(close):
                    val_price = close.vbt.fshift(1)
                else:
                    val_price = np.require(close, dtype=np.float_)
                    val_price = np.roll(val_price, 1, axis=0)
                    val_price[0] = np.nan
            else:
                val_price = price
        if init_cash is None:
            init_cash = settings.portfolio[&#39;init_cash&#39;]
        init_cash = convert_str_enum_value(InitCashMode, init_cash)
        if isinstance(init_cash, int) and init_cash in InitCashMode:
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = settings.portfolio[&#39;cash_sharing&#39;]
        if call_seq is None:
            call_seq = settings.portfolio[&#39;call_seq&#39;]
        call_seq = convert_str_enum_value(CallSeqType, call_seq)
        auto_call_seq = False
        if isinstance(call_seq, int):
            if call_seq == CallSeqType.Auto:
                call_seq = CallSeqType.Default
                auto_call_seq = True
        if seed is None:
            seed = settings.portfolio[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = settings.portfolio[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Broadcast inputs
        # Only close is broadcast, others can remain unchanged thanks to flexible indexing
        broadcastable_args = (
            close,
            entries,
            exits,
            size,
            size_type,
            direction,
            price,
            fees,
            fixed_fees,
            slippage,
            min_size,
            max_size,
            reject_prob,
            allow_partial,
            raise_reject,
            accumulate,
            log,
            conflict_mode,
            close_first,
            val_price
        )
        keep_raw = [False] + [True] * (len(broadcastable_args) - 1)
        broadcast_kwargs = merge_dicts(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
        broadcasted_args = broadcast(*broadcastable_args, **broadcast_kwargs, keep_raw=keep_raw)
        close = broadcasted_args[0]
        if not checks.is_pandas(close):
            close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
        target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
        init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
        group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
        if checks.is_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
        if max_orders is None:
            max_orders = target_shape_2d[0] * target_shape_2d[1]
        if max_logs is None:
            max_logs = target_shape_2d[0] * target_shape_2d[1]
        if not np.any(log):
            max_logs = 1

        # Perform calculation
        order_records, log_records = nb.simulate_from_signals_nb(
            target_shape_2d,
            cs_group_lens,  # group only if cash sharing is enabled to speed up
            init_cash,
            call_seq,
            auto_call_seq,
            *broadcasted_args[1:],
            max_orders,
            max_logs,
            close.ndim == 2
        )

        # Create an instance
        return cls(
            wrapper,
            close,
            order_records,
            log_records,
            init_cash if init_cash_mode is None else init_cash_mode,
            cash_sharing,
            call_seq,
            **kwargs
        )

    @classmethod
    def from_orders(cls, close, size, size_type=None, direction=None, price=None, fees=None,
                    fixed_fees=None, slippage=None, min_size=None, max_size=None, reject_prob=None,
                    allow_partial=None, raise_reject=None, log=None, val_price=None, init_cash=None,
                    cash_sharing=None, call_seq=None, max_orders=None, max_logs=None, seed=None,
                    group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs):
        &#34;&#34;&#34;Simulate portfolio from orders.

        Starting with initial cash `init_cash`, orders the number of shares specified in `size`
        for `price`.

        Args:
            close (array_like): Reference price, such as close.
                Will broadcast.

                Will be used for calculating unrealized P&amp;L and portfolio value.
            size (float or array_like): Size to order.
                Will broadcast.

                Behavior depends upon `size_type` and `direction`. For `SizeType.Shares`:

                * Set to any number to buy/sell some fixed amount of shares.
                    Longs are limited by cash in the account, while shorts are unlimited.
                * Set to `np.inf` to buy shares for all cash, or `-np.inf` to sell shares for
                    initial margin of 100%. If `direction` is not `all`, `-np.inf` will close the position.
                * Set to `np.nan` or 0 to skip.

                For any target size:

                * Set to any number to buy/sell amount of shares relative to current holdings or value.
                * Set to 0 to close the current position.
                * Set to `np.nan` to skip.
            size_type (SizeType or array_like): See `vectorbt.portfolio.enums.SizeType`.
                Will broadcast.

                !!! note
                    `SizeType.Percent` does not support position reversal. Switch to a single direction.

                !!! warning
                    Be cautious using `SizeType.Percent` with `call_seq` set to &#39;auto&#39;.
                    To execute sell orders before buy orders, the value of each order in the group
                    needs to be approximated in advance. But since `SizeType.Percent` depends
                    upon cash balance, which cannot be calculated in advance, the latest cash balance
                    is used. This can yield wrong call sequence for buy orders.
            direction (Direction or array_like): See `vectorbt.portfolio.enums.Direction`.
                Will broadcast.
            price (array_like of float): Order price.
                Defaults to `close`. Will broadcast.
            fees (float or array_like): Fees in percentage of the order value.
                Will broadcast. Note that 0.01 = 1%.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order.
                Will broadcast.
            slippage (float or array_like): Slippage in percentage of price.
                Will broadcast. Note that 0.01 = 1%.
            min_size (float or array_like): Minimum size for an order to be accepted.
                Will broadcast.
            max_size (float or array_like): Maximum size for an order.
                Will broadcast.

                Will be partially filled if exceeded.
            reject_prob (float or array_like): Order rejection probability.
                Will broadcast.
            allow_partial (bool or array_like): Whether to allow partial fills.
                Will broadcast.

                Does not apply when size is `np.inf`.
            raise_reject (bool or array_like): Whether to raise an exception if order gets rejected.
                Will broadcast.
            log (bool or array_like): Whether to log orders.
                Will broadcast.
            val_price (array_like of float): Asset valuation price.
                Defaults to `price`. Will broadcast.

                Used at the time of decision making to calculate value of each asset in the group,
                for example, to convert target value into target shares.

                !!! note
                    Make sure to use timestamp for `val_price` that comes before timestamps of
                    all orders in the group with cash sharing (previous `close` for example),
                    otherwise you&#39;re cheating yourself.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                See `init_cash` in `Portfolio.from_order_func`.
            cash_sharing (bool): Whether to share cash within the same group.

                !!! warning
                    Introduces cross-asset dependencies.

                    This method presumes that in a group of assets that share the same capital all
                    orders will be executed within the same tick and retain their price regardless
                    of their position in the queue, even though they depend upon each other and thus
                    cannot be executed in parallel.
            call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

                Each value in this sequence should indicate the position of column in the group to
                call next. Processing of `call_seq` goes always from left to right.
                For example, `[2, 0, 1]` would first call column &#39;c&#39;, then &#39;a&#39;, and finally &#39;b&#39;.

                * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
                * Set to array to specify custom sequence. Will not broadcast.

                If `CallSeqType.Auto` selected, rearranges calls dynamically based on order value.
                Calculates value of all orders per row and group, and sorts them by this value.
                Sell orders will be executed first to release funds for buy orders.

                !!! warning
                    `CallSeqType.Auto` should be used with caution:

                    * It not only presumes that order prices are known beforehand, but also that
                        orders can be executed in arbitrary order and still retain their price.
                        In reality, this is hardly the case: after processing one asset, some time
                        has passed and the price for other assets might have already changed.
                    * Even if you&#39;re able to specify a slippage large enough to compensate for
                        this behavior, slippage itself should depend upon execution order.
                        This method doesn&#39;t let you do that.
                    * If one order is rejected, it still may execute next orders and possibly
                        leave them without required funds.

                    For more control, use `Portfolio.from_order_func`.
            max_orders (int): Size of the order records array.
                Defaults to the number of elements in the broadcasted shape.

                Set to a lower number if you run out of memory.
            max_logs (int): Size of the log records array.
                Defaults to the number of elements in the broadcasted shape if any of the `log` is True,
                otherwise to 1.

                Set to a lower number if you run out of memory.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            freq (any): Index frequency in case `close.index` is not datetime-like.
            **kwargs: Keyword arguments passed to the `__init__` method.

        All broadcastable arguments will be broadcast using `vectorbt.base.reshape_fns.broadcast`
        but keep original shape to utilize flexible indexing and to save memory.

        For defaults, see `vectorbt.settings.portfolio`.

        !!! note
            When `call_seq` is not `CallSeqType.Auto`, at each timestamp, processing of the assets in
            a group goes strictly in order defined in `call_seq`. This order can&#39;t be changed dynamically.

            This has one big implication for this particular method: the last asset in the call stack
            cannot be processed until other assets are processed. This is the reason why rebalancing
            cannot work properly in this setting: one has to specify percentages for all assets beforehand
            and then tweak the processing order to sell to-be-sold assets first in order to release funds
            for to-be-bought assets. This can be automatically done by using `CallSeqType.Auto`.

        !!! hint
            All broadcastable arguments can be set per frame, series, row, column, or element.

        ## Example

        Buy 10 shares each tick:
        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(close, 10)

        &gt;&gt;&gt; portfolio.shares()
        0    10.0
        1    20.0
        2    30.0
        3    40.0
        4    40.0
        dtype: float64
        &gt;&gt;&gt; portfolio.cash()
        0    90.0
        1    70.0
        2    40.0
        3     0.0
        4     0.0
        dtype: float64
        ```

        Reverse each position by first closing it:
        ```python-repl
        &gt;&gt;&gt; size = [1, 0, -1, 0, 1]
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(close, size, size_type=&#39;targetpercent&#39;)

        &gt;&gt;&gt; portfolio.shares()
        0    100.000000
        1      0.000000
        2    -66.666667
        3      0.000000
        4     26.666667
        dtype: float64
        &gt;&gt;&gt; portfolio.cash()
        0      0.000000
        1    200.000000
        2    400.000000
        3    133.333333
        4      0.000000
        dtype: float64
        ```

        Equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb` example:
        It&#39;s more compact but has less control over execution:

        ```python-repl
        &gt;&gt;&gt; import numpy as np

        &gt;&gt;&gt; np.random.seed(42)
        &gt;&gt;&gt; close = pd.DataFrame(np.random.uniform(1, 10, size=(5, 3)))
        &gt;&gt;&gt; size = pd.Series(np.full(5, 1/3))  # each column 33.3%
        &gt;&gt;&gt; size[1::2] = np.nan  # skip every second tick

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
        ...     close,  # acts both as reference and order price here
        ...     size,
        ...     size_type=&#39;targetpercent&#39;,
        ...     call_seq=&#39;auto&#39;,  # first sell then buy
        ...     group_by=True,  # one group
        ...     cash_sharing=True,  # assets share the same cash
        ...     fees=0.001, fixed_fees=1., slippage=0.001  # costs
        ... )

        &gt;&gt;&gt; portfolio.holding_value(group_by=False).vbt.plot()
        ```

        ![](/vectorbt/docs/img/simulate_nb.png)
        &#34;&#34;&#34;
        # Get defaults
        from vectorbt import settings

        if size is None:
            size = settings.portfolio[&#39;size&#39;]
        if size_type is None:
            size_type = settings.portfolio[&#39;size_type&#39;]
        size_type = convert_str_enum_value(SizeType, size_type)
        if direction is None:
            direction = settings.portfolio[&#39;order_direction&#39;]
        direction = convert_str_enum_value(Direction, direction)
        if price is None:
            price = close
        if fees is None:
            fees = settings.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = settings.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = settings.portfolio[&#39;slippage&#39;]
        if min_size is None:
            min_size = settings.portfolio[&#39;min_size&#39;]
        if max_size is None:
            max_size = settings.portfolio[&#39;max_size&#39;]
        if reject_prob is None:
            reject_prob = settings.portfolio[&#39;reject_prob&#39;]
        if allow_partial is None:
            allow_partial = settings.portfolio[&#39;allow_partial&#39;]
        if raise_reject is None:
            raise_reject = settings.portfolio[&#39;raise_reject&#39;]
        if log is None:
            log = settings.portfolio[&#39;log&#39;]
        if val_price is None:
            val_price = price
        if init_cash is None:
            init_cash = settings.portfolio[&#39;init_cash&#39;]
        init_cash = convert_str_enum_value(InitCashMode, init_cash)
        if isinstance(init_cash, int) and init_cash in InitCashMode:
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = settings.portfolio[&#39;cash_sharing&#39;]
        if call_seq is None:
            call_seq = settings.portfolio[&#39;call_seq&#39;]
        call_seq = convert_str_enum_value(CallSeqType, call_seq)
        auto_call_seq = False
        if isinstance(call_seq, int):
            if call_seq == CallSeqType.Auto:
                call_seq = CallSeqType.Default
                auto_call_seq = True
        if seed is None:
            seed = settings.portfolio[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = settings.portfolio[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Broadcast inputs
        # Only close is broadcast, others can remain unchanged thanks to flexible indexing
        broadcastable_args = (
            close,
            size,
            size_type,
            direction,
            price,
            fees,
            fixed_fees,
            slippage,
            min_size,
            max_size,
            reject_prob,
            allow_partial,
            raise_reject,
            log,
            val_price
        )
        keep_raw = [False] + [True] * (len(broadcastable_args) - 1)
        broadcast_kwargs = merge_dicts(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
        broadcasted_args = broadcast(*broadcastable_args, **broadcast_kwargs, keep_raw=keep_raw)
        close = broadcasted_args[0]
        if not checks.is_pandas(close):
            close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
        target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
        init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
        group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
        if checks.is_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
        if max_orders is None:
            max_orders = target_shape_2d[0] * target_shape_2d[1]
        if max_logs is None:
            max_logs = target_shape_2d[0] * target_shape_2d[1]
        if not np.any(log):
            max_logs = 1

        # Perform calculation
        order_records, log_records = nb.simulate_from_orders_nb(
            target_shape_2d,
            cs_group_lens,  # group only if cash sharing is enabled to speed up
            init_cash,
            call_seq,
            auto_call_seq,
            *broadcasted_args[1:],
            max_orders,
            max_logs,
            close.ndim == 2
        )

        # Create an instance
        return cls(
            wrapper,
            close,
            order_records,
            log_records,
            init_cash if init_cash_mode is None else init_cash_mode,
            cash_sharing,
            call_seq,
            **kwargs
        )

    @classmethod
    def from_order_func(cls, close, order_func_nb, *order_args, target_shape=None, keys=None,
                        init_cash=None, cash_sharing=None, call_seq=None, active_mask=None,
                        prep_func_nb=None, prep_args=None, group_prep_func_nb=None, group_prep_args=None,
                        row_prep_func_nb=None, row_prep_args=None, segment_prep_func_nb=None,
                        segment_prep_args=None, row_wise=None, max_orders=None, max_logs=None,
                        seed=None, group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs):
        &#34;&#34;&#34;Build portfolio from a custom order function.

        For details, see `vectorbt.portfolio.nb.simulate_nb`.

        if `row_wise` is True, also see `vectorbt.portfolio.nb.simulate_row_wise_nb`.

        Args:
            close (array_like): Reference price, such as close.
                Will broadcast to `target_shape`.

                Will be used for calculating unrealized P&amp;L and portfolio value.
            order_func_nb (callable): Order generation function.
            *order_args: Arguments passed to `order_func_nb`.
            target_shape (tuple): Target shape to iterate over. Defaults to `close.shape`.
            keys (sequence): Outermost column level.

                Each element should correspond to one iteration over columns in `close`.
                Should be set only if `target_shape` is bigger than `close.shape`.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                By default, will broadcast to the number of columns.
                If cash sharing is enabled, will broadcast to the number of groups.
                See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

                !!! note
                    Mode `InitCashMode.AutoAlign` is applied after the portfolio is initialized
                    to set the same initial cash for all columns/groups. Changing grouping
                    will change the initial cash, so be aware when indexing.
            cash_sharing (bool): Whether to share cash within the same group.

                !!! warning
                    Introduces cross-asset dependencies.
            call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

                * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
                * Set to array to specify custom sequence. Will not broadcast.

                !!! note
                    CallSeqType.Auto should be implemented manually.
                    Use `auto_call_seq_ctx_nb` in `segment_prep_func_nb`.
            active_mask (int or array_like of bool): Mask of whether a particular segment should be executed.

                Supplying an integer will activate every n-th row (just for convenience).
                Supplying a boolean will broadcast to the number of rows and groups.
            prep_func_nb (callable): Simulation preparation function.
            prep_args (tuple): Packed arguments passed to `prep_func_nb`.

                Defaults to `()`.
            group_prep_func_nb (callable): Group preparation function.

                Called only if `row_wise` is False.
            group_prep_args (tuple): Packed arguments passed to `group_prep_func_nb`.

                Defaults to `()`.
            row_prep_func_nb (callable): Row preparation function.

                Called only if `row_wise` is True.
            row_prep_args (tuple): Packed arguments passed to `row_prep_func_nb`.

                Defaults to `()`.
            segment_prep_func_nb (callable): Segment preparation function.
            segment_prep_args (tuple): Packed arguments passed to `segment_prep_func_nb`.

                Defaults to `()`.
            row_wise (bool): Whether to iterate over rows rather than columns/groups.

                See `vectorbt.portfolio.nb.simulate_row_wise_nb`.
            max_orders (int): Size of the order records array.
                Defaults to the number of elements in the broadcasted shape.

                Set to a lower number if you run out of memory.
            max_logs (int): Size of the log records array.
                Defaults to the number of elements in the broadcasted shape.

                Set to a lower number if you run out of memory.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            freq (any): Index frequency in case `close.index` is not datetime-like.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.settings.portfolio`.

        !!! note
            All passed functions should be Numba-compiled.

            Objects passed as arguments to both functions will not broadcast to `target_shape`
            as their purpose is unknown. You should broadcast manually or use flexible indexing.

            Also see notes on `Portfolio.from_orders`.

        !!! note
            In contrast to other methods, the valuation price is previous `close`
            instead of order price, since the price of an order is unknown before call.
            You can still set valuation price explicitly in `segment_prep_func_nb`.

        ## Example

        Buy 10 shares each tick:
        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from numba import njit
        &gt;&gt;&gt; import vectorbt as vbt
        &gt;&gt;&gt; from vectorbt.portfolio.nb import create_order_nb

        &gt;&gt;&gt; @njit
        ... def order_func_nb(oc, size):
        ...     return create_order_nb(size=size, price=oc.close[oc.i, oc.col])

        &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(close, order_func_nb, 10)

        &gt;&gt;&gt; portfolio.shares()
        0    10.0
        1    20.0
        2    30.0
        3    40.0
        4    40.0
        dtype: float64
        &gt;&gt;&gt; portfolio.cash()
        0    90.0
        1    70.0
        2    40.0
        3     0.0
        4     0.0
        dtype: float64
        ```

        Reverse each position by first closing it. Keep state of last position to determine
        which position to open next (just as an example, there are easier ways to do this):
        ```python-repl
        &gt;&gt;&gt; import numpy as np

        &gt;&gt;&gt; @njit
        ... def group_prep_func_nb(gc):
        ...     last_pos_state = np.array([-1])
        ...     return (last_pos_state,)

        &gt;&gt;&gt; @njit
        ... def order_func_nb(oc, last_pos_state):
        ...     if oc.shares_now &gt; 0:
        ...         size = -oc.shares_now  # close long
        ...     elif oc.shares_now &lt; 0:
        ...         size = -oc.shares_now  # close short
        ...     else:
        ...         if last_pos_state[0] == 1:
        ...             size = -np.inf  # open short
        ...             last_pos_state[0] = -1
        ...         else:
        ...             size = np.inf  # open long
        ...             last_pos_state[0] = 1
        ...
        ...     return create_order_nb(size=size, price=oc.close[oc.i, oc.col])

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
        ...     close, order_func_nb, group_prep_func_nb=group_prep_func_nb)

        &gt;&gt;&gt; portfolio.shares()
        0    100.0
        1      0.0
        2   -100.0
        3      0.0
        4     20.0
        dtype: float64
        &gt;&gt;&gt; portfolio.cash()
        0      0.0
        1    200.0
        2    500.0
        3    100.0
        4      0.0
        dtype: float64
        ```

        Equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb` example:
        ```python-repl
        &gt;&gt;&gt; from vectorbt.portfolio.nb import auto_call_seq_ctx_nb
        &gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, Direction

        &gt;&gt;&gt; @njit
        ... def group_prep_func_nb(gc):
        ...     &#39;&#39;&#39;Define empty arrays for each group.&#39;&#39;&#39;
        ...     size = np.empty(gc.group_len, dtype=np.float_)
        ...     size_type = np.empty(gc.group_len, dtype=np.int_)
        ...     direction = np.empty(gc.group_len, dtype=np.int_)
        ...     temp_float_arr = np.empty(gc.group_len, dtype=np.float_)
        ...     return size, size_type, direction, temp_float_arr

        &gt;&gt;&gt; @njit
        ... def segment_prep_func_nb(sc, size, size_type, direction, temp_float_arr):
        ...     &#39;&#39;&#39;Perform rebalancing at each segment.&#39;&#39;&#39;
        ...     for k in range(sc.group_len):
        ...         col = sc.from_col + k
        ...         size[k] = 1 / sc.group_len
        ...         size_type[k] = SizeType.TargetPercent
        ...         direction[k] = Direction.LongOnly
        ...         sc.last_val_price[col] = sc.close[sc.i, col]
        ...     auto_call_seq_ctx_nb(sc, size, size_type, direction, temp_float_arr)
        ...     return size, size_type, direction

        &gt;&gt;&gt; @njit
        ... def order_func_nb(oc, size, size_type, direction, fees, fixed_fees, slippage):
        ...     &#39;&#39;&#39;Place an order.&#39;&#39;&#39;
        ...     col_i = oc.call_seq_now[oc.call_idx]
        ...     return create_order_nb(
        ...         size=size[col_i],
        ...         size_type=size_type[col_i],
        ...         price=oc.close[oc.i, oc.col],
        ...         fees=fees, fixed_fees=fixed_fees, slippage=slippage,
        ...         direction=direction[col_i]
        ...     )

        &gt;&gt;&gt; np.random.seed(42)
        &gt;&gt;&gt; close = np.random.uniform(1, 10, size=(5, 3))
        &gt;&gt;&gt; fees = 0.001
        &gt;&gt;&gt; fixed_fees = 1.
        &gt;&gt;&gt; slippage = 0.001

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
        ...     close,  # acts both as reference and order price here
        ...     order_func_nb, fees, fixed_fees, slippage,  # order_args as *args
        ...     active_mask=2,  # rebalance every second tick
        ...     group_prep_func_nb=group_prep_func_nb,
        ...     segment_prep_func_nb=segment_prep_func_nb,
        ...     cash_sharing=True, group_by=True,  # one group with cash sharing
        ... )

        &gt;&gt;&gt; portfolio.holding_value(group_by=False).vbt.plot()
        ```

        ![](/vectorbt/docs/img/simulate_nb.png)
        &#34;&#34;&#34;
        # Get defaults
        from vectorbt import settings

        if not checks.is_pandas(close):
            if not checks.is_array(close):
                close = np.asarray(close)
            close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
        if target_shape is None:
            target_shape = close.shape
        if init_cash is None:
            init_cash = settings.portfolio[&#39;init_cash&#39;]
        init_cash = convert_str_enum_value(InitCashMode, init_cash)
        if isinstance(init_cash, int) and init_cash in InitCashMode:
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = settings.portfolio[&#39;cash_sharing&#39;]
        if call_seq is None:
            call_seq = settings.portfolio[&#39;call_seq&#39;]
        call_seq = convert_str_enum_value(CallSeqType, call_seq)
        if isinstance(call_seq, int):
            if call_seq == CallSeqType.Auto:
                raise ValueError(&#34;CallSeqType.Auto should be implemented manually. &#34;
                                 &#34;Use auto_call_seq_ctx_nb in segment_prep_func_nb.&#34;)
        if active_mask is None:
            active_mask = True
        if row_wise is None:
            row_wise = settings.portfolio[&#39;row_wise&#39;]
        if seed is None:
            seed = settings.portfolio[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = settings.portfolio[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        require_kwargs = dict(require_kwargs=dict(requirements=&#39;W&#39;))
        broadcast_kwargs = merge_dicts(require_kwargs, broadcast_kwargs)
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Broadcast inputs
        target_shape_2d = (target_shape[0], target_shape[1] if len(target_shape) &gt; 1 else 1)
        if close.shape != target_shape:
            if len(close.vbt.wrapper.columns) &lt;= target_shape_2d[1]:
                if target_shape_2d[1] % len(close.vbt.wrapper.columns) != 0:
                    raise ValueError(&#34;Cannot broadcast close to target_shape&#34;)
                if keys is None:
                    keys = pd.Index(np.arange(target_shape_2d[1]), name=&#39;iteration_idx&#39;)
                tile_times = target_shape_2d[1] // len(close.vbt.wrapper.columns)
                close = close.vbt.tile(tile_times, keys=keys)
        close = broadcast(close, to_shape=target_shape, **broadcast_kwargs)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
        init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
        group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
        if isinstance(active_mask, int):
            _active_mask = np.full((target_shape_2d[0], len(group_lens)), False)
            _active_mask[0::active_mask] = True
            active_mask = _active_mask
        else:
            active_mask = broadcast(
                active_mask,
                to_shape=(target_shape_2d[0], len(group_lens)),
                to_pd=False,
                **require_kwargs
            )
        if checks.is_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
        if max_orders is None:
            max_orders = target_shape_2d[0] * target_shape_2d[1]
        if max_logs is None:
            max_logs = target_shape_2d[0] * target_shape_2d[1]

        # Prepare arguments
        if prep_func_nb is None:
            prep_func_nb = nb.empty_prep_nb
        if prep_args is None:
            prep_args = ()
        if group_prep_func_nb is None:
            group_prep_func_nb = nb.empty_prep_nb
        if group_prep_args is None:
            group_prep_args = ()
        if row_prep_func_nb is None:
            row_prep_func_nb = nb.empty_prep_nb
        if row_prep_args is None:
            row_prep_args = ()
        if segment_prep_func_nb is None:
            segment_prep_func_nb = nb.empty_prep_nb
        if segment_prep_args is None:
            segment_prep_args = ()

        # Perform calculation
        if row_wise:
            order_records, log_records = nb.simulate_row_wise_nb(
                target_shape_2d,
                to_2d(close, raw=True),
                group_lens,
                init_cash,
                cash_sharing,
                call_seq,
                active_mask,
                prep_func_nb,
                prep_args,
                row_prep_func_nb,
                row_prep_args,
                segment_prep_func_nb,
                segment_prep_args,
                order_func_nb,
                order_args,
                max_orders,
                max_logs
            )
        else:
            order_records, log_records = nb.simulate_nb(
                target_shape_2d,
                to_2d(close, raw=True),
                group_lens,
                init_cash,
                cash_sharing,
                call_seq,
                active_mask,
                prep_func_nb,
                prep_args,
                group_prep_func_nb,
                group_prep_args,
                segment_prep_func_nb,
                segment_prep_args,
                order_func_nb,
                order_args,
                max_orders,
                max_logs
            )

        # Create an instance
        return cls(
            wrapper,
            close,
            order_records,
            log_records,
            init_cash if init_cash_mode is None else init_cash_mode,
            cash_sharing,
            call_seq,
            **kwargs
        )

    # ############# Properties ############# #

    @property
    def wrapper(self):
        &#34;&#34;&#34;Array wrapper.&#34;&#34;&#34;
        if self.cash_sharing:
            # Allow only disabling grouping when needed (but not globally, see regroup)
            return self._wrapper.copy(
                allow_enable=False,
                allow_modify=False
            )
        return self._wrapper

    def regroup(self, group_by, **kwargs):
        &#34;&#34;&#34;Regroup this object.

        See `vectorbt.base.array_wrapper.Wrapping.regroup`.&#34;&#34;&#34;
        if self.cash_sharing:
            if self.wrapper.grouper.is_grouping_modified(group_by=group_by):
                raise ValueError(&#34;Cannot modify grouping globally when cash_sharing=True&#34;)
        return Wrapping.regroup(self, group_by, **kwargs)

    @property
    def cash_sharing(self):
        &#34;&#34;&#34;Whether to share cash within the same group.&#34;&#34;&#34;
        return self._cash_sharing

    @property
    def call_seq(self):
        &#34;&#34;&#34;Sequence of calls per row and group.&#34;&#34;&#34;
        return self.wrapper.wrap(self._call_seq, group_by=False)

    @property
    def incl_unrealized(self):
        &#34;&#34;&#34;Whether to include unrealized trade P&amp;L in statistics.&#34;&#34;&#34;
        return self._incl_unrealized

    @property
    def use_filled_close(self):
        &#34;&#34;&#34;Whether to forward-backward fill NaN values in `Portfolio.close`.&#34;&#34;&#34;
        return self._use_filled_close

    # ############# Reference price ############# #

    @property
    def close(self):
        &#34;&#34;&#34;Price per share series.&#34;&#34;&#34;
        return self._close

    @cached_method
    def fill_close(self, ffill=True, bfill=True):
        &#34;&#34;&#34;Fill NaN values of `Portfolio.close`.
        Use `ffill` and `bfill` to fill forwards and backwards respectively.&#34;&#34;&#34;
        close = to_2d(self.close, raw=True)
        if ffill and np.any(np.isnan(close[-1, :])):
            close = generic_nb.ffill_nb(close)
        if bfill and np.any(np.isnan(close[0, :])):
            close = generic_nb.ffill_nb(close[::-1, :])[::-1, :]
        return self.wrapper.wrap(close, group_by=False)

    # ############# Records ############# #

    @property
    def order_records(self):
        &#34;&#34;&#34;A structured NumPy array of order records.&#34;&#34;&#34;
        return self._order_records

    @cached_property
    def orders(self):
        &#34;&#34;&#34;`Portfolio.get_orders` with default arguments.&#34;&#34;&#34;
        return Orders(self.wrapper, self.order_records, self.close)

    def get_orders(self, group_by=None):
        &#34;&#34;&#34;Get order records.

        See `vectorbt.portfolio.orders.Orders`.&#34;&#34;&#34;
        return self.orders.regroup(group_by=group_by)

    @property
    def log_records(self):
        &#34;&#34;&#34;A structured NumPy array of log records.&#34;&#34;&#34;
        return self._log_records

    @cached_property
    def logs(self):
        &#34;&#34;&#34;`Portfolio.get_logs` with default arguments.&#34;&#34;&#34;
        return Logs(self.wrapper, self.log_records)

    def get_logs(self, group_by=None):
        &#34;&#34;&#34;Get log records.

        See `vectorbt.portfolio.logs.Logs`.&#34;&#34;&#34;
        return self.logs.regroup(group_by=group_by)

    @cached_property
    def trades(self):
        &#34;&#34;&#34;`Portfolio.get_trades` with default arguments.&#34;&#34;&#34;
        return Trades.from_orders(self.orders)

    def get_trades(self, group_by=None):
        &#34;&#34;&#34;Get trade records.

        See `vectorbt.portfolio.trades.Trades`.&#34;&#34;&#34;
        return self.trades.regroup(group_by=group_by)

    @cached_property
    def positions(self):
        &#34;&#34;&#34;`Portfolio.get_positions` with default arguments.&#34;&#34;&#34;
        return Positions.from_trades(self.trades)

    def get_positions(self, group_by=None):
        &#34;&#34;&#34;Get position records.

        See `vectorbt.portfolio.trades.Positions`.&#34;&#34;&#34;
        return self.positions.regroup(group_by=group_by)

    @cached_property
    def drawdowns(self):
        &#34;&#34;&#34;`Portfolio.get_drawdowns` with default arguments.&#34;&#34;&#34;
        return self.get_drawdowns()

    @cached_method
    def get_drawdowns(self, **kwargs):
        &#34;&#34;&#34;Get drawdown records from `Portfolio.value`.

        See `vectorbt.generic.drawdowns.Drawdowns`.

        `**kwargs` are passed to `Portfolio.value`.&#34;&#34;&#34;
        return Drawdowns.from_ts(self.value(**kwargs), freq=self.wrapper.freq)

    # ############# Shares ############# #

    @cached_method
    def share_flow(self, direction=&#39;all&#39;):
        &#34;&#34;&#34;Get share flow series per column.&#34;&#34;&#34;
        direction = convert_str_enum_value(Direction, direction)
        share_flow = nb.share_flow_nb(
            self.wrapper.shape_2d,
            self.orders.values,
            self.orders.col_mapper.col_map,
            direction
        )
        return self.wrapper.wrap(share_flow, group_by=False)

    @cached_method
    def shares(self, direction=&#39;all&#39;):
        &#34;&#34;&#34;Get share series per column.&#34;&#34;&#34;
        direction = convert_str_enum_value(Direction, direction)
        share_flow = to_2d(self.share_flow(direction=&#39;all&#39;), raw=True)
        shares = nb.shares_nb(share_flow)
        if direction == Direction.LongOnly:
            shares = np.where(shares &gt; 0, shares, 0.)
        if direction == Direction.ShortOnly:
            shares = np.where(shares &lt; 0, -shares, 0.)
        return self.wrapper.wrap(shares, group_by=False)

    @cached_method
    def pos_mask(self, direction=&#39;all&#39;, group_by=None):
        &#34;&#34;&#34;Get position mask per column/group.&#34;&#34;&#34;
        direction = convert_str_enum_value(Direction, direction)
        shares = to_2d(self.shares(direction=direction), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            pos_mask = to_2d(self.pos_mask(direction=direction, group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            pos_mask = nb.pos_mask_grouped_nb(pos_mask, group_lens)
        else:
            pos_mask = shares != 0
        return self.wrapper.wrap(pos_mask, group_by=group_by)

    @cached_method
    def pos_coverage(self, direction=&#39;all&#39;, group_by=None):
        &#34;&#34;&#34;Get position coverage per column/group.&#34;&#34;&#34;
        direction = convert_str_enum_value(Direction, direction)
        shares = to_2d(self.shares(direction=direction), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            pos_mask = to_2d(self.pos_mask(direction=direction, group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            pos_coverage = nb.pos_coverage_grouped_nb(pos_mask, group_lens)
        else:
            pos_coverage = np.mean(shares != 0, axis=0)
        return self.wrapper.wrap_reduced(pos_coverage, group_by=group_by)

    # ############# Cash ############# #

    @cached_method
    def cash_flow(self, group_by=None, short_cash=True):
        &#34;&#34;&#34;Get cash flow series per column/group.

        When `short_cash` is set to False, cash never goes above the initial level,
        because an operation always costs money.&#34;&#34;&#34;
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            cash_flow = to_2d(self.cash_flow(group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            cash_flow = nb.cash_flow_grouped_nb(cash_flow, group_lens)
        else:
            cash_flow = nb.cash_flow_nb(
                self.wrapper.shape_2d,
                self.orders.values,
                self.orders.col_mapper.col_map,
                short_cash
            )
        return self.wrapper.wrap(cash_flow, group_by=group_by)

    @cached_property
    def init_cash(self):
        &#34;&#34;&#34;`Portfolio.get_init_cash` with default arguments.&#34;&#34;&#34;
        return self.get_init_cash()

    @cached_method
    def get_init_cash(self, group_by=None):
        &#34;&#34;&#34;Initial amount of cash per column/group with default arguments.

        !!! note
            If initial cash is found automatically and no own cash is used throughout simulation
            (for example, when shorting), initial cash will be set to 1 instead of 0 to
            enable smooth calculation of returns.&#34;&#34;&#34;
        if isinstance(self._init_cash, int):
            cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
            cash_min = np.min(np.cumsum(cash_flow, axis=0), axis=0)
            init_cash = np.where(cash_min &lt; 0, np.abs(cash_min), 1.)
            if self._init_cash == InitCashMode.AutoAlign:
                init_cash = np.full(init_cash.shape, np.max(init_cash))
        else:
            init_cash = to_1d(self._init_cash, raw=True)
            if self.wrapper.grouper.is_grouped(group_by=group_by):
                group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
                init_cash = nb.init_cash_grouped_nb(init_cash, group_lens, self.cash_sharing)
            else:
                group_lens = self.wrapper.grouper.get_group_lens()
                init_cash = nb.init_cash_nb(init_cash, group_lens, self.cash_sharing)
        return self.wrapper.wrap_reduced(init_cash, group_by=group_by)

    @cached_method
    def cash(self, group_by=None, in_sim_order=False, short_cash=True):
        &#34;&#34;&#34;Get cash balance series per column/group.&#34;&#34;&#34;
        if in_sim_order and not self.cash_sharing:
            raise ValueError(&#34;Cash sharing must be enabled for in_sim_order=True&#34;)

        cash_flow = to_2d(self.cash_flow(group_by=group_by, short_cash=short_cash), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
            cash = nb.cash_grouped_nb(
                self.wrapper.shape_2d,
                cash_flow,
                group_lens,
                init_cash
            )
        else:
            group_lens = self.wrapper.grouper.get_group_lens()
            if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
                init_cash = to_1d(self.init_cash, raw=True)
                call_seq = to_2d(self.call_seq, raw=True)
                cash = nb.cash_in_sim_order_nb(cash_flow, group_lens, init_cash, call_seq)
            else:
                init_cash = to_1d(self.get_init_cash(group_by=False), raw=True)
                cash = nb.cash_nb(cash_flow, group_lens, init_cash)
        return self.wrapper.wrap(cash, group_by=group_by)

    # ############# Performance ############# #

    @cached_method
    def holding_value(self, direction=&#39;all&#39;, group_by=None):
        &#34;&#34;&#34;Get holding value series per column/group.&#34;&#34;&#34;
        direction = convert_str_enum_value(Direction, direction)
        close = to_2d(self.close, raw=True).copy()
        shares = to_2d(self.shares(direction=direction), raw=True)
        close[shares == 0] = 0.  # for price being NaN
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            holding_value = to_2d(self.holding_value(direction=direction, group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            holding_value = nb.holding_value_grouped_nb(holding_value, group_lens)
        else:
            holding_value = nb.holding_value_nb(close, shares)
        return self.wrapper.wrap(holding_value, group_by=group_by)

    @cached_method
    def gross_exposure(self, direction=&#39;all&#39;, group_by=None):
        &#34;&#34;&#34;Get gross exposure.&#34;&#34;&#34;
        holding_value = to_2d(self.holding_value(group_by=group_by, direction=direction), raw=True)
        cash = to_2d(self.cash(group_by=group_by, short_cash=False), raw=True)
        gross_exposure = nb.gross_exposure_nb(holding_value, cash)
        return self.wrapper.wrap(gross_exposure, group_by=group_by)

    @cached_method
    def net_exposure(self, group_by=None):
        &#34;&#34;&#34;Get net exposure.&#34;&#34;&#34;
        long_exposure = to_2d(self.gross_exposure(direction=&#39;longonly&#39;, group_by=group_by), raw=True)
        short_exposure = to_2d(self.gross_exposure(direction=&#39;shortonly&#39;, group_by=group_by), raw=True)
        net_exposure = long_exposure - short_exposure
        return self.wrapper.wrap(net_exposure, group_by=group_by)

    @cached_method
    def value(self, group_by=None, in_sim_order=False):
        &#34;&#34;&#34;Get portfolio value series per column/group.

        By default, will generate portfolio value for each asset based on cash flows and thus
        independent from other assets, with initial cash and shares being that of the entire group.
        Useful for generating returns and comparing assets within the same group.

        When `group_by` is False and `in_sim_order` is True, returns value generated in
        simulation order (see [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
        This value cannot be used for generating returns as-is. Useful to analyze how value
        evolved throughout simulation.&#34;&#34;&#34;
        cash = to_2d(self.cash(group_by=group_by, in_sim_order=in_sim_order), raw=True)
        holding_value = to_2d(self.holding_value(group_by=group_by), raw=True)
        if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
            group_lens = self.wrapper.grouper.get_group_lens()
            call_seq = to_2d(self.call_seq, raw=True)
            value = nb.value_in_sim_order_nb(cash, holding_value, group_lens, call_seq)
            # price of NaN is already addressed by ungrouped_value_nb
        else:
            value = nb.value_nb(cash, holding_value)
        return self.wrapper.wrap(value, group_by=group_by)

    @cached_method
    def total_profit(self, group_by=None):
        &#34;&#34;&#34;Get total profit per column/group.

        Calculated directly from order records (fast).

        Uses filled close if `Portfolio.use_filled_close` is True.&#34;&#34;&#34;
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            total_profit = to_1d(self.total_profit(group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            total_profit = nb.total_profit_grouped_nb(
                total_profit,
                group_lens
            )
        else:
            if self.use_filled_close:
                close = to_2d(self.fill_close(), raw=True)
            else:
                close = to_2d(self.close, raw=True)
            total_profit = nb.total_profit_nb(
                self.wrapper.shape_2d,
                close,
                self.orders.values,
                self.orders.col_mapper.col_map
            )
        return self.wrapper.wrap_reduced(total_profit, group_by=group_by)

    @cached_method
    def final_value(self, group_by=None):
        &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        total_profit = to_1d(self.total_profit(group_by=group_by), raw=True)
        final_value = nb.final_value_nb(total_profit, init_cash)
        return self.wrapper.wrap_reduced(final_value, group_by=group_by)

    @cached_method
    def total_return(self, group_by=None):
        &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        total_profit = to_1d(self.total_profit(group_by=group_by), raw=True)
        total_return = nb.total_return_nb(total_profit, init_cash)
        return self.wrapper.wrap_reduced(total_return, group_by=group_by)

    @cached_method
    def returns(self, group_by=None, in_sim_order=False):
        &#34;&#34;&#34;Get return series per column/group based on portfolio value.&#34;&#34;&#34;
        value = to_2d(self.value(group_by=group_by, in_sim_order=in_sim_order), raw=True)
        if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
            group_lens = self.wrapper.grouper.get_group_lens()
            init_cash_grouped = to_1d(self.init_cash, raw=True)
            call_seq = to_2d(self.call_seq, raw=True)
            returns = nb.returns_in_sim_order_nb(value, group_lens, init_cash_grouped, call_seq)
        else:
            init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
            returns = nb.returns_nb(value, init_cash)
        return self.wrapper.wrap(returns, group_by=group_by)

    @cached_method
    def active_returns(self, group_by=None):
        &#34;&#34;&#34;Get active return series per column/group.

        This type of returns is based solely on cash flows and holding value rather than portfolio value.
        It ignores passive cash and thus it will return the same numbers irrespective of the amount of
        cash currently available, even `np.inf`. The scale of returns is comparable to that of going
        all in and keeping available cash at zero.&#34;&#34;&#34;
        cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
        holding_value = to_2d(self.holding_value(group_by=group_by), raw=True)
        active_returns = nb.active_returns_nb(cash_flow, holding_value)
        return self.wrapper.wrap(active_returns, group_by=group_by)

    @cached_method
    def market_value(self, group_by=None):
        &#34;&#34;&#34;Get market (benchmark) value series per column/group.

        If grouped, evenly distributes initial cash among assets in the group.

        Uses filled close if `Portfolio.use_filled_close` is True.

        !!! note
            Does not take into account fees and slippage. For this, create a separate portfolio.&#34;&#34;&#34;
        if self.use_filled_close:
            close = to_2d(self.fill_close(), raw=True)
        else:
            close = to_2d(self.close, raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            init_cash_grouped = to_1d(self.get_init_cash(group_by=group_by), raw=True)
            market_value = nb.market_value_grouped_nb(close, group_lens, init_cash_grouped)
        else:
            init_cash = to_1d(self.get_init_cash(group_by=False), raw=True)
            market_value = nb.market_value_nb(close, init_cash)
        return self.wrapper.wrap(market_value, group_by=group_by)

    @cached_method
    def market_returns(self, group_by=None):
        &#34;&#34;&#34;Get return series per column/group based on market (benchmark) value.&#34;&#34;&#34;
        market_value = to_2d(self.market_value(group_by=group_by), raw=True)
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        market_returns = nb.returns_nb(market_value, init_cash)
        return self.wrapper.wrap(market_returns, group_by=group_by)

    @cached_method
    def total_market_return(self, group_by=None):
        &#34;&#34;&#34;Get total market (benchmark) return.&#34;&#34;&#34;
        market_value = to_2d(self.market_value(group_by=group_by), raw=True)
        total_market_return = nb.total_market_return_nb(market_value)
        return self.wrapper.wrap_reduced(total_market_return, group_by=group_by)

    @cached_method
    def stats(self, column=None, group_by=None, incl_unrealized=None, active_returns=False,
              in_sim_order=False, agg_func=lambda x: x.mean(axis=0), **kwargs):
        &#34;&#34;&#34;Compute various statistics on this portfolio.

        `kwargs` will be passed to each `vectorbt.returns.accessors.ReturnsAccessor` method.

        Can either return aggregated statistics by reducing metrics of all columns with
        `agg_func` (mean by default) or return statistics for a single column if `column`
        was specified or portfolio contains only one column of data. To display rich data types
        such as durations correctly, use an aggregation function that can be applied on `pd.Series`.

        !!! note
            Use `column` only if caching is enabled, otherwise it may re-compute the same
            objects multiple times.&#34;&#34;&#34;
        # Pre-calculate
        trades = self.get_trades(group_by=group_by)
        if incl_unrealized is None:
            incl_unrealized = self.incl_unrealized
        if not incl_unrealized:
            trades = trades.closed
        drawdowns = self.get_drawdowns(group_by=group_by)
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)

        # Run stats
        stats_df = pd.DataFrame({
            &#39;Start&#39;: self.wrapper.index[0],
            &#39;End&#39;: self.wrapper.index[-1],
            &#39;Duration&#39;: self.wrapper.shape[0] * self.wrapper.freq,
            &#39;Init. Cash&#39;: self.get_init_cash(group_by=group_by),
            &#39;Total Profit&#39;: self.total_profit(group_by=group_by),
            &#39;Total Return [%]&#39;: self.total_return(group_by=group_by) * 100,
            &#39;Benchmark Return [%]&#39;: self.total_market_return(group_by=group_by) * 100,
            &#39;Position Coverage [%]&#39;: self.pos_coverage(group_by=group_by) * 100,
            &#39;Max. Drawdown [%]&#39;: -drawdowns.max_drawdown() * 100,
            &#39;Avg. Drawdown [%]&#39;: -drawdowns.avg_drawdown() * 100,
            &#39;Max. Drawdown Duration&#39;: drawdowns.max_duration(),
            &#39;Avg. Drawdown Duration&#39;: drawdowns.avg_duration(),
            &#39;Num. Trades&#39;: trades.count(),
            &#39;Win Rate [%]&#39;: trades.win_rate() * 100,
            &#39;Best Trade [%]&#39;: trades.returns.max() * 100,
            &#39;Worst Trade [%]&#39;: trades.returns.min() * 100,
            &#39;Avg. Trade [%]&#39;: trades.returns.mean() * 100,
            &#39;Max. Trade Duration&#39;: trades.duration.max(time_units=True),
            &#39;Avg. Trade Duration&#39;: trades.duration.mean(time_units=True),
            &#39;Expectancy&#39;: trades.expectancy(),
            &#39;SQN&#39;: trades.sqn(),
            &#39;Gross Exposure&#39;: self.gross_exposure(group_by=group_by).mean(),
            &#39;Sharpe Ratio&#39;: self.sharpe_ratio(reuse_returns=returns, **kwargs),
            &#39;Sortino Ratio&#39;: self.sortino_ratio(reuse_returns=returns, **kwargs),
            &#39;Calmar Ratio&#39;: self.calmar_ratio(reuse_returns=returns, **kwargs)
        }, index=self.wrapper.grouper.get_columns(group_by=group_by))

        # Select columns or reduce
        if stats_df.shape[0] == 1:
            return self.wrapper.wrap_reduced(stats_df.iloc[0], index=stats_df.columns)
        if column is not None:
            return stats_df.loc[column]
        if agg_func is not None:
            agg_stats_sr = pd.Series(index=stats_df.columns, name=agg_func.__name__)
            agg_stats_sr.iloc[:3] = stats_df.iloc[0, :3]
            agg_stats_sr.iloc[3:] = agg_func(stats_df.iloc[:, 3:])
            return agg_stats_sr
        return stats_df

    def returns_stats(self, column=None, group_by=None, active_returns=False, in_sim_order=False,
                      agg_func=lambda x: x.mean(axis=0), year_freq=None, **kwargs):
        &#34;&#34;&#34;Compute various statistics on returns of this portfolio.

        For keyword arguments and notes, see `Portfolio.stats`.

        `kwargs` will be passed to `vectorbt.returns.accessors.ReturnsAccessor.stats` method.
        If `benchmark_rets` is not set, uses `Portfolio.market_returns`.&#34;&#34;&#34;
        # Pre-calculate
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)

        # Run stats
        if &#39;benchmark_rets&#39; not in kwargs:
            kwargs[&#39;benchmark_rets&#39;] = self.market_returns(group_by=group_by)
        stats_obj = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq).stats(**kwargs)

        # Select columns or reduce
        if checks.is_series(stats_obj):
            return stats_obj
        if column is not None:
            return stats_obj.loc[column]
        if agg_func is not None:
            agg_stats_sr = pd.Series(index=stats_obj.columns, name=agg_func.__name__)
            agg_stats_sr.iloc[:3] = stats_obj.iloc[0, :3]
            agg_stats_sr.iloc[3:] = agg_func(stats_obj.iloc[:, 3:])
            return agg_stats_sr
        return stats_obj

    # ############# Plotting ############# #

    subplot_settings = OrderedDict(
        orders=dict(
            title=&#34;Orders&#34;,
            can_plot_groups=False
        ),
        trades=dict(
            title=&#34;Trades&#34;,
            can_plot_groups=False
        ),
        positions=dict(
            title=&#34;Positions&#34;,
            can_plot_groups=False
        ),
        trade_pnl=dict(
            title=&#34;Trade PnL&#34;,
            can_plot_groups=False
        ),
        position_pnl=dict(
            title=&#34;Position PnL&#34;,
            can_plot_groups=False
        ),
        cum_returns=dict(
            title=&#34;Cumulative Returns&#34;
        ),
        share_flow=dict(
            title=&#34;Share Flow&#34;,
            can_plot_groups=False
        ),
        cash_flow=dict(
            title=&#34;Cash Flow&#34;
        ),
        shares=dict(
            title=&#34;Shares&#34;,
            can_plot_groups=False
        ),
        cash=dict(
            title=&#34;Cash&#34;
        ),
        holding_value=dict(
            title=&#34;Holding Value&#34;
        ),
        value=dict(
            title=&#34;Value&#34;
        ),
        drawdowns=dict(
            title=&#34;Drawdowns&#34;
        ),
        underwater=dict(
            title=&#34;Underwater&#34;
        ),
        gross_exposure=dict(
            title=&#34;Gross Exposure&#34;
        ),
        net_exposure=dict(
            title=&#34;Net Exposure&#34;
        )
    )
    &#34;&#34;&#34;Settings of subplots supported by `Portfolio.plot`.&#34;&#34;&#34;

    def plot(self, *,
             column=None,
             subplots=None,
             group_by=None,
             show_titles=True,
             hide_id_labels=True,
             group_id_labels=True,
             hline_shape_kwargs=None,
             make_subplots_kwargs=None,
             **kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot various parts of this portfolio.

        Args:
            subplots (list of str or list of tuple): List of subplots to plot.

                Each element can be either:

                * a subplot name, as listed in `Portfolio.subplot_settings`
                * a tuple of a subplot name and a dict as in `Portfolio.subplot_settings` but with an
                    additional optional key `plot_func`. The plot function should accept current portfolio
                    object (with column already selected) and optionally other keyword arguments.
                    Will pass `row`, `col`, and other subplot-dependent arguments if they can be found
                    in the function&#39;s signature.
            column (str): Name of the column/group to plot.

                Takes effect if portfolio contains multiple columns.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.

                Used to select `group`.
            show_titles (bool): Whether to show the title in the top left corner of each subplot.
            hide_id_labels (bool): Whether to hide identical legend labels.

                Two labels are identical if their name, marker style and line style match.
            group_id_labels (bool): Whether to group identical legend labels.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for horizontal lines.
            make_subplots_kwargs (dict): Keyword arguments passed to `plotly.subplots.make_subplots`.
            **kwargs: Additional keyword arguments.

                Can contain keyword arguments for each subplot, each specified as `{subplot_name}_kwargs`.
                Other keyword arguments are used to update layout of the figure.

        ## Example

        Plot portfolio of a random strategy:
        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from datetime import datetime
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; start = datetime(2020, 1, 1)
        &gt;&gt;&gt; end = datetime(2020, 9, 1)
        &gt;&gt;&gt; close = vbt.utils.data.download(&#34;BTC-USD&#34;, start=start, end=end)[&#39;Close&#39;]

        &gt;&gt;&gt; np.random.seed(42)
        &gt;&gt;&gt; size = pd.Series.vbt.empty_like(close, fill_value=0.)
        &gt;&gt;&gt; n_orders = 20
        &gt;&gt;&gt; rand_idxs = np.random.randint(0, len(size), size=n_orders)
        &gt;&gt;&gt; size.iloc[rand_idxs] = np.random.uniform(-1, 1, size=n_orders)
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
        ...     close, size, direction=&#39;longonly&#39;,
        ...     init_cash=&#39;auto&#39;, freq=&#39;1D&#39;)
        &gt;&gt;&gt; portfolio.plot()
        ```

        ![](/vectorbt/docs/img/portfolio_plot.png)

        You can choose any of the subplots in `Portfolio.subplot_settings`, in any order:

        ```python-repl
        &gt;&gt;&gt; from vectorbt.utils.colors import adjust_opacity

        &gt;&gt;&gt; portfolio.plot(
        ...     subplots=[&#39;drawdowns&#39;, &#39;underwater&#39;],
        ...     drawdowns_kwargs=dict(top_n=3),
        ...     underwater_kwargs=dict(
        ...         trace_kwargs=dict(
        ...             line_color=&#39;#FF6F00&#39;,
        ...             fillcolor=adjust_opacity(&#39;#FF6F00&#39;, 0.3)
        ...         )
        ...     )
        ... )
        ```

        ![](/vectorbt/docs/img/portfolio_plot_drawdowns.png)

        You can also create a custom subplot, either by providing a function or
        by creating a placeholder that can be written later:

        ```python-repl
        &gt;&gt;&gt; fig = portfolio.plot(subplots=[
        ...     &#39;orders&#39;,
        ...     (&#39;order_size&#39;, dict(
        ...         title=&#39;Order Size&#39;,
        ...         can_plot_groups=False
        ...     ))  # placeholder
        ... ])

        &gt;&gt;&gt; size.rename(&#39;Order Size&#39;).vbt.plot(add_trace_kwargs=dict(row=2, col=1), fig=fig)
        ```

        ![](/vectorbt/docs/img/portfolio_plot_custom.png)
        &#34;&#34;&#34;
        from vectorbt.settings import color_schema, layout

        # Select one column/group
        self_col = self.select_series(column=column, group_by=group_by)

        if subplots is None:
            if self_col.wrapper.grouper.is_grouped():
                subplots = [&#39;cum_returns&#39;]
            else:
                subplots = [&#39;orders&#39;, &#39;trade_pnl&#39;, &#39;cum_returns&#39;]
        elif subplots == &#39;all&#39;:
            if self_col.wrapper.grouper.is_grouped():
                supported_subplots = filter(lambda x: x[1].get(&#39;can_plot_groups&#39;, True), self.subplot_settings.items())
            else:
                supported_subplots = self.subplot_settings.items()
            subplots = list(list(zip(*supported_subplots))[0])
        if not isinstance(subplots, list):
            subplots = [subplots]
        if len(subplots) == 0:
            raise ValueError(&#34;You must select at least one subplot&#34;)
        if hline_shape_kwargs is None:
            hline_shape_kwargs = {}
        hline_shape_kwargs = merge_dicts(
            dict(
                type=&#39;line&#39;,
                line=dict(
                    color=&#39;gray&#39;,
                    dash=&#34;dash&#34;,
                )
            ),
            hline_shape_kwargs
        )
        if make_subplots_kwargs is None:
            make_subplots_kwargs = {}

        # Set up figure
        rows = make_subplots_kwargs.pop(&#39;rows&#39;, len(subplots))
        cols = make_subplots_kwargs.pop(&#39;cols&#39;, 1)
        width = kwargs.get(&#39;width&#39;, layout[&#39;width&#39;] + 50)
        height = kwargs.get(&#39;height&#39;, (layout[&#39;height&#39;] - 50) * rows if rows &gt; 1 else layout[&#39;height&#39;])
        specs = make_subplots_kwargs.pop(&#39;specs&#39;, [[{} for _ in range(cols)] for _ in range(rows)])
        row_col_tuples = []
        for row, row_spec in enumerate(specs):
            for col, col_spec in enumerate(row_spec):
                if col_spec is not None:
                    row_col_tuples.append((row + 1, col + 1))
        shared_xaxes = make_subplots_kwargs.pop(&#39;shared_xaxes&#39;, True)
        shared_yaxes = make_subplots_kwargs.pop(&#39;shared_yaxes&#39;, False)
        if height is not None:
            vertical_spacing = make_subplots_kwargs.pop(&#39;vertical_spacing&#39;, 40)
            if vertical_spacing is not None and vertical_spacing &gt; 1:
                vertical_spacing /= height
        else:
            vertical_spacing = make_subplots_kwargs.pop(&#39;vertical_spacing&#39;, None)
        horizontal_spacing = make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;, None)
        if width is not None:
            if horizontal_spacing is not None and horizontal_spacing &gt; 1:
                horizontal_spacing /= width
        if show_titles:
            _subplot_titles = []
            for name in subplots:
                if isinstance(name, tuple):
                    _subplot_titles.append(name[1].get(&#39;title&#39;, None))
                else:
                    _subplot_titles.append(self_col.subplot_settings[name][&#39;title&#39;])
        else:
            _subplot_titles = None
        fig = make_subplots(
            rows=rows,
            cols=cols,
            specs=specs,
            shared_xaxes=shared_xaxes,
            shared_yaxes=shared_yaxes,
            subplot_titles=_subplot_titles,
            vertical_spacing=vertical_spacing,
            horizontal_spacing=horizontal_spacing,
            **make_subplots_kwargs
        )
        default_layout = dict(
            autosize=True,
            width=width,
            height=height,
            legend=dict(
                orientation=&#34;h&#34;,
                yanchor=&#34;bottom&#34;,
                y=(1 + 30 / height) if height is not None else 1.02,
                xanchor=&#34;right&#34;,
                x=1,
                traceorder=&#39;normal&#39;
            )
        )
        fig.update_layout(default_layout)

        def _add_hline(value, x_domain, yref):
            fig.add_shape(**merge_dicts(dict(
                xref=&#34;paper&#34;,
                yref=yref,
                x0=x_domain[0],
                y0=value,
                x1=x_domain[1],
                y1=value
            ), hline_shape_kwargs))

        def _get_arg_names(method):
            sig = signature(method)
            arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
            return arg_names

        def _extract_method_kwargs(method, kwargs):
            arg_names = _get_arg_names(method)
            method_kwargs = {}
            for name in arg_names:
                if name in kwargs:
                    method_kwargs[name] = kwargs.pop(name)
            return method_kwargs

        # Show subplots
        for i, name in enumerate(subplots):
            row, col = row_col_tuples[i]
            xref = &#39;x&#39; if i == 0 else &#39;x&#39; + str(i + 1)
            yref = &#39;y&#39; if i == 0 else &#39;y&#39; + str(i + 1)
            xaxis = &#39;xaxis&#39; if i == 0 else &#39;xaxis&#39; + str(i + 1)
            yaxis = &#39;yaxis&#39; if i == 0 else &#39;yaxis&#39; + str(i + 1)
            x_domain = fig.layout[xaxis][&#39;domain&#39;]
            y_domain = fig.layout[yaxis][&#39;domain&#39;]

            if isinstance(name, tuple):
                _name, settings = name
                can_plot_groups = settings.get(&#39;can_plot_groups&#39;, True)
                if self_col.wrapper.grouper.is_grouped() and not can_plot_groups:
                    raise TypeError(f&#34;Group is not supported by custom subplot with name &#39;{_name}&#39;&#34;)
                plot_func = settings.get(&#39;plot_func&#39;, None)

                if plot_func is not None:
                    arg_names = _get_arg_names(plot_func)
                    custom_kwargs = dict()
                    if &#39;add_trace_kwargs&#39; in arg_names:
                        custom_kwargs[&#39;add_trace_kwargs&#39;] = dict(row=row, col=col)
                    if &#39;xref&#39; in arg_names:
                        custom_kwargs[&#39;xref&#39;] = xref
                    if &#39;yref&#39; in arg_names:
                        custom_kwargs[&#39;yref&#39;] = yref
                    if &#39;xaxis&#39; in arg_names:
                        custom_kwargs[&#39;xaxis&#39;] = xaxis
                    if &#39;yaxis&#39; in arg_names:
                        custom_kwargs[&#39;yaxis&#39;] = yaxis
                    if &#39;x_domain&#39; in arg_names:
                        custom_kwargs[&#39;x_domain&#39;] = x_domain
                    if &#39;y_domain&#39; in arg_names:
                        custom_kwargs[&#39;y_domain&#39;] = y_domain
                    custom_kwargs = merge_dicts(custom_kwargs, kwargs.pop(f&#39;{_name}_kwargs&#39;, {}))
                    plot_func(self_col, **custom_kwargs, fig=fig)

                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = settings.get(&#39;title&#39;, None)
                    
            else:
                settings = self.subplot_settings[name]
                can_plot_groups = settings.get(&#39;can_plot_groups&#39;, True)
                if self_col.wrapper.grouper.is_grouped() and not can_plot_groups:
                    raise TypeError(f&#34;Group is not supported by subplot with name &#39;{name}&#39;&#34;)

                if name == &#39;orders&#39;:
                    orders_kwargs = kwargs.pop(&#39;orders_kwargs&#39;, {})
                    method_kwargs = _extract_method_kwargs(self_col.get_orders, orders_kwargs)
                    self_col.get_orders(**method_kwargs).plot(
                        **orders_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Price&#39;
    
                elif name == &#39;trades&#39;:
                    trades_kwargs = kwargs.pop(&#39;trades_kwargs&#39;, {})
                    method_kwargs = _extract_method_kwargs(self_col.get_trades, trades_kwargs)
                    self_col.get_trades(**method_kwargs).plot(
                        **trades_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Price&#39;
    
                elif name == &#39;positions&#39;:
                    positions_kwargs = kwargs.pop(&#39;positions_kwargs&#39;, {})
                    method_kwargs = _extract_method_kwargs(self_col.get_positions, positions_kwargs)
                    self_col.get_positions(**method_kwargs).plot(
                        **positions_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Price&#39;
    
                elif name == &#39;trade_pnl&#39;:
                    trade_pnl_kwargs = merge_dicts(dict(
                        hline_shape_kwargs=hline_shape_kwargs
                    ), kwargs.pop(&#39;trade_pnl_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.get_trades, trade_pnl_kwargs)
                    self_col.get_trades(**method_kwargs).plot_pnl(
                        **trade_pnl_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;PnL&#39;
    
                elif name == &#39;position_pnl&#39;:
                    position_pnl_kwargs = kwargs.pop(&#39;position_pnl_kwargs&#39;, {})
                    method_kwargs = _extract_method_kwargs(self_col.get_positions, position_pnl_kwargs)
                    self_col.get_positions(**method_kwargs).plot_pnl(
                        **position_pnl_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;PnL&#39;
    
                elif name == &#39;cum_returns&#39;:
                    cum_returns_kwargs = merge_dicts(dict(
                        benchmark_rets=self_col.market_returns(),
                        main_kwargs=dict(
                            trace_kwargs=dict(
                                line_color=color_schema[&#39;purple&#39;],
                                name=&#39;Value&#39;
                            )
                        ),
                        hline_shape_kwargs=hline_shape_kwargs
                    ), kwargs.pop(&#39;cum_returns_kwargs&#39;, {}))
                    active_returns = cum_returns_kwargs.pop(&#39;active_returns&#39;, False)
                    in_sim_order = cum_returns_kwargs.pop(&#39;in_sim_order&#39;, False)
                    if active_returns:
                        returns = self_col.active_returns()
                    else:
                        returns = self_col.returns(in_sim_order=in_sim_order)
                    returns.vbt.returns.plot_cum_returns(
                        **cum_returns_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Cumulative Returns&#39;
    
                elif name == &#39;drawdowns&#39;:
                    drawdowns_kwargs = merge_dicts(dict(
                        ts_trace_kwargs=dict(
                            line_color=color_schema[&#39;purple&#39;],
                            name=&#39;Value&#39;
                        )
                    ), kwargs.pop(&#39;drawdowns_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.get_drawdowns, drawdowns_kwargs)
                    self_col.get_drawdowns(**method_kwargs).plot(
                        **drawdowns_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Value&#39;
    
                elif name == &#39;underwater&#39;:
                    underwater_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;red&#39;],
                            fillcolor=adjust_opacity(color_schema[&#39;red&#39;], 0.3),
                            fill=&#39;tozeroy&#39;,
                            name=&#39;Drawdown&#39;
                        )
                    ), kwargs.pop(&#39;underwater_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.drawdown, underwater_kwargs)
                    self_col.drawdown(**method_kwargs).vbt.plot(
                        **underwater_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(0, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Drawdown&#39;
                    fig.layout[yaxis][&#39;tickformat&#39;] = &#39;%&#39;
    
                elif name == &#39;share_flow&#39;:
                    share_flow_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;brown&#39;],
                            name=&#39;Shares&#39;
                        )
                    ), kwargs.pop(&#39;share_flow_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.share_flow, share_flow_kwargs)
                    self_col.share_flow(**method_kwargs).vbt.plot(
                        **share_flow_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(0, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Share Flow&#39;
    
                elif name == &#39;cash_flow&#39;:
                    cash_flow_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;green&#39;],
                            name=&#39;Cash&#39;
                        )
                    ), kwargs.pop(&#39;cash_flow_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.cash_flow, cash_flow_kwargs)
                    self_col.cash_flow(**method_kwargs).vbt.plot(
                        **cash_flow_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(0, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Cash Flow&#39;
    
                elif name == &#39;shares&#39;:
                    shares_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;brown&#39;],
                            name=&#39;Shares&#39;
                        ),
                        pos_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;brown&#39;], 0.3)
                        ),
                        neg_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;orange&#39;], 0.3)
                        ),
                        other_trace_kwargs=&#39;hidden&#39;
                    ), kwargs.pop(&#39;shares_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.shares, shares_kwargs)
                    self_col.shares(**method_kwargs).vbt.plot_against(
                        0, **shares_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(0, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Shares&#39;
    
                elif name == &#39;cash&#39;:
                    cash_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;green&#39;],
                            name=&#39;Cash&#39;
                        ),
                        pos_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;green&#39;], 0.3)
                        ),
                        neg_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;red&#39;], 0.3)
                        ),
                        other_trace_kwargs=&#39;hidden&#39;
                    ), kwargs.pop(&#39;cash_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.cash, cash_kwargs)
                    self_col.cash(**method_kwargs).vbt.plot_against(
                        0, **cash_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(self_col.init_cash, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Cash&#39;
    
                elif name == &#39;holding_value&#39;:
                    holding_value_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;cyan&#39;],
                            name=&#39;Holding Value&#39;
                        ),
                        pos_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;cyan&#39;], 0.3)
                        ),
                        neg_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;orange&#39;], 0.3)
                        ),
                        other_trace_kwargs=&#39;hidden&#39;
                    ), kwargs.pop(&#39;holding_value_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.holding_value, holding_value_kwargs)
                    self_col.holding_value(**method_kwargs).vbt.plot_against(
                        0, **holding_value_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(0, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Holding Value&#39;
    
                elif name == &#39;value&#39;:
                    value_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;purple&#39;],
                            name=&#39;Value&#39;
                        ),
                        other_trace_kwargs=&#39;hidden&#39;
                    ), kwargs.pop(&#39;value_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.value, value_kwargs)
                    self_col.value(**method_kwargs).vbt.plot_against(
                        self_col.init_cash, **value_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(self_col.init_cash, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Value&#39;
    
                elif name == &#39;gross_exposure&#39;:
                    gross_exposure_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;pink&#39;],
                            name=&#39;Exposure&#39;
                        ),
                        pos_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;orange&#39;], 0.3)
                        ),
                        neg_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;pink&#39;], 0.3)
                        ),
                        other_trace_kwargs=&#39;hidden&#39;
                    ), kwargs.pop(&#39;gross_exposure_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.gross_exposure, gross_exposure_kwargs)
                    self_col.gross_exposure(**method_kwargs).vbt.plot_against(
                        1, **gross_exposure_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(1, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Gross Exposure&#39;
    
                elif name == &#39;net_exposure&#39;:
                    net_exposure_kwargs = merge_dicts(dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;pink&#39;],
                            name=&#39;Exposure&#39;
                        ),
                        pos_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;pink&#39;], 0.3)
                        ),
                        neg_trace_kwargs=dict(
                            fillcolor=adjust_opacity(color_schema[&#39;orange&#39;], 0.3)
                        ),
                        other_trace_kwargs=&#39;hidden&#39;
                    ), kwargs.pop(&#39;net_exposure_kwargs&#39;, {}))
                    method_kwargs = _extract_method_kwargs(self_col.net_exposure, net_exposure_kwargs)
                    self_col.net_exposure(**method_kwargs).vbt.plot_against(
                        0, **net_exposure_kwargs,
                        add_trace_kwargs=dict(row=row, col=col), fig=fig)
                    _add_hline(0, x_domain, yref)
                    fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                    fig.layout[yaxis][&#39;title&#39;] = &#39;Net Exposure&#39;

        # Remove duplicate legend labels
        found_ids = dict()
        unique_idx = 0
        for trace in fig.data:
            if &#39;name&#39; in trace:
                name = trace[&#39;name&#39;]
            else:
                name = None
            if &#39;marker&#39; in trace:
                marker = trace[&#39;marker&#39;]
            else:
                marker = {}
            if &#39;symbol&#39; in marker:
                marker_symbol = marker[&#39;symbol&#39;]
            else:
                marker_symbol = None
            if &#39;color&#39; in marker:
                marker_color = marker[&#39;color&#39;]
            else:
                marker_color = None
            if &#39;line&#39; in trace:
                line = trace[&#39;line&#39;]
            else:
                line = {}
            if &#39;dash&#39; in line:
                line_dash = line[&#39;dash&#39;]
            else:
                line_dash = None
            if &#39;color&#39; in line:
                line_color = line[&#39;color&#39;]
            else:
                line_color = None

            id = (name, marker_symbol, marker_color, line_dash, line_color)
            if id in found_ids:
                if hide_id_labels:
                    trace[&#39;showlegend&#39;] = False
                if group_id_labels:
                    trace[&#39;legendgroup&#39;] = found_ids[id]
            else:
                if group_id_labels:
                    trace[&#39;legendgroup&#39;] = unique_idx
                found_ids[id] = unique_idx
                unique_idx += 1

        # Remove all except the last title if sharing the same axis
        if shared_xaxes:
            i = 0
            for row in range(rows):
                for col in range(cols):
                    if specs[row][col] is not None:
                        xaxis = &#39;xaxis&#39; if i == 0 else &#39;xaxis&#39; + str(i + 1)
                        if row &lt; rows - 1:
                            fig.layout[xaxis][&#39;title&#39;] = None
                        i += 1
        if shared_yaxes:
            i = 0
            for row in range(rows):
                for col in range(cols):
                    if specs[row][col] is not None:
                        yaxis = &#39;yaxis&#39; if i == 0 else &#39;yaxis&#39; + str(i + 1)
                        if col &gt; 0:
                            fig.layout[yaxis][&#39;title&#39;] = None
                        i += 1

        fig.update_layout(kwargs)
        return fig</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio.subplot_settings"><code class="name">var <span class="ident fname">subplot_settings</span></code></dt>
<dd>
<div class="desc"><p>Settings of subplots supported by <code><a title="vectorbt.portfolio.base.Portfolio.plot" href="#vectorbt.portfolio.base.Portfolio.plot">Portfolio.plot()</a></code>.</p></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio.from_holding"><code class="name flex">
<span>def <span class="ident fname">from_holding</span></span>(<span>close, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate portfolio from holding.</p>
<p>Based on <code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">Portfolio.from_signals()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_holding(cls, close, **kwargs):
    &#34;&#34;&#34;Simulate portfolio from holding.

    Based on `Portfolio.from_signals`.&#34;&#34;&#34;
    return cls.from_signals(close, True, False, accumulate=False, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.from_order_func"><code class="name flex">
<span>def <span class="ident fname">from_order_func</span></span>(<span>close, order_func_nb, *order_args, target_shape=None, keys=None, init_cash=None, cash_sharing=None, call_seq=None, active_mask=None, prep_func_nb=None, prep_args=None, group_prep_func_nb=None, group_prep_args=None, row_prep_func_nb=None, row_prep_args=None, segment_prep_func_nb=None, segment_prep_args=None, row_wise=None, max_orders=None, max_logs=None, seed=None, group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from a custom order function.</p>
<p>For details, see <code><a title="vectorbt.portfolio.nb.simulate_nb" href="nb.html#vectorbt.portfolio.nb.simulate_nb">simulate_nb()</a></code>.</p>
<p>if <code>row_wise</code> is True, also see <code><a title="vectorbt.portfolio.nb.simulate_row_wise_nb" href="nb.html#vectorbt.portfolio.nb.simulate_row_wise_nb">simulate_row_wise_nb()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>close</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>Reference price, such as close.
Will broadcast to <code>target_shape</code>.</p>
<p>Will be used for calculating unrealized P&amp;L and portfolio value.</p>
</dd>
<dt><strong><code>order_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>Order generation function.</dd>
<dt><strong><code>*order_args</code></strong></dt>
<dd>Arguments passed to <code>order_func_nb</code>.</dd>
<dt><strong><code>target_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Target shape to iterate over. Defaults to <code>close.shape</code>.</dd>
<dt><strong><code>keys</code></strong> :&ensp;<code>sequence</code></dt>
<dd>
<p>Outermost column level.</p>
<p>Each element should correspond to one iteration over columns in <code>close</code>.
Should be set only if <code>target_shape</code> is bigger than <code>close.shape</code>.</p>
</dd>
<dt><strong><code>init_cash</code></strong> :&ensp;<code>InitCashMode, float</code> or <code>array_like</code> of <code>float</code></dt>
<dd>
<p>Initial capital.</p>
<p>By default, will broadcast to the number of columns.
If cash sharing is enabled, will broadcast to the number of groups.
See <code><a title="vectorbt.portfolio.enums.InitCashMode" href="enums.html#vectorbt.portfolio.enums.InitCashMode">InitCashMode</a></code> to find optimal initial cash.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mode <code>InitCashMode.AutoAlign</code> is applied after the portfolio is initialized
to set the same initial cash for all columns/groups. Changing grouping
will change the initial cash, so be aware when indexing.</p>
</div>
</dd>
<dt><strong><code>cash_sharing</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to share cash within the same group.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Introduces cross-asset dependencies.</p>
</div>
</dd>
<dt><strong><code>call_seq</code></strong> :&ensp;<code>CallSeqType</code> or <code>array_like</code> of <code>int</code></dt>
<dd>
<p>Default sequence of calls per row and group.</p>
<ul>
<li>Use <code><a title="vectorbt.portfolio.enums.CallSeqType" href="enums.html#vectorbt.portfolio.enums.CallSeqType">CallSeqType</a></code> to select a sequence type.</li>
<li>Set to array to specify custom sequence. Will not broadcast.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CallSeqType.Auto should be implemented manually.
Use <code>auto_call_seq_ctx_nb</code> in <code>segment_prep_func_nb</code>.</p>
</div>
</dd>
<dt><strong><code>active_mask</code></strong> :&ensp;<code>int</code> or <code>array_like</code> of <code>bool</code></dt>
<dd>
<p>Mask of whether a particular segment should be executed.</p>
<p>Supplying an integer will activate every n-th row (just for convenience).
Supplying a boolean will broadcast to the number of rows and groups.</p>
</dd>
<dt><strong><code>prep_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>Simulation preparation function.</dd>
<dt><strong><code>prep_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>
<p>Packed arguments passed to <code>prep_func_nb</code>.</p>
<p>Defaults to <code>()</code>.</p>
</dd>
<dt><strong><code>group_prep_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>
<p>Group preparation function.</p>
<p>Called only if <code>row_wise</code> is False.</p>
</dd>
<dt><strong><code>group_prep_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>
<p>Packed arguments passed to <code>group_prep_func_nb</code>.</p>
<p>Defaults to <code>()</code>.</p>
</dd>
<dt><strong><code>row_prep_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>
<p>Row preparation function.</p>
<p>Called only if <code>row_wise</code> is True.</p>
</dd>
<dt><strong><code>row_prep_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>
<p>Packed arguments passed to <code>row_prep_func_nb</code>.</p>
<p>Defaults to <code>()</code>.</p>
</dd>
<dt><strong><code>segment_prep_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>Segment preparation function.</dd>
<dt><strong><code>segment_prep_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>
<p>Packed arguments passed to <code>segment_prep_func_nb</code>.</p>
<p>Defaults to <code>()</code>.</p>
</dd>
<dt><strong><code>row_wise</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to iterate over rows rather than columns/groups.</p>
<p>See <code><a title="vectorbt.portfolio.nb.simulate_row_wise_nb" href="nb.html#vectorbt.portfolio.nb.simulate_row_wise_nb">simulate_row_wise_nb()</a></code>.</p>
</dd>
<dt><strong><code>max_orders</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Size of the order records array.
Defaults to the number of elements in the broadcasted shape.</p>
<p>Set to a lower number if you run out of memory.</p>
</dd>
<dt><strong><code>max_logs</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Size of the log records array.
Defaults to the number of elements in the broadcasted shape.</p>
<p>Set to a lower number if you run out of memory.</p>
</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Seed to be set for both <code>call_seq</code> and at the beginning of the simulation.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>broadcast_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.</dd>
<dt><strong><code>wrapper_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Index frequency in case <code>close.index</code> is not datetime-like.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.settings.portfolio" href="../settings.html#vectorbt.settings.portfolio">portfolio</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All passed functions should be Numba-compiled.</p>
<p>Objects passed as arguments to both functions will not broadcast to <code>target_shape</code>
as their purpose is unknown. You should broadcast manually or use flexible indexing.</p>
<p>Also see notes on <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In contrast to other methods, the valuation price is previous <code>close</code>
instead of order price, since the price of an order is unknown before call.
You can still set valuation price explicitly in <code>segment_prep_func_nb</code>.</p>
</div>
<h2 id="example">Example</h2>
<p>Buy 10 shares each tick:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; from vectorbt.portfolio.nb import create_order_nb

&gt;&gt;&gt; @njit
... def order_func_nb(oc, size):
...     return create_order_nb(size=size, price=oc.close[oc.i, oc.col])

&gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(close, order_func_nb, 10)

&gt;&gt;&gt; portfolio.shares()
0    10.0
1    20.0
2    30.0
3    40.0
4    40.0
dtype: float64
&gt;&gt;&gt; portfolio.cash()
0    90.0
1    70.0
2    40.0
3     0.0
4     0.0
dtype: float64
</code></pre>
<p>Reverse each position by first closing it. Keep state of last position to determine
which position to open next (just as an example, there are easier ways to do this):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np

&gt;&gt;&gt; @njit
... def group_prep_func_nb(gc):
...     last_pos_state = np.array([-1])
...     return (last_pos_state,)

&gt;&gt;&gt; @njit
... def order_func_nb(oc, last_pos_state):
...     if oc.shares_now &gt; 0:
...         size = -oc.shares_now  # close long
...     elif oc.shares_now &lt; 0:
...         size = -oc.shares_now  # close short
...     else:
...         if last_pos_state[0] == 1:
...             size = -np.inf  # open short
...             last_pos_state[0] = -1
...         else:
...             size = np.inf  # open long
...             last_pos_state[0] = 1
...
...     return create_order_nb(size=size, price=oc.close[oc.i, oc.col])

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
...     close, order_func_nb, group_prep_func_nb=group_prep_func_nb)

&gt;&gt;&gt; portfolio.shares()
0    100.0
1      0.0
2   -100.0
3      0.0
4     20.0
dtype: float64
&gt;&gt;&gt; portfolio.cash()
0      0.0
1    200.0
2    500.0
3    100.0
4      0.0
dtype: float64
</code></pre>
<p>Equal-weighted portfolio as in <code><a title="vectorbt.portfolio.nb.simulate_nb" href="nb.html#vectorbt.portfolio.nb.simulate_nb">simulate_nb()</a></code> example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from vectorbt.portfolio.nb import auto_call_seq_ctx_nb
&gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, Direction

&gt;&gt;&gt; @njit
... def group_prep_func_nb(gc):
...     '''Define empty arrays for each group.'''
...     size = np.empty(gc.group_len, dtype=np.float_)
...     size_type = np.empty(gc.group_len, dtype=np.int_)
...     direction = np.empty(gc.group_len, dtype=np.int_)
...     temp_float_arr = np.empty(gc.group_len, dtype=np.float_)
...     return size, size_type, direction, temp_float_arr

&gt;&gt;&gt; @njit
... def segment_prep_func_nb(sc, size, size_type, direction, temp_float_arr):
...     '''Perform rebalancing at each segment.'''
...     for k in range(sc.group_len):
...         col = sc.from_col + k
...         size[k] = 1 / sc.group_len
...         size_type[k] = SizeType.TargetPercent
...         direction[k] = Direction.LongOnly
...         sc.last_val_price[col] = sc.close[sc.i, col]
...     auto_call_seq_ctx_nb(sc, size, size_type, direction, temp_float_arr)
...     return size, size_type, direction

&gt;&gt;&gt; @njit
... def order_func_nb(oc, size, size_type, direction, fees, fixed_fees, slippage):
...     '''Place an order.'''
...     col_i = oc.call_seq_now[oc.call_idx]
...     return create_order_nb(
...         size=size[col_i],
...         size_type=size_type[col_i],
...         price=oc.close[oc.i, oc.col],
...         fees=fees, fixed_fees=fixed_fees, slippage=slippage,
...         direction=direction[col_i]
...     )

&gt;&gt;&gt; np.random.seed(42)
&gt;&gt;&gt; close = np.random.uniform(1, 10, size=(5, 3))
&gt;&gt;&gt; fees = 0.001
&gt;&gt;&gt; fixed_fees = 1.
&gt;&gt;&gt; slippage = 0.001

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
...     close,  # acts both as reference and order price here
...     order_func_nb, fees, fixed_fees, slippage,  # order_args as *args
...     active_mask=2,  # rebalance every second tick
...     group_prep_func_nb=group_prep_func_nb,
...     segment_prep_func_nb=segment_prep_func_nb,
...     cash_sharing=True, group_by=True,  # one group with cash sharing
... )

&gt;&gt;&gt; portfolio.holding_value(group_by=False).vbt.plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/simulate_nb.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_order_func(cls, close, order_func_nb, *order_args, target_shape=None, keys=None,
                    init_cash=None, cash_sharing=None, call_seq=None, active_mask=None,
                    prep_func_nb=None, prep_args=None, group_prep_func_nb=None, group_prep_args=None,
                    row_prep_func_nb=None, row_prep_args=None, segment_prep_func_nb=None,
                    segment_prep_args=None, row_wise=None, max_orders=None, max_logs=None,
                    seed=None, group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs):
    &#34;&#34;&#34;Build portfolio from a custom order function.

    For details, see `vectorbt.portfolio.nb.simulate_nb`.

    if `row_wise` is True, also see `vectorbt.portfolio.nb.simulate_row_wise_nb`.

    Args:
        close (array_like): Reference price, such as close.
            Will broadcast to `target_shape`.

            Will be used for calculating unrealized P&amp;L and portfolio value.
        order_func_nb (callable): Order generation function.
        *order_args: Arguments passed to `order_func_nb`.
        target_shape (tuple): Target shape to iterate over. Defaults to `close.shape`.
        keys (sequence): Outermost column level.

            Each element should correspond to one iteration over columns in `close`.
            Should be set only if `target_shape` is bigger than `close.shape`.
        init_cash (InitCashMode, float or array_like of float): Initial capital.

            By default, will broadcast to the number of columns.
            If cash sharing is enabled, will broadcast to the number of groups.
            See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

            !!! note
                Mode `InitCashMode.AutoAlign` is applied after the portfolio is initialized
                to set the same initial cash for all columns/groups. Changing grouping
                will change the initial cash, so be aware when indexing.
        cash_sharing (bool): Whether to share cash within the same group.

            !!! warning
                Introduces cross-asset dependencies.
        call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

            * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
            * Set to array to specify custom sequence. Will not broadcast.

            !!! note
                CallSeqType.Auto should be implemented manually.
                Use `auto_call_seq_ctx_nb` in `segment_prep_func_nb`.
        active_mask (int or array_like of bool): Mask of whether a particular segment should be executed.

            Supplying an integer will activate every n-th row (just for convenience).
            Supplying a boolean will broadcast to the number of rows and groups.
        prep_func_nb (callable): Simulation preparation function.
        prep_args (tuple): Packed arguments passed to `prep_func_nb`.

            Defaults to `()`.
        group_prep_func_nb (callable): Group preparation function.

            Called only if `row_wise` is False.
        group_prep_args (tuple): Packed arguments passed to `group_prep_func_nb`.

            Defaults to `()`.
        row_prep_func_nb (callable): Row preparation function.

            Called only if `row_wise` is True.
        row_prep_args (tuple): Packed arguments passed to `row_prep_func_nb`.

            Defaults to `()`.
        segment_prep_func_nb (callable): Segment preparation function.
        segment_prep_args (tuple): Packed arguments passed to `segment_prep_func_nb`.

            Defaults to `()`.
        row_wise (bool): Whether to iterate over rows rather than columns/groups.

            See `vectorbt.portfolio.nb.simulate_row_wise_nb`.
        max_orders (int): Size of the order records array.
            Defaults to the number of elements in the broadcasted shape.

            Set to a lower number if you run out of memory.
        max_logs (int): Size of the log records array.
            Defaults to the number of elements in the broadcasted shape.

            Set to a lower number if you run out of memory.
        seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
        group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
        wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
        freq (any): Index frequency in case `close.index` is not datetime-like.
        **kwargs: Keyword arguments passed to the `__init__` method.

    For defaults, see `vectorbt.settings.portfolio`.

    !!! note
        All passed functions should be Numba-compiled.

        Objects passed as arguments to both functions will not broadcast to `target_shape`
        as their purpose is unknown. You should broadcast manually or use flexible indexing.

        Also see notes on `Portfolio.from_orders`.

    !!! note
        In contrast to other methods, the valuation price is previous `close`
        instead of order price, since the price of an order is unknown before call.
        You can still set valuation price explicitly in `segment_prep_func_nb`.

    ## Example

    Buy 10 shares each tick:
    ```python-repl
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from numba import njit
    &gt;&gt;&gt; import vectorbt as vbt
    &gt;&gt;&gt; from vectorbt.portfolio.nb import create_order_nb

    &gt;&gt;&gt; @njit
    ... def order_func_nb(oc, size):
    ...     return create_order_nb(size=size, price=oc.close[oc.i, oc.col])

    &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(close, order_func_nb, 10)

    &gt;&gt;&gt; portfolio.shares()
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    40.0
    dtype: float64
    &gt;&gt;&gt; portfolio.cash()
    0    90.0
    1    70.0
    2    40.0
    3     0.0
    4     0.0
    dtype: float64
    ```

    Reverse each position by first closing it. Keep state of last position to determine
    which position to open next (just as an example, there are easier ways to do this):
    ```python-repl
    &gt;&gt;&gt; import numpy as np

    &gt;&gt;&gt; @njit
    ... def group_prep_func_nb(gc):
    ...     last_pos_state = np.array([-1])
    ...     return (last_pos_state,)

    &gt;&gt;&gt; @njit
    ... def order_func_nb(oc, last_pos_state):
    ...     if oc.shares_now &gt; 0:
    ...         size = -oc.shares_now  # close long
    ...     elif oc.shares_now &lt; 0:
    ...         size = -oc.shares_now  # close short
    ...     else:
    ...         if last_pos_state[0] == 1:
    ...             size = -np.inf  # open short
    ...             last_pos_state[0] = -1
    ...         else:
    ...             size = np.inf  # open long
    ...             last_pos_state[0] = 1
    ...
    ...     return create_order_nb(size=size, price=oc.close[oc.i, oc.col])

    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
    ...     close, order_func_nb, group_prep_func_nb=group_prep_func_nb)

    &gt;&gt;&gt; portfolio.shares()
    0    100.0
    1      0.0
    2   -100.0
    3      0.0
    4     20.0
    dtype: float64
    &gt;&gt;&gt; portfolio.cash()
    0      0.0
    1    200.0
    2    500.0
    3    100.0
    4      0.0
    dtype: float64
    ```

    Equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb` example:
    ```python-repl
    &gt;&gt;&gt; from vectorbt.portfolio.nb import auto_call_seq_ctx_nb
    &gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, Direction

    &gt;&gt;&gt; @njit
    ... def group_prep_func_nb(gc):
    ...     &#39;&#39;&#39;Define empty arrays for each group.&#39;&#39;&#39;
    ...     size = np.empty(gc.group_len, dtype=np.float_)
    ...     size_type = np.empty(gc.group_len, dtype=np.int_)
    ...     direction = np.empty(gc.group_len, dtype=np.int_)
    ...     temp_float_arr = np.empty(gc.group_len, dtype=np.float_)
    ...     return size, size_type, direction, temp_float_arr

    &gt;&gt;&gt; @njit
    ... def segment_prep_func_nb(sc, size, size_type, direction, temp_float_arr):
    ...     &#39;&#39;&#39;Perform rebalancing at each segment.&#39;&#39;&#39;
    ...     for k in range(sc.group_len):
    ...         col = sc.from_col + k
    ...         size[k] = 1 / sc.group_len
    ...         size_type[k] = SizeType.TargetPercent
    ...         direction[k] = Direction.LongOnly
    ...         sc.last_val_price[col] = sc.close[sc.i, col]
    ...     auto_call_seq_ctx_nb(sc, size, size_type, direction, temp_float_arr)
    ...     return size, size_type, direction

    &gt;&gt;&gt; @njit
    ... def order_func_nb(oc, size, size_type, direction, fees, fixed_fees, slippage):
    ...     &#39;&#39;&#39;Place an order.&#39;&#39;&#39;
    ...     col_i = oc.call_seq_now[oc.call_idx]
    ...     return create_order_nb(
    ...         size=size[col_i],
    ...         size_type=size_type[col_i],
    ...         price=oc.close[oc.i, oc.col],
    ...         fees=fees, fixed_fees=fixed_fees, slippage=slippage,
    ...         direction=direction[col_i]
    ...     )

    &gt;&gt;&gt; np.random.seed(42)
    &gt;&gt;&gt; close = np.random.uniform(1, 10, size=(5, 3))
    &gt;&gt;&gt; fees = 0.001
    &gt;&gt;&gt; fixed_fees = 1.
    &gt;&gt;&gt; slippage = 0.001

    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
    ...     close,  # acts both as reference and order price here
    ...     order_func_nb, fees, fixed_fees, slippage,  # order_args as *args
    ...     active_mask=2,  # rebalance every second tick
    ...     group_prep_func_nb=group_prep_func_nb,
    ...     segment_prep_func_nb=segment_prep_func_nb,
    ...     cash_sharing=True, group_by=True,  # one group with cash sharing
    ... )

    &gt;&gt;&gt; portfolio.holding_value(group_by=False).vbt.plot()
    ```

    ![](/vectorbt/docs/img/simulate_nb.png)
    &#34;&#34;&#34;
    # Get defaults
    from vectorbt import settings

    if not checks.is_pandas(close):
        if not checks.is_array(close):
            close = np.asarray(close)
        close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
    if target_shape is None:
        target_shape = close.shape
    if init_cash is None:
        init_cash = settings.portfolio[&#39;init_cash&#39;]
    init_cash = convert_str_enum_value(InitCashMode, init_cash)
    if isinstance(init_cash, int) and init_cash in InitCashMode:
        init_cash_mode = init_cash
        init_cash = np.inf
    else:
        init_cash_mode = None
    if cash_sharing is None:
        cash_sharing = settings.portfolio[&#39;cash_sharing&#39;]
    if call_seq is None:
        call_seq = settings.portfolio[&#39;call_seq&#39;]
    call_seq = convert_str_enum_value(CallSeqType, call_seq)
    if isinstance(call_seq, int):
        if call_seq == CallSeqType.Auto:
            raise ValueError(&#34;CallSeqType.Auto should be implemented manually. &#34;
                             &#34;Use auto_call_seq_ctx_nb in segment_prep_func_nb.&#34;)
    if active_mask is None:
        active_mask = True
    if row_wise is None:
        row_wise = settings.portfolio[&#39;row_wise&#39;]
    if seed is None:
        seed = settings.portfolio[&#39;seed&#39;]
    if seed is not None:
        set_seed(seed)
    if freq is None:
        freq = settings.portfolio[&#39;freq&#39;]
    if broadcast_kwargs is None:
        broadcast_kwargs = {}
    require_kwargs = dict(require_kwargs=dict(requirements=&#39;W&#39;))
    broadcast_kwargs = merge_dicts(require_kwargs, broadcast_kwargs)
    if wrapper_kwargs is None:
        wrapper_kwargs = {}
    if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
        raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

    # Broadcast inputs
    target_shape_2d = (target_shape[0], target_shape[1] if len(target_shape) &gt; 1 else 1)
    if close.shape != target_shape:
        if len(close.vbt.wrapper.columns) &lt;= target_shape_2d[1]:
            if target_shape_2d[1] % len(close.vbt.wrapper.columns) != 0:
                raise ValueError(&#34;Cannot broadcast close to target_shape&#34;)
            if keys is None:
                keys = pd.Index(np.arange(target_shape_2d[1]), name=&#39;iteration_idx&#39;)
            tile_times = target_shape_2d[1] // len(close.vbt.wrapper.columns)
            close = close.vbt.tile(tile_times, keys=keys)
    close = broadcast(close, to_shape=target_shape, **broadcast_kwargs)
    wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
    cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
    init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
    group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
    if isinstance(active_mask, int):
        _active_mask = np.full((target_shape_2d[0], len(group_lens)), False)
        _active_mask[0::active_mask] = True
        active_mask = _active_mask
    else:
        active_mask = broadcast(
            active_mask,
            to_shape=(target_shape_2d[0], len(group_lens)),
            to_pd=False,
            **require_kwargs
        )
    if checks.is_array(call_seq):
        call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
    else:
        call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
    if max_orders is None:
        max_orders = target_shape_2d[0] * target_shape_2d[1]
    if max_logs is None:
        max_logs = target_shape_2d[0] * target_shape_2d[1]

    # Prepare arguments
    if prep_func_nb is None:
        prep_func_nb = nb.empty_prep_nb
    if prep_args is None:
        prep_args = ()
    if group_prep_func_nb is None:
        group_prep_func_nb = nb.empty_prep_nb
    if group_prep_args is None:
        group_prep_args = ()
    if row_prep_func_nb is None:
        row_prep_func_nb = nb.empty_prep_nb
    if row_prep_args is None:
        row_prep_args = ()
    if segment_prep_func_nb is None:
        segment_prep_func_nb = nb.empty_prep_nb
    if segment_prep_args is None:
        segment_prep_args = ()

    # Perform calculation
    if row_wise:
        order_records, log_records = nb.simulate_row_wise_nb(
            target_shape_2d,
            to_2d(close, raw=True),
            group_lens,
            init_cash,
            cash_sharing,
            call_seq,
            active_mask,
            prep_func_nb,
            prep_args,
            row_prep_func_nb,
            row_prep_args,
            segment_prep_func_nb,
            segment_prep_args,
            order_func_nb,
            order_args,
            max_orders,
            max_logs
        )
    else:
        order_records, log_records = nb.simulate_nb(
            target_shape_2d,
            to_2d(close, raw=True),
            group_lens,
            init_cash,
            cash_sharing,
            call_seq,
            active_mask,
            prep_func_nb,
            prep_args,
            group_prep_func_nb,
            group_prep_args,
            segment_prep_func_nb,
            segment_prep_args,
            order_func_nb,
            order_args,
            max_orders,
            max_logs
        )

    # Create an instance
    return cls(
        wrapper,
        close,
        order_records,
        log_records,
        init_cash if init_cash_mode is None else init_cash_mode,
        cash_sharing,
        call_seq,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.from_orders"><code class="name flex">
<span>def <span class="ident fname">from_orders</span></span>(<span>close, size, size_type=None, direction=None, price=None, fees=None, fixed_fees=None, slippage=None, min_size=None, max_size=None, reject_prob=None, allow_partial=None, raise_reject=None, log=None, val_price=None, init_cash=None, cash_sharing=None, call_seq=None, max_orders=None, max_logs=None, seed=None, group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate portfolio from orders.</p>
<p>Starting with initial cash <code>init_cash</code>, orders the number of shares specified in <code>size</code>
for <code>price</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>close</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>Reference price, such as close.
Will broadcast.</p>
<p>Will be used for calculating unrealized P&amp;L and portfolio value.</p>
</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>
<p>Size to order.
Will broadcast.</p>
<p>Behavior depends upon <code>size_type</code> and <code>direction</code>. For <code>SizeType.Shares</code>:</p>
<ul>
<li>Set to any number to buy/sell some fixed amount of shares.
Longs are limited by cash in the account, while shorts are unlimited.</li>
<li>Set to <code>np.inf</code> to buy shares for all cash, or <code>-np.inf</code> to sell shares for
initial margin of 100%. If <code>direction</code> is not <code>all</code>, <code>-np.inf</code> will close the position.</li>
<li>Set to <code>np.nan</code> or 0 to skip.</li>
</ul>
<p>For any target size:</p>
<ul>
<li>Set to any number to buy/sell amount of shares relative to current holdings or value.</li>
<li>Set to 0 to close the current position.</li>
<li>Set to <code>np.nan</code> to skip.</li>
</ul>
</dd>
<dt><strong><code>size_type</code></strong> :&ensp;<code>SizeType</code> or <code>array_like</code></dt>
<dd>
<p>See <code><a title="vectorbt.portfolio.enums.SizeType" href="enums.html#vectorbt.portfolio.enums.SizeType">SizeType</a></code>.
Will broadcast.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>SizeType.Percent</code> does not support position reversal. Switch to a single direction.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Be cautious using <code>SizeType.Percent</code> with <code>call_seq</code> set to 'auto'.
To execute sell orders before buy orders, the value of each order in the group
needs to be approximated in advance. But since <code>SizeType.Percent</code> depends
upon cash balance, which cannot be calculated in advance, the latest cash balance
is used. This can yield wrong call sequence for buy orders.</p>
</div>
</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>Direction</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.enums.Direction" href="enums.html#vectorbt.portfolio.enums.Direction">Direction</a></code>.
Will broadcast.</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>Order price.
Defaults to <code>close</code>. Will broadcast.</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fees in percentage of the order value.
Will broadcast. Note that 0.01 = 1%.</dd>
<dt><strong><code>fixed_fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fixed amount of fees to pay per order.
Will broadcast.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of price.
Will broadcast. Note that 0.01 = 1%.</dd>
<dt><strong><code>min_size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Minimum size for an order to be accepted.
Will broadcast.</dd>
<dt><strong><code>max_size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>
<p>Maximum size for an order.
Will broadcast.</p>
<p>Will be partially filled if exceeded.</p>
</dd>
<dt><strong><code>reject_prob</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Order rejection probability.
Will broadcast.</dd>
<dt><strong><code>allow_partial</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>
<p>Whether to allow partial fills.
Will broadcast.</p>
<p>Does not apply when size is <code>np.inf</code>.</p>
</dd>
<dt><strong><code>raise_reject</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>Whether to raise an exception if order gets rejected.
Will broadcast.</dd>
<dt><strong><code>log</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>Whether to log orders.
Will broadcast.</dd>
<dt><strong><code>val_price</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>
<p>Asset valuation price.
Defaults to <code>price</code>. Will broadcast.</p>
<p>Used at the time of decision making to calculate value of each asset in the group,
for example, to convert target value into target shares.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Make sure to use timestamp for <code>val_price</code> that comes before timestamps of
all orders in the group with cash sharing (previous <code>close</code> for example),
otherwise you're cheating yourself.</p>
</div>
</dd>
<dt><strong><code>init_cash</code></strong> :&ensp;<code>InitCashMode, float</code> or <code>array_like</code> of <code>float</code></dt>
<dd>
<p>Initial capital.</p>
<p>See <code>init_cash</code> in <code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">Portfolio.from_order_func()</a></code>.</p>
</dd>
<dt><strong><code>cash_sharing</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to share cash within the same group.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Introduces cross-asset dependencies.</p>
<p>This method presumes that in a group of assets that share the same capital all
orders will be executed within the same tick and retain their price regardless
of their position in the queue, even though they depend upon each other and thus
cannot be executed in parallel.</p>
</div>
</dd>
<dt><strong><code>call_seq</code></strong> :&ensp;<code>CallSeqType</code> or <code>array_like</code> of <code>int</code></dt>
<dd>
<p>Default sequence of calls per row and group.</p>
<p>Each value in this sequence should indicate the position of column in the group to
call next. Processing of <code>call_seq</code> goes always from left to right.
For example, <code>[2, 0, 1]</code> would first call column 'c', then 'a', and finally 'b'.</p>
<ul>
<li>Use <code><a title="vectorbt.portfolio.enums.CallSeqType" href="enums.html#vectorbt.portfolio.enums.CallSeqType">CallSeqType</a></code> to select a sequence type.</li>
<li>Set to array to specify custom sequence. Will not broadcast.</li>
</ul>
<p>If <code>CallSeqType.Auto</code> selected, rearranges calls dynamically based on order value.
Calculates value of all orders per row and group, and sorts them by this value.
Sell orders will be executed first to release funds for buy orders.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code>CallSeqType.Auto</code> should be used with caution:</p>
<ul>
<li>It not only presumes that order prices are known beforehand, but also that
orders can be executed in arbitrary order and still retain their price.
In reality, this is hardly the case: after processing one asset, some time
has passed and the price for other assets might have already changed.</li>
<li>Even if you're able to specify a slippage large enough to compensate for
this behavior, slippage itself should depend upon execution order.
This method doesn't let you do that.</li>
<li>If one order is rejected, it still may execute next orders and possibly
leave them without required funds.</li>
</ul>
<p>For more control, use <code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">Portfolio.from_order_func()</a></code>.</p>
</div>
</dd>
<dt><strong><code>max_orders</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Size of the order records array.
Defaults to the number of elements in the broadcasted shape.</p>
<p>Set to a lower number if you run out of memory.</p>
</dd>
<dt><strong><code>max_logs</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Size of the log records array.
Defaults to the number of elements in the broadcasted shape if any of the <code>log</code> is True,
otherwise to 1.</p>
<p>Set to a lower number if you run out of memory.</p>
</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Seed to be set for both <code>call_seq</code> and at the beginning of the simulation.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>broadcast_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.</dd>
<dt><strong><code>wrapper_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Index frequency in case <code>close.index</code> is not datetime-like.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>All broadcastable arguments will be broadcast using <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>
but keep original shape to utilize flexible indexing and to save memory.</p>
<p>For defaults, see <code><a title="vectorbt.settings.portfolio" href="../settings.html#vectorbt.settings.portfolio">portfolio</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When <code>call_seq</code> is not <code>CallSeqType.Auto</code>, at each timestamp, processing of the assets in
a group goes strictly in order defined in <code>call_seq</code>. This order can't be changed dynamically.</p>
<p>This has one big implication for this particular method: the last asset in the call stack
cannot be processed until other assets are processed. This is the reason why rebalancing
cannot work properly in this setting: one has to specify percentages for all assets beforehand
and then tweak the processing order to sell to-be-sold assets first in order to release funds
for to-be-bought assets. This can be automatically done by using <code>CallSeqType.Auto</code>.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>All broadcastable arguments can be set per frame, series, row, column, or element.</p>
</div>
<h2 id="example">Example</h2>
<p>Buy 10 shares each tick:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(close, 10)

&gt;&gt;&gt; portfolio.shares()
0    10.0
1    20.0
2    30.0
3    40.0
4    40.0
dtype: float64
&gt;&gt;&gt; portfolio.cash()
0    90.0
1    70.0
2    40.0
3     0.0
4     0.0
dtype: float64
</code></pre>
<p>Reverse each position by first closing it:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; size = [1, 0, -1, 0, 1]
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(close, size, size_type='targetpercent')

&gt;&gt;&gt; portfolio.shares()
0    100.000000
1      0.000000
2    -66.666667
3      0.000000
4     26.666667
dtype: float64
&gt;&gt;&gt; portfolio.cash()
0      0.000000
1    200.000000
2    400.000000
3    133.333333
4      0.000000
dtype: float64
</code></pre>
<p>Equal-weighted portfolio as in <code><a title="vectorbt.portfolio.nb.simulate_nb" href="nb.html#vectorbt.portfolio.nb.simulate_nb">simulate_nb()</a></code> example:
It's more compact but has less control over execution:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np

&gt;&gt;&gt; np.random.seed(42)
&gt;&gt;&gt; close = pd.DataFrame(np.random.uniform(1, 10, size=(5, 3)))
&gt;&gt;&gt; size = pd.Series(np.full(5, 1/3))  # each column 33.3%
&gt;&gt;&gt; size[1::2] = np.nan  # skip every second tick

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
...     close,  # acts both as reference and order price here
...     size,
...     size_type='targetpercent',
...     call_seq='auto',  # first sell then buy
...     group_by=True,  # one group
...     cash_sharing=True,  # assets share the same cash
...     fees=0.001, fixed_fees=1., slippage=0.001  # costs
... )

&gt;&gt;&gt; portfolio.holding_value(group_by=False).vbt.plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/simulate_nb.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_orders(cls, close, size, size_type=None, direction=None, price=None, fees=None,
                fixed_fees=None, slippage=None, min_size=None, max_size=None, reject_prob=None,
                allow_partial=None, raise_reject=None, log=None, val_price=None, init_cash=None,
                cash_sharing=None, call_seq=None, max_orders=None, max_logs=None, seed=None,
                group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs):
    &#34;&#34;&#34;Simulate portfolio from orders.

    Starting with initial cash `init_cash`, orders the number of shares specified in `size`
    for `price`.

    Args:
        close (array_like): Reference price, such as close.
            Will broadcast.

            Will be used for calculating unrealized P&amp;L and portfolio value.
        size (float or array_like): Size to order.
            Will broadcast.

            Behavior depends upon `size_type` and `direction`. For `SizeType.Shares`:

            * Set to any number to buy/sell some fixed amount of shares.
                Longs are limited by cash in the account, while shorts are unlimited.
            * Set to `np.inf` to buy shares for all cash, or `-np.inf` to sell shares for
                initial margin of 100%. If `direction` is not `all`, `-np.inf` will close the position.
            * Set to `np.nan` or 0 to skip.

            For any target size:

            * Set to any number to buy/sell amount of shares relative to current holdings or value.
            * Set to 0 to close the current position.
            * Set to `np.nan` to skip.
        size_type (SizeType or array_like): See `vectorbt.portfolio.enums.SizeType`.
            Will broadcast.

            !!! note
                `SizeType.Percent` does not support position reversal. Switch to a single direction.

            !!! warning
                Be cautious using `SizeType.Percent` with `call_seq` set to &#39;auto&#39;.
                To execute sell orders before buy orders, the value of each order in the group
                needs to be approximated in advance. But since `SizeType.Percent` depends
                upon cash balance, which cannot be calculated in advance, the latest cash balance
                is used. This can yield wrong call sequence for buy orders.
        direction (Direction or array_like): See `vectorbt.portfolio.enums.Direction`.
            Will broadcast.
        price (array_like of float): Order price.
            Defaults to `close`. Will broadcast.
        fees (float or array_like): Fees in percentage of the order value.
            Will broadcast. Note that 0.01 = 1%.
        fixed_fees (float or array_like): Fixed amount of fees to pay per order.
            Will broadcast.
        slippage (float or array_like): Slippage in percentage of price.
            Will broadcast. Note that 0.01 = 1%.
        min_size (float or array_like): Minimum size for an order to be accepted.
            Will broadcast.
        max_size (float or array_like): Maximum size for an order.
            Will broadcast.

            Will be partially filled if exceeded.
        reject_prob (float or array_like): Order rejection probability.
            Will broadcast.
        allow_partial (bool or array_like): Whether to allow partial fills.
            Will broadcast.

            Does not apply when size is `np.inf`.
        raise_reject (bool or array_like): Whether to raise an exception if order gets rejected.
            Will broadcast.
        log (bool or array_like): Whether to log orders.
            Will broadcast.
        val_price (array_like of float): Asset valuation price.
            Defaults to `price`. Will broadcast.

            Used at the time of decision making to calculate value of each asset in the group,
            for example, to convert target value into target shares.

            !!! note
                Make sure to use timestamp for `val_price` that comes before timestamps of
                all orders in the group with cash sharing (previous `close` for example),
                otherwise you&#39;re cheating yourself.
        init_cash (InitCashMode, float or array_like of float): Initial capital.

            See `init_cash` in `Portfolio.from_order_func`.
        cash_sharing (bool): Whether to share cash within the same group.

            !!! warning
                Introduces cross-asset dependencies.

                This method presumes that in a group of assets that share the same capital all
                orders will be executed within the same tick and retain their price regardless
                of their position in the queue, even though they depend upon each other and thus
                cannot be executed in parallel.
        call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

            Each value in this sequence should indicate the position of column in the group to
            call next. Processing of `call_seq` goes always from left to right.
            For example, `[2, 0, 1]` would first call column &#39;c&#39;, then &#39;a&#39;, and finally &#39;b&#39;.

            * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
            * Set to array to specify custom sequence. Will not broadcast.

            If `CallSeqType.Auto` selected, rearranges calls dynamically based on order value.
            Calculates value of all orders per row and group, and sorts them by this value.
            Sell orders will be executed first to release funds for buy orders.

            !!! warning
                `CallSeqType.Auto` should be used with caution:

                * It not only presumes that order prices are known beforehand, but also that
                    orders can be executed in arbitrary order and still retain their price.
                    In reality, this is hardly the case: after processing one asset, some time
                    has passed and the price for other assets might have already changed.
                * Even if you&#39;re able to specify a slippage large enough to compensate for
                    this behavior, slippage itself should depend upon execution order.
                    This method doesn&#39;t let you do that.
                * If one order is rejected, it still may execute next orders and possibly
                    leave them without required funds.

                For more control, use `Portfolio.from_order_func`.
        max_orders (int): Size of the order records array.
            Defaults to the number of elements in the broadcasted shape.

            Set to a lower number if you run out of memory.
        max_logs (int): Size of the log records array.
            Defaults to the number of elements in the broadcasted shape if any of the `log` is True,
            otherwise to 1.

            Set to a lower number if you run out of memory.
        seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
        group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
        wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
        freq (any): Index frequency in case `close.index` is not datetime-like.
        **kwargs: Keyword arguments passed to the `__init__` method.

    All broadcastable arguments will be broadcast using `vectorbt.base.reshape_fns.broadcast`
    but keep original shape to utilize flexible indexing and to save memory.

    For defaults, see `vectorbt.settings.portfolio`.

    !!! note
        When `call_seq` is not `CallSeqType.Auto`, at each timestamp, processing of the assets in
        a group goes strictly in order defined in `call_seq`. This order can&#39;t be changed dynamically.

        This has one big implication for this particular method: the last asset in the call stack
        cannot be processed until other assets are processed. This is the reason why rebalancing
        cannot work properly in this setting: one has to specify percentages for all assets beforehand
        and then tweak the processing order to sell to-be-sold assets first in order to release funds
        for to-be-bought assets. This can be automatically done by using `CallSeqType.Auto`.

    !!! hint
        All broadcastable arguments can be set per frame, series, row, column, or element.

    ## Example

    Buy 10 shares each tick:
    ```python-repl
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(close, 10)

    &gt;&gt;&gt; portfolio.shares()
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    40.0
    dtype: float64
    &gt;&gt;&gt; portfolio.cash()
    0    90.0
    1    70.0
    2    40.0
    3     0.0
    4     0.0
    dtype: float64
    ```

    Reverse each position by first closing it:
    ```python-repl
    &gt;&gt;&gt; size = [1, 0, -1, 0, 1]
    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(close, size, size_type=&#39;targetpercent&#39;)

    &gt;&gt;&gt; portfolio.shares()
    0    100.000000
    1      0.000000
    2    -66.666667
    3      0.000000
    4     26.666667
    dtype: float64
    &gt;&gt;&gt; portfolio.cash()
    0      0.000000
    1    200.000000
    2    400.000000
    3    133.333333
    4      0.000000
    dtype: float64
    ```

    Equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb` example:
    It&#39;s more compact but has less control over execution:

    ```python-repl
    &gt;&gt;&gt; import numpy as np

    &gt;&gt;&gt; np.random.seed(42)
    &gt;&gt;&gt; close = pd.DataFrame(np.random.uniform(1, 10, size=(5, 3)))
    &gt;&gt;&gt; size = pd.Series(np.full(5, 1/3))  # each column 33.3%
    &gt;&gt;&gt; size[1::2] = np.nan  # skip every second tick

    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
    ...     close,  # acts both as reference and order price here
    ...     size,
    ...     size_type=&#39;targetpercent&#39;,
    ...     call_seq=&#39;auto&#39;,  # first sell then buy
    ...     group_by=True,  # one group
    ...     cash_sharing=True,  # assets share the same cash
    ...     fees=0.001, fixed_fees=1., slippage=0.001  # costs
    ... )

    &gt;&gt;&gt; portfolio.holding_value(group_by=False).vbt.plot()
    ```

    ![](/vectorbt/docs/img/simulate_nb.png)
    &#34;&#34;&#34;
    # Get defaults
    from vectorbt import settings

    if size is None:
        size = settings.portfolio[&#39;size&#39;]
    if size_type is None:
        size_type = settings.portfolio[&#39;size_type&#39;]
    size_type = convert_str_enum_value(SizeType, size_type)
    if direction is None:
        direction = settings.portfolio[&#39;order_direction&#39;]
    direction = convert_str_enum_value(Direction, direction)
    if price is None:
        price = close
    if fees is None:
        fees = settings.portfolio[&#39;fees&#39;]
    if fixed_fees is None:
        fixed_fees = settings.portfolio[&#39;fixed_fees&#39;]
    if slippage is None:
        slippage = settings.portfolio[&#39;slippage&#39;]
    if min_size is None:
        min_size = settings.portfolio[&#39;min_size&#39;]
    if max_size is None:
        max_size = settings.portfolio[&#39;max_size&#39;]
    if reject_prob is None:
        reject_prob = settings.portfolio[&#39;reject_prob&#39;]
    if allow_partial is None:
        allow_partial = settings.portfolio[&#39;allow_partial&#39;]
    if raise_reject is None:
        raise_reject = settings.portfolio[&#39;raise_reject&#39;]
    if log is None:
        log = settings.portfolio[&#39;log&#39;]
    if val_price is None:
        val_price = price
    if init_cash is None:
        init_cash = settings.portfolio[&#39;init_cash&#39;]
    init_cash = convert_str_enum_value(InitCashMode, init_cash)
    if isinstance(init_cash, int) and init_cash in InitCashMode:
        init_cash_mode = init_cash
        init_cash = np.inf
    else:
        init_cash_mode = None
    if cash_sharing is None:
        cash_sharing = settings.portfolio[&#39;cash_sharing&#39;]
    if call_seq is None:
        call_seq = settings.portfolio[&#39;call_seq&#39;]
    call_seq = convert_str_enum_value(CallSeqType, call_seq)
    auto_call_seq = False
    if isinstance(call_seq, int):
        if call_seq == CallSeqType.Auto:
            call_seq = CallSeqType.Default
            auto_call_seq = True
    if seed is None:
        seed = settings.portfolio[&#39;seed&#39;]
    if seed is not None:
        set_seed(seed)
    if freq is None:
        freq = settings.portfolio[&#39;freq&#39;]
    if broadcast_kwargs is None:
        broadcast_kwargs = {}
    if wrapper_kwargs is None:
        wrapper_kwargs = {}
    if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
        raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

    # Broadcast inputs
    # Only close is broadcast, others can remain unchanged thanks to flexible indexing
    broadcastable_args = (
        close,
        size,
        size_type,
        direction,
        price,
        fees,
        fixed_fees,
        slippage,
        min_size,
        max_size,
        reject_prob,
        allow_partial,
        raise_reject,
        log,
        val_price
    )
    keep_raw = [False] + [True] * (len(broadcastable_args) - 1)
    broadcast_kwargs = merge_dicts(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
    broadcasted_args = broadcast(*broadcastable_args, **broadcast_kwargs, keep_raw=keep_raw)
    close = broadcasted_args[0]
    if not checks.is_pandas(close):
        close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
    target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
    wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
    cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
    init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
    group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
    if checks.is_array(call_seq):
        call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
    else:
        call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
    if max_orders is None:
        max_orders = target_shape_2d[0] * target_shape_2d[1]
    if max_logs is None:
        max_logs = target_shape_2d[0] * target_shape_2d[1]
    if not np.any(log):
        max_logs = 1

    # Perform calculation
    order_records, log_records = nb.simulate_from_orders_nb(
        target_shape_2d,
        cs_group_lens,  # group only if cash sharing is enabled to speed up
        init_cash,
        call_seq,
        auto_call_seq,
        *broadcasted_args[1:],
        max_orders,
        max_logs,
        close.ndim == 2
    )

    # Create an instance
    return cls(
        wrapper,
        close,
        order_records,
        log_records,
        init_cash if init_cash_mode is None else init_cash_mode,
        cash_sharing,
        call_seq,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.from_random"><code class="name flex">
<span>def <span class="ident fname">from_random</span></span>(<span>close, n=None, prob=None, entry_prob=None, exit_prob=None, param_product=False, seed=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate portfolio from random entry and exit signals.</p>
<p>Generates signals based either on the number of signals <code>n</code> or the probability
of encountering a signal <code>prob</code>.</p>
<p>If <code>n</code> is set, see <code><a title="vectorbt.signals.basic.RAND" href="../signals/basic.html#vectorbt.signals.basic.RAND">RAND</a></code>.
If <code>prob</code> is set, see <code><a title="vectorbt.signals.basic.RPROB" href="../signals/basic.html#vectorbt.signals.basic.RPROB">RPROB</a></code>.</p>
<p>Based on <code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">Portfolio.from_signals()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_random(cls, close, n=None, prob=None, entry_prob=None, exit_prob=None,
                param_product=False, seed=None, **kwargs):
    &#34;&#34;&#34;Simulate portfolio from random entry and exit signals.

    Generates signals based either on the number of signals `n` or the probability
    of encountering a signal `prob`.

    If `n` is set, see `vectorbt.signals.basic.RAND`.
    If `prob` is set, see `vectorbt.signals.basic.RPROB`.

    Based on `Portfolio.from_signals`.&#34;&#34;&#34;
    from vectorbt import settings

    if entry_prob is None:
        entry_prob = prob
    if exit_prob is None:
        exit_prob = prob
    if seed is None:
        seed = settings.portfolio[&#39;seed&#39;]

    if n is not None and (entry_prob is not None or exit_prob is not None):
        raise ValueError(&#34;Either n or entry_prob and exit_prob should be set&#34;)
    if n is not None:
        rand = RAND.run(
            n=n,
            input_shape=close.shape,
            input_index=close.vbt.wrapper.index,
            input_columns=close.vbt.wrapper.columns,
            seed=seed
        )
        entries = rand.entries
        exits = rand.exits
    elif entry_prob is not None and exit_prob is not None:
        rprob = RPROB.run(
            entry_prob=entry_prob,
            exit_prob=exit_prob,
            param_product=param_product,
            input_shape=close.shape,
            input_index=close.vbt.wrapper.index,
            input_columns=close.vbt.wrapper.columns,
            seed=seed
        )
        entries = rprob.entries
        exits = rprob.exits
    else:
        raise ValueError(&#34;At least n or entry_prob and exit_prob should be set&#34;)

    return cls.from_signals(close, entries, exits, seed=seed, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.from_signals"><code class="name flex">
<span>def <span class="ident fname">from_signals</span></span>(<span>close, entries, exits, size=None, size_type=None, direction=None, price=None, fees=None, fixed_fees=None, slippage=None, min_size=None, max_size=None, reject_prob=None, allow_partial=None, raise_reject=None, accumulate=None, log=None, conflict_mode=None, close_first=None, val_price=None, init_cash=None, cash_sharing=None, call_seq=None, max_orders=None, max_logs=None, seed=None, group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate portfolio from entry and exit signals.</p>
<p>Starting with initial cash <code>init_cash</code>, for each signal in <code>entries</code>, enters a long/short position
by buying/selling <code>size</code> of shares. For each signal in <code>exits</code>, closes the position by
selling/buying shares. Depending upon accumulation, each entry signal may increase
the position and each exit signal may decrease the position. When both entry and exit signals
are present, ignores them by default. When grouping is enabled with <code>group_by</code>, will compute
the performance of the entire group. When <code>cash_sharing</code> is enabled, will share the cash among
all columns in the group.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>close</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>Reference price, such as close.
Will broadcast.</p>
<p>Will be used for calculating unrealized P&amp;L and portfolio value.</p>
</dd>
<dt><strong><code>entries</code></strong> :&ensp;<code>array_like</code> of <code>bool</code></dt>
<dd>
<p>Boolean array of entry signals.
Will broadcast.</p>
<p>Becomes a long signal if <code>direction</code> is <code>all</code> or <code>longonly</code>, otherwise short.</p>
</dd>
<dt><strong><code>exits</code></strong> :&ensp;<code>array_like</code> of <code>bool</code></dt>
<dd>
<p>Boolean array of exit signals.
Will broadcast.</p>
<p>Becomes a short signal if <code>direction</code> is <code>all</code> or <code>longonly</code>, otherwise long.</p>
</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>
<p>Size to order.
Will broadcast.</p>
<ul>
<li>Set to any number to buy/sell some fixed amount of shares.
Longs are limited by cash in the account, while shorts are unlimited.</li>
<li>Set to <code>np.inf</code> to buy shares for all cash, or <code>-np.inf</code> to sell shares for
initial margin of 100%. If <code>direction</code> is not <code>all</code>, <code>-np.inf</code> will close the position.</li>
<li>Set to <code>np.nan</code> or 0 to skip.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Sign will be ignored.</p>
</div>
</dd>
<dt><strong><code>size_type</code></strong> :&ensp;<code>SizeType</code> or <code>array_like</code></dt>
<dd>
<p>See <code><a title="vectorbt.portfolio.enums.SizeType" href="enums.html#vectorbt.portfolio.enums.SizeType">SizeType</a></code>.
Will broadcast.</p>
<p>Only <code>SizeType.Shares</code> and <code>SizeType.Percent</code> are supported.
Other modes such as target percentage are not compatible with signals since
their logic may contradict the direction of the signal.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>SizeType.Percent</code> does not support position reversal. Switch to a single
direction or use <code>close_first</code>.</p>
</div>
<p>See warning on <code>size_type</code> in <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>Direction</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.enums.Direction" href="enums.html#vectorbt.portfolio.enums.Direction">Direction</a></code>.
Will broadcast.</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>Order price.
Defaults to <code>close</code>. Will broadcast.</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fees in percentage of the order value.
Will broadcast. Note that 0.01 = 1%.</dd>
<dt><strong><code>fixed_fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fixed amount of fees to pay per order.
Will broadcast.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of price.
Will broadcast. Note that 0.01 = 1%.</dd>
<dt><strong><code>min_size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Minimum size for an order to be accepted.
Will broadcast.</dd>
<dt><strong><code>max_size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>
<p>Maximum size for an order.
Will broadcast.</p>
<p>Will be partially filled if exceeded. You might not be able to properly close
the position if accumulation is enabled and <code>max_size</code> is too low.</p>
</dd>
<dt><strong><code>reject_prob</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Order rejection probability.
Will broadcast.</dd>
<dt><strong><code>allow_partial</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>
<p>Whether to allow partial fills.
Will broadcast.</p>
<p>Does not apply when size is <code>np.inf</code>.</p>
</dd>
<dt><strong><code>raise_reject</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>Whether to raise an exception if order gets rejected.
Will broadcast.</dd>
<dt><strong><code>log</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>Whether to log orders.
Will broadcast.</dd>
<dt><strong><code>accumulate</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>
<p>Whether to accumulate signals.
Will broadcast.</p>
<p>Behaves similarly to <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
</dd>
<dt><strong><code>conflict_mode</code></strong> :&ensp;<code>ConflictMode</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.enums.ConflictMode" href="enums.html#vectorbt.portfolio.enums.ConflictMode">ConflictMode</a></code>.
Will broadcast.</dd>
<dt><strong><code>close_first</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>
<p>Whether to close the position first before reversal.
Will broadcast.</p>
<p>Otherwise reverses the position with a single order and within the same tick.
Takes only effect under <code>Direction.All</code>. Requires a second signal to enter
the opposite position. This allows to define parameters such as <code>fixed_fees</code> for long
and short positions separately.</p>
</dd>
<dt><strong><code>val_price</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>
<p>Asset valuation price.
Defaults to <code>price</code> if set, otherwise to previous <code>close</code>.</p>
<p>See <code>val_price</code> in <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
</dd>
<dt><strong><code>init_cash</code></strong> :&ensp;<code>InitCashMode, float</code> or <code>array_like</code> of <code>float</code></dt>
<dd>
<p>Initial capital.</p>
<p>See <code>init_cash</code> in <code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">Portfolio.from_order_func()</a></code>.</p>
</dd>
<dt><strong><code>cash_sharing</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to share cash within the same group.</p>
<p>See <code>cash_sharing</code> in <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
</dd>
<dt><strong><code>call_seq</code></strong> :&ensp;<code>CallSeqType</code> or <code>array_like</code> of <code>int</code></dt>
<dd>
<p>Default sequence of calls per row and group.</p>
<p>See <code>call_seq</code> in <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
</dd>
<dt><strong><code>max_orders</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Size of the order records array.
Defaults to the number of elements in the broadcasted shape.</p>
<p>Set to a lower number if you run out of memory.</p>
</dd>
<dt><strong><code>max_logs</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Size of the log records array.
Defaults to the number of elements in the broadcasted shape if any of the <code>log</code> is True,
otherwise to 1.</p>
<p>Set to a lower number if you run out of memory.</p>
</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Seed to be set for both <code>call_seq</code> and at the beginning of the simulation.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>broadcast_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.</dd>
<dt><strong><code>wrapper_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Index frequency in case <code>close.index</code> is not datetime-like.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>All broadcastable arguments will be broadcast using <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>
but keep original shape to utilize flexible indexing and to save memory.</p>
<p>For defaults, see <code><a title="vectorbt.settings.portfolio" href="../settings.html#vectorbt.settings.portfolio">portfolio</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>If you generated signals using close price, don't forget to shift your signals by one tick
forward, for example, with <code>signals.vbt.fshift(1)</code>. In general, make sure to use a price
that comes after the signal.</p>
</div>
<p>Also see notes and hints for <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
<h2 id="example">Example</h2>
<p>Some of the ways of how signals are interpreted:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
&gt;&gt;&gt; entries = pd.Series([True, True, True, False, False])
&gt;&gt;&gt; exits = pd.Series([False, False, True, True, True])

&gt;&gt;&gt; # Entry opens long, exit closes long
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
...     close, entries, exits, size=1., direction='longonly')
&gt;&gt;&gt; portfolio.share_flow()
0    1.0
1    0.0
2    0.0
3   -1.0
4    0.0
dtype: float64

&gt;&gt;&gt; # Entry opens short, exit closes short
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
...     close, entries, exits, size=1., direction='shortonly')
&gt;&gt;&gt; portfolio.share_flow()
0   -1.0
1    0.0
2    0.0
3    1.0
4    0.0
dtype: float64

&gt;&gt;&gt; # Entry opens long and closes short, exit closes long and opens short
&gt;&gt;&gt; # Reversal within one tick
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
...     close, entries, exits, size=1., direction='all')
&gt;&gt;&gt; portfolio.share_flow()
0    1.0
1    0.0
2    0.0
3   -2.0
4    0.0
dtype: float64

&gt;&gt;&gt; # Reversal within two ticks
&gt;&gt;&gt; # First signal closes position, second signal opens the opposite one
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
...     close, entries, exits, size=1., direction='all',
...     close_first=True)
&gt;&gt;&gt; portfolio.share_flow()
0    1.0
1    0.0
2    0.0
3   -1.0
4   -1.0
dtype: float64

&gt;&gt;&gt; # If entry and exit, chooses exit
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
...     close, entries, exits, size=1., direction='all',
...     close_first=True, conflict_mode='exit')
&gt;&gt;&gt; portfolio.share_flow()
0    1.0
1    0.0
2   -1.0
3   -1.0
4    0.0
dtype: float64

&gt;&gt;&gt; # Entry means long order, exit means short order
&gt;&gt;&gt; # Acts similar to `from_orders`
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
...     close, entries, exits, size=1., direction='all',
...     accumulate=True)
&gt;&gt;&gt; portfolio.share_flow()
0    1.0
1    1.0
2    0.0
3   -1.0
4   -1.0
dtype: float64

&gt;&gt;&gt; # Testing multiple parameters (via broadcasting)
&gt;&gt;&gt; from vectorbt.portfolio.enums import Direction

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
...     close, entries, exits, direction=[list(Direction)],
...     broadcast_kwargs=dict(columns_from=Direction._fields))
&gt;&gt;&gt; portfolio.share_flow()
    Long  Short    All
0  100.0 -100.0  100.0
1    0.0    0.0    0.0
2    0.0    0.0    0.0
3 -100.0   50.0 -200.0
4    0.0    0.0    0.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_signals(cls, close, entries, exits, size=None, size_type=None, direction=None, price=None,
                 fees=None, fixed_fees=None, slippage=None, min_size=None, max_size=None,
                 reject_prob=None, allow_partial=None, raise_reject=None, accumulate=None, log=None,
                 conflict_mode=None, close_first=None, val_price=None, init_cash=None, cash_sharing=None,
                 call_seq=None, max_orders=None, max_logs=None, seed=None, group_by=None,
                 broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs):
    &#34;&#34;&#34;Simulate portfolio from entry and exit signals.

    Starting with initial cash `init_cash`, for each signal in `entries`, enters a long/short position
    by buying/selling `size` of shares. For each signal in `exits`, closes the position by
    selling/buying shares. Depending upon accumulation, each entry signal may increase
    the position and each exit signal may decrease the position. When both entry and exit signals
    are present, ignores them by default. When grouping is enabled with `group_by`, will compute
    the performance of the entire group. When `cash_sharing` is enabled, will share the cash among
    all columns in the group.

    Args:
        close (array_like): Reference price, such as close.
            Will broadcast.

            Will be used for calculating unrealized P&amp;L and portfolio value.
        entries (array_like of bool): Boolean array of entry signals.
            Will broadcast.

            Becomes a long signal if `direction` is `all` or `longonly`, otherwise short.
        exits (array_like of bool): Boolean array of exit signals.
            Will broadcast.

            Becomes a short signal if `direction` is `all` or `longonly`, otherwise long.
        size (float or array_like): Size to order.
            Will broadcast.

            * Set to any number to buy/sell some fixed amount of shares.
                Longs are limited by cash in the account, while shorts are unlimited.
            * Set to `np.inf` to buy shares for all cash, or `-np.inf` to sell shares for
                initial margin of 100%. If `direction` is not `all`, `-np.inf` will close the position.
            * Set to `np.nan` or 0 to skip.

            !!! note
                Sign will be ignored.
        size_type (SizeType or array_like): See `vectorbt.portfolio.enums.SizeType`.
            Will broadcast.

            Only `SizeType.Shares` and `SizeType.Percent` are supported.
            Other modes such as target percentage are not compatible with signals since
            their logic may contradict the direction of the signal.

            !!! note
                `SizeType.Percent` does not support position reversal. Switch to a single
                direction or use `close_first`.

            See warning on `size_type` in `Portfolio.from_orders`.
        direction (Direction or array_like): See `vectorbt.portfolio.enums.Direction`.
            Will broadcast.
        price (array_like of float): Order price.
            Defaults to `close`. Will broadcast.
        fees (float or array_like): Fees in percentage of the order value.
            Will broadcast. Note that 0.01 = 1%.
        fixed_fees (float or array_like): Fixed amount of fees to pay per order.
            Will broadcast.
        slippage (float or array_like): Slippage in percentage of price.
            Will broadcast. Note that 0.01 = 1%.
        min_size (float or array_like): Minimum size for an order to be accepted.
            Will broadcast.
        max_size (float or array_like): Maximum size for an order.
            Will broadcast.

            Will be partially filled if exceeded. You might not be able to properly close
            the position if accumulation is enabled and `max_size` is too low.
        reject_prob (float or array_like): Order rejection probability.
            Will broadcast.
        allow_partial (bool or array_like): Whether to allow partial fills.
            Will broadcast.

            Does not apply when size is `np.inf`.
        raise_reject (bool or array_like): Whether to raise an exception if order gets rejected.
            Will broadcast.
        log (bool or array_like): Whether to log orders.
            Will broadcast.
        accumulate (bool or array_like): Whether to accumulate signals.
            Will broadcast.

            Behaves similarly to `Portfolio.from_orders`.
        conflict_mode (ConflictMode or array_like): See `vectorbt.portfolio.enums.ConflictMode`.
            Will broadcast.
        close_first (bool or array_like): Whether to close the position first before reversal.
            Will broadcast.

            Otherwise reverses the position with a single order and within the same tick.
            Takes only effect under `Direction.All`. Requires a second signal to enter
            the opposite position. This allows to define parameters such as `fixed_fees` for long
            and short positions separately.
        val_price (array_like of float): Asset valuation price.
            Defaults to `price` if set, otherwise to previous `close`.

            See `val_price` in `Portfolio.from_orders`.
        init_cash (InitCashMode, float or array_like of float): Initial capital.

            See `init_cash` in `Portfolio.from_order_func`.
        cash_sharing (bool): Whether to share cash within the same group.

            See `cash_sharing` in `Portfolio.from_orders`.
        call_seq (CallSeqType or array_like of int): Default sequence of calls per row and group.

            See `call_seq` in `Portfolio.from_orders`.
        max_orders (int): Size of the order records array.
            Defaults to the number of elements in the broadcasted shape.

            Set to a lower number if you run out of memory.
        max_logs (int): Size of the log records array.
            Defaults to the number of elements in the broadcasted shape if any of the `log` is True,
            otherwise to 1.

            Set to a lower number if you run out of memory.
        seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
        group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
        wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
        freq (any): Index frequency in case `close.index` is not datetime-like.
        **kwargs: Keyword arguments passed to the `__init__` method.

    All broadcastable arguments will be broadcast using `vectorbt.base.reshape_fns.broadcast`
    but keep original shape to utilize flexible indexing and to save memory.

    For defaults, see `vectorbt.settings.portfolio`.

    !!! hint
        If you generated signals using close price, don&#39;t forget to shift your signals by one tick
        forward, for example, with `signals.vbt.fshift(1)`. In general, make sure to use a price
        that comes after the signal.

    Also see notes and hints for `Portfolio.from_orders`.

    ## Example

    Some of the ways of how signals are interpreted:

    ```python-repl
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
    &gt;&gt;&gt; entries = pd.Series([True, True, True, False, False])
    &gt;&gt;&gt; exits = pd.Series([False, False, True, True, True])

    &gt;&gt;&gt; # Entry opens long, exit closes long
    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
    ...     close, entries, exits, size=1., direction=&#39;longonly&#39;)
    &gt;&gt;&gt; portfolio.share_flow()
    0    1.0
    1    0.0
    2    0.0
    3   -1.0
    4    0.0
    dtype: float64

    &gt;&gt;&gt; # Entry opens short, exit closes short
    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
    ...     close, entries, exits, size=1., direction=&#39;shortonly&#39;)
    &gt;&gt;&gt; portfolio.share_flow()
    0   -1.0
    1    0.0
    2    0.0
    3    1.0
    4    0.0
    dtype: float64

    &gt;&gt;&gt; # Entry opens long and closes short, exit closes long and opens short
    &gt;&gt;&gt; # Reversal within one tick
    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
    ...     close, entries, exits, size=1., direction=&#39;all&#39;)
    &gt;&gt;&gt; portfolio.share_flow()
    0    1.0
    1    0.0
    2    0.0
    3   -2.0
    4    0.0
    dtype: float64

    &gt;&gt;&gt; # Reversal within two ticks
    &gt;&gt;&gt; # First signal closes position, second signal opens the opposite one
    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
    ...     close, entries, exits, size=1., direction=&#39;all&#39;,
    ...     close_first=True)
    &gt;&gt;&gt; portfolio.share_flow()
    0    1.0
    1    0.0
    2    0.0
    3   -1.0
    4   -1.0
    dtype: float64

    &gt;&gt;&gt; # If entry and exit, chooses exit
    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
    ...     close, entries, exits, size=1., direction=&#39;all&#39;,
    ...     close_first=True, conflict_mode=&#39;exit&#39;)
    &gt;&gt;&gt; portfolio.share_flow()
    0    1.0
    1    0.0
    2   -1.0
    3   -1.0
    4    0.0
    dtype: float64

    &gt;&gt;&gt; # Entry means long order, exit means short order
    &gt;&gt;&gt; # Acts similar to `from_orders`
    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
    ...     close, entries, exits, size=1., direction=&#39;all&#39;,
    ...     accumulate=True)
    &gt;&gt;&gt; portfolio.share_flow()
    0    1.0
    1    1.0
    2    0.0
    3   -1.0
    4   -1.0
    dtype: float64

    &gt;&gt;&gt; # Testing multiple parameters (via broadcasting)
    &gt;&gt;&gt; from vectorbt.portfolio.enums import Direction

    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
    ...     close, entries, exits, direction=[list(Direction)],
    ...     broadcast_kwargs=dict(columns_from=Direction._fields))
    &gt;&gt;&gt; portfolio.share_flow()
        Long  Short    All
    0  100.0 -100.0  100.0
    1    0.0    0.0    0.0
    2    0.0    0.0    0.0
    3 -100.0   50.0 -200.0
    4    0.0    0.0    0.0
    ```
    &#34;&#34;&#34;
    # Get defaults
    from vectorbt import settings

    if size is None:
        size = settings.portfolio[&#39;size&#39;]
    if size_type is None:
        size_type = settings.portfolio[&#39;signal_size_type&#39;]
    size_type = convert_str_enum_value(SizeType, size_type)
    if direction is None:
        direction = settings.portfolio[&#39;signal_direction&#39;]
    direction = convert_str_enum_value(Direction, direction)
    if price is None:
        price = close
    if fees is None:
        fees = settings.portfolio[&#39;fees&#39;]
    if fixed_fees is None:
        fixed_fees = settings.portfolio[&#39;fixed_fees&#39;]
    if slippage is None:
        slippage = settings.portfolio[&#39;slippage&#39;]
    if min_size is None:
        min_size = settings.portfolio[&#39;min_size&#39;]
    if max_size is None:
        max_size = settings.portfolio[&#39;max_size&#39;]
    if reject_prob is None:
        reject_prob = settings.portfolio[&#39;reject_prob&#39;]
    if allow_partial is None:
        allow_partial = settings.portfolio[&#39;allow_partial&#39;]
    if raise_reject is None:
        raise_reject = settings.portfolio[&#39;raise_reject&#39;]
    if log is None:
        log = settings.portfolio[&#39;log&#39;]
    if accumulate is None:
        accumulate = settings.portfolio[&#39;accumulate&#39;]
    if conflict_mode is None:
        conflict_mode = settings.portfolio[&#39;conflict_mode&#39;]
    conflict_mode = convert_str_enum_value(ConflictMode, conflict_mode)
    if close_first is None:
        close_first = settings.portfolio[&#39;close_first&#39;]
    if val_price is None:
        if price is None:
            if checks.is_pandas(close):
                val_price = close.vbt.fshift(1)
            else:
                val_price = np.require(close, dtype=np.float_)
                val_price = np.roll(val_price, 1, axis=0)
                val_price[0] = np.nan
        else:
            val_price = price
    if init_cash is None:
        init_cash = settings.portfolio[&#39;init_cash&#39;]
    init_cash = convert_str_enum_value(InitCashMode, init_cash)
    if isinstance(init_cash, int) and init_cash in InitCashMode:
        init_cash_mode = init_cash
        init_cash = np.inf
    else:
        init_cash_mode = None
    if cash_sharing is None:
        cash_sharing = settings.portfolio[&#39;cash_sharing&#39;]
    if call_seq is None:
        call_seq = settings.portfolio[&#39;call_seq&#39;]
    call_seq = convert_str_enum_value(CallSeqType, call_seq)
    auto_call_seq = False
    if isinstance(call_seq, int):
        if call_seq == CallSeqType.Auto:
            call_seq = CallSeqType.Default
            auto_call_seq = True
    if seed is None:
        seed = settings.portfolio[&#39;seed&#39;]
    if seed is not None:
        set_seed(seed)
    if freq is None:
        freq = settings.portfolio[&#39;freq&#39;]
    if broadcast_kwargs is None:
        broadcast_kwargs = {}
    if wrapper_kwargs is None:
        wrapper_kwargs = {}
    if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
        raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

    # Broadcast inputs
    # Only close is broadcast, others can remain unchanged thanks to flexible indexing
    broadcastable_args = (
        close,
        entries,
        exits,
        size,
        size_type,
        direction,
        price,
        fees,
        fixed_fees,
        slippage,
        min_size,
        max_size,
        reject_prob,
        allow_partial,
        raise_reject,
        accumulate,
        log,
        conflict_mode,
        close_first,
        val_price
    )
    keep_raw = [False] + [True] * (len(broadcastable_args) - 1)
    broadcast_kwargs = merge_dicts(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
    broadcasted_args = broadcast(*broadcastable_args, **broadcast_kwargs, keep_raw=keep_raw)
    close = broadcasted_args[0]
    if not checks.is_pandas(close):
        close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
    target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
    wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
    cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
    init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
    group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
    if checks.is_array(call_seq):
        call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
    else:
        call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
    if max_orders is None:
        max_orders = target_shape_2d[0] * target_shape_2d[1]
    if max_logs is None:
        max_logs = target_shape_2d[0] * target_shape_2d[1]
    if not np.any(log):
        max_logs = 1

    # Perform calculation
    order_records, log_records = nb.simulate_from_signals_nb(
        target_shape_2d,
        cs_group_lens,  # group only if cash sharing is enabled to speed up
        init_cash,
        call_seq,
        auto_call_seq,
        *broadcasted_args[1:],
        max_orders,
        max_logs,
        close.ndim == 2
    )

    # Create an instance
    return cls(
        wrapper,
        close,
        order_records,
        log_records,
        init_cash if init_cash_mode is None else init_cash_mode,
        cash_sharing,
        call_seq,
        **kwargs
    )</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio.call_seq"><code class="name">var <span class="ident fname">call_seq</span></code></dt>
<dd>
<div class="desc"><p>Sequence of calls per row and group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def call_seq(self):
    &#34;&#34;&#34;Sequence of calls per row and group.&#34;&#34;&#34;
    return self.wrapper.wrap(self._call_seq, group_by=False)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cash_sharing"><code class="name">var <span class="ident fname">cash_sharing</span></code></dt>
<dd>
<div class="desc"><p>Whether to share cash within the same group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cash_sharing(self):
    &#34;&#34;&#34;Whether to share cash within the same group.&#34;&#34;&#34;
    return self._cash_sharing</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Price per share series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def close(self):
    &#34;&#34;&#34;Price per share series.&#34;&#34;&#34;
    return self._close</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.drawdowns"><code class="name">var <span class="ident fname">drawdowns</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.portfolio.base.Portfolio.get_drawdowns" href="#vectorbt.portfolio.base.Portfolio.get_drawdowns">Portfolio.get_drawdowns()</a></code> with default arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.incl_unrealized"><code class="name">var <span class="ident fname">incl_unrealized</span></code></dt>
<dd>
<div class="desc"><p>Whether to include unrealized trade P&amp;L in statistics.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def incl_unrealized(self):
    &#34;&#34;&#34;Whether to include unrealized trade P&amp;L in statistics.&#34;&#34;&#34;
    return self._incl_unrealized</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.init_cash"><code class="name">var <span class="ident fname">init_cash</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.portfolio.base.Portfolio.get_init_cash" href="#vectorbt.portfolio.base.Portfolio.get_init_cash">Portfolio.get_init_cash()</a></code> with default arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.log_records"><code class="name">var <span class="ident fname">log_records</span></code></dt>
<dd>
<div class="desc"><p>A structured NumPy array of log records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def log_records(self):
    &#34;&#34;&#34;A structured NumPy array of log records.&#34;&#34;&#34;
    return self._log_records</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.logs"><code class="name">var <span class="ident fname">logs</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.portfolio.base.Portfolio.get_logs" href="#vectorbt.portfolio.base.Portfolio.get_logs">Portfolio.get_logs()</a></code> with default arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.order_records"><code class="name">var <span class="ident fname">order_records</span></code></dt>
<dd>
<div class="desc"><p>A structured NumPy array of order records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def order_records(self):
    &#34;&#34;&#34;A structured NumPy array of order records.&#34;&#34;&#34;
    return self._order_records</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.orders"><code class="name">var <span class="ident fname">orders</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.portfolio.base.Portfolio.get_orders" href="#vectorbt.portfolio.base.Portfolio.get_orders">Portfolio.get_orders()</a></code> with default arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.positions"><code class="name">var <span class="ident fname">positions</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.portfolio.base.Portfolio.get_positions" href="#vectorbt.portfolio.base.Portfolio.get_positions">Portfolio.get_positions()</a></code> with default arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.trades"><code class="name">var <span class="ident fname">trades</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.portfolio.base.Portfolio.get_trades" href="#vectorbt.portfolio.base.Portfolio.get_trades">Portfolio.get_trades()</a></code> with default arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.use_filled_close"><code class="name">var <span class="ident fname">use_filled_close</span></code></dt>
<dd>
<div class="desc"><p>Whether to forward-backward fill NaN values in <code><a title="vectorbt.portfolio.base.Portfolio.close" href="#vectorbt.portfolio.base.Portfolio.close">Portfolio.close</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def use_filled_close(self):
    &#34;&#34;&#34;Whether to forward-backward fill NaN values in `Portfolio.close`.&#34;&#34;&#34;
    return self._use_filled_close</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio.active_returns"><code class="name flex">
<span>def <span class="ident fname">active_returns</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get active return series per column/group.</p>
<p>This type of returns is based solely on cash flows and holding value rather than portfolio value.
It ignores passive cash and thus it will return the same numbers irrespective of the amount of
cash currently available, even <code>np.inf</code>. The scale of returns is comparable to that of going
all in and keeping available cash at zero.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def active_returns(self, group_by=None):
    &#34;&#34;&#34;Get active return series per column/group.

    This type of returns is based solely on cash flows and holding value rather than portfolio value.
    It ignores passive cash and thus it will return the same numbers irrespective of the amount of
    cash currently available, even `np.inf`. The scale of returns is comparable to that of going
    all in and keeping available cash at zero.&#34;&#34;&#34;
    cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
    holding_value = to_2d(self.holding_value(group_by=group_by), raw=True)
    active_returns = nb.active_returns_nb(cash_flow, holding_value)
    return self.wrapper.wrap(active_returns, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.alpha"><code class="name flex">
<span>def <span class="ident fname">alpha</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='alpha', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.alpha" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.alpha">ReturnsAccessor.alpha()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.annual_returns"><code class="name flex">
<span>def <span class="ident fname">annual_returns</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='annual', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.annual" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.annual">ReturnsAccessor.annual()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.annualized_return"><code class="name flex">
<span>def <span class="ident fname">annualized_return</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='annualized', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.annualized" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.annualized">ReturnsAccessor.annualized()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.annualized_volatility"><code class="name flex">
<span>def <span class="ident fname">annualized_volatility</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='annualized_volatility', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.annualized_volatility" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.annualized_volatility">ReturnsAccessor.annualized_volatility()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.beta"><code class="name flex">
<span>def <span class="ident fname">beta</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='beta', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.beta" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.beta">ReturnsAccessor.beta()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.calmar_ratio"><code class="name flex">
<span>def <span class="ident fname">calmar_ratio</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='calmar_ratio', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.calmar_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.calmar_ratio">ReturnsAccessor.calmar_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.capture"><code class="name flex">
<span>def <span class="ident fname">capture</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='capture', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.capture" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.capture">ReturnsAccessor.capture()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cash"><code class="name flex">
<span>def <span class="ident fname">cash</span></span>(<span>self, group_by=None, in_sim_order=False, short_cash=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get cash balance series per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def cash(self, group_by=None, in_sim_order=False, short_cash=True):
    &#34;&#34;&#34;Get cash balance series per column/group.&#34;&#34;&#34;
    if in_sim_order and not self.cash_sharing:
        raise ValueError(&#34;Cash sharing must be enabled for in_sim_order=True&#34;)

    cash_flow = to_2d(self.cash_flow(group_by=group_by, short_cash=short_cash), raw=True)
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        cash = nb.cash_grouped_nb(
            self.wrapper.shape_2d,
            cash_flow,
            group_lens,
            init_cash
        )
    else:
        group_lens = self.wrapper.grouper.get_group_lens()
        if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
            init_cash = to_1d(self.init_cash, raw=True)
            call_seq = to_2d(self.call_seq, raw=True)
            cash = nb.cash_in_sim_order_nb(cash_flow, group_lens, init_cash, call_seq)
        else:
            init_cash = to_1d(self.get_init_cash(group_by=False), raw=True)
            cash = nb.cash_nb(cash_flow, group_lens, init_cash)
    return self.wrapper.wrap(cash, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cash_flow"><code class="name flex">
<span>def <span class="ident fname">cash_flow</span></span>(<span>self, group_by=None, short_cash=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get cash flow series per column/group.</p>
<p>When <code>short_cash</code> is set to False, cash never goes above the initial level,
because an operation always costs money.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def cash_flow(self, group_by=None, short_cash=True):
    &#34;&#34;&#34;Get cash flow series per column/group.

    When `short_cash` is set to False, cash never goes above the initial level,
    because an operation always costs money.&#34;&#34;&#34;
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        cash_flow = to_2d(self.cash_flow(group_by=False), raw=True)
        group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
        cash_flow = nb.cash_flow_grouped_nb(cash_flow, group_lens)
    else:
        cash_flow = nb.cash_flow_nb(
            self.wrapper.shape_2d,
            self.orders.values,
            self.orders.col_mapper.col_map,
            short_cash
        )
    return self.wrapper.wrap(cash_flow, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.conditional_value_at_risk"><code class="name flex">
<span>def <span class="ident fname">conditional_value_at_risk</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='conditional_value_at_risk', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.conditional_value_at_risk" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.conditional_value_at_risk">ReturnsAccessor.conditional_value_at_risk()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cumulative_returns"><code class="name flex">
<span>def <span class="ident fname">cumulative_returns</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='cumulative', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.cumulative" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.cumulative">ReturnsAccessor.cumulative()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.daily_returns"><code class="name flex">
<span>def <span class="ident fname">daily_returns</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='daily', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.daily" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.daily">ReturnsAccessor.daily()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.deflated_sharpe_ratio"><code class="name flex">
<span>def <span class="ident fname">deflated_sharpe_ratio</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='deflated_sharpe_ratio', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.deflated_sharpe_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.deflated_sharpe_ratio">ReturnsAccessor.deflated_sharpe_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.down_capture"><code class="name flex">
<span>def <span class="ident fname">down_capture</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='down_capture', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.down_capture" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.down_capture">ReturnsAccessor.down_capture()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.downside_risk"><code class="name flex">
<span>def <span class="ident fname">downside_risk</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='downside_risk', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.downside_risk" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.downside_risk">ReturnsAccessor.downside_risk()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.drawdown"><code class="name flex">
<span>def <span class="ident fname">drawdown</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='drawdown', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.drawdown" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.drawdown">ReturnsAccessor.drawdown()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.fill_close"><code class="name flex">
<span>def <span class="ident fname">fill_close</span></span>(<span>self, ffill=True, bfill=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill NaN values of <code><a title="vectorbt.portfolio.base.Portfolio.close" href="#vectorbt.portfolio.base.Portfolio.close">Portfolio.close</a></code>.
Use <code>ffill</code> and <code>bfill</code> to fill forwards and backwards respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def fill_close(self, ffill=True, bfill=True):
    &#34;&#34;&#34;Fill NaN values of `Portfolio.close`.
    Use `ffill` and `bfill` to fill forwards and backwards respectively.&#34;&#34;&#34;
    close = to_2d(self.close, raw=True)
    if ffill and np.any(np.isnan(close[-1, :])):
        close = generic_nb.ffill_nb(close)
    if bfill and np.any(np.isnan(close[0, :])):
        close = generic_nb.ffill_nb(close[::-1, :])[::-1, :]
    return self.wrapper.wrap(close, group_by=False)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.final_value"><code class="name flex">
<span>def <span class="ident fname">final_value</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get total profit per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def final_value(self, group_by=None):
    &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
    init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
    total_profit = to_1d(self.total_profit(group_by=group_by), raw=True)
    final_value = nb.final_value_nb(total_profit, init_cash)
    return self.wrapper.wrap_reduced(final_value, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.get_drawdowns"><code class="name flex">
<span>def <span class="ident fname">get_drawdowns</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get drawdown records from <code><a title="vectorbt.portfolio.base.Portfolio.value" href="#vectorbt.portfolio.base.Portfolio.value">Portfolio.value()</a></code>.</p>
<p>See <code><a title="vectorbt.generic.drawdowns.Drawdowns" href="../generic/drawdowns.html#vectorbt.generic.drawdowns.Drawdowns">Drawdowns</a></code>.</p>
<p><code>**kwargs</code> are passed to <code><a title="vectorbt.portfolio.base.Portfolio.value" href="#vectorbt.portfolio.base.Portfolio.value">Portfolio.value()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def get_drawdowns(self, **kwargs):
    &#34;&#34;&#34;Get drawdown records from `Portfolio.value`.

    See `vectorbt.generic.drawdowns.Drawdowns`.

    `**kwargs` are passed to `Portfolio.value`.&#34;&#34;&#34;
    return Drawdowns.from_ts(self.value(**kwargs), freq=self.wrapper.freq)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.get_init_cash"><code class="name flex">
<span>def <span class="ident fname">get_init_cash</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initial amount of cash per column/group with default arguments.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If initial cash is found automatically and no own cash is used throughout simulation
(for example, when shorting), initial cash will be set to 1 instead of 0 to
enable smooth calculation of returns.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def get_init_cash(self, group_by=None):
    &#34;&#34;&#34;Initial amount of cash per column/group with default arguments.

    !!! note
        If initial cash is found automatically and no own cash is used throughout simulation
        (for example, when shorting), initial cash will be set to 1 instead of 0 to
        enable smooth calculation of returns.&#34;&#34;&#34;
    if isinstance(self._init_cash, int):
        cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
        cash_min = np.min(np.cumsum(cash_flow, axis=0), axis=0)
        init_cash = np.where(cash_min &lt; 0, np.abs(cash_min), 1.)
        if self._init_cash == InitCashMode.AutoAlign:
            init_cash = np.full(init_cash.shape, np.max(init_cash))
    else:
        init_cash = to_1d(self._init_cash, raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            init_cash = nb.init_cash_grouped_nb(init_cash, group_lens, self.cash_sharing)
        else:
            group_lens = self.wrapper.grouper.get_group_lens()
            init_cash = nb.init_cash_nb(init_cash, group_lens, self.cash_sharing)
    return self.wrapper.wrap_reduced(init_cash, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.get_logs"><code class="name flex">
<span>def <span class="ident fname">get_logs</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get log records.</p>
<p>See <code><a title="vectorbt.portfolio.logs.Logs" href="logs.html#vectorbt.portfolio.logs.Logs">Logs</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_logs(self, group_by=None):
    &#34;&#34;&#34;Get log records.

    See `vectorbt.portfolio.logs.Logs`.&#34;&#34;&#34;
    return self.logs.regroup(group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.get_orders"><code class="name flex">
<span>def <span class="ident fname">get_orders</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get order records.</p>
<p>See <code><a title="vectorbt.portfolio.orders.Orders" href="orders.html#vectorbt.portfolio.orders.Orders">Orders</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_orders(self, group_by=None):
    &#34;&#34;&#34;Get order records.

    See `vectorbt.portfolio.orders.Orders`.&#34;&#34;&#34;
    return self.orders.regroup(group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.get_positions"><code class="name flex">
<span>def <span class="ident fname">get_positions</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get position records.</p>
<p>See <code><a title="vectorbt.portfolio.trades.Positions" href="trades.html#vectorbt.portfolio.trades.Positions">Positions</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_positions(self, group_by=None):
    &#34;&#34;&#34;Get position records.

    See `vectorbt.portfolio.trades.Positions`.&#34;&#34;&#34;
    return self.positions.regroup(group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.get_trades"><code class="name flex">
<span>def <span class="ident fname">get_trades</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get trade records.</p>
<p>See <code><a title="vectorbt.portfolio.trades.Trades" href="trades.html#vectorbt.portfolio.trades.Trades">Trades</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_trades(self, group_by=None):
    &#34;&#34;&#34;Get trade records.

    See `vectorbt.portfolio.trades.Trades`.&#34;&#34;&#34;
    return self.trades.regroup(group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.gross_exposure"><code class="name flex">
<span>def <span class="ident fname">gross_exposure</span></span>(<span>self, direction='all', group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get gross exposure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def gross_exposure(self, direction=&#39;all&#39;, group_by=None):
    &#34;&#34;&#34;Get gross exposure.&#34;&#34;&#34;
    holding_value = to_2d(self.holding_value(group_by=group_by, direction=direction), raw=True)
    cash = to_2d(self.cash(group_by=group_by, short_cash=False), raw=True)
    gross_exposure = nb.gross_exposure_nb(holding_value, cash)
    return self.wrapper.wrap(gross_exposure, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.holding_value"><code class="name flex">
<span>def <span class="ident fname">holding_value</span></span>(<span>self, direction='all', group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get holding value series per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def holding_value(self, direction=&#39;all&#39;, group_by=None):
    &#34;&#34;&#34;Get holding value series per column/group.&#34;&#34;&#34;
    direction = convert_str_enum_value(Direction, direction)
    close = to_2d(self.close, raw=True).copy()
    shares = to_2d(self.shares(direction=direction), raw=True)
    close[shares == 0] = 0.  # for price being NaN
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        holding_value = to_2d(self.holding_value(direction=direction, group_by=False), raw=True)
        group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
        holding_value = nb.holding_value_grouped_nb(holding_value, group_lens)
    else:
        holding_value = nb.holding_value_nb(close, shares)
    return self.wrapper.wrap(holding_value, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.information_ratio"><code class="name flex">
<span>def <span class="ident fname">information_ratio</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='information_ratio', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.information_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.information_ratio">ReturnsAccessor.information_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.market_returns"><code class="name flex">
<span>def <span class="ident fname">market_returns</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get return series per column/group based on market (benchmark) value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def market_returns(self, group_by=None):
    &#34;&#34;&#34;Get return series per column/group based on market (benchmark) value.&#34;&#34;&#34;
    market_value = to_2d(self.market_value(group_by=group_by), raw=True)
    init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
    market_returns = nb.returns_nb(market_value, init_cash)
    return self.wrapper.wrap(market_returns, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.market_value"><code class="name flex">
<span>def <span class="ident fname">market_value</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get market (benchmark) value series per column/group.</p>
<p>If grouped, evenly distributes initial cash among assets in the group.</p>
<p>Uses filled close if <code><a title="vectorbt.portfolio.base.Portfolio.use_filled_close" href="#vectorbt.portfolio.base.Portfolio.use_filled_close">Portfolio.use_filled_close</a></code> is True.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Does not take into account fees and slippage. For this, create a separate portfolio.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def market_value(self, group_by=None):
    &#34;&#34;&#34;Get market (benchmark) value series per column/group.

    If grouped, evenly distributes initial cash among assets in the group.

    Uses filled close if `Portfolio.use_filled_close` is True.

    !!! note
        Does not take into account fees and slippage. For this, create a separate portfolio.&#34;&#34;&#34;
    if self.use_filled_close:
        close = to_2d(self.fill_close(), raw=True)
    else:
        close = to_2d(self.close, raw=True)
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
        init_cash_grouped = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        market_value = nb.market_value_grouped_nb(close, group_lens, init_cash_grouped)
    else:
        init_cash = to_1d(self.get_init_cash(group_by=False), raw=True)
        market_value = nb.market_value_nb(close, init_cash)
    return self.wrapper.wrap(market_value, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.max_drawdown"><code class="name flex">
<span>def <span class="ident fname">max_drawdown</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='max_drawdown', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.max_drawdown" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.max_drawdown">ReturnsAccessor.max_drawdown()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.net_exposure"><code class="name flex">
<span>def <span class="ident fname">net_exposure</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get net exposure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def net_exposure(self, group_by=None):
    &#34;&#34;&#34;Get net exposure.&#34;&#34;&#34;
    long_exposure = to_2d(self.gross_exposure(direction=&#39;longonly&#39;, group_by=group_by), raw=True)
    short_exposure = to_2d(self.gross_exposure(direction=&#39;shortonly&#39;, group_by=group_by), raw=True)
    net_exposure = long_exposure - short_exposure
    return self.wrapper.wrap(net_exposure, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.omega_ratio"><code class="name flex">
<span>def <span class="ident fname">omega_ratio</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='omega_ratio', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.omega_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.omega_ratio">ReturnsAccessor.omega_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, *, column=None, subplots=None, group_by=None, show_titles=True, hide_id_labels=True, group_id_labels=True, hline_shape_kwargs=None, make_subplots_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot various parts of this portfolio.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>subplots</code></strong> :&ensp;<code>list</code> of <code>str</code> or <code>list</code> of <code>tuple</code></dt>
<dd>
<p>List of subplots to plot.</p>
<p>Each element can be either:</p>
<ul>
<li>a subplot name, as listed in <code><a title="vectorbt.portfolio.base.Portfolio.subplot_settings" href="#vectorbt.portfolio.base.Portfolio.subplot_settings">Portfolio.subplot_settings</a></code></li>
<li>a tuple of a subplot name and a dict as in <code><a title="vectorbt.portfolio.base.Portfolio.subplot_settings" href="#vectorbt.portfolio.base.Portfolio.subplot_settings">Portfolio.subplot_settings</a></code> but with an
additional optional key <code>plot_func</code>. The plot function should accept current portfolio
object (with column already selected) and optionally other keyword arguments.
Will pass <code>row</code>, <code>col</code>, and other subplot-dependent arguments if they can be found
in the function's signature.</li>
</ul>
</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Name of the column/group to plot.</p>
<p>Takes effect if portfolio contains multiple columns.</p>
</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>
<p>Group columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</p>
<p>Used to select <code>group</code>.</p>
</dd>
<dt><strong><code>show_titles</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the title in the top left corner of each subplot.</dd>
<dt><strong><code>hide_id_labels</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to hide identical legend labels.</p>
<p>Two labels are identical if their name, marker style and line style match.</p>
</dd>
<dt><strong><code>group_id_labels</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to group identical legend labels.</dd>
<dt><strong><code>hline_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for horizontal lines.</dd>
<dt><strong><code>make_subplots_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.subplots.make_subplots</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>
<p>Additional keyword arguments.</p>
<p>Can contain keyword arguments for each subplot, each specified as <code>{subplot_name}_kwargs</code>.
Other keyword arguments are used to update layout of the figure.</p>
</dd>
</dl>
<h2 id="example">Example</h2>
<p>Plot portfolio of a random strategy:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; start = datetime(2020, 1, 1)
&gt;&gt;&gt; end = datetime(2020, 9, 1)
&gt;&gt;&gt; close = vbt.utils.data.download(&quot;BTC-USD&quot;, start=start, end=end)['Close']

&gt;&gt;&gt; np.random.seed(42)
&gt;&gt;&gt; size = pd.Series.vbt.empty_like(close, fill_value=0.)
&gt;&gt;&gt; n_orders = 20
&gt;&gt;&gt; rand_idxs = np.random.randint(0, len(size), size=n_orders)
&gt;&gt;&gt; size.iloc[rand_idxs] = np.random.uniform(-1, 1, size=n_orders)
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
...     close, size, direction='longonly',
...     init_cash='auto', freq='1D')
&gt;&gt;&gt; portfolio.plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/portfolio_plot.png"></p>
<p>You can choose any of the subplots in <code><a title="vectorbt.portfolio.base.Portfolio.subplot_settings" href="#vectorbt.portfolio.base.Portfolio.subplot_settings">Portfolio.subplot_settings</a></code>, in any order:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from vectorbt.utils.colors import adjust_opacity

&gt;&gt;&gt; portfolio.plot(
...     subplots=['drawdowns', 'underwater'],
...     drawdowns_kwargs=dict(top_n=3),
...     underwater_kwargs=dict(
...         trace_kwargs=dict(
...             line_color='#FF6F00',
...             fillcolor=adjust_opacity('#FF6F00', 0.3)
...         )
...     )
... )
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/portfolio_plot_drawdowns.png"></p>
<p>You can also create a custom subplot, either by providing a function or
by creating a placeholder that can be written later:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fig = portfolio.plot(subplots=[
...     'orders',
...     ('order_size', dict(
...         title='Order Size',
...         can_plot_groups=False
...     ))  # placeholder
... ])

&gt;&gt;&gt; size.rename('Order Size').vbt.plot(add_trace_kwargs=dict(row=2, col=1), fig=fig)
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/portfolio_plot_custom.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, *,
         column=None,
         subplots=None,
         group_by=None,
         show_titles=True,
         hide_id_labels=True,
         group_id_labels=True,
         hline_shape_kwargs=None,
         make_subplots_kwargs=None,
         **kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot various parts of this portfolio.

    Args:
        subplots (list of str or list of tuple): List of subplots to plot.

            Each element can be either:

            * a subplot name, as listed in `Portfolio.subplot_settings`
            * a tuple of a subplot name and a dict as in `Portfolio.subplot_settings` but with an
                additional optional key `plot_func`. The plot function should accept current portfolio
                object (with column already selected) and optionally other keyword arguments.
                Will pass `row`, `col`, and other subplot-dependent arguments if they can be found
                in the function&#39;s signature.
        column (str): Name of the column/group to plot.

            Takes effect if portfolio contains multiple columns.
        group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.

            Used to select `group`.
        show_titles (bool): Whether to show the title in the top left corner of each subplot.
        hide_id_labels (bool): Whether to hide identical legend labels.

            Two labels are identical if their name, marker style and line style match.
        group_id_labels (bool): Whether to group identical legend labels.
        hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for horizontal lines.
        make_subplots_kwargs (dict): Keyword arguments passed to `plotly.subplots.make_subplots`.
        **kwargs: Additional keyword arguments.

            Can contain keyword arguments for each subplot, each specified as `{subplot_name}_kwargs`.
            Other keyword arguments are used to update layout of the figure.

    ## Example

    Plot portfolio of a random strategy:
    ```python-repl
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from datetime import datetime
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; start = datetime(2020, 1, 1)
    &gt;&gt;&gt; end = datetime(2020, 9, 1)
    &gt;&gt;&gt; close = vbt.utils.data.download(&#34;BTC-USD&#34;, start=start, end=end)[&#39;Close&#39;]

    &gt;&gt;&gt; np.random.seed(42)
    &gt;&gt;&gt; size = pd.Series.vbt.empty_like(close, fill_value=0.)
    &gt;&gt;&gt; n_orders = 20
    &gt;&gt;&gt; rand_idxs = np.random.randint(0, len(size), size=n_orders)
    &gt;&gt;&gt; size.iloc[rand_idxs] = np.random.uniform(-1, 1, size=n_orders)
    &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(
    ...     close, size, direction=&#39;longonly&#39;,
    ...     init_cash=&#39;auto&#39;, freq=&#39;1D&#39;)
    &gt;&gt;&gt; portfolio.plot()
    ```

    ![](/vectorbt/docs/img/portfolio_plot.png)

    You can choose any of the subplots in `Portfolio.subplot_settings`, in any order:

    ```python-repl
    &gt;&gt;&gt; from vectorbt.utils.colors import adjust_opacity

    &gt;&gt;&gt; portfolio.plot(
    ...     subplots=[&#39;drawdowns&#39;, &#39;underwater&#39;],
    ...     drawdowns_kwargs=dict(top_n=3),
    ...     underwater_kwargs=dict(
    ...         trace_kwargs=dict(
    ...             line_color=&#39;#FF6F00&#39;,
    ...             fillcolor=adjust_opacity(&#39;#FF6F00&#39;, 0.3)
    ...         )
    ...     )
    ... )
    ```

    ![](/vectorbt/docs/img/portfolio_plot_drawdowns.png)

    You can also create a custom subplot, either by providing a function or
    by creating a placeholder that can be written later:

    ```python-repl
    &gt;&gt;&gt; fig = portfolio.plot(subplots=[
    ...     &#39;orders&#39;,
    ...     (&#39;order_size&#39;, dict(
    ...         title=&#39;Order Size&#39;,
    ...         can_plot_groups=False
    ...     ))  # placeholder
    ... ])

    &gt;&gt;&gt; size.rename(&#39;Order Size&#39;).vbt.plot(add_trace_kwargs=dict(row=2, col=1), fig=fig)
    ```

    ![](/vectorbt/docs/img/portfolio_plot_custom.png)
    &#34;&#34;&#34;
    from vectorbt.settings import color_schema, layout

    # Select one column/group
    self_col = self.select_series(column=column, group_by=group_by)

    if subplots is None:
        if self_col.wrapper.grouper.is_grouped():
            subplots = [&#39;cum_returns&#39;]
        else:
            subplots = [&#39;orders&#39;, &#39;trade_pnl&#39;, &#39;cum_returns&#39;]
    elif subplots == &#39;all&#39;:
        if self_col.wrapper.grouper.is_grouped():
            supported_subplots = filter(lambda x: x[1].get(&#39;can_plot_groups&#39;, True), self.subplot_settings.items())
        else:
            supported_subplots = self.subplot_settings.items()
        subplots = list(list(zip(*supported_subplots))[0])
    if not isinstance(subplots, list):
        subplots = [subplots]
    if len(subplots) == 0:
        raise ValueError(&#34;You must select at least one subplot&#34;)
    if hline_shape_kwargs is None:
        hline_shape_kwargs = {}
    hline_shape_kwargs = merge_dicts(
        dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            )
        ),
        hline_shape_kwargs
    )
    if make_subplots_kwargs is None:
        make_subplots_kwargs = {}

    # Set up figure
    rows = make_subplots_kwargs.pop(&#39;rows&#39;, len(subplots))
    cols = make_subplots_kwargs.pop(&#39;cols&#39;, 1)
    width = kwargs.get(&#39;width&#39;, layout[&#39;width&#39;] + 50)
    height = kwargs.get(&#39;height&#39;, (layout[&#39;height&#39;] - 50) * rows if rows &gt; 1 else layout[&#39;height&#39;])
    specs = make_subplots_kwargs.pop(&#39;specs&#39;, [[{} for _ in range(cols)] for _ in range(rows)])
    row_col_tuples = []
    for row, row_spec in enumerate(specs):
        for col, col_spec in enumerate(row_spec):
            if col_spec is not None:
                row_col_tuples.append((row + 1, col + 1))
    shared_xaxes = make_subplots_kwargs.pop(&#39;shared_xaxes&#39;, True)
    shared_yaxes = make_subplots_kwargs.pop(&#39;shared_yaxes&#39;, False)
    if height is not None:
        vertical_spacing = make_subplots_kwargs.pop(&#39;vertical_spacing&#39;, 40)
        if vertical_spacing is not None and vertical_spacing &gt; 1:
            vertical_spacing /= height
    else:
        vertical_spacing = make_subplots_kwargs.pop(&#39;vertical_spacing&#39;, None)
    horizontal_spacing = make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;, None)
    if width is not None:
        if horizontal_spacing is not None and horizontal_spacing &gt; 1:
            horizontal_spacing /= width
    if show_titles:
        _subplot_titles = []
        for name in subplots:
            if isinstance(name, tuple):
                _subplot_titles.append(name[1].get(&#39;title&#39;, None))
            else:
                _subplot_titles.append(self_col.subplot_settings[name][&#39;title&#39;])
    else:
        _subplot_titles = None
    fig = make_subplots(
        rows=rows,
        cols=cols,
        specs=specs,
        shared_xaxes=shared_xaxes,
        shared_yaxes=shared_yaxes,
        subplot_titles=_subplot_titles,
        vertical_spacing=vertical_spacing,
        horizontal_spacing=horizontal_spacing,
        **make_subplots_kwargs
    )
    default_layout = dict(
        autosize=True,
        width=width,
        height=height,
        legend=dict(
            orientation=&#34;h&#34;,
            yanchor=&#34;bottom&#34;,
            y=(1 + 30 / height) if height is not None else 1.02,
            xanchor=&#34;right&#34;,
            x=1,
            traceorder=&#39;normal&#39;
        )
    )
    fig.update_layout(default_layout)

    def _add_hline(value, x_domain, yref):
        fig.add_shape(**merge_dicts(dict(
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=value,
            x1=x_domain[1],
            y1=value
        ), hline_shape_kwargs))

    def _get_arg_names(method):
        sig = signature(method)
        arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
        return arg_names

    def _extract_method_kwargs(method, kwargs):
        arg_names = _get_arg_names(method)
        method_kwargs = {}
        for name in arg_names:
            if name in kwargs:
                method_kwargs[name] = kwargs.pop(name)
        return method_kwargs

    # Show subplots
    for i, name in enumerate(subplots):
        row, col = row_col_tuples[i]
        xref = &#39;x&#39; if i == 0 else &#39;x&#39; + str(i + 1)
        yref = &#39;y&#39; if i == 0 else &#39;y&#39; + str(i + 1)
        xaxis = &#39;xaxis&#39; if i == 0 else &#39;xaxis&#39; + str(i + 1)
        yaxis = &#39;yaxis&#39; if i == 0 else &#39;yaxis&#39; + str(i + 1)
        x_domain = fig.layout[xaxis][&#39;domain&#39;]
        y_domain = fig.layout[yaxis][&#39;domain&#39;]

        if isinstance(name, tuple):
            _name, settings = name
            can_plot_groups = settings.get(&#39;can_plot_groups&#39;, True)
            if self_col.wrapper.grouper.is_grouped() and not can_plot_groups:
                raise TypeError(f&#34;Group is not supported by custom subplot with name &#39;{_name}&#39;&#34;)
            plot_func = settings.get(&#39;plot_func&#39;, None)

            if plot_func is not None:
                arg_names = _get_arg_names(plot_func)
                custom_kwargs = dict()
                if &#39;add_trace_kwargs&#39; in arg_names:
                    custom_kwargs[&#39;add_trace_kwargs&#39;] = dict(row=row, col=col)
                if &#39;xref&#39; in arg_names:
                    custom_kwargs[&#39;xref&#39;] = xref
                if &#39;yref&#39; in arg_names:
                    custom_kwargs[&#39;yref&#39;] = yref
                if &#39;xaxis&#39; in arg_names:
                    custom_kwargs[&#39;xaxis&#39;] = xaxis
                if &#39;yaxis&#39; in arg_names:
                    custom_kwargs[&#39;yaxis&#39;] = yaxis
                if &#39;x_domain&#39; in arg_names:
                    custom_kwargs[&#39;x_domain&#39;] = x_domain
                if &#39;y_domain&#39; in arg_names:
                    custom_kwargs[&#39;y_domain&#39;] = y_domain
                custom_kwargs = merge_dicts(custom_kwargs, kwargs.pop(f&#39;{_name}_kwargs&#39;, {}))
                plot_func(self_col, **custom_kwargs, fig=fig)

            fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
            fig.layout[yaxis][&#39;title&#39;] = settings.get(&#39;title&#39;, None)
                
        else:
            settings = self.subplot_settings[name]
            can_plot_groups = settings.get(&#39;can_plot_groups&#39;, True)
            if self_col.wrapper.grouper.is_grouped() and not can_plot_groups:
                raise TypeError(f&#34;Group is not supported by subplot with name &#39;{name}&#39;&#34;)

            if name == &#39;orders&#39;:
                orders_kwargs = kwargs.pop(&#39;orders_kwargs&#39;, {})
                method_kwargs = _extract_method_kwargs(self_col.get_orders, orders_kwargs)
                self_col.get_orders(**method_kwargs).plot(
                    **orders_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), fig=fig)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;Price&#39;

            elif name == &#39;trades&#39;:
                trades_kwargs = kwargs.pop(&#39;trades_kwargs&#39;, {})
                method_kwargs = _extract_method_kwargs(self_col.get_trades, trades_kwargs)
                self_col.get_trades(**method_kwargs).plot(
                    **trades_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;Price&#39;

            elif name == &#39;positions&#39;:
                positions_kwargs = kwargs.pop(&#39;positions_kwargs&#39;, {})
                method_kwargs = _extract_method_kwargs(self_col.get_positions, positions_kwargs)
                self_col.get_positions(**method_kwargs).plot(
                    **positions_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;Price&#39;

            elif name == &#39;trade_pnl&#39;:
                trade_pnl_kwargs = merge_dicts(dict(
                    hline_shape_kwargs=hline_shape_kwargs
                ), kwargs.pop(&#39;trade_pnl_kwargs&#39;, {}))
                method_kwargs = _extract_method_kwargs(self_col.get_trades, trade_pnl_kwargs)
                self_col.get_trades(**method_kwargs).plot_pnl(
                    **trade_pnl_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;PnL&#39;

            elif name == &#39;position_pnl&#39;:
                position_pnl_kwargs = kwargs.pop(&#39;position_pnl_kwargs&#39;, {})
                method_kwargs = _extract_method_kwargs(self_col.get_positions, position_pnl_kwargs)
                self_col.get_positions(**method_kwargs).plot_pnl(
                    **position_pnl_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;PnL&#39;

            elif name == &#39;cum_returns&#39;:
                cum_returns_kwargs = merge_dicts(dict(
                    benchmark_rets=self_col.market_returns(),
                    main_kwargs=dict(
                        trace_kwargs=dict(
                            line_color=color_schema[&#39;purple&#39;],
                            name=&#39;Value&#39;
                        )
                    ),
                    hline_shape_kwargs=hline_shape_kwargs
                ), kwargs.pop(&#39;cum_returns_kwargs&#39;, {}))
                active_returns = cum_returns_kwargs.pop(&#39;active_returns&#39;, False)
                in_sim_order = cum_returns_kwargs.pop(&#39;in_sim_order&#39;, False)
                if active_returns:
                    returns = self_col.active_returns()
                else:
                    returns = self_col.returns(in_sim_order=in_sim_order)
                returns.vbt.returns.plot_cum_returns(
                    **cum_returns_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;Cumulative Returns&#39;

            elif name == &#39;drawdowns&#39;:
                drawdowns_kwargs = merge_dicts(dict(
                    ts_trace_kwargs=dict(
                        line_color=color_schema[&#39;purple&#39;],
                        name=&#39;Value&#39;
                    )
                ), kwargs.pop(&#39;drawdowns_kwargs&#39;, {}))
                method_kwargs = _extract_method_kwargs(self_col.get_drawdowns, drawdowns_kwargs)
                self_col.get_drawdowns(**method_kwargs).plot(
                    **drawdowns_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), xref=xref, yref=yref, fig=fig)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;Value&#39;

            elif name == &#39;underwater&#39;:
                underwater_kwargs = merge_dicts(dict(
                    trace_kwargs=dict(
                        line_color=color_schema[&#39;red&#39;],
                        fillcolor=adjust_opacity(color_schema[&#39;red&#39;], 0.3),
                        fill=&#39;tozeroy&#39;,
                        name=&#39;Drawdown&#39;
                    )
                ), kwargs.pop(&#39;underwater_kwargs&#39;, {}))
                method_kwargs = _extract_method_kwargs(self_col.drawdown, underwater_kwargs)
                self_col.drawdown(**method_kwargs).vbt.plot(
                    **underwater_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), fig=fig)
                _add_hline(0, x_domain, yref)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;Drawdown&#39;
                fig.layout[yaxis][&#39;tickformat&#39;] = &#39;%&#39;

            elif name == &#39;share_flow&#39;:
                share_flow_kwargs = merge_dicts(dict(
                    trace_kwargs=dict(
                        line_color=color_schema[&#39;brown&#39;],
                        name=&#39;Shares&#39;
                    )
                ), kwargs.pop(&#39;share_flow_kwargs&#39;, {}))
                method_kwargs = _extract_method_kwargs(self_col.share_flow, share_flow_kwargs)
                self_col.share_flow(**method_kwargs).vbt.plot(
                    **share_flow_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), fig=fig)
                _add_hline(0, x_domain, yref)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;Share Flow&#39;

            elif name == &#39;cash_flow&#39;:
                cash_flow_kwargs = merge_dicts(dict(
                    trace_kwargs=dict(
                        line_color=color_schema[&#39;green&#39;],
                        name=&#39;Cash&#39;
                    )
                ), kwargs.pop(&#39;cash_flow_kwargs&#39;, {}))
                method_kwargs = _extract_method_kwargs(self_col.cash_flow, cash_flow_kwargs)
                self_col.cash_flow(**method_kwargs).vbt.plot(
                    **cash_flow_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), fig=fig)
                _add_hline(0, x_domain, yref)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;Cash Flow&#39;

            elif name == &#39;shares&#39;:
                shares_kwargs = merge_dicts(dict(
                    trace_kwargs=dict(
                        line_color=color_schema[&#39;brown&#39;],
                        name=&#39;Shares&#39;
                    ),
                    pos_trace_kwargs=dict(
                        fillcolor=adjust_opacity(color_schema[&#39;brown&#39;], 0.3)
                    ),
                    neg_trace_kwargs=dict(
                        fillcolor=adjust_opacity(color_schema[&#39;orange&#39;], 0.3)
                    ),
                    other_trace_kwargs=&#39;hidden&#39;
                ), kwargs.pop(&#39;shares_kwargs&#39;, {}))
                method_kwargs = _extract_method_kwargs(self_col.shares, shares_kwargs)
                self_col.shares(**method_kwargs).vbt.plot_against(
                    0, **shares_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), fig=fig)
                _add_hline(0, x_domain, yref)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;Shares&#39;

            elif name == &#39;cash&#39;:
                cash_kwargs = merge_dicts(dict(
                    trace_kwargs=dict(
                        line_color=color_schema[&#39;green&#39;],
                        name=&#39;Cash&#39;
                    ),
                    pos_trace_kwargs=dict(
                        fillcolor=adjust_opacity(color_schema[&#39;green&#39;], 0.3)
                    ),
                    neg_trace_kwargs=dict(
                        fillcolor=adjust_opacity(color_schema[&#39;red&#39;], 0.3)
                    ),
                    other_trace_kwargs=&#39;hidden&#39;
                ), kwargs.pop(&#39;cash_kwargs&#39;, {}))
                method_kwargs = _extract_method_kwargs(self_col.cash, cash_kwargs)
                self_col.cash(**method_kwargs).vbt.plot_against(
                    0, **cash_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), fig=fig)
                _add_hline(self_col.init_cash, x_domain, yref)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;Cash&#39;

            elif name == &#39;holding_value&#39;:
                holding_value_kwargs = merge_dicts(dict(
                    trace_kwargs=dict(
                        line_color=color_schema[&#39;cyan&#39;],
                        name=&#39;Holding Value&#39;
                    ),
                    pos_trace_kwargs=dict(
                        fillcolor=adjust_opacity(color_schema[&#39;cyan&#39;], 0.3)
                    ),
                    neg_trace_kwargs=dict(
                        fillcolor=adjust_opacity(color_schema[&#39;orange&#39;], 0.3)
                    ),
                    other_trace_kwargs=&#39;hidden&#39;
                ), kwargs.pop(&#39;holding_value_kwargs&#39;, {}))
                method_kwargs = _extract_method_kwargs(self_col.holding_value, holding_value_kwargs)
                self_col.holding_value(**method_kwargs).vbt.plot_against(
                    0, **holding_value_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), fig=fig)
                _add_hline(0, x_domain, yref)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;Holding Value&#39;

            elif name == &#39;value&#39;:
                value_kwargs = merge_dicts(dict(
                    trace_kwargs=dict(
                        line_color=color_schema[&#39;purple&#39;],
                        name=&#39;Value&#39;
                    ),
                    other_trace_kwargs=&#39;hidden&#39;
                ), kwargs.pop(&#39;value_kwargs&#39;, {}))
                method_kwargs = _extract_method_kwargs(self_col.value, value_kwargs)
                self_col.value(**method_kwargs).vbt.plot_against(
                    self_col.init_cash, **value_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), fig=fig)
                _add_hline(self_col.init_cash, x_domain, yref)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;Value&#39;

            elif name == &#39;gross_exposure&#39;:
                gross_exposure_kwargs = merge_dicts(dict(
                    trace_kwargs=dict(
                        line_color=color_schema[&#39;pink&#39;],
                        name=&#39;Exposure&#39;
                    ),
                    pos_trace_kwargs=dict(
                        fillcolor=adjust_opacity(color_schema[&#39;orange&#39;], 0.3)
                    ),
                    neg_trace_kwargs=dict(
                        fillcolor=adjust_opacity(color_schema[&#39;pink&#39;], 0.3)
                    ),
                    other_trace_kwargs=&#39;hidden&#39;
                ), kwargs.pop(&#39;gross_exposure_kwargs&#39;, {}))
                method_kwargs = _extract_method_kwargs(self_col.gross_exposure, gross_exposure_kwargs)
                self_col.gross_exposure(**method_kwargs).vbt.plot_against(
                    1, **gross_exposure_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), fig=fig)
                _add_hline(1, x_domain, yref)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;Gross Exposure&#39;

            elif name == &#39;net_exposure&#39;:
                net_exposure_kwargs = merge_dicts(dict(
                    trace_kwargs=dict(
                        line_color=color_schema[&#39;pink&#39;],
                        name=&#39;Exposure&#39;
                    ),
                    pos_trace_kwargs=dict(
                        fillcolor=adjust_opacity(color_schema[&#39;pink&#39;], 0.3)
                    ),
                    neg_trace_kwargs=dict(
                        fillcolor=adjust_opacity(color_schema[&#39;orange&#39;], 0.3)
                    ),
                    other_trace_kwargs=&#39;hidden&#39;
                ), kwargs.pop(&#39;net_exposure_kwargs&#39;, {}))
                method_kwargs = _extract_method_kwargs(self_col.net_exposure, net_exposure_kwargs)
                self_col.net_exposure(**method_kwargs).vbt.plot_against(
                    0, **net_exposure_kwargs,
                    add_trace_kwargs=dict(row=row, col=col), fig=fig)
                _add_hline(0, x_domain, yref)
                fig.layout[xaxis][&#39;title&#39;] = &#39;Date&#39;
                fig.layout[yaxis][&#39;title&#39;] = &#39;Net Exposure&#39;

    # Remove duplicate legend labels
    found_ids = dict()
    unique_idx = 0
    for trace in fig.data:
        if &#39;name&#39; in trace:
            name = trace[&#39;name&#39;]
        else:
            name = None
        if &#39;marker&#39; in trace:
            marker = trace[&#39;marker&#39;]
        else:
            marker = {}
        if &#39;symbol&#39; in marker:
            marker_symbol = marker[&#39;symbol&#39;]
        else:
            marker_symbol = None
        if &#39;color&#39; in marker:
            marker_color = marker[&#39;color&#39;]
        else:
            marker_color = None
        if &#39;line&#39; in trace:
            line = trace[&#39;line&#39;]
        else:
            line = {}
        if &#39;dash&#39; in line:
            line_dash = line[&#39;dash&#39;]
        else:
            line_dash = None
        if &#39;color&#39; in line:
            line_color = line[&#39;color&#39;]
        else:
            line_color = None

        id = (name, marker_symbol, marker_color, line_dash, line_color)
        if id in found_ids:
            if hide_id_labels:
                trace[&#39;showlegend&#39;] = False
            if group_id_labels:
                trace[&#39;legendgroup&#39;] = found_ids[id]
        else:
            if group_id_labels:
                trace[&#39;legendgroup&#39;] = unique_idx
            found_ids[id] = unique_idx
            unique_idx += 1

    # Remove all except the last title if sharing the same axis
    if shared_xaxes:
        i = 0
        for row in range(rows):
            for col in range(cols):
                if specs[row][col] is not None:
                    xaxis = &#39;xaxis&#39; if i == 0 else &#39;xaxis&#39; + str(i + 1)
                    if row &lt; rows - 1:
                        fig.layout[xaxis][&#39;title&#39;] = None
                    i += 1
    if shared_yaxes:
        i = 0
        for row in range(rows):
            for col in range(cols):
                if specs[row][col] is not None:
                    yaxis = &#39;yaxis&#39; if i == 0 else &#39;yaxis&#39; + str(i + 1)
                    if col &gt; 0:
                        fig.layout[yaxis][&#39;title&#39;] = None
                    i += 1

    fig.update_layout(kwargs)
    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.pos_coverage"><code class="name flex">
<span>def <span class="ident fname">pos_coverage</span></span>(<span>self, direction='all', group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get position coverage per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def pos_coverage(self, direction=&#39;all&#39;, group_by=None):
    &#34;&#34;&#34;Get position coverage per column/group.&#34;&#34;&#34;
    direction = convert_str_enum_value(Direction, direction)
    shares = to_2d(self.shares(direction=direction), raw=True)
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        pos_mask = to_2d(self.pos_mask(direction=direction, group_by=False), raw=True)
        group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
        pos_coverage = nb.pos_coverage_grouped_nb(pos_mask, group_lens)
    else:
        pos_coverage = np.mean(shares != 0, axis=0)
    return self.wrapper.wrap_reduced(pos_coverage, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.pos_mask"><code class="name flex">
<span>def <span class="ident fname">pos_mask</span></span>(<span>self, direction='all', group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get position mask per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def pos_mask(self, direction=&#39;all&#39;, group_by=None):
    &#34;&#34;&#34;Get position mask per column/group.&#34;&#34;&#34;
    direction = convert_str_enum_value(Direction, direction)
    shares = to_2d(self.shares(direction=direction), raw=True)
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        pos_mask = to_2d(self.pos_mask(direction=direction, group_by=False), raw=True)
        group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
        pos_mask = nb.pos_mask_grouped_nb(pos_mask, group_lens)
    else:
        pos_mask = shares != 0
    return self.wrapper.wrap(pos_mask, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.regroup"><code class="name flex">
<span>def <span class="ident fname">regroup</span></span>(<span>self, group_by, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Regroup this object.</p>
<p>See <code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">Wrapping.regroup()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regroup(self, group_by, **kwargs):
    &#34;&#34;&#34;Regroup this object.

    See `vectorbt.base.array_wrapper.Wrapping.regroup`.&#34;&#34;&#34;
    if self.cash_sharing:
        if self.wrapper.grouper.is_grouping_modified(group_by=group_by):
            raise ValueError(&#34;Cannot modify grouping globally when cash_sharing=True&#34;)
    return Wrapping.regroup(self, group_by, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.returns"><code class="name flex">
<span>def <span class="ident fname">returns</span></span>(<span>self, group_by=None, in_sim_order=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get return series per column/group based on portfolio value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def returns(self, group_by=None, in_sim_order=False):
    &#34;&#34;&#34;Get return series per column/group based on portfolio value.&#34;&#34;&#34;
    value = to_2d(self.value(group_by=group_by, in_sim_order=in_sim_order), raw=True)
    if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
        group_lens = self.wrapper.grouper.get_group_lens()
        init_cash_grouped = to_1d(self.init_cash, raw=True)
        call_seq = to_2d(self.call_seq, raw=True)
        returns = nb.returns_in_sim_order_nb(value, group_lens, init_cash_grouped, call_seq)
    else:
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        returns = nb.returns_nb(value, init_cash)
    return self.wrapper.wrap(returns, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.returns_stats"><code class="name flex">
<span>def <span class="ident fname">returns_stats</span></span>(<span>self, column=None, group_by=None, active_returns=False, in_sim_order=False, agg_func=&lt;function Portfolio.&lt;lambda&gt;&gt;, year_freq=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute various statistics on returns of this portfolio.</p>
<p>For keyword arguments and notes, see <code><a title="vectorbt.portfolio.base.Portfolio.stats" href="#vectorbt.portfolio.base.Portfolio.stats">Portfolio.stats()</a></code>.</p>
<p><code>kwargs</code> will be passed to <code><a title="vectorbt.returns.accessors.ReturnsAccessor.stats" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.stats">ReturnsAccessor.stats()</a></code> method.
If <code>benchmark_rets</code> is not set, uses <code><a title="vectorbt.portfolio.base.Portfolio.market_returns" href="#vectorbt.portfolio.base.Portfolio.market_returns">Portfolio.market_returns()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_stats(self, column=None, group_by=None, active_returns=False, in_sim_order=False,
                  agg_func=lambda x: x.mean(axis=0), year_freq=None, **kwargs):
    &#34;&#34;&#34;Compute various statistics on returns of this portfolio.

    For keyword arguments and notes, see `Portfolio.stats`.

    `kwargs` will be passed to `vectorbt.returns.accessors.ReturnsAccessor.stats` method.
    If `benchmark_rets` is not set, uses `Portfolio.market_returns`.&#34;&#34;&#34;
    # Pre-calculate
    if active_returns:
        returns = self.active_returns(group_by=group_by)
    else:
        returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)

    # Run stats
    if &#39;benchmark_rets&#39; not in kwargs:
        kwargs[&#39;benchmark_rets&#39;] = self.market_returns(group_by=group_by)
    stats_obj = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq).stats(**kwargs)

    # Select columns or reduce
    if checks.is_series(stats_obj):
        return stats_obj
    if column is not None:
        return stats_obj.loc[column]
    if agg_func is not None:
        agg_stats_sr = pd.Series(index=stats_obj.columns, name=agg_func.__name__)
        agg_stats_sr.iloc[:3] = stats_obj.iloc[0, :3]
        agg_stats_sr.iloc[3:] = agg_func(stats_obj.iloc[:, 3:])
        return agg_stats_sr
    return stats_obj</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.share_flow"><code class="name flex">
<span>def <span class="ident fname">share_flow</span></span>(<span>self, direction='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Get share flow series per column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def share_flow(self, direction=&#39;all&#39;):
    &#34;&#34;&#34;Get share flow series per column.&#34;&#34;&#34;
    direction = convert_str_enum_value(Direction, direction)
    share_flow = nb.share_flow_nb(
        self.wrapper.shape_2d,
        self.orders.values,
        self.orders.col_mapper.col_map,
        direction
    )
    return self.wrapper.wrap(share_flow, group_by=False)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.shares"><code class="name flex">
<span>def <span class="ident fname">shares</span></span>(<span>self, direction='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Get share series per column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def shares(self, direction=&#39;all&#39;):
    &#34;&#34;&#34;Get share series per column.&#34;&#34;&#34;
    direction = convert_str_enum_value(Direction, direction)
    share_flow = to_2d(self.share_flow(direction=&#39;all&#39;), raw=True)
    shares = nb.shares_nb(share_flow)
    if direction == Direction.LongOnly:
        shares = np.where(shares &gt; 0, shares, 0.)
    if direction == Direction.ShortOnly:
        shares = np.where(shares &lt; 0, -shares, 0.)
    return self.wrapper.wrap(shares, group_by=False)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.sharpe_ratio"><code class="name flex">
<span>def <span class="ident fname">sharpe_ratio</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='sharpe_ratio', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.sharpe_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.sharpe_ratio">ReturnsAccessor.sharpe_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.sortino_ratio"><code class="name flex">
<span>def <span class="ident fname">sortino_ratio</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='sortino_ratio', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.sortino_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.sortino_ratio">ReturnsAccessor.sortino_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.stats"><code class="name flex">
<span>def <span class="ident fname">stats</span></span>(<span>self, column=None, group_by=None, incl_unrealized=None, active_returns=False, in_sim_order=False, agg_func=&lt;function Portfolio.&lt;lambda&gt;&gt;, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute various statistics on this portfolio.</p>
<p><code>kwargs</code> will be passed to each <code><a title="vectorbt.returns.accessors.ReturnsAccessor" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor">ReturnsAccessor</a></code> method.</p>
<p>Can either return aggregated statistics by reducing metrics of all columns with
<code>agg_func</code> (mean by default) or return statistics for a single column if <code>column</code>
was specified or portfolio contains only one column of data. To display rich data types
such as durations correctly, use an aggregation function that can be applied on <code>pd.Series</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use <code>column</code> only if caching is enabled, otherwise it may re-compute the same
objects multiple times.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def stats(self, column=None, group_by=None, incl_unrealized=None, active_returns=False,
          in_sim_order=False, agg_func=lambda x: x.mean(axis=0), **kwargs):
    &#34;&#34;&#34;Compute various statistics on this portfolio.

    `kwargs` will be passed to each `vectorbt.returns.accessors.ReturnsAccessor` method.

    Can either return aggregated statistics by reducing metrics of all columns with
    `agg_func` (mean by default) or return statistics for a single column if `column`
    was specified or portfolio contains only one column of data. To display rich data types
    such as durations correctly, use an aggregation function that can be applied on `pd.Series`.

    !!! note
        Use `column` only if caching is enabled, otherwise it may re-compute the same
        objects multiple times.&#34;&#34;&#34;
    # Pre-calculate
    trades = self.get_trades(group_by=group_by)
    if incl_unrealized is None:
        incl_unrealized = self.incl_unrealized
    if not incl_unrealized:
        trades = trades.closed
    drawdowns = self.get_drawdowns(group_by=group_by)
    if active_returns:
        returns = self.active_returns(group_by=group_by)
    else:
        returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)

    # Run stats
    stats_df = pd.DataFrame({
        &#39;Start&#39;: self.wrapper.index[0],
        &#39;End&#39;: self.wrapper.index[-1],
        &#39;Duration&#39;: self.wrapper.shape[0] * self.wrapper.freq,
        &#39;Init. Cash&#39;: self.get_init_cash(group_by=group_by),
        &#39;Total Profit&#39;: self.total_profit(group_by=group_by),
        &#39;Total Return [%]&#39;: self.total_return(group_by=group_by) * 100,
        &#39;Benchmark Return [%]&#39;: self.total_market_return(group_by=group_by) * 100,
        &#39;Position Coverage [%]&#39;: self.pos_coverage(group_by=group_by) * 100,
        &#39;Max. Drawdown [%]&#39;: -drawdowns.max_drawdown() * 100,
        &#39;Avg. Drawdown [%]&#39;: -drawdowns.avg_drawdown() * 100,
        &#39;Max. Drawdown Duration&#39;: drawdowns.max_duration(),
        &#39;Avg. Drawdown Duration&#39;: drawdowns.avg_duration(),
        &#39;Num. Trades&#39;: trades.count(),
        &#39;Win Rate [%]&#39;: trades.win_rate() * 100,
        &#39;Best Trade [%]&#39;: trades.returns.max() * 100,
        &#39;Worst Trade [%]&#39;: trades.returns.min() * 100,
        &#39;Avg. Trade [%]&#39;: trades.returns.mean() * 100,
        &#39;Max. Trade Duration&#39;: trades.duration.max(time_units=True),
        &#39;Avg. Trade Duration&#39;: trades.duration.mean(time_units=True),
        &#39;Expectancy&#39;: trades.expectancy(),
        &#39;SQN&#39;: trades.sqn(),
        &#39;Gross Exposure&#39;: self.gross_exposure(group_by=group_by).mean(),
        &#39;Sharpe Ratio&#39;: self.sharpe_ratio(reuse_returns=returns, **kwargs),
        &#39;Sortino Ratio&#39;: self.sortino_ratio(reuse_returns=returns, **kwargs),
        &#39;Calmar Ratio&#39;: self.calmar_ratio(reuse_returns=returns, **kwargs)
    }, index=self.wrapper.grouper.get_columns(group_by=group_by))

    # Select columns or reduce
    if stats_df.shape[0] == 1:
        return self.wrapper.wrap_reduced(stats_df.iloc[0], index=stats_df.columns)
    if column is not None:
        return stats_df.loc[column]
    if agg_func is not None:
        agg_stats_sr = pd.Series(index=stats_df.columns, name=agg_func.__name__)
        agg_stats_sr.iloc[:3] = stats_df.iloc[0, :3]
        agg_stats_sr.iloc[3:] = agg_func(stats_df.iloc[:, 3:])
        return agg_stats_sr
    return stats_df</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.tail_ratio"><code class="name flex">
<span>def <span class="ident fname">tail_ratio</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='tail_ratio', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.tail_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.tail_ratio">ReturnsAccessor.tail_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.total_market_return"><code class="name flex">
<span>def <span class="ident fname">total_market_return</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get total market (benchmark) return.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def total_market_return(self, group_by=None):
    &#34;&#34;&#34;Get total market (benchmark) return.&#34;&#34;&#34;
    market_value = to_2d(self.market_value(group_by=group_by), raw=True)
    total_market_return = nb.total_market_return_nb(market_value)
    return self.wrapper.wrap_reduced(total_market_return, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.total_profit"><code class="name flex">
<span>def <span class="ident fname">total_profit</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get total profit per column/group.</p>
<p>Calculated directly from order records (fast).</p>
<p>Uses filled close if <code><a title="vectorbt.portfolio.base.Portfolio.use_filled_close" href="#vectorbt.portfolio.base.Portfolio.use_filled_close">Portfolio.use_filled_close</a></code> is True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def total_profit(self, group_by=None):
    &#34;&#34;&#34;Get total profit per column/group.

    Calculated directly from order records (fast).

    Uses filled close if `Portfolio.use_filled_close` is True.&#34;&#34;&#34;
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        total_profit = to_1d(self.total_profit(group_by=False), raw=True)
        group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
        total_profit = nb.total_profit_grouped_nb(
            total_profit,
            group_lens
        )
    else:
        if self.use_filled_close:
            close = to_2d(self.fill_close(), raw=True)
        else:
            close = to_2d(self.close, raw=True)
        total_profit = nb.total_profit_nb(
            self.wrapper.shape_2d,
            close,
            self.orders.values,
            self.orders.col_mapper.col_map
        )
    return self.wrapper.wrap_reduced(total_profit, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.total_return"><code class="name flex">
<span>def <span class="ident fname">total_return</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get total profit per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def total_return(self, group_by=None):
    &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
    init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
    total_profit = to_1d(self.total_profit(group_by=group_by), raw=True)
    total_return = nb.total_return_nb(total_profit, init_cash)
    return self.wrapper.wrap_reduced(total_return, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.up_capture"><code class="name flex">
<span>def <span class="ident fname">up_capture</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='up_capture', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.up_capture" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.up_capture">ReturnsAccessor.up_capture()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.value"><code class="name flex">
<span>def <span class="ident fname">value</span></span>(<span>self, group_by=None, in_sim_order=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get portfolio value series per column/group.</p>
<p>By default, will generate portfolio value for each asset based on cash flows and thus
independent from other assets, with initial cash and shares being that of the entire group.
Useful for generating returns and comparing assets within the same group.</p>
<p>When <code>group_by</code> is False and <code>in_sim_order</code> is True, returns value generated in
simulation order (see <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">row-major order</a>.
This value cannot be used for generating returns as-is. Useful to analyze how value
evolved throughout simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def value(self, group_by=None, in_sim_order=False):
    &#34;&#34;&#34;Get portfolio value series per column/group.

    By default, will generate portfolio value for each asset based on cash flows and thus
    independent from other assets, with initial cash and shares being that of the entire group.
    Useful for generating returns and comparing assets within the same group.

    When `group_by` is False and `in_sim_order` is True, returns value generated in
    simulation order (see [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
    This value cannot be used for generating returns as-is. Useful to analyze how value
    evolved throughout simulation.&#34;&#34;&#34;
    cash = to_2d(self.cash(group_by=group_by, in_sim_order=in_sim_order), raw=True)
    holding_value = to_2d(self.holding_value(group_by=group_by), raw=True)
    if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
        group_lens = self.wrapper.grouper.get_group_lens()
        call_seq = to_2d(self.call_seq, raw=True)
        value = nb.value_in_sim_order_nb(cash, holding_value, group_lens, call_seq)
        # price of NaN is already addressed by ungrouped_value_nb
    else:
        value = nb.value_nb(cash, holding_value)
    return self.wrapper.wrap(value, group_by=group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.value_at_risk"><code class="name flex">
<span>def <span class="ident fname">value_at_risk</span></span>(<span>self, *args, group_by=None, year_freq=None, ret_func_name='value_at_risk', active_returns=False, in_sim_order=False, reuse_returns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.value_at_risk" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.value_at_risk">ReturnsAccessor.value_at_risk()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self,
        *args,
        group_by=None,
        year_freq=None,
        ret_func_name=ret_func_name,
        active_returns=False,
        in_sim_order=False,
        reuse_returns=None,
        **kwargs):
    if reuse_returns is not None:
        returns = reuse_returns
    else:
        if active_returns:
            returns = self.active_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)
    returns_acc = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq)
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, ret_func_name)
    sig = signature(method)
    arg_names = [p.name for p in sig.parameters.values() if p.kind == p.POSITIONAL_OR_KEYWORD]
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in kwargs:
            new_kwargs[arg_name] = kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABmtJREFUeNrsnD1vFEkQhtve+fIuax9gDDIHQubDSMiQOEByjERGxg+4iL9DRI6A4IhAAkLIIeV0BwEICQJbwpbshRXegDbmkAW2p96erp7qpiqxg9mveWuq3nqme8aWrlw3Gu3FuJ4CFUAF0FABVAANFUAF0FABVAANFUAF0FABVAANFUAF0FABko/M7WULqysLq8v046uryLsfM2aKeuyHlerhs2PQl79x8e33/yaMOQm80H6Q/Tj68Z2s6GQ5iwCXl99fe/eK+j2Om/5Z5N2XjJmmHvvi5R/3n/ShL//X2Zff/ztvzDz1VeuD7ObtI8YM6B/U7RdcJWhufY1+8NiE1Ov/BJb+WHEf79Smfwo9YP0TdhEvHv0/dWzx6QIvvPPoT+iDiomelCY8fgh8wTRw7H9vDwRI/6fPp6Hqb9M/LypGAaAODAvAGfMHN7b+TGEyo+mfl1S1fjsbOlmMvjUx4CU2922rB3re2FhedgUJgDXhKezNnyOnxsbsgaHJMfd56+9TWPWvulYDRgEgC7RtQ5GrlzcbZntDcxpp8oPMNgBstiqQbuHwG3qjzXhLUN+WINB9Wg2A/Ckq24FjRhHgFYC6oPlLGxLcZyMBjn4eYJfkGcYeAKUnt/vM8hJKf0cBZoYDE2csnltjdZ+2/cJDUtSeEkpPtL6h7pOC3jw14U2gCWMWyMZh5BwtYwLMn9rgc5/04SuoDRVF4iZ7Iyb3SWcPSZUglMTNHhnS2y/U3lHzE04AGAQhLgj1oHQBoPqzxR6c0t9RAF4SxzkJ92klyPZeqL07mJ9EShAaxCYMuU8IvbUgANaEwR+Ckjii+4Tarx2+6OjNgwC8JK7LmAqLF9a8p3+T9usoQNQkjuI+oXu/KHoT3wM4SRylAcDus2p6zcICoCQOK0GcJI4yhUHus5MV450stAAoiZMzCdcOAaj7LJtV/+htKEriagWA2q/NfQf05qMJIyQOnsI4Sdz+UxjqPptX/xA2VNaClH2bMGR+nNFbUiUIJXEe609eeetsvALAHZiNxNWmP91QfUNv7Qkwt77K5UENI4nbvwFA6Q8t+9FJuN4CWfcJXUxN0JvsHsBJ4o7P7CnAA5A9eEx/WADeBSmcJK7fHe3lPiH/U/gYvtwFmBl+itQy7dWEA6M32SWIeU2cB/dZ+ucqmAC9zS/Q8XJI3K43AyD36bbsx7MAcxvY3Ri5u8Nc3CfLj4l1EoZI3K4NwFYwehGzpT/Ly8gEkEPidp3CsPT3bX4cBVj4uMIoQMApDLr16BG9pVOCIBL36xR29zFkfirGOsH31nJI3K9T2IOn1PRvuOzHtwuKk8T91IShRz74RW+N54Ak1qRA8CcrKtYvI6YHcJK4nVOYrV30bRcc7MFdgHhJnED36SJApCRuZwOA3OfWsh/m9JdUgthI3M4pDHKfJX/6YwJESuJ2TmF098mE3hoJECmJ+zGFQZt+WYev6CdhCET/mMLo7ZeVPQQSgJXEOSxIgTb9FkGqPyxApCRuO+jLnpvsuPtdShAUdgqDNv36WvTZsgCsJO7FP9jWMPqtR2701swFRUjithsAvf023HHHPAdESOLsFAa5z5DtV1IPAC/6f9+Qx+DuiJ7+AdCbuwCiSBz9dpi9AgD3Gbb9YgJESuIw9NbJ5ArAG2AHRjcnUaIMXv0xAUSROPhBWbVnwdOOO0YBElsTJ6H6xzoJw49JrD0FAdFbIAHkkDhSA6ravFqpAkRN4mrYQxGDAKkG97KfdgSAOzDSAlESV1N/ym67GUB2QawkrqWT4H3HHecckOJzmoqWhi9hPQAcgOgkbv9weNB2awLIely6p0dEtDh8wQLEuzt1zy4VatlPgjbUC4krKimohCQAL4mbBgVoTOL4dtxxCZAYiZNgfmItQc1JXLvoLYQAMAiaBI5tTuKCLfr0KQAviQtoRsIv+0nQBTVjDxOtswd2ASSTuLwSZw9oLigJEtfKsh9Pc0ASJE6U+xTTA0KRuDA77lgESIPElSLTnyRAAiRODnqL3oa6kThpwxcmAErisEGMn8RJYw+wACiJk7YmpZBa/eMrQQ4kzs69cshzCAHgMZiZxLW+7KfeNNYesVz17p2+QK8/xWvk84fAJGwbAOompaG3XVJ26cp1o6E9QAXQUAFUAA0VQAXQUAFUAA0VQAXQUAFUAA0VQAXQUAFUAA2++CrAAE3lth2zPPJAAAAAAElFTkSuQmCC"/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul>
<li><a href="#workflow">Workflow</a><ul>
<li><a href="#example">Example</a></li>
</ul>
</li>
<li><a href="#broadcasting">Broadcasting</a></li>
<li><a href="#grouping">Grouping</a></li>
<li><a href="#indexing">Indexing</a></li>
<li><a href="#logging">Logging</a></li>
<li><a href="#caching">Caching</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.portfolio" href="index.html">vectorbt.portfolio</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.portfolio.base.add_returns_methods" href="#vectorbt.portfolio.base.add_returns_methods">add_returns_methods</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.portfolio.base.Portfolio.active_returns" href="#vectorbt.portfolio.base.Portfolio.active_returns">active_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.alpha" href="#vectorbt.portfolio.base.Portfolio.alpha">alpha</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.annual_returns" href="#vectorbt.portfolio.base.Portfolio.annual_returns">annual_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.annualized_return" href="#vectorbt.portfolio.base.Portfolio.annualized_return">annualized_return</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.annualized_volatility" href="#vectorbt.portfolio.base.Portfolio.annualized_volatility">annualized_volatility</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.beta" href="#vectorbt.portfolio.base.Portfolio.beta">beta</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.call_seq" href="#vectorbt.portfolio.base.Portfolio.call_seq">call_seq</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.calmar_ratio" href="#vectorbt.portfolio.base.Portfolio.calmar_ratio">calmar_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.capture" href="#vectorbt.portfolio.base.Portfolio.capture">capture</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cash" href="#vectorbt.portfolio.base.Portfolio.cash">cash</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cash_flow" href="#vectorbt.portfolio.base.Portfolio.cash_flow">cash_flow</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cash_sharing" href="#vectorbt.portfolio.base.Portfolio.cash_sharing">cash_sharing</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.close" href="#vectorbt.portfolio.base.Portfolio.close">close</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.conditional_value_at_risk" href="#vectorbt.portfolio.base.Portfolio.conditional_value_at_risk">conditional_value_at_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cumulative_returns" href="#vectorbt.portfolio.base.Portfolio.cumulative_returns">cumulative_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.daily_returns" href="#vectorbt.portfolio.base.Portfolio.daily_returns">daily_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.deflated_sharpe_ratio" href="#vectorbt.portfolio.base.Portfolio.deflated_sharpe_ratio">deflated_sharpe_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.down_capture" href="#vectorbt.portfolio.base.Portfolio.down_capture">down_capture</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.downside_risk" href="#vectorbt.portfolio.base.Portfolio.downside_risk">downside_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.drawdown" href="#vectorbt.portfolio.base.Portfolio.drawdown">drawdown</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.drawdowns" href="#vectorbt.portfolio.base.Portfolio.drawdowns">drawdowns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.fill_close" href="#vectorbt.portfolio.base.Portfolio.fill_close">fill_close</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.final_value" href="#vectorbt.portfolio.base.Portfolio.final_value">final_value</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_holding" href="#vectorbt.portfolio.base.Portfolio.from_holding">from_holding</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">from_order_func</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">from_orders</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_random" href="#vectorbt.portfolio.base.Portfolio.from_random">from_random</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">from_signals</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.get_drawdowns" href="#vectorbt.portfolio.base.Portfolio.get_drawdowns">get_drawdowns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.get_init_cash" href="#vectorbt.portfolio.base.Portfolio.get_init_cash">get_init_cash</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.get_logs" href="#vectorbt.portfolio.base.Portfolio.get_logs">get_logs</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.get_orders" href="#vectorbt.portfolio.base.Portfolio.get_orders">get_orders</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.get_positions" href="#vectorbt.portfolio.base.Portfolio.get_positions">get_positions</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.get_trades" href="#vectorbt.portfolio.base.Portfolio.get_trades">get_trades</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.gross_exposure" href="#vectorbt.portfolio.base.Portfolio.gross_exposure">gross_exposure</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.holding_value" href="#vectorbt.portfolio.base.Portfolio.holding_value">holding_value</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.incl_unrealized" href="#vectorbt.portfolio.base.Portfolio.incl_unrealized">incl_unrealized</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.information_ratio" href="#vectorbt.portfolio.base.Portfolio.information_ratio">information_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.init_cash" href="#vectorbt.portfolio.base.Portfolio.init_cash">init_cash</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.log_records" href="#vectorbt.portfolio.base.Portfolio.log_records">log_records</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.logs" href="#vectorbt.portfolio.base.Portfolio.logs">logs</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.market_returns" href="#vectorbt.portfolio.base.Portfolio.market_returns">market_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.market_value" href="#vectorbt.portfolio.base.Portfolio.market_value">market_value</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.max_drawdown" href="#vectorbt.portfolio.base.Portfolio.max_drawdown">max_drawdown</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.net_exposure" href="#vectorbt.portfolio.base.Portfolio.net_exposure">net_exposure</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.omega_ratio" href="#vectorbt.portfolio.base.Portfolio.omega_ratio">omega_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.order_records" href="#vectorbt.portfolio.base.Portfolio.order_records">order_records</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.orders" href="#vectorbt.portfolio.base.Portfolio.orders">orders</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.plot" href="#vectorbt.portfolio.base.Portfolio.plot">plot</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.pos_coverage" href="#vectorbt.portfolio.base.Portfolio.pos_coverage">pos_coverage</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.pos_mask" href="#vectorbt.portfolio.base.Portfolio.pos_mask">pos_mask</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.positions" href="#vectorbt.portfolio.base.Portfolio.positions">positions</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.regroup" href="#vectorbt.portfolio.base.Portfolio.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.returns" href="#vectorbt.portfolio.base.Portfolio.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.returns_stats" href="#vectorbt.portfolio.base.Portfolio.returns_stats">returns_stats</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.share_flow" href="#vectorbt.portfolio.base.Portfolio.share_flow">share_flow</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.shares" href="#vectorbt.portfolio.base.Portfolio.shares">shares</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.sharpe_ratio" href="#vectorbt.portfolio.base.Portfolio.sharpe_ratio">sharpe_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.sortino_ratio" href="#vectorbt.portfolio.base.Portfolio.sortino_ratio">sortino_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.stats" href="#vectorbt.portfolio.base.Portfolio.stats">stats</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.subplot_settings" href="#vectorbt.portfolio.base.Portfolio.subplot_settings">subplot_settings</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.tail_ratio" href="#vectorbt.portfolio.base.Portfolio.tail_ratio">tail_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.total_market_return" href="#vectorbt.portfolio.base.Portfolio.total_market_return">total_market_return</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.total_profit" href="#vectorbt.portfolio.base.Portfolio.total_profit">total_profit</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.total_return" href="#vectorbt.portfolio.base.Portfolio.total_return">total_return</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.trades" href="#vectorbt.portfolio.base.Portfolio.trades">trades</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.up_capture" href="#vectorbt.portfolio.base.Portfolio.up_capture">up_capture</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.use_filled_close" href="#vectorbt.portfolio.base.Portfolio.use_filled_close">use_filled_close</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.value" href="#vectorbt.portfolio.base.Portfolio.value">value</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.value_at_risk" href="#vectorbt.portfolio.base.Portfolio.value_at_risk">value_at_risk</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>