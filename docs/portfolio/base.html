<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.portfolio.base API documentation</title>
<meta name="description" content="Base class for modeling portfolio and measuring its performance â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:rgba(0,0,0,.2);border:none;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3A4D6B}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://github.com/polakowo/vectorbt/blob/master/favicon.ico?raw=true">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.portfolio.base</code></h1>
</header>
<section id="section-intro">
<p>Base class for modeling portfolio and measuring its performance.</p>
<p>The job of the <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> class is to create a series of positions allocated
against a cash component, produce an equity curve, incorporate basic transaction costs
and produce a set of statistics about its performance. In particular it outputs
position/profit metrics and drawdown information.</p>
<h2 id="workflow">Workflow</h2>
<p><code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> class can be instantiated using main price of the asset, initial capital,
records of filled orders, and cash and shares balances (as a result of filling orders).
It also accepts many other parameters such as annualization factor.</p>
<ul>
<li>Order records are used to track trades and positions, and to measure their performance.</li>
<li>Main price, initial capital, and balances are used to compute risk and performance metrics.</li>
</ul>
<p>To simplify creation of order records and keeping track of balances, it exposes several convenience methods
with prefix <code>from_</code>. For example, you can use <code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">Portfolio.from_signals()</a></code> method to create and fill orders
based on entry and exit signals. Alternatively, you can use <code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">Portfolio.from_order_func()</a></code> to define
a custom order function. The results are then automatically passed to the constructor method of
<code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> and you will receive a portfolio instance ready to be used for performance measurements.</p>
<h2 id="properties">Properties</h2>
<p>The <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> class offers numerous properties for measuring the performance of a strategy.
They can be categorized as follows:</p>
<ul>
<li>Time series indexed by time, such as <code><a title="vectorbt.portfolio.base.Portfolio.returns" href="#vectorbt.portfolio.base.Portfolio.returns">Portfolio.returns</a></code>.</li>
<li>Metrics indexed by columns, such as <code><a title="vectorbt.portfolio.base.Portfolio.total_profit" href="#vectorbt.portfolio.base.Portfolio.total_profit">Portfolio.total_profit</a></code>.</li>
<li>Group objects with own time series and metrics, such as <code><a title="vectorbt.portfolio.base.Portfolio.positions" href="#vectorbt.portfolio.base.Portfolio.positions">Portfolio.positions</a></code>.</li>
</ul>
<h3 id="caching">Caching</h3>
<p>Each property is cached, thus properties can effectively build upon each other, without side effects.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Due to caching, <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> class is meant to be atomic and immutable, thus each public attribute
is marked as read-only. To change any parameter, you need to create a new <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> instance.</p>
</div>
<h2 id="indexing">Indexing</h2>
<p>In addition, you can use pandas indexing on the <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> class itself, which forwards
indexing operation to each <code>__init__</code> argument with pandas type:</p>
<pre><code class="python-repl">&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; index = pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5)
... ])
&gt;&gt;&gt; price = pd.Series([1, 2, 3, 2, 1], index=index, name='a')
&gt;&gt;&gt; orders = pd.DataFrame({
...     'a': [np.inf, 0, 0, 0, 0],
...     'b': [1, 1, 1, 1, -np.inf],
...     'c': [np.inf, -np.inf, np.inf, -np.inf, np.inf]
... }, index=index)
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, init_capital=100)

&gt;&gt;&gt; print(portfolio.equity)
                a      b           c
2020-01-01  100.0  100.0  100.000000
2020-01-02  200.0  101.0  200.000000
2020-01-03  300.0  103.0  200.000000
2020-01-04  200.0  100.0  133.333333
2020-01-05  100.0   96.0  133.333333
&gt;&gt;&gt; print(portfolio['a'].equity)
2020-01-01    100.0
2020-01-02    200.0
2020-01-03    300.0
2020-01-04    200.0
2020-01-05    100.0
Name: a, dtype: float64
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Changing index (time axis) is not supported.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Base class for modeling portfolio and measuring its performance.

The job of the `Portfolio` class is to create a series of positions allocated 
    against a cash component, produce an equity curve, incorporate basic transaction costs 
    and produce a set of statistics about its performance. In particular it outputs 
    position/profit metrics and drawdown information.

## Workflow

`Portfolio` class can be instantiated using main price of the asset, initial capital, 
records of filled orders, and cash and shares balances (as a result of filling orders).
It also accepts many other parameters such as annualization factor.

* Order records are used to track trades and positions, and to measure their performance.
* Main price, initial capital, and balances are used to compute risk and performance metrics.

To simplify creation of order records and keeping track of balances, it exposes several convenience methods
with prefix `from_`. For example, you can use `Portfolio.from_signals` method to create and fill orders 
based on entry and exit signals. Alternatively, you can use `Portfolio.from_order_func` to define 
a custom order function. The results are then automatically passed to the constructor method of 
`Portfolio` and you will receive a portfolio instance ready to be used for performance measurements.

## Properties

The `Portfolio` class offers numerous properties for measuring the performance of a strategy. 
They can be categorized as follows:

* Time series indexed by time, such as `Portfolio.returns`.
* Metrics indexed by columns, such as `Portfolio.total_profit`.
* Group objects with own time series and metrics, such as `Portfolio.positions`.

### Caching

Each property is cached, thus properties can effectively build upon each other, without side effects.

!!! note
    Due to caching, `Portfolio` class is meant to be atomic and immutable, thus each public attribute
    is marked as read-only. To change any parameter, you need to create a new `Portfolio` instance.

## Indexing

In addition, you can use pandas indexing on the `Portfolio` class itself, which forwards
indexing operation to each `__init__` argument with pandas type:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; index = pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5)
... ])
&gt;&gt;&gt; price = pd.Series([1, 2, 3, 2, 1], index=index, name=&#39;a&#39;)
&gt;&gt;&gt; orders = pd.DataFrame({
...     &#39;a&#39;: [np.inf, 0, 0, 0, 0],
...     &#39;b&#39;: [1, 1, 1, 1, -np.inf],
...     &#39;c&#39;: [np.inf, -np.inf, np.inf, -np.inf, np.inf]
... }, index=index)
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders, init_capital=100)

&gt;&gt;&gt; print(portfolio.equity)
                a      b           c
2020-01-01  100.0  100.0  100.000000
2020-01-02  200.0  101.0  200.000000
2020-01-03  300.0  103.0  200.000000
2020-01-04  200.0  100.0  133.333333
2020-01-05  100.0   96.0  133.333333
&gt;&gt;&gt; print(portfolio[&#39;a&#39;].equity)
2020-01-01    100.0
2020-01-02    200.0
2020-01-03    300.0
2020-01-04    200.0
2020-01-05    100.0
Name: a, dtype: float64
```

!!! note
    Changing index (time axis) is not supported.&#34;&#34;&#34;

import numpy as np
import pandas as pd

from vectorbt import tseries, defaults
from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base import reshape_fns
from vectorbt.base.indexing import PandasIndexer
from vectorbt.tseries.common import TSArrayWrapper
from vectorbt.portfolio import nb
from vectorbt.records import Orders, Trades, Positions, Drawdowns


def _indexing_func(obj, pd_indexing_func):
    &#34;&#34;&#34;Perform indexing on `Portfolio`.&#34;&#34;&#34;
    if obj.wrapper.ndim == 1:
        raise Exception(&#34;Indexing on Series is not supported&#34;)

    n_rows = len(obj.wrapper.index)
    n_cols = len(obj.wrapper.columns)
    col_mapper = obj.wrapper.wrap(np.broadcast_to(np.arange(n_cols), (n_rows, n_cols)))
    col_mapper = pd_indexing_func(col_mapper)
    if not pd.Index.equals(col_mapper.index, obj.wrapper.index):
        raise Exception(&#34;Changing index (time axis) is not supported&#34;)
    new_cols = col_mapper.values[0]

    # Array-like params
    def index_arraylike_param(param):
        if np.asarray(param).ndim &gt; 0:
            param = reshape_fns.broadcast_to_axis_of(param, obj.main_price, 1)
            param = param[new_cols]
        return param

    factor_returns = obj.factor_returns
    if factor_returns is not None:
        if checks.is_frame(factor_returns):
            factor_returns = reshape_fns.broadcast_to(factor_returns, obj.main_price)
            factor_returns = pd_indexing_func(factor_returns)

    # Create new Portfolio instance
    return obj.__class__(
        pd_indexing_func(obj.main_price),
        obj.init_capital.iloc[new_cols],
        pd_indexing_func(obj.orders),  # Orders class supports indexing
        pd_indexing_func(obj.cash),
        pd_indexing_func(obj.shares),
        freq=obj.freq,
        year_freq=obj.year_freq,
        levy_alpha=index_arraylike_param(obj.levy_alpha),
        risk_free=index_arraylike_param(obj.risk_free),
        required_return=index_arraylike_param(obj.required_return),
        cutoff=index_arraylike_param(obj.cutoff),
        factor_returns=factor_returns
    )


class Portfolio(PandasIndexer):
    &#34;&#34;&#34;Class for modeling portfolio and measuring its performance.

    Args:
        main_price (pandas_like): Main price of the asset.
        init_capital (int, float or pd.Series): The initial capital.

            If `pd.Series`, must have the same index as columns in `main_price`.
        orders (vectorbt.records.orders.Orders): Order records.
        cash (pandas_like): Cash held at each time step.

            Must have the same metadata as `main_price`.
        shares (pandas_like): Shares held at each time step.

            Must have the same metadata as `main_price`.
        freq (any): Index frequency in case `main_price.index` is not datetime-like.
        year_freq (any): Year frequency for working with returns.
        levy_alpha (float or array_like): Scaling relation (Levy stability exponent).
        risk_free (float or array_like): Constant risk-free return throughout the period.
        required_return (float or array_like): Minimum acceptance return of the investor.
        cutoff (float or array_like): Decimal representing the percentage cutoff for the
                bottom percentile of returns.
        factor_returns (array_like): Benchmark return to compare returns against. Will broadcast.

            By default it&#39;s `None`, but it&#39;s required by some return-based metrics.

    !!! note
        Use class methods with `from_` prefix to build a portfolio.
        The `__init__` method is reserved for indexing purposes.

        All array objects must have the same metadata as `main_price`.&#34;&#34;&#34;

    def __init__(self, main_price, init_capital, orders, cash, shares, freq=None, year_freq=None,
                 levy_alpha=None, risk_free=None, required_return=None, cutoff=None,
                 factor_returns=None):
        # Perform checks
        checks.assert_type(main_price, (pd.Series, pd.DataFrame))
        if checks.is_frame(main_price):
            checks.assert_type(init_capital, pd.Series)
            checks.assert_same(main_price.columns, init_capital.index)
        else:
            checks.assert_ndim(init_capital, 0)
        checks.assert_same_meta(main_price, cash)
        checks.assert_same_meta(main_price, shares)

        # Store passed arguments
        self._main_price = main_price
        self._init_capital = init_capital
        self._orders = orders
        self._cash = cash
        self._shares = shares

        freq = main_price.vbt.tseries(freq=freq).freq
        if freq is None:
            raise Exception(&#34;Couldn&#39;t parse the frequency of index. You must set `freq`.&#34;)
        self._freq = freq

        year_freq = main_price.vbt.returns(year_freq=year_freq).year_freq
        if freq is None:
            raise Exception(&#34;You must set `year_freq`.&#34;)
        self._year_freq = year_freq

        # Parameters
        self._levy_alpha = defaults.portfolio[&#39;levy_alpha&#39;] if levy_alpha is None else levy_alpha
        self._risk_free = defaults.portfolio[&#39;risk_free&#39;] if risk_free is None else risk_free
        self._required_return = defaults.portfolio[&#39;required_return&#39;] if required_return is None else required_return
        self._cutoff = defaults.portfolio[&#39;cutoff&#39;] if cutoff is None else cutoff
        self._factor_returns = defaults.portfolio[&#39;factor_returns&#39;] if factor_returns is None else factor_returns

        # Supercharge
        PandasIndexer.__init__(self, _indexing_func)
        self.wrapper = TSArrayWrapper.from_obj(main_price, freq=freq)

    # ############# Class methods ############# #

    @classmethod
    def from_signals(cls, main_price, entries, exits, size=np.inf, entry_price=None, exit_price=None,
                     init_capital=None, fees=None, fixed_fees=None, slippage=None, accumulate=False,
                     broadcast_kwargs={}, freq=None, **kwargs):
        &#34;&#34;&#34;Build portfolio from entry and exit signals.

        At each entry signal in `entries`, buys `size` of shares for `entry_price` to enter
        a position. At each exit signal in `exits`, sells everything for `exit_price`
        to exit the position. Accumulation of orders is disabled by default.

        Args:
            main_price (pandas_like): Main price of the asset, such as close.
            entries (array_like): Boolean array of entry signals.
            exits (array_like): Boolean array of exit signals.
            size (int, float or array_like): The amount of shares to order.

                To buy/sell everything, set the size to `numpy.inf`.
            entry_price (array_like): Entry price. Defaults to `main_price`.
            exit_price (array_like): Exit price. Defaults to `main_price`.
            init_capital (int, float or array_like): The initial capital.

                If array, should match the number of columns.
            fees (float or array_like): Fees in percentage of the order value.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order.
            slippage (float or array_like): Slippage in percentage of price.
            accumulate (bool): If `accumulate` is `True`, entering the market when already
                in the market will be allowed to increase a position.
            broadcast_kwargs: Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            freq (any): Index frequency in case `main_price.index` is not datetime-like.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All time series will be broadcasted together using `vectorbt.base.reshape_fns.broadcast`.
        At the end, they will have the same metadata.

        Example:
            Portfolio from various signal sequences:
            ```python-repl
            &gt;&gt;&gt; entries = pd.DataFrame({
            ...     &#39;a&#39;: [True, False, False, False, False],
            ...     &#39;b&#39;: [True, False, True, False, True],
            ...     &#39;c&#39;: [True, True, True, True, True]
            ... }, index=index)
            &gt;&gt;&gt; exits = pd.DataFrame({
            ...     &#39;a&#39;: [False, False, False, False, False],
            ...     &#39;b&#39;: [False, True, False, True, False],
            ...     &#39;c&#39;: [True, True, True, True, True]
            ... }, index=index)
            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
            ...     price, entries, exits, size=10,
            ...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

            &gt;&gt;&gt; print(portfolio.orders.records)
               col  idx  size  price      fees  side
            0    0    0  10.0  1.001  1.025025     0
            1    1    0  10.0  1.001  1.025025     0
            2    1    1  10.0  1.998  1.049950     1
            3    1    2  10.0  3.003  1.075075     0
            4    1    3  10.0  1.998  1.049950     1
            5    1    4  10.0  1.001  1.025025     0
            6    2    0  10.0  1.001  1.025025     0
            &gt;&gt;&gt; print(portfolio.equity)
                                 a           b           c
            2020-01-01   98.964975   98.964975   98.964975
            2020-01-02  108.964975  107.895025  108.964975
            2020-01-03  118.964975  106.789950  118.964975
            2020-01-04  108.964975   95.720000  108.964975
            2020-01-05   98.964975   94.684975   98.964975
            ```
        &#34;&#34;&#34;
        # Get defaults
        if entry_price is None:
            entry_price = main_price
        if exit_price is None:
            exit_price = main_price
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(main_price, (pd.Series, pd.DataFrame))
        checks.assert_dtype(entries, np.bool_)
        checks.assert_dtype(exits, np.bool_)

        # Broadcast inputs
        main_price, entries, exits, size, entry_price, exit_price, fees, fixed_fees, slippage = \
            reshape_fns.broadcast(
                main_price, entries, exits, size, entry_price, exit_price, fees,
                fixed_fees, slippage, **broadcast_kwargs, writeable=True)
        target_shape = (main_price.shape[0], main_price.shape[1] if main_price.ndim &gt; 1 else 1)
        init_capital = np.broadcast_to(init_capital, (target_shape[1],))

        # Perform calculation
        order_records, cash, shares = nb.simulate_from_signals_nb(
            target_shape,
            init_capital,
            reshape_fns.to_2d(entries, raw=True),
            reshape_fns.to_2d(exits, raw=True),
            reshape_fns.to_2d(size, raw=True),
            reshape_fns.to_2d(entry_price, raw=True),
            reshape_fns.to_2d(exit_price, raw=True),
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(fixed_fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            accumulate)

        # Bring to the same meta
        wrapper = TSArrayWrapper.from_obj(main_price, freq=freq)
        cash = wrapper.wrap(cash)
        shares = wrapper.wrap(shares)
        orders = Orders(order_records, main_price, freq=freq)
        if checks.is_series(main_price):
            init_capital = init_capital[0]
        else:
            init_capital = wrapper.wrap_reduced(init_capital)

        return cls(main_price, init_capital, orders, cash, shares, freq=freq, **kwargs)

    @classmethod
    def from_orders(cls, main_price, order_size, order_price=None, init_capital=None, fees=None, fixed_fees=None,
                    slippage=None, is_target=False, broadcast_kwargs={}, freq=None, **kwargs):
        &#34;&#34;&#34;Build portfolio from orders.

        Starting with initial capital `init_capital`, at each time step, orders the number
        of shares specified in `order_size` for `order_price`.

        Args:
            main_price (pandas_like): Main price of the asset, such as close.
            order_size (int, float or array_like): The amount of shares to order.

                If the size is positive, this is the number of shares to buy.
                If the size is negative, this is the number of shares to sell.
                To buy/sell everything, set the size to `numpy.inf`.
            order_price (array_like): Order price. Defaults to `main_price`.
            init_capital (int, float or array_like): The initial capital.

                If array, should match the number of columns.
            fees (float or array_like): Fees in percentage of the order value.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order.
            slippage (float or array_like): Slippage in percentage of `order_price`.
            is_target (bool): If `True`, will order the difference between current and target size.
            broadcast_kwargs: Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            freq (any): Index frequency in case `main_price.index` is not datetime-like.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All time series will be broadcasted together using `vectorbt.base.reshape_fns.broadcast`.
        At the end, they will have the same metadata.

        Example:
            Portfolio from various order sequences:
            ```python-repl
            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders,
            ...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

            &gt;&gt;&gt; print(portfolio.orders.records)
                col  idx        size  price      fees  side
            0     0    0   98.654463  1.001  1.246883     0
            1     1    0    1.000000  1.001  1.002502     0
            2     1    1    1.000000  2.002  1.005005     0
            3     1    2    1.000000  3.003  1.007507     0
            4     1    3    1.000000  2.002  1.005005     0
            5     1    4    4.000000  0.999  1.009990     1
            6     2    0   98.654463  1.001  1.246883     0
            7     2    1   98.654463  1.998  1.492779     1
            8     2    2   64.646521  3.003  1.485334     0
            9     2    3   64.646521  1.998  1.322909     1
            10    2    4  126.398131  1.001  1.316311     0
            &gt;&gt;&gt; print(portfolio.equity)
                                 a          b           c
            2020-01-01   98.654463  98.996498   98.654463
            2020-01-02  197.308925  98.989493  195.618838
            2020-01-03  295.963388  99.978985  193.939564
            2020-01-04  197.308925  95.971980  127.840840
            2020-01-05   98.654463  90.957990  126.398131
            ```
        &#34;&#34;&#34;
        # Get defaults
        if order_price is None:
            order_price = main_price
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(main_price, (pd.Series, pd.DataFrame))

        # Broadcast inputs
        main_price, order_size, order_price, fees, fixed_fees, slippage = \
            reshape_fns.broadcast(main_price, order_size, order_price, fees, fixed_fees,
                                  slippage, **broadcast_kwargs, writeable=True)
        target_shape = (main_price.shape[0], main_price.shape[1] if main_price.ndim &gt; 1 else 1)
        init_capital = np.broadcast_to(init_capital, (target_shape[1],))

        # Perform calculation
        order_records, cash, shares = nb.simulate_from_orders_nb(
            target_shape,
            init_capital,
            reshape_fns.to_2d(order_size, raw=True),
            reshape_fns.to_2d(order_price, raw=True),
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(fixed_fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            is_target)

        # Bring to the same meta
        wrapper = TSArrayWrapper.from_obj(main_price, freq=freq)
        cash = wrapper.wrap(cash)
        shares = wrapper.wrap(shares)
        orders = Orders(order_records, main_price, freq=freq)
        if checks.is_series(main_price):
            init_capital = init_capital[0]
        else:
            init_capital = wrapper.wrap_reduced(init_capital)

        return cls(main_price, init_capital, orders, cash, shares, freq=freq, **kwargs)

    @classmethod
    def from_order_func(cls, main_price, order_func_nb, *args, init_capital=None, freq=None, **kwargs):
        &#34;&#34;&#34;Build portfolio from a custom order function.

        Starting with initial capital `init_capital`, iterates over shape `main_price.shape`, and for
        each data point, generates an order using `order_func_nb`. This way, you can specify order
        size, price and transaction costs dynamically (for example, based on the current balance).

        To iterate over a bigger shape than `main_price`, you should tile/repeat `main_price` to the desired shape.

        Args:
            main_price (pandas_like): Main price of the asset, such as close.

                Must be a pandas object.
            order_func_nb (function): Function that returns an order.

                See `vectorbt.portfolio.enums.Order`.
            *args: Arguments passed to `order_func_nb`.
            init_capital (int, float or array_like): The initial capital.

                If array, should match the number of columns.
            freq (any): Index frequency in case `main_price.index` is not datetime-like.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All time series will be broadcasted together using `vectorbt.base.reshape_fns.broadcast`.
        At the end, they will have the same metadata.

        !!! note
            `order_func_nb` must be Numba-compiled.

        Example:
            Portfolio from buying daily:
            ```python-repl
            &gt;&gt;&gt; from vectorbt.portfolio import Order

            &gt;&gt;&gt; @njit
            ... def order_func_nb(col, i, run_cash, run_shares, price):
            ...     return Order(10, price[i], fees=0.01, fixed_fees=1., slippage=0.01)

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
            ...     price, order_func_nb, price.values, init_capital=100)

            &gt;&gt;&gt; print(portfolio.orders.records)
               col  idx  size  price   fees  side
            0    0    0  10.0   1.01  1.101     0
            1    0    1  10.0   2.02  1.202     0
            2    0    2  10.0   3.03  1.303     0
            3    0    3  10.0   2.02  1.202     0
            4    0    4  10.0   1.01  1.101     0
            &gt;&gt;&gt; print(portfolio.equity)
            2020-01-01     98.799
            2020-01-02    107.397
            2020-01-03    125.794
            2020-01-04     94.392
            2020-01-05     53.191
            Name: a, dtype: float64
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]

        # Perform checks
        checks.assert_type(main_price, (pd.Series, pd.DataFrame))
        checks.assert_numba_func(order_func_nb)

        # Broadcast inputs
        target_shape = (main_price.shape[0], main_price.shape[1] if main_price.ndim &gt; 1 else 1)
        init_capital = np.broadcast_to(init_capital, (target_shape[1],))

        # Perform calculation
        order_records, cash, shares = nb.simulate_nb(
            target_shape,
            init_capital,
            order_func_nb,
            *args)

        # Bring to the same meta
        wrapper = TSArrayWrapper.from_obj(main_price, freq=freq)
        cash = wrapper.wrap(cash)
        shares = wrapper.wrap(shares)
        orders = Orders(order_records, main_price, freq=freq)
        if checks.is_series(main_price):
            init_capital = init_capital[0]
        else:
            init_capital = wrapper.wrap_reduced(init_capital)

        return cls(main_price, init_capital, orders, cash, shares, freq=freq, **kwargs)

    # ############# Passed arguments ############# #

    @property
    def init_capital(self):
        &#34;&#34;&#34;Initial capital.&#34;&#34;&#34;
        return self._init_capital

    @cached_property
    def main_price(self):
        &#34;&#34;&#34;Price per share series.&#34;&#34;&#34;
        return self._main_price

    @cached_property
    def cash(self):
        &#34;&#34;&#34;Cash series.&#34;&#34;&#34;
        return self._cash

    @cached_property
    def shares(self):
        &#34;&#34;&#34;Shares series.&#34;&#34;&#34;
        return self._shares

    @property
    def freq(self):
        &#34;&#34;&#34;Index frequency.&#34;&#34;&#34;
        return self._freq

    @property
    def year_freq(self):
        &#34;&#34;&#34;Year frequency.&#34;&#34;&#34;
        return self._year_freq

    @property
    def levy_alpha(self):
        &#34;&#34;&#34;Scaling relation (Levy stability exponent).&#34;&#34;&#34;
        return self._levy_alpha

    @property
    def risk_free(self):
        &#34;&#34;&#34;Constant risk-free return throughout the period.&#34;&#34;&#34;
        return self._risk_free

    @property
    def required_return(self):
        &#34;&#34;&#34;Minimum acceptance return of the investor.&#34;&#34;&#34;
        return self._required_return

    @property
    def cutoff(self):
        &#34;&#34;&#34;Decimal representing the percentage cutoff for the bottom percentile of returns.&#34;&#34;&#34;
        return self._cutoff

    @property
    def factor_returns(self):
        &#34;&#34;&#34;Benchmark return to compare returns against.&#34;&#34;&#34;
        return self._factor_returns

    # ############# Records ############# #

    @cached_property
    def orders(self):
        &#34;&#34;&#34;Order records.

        See `vectorbt.records.orders.Orders`.&#34;&#34;&#34;
        return self._orders

    @cached_property
    def trades(self):
        &#34;&#34;&#34;Trade records.

        See `vectorbt.records.events.Trades`.&#34;&#34;&#34;
        return Trades.from_orders(self.orders)

    @cached_property
    def positions(self):
        &#34;&#34;&#34;Position records.

        See `vectorbt.records.events.Positions`.&#34;&#34;&#34;
        return Positions.from_orders(self.orders)

    # ############# Equity ############# #

    @cached_property
    def equity(self):
        &#34;&#34;&#34;Portfolio equity series.&#34;&#34;&#34;
        return self.cash.vbt + self.shares.vbt * self.main_price.vbt

    @cached_property
    def final_equity(self):
        &#34;&#34;&#34;Final equity.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(self.equity.values[-1])

    @cached_property
    def peak_equity(self):
        &#34;&#34;&#34;Peak equity.&#34;&#34;&#34;
        return self.equity.vbt.tseries.max()

    @cached_property
    def dip_equity(self):
        &#34;&#34;&#34;Dip equity.&#34;&#34;&#34;
        return self.equity.vbt.tseries.min()

    @cached_property
    def total_profit(self):
        &#34;&#34;&#34;Total profit.&#34;&#34;&#34;
        equity = self.equity.vbt.to_2d_array()[-1, :]
        init_capital = reshape_fns.to_1d(self.init_capital, raw=True)
        return self.wrapper.wrap_reduced(equity - init_capital)

    # ############# Drawdown ############# #

    @cached_property
    def drawdown(self):
        &#34;&#34;&#34;Drawdown series.&#34;&#34;&#34;
        equity = self.equity.vbt.to_2d_array()
        return self.wrapper.wrap(equity / tseries.nb.expanding_max_nb(equity) - 1)

    @cached_property
    def max_drawdown(self):
        &#34;&#34;&#34;Max drawdown.&#34;&#34;&#34;
        return self.drawdown.vbt.tseries.min()

    @cached_property
    def drawdowns(self):
        &#34;&#34;&#34;Drawdown records.

        See `vectorbt.records.drawdowns.Drawdowns`.&#34;&#34;&#34;
        return Drawdowns.from_ts(self.equity, freq=self.freq)

    # ############# Returns ############# #

    @cached_property
    def buy_and_hold_return(self):
        &#34;&#34;&#34;Total return of buying and holding.

        !!! note:
            Does not take into account fees and slippage. For this, create a separate portfolio.&#34;&#34;&#34;
        returns = tseries.nb.pct_change_nb(self.main_price.vbt.to_2d_array())
        return self.wrapper.wrap(returns).vbt.returns.total()

    @cached_property
    def returns(self):
        &#34;&#34;&#34;Portfolio return series.&#34;&#34;&#34;
        equity = self.equity.vbt.to_2d_array()
        returns = tseries.nb.pct_change_nb(equity)
        init_capital = reshape_fns.to_1d(self.init_capital, raw=True)
        returns[0, :] = (equity[0, :] - init_capital) / init_capital
        return self.wrapper.wrap(returns)

    @cached_property
    def daily_returns(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.daily`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .daily()

    @cached_property
    def annual_returns(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.annual`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .annual()

    @cached_property
    def cumulative_returns(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.cumulative`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .cumulative()

    @cached_property
    def total_return(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.total`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .total()

    @cached_property
    def annualized_return(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.annualized_return`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .annualized_return()

    @cached_property
    def annualized_volatility(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.annualized_volatility`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .annualized_volatility(levy_alpha=self.levy_alpha)

    @cached_property
    def calmar_ratio(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.calmar_ratio`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .calmar_ratio()

    @cached_property
    def omega_ratio(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.omega_ratio`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .omega_ratio(risk_free=self.risk_free, required_return=self.required_return)

    @cached_property
    def sharpe_ratio(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.sharpe_ratio`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .sharpe_ratio(risk_free=self.risk_free)

    @cached_property
    def downside_risk(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.downside_risk`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .downside_risk(required_return=self.required_return)

    @cached_property
    def sortino_ratio(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.sortino_ratio`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .sortino_ratio(required_return=self.required_return)

    @cached_property
    def information_ratio(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.information_ratio`.&#34;&#34;&#34;
        if self.factor_returns is None:
            raise Exception(&#34;This property requires factor_returns to be set&#34;)
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .information_ratio(self.factor_returns)

    @cached_property
    def beta(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.beta`.&#34;&#34;&#34;
        if self.factor_returns is None:
            raise Exception(&#34;This property requires factor_returns to be set&#34;)
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .beta(self.factor_returns)

    @cached_property
    def alpha(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.alpha`.&#34;&#34;&#34;
        if self.factor_returns is None:
            raise Exception(&#34;This property requires factor_returns to be set&#34;)
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .alpha(self.factor_returns, risk_free=self.risk_free)

    @cached_property
    def tail_ratio(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.tail_ratio`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .tail_ratio()

    @cached_property
    def value_at_risk(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.value_at_risk`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .value_at_risk(cutoff=self.cutoff)

    @cached_property
    def conditional_value_at_risk(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.conditional_value_at_risk`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .conditional_value_at_risk(cutoff=self.cutoff)

    @cached_property
    def capture(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.capture`.&#34;&#34;&#34;
        if self.factor_returns is None:
            raise Exception(&#34;This property requires factor_returns to be set&#34;)
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .capture(self.factor_returns)

    @cached_property
    def up_capture(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.up_capture`.&#34;&#34;&#34;
        if self.factor_returns is None:
            raise Exception(&#34;This property requires factor_returns to be set&#34;)
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .up_capture(self.factor_returns)

    @cached_property
    def down_capture(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.down_capture`.&#34;&#34;&#34;
        if self.factor_returns is None:
            raise Exception(&#34;This property requires factor_returns to be set&#34;)
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .down_capture(self.factor_returns)

    # ############# Stats ############# #

    @cached_property
    def stats(self):
        &#34;&#34;&#34;Compute various interesting statistics on this portfolio.&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise Exception(&#34;You must select a column first&#34;)

        return pd.Series({
            &#39;Start&#39;: self.wrapper.index[0],
            &#39;End&#39;: self.wrapper.index[-1],
            &#39;Duration&#39;: self.wrapper.shape[0] * self.freq,
            &#39;Time in Position [%]&#39;: self.positions.coverage * 100,
            &#39;Total Profit&#39;: self.total_profit,
            &#39;Total Return [%]&#39;: self.total_return * 100,
            &#39;Buy &amp; Hold Return [%]&#39;: self.buy_and_hold_return * 100,
            &#39;Max. Drawdown [%]&#39;: -self.max_drawdown * 100,
            &#39;Avg. Drawdown [%]&#39;: -self.drawdowns.avg_drawdown * 100,
            &#39;Max. Drawdown Duration&#39;: self.drawdowns.max_duration,
            &#39;Avg. Drawdown Duration&#39;: self.drawdowns.avg_duration,
            &#39;Num. Trades&#39;: self.trades.count,
            &#39;Win Rate [%]&#39;: self.trades.win_rate * 100,
            &#39;Best Trade [%]&#39;: self.trades.max_return * 100,
            &#39;Worst Trade [%]&#39;: self.trades.min_return * 100,
            &#39;Avg. Trade [%]&#39;: self.trades.avg_return * 100,
            &#39;Max. Trade Duration&#39;: self.trades.max_duration,
            &#39;Avg. Trade Duration&#39;: self.trades.avg_duration,
            &#39;Expectancy&#39;: self.trades.expectancy,
            &#39;SQN&#39;: self.trades.sqn,
            &#39;Sharpe Ratio&#39;: self.sharpe_ratio,
            &#39;Sortino Ratio&#39;: self.sortino_ratio,
            &#39;Calmar Ratio&#39;: self.calmar_ratio
        })</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio"><code class="flex name class">
<span>class <span class="ident parent-fname">Portfolio</span></span>
<span>(</span><span>main_price, init_capital, orders, cash, shares, freq=None, year_freq=None, levy_alpha=None, risk_free=None, required_return=None, cutoff=None, factor_returns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for modeling portfolio and measuring its performance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>main_price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Main price of the asset.</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int, float</code> or <code>pd.Series</code></dt>
<dd>
<p>The initial capital.</p>
<p>If <code>pd.Series</code>, must have the same index as columns in <code>main_price</code>.</p>
</dd>
<dt><strong><code>orders</code></strong> :&ensp;<code><a title="vectorbt.records.orders.Orders" href="../records/orders.html#vectorbt.records.orders.Orders">Orders</a></code></dt>
<dd>Order records.</dd>
<dt><strong><code>cash</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>
<p>Cash held at each time step.</p>
<p>Must have the same metadata as <code>main_price</code>.</p>
</dd>
<dt><strong><code>shares</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>
<p>Shares held at each time step.</p>
<p>Must have the same metadata as <code>main_price</code>.</p>
</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Index frequency in case <code>main_price.index</code> is not datetime-like.</dd>
<dt><strong><code>year_freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Year frequency for working with returns.</dd>
<dt><strong><code>levy_alpha</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Scaling relation (Levy stability exponent).</dd>
<dt><strong><code>risk_free</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Constant risk-free return throughout the period.</dd>
<dt><strong><code>required_return</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Minimum acceptance return of the investor.</dd>
<dt><strong><code>cutoff</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Decimal representing the percentage cutoff for the
bottom percentile of returns.</dd>
<dt><strong><code>factor_returns</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>Benchmark return to compare returns against. Will broadcast.</p>
<p>By default it's <code>None</code>, but it's required by some return-based metrics.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use class methods with <code>from_</code> prefix to build a portfolio.
The <code>__init__</code> method is reserved for indexing purposes.</p>
<p>All array objects must have the same metadata as <code>main_price</code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Portfolio(PandasIndexer):
    &#34;&#34;&#34;Class for modeling portfolio and measuring its performance.

    Args:
        main_price (pandas_like): Main price of the asset.
        init_capital (int, float or pd.Series): The initial capital.

            If `pd.Series`, must have the same index as columns in `main_price`.
        orders (vectorbt.records.orders.Orders): Order records.
        cash (pandas_like): Cash held at each time step.

            Must have the same metadata as `main_price`.
        shares (pandas_like): Shares held at each time step.

            Must have the same metadata as `main_price`.
        freq (any): Index frequency in case `main_price.index` is not datetime-like.
        year_freq (any): Year frequency for working with returns.
        levy_alpha (float or array_like): Scaling relation (Levy stability exponent).
        risk_free (float or array_like): Constant risk-free return throughout the period.
        required_return (float or array_like): Minimum acceptance return of the investor.
        cutoff (float or array_like): Decimal representing the percentage cutoff for the
                bottom percentile of returns.
        factor_returns (array_like): Benchmark return to compare returns against. Will broadcast.

            By default it&#39;s `None`, but it&#39;s required by some return-based metrics.

    !!! note
        Use class methods with `from_` prefix to build a portfolio.
        The `__init__` method is reserved for indexing purposes.

        All array objects must have the same metadata as `main_price`.&#34;&#34;&#34;

    def __init__(self, main_price, init_capital, orders, cash, shares, freq=None, year_freq=None,
                 levy_alpha=None, risk_free=None, required_return=None, cutoff=None,
                 factor_returns=None):
        # Perform checks
        checks.assert_type(main_price, (pd.Series, pd.DataFrame))
        if checks.is_frame(main_price):
            checks.assert_type(init_capital, pd.Series)
            checks.assert_same(main_price.columns, init_capital.index)
        else:
            checks.assert_ndim(init_capital, 0)
        checks.assert_same_meta(main_price, cash)
        checks.assert_same_meta(main_price, shares)

        # Store passed arguments
        self._main_price = main_price
        self._init_capital = init_capital
        self._orders = orders
        self._cash = cash
        self._shares = shares

        freq = main_price.vbt.tseries(freq=freq).freq
        if freq is None:
            raise Exception(&#34;Couldn&#39;t parse the frequency of index. You must set `freq`.&#34;)
        self._freq = freq

        year_freq = main_price.vbt.returns(year_freq=year_freq).year_freq
        if freq is None:
            raise Exception(&#34;You must set `year_freq`.&#34;)
        self._year_freq = year_freq

        # Parameters
        self._levy_alpha = defaults.portfolio[&#39;levy_alpha&#39;] if levy_alpha is None else levy_alpha
        self._risk_free = defaults.portfolio[&#39;risk_free&#39;] if risk_free is None else risk_free
        self._required_return = defaults.portfolio[&#39;required_return&#39;] if required_return is None else required_return
        self._cutoff = defaults.portfolio[&#39;cutoff&#39;] if cutoff is None else cutoff
        self._factor_returns = defaults.portfolio[&#39;factor_returns&#39;] if factor_returns is None else factor_returns

        # Supercharge
        PandasIndexer.__init__(self, _indexing_func)
        self.wrapper = TSArrayWrapper.from_obj(main_price, freq=freq)

    # ############# Class methods ############# #

    @classmethod
    def from_signals(cls, main_price, entries, exits, size=np.inf, entry_price=None, exit_price=None,
                     init_capital=None, fees=None, fixed_fees=None, slippage=None, accumulate=False,
                     broadcast_kwargs={}, freq=None, **kwargs):
        &#34;&#34;&#34;Build portfolio from entry and exit signals.

        At each entry signal in `entries`, buys `size` of shares for `entry_price` to enter
        a position. At each exit signal in `exits`, sells everything for `exit_price`
        to exit the position. Accumulation of orders is disabled by default.

        Args:
            main_price (pandas_like): Main price of the asset, such as close.
            entries (array_like): Boolean array of entry signals.
            exits (array_like): Boolean array of exit signals.
            size (int, float or array_like): The amount of shares to order.

                To buy/sell everything, set the size to `numpy.inf`.
            entry_price (array_like): Entry price. Defaults to `main_price`.
            exit_price (array_like): Exit price. Defaults to `main_price`.
            init_capital (int, float or array_like): The initial capital.

                If array, should match the number of columns.
            fees (float or array_like): Fees in percentage of the order value.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order.
            slippage (float or array_like): Slippage in percentage of price.
            accumulate (bool): If `accumulate` is `True`, entering the market when already
                in the market will be allowed to increase a position.
            broadcast_kwargs: Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            freq (any): Index frequency in case `main_price.index` is not datetime-like.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All time series will be broadcasted together using `vectorbt.base.reshape_fns.broadcast`.
        At the end, they will have the same metadata.

        Example:
            Portfolio from various signal sequences:
            ```python-repl
            &gt;&gt;&gt; entries = pd.DataFrame({
            ...     &#39;a&#39;: [True, False, False, False, False],
            ...     &#39;b&#39;: [True, False, True, False, True],
            ...     &#39;c&#39;: [True, True, True, True, True]
            ... }, index=index)
            &gt;&gt;&gt; exits = pd.DataFrame({
            ...     &#39;a&#39;: [False, False, False, False, False],
            ...     &#39;b&#39;: [False, True, False, True, False],
            ...     &#39;c&#39;: [True, True, True, True, True]
            ... }, index=index)
            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
            ...     price, entries, exits, size=10,
            ...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

            &gt;&gt;&gt; print(portfolio.orders.records)
               col  idx  size  price      fees  side
            0    0    0  10.0  1.001  1.025025     0
            1    1    0  10.0  1.001  1.025025     0
            2    1    1  10.0  1.998  1.049950     1
            3    1    2  10.0  3.003  1.075075     0
            4    1    3  10.0  1.998  1.049950     1
            5    1    4  10.0  1.001  1.025025     0
            6    2    0  10.0  1.001  1.025025     0
            &gt;&gt;&gt; print(portfolio.equity)
                                 a           b           c
            2020-01-01   98.964975   98.964975   98.964975
            2020-01-02  108.964975  107.895025  108.964975
            2020-01-03  118.964975  106.789950  118.964975
            2020-01-04  108.964975   95.720000  108.964975
            2020-01-05   98.964975   94.684975   98.964975
            ```
        &#34;&#34;&#34;
        # Get defaults
        if entry_price is None:
            entry_price = main_price
        if exit_price is None:
            exit_price = main_price
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(main_price, (pd.Series, pd.DataFrame))
        checks.assert_dtype(entries, np.bool_)
        checks.assert_dtype(exits, np.bool_)

        # Broadcast inputs
        main_price, entries, exits, size, entry_price, exit_price, fees, fixed_fees, slippage = \
            reshape_fns.broadcast(
                main_price, entries, exits, size, entry_price, exit_price, fees,
                fixed_fees, slippage, **broadcast_kwargs, writeable=True)
        target_shape = (main_price.shape[0], main_price.shape[1] if main_price.ndim &gt; 1 else 1)
        init_capital = np.broadcast_to(init_capital, (target_shape[1],))

        # Perform calculation
        order_records, cash, shares = nb.simulate_from_signals_nb(
            target_shape,
            init_capital,
            reshape_fns.to_2d(entries, raw=True),
            reshape_fns.to_2d(exits, raw=True),
            reshape_fns.to_2d(size, raw=True),
            reshape_fns.to_2d(entry_price, raw=True),
            reshape_fns.to_2d(exit_price, raw=True),
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(fixed_fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            accumulate)

        # Bring to the same meta
        wrapper = TSArrayWrapper.from_obj(main_price, freq=freq)
        cash = wrapper.wrap(cash)
        shares = wrapper.wrap(shares)
        orders = Orders(order_records, main_price, freq=freq)
        if checks.is_series(main_price):
            init_capital = init_capital[0]
        else:
            init_capital = wrapper.wrap_reduced(init_capital)

        return cls(main_price, init_capital, orders, cash, shares, freq=freq, **kwargs)

    @classmethod
    def from_orders(cls, main_price, order_size, order_price=None, init_capital=None, fees=None, fixed_fees=None,
                    slippage=None, is_target=False, broadcast_kwargs={}, freq=None, **kwargs):
        &#34;&#34;&#34;Build portfolio from orders.

        Starting with initial capital `init_capital`, at each time step, orders the number
        of shares specified in `order_size` for `order_price`.

        Args:
            main_price (pandas_like): Main price of the asset, such as close.
            order_size (int, float or array_like): The amount of shares to order.

                If the size is positive, this is the number of shares to buy.
                If the size is negative, this is the number of shares to sell.
                To buy/sell everything, set the size to `numpy.inf`.
            order_price (array_like): Order price. Defaults to `main_price`.
            init_capital (int, float or array_like): The initial capital.

                If array, should match the number of columns.
            fees (float or array_like): Fees in percentage of the order value.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order.
            slippage (float or array_like): Slippage in percentage of `order_price`.
            is_target (bool): If `True`, will order the difference between current and target size.
            broadcast_kwargs: Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            freq (any): Index frequency in case `main_price.index` is not datetime-like.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All time series will be broadcasted together using `vectorbt.base.reshape_fns.broadcast`.
        At the end, they will have the same metadata.

        Example:
            Portfolio from various order sequences:
            ```python-repl
            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders,
            ...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

            &gt;&gt;&gt; print(portfolio.orders.records)
                col  idx        size  price      fees  side
            0     0    0   98.654463  1.001  1.246883     0
            1     1    0    1.000000  1.001  1.002502     0
            2     1    1    1.000000  2.002  1.005005     0
            3     1    2    1.000000  3.003  1.007507     0
            4     1    3    1.000000  2.002  1.005005     0
            5     1    4    4.000000  0.999  1.009990     1
            6     2    0   98.654463  1.001  1.246883     0
            7     2    1   98.654463  1.998  1.492779     1
            8     2    2   64.646521  3.003  1.485334     0
            9     2    3   64.646521  1.998  1.322909     1
            10    2    4  126.398131  1.001  1.316311     0
            &gt;&gt;&gt; print(portfolio.equity)
                                 a          b           c
            2020-01-01   98.654463  98.996498   98.654463
            2020-01-02  197.308925  98.989493  195.618838
            2020-01-03  295.963388  99.978985  193.939564
            2020-01-04  197.308925  95.971980  127.840840
            2020-01-05   98.654463  90.957990  126.398131
            ```
        &#34;&#34;&#34;
        # Get defaults
        if order_price is None:
            order_price = main_price
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]
        if fees is None:
            fees = defaults.portfolio[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = defaults.portfolio[&#39;slippage&#39;]

        # Perform checks
        checks.assert_type(main_price, (pd.Series, pd.DataFrame))

        # Broadcast inputs
        main_price, order_size, order_price, fees, fixed_fees, slippage = \
            reshape_fns.broadcast(main_price, order_size, order_price, fees, fixed_fees,
                                  slippage, **broadcast_kwargs, writeable=True)
        target_shape = (main_price.shape[0], main_price.shape[1] if main_price.ndim &gt; 1 else 1)
        init_capital = np.broadcast_to(init_capital, (target_shape[1],))

        # Perform calculation
        order_records, cash, shares = nb.simulate_from_orders_nb(
            target_shape,
            init_capital,
            reshape_fns.to_2d(order_size, raw=True),
            reshape_fns.to_2d(order_price, raw=True),
            reshape_fns.to_2d(fees, raw=True),
            reshape_fns.to_2d(fixed_fees, raw=True),
            reshape_fns.to_2d(slippage, raw=True),
            is_target)

        # Bring to the same meta
        wrapper = TSArrayWrapper.from_obj(main_price, freq=freq)
        cash = wrapper.wrap(cash)
        shares = wrapper.wrap(shares)
        orders = Orders(order_records, main_price, freq=freq)
        if checks.is_series(main_price):
            init_capital = init_capital[0]
        else:
            init_capital = wrapper.wrap_reduced(init_capital)

        return cls(main_price, init_capital, orders, cash, shares, freq=freq, **kwargs)

    @classmethod
    def from_order_func(cls, main_price, order_func_nb, *args, init_capital=None, freq=None, **kwargs):
        &#34;&#34;&#34;Build portfolio from a custom order function.

        Starting with initial capital `init_capital`, iterates over shape `main_price.shape`, and for
        each data point, generates an order using `order_func_nb`. This way, you can specify order
        size, price and transaction costs dynamically (for example, based on the current balance).

        To iterate over a bigger shape than `main_price`, you should tile/repeat `main_price` to the desired shape.

        Args:
            main_price (pandas_like): Main price of the asset, such as close.

                Must be a pandas object.
            order_func_nb (function): Function that returns an order.

                See `vectorbt.portfolio.enums.Order`.
            *args: Arguments passed to `order_func_nb`.
            init_capital (int, float or array_like): The initial capital.

                If array, should match the number of columns.
            freq (any): Index frequency in case `main_price.index` is not datetime-like.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `vectorbt.defaults.portfolio`.

        All time series will be broadcasted together using `vectorbt.base.reshape_fns.broadcast`.
        At the end, they will have the same metadata.

        !!! note
            `order_func_nb` must be Numba-compiled.

        Example:
            Portfolio from buying daily:
            ```python-repl
            &gt;&gt;&gt; from vectorbt.portfolio import Order

            &gt;&gt;&gt; @njit
            ... def order_func_nb(col, i, run_cash, run_shares, price):
            ...     return Order(10, price[i], fees=0.01, fixed_fees=1., slippage=0.01)

            &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
            ...     price, order_func_nb, price.values, init_capital=100)

            &gt;&gt;&gt; print(portfolio.orders.records)
               col  idx  size  price   fees  side
            0    0    0  10.0   1.01  1.101     0
            1    0    1  10.0   2.02  1.202     0
            2    0    2  10.0   3.03  1.303     0
            3    0    3  10.0   2.02  1.202     0
            4    0    4  10.0   1.01  1.101     0
            &gt;&gt;&gt; print(portfolio.equity)
            2020-01-01     98.799
            2020-01-02    107.397
            2020-01-03    125.794
            2020-01-04     94.392
            2020-01-05     53.191
            Name: a, dtype: float64
            ```
        &#34;&#34;&#34;
        # Get defaults
        if init_capital is None:
            init_capital = defaults.portfolio[&#39;init_capital&#39;]

        # Perform checks
        checks.assert_type(main_price, (pd.Series, pd.DataFrame))
        checks.assert_numba_func(order_func_nb)

        # Broadcast inputs
        target_shape = (main_price.shape[0], main_price.shape[1] if main_price.ndim &gt; 1 else 1)
        init_capital = np.broadcast_to(init_capital, (target_shape[1],))

        # Perform calculation
        order_records, cash, shares = nb.simulate_nb(
            target_shape,
            init_capital,
            order_func_nb,
            *args)

        # Bring to the same meta
        wrapper = TSArrayWrapper.from_obj(main_price, freq=freq)
        cash = wrapper.wrap(cash)
        shares = wrapper.wrap(shares)
        orders = Orders(order_records, main_price, freq=freq)
        if checks.is_series(main_price):
            init_capital = init_capital[0]
        else:
            init_capital = wrapper.wrap_reduced(init_capital)

        return cls(main_price, init_capital, orders, cash, shares, freq=freq, **kwargs)

    # ############# Passed arguments ############# #

    @property
    def init_capital(self):
        &#34;&#34;&#34;Initial capital.&#34;&#34;&#34;
        return self._init_capital

    @cached_property
    def main_price(self):
        &#34;&#34;&#34;Price per share series.&#34;&#34;&#34;
        return self._main_price

    @cached_property
    def cash(self):
        &#34;&#34;&#34;Cash series.&#34;&#34;&#34;
        return self._cash

    @cached_property
    def shares(self):
        &#34;&#34;&#34;Shares series.&#34;&#34;&#34;
        return self._shares

    @property
    def freq(self):
        &#34;&#34;&#34;Index frequency.&#34;&#34;&#34;
        return self._freq

    @property
    def year_freq(self):
        &#34;&#34;&#34;Year frequency.&#34;&#34;&#34;
        return self._year_freq

    @property
    def levy_alpha(self):
        &#34;&#34;&#34;Scaling relation (Levy stability exponent).&#34;&#34;&#34;
        return self._levy_alpha

    @property
    def risk_free(self):
        &#34;&#34;&#34;Constant risk-free return throughout the period.&#34;&#34;&#34;
        return self._risk_free

    @property
    def required_return(self):
        &#34;&#34;&#34;Minimum acceptance return of the investor.&#34;&#34;&#34;
        return self._required_return

    @property
    def cutoff(self):
        &#34;&#34;&#34;Decimal representing the percentage cutoff for the bottom percentile of returns.&#34;&#34;&#34;
        return self._cutoff

    @property
    def factor_returns(self):
        &#34;&#34;&#34;Benchmark return to compare returns against.&#34;&#34;&#34;
        return self._factor_returns

    # ############# Records ############# #

    @cached_property
    def orders(self):
        &#34;&#34;&#34;Order records.

        See `vectorbt.records.orders.Orders`.&#34;&#34;&#34;
        return self._orders

    @cached_property
    def trades(self):
        &#34;&#34;&#34;Trade records.

        See `vectorbt.records.events.Trades`.&#34;&#34;&#34;
        return Trades.from_orders(self.orders)

    @cached_property
    def positions(self):
        &#34;&#34;&#34;Position records.

        See `vectorbt.records.events.Positions`.&#34;&#34;&#34;
        return Positions.from_orders(self.orders)

    # ############# Equity ############# #

    @cached_property
    def equity(self):
        &#34;&#34;&#34;Portfolio equity series.&#34;&#34;&#34;
        return self.cash.vbt + self.shares.vbt * self.main_price.vbt

    @cached_property
    def final_equity(self):
        &#34;&#34;&#34;Final equity.&#34;&#34;&#34;
        return self.wrapper.wrap_reduced(self.equity.values[-1])

    @cached_property
    def peak_equity(self):
        &#34;&#34;&#34;Peak equity.&#34;&#34;&#34;
        return self.equity.vbt.tseries.max()

    @cached_property
    def dip_equity(self):
        &#34;&#34;&#34;Dip equity.&#34;&#34;&#34;
        return self.equity.vbt.tseries.min()

    @cached_property
    def total_profit(self):
        &#34;&#34;&#34;Total profit.&#34;&#34;&#34;
        equity = self.equity.vbt.to_2d_array()[-1, :]
        init_capital = reshape_fns.to_1d(self.init_capital, raw=True)
        return self.wrapper.wrap_reduced(equity - init_capital)

    # ############# Drawdown ############# #

    @cached_property
    def drawdown(self):
        &#34;&#34;&#34;Drawdown series.&#34;&#34;&#34;
        equity = self.equity.vbt.to_2d_array()
        return self.wrapper.wrap(equity / tseries.nb.expanding_max_nb(equity) - 1)

    @cached_property
    def max_drawdown(self):
        &#34;&#34;&#34;Max drawdown.&#34;&#34;&#34;
        return self.drawdown.vbt.tseries.min()

    @cached_property
    def drawdowns(self):
        &#34;&#34;&#34;Drawdown records.

        See `vectorbt.records.drawdowns.Drawdowns`.&#34;&#34;&#34;
        return Drawdowns.from_ts(self.equity, freq=self.freq)

    # ############# Returns ############# #

    @cached_property
    def buy_and_hold_return(self):
        &#34;&#34;&#34;Total return of buying and holding.

        !!! note:
            Does not take into account fees and slippage. For this, create a separate portfolio.&#34;&#34;&#34;
        returns = tseries.nb.pct_change_nb(self.main_price.vbt.to_2d_array())
        return self.wrapper.wrap(returns).vbt.returns.total()

    @cached_property
    def returns(self):
        &#34;&#34;&#34;Portfolio return series.&#34;&#34;&#34;
        equity = self.equity.vbt.to_2d_array()
        returns = tseries.nb.pct_change_nb(equity)
        init_capital = reshape_fns.to_1d(self.init_capital, raw=True)
        returns[0, :] = (equity[0, :] - init_capital) / init_capital
        return self.wrapper.wrap(returns)

    @cached_property
    def daily_returns(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.daily`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .daily()

    @cached_property
    def annual_returns(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.annual`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .annual()

    @cached_property
    def cumulative_returns(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.cumulative`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .cumulative()

    @cached_property
    def total_return(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.total`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .total()

    @cached_property
    def annualized_return(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.annualized_return`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .annualized_return()

    @cached_property
    def annualized_volatility(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.annualized_volatility`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .annualized_volatility(levy_alpha=self.levy_alpha)

    @cached_property
    def calmar_ratio(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.calmar_ratio`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .calmar_ratio()

    @cached_property
    def omega_ratio(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.omega_ratio`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .omega_ratio(risk_free=self.risk_free, required_return=self.required_return)

    @cached_property
    def sharpe_ratio(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.sharpe_ratio`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .sharpe_ratio(risk_free=self.risk_free)

    @cached_property
    def downside_risk(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.downside_risk`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .downside_risk(required_return=self.required_return)

    @cached_property
    def sortino_ratio(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.sortino_ratio`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .sortino_ratio(required_return=self.required_return)

    @cached_property
    def information_ratio(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.information_ratio`.&#34;&#34;&#34;
        if self.factor_returns is None:
            raise Exception(&#34;This property requires factor_returns to be set&#34;)
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .information_ratio(self.factor_returns)

    @cached_property
    def beta(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.beta`.&#34;&#34;&#34;
        if self.factor_returns is None:
            raise Exception(&#34;This property requires factor_returns to be set&#34;)
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .beta(self.factor_returns)

    @cached_property
    def alpha(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.alpha`.&#34;&#34;&#34;
        if self.factor_returns is None:
            raise Exception(&#34;This property requires factor_returns to be set&#34;)
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .alpha(self.factor_returns, risk_free=self.risk_free)

    @cached_property
    def tail_ratio(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.tail_ratio`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .tail_ratio()

    @cached_property
    def value_at_risk(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.value_at_risk`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .value_at_risk(cutoff=self.cutoff)

    @cached_property
    def conditional_value_at_risk(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.conditional_value_at_risk`.&#34;&#34;&#34;
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .conditional_value_at_risk(cutoff=self.cutoff)

    @cached_property
    def capture(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.capture`.&#34;&#34;&#34;
        if self.factor_returns is None:
            raise Exception(&#34;This property requires factor_returns to be set&#34;)
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .capture(self.factor_returns)

    @cached_property
    def up_capture(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.up_capture`.&#34;&#34;&#34;
        if self.factor_returns is None:
            raise Exception(&#34;This property requires factor_returns to be set&#34;)
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .up_capture(self.factor_returns)

    @cached_property
    def down_capture(self):
        &#34;&#34;&#34;See `vectorbt.returns.accessors.Returns_Accessor.down_capture`.&#34;&#34;&#34;
        if self.factor_returns is None:
            raise Exception(&#34;This property requires factor_returns to be set&#34;)
        return self.returns.vbt.returns(freq=self.freq, year_freq=self.year_freq) \
            .down_capture(self.factor_returns)

    # ############# Stats ############# #

    @cached_property
    def stats(self):
        &#34;&#34;&#34;Compute various interesting statistics on this portfolio.&#34;&#34;&#34;
        if self.wrapper.ndim &gt; 1:
            raise Exception(&#34;You must select a column first&#34;)

        return pd.Series({
            &#39;Start&#39;: self.wrapper.index[0],
            &#39;End&#39;: self.wrapper.index[-1],
            &#39;Duration&#39;: self.wrapper.shape[0] * self.freq,
            &#39;Time in Position [%]&#39;: self.positions.coverage * 100,
            &#39;Total Profit&#39;: self.total_profit,
            &#39;Total Return [%]&#39;: self.total_return * 100,
            &#39;Buy &amp; Hold Return [%]&#39;: self.buy_and_hold_return * 100,
            &#39;Max. Drawdown [%]&#39;: -self.max_drawdown * 100,
            &#39;Avg. Drawdown [%]&#39;: -self.drawdowns.avg_drawdown * 100,
            &#39;Max. Drawdown Duration&#39;: self.drawdowns.max_duration,
            &#39;Avg. Drawdown Duration&#39;: self.drawdowns.avg_duration,
            &#39;Num. Trades&#39;: self.trades.count,
            &#39;Win Rate [%]&#39;: self.trades.win_rate * 100,
            &#39;Best Trade [%]&#39;: self.trades.max_return * 100,
            &#39;Worst Trade [%]&#39;: self.trades.min_return * 100,
            &#39;Avg. Trade [%]&#39;: self.trades.avg_return * 100,
            &#39;Max. Trade Duration&#39;: self.trades.max_duration,
            &#39;Avg. Trade Duration&#39;: self.trades.avg_duration,
            &#39;Expectancy&#39;: self.trades.expectancy,
            &#39;SQN&#39;: self.trades.sqn,
            &#39;Sharpe Ratio&#39;: self.sharpe_ratio,
            &#39;Sortino Ratio&#39;: self.sortino_ratio,
            &#39;Calmar Ratio&#39;: self.calmar_ratio
        })</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio.from_order_func"><code class="name flex">
<span>def <span class="ident fname">from_order_func</span></span>(<span>main_price, order_func_nb, *args, init_capital=None, freq=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from a custom order function.</p>
<p>Starting with initial capital <code>init_capital</code>, iterates over shape <code>main_price.shape</code>, and for
each data point, generates an order using <code>order_func_nb</code>. This way, you can specify order
size, price and transaction costs dynamically (for example, based on the current balance).</p>
<p>To iterate over a bigger shape than <code>main_price</code>, you should tile/repeat <code>main_price</code> to the desired shape.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>main_price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>
<p>Main price of the asset, such as close.</p>
<p>Must be a pandas object.</p>
</dd>
<dt><strong><code>order_func_nb</code></strong> :&ensp;<code>function</code></dt>
<dd>
<p>Function that returns an order.</p>
<p>See <code><a title="vectorbt.portfolio.enums.Order" href="enums.html#vectorbt.portfolio.enums.Order">Order</a></code>.</p>
</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>Arguments passed to <code>order_func_nb</code>.</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int, float</code> or <code>array_like</code></dt>
<dd>
<p>The initial capital.</p>
<p>If array, should match the number of columns.</p>
</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Index frequency in case <code>main_price.index</code> is not datetime-like.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.defaults.portfolio" href="../defaults.html#vectorbt.defaults.portfolio">portfolio</a></code>.</p>
<p>All time series will be broadcasted together using <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.
At the end, they will have the same metadata.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>order_func_nb</code> must be Numba-compiled.</p>
</div>
<h2 id="example">Example</h2>
<p>Portfolio from buying daily:</p>
<pre><code class="python-repl">&gt;&gt;&gt; from vectorbt.portfolio import Order

&gt;&gt;&gt; @njit
... def order_func_nb(col, i, run_cash, run_shares, price):
...     return Order(10, price[i], fees=0.01, fixed_fees=1., slippage=0.01)

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
...     price, order_func_nb, price.values, init_capital=100)

&gt;&gt;&gt; print(portfolio.orders.records)
   col  idx  size  price   fees  side
0    0    0  10.0   1.01  1.101     0
1    0    1  10.0   2.02  1.202     0
2    0    2  10.0   3.03  1.303     0
3    0    3  10.0   2.02  1.202     0
4    0    4  10.0   1.01  1.101     0
&gt;&gt;&gt; print(portfolio.equity)
2020-01-01     98.799
2020-01-02    107.397
2020-01-03    125.794
2020-01-04     94.392
2020-01-05     53.191
Name: a, dtype: float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_order_func(cls, main_price, order_func_nb, *args, init_capital=None, freq=None, **kwargs):
    &#34;&#34;&#34;Build portfolio from a custom order function.

    Starting with initial capital `init_capital`, iterates over shape `main_price.shape`, and for
    each data point, generates an order using `order_func_nb`. This way, you can specify order
    size, price and transaction costs dynamically (for example, based on the current balance).

    To iterate over a bigger shape than `main_price`, you should tile/repeat `main_price` to the desired shape.

    Args:
        main_price (pandas_like): Main price of the asset, such as close.

            Must be a pandas object.
        order_func_nb (function): Function that returns an order.

            See `vectorbt.portfolio.enums.Order`.
        *args: Arguments passed to `order_func_nb`.
        init_capital (int, float or array_like): The initial capital.

            If array, should match the number of columns.
        freq (any): Index frequency in case `main_price.index` is not datetime-like.
        **kwargs: Keyword arguments passed to the `__init__` method.

    For defaults, see `vectorbt.defaults.portfolio`.

    All time series will be broadcasted together using `vectorbt.base.reshape_fns.broadcast`.
    At the end, they will have the same metadata.

    !!! note
        `order_func_nb` must be Numba-compiled.

    Example:
        Portfolio from buying daily:
        ```python-repl
        &gt;&gt;&gt; from vectorbt.portfolio import Order

        &gt;&gt;&gt; @njit
        ... def order_func_nb(col, i, run_cash, run_shares, price):
        ...     return Order(10, price[i], fees=0.01, fixed_fees=1., slippage=0.01)

        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_order_func(
        ...     price, order_func_nb, price.values, init_capital=100)

        &gt;&gt;&gt; print(portfolio.orders.records)
           col  idx  size  price   fees  side
        0    0    0  10.0   1.01  1.101     0
        1    0    1  10.0   2.02  1.202     0
        2    0    2  10.0   3.03  1.303     0
        3    0    3  10.0   2.02  1.202     0
        4    0    4  10.0   1.01  1.101     0
        &gt;&gt;&gt; print(portfolio.equity)
        2020-01-01     98.799
        2020-01-02    107.397
        2020-01-03    125.794
        2020-01-04     94.392
        2020-01-05     53.191
        Name: a, dtype: float64
        ```
    &#34;&#34;&#34;
    # Get defaults
    if init_capital is None:
        init_capital = defaults.portfolio[&#39;init_capital&#39;]

    # Perform checks
    checks.assert_type(main_price, (pd.Series, pd.DataFrame))
    checks.assert_numba_func(order_func_nb)

    # Broadcast inputs
    target_shape = (main_price.shape[0], main_price.shape[1] if main_price.ndim &gt; 1 else 1)
    init_capital = np.broadcast_to(init_capital, (target_shape[1],))

    # Perform calculation
    order_records, cash, shares = nb.simulate_nb(
        target_shape,
        init_capital,
        order_func_nb,
        *args)

    # Bring to the same meta
    wrapper = TSArrayWrapper.from_obj(main_price, freq=freq)
    cash = wrapper.wrap(cash)
    shares = wrapper.wrap(shares)
    orders = Orders(order_records, main_price, freq=freq)
    if checks.is_series(main_price):
        init_capital = init_capital[0]
    else:
        init_capital = wrapper.wrap_reduced(init_capital)

    return cls(main_price, init_capital, orders, cash, shares, freq=freq, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.from_orders"><code class="name flex">
<span>def <span class="ident fname">from_orders</span></span>(<span>main_price, order_size, order_price=None, init_capital=None, fees=None, fixed_fees=None, slippage=None, is_target=False, broadcast_kwargs={}, freq=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from orders.</p>
<p>Starting with initial capital <code>init_capital</code>, at each time step, orders the number
of shares specified in <code>order_size</code> for <code>order_price</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>main_price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Main price of the asset, such as close.</dd>
<dt><strong><code>order_size</code></strong> :&ensp;<code>int, float</code> or <code>array_like</code></dt>
<dd>
<p>The amount of shares to order.</p>
<p>If the size is positive, this is the number of shares to buy.
If the size is negative, this is the number of shares to sell.
To buy/sell everything, set the size to <code>numpy.inf</code>.</p>
</dd>
<dt><strong><code>order_price</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Order price. Defaults to <code>main_price</code>.</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int, float</code> or <code>array_like</code></dt>
<dd>
<p>The initial capital.</p>
<p>If array, should match the number of columns.</p>
</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fees in percentage of the order value.</dd>
<dt><strong><code>fixed_fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fixed amount of fees to pay per order.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of <code>order_price</code>.</dd>
<dt><strong><code>is_target</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, will order the difference between current and target size.</dd>
<dt><strong><code>broadcast_kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Index frequency in case <code>main_price.index</code> is not datetime-like.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.defaults.portfolio" href="../defaults.html#vectorbt.defaults.portfolio">portfolio</a></code>.</p>
<p>All time series will be broadcasted together using <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.
At the end, they will have the same metadata.</p>
<h2 id="example">Example</h2>
<p>Portfolio from various order sequences:</p>
<pre><code class="python-repl">&gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders,
...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

&gt;&gt;&gt; print(portfolio.orders.records)
    col  idx        size  price      fees  side
0     0    0   98.654463  1.001  1.246883     0
1     1    0    1.000000  1.001  1.002502     0
2     1    1    1.000000  2.002  1.005005     0
3     1    2    1.000000  3.003  1.007507     0
4     1    3    1.000000  2.002  1.005005     0
5     1    4    4.000000  0.999  1.009990     1
6     2    0   98.654463  1.001  1.246883     0
7     2    1   98.654463  1.998  1.492779     1
8     2    2   64.646521  3.003  1.485334     0
9     2    3   64.646521  1.998  1.322909     1
10    2    4  126.398131  1.001  1.316311     0
&gt;&gt;&gt; print(portfolio.equity)
                     a          b           c
2020-01-01   98.654463  98.996498   98.654463
2020-01-02  197.308925  98.989493  195.618838
2020-01-03  295.963388  99.978985  193.939564
2020-01-04  197.308925  95.971980  127.840840
2020-01-05   98.654463  90.957990  126.398131
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_orders(cls, main_price, order_size, order_price=None, init_capital=None, fees=None, fixed_fees=None,
                slippage=None, is_target=False, broadcast_kwargs={}, freq=None, **kwargs):
    &#34;&#34;&#34;Build portfolio from orders.

    Starting with initial capital `init_capital`, at each time step, orders the number
    of shares specified in `order_size` for `order_price`.

    Args:
        main_price (pandas_like): Main price of the asset, such as close.
        order_size (int, float or array_like): The amount of shares to order.

            If the size is positive, this is the number of shares to buy.
            If the size is negative, this is the number of shares to sell.
            To buy/sell everything, set the size to `numpy.inf`.
        order_price (array_like): Order price. Defaults to `main_price`.
        init_capital (int, float or array_like): The initial capital.

            If array, should match the number of columns.
        fees (float or array_like): Fees in percentage of the order value.
        fixed_fees (float or array_like): Fixed amount of fees to pay per order.
        slippage (float or array_like): Slippage in percentage of `order_price`.
        is_target (bool): If `True`, will order the difference between current and target size.
        broadcast_kwargs: Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
        freq (any): Index frequency in case `main_price.index` is not datetime-like.
        **kwargs: Keyword arguments passed to the `__init__` method.

    For defaults, see `vectorbt.defaults.portfolio`.

    All time series will be broadcasted together using `vectorbt.base.reshape_fns.broadcast`.
    At the end, they will have the same metadata.

    Example:
        Portfolio from various order sequences:
        ```python-repl
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_orders(price, orders,
        ...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

        &gt;&gt;&gt; print(portfolio.orders.records)
            col  idx        size  price      fees  side
        0     0    0   98.654463  1.001  1.246883     0
        1     1    0    1.000000  1.001  1.002502     0
        2     1    1    1.000000  2.002  1.005005     0
        3     1    2    1.000000  3.003  1.007507     0
        4     1    3    1.000000  2.002  1.005005     0
        5     1    4    4.000000  0.999  1.009990     1
        6     2    0   98.654463  1.001  1.246883     0
        7     2    1   98.654463  1.998  1.492779     1
        8     2    2   64.646521  3.003  1.485334     0
        9     2    3   64.646521  1.998  1.322909     1
        10    2    4  126.398131  1.001  1.316311     0
        &gt;&gt;&gt; print(portfolio.equity)
                             a          b           c
        2020-01-01   98.654463  98.996498   98.654463
        2020-01-02  197.308925  98.989493  195.618838
        2020-01-03  295.963388  99.978985  193.939564
        2020-01-04  197.308925  95.971980  127.840840
        2020-01-05   98.654463  90.957990  126.398131
        ```
    &#34;&#34;&#34;
    # Get defaults
    if order_price is None:
        order_price = main_price
    if init_capital is None:
        init_capital = defaults.portfolio[&#39;init_capital&#39;]
    if fees is None:
        fees = defaults.portfolio[&#39;fees&#39;]
    if fixed_fees is None:
        fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
    if slippage is None:
        slippage = defaults.portfolio[&#39;slippage&#39;]

    # Perform checks
    checks.assert_type(main_price, (pd.Series, pd.DataFrame))

    # Broadcast inputs
    main_price, order_size, order_price, fees, fixed_fees, slippage = \
        reshape_fns.broadcast(main_price, order_size, order_price, fees, fixed_fees,
                              slippage, **broadcast_kwargs, writeable=True)
    target_shape = (main_price.shape[0], main_price.shape[1] if main_price.ndim &gt; 1 else 1)
    init_capital = np.broadcast_to(init_capital, (target_shape[1],))

    # Perform calculation
    order_records, cash, shares = nb.simulate_from_orders_nb(
        target_shape,
        init_capital,
        reshape_fns.to_2d(order_size, raw=True),
        reshape_fns.to_2d(order_price, raw=True),
        reshape_fns.to_2d(fees, raw=True),
        reshape_fns.to_2d(fixed_fees, raw=True),
        reshape_fns.to_2d(slippage, raw=True),
        is_target)

    # Bring to the same meta
    wrapper = TSArrayWrapper.from_obj(main_price, freq=freq)
    cash = wrapper.wrap(cash)
    shares = wrapper.wrap(shares)
    orders = Orders(order_records, main_price, freq=freq)
    if checks.is_series(main_price):
        init_capital = init_capital[0]
    else:
        init_capital = wrapper.wrap_reduced(init_capital)

    return cls(main_price, init_capital, orders, cash, shares, freq=freq, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.from_signals"><code class="name flex">
<span>def <span class="ident fname">from_signals</span></span>(<span>main_price, entries, exits, size=inf, entry_price=None, exit_price=None, init_capital=None, fees=None, fixed_fees=None, slippage=None, accumulate=False, broadcast_kwargs={}, freq=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from entry and exit signals.</p>
<p>At each entry signal in <code>entries</code>, buys <code>size</code> of shares for <code>entry_price</code> to enter
a position. At each exit signal in <code>exits</code>, sells everything for <code>exit_price</code>
to exit the position. Accumulation of orders is disabled by default.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>main_price</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Main price of the asset, such as close.</dd>
<dt><strong><code>entries</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Boolean array of entry signals.</dd>
<dt><strong><code>exits</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Boolean array of exit signals.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int, float</code> or <code>array_like</code></dt>
<dd>
<p>The amount of shares to order.</p>
<p>To buy/sell everything, set the size to <code>numpy.inf</code>.</p>
</dd>
<dt><strong><code>entry_price</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Entry price. Defaults to <code>main_price</code>.</dd>
<dt><strong><code>exit_price</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Exit price. Defaults to <code>main_price</code>.</dd>
<dt><strong><code>init_capital</code></strong> :&ensp;<code>int, float</code> or <code>array_like</code></dt>
<dd>
<p>The initial capital.</p>
<p>If array, should match the number of columns.</p>
</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fees in percentage of the order value.</dd>
<dt><strong><code>fixed_fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fixed amount of fees to pay per order.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of price.</dd>
<dt><strong><code>accumulate</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>accumulate</code> is <code>True</code>, entering the market when already
in the market will be allowed to increase a position.</dd>
<dt><strong><code>broadcast_kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Index frequency in case <code>main_price.index</code> is not datetime-like.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>For defaults, see <code><a title="vectorbt.defaults.portfolio" href="../defaults.html#vectorbt.defaults.portfolio">portfolio</a></code>.</p>
<p>All time series will be broadcasted together using <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.
At the end, they will have the same metadata.</p>
<h2 id="example">Example</h2>
<p>Portfolio from various signal sequences:</p>
<pre><code class="python-repl">&gt;&gt;&gt; entries = pd.DataFrame({
...     'a': [True, False, False, False, False],
...     'b': [True, False, True, False, True],
...     'c': [True, True, True, True, True]
... }, index=index)
&gt;&gt;&gt; exits = pd.DataFrame({
...     'a': [False, False, False, False, False],
...     'b': [False, True, False, True, False],
...     'c': [True, True, True, True, True]
... }, index=index)
&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
...     price, entries, exits, size=10,
...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

&gt;&gt;&gt; print(portfolio.orders.records)
   col  idx  size  price      fees  side
0    0    0  10.0  1.001  1.025025     0
1    1    0  10.0  1.001  1.025025     0
2    1    1  10.0  1.998  1.049950     1
3    1    2  10.0  3.003  1.075075     0
4    1    3  10.0  1.998  1.049950     1
5    1    4  10.0  1.001  1.025025     0
6    2    0  10.0  1.001  1.025025     0
&gt;&gt;&gt; print(portfolio.equity)
                     a           b           c
2020-01-01   98.964975   98.964975   98.964975
2020-01-02  108.964975  107.895025  108.964975
2020-01-03  118.964975  106.789950  118.964975
2020-01-04  108.964975   95.720000  108.964975
2020-01-05   98.964975   94.684975   98.964975
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_signals(cls, main_price, entries, exits, size=np.inf, entry_price=None, exit_price=None,
                 init_capital=None, fees=None, fixed_fees=None, slippage=None, accumulate=False,
                 broadcast_kwargs={}, freq=None, **kwargs):
    &#34;&#34;&#34;Build portfolio from entry and exit signals.

    At each entry signal in `entries`, buys `size` of shares for `entry_price` to enter
    a position. At each exit signal in `exits`, sells everything for `exit_price`
    to exit the position. Accumulation of orders is disabled by default.

    Args:
        main_price (pandas_like): Main price of the asset, such as close.
        entries (array_like): Boolean array of entry signals.
        exits (array_like): Boolean array of exit signals.
        size (int, float or array_like): The amount of shares to order.

            To buy/sell everything, set the size to `numpy.inf`.
        entry_price (array_like): Entry price. Defaults to `main_price`.
        exit_price (array_like): Exit price. Defaults to `main_price`.
        init_capital (int, float or array_like): The initial capital.

            If array, should match the number of columns.
        fees (float or array_like): Fees in percentage of the order value.
        fixed_fees (float or array_like): Fixed amount of fees to pay per order.
        slippage (float or array_like): Slippage in percentage of price.
        accumulate (bool): If `accumulate` is `True`, entering the market when already
            in the market will be allowed to increase a position.
        broadcast_kwargs: Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
        freq (any): Index frequency in case `main_price.index` is not datetime-like.
        **kwargs: Keyword arguments passed to the `__init__` method.

    For defaults, see `vectorbt.defaults.portfolio`.

    All time series will be broadcasted together using `vectorbt.base.reshape_fns.broadcast`.
    At the end, they will have the same metadata.

    Example:
        Portfolio from various signal sequences:
        ```python-repl
        &gt;&gt;&gt; entries = pd.DataFrame({
        ...     &#39;a&#39;: [True, False, False, False, False],
        ...     &#39;b&#39;: [True, False, True, False, True],
        ...     &#39;c&#39;: [True, True, True, True, True]
        ... }, index=index)
        &gt;&gt;&gt; exits = pd.DataFrame({
        ...     &#39;a&#39;: [False, False, False, False, False],
        ...     &#39;b&#39;: [False, True, False, True, False],
        ...     &#39;c&#39;: [True, True, True, True, True]
        ... }, index=index)
        &gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(
        ...     price, entries, exits, size=10,
        ...     init_capital=100, fees=0.0025, fixed_fees=1., slippage=0.001)

        &gt;&gt;&gt; print(portfolio.orders.records)
           col  idx  size  price      fees  side
        0    0    0  10.0  1.001  1.025025     0
        1    1    0  10.0  1.001  1.025025     0
        2    1    1  10.0  1.998  1.049950     1
        3    1    2  10.0  3.003  1.075075     0
        4    1    3  10.0  1.998  1.049950     1
        5    1    4  10.0  1.001  1.025025     0
        6    2    0  10.0  1.001  1.025025     0
        &gt;&gt;&gt; print(portfolio.equity)
                             a           b           c
        2020-01-01   98.964975   98.964975   98.964975
        2020-01-02  108.964975  107.895025  108.964975
        2020-01-03  118.964975  106.789950  118.964975
        2020-01-04  108.964975   95.720000  108.964975
        2020-01-05   98.964975   94.684975   98.964975
        ```
    &#34;&#34;&#34;
    # Get defaults
    if entry_price is None:
        entry_price = main_price
    if exit_price is None:
        exit_price = main_price
    if init_capital is None:
        init_capital = defaults.portfolio[&#39;init_capital&#39;]
    if fees is None:
        fees = defaults.portfolio[&#39;fees&#39;]
    if fixed_fees is None:
        fixed_fees = defaults.portfolio[&#39;fixed_fees&#39;]
    if slippage is None:
        slippage = defaults.portfolio[&#39;slippage&#39;]

    # Perform checks
    checks.assert_type(main_price, (pd.Series, pd.DataFrame))
    checks.assert_dtype(entries, np.bool_)
    checks.assert_dtype(exits, np.bool_)

    # Broadcast inputs
    main_price, entries, exits, size, entry_price, exit_price, fees, fixed_fees, slippage = \
        reshape_fns.broadcast(
            main_price, entries, exits, size, entry_price, exit_price, fees,
            fixed_fees, slippage, **broadcast_kwargs, writeable=True)
    target_shape = (main_price.shape[0], main_price.shape[1] if main_price.ndim &gt; 1 else 1)
    init_capital = np.broadcast_to(init_capital, (target_shape[1],))

    # Perform calculation
    order_records, cash, shares = nb.simulate_from_signals_nb(
        target_shape,
        init_capital,
        reshape_fns.to_2d(entries, raw=True),
        reshape_fns.to_2d(exits, raw=True),
        reshape_fns.to_2d(size, raw=True),
        reshape_fns.to_2d(entry_price, raw=True),
        reshape_fns.to_2d(exit_price, raw=True),
        reshape_fns.to_2d(fees, raw=True),
        reshape_fns.to_2d(fixed_fees, raw=True),
        reshape_fns.to_2d(slippage, raw=True),
        accumulate)

    # Bring to the same meta
    wrapper = TSArrayWrapper.from_obj(main_price, freq=freq)
    cash = wrapper.wrap(cash)
    shares = wrapper.wrap(shares)
    orders = Orders(order_records, main_price, freq=freq)
    if checks.is_series(main_price):
        init_capital = init_capital[0]
    else:
        init_capital = wrapper.wrap_reduced(init_capital)

    return cls(main_price, init_capital, orders, cash, shares, freq=freq, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio.alpha"><code class="name">var <span class="ident fname">alpha</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.alpha" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.alpha">Returns_Accessor.alpha()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.annual_returns"><code class="name">var <span class="ident fname">annual_returns</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.annual" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.annual">Returns_Accessor.annual()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.annualized_return"><code class="name">var <span class="ident fname">annualized_return</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.annualized_return" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.annualized_return">Returns_Accessor.annualized_return()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.annualized_volatility"><code class="name">var <span class="ident fname">annualized_volatility</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.annualized_volatility" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.annualized_volatility">Returns_Accessor.annualized_volatility()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.beta"><code class="name">var <span class="ident fname">beta</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.beta" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.beta">Returns_Accessor.beta()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.buy_and_hold_return"><code class="name">var <span class="ident fname">buy_and_hold_return</span></code></dt>
<dd>
<div class="desc"><p>Total return of buying and holding.</p>
<p>!!! note:
Does not take into account fees and slippage. For this, create a separate portfolio.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.calmar_ratio"><code class="name">var <span class="ident fname">calmar_ratio</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.calmar_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.calmar_ratio">Returns_Accessor.calmar_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.capture"><code class="name">var <span class="ident fname">capture</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.capture" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.capture">Returns_Accessor.capture()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cash"><code class="name">var <span class="ident fname">cash</span></code></dt>
<dd>
<div class="desc"><p>Cash series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.conditional_value_at_risk"><code class="name">var <span class="ident fname">conditional_value_at_risk</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.conditional_value_at_risk" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.conditional_value_at_risk">Returns_Accessor.conditional_value_at_risk()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cumulative_returns"><code class="name">var <span class="ident fname">cumulative_returns</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.cumulative" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.cumulative">Returns_Accessor.cumulative()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cutoff"><code class="name">var <span class="ident fname">cutoff</span></code></dt>
<dd>
<div class="desc"><p>Decimal representing the percentage cutoff for the bottom percentile of returns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cutoff(self):
    &#34;&#34;&#34;Decimal representing the percentage cutoff for the bottom percentile of returns.&#34;&#34;&#34;
    return self._cutoff</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.daily_returns"><code class="name">var <span class="ident fname">daily_returns</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.daily" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.daily">Returns_Accessor.daily()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.dip_equity"><code class="name">var <span class="ident fname">dip_equity</span></code></dt>
<dd>
<div class="desc"><p>Dip equity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.down_capture"><code class="name">var <span class="ident fname">down_capture</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.down_capture" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.down_capture">Returns_Accessor.down_capture()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.downside_risk"><code class="name">var <span class="ident fname">downside_risk</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.downside_risk" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.downside_risk">Returns_Accessor.downside_risk()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.drawdown"><code class="name">var <span class="ident fname">drawdown</span></code></dt>
<dd>
<div class="desc"><p>Drawdown series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.drawdowns"><code class="name">var <span class="ident fname">drawdowns</span></code></dt>
<dd>
<div class="desc"><p>Drawdown records.</p>
<p>See <code><a title="vectorbt.records.drawdowns.Drawdowns" href="../records/drawdowns.html#vectorbt.records.drawdowns.Drawdowns">Drawdowns</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.equity"><code class="name">var <span class="ident fname">equity</span></code></dt>
<dd>
<div class="desc"><p>Portfolio equity series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.factor_returns"><code class="name">var <span class="ident fname">factor_returns</span></code></dt>
<dd>
<div class="desc"><p>Benchmark return to compare returns against.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def factor_returns(self):
    &#34;&#34;&#34;Benchmark return to compare returns against.&#34;&#34;&#34;
    return self._factor_returns</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.final_equity"><code class="name">var <span class="ident fname">final_equity</span></code></dt>
<dd>
<div class="desc"><p>Final equity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.freq"><code class="name">var <span class="ident fname">freq</span></code></dt>
<dd>
<div class="desc"><p>Index frequency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def freq(self):
    &#34;&#34;&#34;Index frequency.&#34;&#34;&#34;
    return self._freq</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.information_ratio"><code class="name">var <span class="ident fname">information_ratio</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.information_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.information_ratio">Returns_Accessor.information_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.init_capital"><code class="name">var <span class="ident fname">init_capital</span></code></dt>
<dd>
<div class="desc"><p>Initial capital.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def init_capital(self):
    &#34;&#34;&#34;Initial capital.&#34;&#34;&#34;
    return self._init_capital</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.levy_alpha"><code class="name">var <span class="ident fname">levy_alpha</span></code></dt>
<dd>
<div class="desc"><p>Scaling relation (Levy stability exponent).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def levy_alpha(self):
    &#34;&#34;&#34;Scaling relation (Levy stability exponent).&#34;&#34;&#34;
    return self._levy_alpha</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.main_price"><code class="name">var <span class="ident fname">main_price</span></code></dt>
<dd>
<div class="desc"><p>Price per share series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.max_drawdown"><code class="name">var <span class="ident fname">max_drawdown</span></code></dt>
<dd>
<div class="desc"><p>Max drawdown.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.omega_ratio"><code class="name">var <span class="ident fname">omega_ratio</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.omega_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.omega_ratio">Returns_Accessor.omega_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.orders"><code class="name">var <span class="ident fname">orders</span></code></dt>
<dd>
<div class="desc"><p>Order records.</p>
<p>See <code><a title="vectorbt.records.orders.Orders" href="../records/orders.html#vectorbt.records.orders.Orders">Orders</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.peak_equity"><code class="name">var <span class="ident fname">peak_equity</span></code></dt>
<dd>
<div class="desc"><p>Peak equity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.positions"><code class="name">var <span class="ident fname">positions</span></code></dt>
<dd>
<div class="desc"><p>Position records.</p>
<p>See <code><a title="vectorbt.records.events.Positions" href="../records/events.html#vectorbt.records.events.Positions">Positions</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.required_return"><code class="name">var <span class="ident fname">required_return</span></code></dt>
<dd>
<div class="desc"><p>Minimum acceptance return of the investor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def required_return(self):
    &#34;&#34;&#34;Minimum acceptance return of the investor.&#34;&#34;&#34;
    return self._required_return</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.returns"><code class="name">var <span class="ident fname">returns</span></code></dt>
<dd>
<div class="desc"><p>Portfolio return series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.risk_free"><code class="name">var <span class="ident fname">risk_free</span></code></dt>
<dd>
<div class="desc"><p>Constant risk-free return throughout the period.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def risk_free(self):
    &#34;&#34;&#34;Constant risk-free return throughout the period.&#34;&#34;&#34;
    return self._risk_free</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.shares"><code class="name">var <span class="ident fname">shares</span></code></dt>
<dd>
<div class="desc"><p>Shares series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.sharpe_ratio"><code class="name">var <span class="ident fname">sharpe_ratio</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.sharpe_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.sharpe_ratio">Returns_Accessor.sharpe_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.sortino_ratio"><code class="name">var <span class="ident fname">sortino_ratio</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.sortino_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.sortino_ratio">Returns_Accessor.sortino_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.stats"><code class="name">var <span class="ident fname">stats</span></code></dt>
<dd>
<div class="desc"><p>Compute various interesting statistics on this portfolio.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.tail_ratio"><code class="name">var <span class="ident fname">tail_ratio</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.tail_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.tail_ratio">Returns_Accessor.tail_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.total_profit"><code class="name">var <span class="ident fname">total_profit</span></code></dt>
<dd>
<div class="desc"><p>Total profit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.total_return"><code class="name">var <span class="ident fname">total_return</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.total" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.total">Returns_Accessor.total()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.trades"><code class="name">var <span class="ident fname">trades</span></code></dt>
<dd>
<div class="desc"><p>Trade records.</p>
<p>See <code><a title="vectorbt.records.events.Trades" href="../records/events.html#vectorbt.records.events.Trades">Trades</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.up_capture"><code class="name">var <span class="ident fname">up_capture</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.up_capture" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.up_capture">Returns_Accessor.up_capture()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.value_at_risk"><code class="name">var <span class="ident fname">value_at_risk</span></code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.Returns_Accessor.value_at_risk" href="../returns/accessors.html#vectorbt.returns.accessors.Returns_Accessor.value_at_risk">Returns_Accessor.value_at_risk()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.year_freq"><code class="name">var <span class="ident fname">year_freq</span></code></dt>
<dd>
<div class="desc"><p>Year frequency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def year_freq(self):
    &#34;&#34;&#34;Year frequency.&#34;&#34;&#34;
    return self._year_freq</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.indexing.PandasIndexer.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAACXBIWXMAACcQAAAnEAGUaVEZAAAGuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDggNzkuMTY0MDM2LCAyMDE5LzA4LzEzLTAxOjA2OjU3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjEuMCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjAtMDYtMjVUMjM6MzU6MTMrMDI6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjAtMDYtMjZUMTQ6MTA6MzgrMDI6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIwLTA2LTI2VDE0OjEwOjM4KzAyOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNzE0MGFiYi05Mjk1LTQ3MDYtYTNhZi1lMDg2OTFkOTk3NjQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NzZmN2Y4NjAtMThmMi00ZDgxLTg5NjUtNDU5ZjY1NDY2ZGZlIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NzZmN2Y4NjAtMThmMi00ZDgxLTg5NjUtNDU5ZjY1NDY2ZGZlIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjc2ZjdmODYwLTE4ZjItNGQ4MS04OTY1LTQ1OWY2NTQ2NmRmZSIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNVQyMzozNToxMyswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2NjI2MGIzLTY0ZmUtNGJiYy1iMTNiLWZkMDU3NDI3NjIyNCIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNlQxMzoyMTo1NSswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjA3MTQwYWJiLTkyOTUtNDcwNi1hM2FmLWUwODY5MWQ5OTc2NCIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNlQxNDoxMDozOCswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Qc/+aQAAAa5JREFUeJzt3cFJA0EYgFEjgj3FGmIjsQexByuxB4vy5kHwELJhCRPekP3eMYdl4Ms/y84Gstsfjg9xHvUCtq4AWAGwAmAFwAqAFQArAFYArABYAbACYAXACoAVACsAVgCsAFgBsAJgBcAKgBUAexp1oe+vz7Ofv7y+dZ0LmgCsAFgBsAJgBcAKgBUAKwBWAKwAWAGwAmAFwAqAFQAb9j5glFHn7KPcej1NAFYAzG9BP+/n3/ld9vwx1051tSYA8xPwZ/03+rqJmVYTgBUAm2UL+re0w6i7br8LunMFwAqAFQArAFYArADYdM8Bd3PKtlITgBUAm2ULurMzzvWaAMxPwNbuuieaAKwAmN+CTtz6/H02TQBWAKwAWAGwAmAFwAqAFQArAFYArABYAbACYAXACoANex8w23n9bOtZ0gRgBcAKgBUAKwBWAKwA2HT/HzDKbOtZ0gRgBcAKgBUAKwBWAKwAWAGwAmAFwAqAFQArAFYArADYbn846jVsWhOAFQArAFYArABYAbACYAXACoAVACsAVgCsAFgBsAJgBcAKgBUAKwBWAKwAWAGwAmC/7uUrwcQVST8AAAAASUVORK5CYII="/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul>
<li><a href="#workflow">Workflow</a></li>
<li><a href="#properties">Properties</a><ul>
<li><a href="#caching">Caching</a></li>
</ul>
</li>
<li><a href="#indexing">Indexing</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.portfolio" href="index.html">vectorbt.portfolio</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.portfolio.base.Portfolio.alpha" href="#vectorbt.portfolio.base.Portfolio.alpha">alpha</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.annual_returns" href="#vectorbt.portfolio.base.Portfolio.annual_returns">annual_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.annualized_return" href="#vectorbt.portfolio.base.Portfolio.annualized_return">annualized_return</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.annualized_volatility" href="#vectorbt.portfolio.base.Portfolio.annualized_volatility">annualized_volatility</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.beta" href="#vectorbt.portfolio.base.Portfolio.beta">beta</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.buy_and_hold_return" href="#vectorbt.portfolio.base.Portfolio.buy_and_hold_return">buy_and_hold_return</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.calmar_ratio" href="#vectorbt.portfolio.base.Portfolio.calmar_ratio">calmar_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.capture" href="#vectorbt.portfolio.base.Portfolio.capture">capture</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cash" href="#vectorbt.portfolio.base.Portfolio.cash">cash</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.conditional_value_at_risk" href="#vectorbt.portfolio.base.Portfolio.conditional_value_at_risk">conditional_value_at_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cumulative_returns" href="#vectorbt.portfolio.base.Portfolio.cumulative_returns">cumulative_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cutoff" href="#vectorbt.portfolio.base.Portfolio.cutoff">cutoff</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.daily_returns" href="#vectorbt.portfolio.base.Portfolio.daily_returns">daily_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.dip_equity" href="#vectorbt.portfolio.base.Portfolio.dip_equity">dip_equity</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.down_capture" href="#vectorbt.portfolio.base.Portfolio.down_capture">down_capture</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.downside_risk" href="#vectorbt.portfolio.base.Portfolio.downside_risk">downside_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.drawdown" href="#vectorbt.portfolio.base.Portfolio.drawdown">drawdown</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.drawdowns" href="#vectorbt.portfolio.base.Portfolio.drawdowns">drawdowns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.equity" href="#vectorbt.portfolio.base.Portfolio.equity">equity</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.factor_returns" href="#vectorbt.portfolio.base.Portfolio.factor_returns">factor_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.final_equity" href="#vectorbt.portfolio.base.Portfolio.final_equity">final_equity</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.freq" href="#vectorbt.portfolio.base.Portfolio.freq">freq</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">from_order_func</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">from_orders</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">from_signals</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.information_ratio" href="#vectorbt.portfolio.base.Portfolio.information_ratio">information_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.init_capital" href="#vectorbt.portfolio.base.Portfolio.init_capital">init_capital</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.levy_alpha" href="#vectorbt.portfolio.base.Portfolio.levy_alpha">levy_alpha</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.main_price" href="#vectorbt.portfolio.base.Portfolio.main_price">main_price</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.max_drawdown" href="#vectorbt.portfolio.base.Portfolio.max_drawdown">max_drawdown</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.omega_ratio" href="#vectorbt.portfolio.base.Portfolio.omega_ratio">omega_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.orders" href="#vectorbt.portfolio.base.Portfolio.orders">orders</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.peak_equity" href="#vectorbt.portfolio.base.Portfolio.peak_equity">peak_equity</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.positions" href="#vectorbt.portfolio.base.Portfolio.positions">positions</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.required_return" href="#vectorbt.portfolio.base.Portfolio.required_return">required_return</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.returns" href="#vectorbt.portfolio.base.Portfolio.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.risk_free" href="#vectorbt.portfolio.base.Portfolio.risk_free">risk_free</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.shares" href="#vectorbt.portfolio.base.Portfolio.shares">shares</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.sharpe_ratio" href="#vectorbt.portfolio.base.Portfolio.sharpe_ratio">sharpe_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.sortino_ratio" href="#vectorbt.portfolio.base.Portfolio.sortino_ratio">sortino_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.stats" href="#vectorbt.portfolio.base.Portfolio.stats">stats</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.tail_ratio" href="#vectorbt.portfolio.base.Portfolio.tail_ratio">tail_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.total_profit" href="#vectorbt.portfolio.base.Portfolio.total_profit">total_profit</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.total_return" href="#vectorbt.portfolio.base.Portfolio.total_return">total_return</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.trades" href="#vectorbt.portfolio.base.Portfolio.trades">trades</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.up_capture" href="#vectorbt.portfolio.base.Portfolio.up_capture">up_capture</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.value_at_risk" href="#vectorbt.portfolio.base.Portfolio.value_at_risk">value_at_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.year_freq" href="#vectorbt.portfolio.base.Portfolio.year_freq">year_freq</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>