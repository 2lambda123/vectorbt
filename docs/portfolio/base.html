<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.portfolio.base API documentation</title>
<meta name="description" content="Base class for modeling portfolio and measuring its performance â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#e82}.flex{display:flex !important}body{line-height:1.5em}.version{font-weight:normal;font-style:italic;font-size:.75em;color:#56b6c2}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-weight:400;font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:100px;max-height:100px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.portfolio.base</code></h1>
</header>
<section id="section-intro">
<p>Base class for modeling portfolio and measuring its performance.</p>
<p>Provides the class <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> for modeling portfolio performance
and calculating various risk and performance metrics. It uses Numba-compiled
functions from <code><a title="vectorbt.portfolio.nb" href="nb.html">vectorbt.portfolio.nb</a></code> for most computations and record classes based on
<code><a title="vectorbt.records.base.Records" href="../records/base.html#vectorbt.records.base.Records">Records</a></code> for evaluating events such as orders, logs, trades, positions and drawdowns.</p>
<p>The job of the <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> class is to create a series of positions allocated
against a cash component, produce an equity curve, incorporate basic transaction costs
and produce a set of statistics about its performance. In particular it outputs
position/profit metrics and drawdown information.</p>
<h2 id="workflow">Workflow</h2>
<p>The workflow of <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> is simple:</p>
<ol>
<li>Receives a set of inputs, such as entry and exit signals</li>
<li>Uses them to generate and fill orders in form of records (simulation part)</li>
<li>Calculates a broad range of risk &amp; performance metrics based on these records (analysis part)</li>
</ol>
<p>It basically builds upon the <code><a title="vectorbt.portfolio.orders.Orders" href="orders.html#vectorbt.portfolio.orders.Orders">Orders</a></code> class. To simplify creation of order
records and keep track of balances, it exposes several convenience methods with prefix <code>from_</code>.
For example, you can use <code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">Portfolio.from_signals()</a></code> method to generate orders from entry and exit signals.
Alternatively, you can use <code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">Portfolio.from_order_func()</a></code> to run a custom order function on each tick.
The results are then automatically passed to the constructor method of <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> and you will
receive a portfolio instance ready to be used for performance analysis.</p>
<p>This way, one can simulate and analyze his/her strategy in a couple of lines.</p>
<h3 id="example">Example</h3>
<p>The following example does something crazy: it checks candlestick data of 6 major cryptocurrencies
in 2020 against every single pattern found in TA-Lib, and translates them into signals:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; import talib
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; # Fetch price history
&gt;&gt;&gt; symbols = ['BTC-USD', 'ETH-USD', 'XRP-USD', 'BNB-USD', 'BCH-USD', 'LTC-USD']
&gt;&gt;&gt; start = '2020-01-01 UTC'  # crypto is UTC
&gt;&gt;&gt; end = '2020-09-01 UTC'
&gt;&gt;&gt; # OHLCV by column
&gt;&gt;&gt; ohlcv = vbt.YFData.download(symbols, start=start, end=end).concat()
&gt;&gt;&gt; ohlcv['Open']

symbol                          BTC-USD     ETH-USD   XRP-USD    BNB-USD  Date
2020-01-01 00:00:00+00:00   7194.892090  129.630661  0.192912  13.730962
2020-01-02 00:00:00+00:00   7202.551270  130.820038  0.192708  13.698126
2020-01-03 00:00:00+00:00   6984.428711  127.411263  0.187948  13.035329
...                                 ...         ...       ...        ...
2020-08-30 00:00:00+00:00  11508.713867  399.616699  0.274568  23.009060
2020-08-31 00:00:00+00:00  11713.306641  428.509003  0.283065  23.647858
2020-09-01 00:00:00+00:00  11679.316406  434.874451  0.281612  23.185047

symbol                        BCH-USD    LTC-USD
Date
2020-01-01 00:00:00+00:00  204.671295  41.326534
2020-01-02 00:00:00+00:00  204.354538  42.018085
2020-01-03 00:00:00+00:00  196.007690  39.863129
...                               ...        ...
2020-08-30 00:00:00+00:00  268.842865  57.207737
2020-08-31 00:00:00+00:00  279.280426  62.844059
2020-09-01 00:00:00+00:00  274.480865  61.105076

[244 rows x 6 columns]

&gt;&gt;&gt; # Run every single pattern recognition indicator and combine results
&gt;&gt;&gt; result = pd.DataFrame.vbt.empty_like(ohlcv['Open'], fill_value=0.)
&gt;&gt;&gt; for pattern in talib.get_function_groups()['Pattern Recognition']:
...     PRecognizer = vbt.IndicatorFactory.from_talib(pattern)
...     pr = PRecognizer.run(ohlcv['Open'], ohlcv['High'], ohlcv['Low'], ohlcv['Close'])
...     result = result + pr.integer

&gt;&gt;&gt; # Don't look into future
&gt;&gt;&gt; result = result.vbt.fshift(1)

&gt;&gt;&gt; # Treat each number as order value in USD
&gt;&gt;&gt; size = result / ohlcv['Open']

&gt;&gt;&gt; # Simulate portfolio
&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(
...     ohlcv['Close'], size, price=ohlcv['Open'],
...     init_cash='autoalign', fees=0.001, slippage=0.001)

&gt;&gt;&gt; # Visualize portfolio value
&gt;&gt;&gt; pf.value().vbt.plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/portfolio_value.svg"></p>
<h2 id="broadcasting">Broadcasting</h2>
<p><code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> is very flexible towards inputs:</p>
<ul>
<li>Accepts both Series and DataFrames as inputs</li>
<li>Broadcasts inputs to the same shape using vectorbt's own broadcasting rules</li>
<li>Many inputs (such as <code>fees</code>) can be passed as a single value, value per column/row, or as a matrix</li>
<li>Implements flexible indexing wherever possible to save memory</li>
</ul>
<h2 id="grouping">Grouping</h2>
<p>One of the key features of <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> is the ability to group columns. Groups can be specified by
<code>group_by</code>, which can be anything from positions or names of column levels, to a NumPy array with
actual groups. Groups can be formed to share capital between columns or to compute metrics
for a combined portfolio of multiple independent columns.</p>
<p>For example, let's divide our portfolio into two groups sharing the same cash balance:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Simulate combined portfolio
&gt;&gt;&gt; group_by = pd.Index([
...     'first', 'first', 'first',
...     'second', 'second', 'second'
... ], name='group')
&gt;&gt;&gt; comb_pf = vbt.Portfolio.from_orders(
...     ohlcv['Close'], size, price=ohlcv['Open'],
...     init_cash='autoalign', fees=0.001, slippage=0.001,
...     group_by=group_by, cash_sharing=True)

&gt;&gt;&gt; # Get total profit per group
&gt;&gt;&gt; comb_pf.total_profit()
group
first     26221.571200
second    10141.952674
Name: total_profit, dtype: float64
</code></pre>
<p>Not only can you analyze each group, but also each column in the group:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Get total profit per column
&gt;&gt;&gt; comb_pf.total_profit(group_by=False)
symbol
BTC-USD     5792.120252
ETH-USD    16380.039692
XRP-USD     4049.411256
BNB-USD     6081.253551
BCH-USD      400.573418
LTC-USD     3660.125705
Name: total_profit, dtype: float64
</code></pre>
<p>In the same way, you can introduce new grouping to the method itself:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Get total profit per group
&gt;&gt;&gt; pf.total_profit(group_by=group_by)
group
first     26221.571200
second    10141.952674
Name: total_profit, dtype: float64
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If cash sharing is enabled, grouping can be disabled but cannot be modified.</p>
</div>
<h2 id="indexing">Indexing</h2>
<p>Like any other class subclassing <code><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></code>, we can do pandas indexing
on a <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> instance, which forwards indexing operation to each object with columns:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf['BTC-USD']
&lt;vectorbt.portfolio.base.Portfolio at 0x7fac7517ac88&gt;

&gt;&gt;&gt; pf['BTC-USD'].total_profit()
5792.120252189081
</code></pre>
<p>Combined portfolio is indexed by group:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; comb_pf['first']
&lt;vectorbt.portfolio.base.Portfolio at 0x7fac5756b828&gt;

&gt;&gt;&gt; comb_pf['first'].total_profit()
26221.57120014546
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Changing index (time axis) is not supported. The object should be treated as a Series
rather than a DataFrame; for example, use <code>pf.iloc[0]</code> instead of <code>pf.iloc[:, 0]</code>.</p>
<p>Indexing behavior depends solely upon <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.
For example, if <code>group_select</code> is enabled indexing will be performed on groups,
otherwise on single columns. You can pass wrapper arguments with <code>wrapper_kwargs</code>.</p>
</div>
<h2 id="logging">Logging</h2>
<p>To collect more information on how a specific order was processed or to be able to track the whole
simulation from the beginning to the end, you can turn on logging.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Simulate portfolio with logging
&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(
...     ohlcv['Close'], size, price=ohlcv['Open'],
...     init_cash='autoalign', fees=0.001, slippage=0.001, log=True)

&gt;&gt;&gt; pf.logs.records
        id  idx  col  group  cash    position  debt  free_cash    val_price  \
0        0    0    0      0   inf    0.000000   0.0        inf  7194.892090
1        1    1    0      0   inf    0.000000   0.0        inf  7202.551270
2        2    2    0      0   inf    0.000000   0.0        inf  6984.428711
...    ...  ...  ...    ...   ...         ...   ...        ...          ...
1461  1461  241    5      5   inf  272.389644   0.0        inf    57.207737
1462  1462  242    5      5   inf  274.137659   0.0        inf    62.844059
1463  1463  243    5      5   inf  282.093860   0.0        inf    61.105076

      value  ...  new_free_cash  new_val_price  new_value  res_size  \
0       inf  ...            inf    7194.892090        inf       NaN
1       inf  ...            inf    7202.551270        inf       NaN
2       inf  ...            inf    6984.428711        inf       NaN
...     ...  ...            ...            ...        ...       ...
1461    inf  ...            inf      57.207737        inf  1.748015
1462    inf  ...            inf      62.844059        inf  7.956202
1463    inf  ...            inf      61.105076        inf  1.636525

        res_price  res_fees  res_side  res_status  res_status_info  order_id
0             NaN       NaN        -1           1                0        -1
1             NaN       NaN        -1           1                5        -1
2             NaN       NaN        -1           1                5        -1
...           ...       ...       ...         ...              ...       ...
1461    57.264945    0.1001         0           0               -1      1070
1462    62.906903    0.5005         0           0               -1      1071
1463    61.043971    0.0999         1           0               -1      1072

[1464 rows x 37 columns]
</code></pre>
<p>Just as orders, logs are also records and thus can be easily analyzed:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from vectorbt.portfolio.enums import OrderStatus

&gt;&gt;&gt; pf.logs.map_field('res_status', value_map=OrderStatus).value_counts()
symbol   BTC-USD  ETH-USD  XRP-USD  BNB-USD  BCH-USD  LTC-USD
Ignored       60       72       67       66       67       59
Filled       184      172      177      178      177      185
</code></pre>
<p>Logging can also be turned on just for one order, row, or column, since as many other
variables it's specified per order and can broadcast automatically.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Logging can slow down simulation.</p>
</div>
<h2 id="caching">Caching</h2>
<p><code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> heavily relies upon caching. If a method or a property requires heavy computation,
it's wrapped with <code><a title="vectorbt.utils.decorators.cached_method" href="../utils/decorators.html#vectorbt.utils.decorators.cached_method">cached_method()</a></code> and <code><a title="vectorbt.utils.decorators.cached_property" href="../utils/decorators.html#vectorbt.utils.decorators.cached_property">cached_property</a></code>
respectively. Caching can be disabled globally via <code>caching</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because of caching, class is meant to be immutable and all properties are read-only.
To change any attribute, use the <code>copy</code> method and pass the attribute as keyword argument.</p>
</div>
<p>If you're running out of memory when working with large arrays, make sure to disable caching
and then store most important time series manually. For example, if you're interested in Sharpe
ratio or other metrics based on returns, run and save <code><a title="vectorbt.portfolio.base.Portfolio.returns" href="#vectorbt.portfolio.base.Portfolio.returns">Portfolio.returns()</a></code> and then use the
<code><a title="vectorbt.returns.accessors.ReturnsAccessor" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor">ReturnsAccessor</a></code> to analyze them. Do not use methods akin to
<code><a title="vectorbt.portfolio.base.Portfolio.sharpe_ratio" href="#vectorbt.portfolio.base.Portfolio.sharpe_ratio">Portfolio.sharpe_ratio()</a></code> because they will re-calculate returns each time.</p>
<p>Alternatively, you can precisely point at attributes and methods that should or shouldn't
be cached. For example, you can blacklist the entire <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code> class except a few most called
methods such as <code><a title="vectorbt.portfolio.base.Portfolio.cash_flow" href="#vectorbt.portfolio.base.Portfolio.cash_flow">Portfolio.cash_flow()</a></code> and <code><a title="vectorbt.portfolio.base.Portfolio.asset_flow" href="#vectorbt.portfolio.base.Portfolio.asset_flow">Portfolio.asset_flow()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.settings.caching['blacklist'].append(
...     vbt.CacheCondition(base_cls='Portfolio')
... )
&gt;&gt;&gt; vbt.settings.caching['whitelist'].extend([
...     vbt.CacheCondition(base_cls='Portfolio', func='cash_flow'),
...     vbt.CacheCondition(base_cls='Portfolio', func='asset_flow')
... ])
</code></pre>
<p>Define rules for one instance of <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.settings.caching['blacklist'].append(
...     vbt.CacheCondition(instance=pf)
... )
&gt;&gt;&gt; vbt.settings.caching['whitelist'].extend([
...     vbt.CacheCondition(instance=pf, func='cash_flow'),
...     vbt.CacheCondition(instance=pf, func='asset_flow')
... ])
</code></pre>
<p>See <code><a title="vectorbt.utils.decorators.should_cache" href="../utils/decorators.html#vectorbt.utils.decorators.should_cache">should_cache()</a></code> for caching rules.</p>
<p>To reset caching:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.settings.caching.reset()
</code></pre>
<h2 id="saving-and-loading">Saving and loading</h2>
<p>Like any other class subclassing <code><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></code>, we can save a <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code>
instance to the disk with <code><a title="vectorbt.portfolio.base.Portfolio.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">Pickleable.save()</a></code> and load it with <code><a title="vectorbt.portfolio.base.Portfolio.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">Pickleable.load()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(
...     ohlcv['Close'], size, price=ohlcv['Open'],
...     init_cash='autoalign', fees=0.001, slippage=0.001, freq='1D')
&gt;&gt;&gt; pf.sharpe_ratio()
symbol
BTC-USD    1.743437
ETH-USD    2.800903
XRP-USD    1.607904
BNB-USD    1.805373
BCH-USD    0.269392
LTC-USD    1.040494
Name: sharpe_ratio, dtype: float64

&gt;&gt;&gt; pf.save('my_pf')
&gt;&gt;&gt; pf = vbt.Portfolio.load('my_pf')
&gt;&gt;&gt; pf.sharpe_ratio()
symbol
BTC-USD    1.743437
ETH-USD    2.800903
XRP-USD    1.607904
BNB-USD    1.805373
BCH-USD    0.269392
LTC-USD    1.040494
Name: sharpe_ratio, dtype: float64
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Save files won't include neither cached results nor global defaults. For example,
passing <code>fillna_close</code> as None will also use None when the portfolio is loaded from disk.
Make sure to either pass all arguments explicitly or to also save the <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code> config.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Base class for modeling portfolio and measuring its performance.

Provides the class `vectorbt.portfolio.base.Portfolio` for modeling portfolio performance
and calculating various risk and performance metrics. It uses Numba-compiled
functions from `vectorbt.portfolio.nb` for most computations and record classes based on
`vectorbt.records.base.Records` for evaluating events such as orders, logs, trades, positions and drawdowns.

The job of the `Portfolio` class is to create a series of positions allocated 
against a cash component, produce an equity curve, incorporate basic transaction costs
and produce a set of statistics about its performance. In particular it outputs
position/profit metrics and drawdown information.

## Workflow

The workflow of `Portfolio` is simple:

1. Receives a set of inputs, such as entry and exit signals
2. Uses them to generate and fill orders in form of records (simulation part)
3. Calculates a broad range of risk &amp; performance metrics based on these records (analysis part)

It basically builds upon the `vectorbt.portfolio.orders.Orders` class. To simplify creation of order
records and keep track of balances, it exposes several convenience methods with prefix `from_`.
For example, you can use `Portfolio.from_signals` method to generate orders from entry and exit signals.
Alternatively, you can use `Portfolio.from_order_func` to run a custom order function on each tick.
The results are then automatically passed to the constructor method of `Portfolio` and you will
receive a portfolio instance ready to be used for performance analysis.

This way, one can simulate and analyze his/her strategy in a couple of lines.

### Example

The following example does something crazy: it checks candlestick data of 6 major cryptocurrencies
in 2020 against every single pattern found in TA-Lib, and translates them into signals:

```python-repl
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; import talib
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; # Fetch price history
&gt;&gt;&gt; symbols = [&#39;BTC-USD&#39;, &#39;ETH-USD&#39;, &#39;XRP-USD&#39;, &#39;BNB-USD&#39;, &#39;BCH-USD&#39;, &#39;LTC-USD&#39;]
&gt;&gt;&gt; start = &#39;2020-01-01 UTC&#39;  # crypto is UTC
&gt;&gt;&gt; end = &#39;2020-09-01 UTC&#39;
&gt;&gt;&gt; # OHLCV by column
&gt;&gt;&gt; ohlcv = vbt.YFData.download(symbols, start=start, end=end).concat()
&gt;&gt;&gt; ohlcv[&#39;Open&#39;]

symbol                          BTC-USD     ETH-USD   XRP-USD    BNB-USD  \
Date
2020-01-01 00:00:00+00:00   7194.892090  129.630661  0.192912  13.730962
2020-01-02 00:00:00+00:00   7202.551270  130.820038  0.192708  13.698126
2020-01-03 00:00:00+00:00   6984.428711  127.411263  0.187948  13.035329
...                                 ...         ...       ...        ...
2020-08-30 00:00:00+00:00  11508.713867  399.616699  0.274568  23.009060
2020-08-31 00:00:00+00:00  11713.306641  428.509003  0.283065  23.647858
2020-09-01 00:00:00+00:00  11679.316406  434.874451  0.281612  23.185047

symbol                        BCH-USD    LTC-USD
Date
2020-01-01 00:00:00+00:00  204.671295  41.326534
2020-01-02 00:00:00+00:00  204.354538  42.018085
2020-01-03 00:00:00+00:00  196.007690  39.863129
...                               ...        ...
2020-08-30 00:00:00+00:00  268.842865  57.207737
2020-08-31 00:00:00+00:00  279.280426  62.844059
2020-09-01 00:00:00+00:00  274.480865  61.105076

[244 rows x 6 columns]

&gt;&gt;&gt; # Run every single pattern recognition indicator and combine results
&gt;&gt;&gt; result = pd.DataFrame.vbt.empty_like(ohlcv[&#39;Open&#39;], fill_value=0.)
&gt;&gt;&gt; for pattern in talib.get_function_groups()[&#39;Pattern Recognition&#39;]:
...     PRecognizer = vbt.IndicatorFactory.from_talib(pattern)
...     pr = PRecognizer.run(ohlcv[&#39;Open&#39;], ohlcv[&#39;High&#39;], ohlcv[&#39;Low&#39;], ohlcv[&#39;Close&#39;])
...     result = result + pr.integer

&gt;&gt;&gt; # Don&#39;t look into future
&gt;&gt;&gt; result = result.vbt.fshift(1)

&gt;&gt;&gt; # Treat each number as order value in USD
&gt;&gt;&gt; size = result / ohlcv[&#39;Open&#39;]

&gt;&gt;&gt; # Simulate portfolio
&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(
...     ohlcv[&#39;Close&#39;], size, price=ohlcv[&#39;Open&#39;],
...     init_cash=&#39;autoalign&#39;, fees=0.001, slippage=0.001)

&gt;&gt;&gt; # Visualize portfolio value
&gt;&gt;&gt; pf.value().vbt.plot()
```

![](/vectorbt/docs/img/portfolio_value.svg)

## Broadcasting

`Portfolio` is very flexible towards inputs:

* Accepts both Series and DataFrames as inputs
* Broadcasts inputs to the same shape using vectorbt&#39;s own broadcasting rules
* Many inputs (such as `fees`) can be passed as a single value, value per column/row, or as a matrix
* Implements flexible indexing wherever possible to save memory

## Grouping

One of the key features of `Portfolio` is the ability to group columns. Groups can be specified by
`group_by`, which can be anything from positions or names of column levels, to a NumPy array with
actual groups. Groups can be formed to share capital between columns or to compute metrics
for a combined portfolio of multiple independent columns.

For example, let&#39;s divide our portfolio into two groups sharing the same cash balance:

```python-repl
&gt;&gt;&gt; # Simulate combined portfolio
&gt;&gt;&gt; group_by = pd.Index([
...     &#39;first&#39;, &#39;first&#39;, &#39;first&#39;,
...     &#39;second&#39;, &#39;second&#39;, &#39;second&#39;
... ], name=&#39;group&#39;)
&gt;&gt;&gt; comb_pf = vbt.Portfolio.from_orders(
...     ohlcv[&#39;Close&#39;], size, price=ohlcv[&#39;Open&#39;],
...     init_cash=&#39;autoalign&#39;, fees=0.001, slippage=0.001,
...     group_by=group_by, cash_sharing=True)

&gt;&gt;&gt; # Get total profit per group
&gt;&gt;&gt; comb_pf.total_profit()
group
first     26221.571200
second    10141.952674
Name: total_profit, dtype: float64
```

Not only can you analyze each group, but also each column in the group:

```python-repl
&gt;&gt;&gt; # Get total profit per column
&gt;&gt;&gt; comb_pf.total_profit(group_by=False)
symbol
BTC-USD     5792.120252
ETH-USD    16380.039692
XRP-USD     4049.411256
BNB-USD     6081.253551
BCH-USD      400.573418
LTC-USD     3660.125705
Name: total_profit, dtype: float64
```

In the same way, you can introduce new grouping to the method itself:

```python-repl
&gt;&gt;&gt; # Get total profit per group
&gt;&gt;&gt; pf.total_profit(group_by=group_by)
group
first     26221.571200
second    10141.952674
Name: total_profit, dtype: float64
```

!!! note
    If cash sharing is enabled, grouping can be disabled but cannot be modified.

## Indexing

Like any other class subclassing `vectorbt.base.array_wrapper.Wrapping`, we can do pandas indexing
on a `Portfolio` instance, which forwards indexing operation to each object with columns:

```python-repl
&gt;&gt;&gt; pf[&#39;BTC-USD&#39;]
&lt;vectorbt.portfolio.base.Portfolio at 0x7fac7517ac88&gt;

&gt;&gt;&gt; pf[&#39;BTC-USD&#39;].total_profit()
5792.120252189081
```

Combined portfolio is indexed by group:

```python-repl
&gt;&gt;&gt; comb_pf[&#39;first&#39;]
&lt;vectorbt.portfolio.base.Portfolio at 0x7fac5756b828&gt;

&gt;&gt;&gt; comb_pf[&#39;first&#39;].total_profit()
26221.57120014546
```

!!! note
    Changing index (time axis) is not supported. The object should be treated as a Series
    rather than a DataFrame; for example, use `pf.iloc[0]` instead of `pf.iloc[:, 0]`.

    Indexing behavior depends solely upon `vectorbt.base.array_wrapper.ArrayWrapper`.
    For example, if `group_select` is enabled indexing will be performed on groups,
    otherwise on single columns. You can pass wrapper arguments with `wrapper_kwargs`.

## Logging

To collect more information on how a specific order was processed or to be able to track the whole
simulation from the beginning to the end, you can turn on logging.

```python-repl
&gt;&gt;&gt; # Simulate portfolio with logging
&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(
...     ohlcv[&#39;Close&#39;], size, price=ohlcv[&#39;Open&#39;],
...     init_cash=&#39;autoalign&#39;, fees=0.001, slippage=0.001, log=True)

&gt;&gt;&gt; pf.logs.records
        id  idx  col  group  cash    position  debt  free_cash    val_price  \\
0        0    0    0      0   inf    0.000000   0.0        inf  7194.892090
1        1    1    0      0   inf    0.000000   0.0        inf  7202.551270
2        2    2    0      0   inf    0.000000   0.0        inf  6984.428711
...    ...  ...  ...    ...   ...         ...   ...        ...          ...
1461  1461  241    5      5   inf  272.389644   0.0        inf    57.207737
1462  1462  242    5      5   inf  274.137659   0.0        inf    62.844059
1463  1463  243    5      5   inf  282.093860   0.0        inf    61.105076

      value  ...  new_free_cash  new_val_price  new_value  res_size  \\
0       inf  ...            inf    7194.892090        inf       NaN
1       inf  ...            inf    7202.551270        inf       NaN
2       inf  ...            inf    6984.428711        inf       NaN
...     ...  ...            ...            ...        ...       ...
1461    inf  ...            inf      57.207737        inf  1.748015
1462    inf  ...            inf      62.844059        inf  7.956202
1463    inf  ...            inf      61.105076        inf  1.636525

        res_price  res_fees  res_side  res_status  res_status_info  order_id
0             NaN       NaN        -1           1                0        -1
1             NaN       NaN        -1           1                5        -1
2             NaN       NaN        -1           1                5        -1
...           ...       ...       ...         ...              ...       ...
1461    57.264945    0.1001         0           0               -1      1070
1462    62.906903    0.5005         0           0               -1      1071
1463    61.043971    0.0999         1           0               -1      1072

[1464 rows x 37 columns]
```

Just as orders, logs are also records and thus can be easily analyzed:

```python-repl
&gt;&gt;&gt; from vectorbt.portfolio.enums import OrderStatus

&gt;&gt;&gt; pf.logs.map_field(&#39;res_status&#39;, value_map=OrderStatus).value_counts()
symbol   BTC-USD  ETH-USD  XRP-USD  BNB-USD  BCH-USD  LTC-USD
Ignored       60       72       67       66       67       59
Filled       184      172      177      178      177      185
```

Logging can also be turned on just for one order, row, or column, since as many other
variables it&#39;s specified per order and can broadcast automatically.

!!! note
    Logging can slow down simulation.

## Caching

`Portfolio` heavily relies upon caching. If a method or a property requires heavy computation,
it&#39;s wrapped with `vectorbt.utils.decorators.cached_method` and `vectorbt.utils.decorators.cached_property`
respectively. Caching can be disabled globally via `caching` in `vectorbt._settings.settings`.

!!! note
    Because of caching, class is meant to be immutable and all properties are read-only.
    To change any attribute, use the `copy` method and pass the attribute as keyword argument.

If you&#39;re running out of memory when working with large arrays, make sure to disable caching
and then store most important time series manually. For example, if you&#39;re interested in Sharpe
ratio or other metrics based on returns, run and save `Portfolio.returns` and then use the
`vectorbt.returns.accessors.ReturnsAccessor` to analyze them. Do not use methods akin to
`Portfolio.sharpe_ratio` because they will re-calculate returns each time.

Alternatively, you can precisely point at attributes and methods that should or shouldn&#39;t
be cached. For example, you can blacklist the entire `Portfolio` class except a few most called
methods such as `Portfolio.cash_flow` and `Portfolio.asset_flow`:

```python-repl
&gt;&gt;&gt; vbt.settings.caching[&#39;blacklist&#39;].append(
...     vbt.CacheCondition(base_cls=&#39;Portfolio&#39;)
... )
&gt;&gt;&gt; vbt.settings.caching[&#39;whitelist&#39;].extend([
...     vbt.CacheCondition(base_cls=&#39;Portfolio&#39;, func=&#39;cash_flow&#39;),
...     vbt.CacheCondition(base_cls=&#39;Portfolio&#39;, func=&#39;asset_flow&#39;)
... ])
```

Define rules for one instance of `Portfolio`:

```python-repl
&gt;&gt;&gt; vbt.settings.caching[&#39;blacklist&#39;].append(
...     vbt.CacheCondition(instance=pf)
... )
&gt;&gt;&gt; vbt.settings.caching[&#39;whitelist&#39;].extend([
...     vbt.CacheCondition(instance=pf, func=&#39;cash_flow&#39;),
...     vbt.CacheCondition(instance=pf, func=&#39;asset_flow&#39;)
... ])
```

See `vectorbt.utils.decorators.should_cache` for caching rules.

To reset caching:

```python-repl
&gt;&gt;&gt; vbt.settings.caching.reset()
```

## Saving and loading

Like any other class subclassing `vectorbt.utils.config.Pickleable`, we can save a `Portfolio`
instance to the disk with `Portfolio.save` and load it with `Portfolio.load`:

```python-repl
&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(
...     ohlcv[&#39;Close&#39;], size, price=ohlcv[&#39;Open&#39;],
...     init_cash=&#39;autoalign&#39;, fees=0.001, slippage=0.001, freq=&#39;1D&#39;)
&gt;&gt;&gt; pf.sharpe_ratio()
symbol
BTC-USD    1.743437
ETH-USD    2.800903
XRP-USD    1.607904
BNB-USD    1.805373
BCH-USD    0.269392
LTC-USD    1.040494
Name: sharpe_ratio, dtype: float64

&gt;&gt;&gt; pf.save(&#39;my_pf&#39;)
&gt;&gt;&gt; pf = vbt.Portfolio.load(&#39;my_pf&#39;)
&gt;&gt;&gt; pf.sharpe_ratio()
symbol
BTC-USD    1.743437
ETH-USD    2.800903
XRP-USD    1.607904
BNB-USD    1.805373
BCH-USD    0.269392
LTC-USD    1.040494
Name: sharpe_ratio, dtype: float64
```

!!! note
    Save files won&#39;t include neither cached results nor global defaults. For example,
    passing `fillna_close` as None will also use None when the portfolio is loaded from disk.
    Make sure to either pass all arguments explicitly or to also save the `vectorbt._settings.settings` config.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from collections import Counter
import warnings

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property, cached_method
from vectorbt.utils.enum import cast_enum_value
from vectorbt.utils.config import merge_dicts, get_func_arg_names, Config
from vectorbt.utils.template import deep_substitute, Rep
from vectorbt.utils.random import set_seed
from vectorbt.utils.colors import adjust_opacity
from vectorbt.utils.figure import make_subplots, get_domain
from vectorbt.utils.datetime import freq_to_timedelta
from vectorbt.base.reshape_fns import to_1d, to_2d, broadcast, broadcast_to, to_pd_array
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.drawdowns import Drawdowns
from vectorbt.signals.generators import RAND, RPROB
from vectorbt.returns.accessors import ReturnsAccessor
from vectorbt.portfolio import nb
from vectorbt.portfolio.orders import Orders
from vectorbt.portfolio.trades import Trades, Positions
from vectorbt.portfolio.logs import Logs
from vectorbt.portfolio.enums import *


WrapperFuncT = tp.Callable[[tp.Type[tp.T]], tp.Type[tp.T]]
PortfolioT = tp.TypeVar(&#34;PortfolioT&#34;, bound=&#34;Portfolio&#34;)


def add_returns_methods(func_names: tp.Iterable[tp.Union[str, tp.Tuple[str, str]]]) -&gt; WrapperFuncT:
    &#34;&#34;&#34;Class decorator to add `vectorbt.returns.accessors.ReturnsAccessor` methods to `Portfolio`.&#34;&#34;&#34;

    def wrapper(cls: tp.Type[tp.T]) -&gt; tp.Type[tp.T]:
        for func_name in func_names:
            if isinstance(func_name, tuple):
                ret_func_name = func_name[0]
            else:
                ret_func_name = func_name

            def returns_method(
                    self: &#34;Portfolio&#34;,
                    *args,
                    group_by: tp.GroupByLike = None,
                    freq: tp.Optional[tp.FrequencyLike] = None,
                    year_freq: tp.Optional[tp.FrequencyLike] = None,
                    _ret_func_name: str = ret_func_name,
                    use_asset_returns: bool = False,
                    **ret_func_kwargs) -&gt; tp.Any:
                returns_acc = self.returns_acc(
                    group_by=group_by,
                    freq=freq,
                    year_freq=year_freq,
                    use_asset_returns=use_asset_returns
                )
                # Select only those arguments in kwargs that are also in the method&#39;s signature
                # This is done for Portfolio.stats which passes the same kwargs to multiple methods
                method = getattr(returns_acc, _ret_func_name)
                arg_names = get_func_arg_names(method)
                new_kwargs = {}
                for arg_name in arg_names:
                    if arg_name in ret_func_kwargs:
                        new_kwargs[arg_name] = ret_func_kwargs[arg_name]
                return method(*args, **new_kwargs)

            if isinstance(func_name, tuple):
                func_name = func_name[1]
            returns_method.__name__ = func_name
            returns_method.__qualname__ = f&#34;{cls.__name__}.{func_name}&#34;
            returns_method.__doc__ = f&#34;See `vectorbt.returns.accessors.ReturnsAccessor.{ret_func_name}`.&#34;
            setattr(cls, func_name, cached_method(returns_method))
        return cls

    return wrapper


@add_returns_methods([
    (&#39;daily&#39;, &#39;daily_returns&#39;),
    (&#39;annual&#39;, &#39;annual_returns&#39;),
    (&#39;cumulative&#39;, &#39;cumulative_returns&#39;),
    (&#39;annualized&#39;, &#39;annualized_return&#39;),
    &#39;annualized_volatility&#39;,
    &#39;calmar_ratio&#39;,
    &#39;omega_ratio&#39;,
    &#39;sharpe_ratio&#39;,
    &#39;deflated_sharpe_ratio&#39;,
    &#39;downside_risk&#39;,
    &#39;sortino_ratio&#39;,
    &#39;information_ratio&#39;,
    &#39;beta&#39;,
    &#39;alpha&#39;,
    &#39;tail_ratio&#39;,
    &#39;value_at_risk&#39;,
    &#39;cond_value_at_risk&#39;,
    &#39;capture&#39;,
    &#39;up_capture&#39;,
    &#39;down_capture&#39;,
    &#39;drawdown&#39;,
    &#39;max_drawdown&#39;
])
class Portfolio(Wrapping):
    &#34;&#34;&#34;Class for modeling portfolio and measuring its performance.

    Args:
        wrapper (ArrayWrapper): Array wrapper.

            See `vectorbt.base.array_wrapper.ArrayWrapper`.
        close (array_like): Last asset price at each time step.
        order_records (array_like): A structured NumPy array of order records.
        log_records (array_like): A structured NumPy array of log records.
        init_cash (InitCashMode, float or array_like of float): Initial capital.
        cash_sharing (bool): Whether to share cash within the same group.
        call_seq (array_like of int): Sequence of calls per row and group.
        fillna_close (bool): Whether to forward and backward fill NaN values in `close`.

            Applied after the simulation to avoid NaNs in asset value.

            See `Portfolio.get_filled_close`.

    !!! note
        Use class methods with `from_` prefix to build a portfolio.
        The `__init__` method is reserved for indexing purposes.

    !!! note
        This class is meant to be immutable. To change any attribute, use `Portfolio.copy`.&#34;&#34;&#34;

    writeable_attrs: tp.ClassVar[tp.List[str]] = [&#39;metrics&#39;, &#39;subplots&#39;]
    &#34;&#34;&#34;List of writeable attributes that will be saved/copied along with the config.&#34;&#34;&#34;

    def __init__(self,
                 wrapper: ArrayWrapper,
                 close: tp.ArrayLike,
                 order_records: tp.RecordArray,
                 log_records: tp.RecordArray,
                 init_cash: tp.ArrayLike,
                 cash_sharing: bool,
                 call_seq: tp.Array2d,
                 fillna_close: tp.Optional[bool] = None) -&gt; None:
        Wrapping.__init__(
            self,
            wrapper,
            close=close,
            order_records=order_records,
            log_records=log_records,
            init_cash=init_cash,
            cash_sharing=cash_sharing,
            call_seq=call_seq,
            fillna_close=fillna_close
        )
        # Get defaults
        from vectorbt._settings import settings
        portfolio_cfg = settings[&#39;portfolio&#39;]

        if fillna_close is None:
            fillna_close = portfolio_cfg[&#39;fillna_close&#39;]

        # Store passed arguments
        self._close = broadcast_to(close, wrapper.dummy(group_by=False))
        self._order_records = order_records
        self._log_records = log_records
        self._init_cash = init_cash
        self._cash_sharing = cash_sharing
        self._call_seq = call_seq
        self._fillna_close = fillna_close

        # Copy dicts
        self.metrics = self.__class__.metrics.copy()
        self.subplots = self.__class__.subplots.copy()

    def indexing_func(self: PortfolioT, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; PortfolioT:
        &#34;&#34;&#34;Perform indexing on `Portfolio`.&#34;&#34;&#34;
        new_wrapper, _, group_idxs, col_idxs = \
            self.wrapper.indexing_func_meta(pd_indexing_func, column_only_select=True, **kwargs)
        new_close = new_wrapper.wrap(to_2d(self.close, raw=True)[:, col_idxs], group_by=False)
        new_order_records = self.orders.get_by_col_idxs(col_idxs)
        new_log_records = self.logs.get_by_col_idxs(col_idxs)
        if isinstance(self._init_cash, int):
            new_init_cash = self._init_cash
        else:
            new_init_cash = to_1d(self._init_cash, raw=True)[group_idxs if self.cash_sharing else col_idxs]
        new_call_seq = self.call_seq.values[:, col_idxs]

        return self.copy(
            wrapper=new_wrapper,
            close=new_close,
            order_records=new_order_records,
            log_records=new_log_records,
            init_cash=new_init_cash,
            call_seq=new_call_seq
        )

    # ############# Class methods ############# #

    @classmethod
    def from_holding(cls: tp.Type[PortfolioT], close: tp.ArrayLike, **kwargs) -&gt; PortfolioT:
        &#34;&#34;&#34;Simulate portfolio from holding.

        Based on `Portfolio.from_signals`.&#34;&#34;&#34;
        return cls.from_signals(close, True, False, accumulate=False, **kwargs)

    @classmethod
    def from_random_signals(cls: tp.Type[PortfolioT],
                            close: tp.ArrayLike,
                            n: tp.Optional[tp.ArrayLike] = None,
                            prob: tp.Optional[tp.ArrayLike] = None,
                            entry_prob: tp.Optional[tp.ArrayLike] = None,
                            exit_prob: tp.Optional[tp.ArrayLike] = None,
                            param_product: bool = False,
                            seed: tp.Optional[int] = None,
                            run_kwargs: tp.KwargsLike = None,
                            **kwargs) -&gt; PortfolioT:
        &#34;&#34;&#34;Simulate portfolio from random entry and exit signals.

        Generates signals based either on the number of signals `n` or the probability
        of encountering a signal `prob`.

        If `n` is set, see `vectorbt.signals.generators.RAND`.
        If `prob` is set, see `vectorbt.signals.generators.RPROB`.

        Based on `Portfolio.from_signals`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        portfolio_cfg = settings[&#39;portfolio&#39;]

        close = to_pd_array(close)
        if entry_prob is None:
            entry_prob = prob
        if exit_prob is None:
            exit_prob = prob
        if seed is None:
            seed = portfolio_cfg[&#39;seed&#39;]
        if run_kwargs is None:
            run_kwargs = {}

        if n is not None and (entry_prob is not None or exit_prob is not None):
            raise ValueError(&#34;Either n or entry_prob and exit_prob should be set&#34;)
        if n is not None:
            rand = RAND.run(
                n=n,
                input_shape=close.shape,
                input_index=close.vbt.wrapper.index,
                input_columns=close.vbt.wrapper.columns,
                seed=seed,
                **run_kwargs
            )
            entries = rand.entries
            exits = rand.exits
        elif entry_prob is not None and exit_prob is not None:
            rprob = RPROB.run(
                entry_prob=entry_prob,
                exit_prob=exit_prob,
                param_product=param_product,
                input_shape=close.shape,
                input_index=close.vbt.wrapper.index,
                input_columns=close.vbt.wrapper.columns,
                seed=seed,
                **run_kwargs
            )
            entries = rprob.entries
            exits = rprob.exits
        else:
            raise ValueError(&#34;At least n or entry_prob and exit_prob should be set&#34;)

        return cls.from_signals(close, entries, exits, seed=seed, **kwargs)

    @classmethod
    def from_signals(cls: tp.Type[PortfolioT],
                     close: tp.ArrayLike,
                     entries: tp.Optional[tp.ArrayLike] = None,
                     exits: tp.Optional[tp.ArrayLike] = None,
                     size: tp.Optional[tp.ArrayLike] = None,
                     size_type: tp.Optional[tp.ArrayLike] = None,
                     direction: tp.Optional[tp.ArrayLike] = None,
                     price: tp.Optional[tp.ArrayLike] = None,
                     fees: tp.Optional[tp.ArrayLike] = None,
                     fixed_fees: tp.Optional[tp.ArrayLike] = None,
                     slippage: tp.Optional[tp.ArrayLike] = None,
                     min_size: tp.Optional[tp.ArrayLike] = None,
                     max_size: tp.Optional[tp.ArrayLike] = None,
                     reject_prob: tp.Optional[tp.ArrayLike] = None,
                     lock_cash: tp.Optional[tp.ArrayLike] = None,
                     allow_partial: tp.Optional[tp.ArrayLike] = None,
                     raise_reject: tp.Optional[tp.ArrayLike] = None,
                     log: tp.Optional[tp.ArrayLike] = None,
                     accumulate: tp.Optional[tp.ArrayLike] = None,
                     conflict_mode: tp.Optional[tp.ArrayLike] = None,
                     close_first: tp.Optional[tp.ArrayLike] = None,
                     val_price: tp.Optional[tp.ArrayLike] = None,
                     open: tp.Optional[tp.ArrayLike] = None,
                     high: tp.Optional[tp.ArrayLike] = None,
                     low: tp.Optional[tp.ArrayLike] = None,
                     sl_stop: tp.Optional[tp.ArrayLike] = None,
                     sl_trail: tp.Optional[tp.ArrayLike] = None,
                     tp_stop: tp.Optional[tp.ArrayLike] = None,
                     stop_entry_price: tp.Optional[tp.ArrayLike] = None,
                     stop_exit_price: tp.Optional[tp.ArrayLike] = None,
                     stop_conflict_mode: tp.Optional[tp.ArrayLike] = None,
                     stop_exit_mode: tp.Optional[tp.ArrayLike] = None,
                     stop_update_mode: tp.Optional[tp.ArrayLike] = None,
                     adjust_sl_func_nb: nb.AdjustSLFuncT = nb.no_adjust_sl_func_nb,
                     adjust_sl_args: tp.Args = (),
                     adjust_tp_func_nb: nb.AdjustTPFuncT = nb.no_adjust_tp_func_nb,
                     adjust_tp_args: tp.Args = (),
                     use_stops: tp.Optional[bool] = None,
                     init_cash: tp.Optional[tp.ArrayLike] = None,
                     cash_sharing: tp.Optional[bool] = None,
                     call_seq: tp.Optional[tp.ArrayLike] = None,
                     ffill_val_price: tp.Optional[bool] = None,
                     update_value: tp.Optional[bool] = None,
                     max_orders: tp.Optional[int] = None,
                     max_logs: tp.Optional[int] = None,
                     seed: tp.Optional[int] = None,
                     group_by: tp.GroupByLike = None,
                     broadcast_kwargs: tp.KwargsLike = None,
                     wrapper_kwargs: tp.KwargsLike = None,
                     freq: tp.Optional[tp.FrequencyLike] = None,
                     **kwargs) -&gt; PortfolioT:
        &#34;&#34;&#34;Simulate portfolio from entry and exit signals.

        Args:
            close (array_like): See `Portfolio.from_orders`.
            entries (array_like of bool): Boolean array of entry signals.
                Defaults to True. Will broadcast.

                Becomes a long signal if `direction` is `all` or `longonly`, otherwise short.
            exits (array_like of bool): Boolean array of exit signals.
                Defaults to False. Will broadcast.

                Becomes a short signal if `direction` is `all` or `longonly`, otherwise long.
            size (float or array_like): See `Portfolio.from_orders`.

                !!! note
                    Negative size is not allowed. You should express direction using signals.
            size_type (SizeType or array_like): See `Portfolio.from_orders`.

                Only `SizeType.Amount`, `SizeType.Value`, and `SizeType.Percent` are supported.
                Other modes such as target percentage are not compatible with signals since
                their logic may contradict the direction of the signal.

                !!! note
                    `SizeType.Percent` does not support position reversal. Switch to a single
                    direction or use `close_first`.

                See warning in `Portfolio.from_orders`.
            direction (Direction or array_like): See `Portfolio.from_orders`.
            price (array_like of float): See `Portfolio.from_orders`.
            fees (float or array_like): See `Portfolio.from_orders`.
            fixed_fees (float or array_like): See `Portfolio.from_orders`.
            slippage (float or array_like): See `Portfolio.from_orders`.
            min_size (float or array_like): See `Portfolio.from_orders`.
            max_size (float or array_like): See `Portfolio.from_orders`.

                Will be partially filled if exceeded. You might not be able to properly close
                the position if accumulation is enabled and `max_size` is too low.
            reject_prob (float or array_like): See `Portfolio.from_orders`.
            lock_cash (bool or array_like): See `Portfolio.from_orders`.
            allow_partial (bool or array_like): See `Portfolio.from_orders`.
            raise_reject (bool or array_like): See `Portfolio.from_orders`.
            log (bool or array_like): See `Portfolio.from_orders`.
            accumulate (bool or array_like): Whether to accumulate signals.
                Will broadcast.

                Allows gradually increasing and decreasing positions using `size`.
                When enabled, `Portfolio.from_signals` behaves like `Portfolio.from_orders`.
            conflict_mode (ConflictMode or array_like): See `vectorbt.portfolio.enums.ConflictMode`.
                Will broadcast.
            close_first (bool or array_like): Whether to close the position first before reversal.
                Will broadcast.

                Otherwise reverses the position with a single order and within the same tick.
                Takes only effect under `Direction.All`. Requires a second signal to enter
                the opposite position. This allows to define parameters such as `fixed_fees` for long
                and short positions separately.
            val_price (array_like of float): See `Portfolio.from_orders`.
            open (array_like of float): First asset price at each time step.
                Defaults to `np.nan`, which gets replaced by `close`. Will broadcast.

                Used solely for stop signals.
            high (array_like of float): Highest asset price at each time step.
                Defaults to `np.nan`, which gets replaced by the maximum out of `open` and `close`. Will broadcast.

                Used solely for stop signals.
            low (array_like of float): Lowest asset price at each time step.
                Defaults to `np.nan`, which gets replaced by the minimum out of `open` and `close`. Will broadcast.

                Used solely for stop signals.
            sl_stop (array_like of float): Stop loss.
                Will broadcast.

                A percentage below/above the acquisition price for long/short position.
                Note that 0.01 = 1%.
            sl_trail (array_like of bool): Whether `sl_stop` should be trailing.
                Will broadcast.
            tp_stop (array_like of float): Take profit.
                Will broadcast.

                A percentage above/below the acquisition price for long/short position.
                Note that 0.01 = 1%.
            stop_entry_price (StopEntryPrice or array_like): See `vectorbt.portfolio.enums.StopEntryPrice`.
                Will broadcast.

                If provided on per-element basis, gets applied upon entry.
            stop_exit_price (StopExitPrice or array_like): See `vectorbt.portfolio.enums.StopExitPrice`.
                Will broadcast.

                If provided on per-element basis, gets applied upon exit.
            stop_conflict_mode (StopConflictMode or array_like): See `vectorbt.portfolio.enums.StopConflictMode`.
                Will broadcast.

                If provided on per-element basis, gets applied upon exit.
            stop_exit_mode (StopExitMode or array_like): See `vectorbt.portfolio.enums.StopExitMode`.
                Will broadcast.

                If provided on per-element basis, gets applied upon exit.
            stop_update_mode (StopUpdateMode or array_like): See `vectorbt.portfolio.enums.StopUpdateMode`.
                Will broadcast.

                Only has effect is `accumulate` is True.

                If provided on per-element basis, gets applied upon repeated entry.
            adjust_sl_func_nb (callable): Function to adjust stop loss.
                Defaults to `vectorbt.portfolio.nb.no_adjust_sl_func_nb`.

                Called for each element before each row.

                Should accept index of the current row, index of the current column, the current position size,
                the latest asset price, initial index of the stop, initial price of the stop, initial value
                of the stop, initial trailing flag of the stop, and `*adjust_sl_args`.
                Should return a tuple of a new stop value and trailing flag.
            adjust_sl_args (tuple): Packed arguments passed to `adjust_sl_func_nb`.
                Defaults to `()`.
            adjust_tp_func_nb (callable): Function to adjust take profit.
                Defaults to `vectorbt.portfolio.nb.no_adjust_tp_func_nb`.

                Called for each element before each row.

                Should accept index of the current row, index of the current column, the current position size,
                the latest asset price, initial index of the stop, initial price of the stop, initial value
                of the stop, and `*adjust_tp_args`. Should return a new stop value.
            adjust_tp_args (tuple): Packed arguments passed to `adjust_tp_func_nb`.
                Defaults to `()`.
            use_stops (bool): Whether to use stops.
                Defaults to None, which becomes True if any of the stops are not NaN or
                any of the adjustment functions are custom.

                Disable this to make simulation a bit faster for simple use cases.
            init_cash (InitCashMode, float or array_like of float): See `Portfolio.from_orders`.
            cash_sharing (bool): See `Portfolio.from_orders`.
            call_seq (CallSeqType or array_like): See `Portfolio.from_orders`.
            ffill_val_price (bool): See `Portfolio.from_orders`.
            update_value (bool): See `Portfolio.from_orders`.
            max_orders (int): See `Portfolio.from_orders`.
            max_logs (int): See `Portfolio.from_orders`.
            seed (int): See `Portfolio.from_orders`.
            group_by (any): See `Portfolio.from_orders`.
            broadcast_kwargs (dict): See `Portfolio.from_orders`.
            wrapper_kwargs (dict): See `Portfolio.from_orders`.
            freq (any): See `Portfolio.from_orders`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        All broadcastable arguments will broadcast using `vectorbt.base.reshape_fns.broadcast`
        but keep original shape to utilize flexible indexing and to save memory.

        For defaults, see `portfolio` in `vectorbt._settings.settings`.

        !!! hint
            If you generated signals using close price, don&#39;t forget to shift your signals by one tick
            forward, for example, with `signals.vbt.fshift(1)`. In general, make sure to use a price
            that comes after the signal.

        Also see notes and hints for `Portfolio.from_orders`.

        ## Example

        Entry opens long, exit closes long:

        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; entries = pd.Series([True, True, True, False, False])
        &gt;&gt;&gt; exits = pd.Series([False, False, True, True, True])

        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;longonly&#39;)
        &gt;&gt;&gt; pf.asset_flow()
        0    1.0
        1    0.0
        2    0.0
        3   -1.0
        4    0.0
        dtype: float64
        ```

        Entry opens short, exit closes short:

        ```python-repl
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;shortonly&#39;)
        &gt;&gt;&gt; pf.asset_flow()
        0   -1.0
        1    0.0
        2    0.0
        3    1.0
        4    0.0
        dtype: float64
        ```

        Reversal within one tick. Entry opens long and closes short, exit closes long and opens short:

        ```python-repl
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;)
        &gt;&gt;&gt; pf.asset_flow()
        0    1.0
        1    0.0
        2    0.0
        3   -2.0
        4    0.0
        dtype: float64
        ```

        Reversal within two ticks. First signal closes position, second signal opens the opposite one:

        ```python-repl
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;,
        ...     close_first=True)
        &gt;&gt;&gt; pf.asset_flow()
        0    1.0
        1    0.0
        2    0.0
        3   -1.0
        4   -1.0
        dtype: float64
        ```

        If entry and exit, chooses exit:

        ```python-repl
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;,
        ...     close_first=True, conflict_mode=&#39;exit&#39;)
        &gt;&gt;&gt; pf.asset_flow()
        0    1.0
        1    0.0
        2   -1.0
        3   -1.0
        4    0.0
        dtype: float64
        ```

        Entry means long order, exit means short order (acts similar to `from_orders`):

        ```python-repl
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;,
        ...     accumulate=True)
        &gt;&gt;&gt; pf.asset_flow()
        0    1.0
        1    1.0
        2    0.0
        3   -1.0
        4   -1.0
        dtype: float64
        ```

        Testing multiple parameters (via broadcasting):

        ```python-repl
        &gt;&gt;&gt; from vectorbt.portfolio.enums import Direction

        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, direction=[list(Direction)],
        ...     broadcast_kwargs=dict(columns_from=Direction._fields))
        &gt;&gt;&gt; pf.asset_flow()
            Long  Short    All
        0  100.0 -100.0  100.0
        1    0.0    0.0    0.0
        2    0.0    0.0    0.0
        3 -100.0   50.0 -200.0
        4    0.0    0.0    0.0
        ```

        Specifying information in a more granular way thanks to broadcasting.
        Reverse the first long position by first closing it, and all other immediately:

        ```python-repl
        &gt;&gt;&gt; entries = pd.Series([True, False, False, True, False])
        &gt;&gt;&gt; exits = pd.Series([False, True, True, False, True])
        &gt;&gt;&gt; close_first = pd.Series([False, True, False, False, False])
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;,
        ...     close_first=close_first)
        &gt;&gt;&gt; pf.asset_flow()
        0    1.0
        1   -1.0
        2   -1.0
        3    2.0
        4   -2.0
        dtype: float64
        ```

        Set risk/reward ratio by passing trailing stop loss and take profit thresholds:

        ```python-repl
        &gt;&gt;&gt; close = pd.Series([10, 11, 12, 11, 10, 9])
        &gt;&gt;&gt; entries = pd.Series([True, False, False, False, False, False])
        &gt;&gt;&gt; exits = pd.Series([False, False, False, False, False, True])
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits,
        ...     sl_stop=0.1, sl_trail=True, tp_stop=0.2)  # take profit hit
        &gt;&gt;&gt; pf.asset_flow()
        0    10.0
        1     0.0
        2   -10.0
        3     0.0
        4     0.0
        5     0.0
        dtype: float64

        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits,
        ...     sl_stop=0.1, sl_trail=True, tp_stop=0.3)  # stop loss hit
        &gt;&gt;&gt; pf.asset_flow()
        0    10.0
        1     0.0
        2     0.0
        3     0.0
        4   -10.0
        5     0.0
        dtype: float64

        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits,
        ...     sl_stop=np.inf, sl_trail=True, tp_stop=np.inf)  # nothing hit, exit as usual
        &gt;&gt;&gt; pf.asset_flow()
        0    10.0
        1     0.0
        2     0.0
        3     0.0
        4     0.0
        5   -10.0
        dtype: float64
        ```

        We can implement our own stop loss or take profit, or adjust the existing one at each time step.
        Let&#39;s implement [stepped stop-loss](https://www.freqtrade.io/en/stable/strategy-advanced/#stepped-stoploss):

        ```python-repl
        &gt;&gt;&gt; from numba import njit

        &gt;&gt;&gt; @njit
        ... def adjust_sl_func_nb(i, col, position, val_price, init_i, init_price, init_stop, init_trail):
        ...     current_profit = (val_price - init_price) / init_price
        ...     if current_profit &gt;= 0.40:
        ...         return 0.25, True
        ...     elif current_profit &gt;= 0.25:
        ...         return 0.15, True
        ...     elif current_profit &gt;= 0.20:
        ...         return 0.07, True
        ...     return init_stop, init_trail

        &gt;&gt;&gt; close = pd.Series([10, 11, 12, 11, 10])
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, adjust_sl_func_nb=adjust_sl_func_nb)
        &gt;&gt;&gt; pf.asset_flow()
        0    10.0
        1     0.0
        2     0.0
        3   -10.0  # 7% from 12 hit
        4    11.0
        dtype: float64
        ```

        Combine multiple exit conditions. Exit early if the price hits some threshold before an actual exit:

        ```python-repl
        &gt;&gt;&gt; close = pd.Series([10, 11, 12, 13, 14, 15])
        &gt;&gt;&gt; entries = pd.Series([True, True, True, False, False, False])
        &gt;&gt;&gt; exits = pd.Series([False, False, False, True, True, True])

        &gt;&gt;&gt; # 1. Remove adjacent entries and exits
        &gt;&gt;&gt; # since stop condition refers only to the first signal
        &gt;&gt;&gt; entries, exits = entries.vbt.signals.clean(exits)
        &gt;&gt;&gt; entries
        0     True
        1    False
        2    False
        3    False
        4    False
        5    False
        dtype: bool
        &gt;&gt;&gt; exits
        0    False
        1    False
        2    False
        3     True
        4    False
        5    False
        dtype: bool

        &gt;&gt;&gt; # 2. Find stop exits
        &gt;&gt;&gt; stop_exits = entries.vbt.signals.generate_stop_exits(close, 0.1)
        &gt;&gt;&gt; stop_exits
        0    False
        1     True
        2    False
        3    False
        4    False
        5    False
        dtype: bool

        &gt;&gt;&gt; # 3. Combine exits
        &gt;&gt;&gt; exits = exits | stop_exits
        &gt;&gt;&gt; exits
        0    False
        1     True
        2    False
        3     True
        4    False
        5    False
        dtype: bool

        &gt;&gt;&gt; # 4. Pick the first exit after each entry
        &gt;&gt;&gt; exits = exits.vbt.signals.first(reset_by=entries, allow_gaps=True)
        &gt;&gt;&gt; exits
        0    False
        1     True
        2    False
        3    False
        4    False
        5    False
        dtype: bool

        &gt;&gt;&gt; # 5. Simulate portfolio
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(close, entries, exits)
        &gt;&gt;&gt; pf.asset_flow()
        0    10.0
        1   -10.0
        2     0.0
        3     0.0
        4     0.0
        5     0.0
        dtype: float64
        ```

        !!! note
            By cleaning signals, we lose information. Moreover, this automatically assumes
            that each entry/signal signal succeeds (= order gets filled). Use this with caution,
            and consider rewriting your strategy with `Portfolio.from_order_func`, which is a
            preferred way of defining a complex logic in vectorbt.
        &#34;&#34;&#34;
        # Get defaults
        from vectorbt._settings import settings
        portfolio_cfg = settings[&#39;portfolio&#39;]

        if entries is None:
            entries = True
        if exits is None:
            exits = False
        if size is None:
            size = portfolio_cfg[&#39;size&#39;]
        if size_type is None:
            size_type = portfolio_cfg[&#39;signal_size_type&#39;]
        size_type = cast_enum_value(size_type, SizeType)
        if direction is None:
            direction = portfolio_cfg[&#39;signal_direction&#39;]
        direction = cast_enum_value(direction, Direction)
        if price is None:
            price = np.inf
        if fees is None:
            fees = portfolio_cfg[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = portfolio_cfg[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = portfolio_cfg[&#39;slippage&#39;]
        if min_size is None:
            min_size = portfolio_cfg[&#39;min_size&#39;]
        if max_size is None:
            max_size = portfolio_cfg[&#39;max_size&#39;]
        if reject_prob is None:
            reject_prob = portfolio_cfg[&#39;reject_prob&#39;]
        if lock_cash is None:
            lock_cash = portfolio_cfg[&#39;lock_cash&#39;]
        if allow_partial is None:
            allow_partial = portfolio_cfg[&#39;allow_partial&#39;]
        if raise_reject is None:
            raise_reject = portfolio_cfg[&#39;raise_reject&#39;]
        if log is None:
            log = portfolio_cfg[&#39;log&#39;]
        if accumulate is None:
            accumulate = portfolio_cfg[&#39;accumulate&#39;]
        if conflict_mode is None:
            conflict_mode = portfolio_cfg[&#39;conflict_mode&#39;]
        conflict_mode = cast_enum_value(conflict_mode, ConflictMode)
        if close_first is None:
            close_first = portfolio_cfg[&#39;close_first&#39;]
        if val_price is None:
            val_price = portfolio_cfg[&#39;val_price&#39;]
        if open is None:
            open = np.nan
        if high is None:
            high = np.nan
        if low is None:
            low = np.nan
        if sl_stop is None:
            sl_stop = portfolio_cfg[&#39;sl_stop&#39;]
        if sl_trail is None:
            sl_trail = portfolio_cfg[&#39;sl_trail&#39;]
        if tp_stop is None:
            tp_stop = portfolio_cfg[&#39;tp_stop&#39;]
        if stop_entry_price is None:
            stop_entry_price = portfolio_cfg[&#39;stop_entry_price&#39;]
        stop_entry_price = cast_enum_value(stop_entry_price, StopEntryPrice)
        if stop_exit_price is None:
            stop_exit_price = portfolio_cfg[&#39;stop_exit_price&#39;]
        stop_exit_price = cast_enum_value(stop_exit_price, StopExitPrice)
        if stop_conflict_mode is None:
            stop_conflict_mode = portfolio_cfg[&#39;stop_conflict_mode&#39;]
        stop_conflict_mode = cast_enum_value(stop_conflict_mode, ConflictMode)
        if stop_exit_mode is None:
            stop_exit_mode = portfolio_cfg[&#39;stop_exit_mode&#39;]
        stop_exit_mode = cast_enum_value(stop_exit_mode, StopExitMode)
        if stop_update_mode is None:
            stop_update_mode = portfolio_cfg[&#39;stop_update_mode&#39;]
        stop_update_mode = cast_enum_value(stop_update_mode, StopUpdateMode)
        if use_stops is None:
            use_stops = portfolio_cfg[&#39;use_stops&#39;]
        if use_stops is None:
            if isinstance(sl_stop, float) and \
                    np.isnan(sl_stop) and \
                    isinstance(tp_stop, float) and \
                    np.isnan(tp_stop) and \
                    adjust_sl_func_nb == nb.no_adjust_sl_func_nb and \
                    adjust_tp_func_nb == nb.no_adjust_tp_func_nb:
                use_stops = False
            else:
                use_stops = True

        if init_cash is None:
            init_cash = portfolio_cfg[&#39;init_cash&#39;]
        init_cash = cast_enum_value(init_cash, InitCashMode)
        if isinstance(init_cash, int) and init_cash in InitCashMode:
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = portfolio_cfg[&#39;cash_sharing&#39;]
        if cash_sharing and group_by is None:
            group_by = True
        if call_seq is None:
            call_seq = portfolio_cfg[&#39;call_seq&#39;]
        call_seq = cast_enum_value(call_seq, CallSeqType)
        auto_call_seq = False
        if isinstance(call_seq, int):
            if call_seq == CallSeqType.Auto:
                call_seq = CallSeqType.Default
                auto_call_seq = True
        if ffill_val_price is None:
            ffill_val_price = portfolio_cfg[&#39;ffill_val_price&#39;]
        if update_value is None:
            update_value = portfolio_cfg[&#39;update_value&#39;]
        if seed is None:
            seed = portfolio_cfg[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = portfolio_cfg[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Broadcast inputs
        # Only close is broadcast, others can remain unchanged thanks to flexible indexing
        broadcastable_args = (
            close,
            entries,
            exits,
            size,
            price,
            size_type,
            direction,
            fees,
            fixed_fees,
            slippage,
            min_size,
            max_size,
            reject_prob,
            lock_cash,
            allow_partial,
            raise_reject,
            log,
            accumulate,
            conflict_mode,
            close_first,
            val_price,
            open,
            high,
            low,
            sl_stop,
            sl_trail,
            tp_stop,
            stop_entry_price,
            stop_exit_price,
            stop_conflict_mode,
            stop_exit_mode,
            stop_update_mode
        )
        broadcast_kwargs = merge_dicts(dict(
            keep_raw=[False] + [True] * (len(broadcastable_args) - 1),
            require_kwargs=dict(requirements=&#39;W&#39;)
        ), broadcast_kwargs)
        broadcasted_args = broadcast(*broadcastable_args, **broadcast_kwargs)
        close = broadcasted_args[0]
        if not checks.is_pandas(close):
            close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
        target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
        init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
        group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
        if checks.is_any_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
        if max_orders is None:
            max_orders = target_shape_2d[0] * target_shape_2d[1]
        if max_logs is None:
            max_logs = target_shape_2d[0] * target_shape_2d[1]
        if not np.any(log):
            max_logs = 1

        # Perform calculation
        order_records, log_records = nb.simulate_from_signals_nb(
            target_shape_2d,
            to_2d(close, raw=True),
            cs_group_lens,  # group only if cash sharing is enabled to speed up
            init_cash,
            call_seq,
            *map(np.asarray, broadcasted_args[1:]),
            adjust_sl_func_nb,
            adjust_sl_args,
            adjust_tp_func_nb,
            adjust_tp_args,
            use_stops,
            auto_call_seq,
            ffill_val_price,
            update_value,
            max_orders,
            max_logs,
            close.ndim == 2
        )

        # Create an instance
        return cls(
            wrapper,
            close,
            order_records,
            log_records,
            init_cash if init_cash_mode is None else init_cash_mode,
            cash_sharing,
            call_seq,
            **kwargs
        )

    @classmethod
    def from_orders(cls: tp.Type[PortfolioT],
                    close: tp.ArrayLike,
                    size: tp.Optional[tp.ArrayLike] = None,
                    size_type: tp.Optional[tp.ArrayLike] = None,
                    direction: tp.Optional[tp.ArrayLike] = None,
                    price: tp.Optional[tp.ArrayLike] = None,
                    fees: tp.Optional[tp.ArrayLike] = None,
                    fixed_fees: tp.Optional[tp.ArrayLike] = None,
                    slippage: tp.Optional[tp.ArrayLike] = None,
                    min_size: tp.Optional[tp.ArrayLike] = None,
                    max_size: tp.Optional[tp.ArrayLike] = None,
                    reject_prob: tp.Optional[tp.ArrayLike] = None,
                    lock_cash: tp.Optional[tp.ArrayLike] = None,
                    allow_partial: tp.Optional[tp.ArrayLike] = None,
                    raise_reject: tp.Optional[tp.ArrayLike] = None,
                    log: tp.Optional[tp.ArrayLike] = None,
                    val_price: tp.Optional[tp.ArrayLike] = None,
                    init_cash: tp.Optional[tp.ArrayLike] = None,
                    cash_sharing: tp.Optional[bool] = None,
                    call_seq: tp.Optional[tp.ArrayLike] = None,
                    ffill_val_price: tp.Optional[bool] = None,
                    update_value: tp.Optional[bool] = None,
                    max_orders: tp.Optional[int] = None,
                    max_logs: tp.Optional[int] = None,
                    seed: tp.Optional[int] = None,
                    group_by: tp.GroupByLike = None,
                    broadcast_kwargs: tp.KwargsLike = None,
                    wrapper_kwargs: tp.KwargsLike = None,
                    freq: tp.Optional[tp.FrequencyLike] = None,
                    **kwargs) -&gt; PortfolioT:
        &#34;&#34;&#34;Simulate portfolio from orders.

        Args:
            close (array_like): Last asset price at each time step.
                Will broadcast.

                Used for calculating unrealized P&amp;L and portfolio value.
            size (float or array_like): Size to order.
                See `vectorbt.portfolio.enums.Order.size`. Will broadcast.
            size_type (SizeType or array_like): See `vectorbt.portfolio.enums.SizeType`.
                See `vectorbt.portfolio.enums.Order.size_type`. Will broadcast.

                !!! note
                    `SizeType.Percent` does not support position reversal. Switch to a single direction.

                !!! warning
                    Be cautious using `SizeType.Percent` with `call_seq` set to &#39;auto&#39;.
                    To execute sell orders before buy orders, the value of each order in the group
                    needs to be approximated in advance. But since `SizeType.Percent` depends
                    upon the cash balance, which cannot be calculated in advance since it may change
                    after each order, this can yield a non-optimal call sequence.
            direction (Direction or array_like): See `vectorbt.portfolio.enums.Direction`.
                See `vectorbt.portfolio.enums.Order.direction`. Will broadcast.
            price (array_like of float): Order price.
                See `vectorbt.portfolio.enums.Order.price`. Defaults to `np.inf`. Will broadcast.

                !!! note
                    Make sure to use the same timestamp for all order prices in the group with cash sharing
                    and `call_seq` set to `CallSeqType.Auto`.
            fees (float or array_like): Fees in percentage of the order value.
                See `vectorbt.portfolio.enums.Order.fees`. Will broadcast.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order.
                See `vectorbt.portfolio.enums.Order.fixed_fees`. Will broadcast.
            slippage (float or array_like): Slippage in percentage of price.
                See `vectorbt.portfolio.enums.Order.slippage`. Will broadcast.
            min_size (float or array_like): Minimum size for an order to be accepted.
                See `vectorbt.portfolio.enums.Order.min_size`. Will broadcast.
            max_size (float or array_like): Maximum size for an order.
                See `vectorbt.portfolio.enums.Order.max_size`. Will broadcast.

                Will be partially filled if exceeded.
            reject_prob (float or array_like): Order rejection probability.
                See `vectorbt.portfolio.enums.Order.reject_prob`. Will broadcast.
            lock_cash (bool or array_like): Whether to lock cash when shorting.
                See `vectorbt.portfolio.enums.Order.lock_cash`. Will broadcast.
            allow_partial (bool or array_like): Whether to allow partial fills.
                See `vectorbt.portfolio.enums.Order.allow_partial`. Will broadcast.

                Does not apply when size is `np.inf`.
            raise_reject (bool or array_like): Whether to raise an exception if order gets rejected.
                See `vectorbt.portfolio.enums.Order.raise_reject`. Will broadcast.
            log (bool or array_like): Whether to log orders.
                See `vectorbt.portfolio.enums.Order.log`. Will broadcast.
            val_price (array_like of float): Asset valuation price.
                Will broadcast.

                * Any `-np.inf` element is replaced by the latest valuation price (the previous `close` or
                    the latest known valuation price if `ffill_val_price`).
                * Any `np.inf` element is replaced by the current order price.

                Used at the time of decision making to calculate value of each asset in the group,
                for example, to convert target value into target amount.

                !!! note
                    In contrast to `Portfolio.from_order_func`, order price is known beforehand (kind of),
                    thus `val_price` is set to the current order price (using `np.inf`) by default.
                    To valuate using previous close, set it in the settings to `-np.inf`.

                !!! note
                    Make sure to use timestamp for `val_price` that comes before timestamps of
                    all orders in the group with cash sharing (previous `close` for example),
                    otherwise you&#39;re cheating yourself.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                By default, will broadcast to the number of columns.
                If cash sharing is enabled, will broadcast to the number of groups.
                See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

                !!! note
                    Mode `InitCashMode.AutoAlign` is applied after the portfolio is initialized
                    to set the same initial cash for all columns/groups. Changing grouping
                    will change the initial cash, so be aware when indexing.
            cash_sharing (bool): Whether to share cash within the same group.

                If `group_by` is None, `group_by` becomes True to form a single group with cash sharing.

                !!! warning
                    Introduces cross-asset dependencies.

                    This method presumes that in a group of assets that share the same capital all
                    orders will be executed within the same tick and retain their price regardless
                    of their position in the queue, even though they depend upon each other and thus
                    cannot be executed in parallel.
            call_seq (CallSeqType or array_like): Default sequence of calls per row and group.

                Each value in this sequence should indicate the position of column in the group to
                call next. Processing of `call_seq` goes always from left to right.
                For example, `[2, 0, 1]` would first call column &#39;c&#39;, then &#39;a&#39;, and finally &#39;b&#39;.

                * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
                * Set to array to specify custom sequence. Will not broadcast.

                If `CallSeqType.Auto` selected, rearranges calls dynamically based on order value.
                Calculates value of all orders per row and group, and sorts them by this value.
                Sell orders will be executed first to release funds for buy orders.

                !!! warning
                    `CallSeqType.Auto` should be used with caution:

                    * It not only presumes that order prices are known beforehand, but also that
                        orders can be executed in arbitrary order and still retain their price.
                        In reality, this is hardly the case: after processing one asset, some time
                        has passed and the price for other assets might have already changed.
                    * Even if you&#39;re able to specify a slippage large enough to compensate for
                        this behavior, slippage itself should depend upon execution order.
                        This method doesn&#39;t let you do that.
                    * If one order is rejected, it still may execute next orders and possibly
                        leave them without required funds.

                    For more control, use `Portfolio.from_order_func`.
            ffill_val_price (bool): Whether to track valuation price only if it&#39;s known.

                Otherwise, unknown `close` will lead to NaN in valuation price at the next timestamp.
            update_value (bool): Whether to update group value after each filled order.
            max_orders (int): Size of the order records array.
                Defaults to the number of elements in the broadcasted shape.

                Set to a lower number if you run out of memory.
            max_logs (int): Size of the log records array.
                Defaults to the number of elements in the broadcasted shape if any of the `log` is True,
                otherwise to 1.

                Set to a lower number if you run out of memory.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            freq (any): Index frequency in case it cannot be parsed from `close`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        All broadcastable arguments will broadcast using `vectorbt.base.reshape_fns.broadcast`
        but keep original shape to utilize flexible indexing and to save memory.

        For defaults, see `portfolio` in `vectorbt._settings.settings`.

        !!! note
            When `call_seq` is not `CallSeqType.Auto`, at each timestamp, processing of the assets in
            a group goes strictly in order defined in `call_seq`. This order can&#39;t be changed dynamically.

            This has one big implication for this particular method: the last asset in the call stack
            cannot be processed until other assets are processed. This is the reason why rebalancing
            cannot work properly in this setting: one has to specify percentages for all assets beforehand
            and then tweak the processing order to sell to-be-sold assets first in order to release funds
            for to-be-bought assets. This can be automatically done by using `CallSeqType.Auto`.

        !!! hint
            All broadcastable arguments can be set per frame, series, row, column, or element.

        ## Example

        Buy 10 units each tick:

        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; pf = vbt.Portfolio.from_orders(close, 10)

        &gt;&gt;&gt; pf.assets()
        0    10.0
        1    20.0
        2    30.0
        3    40.0
        4    40.0
        dtype: float64
        &gt;&gt;&gt; pf.cash()
        0    90.0
        1    70.0
        2    40.0
        3     0.0
        4     0.0
        dtype: float64
        ```

        Reverse each position by first closing it:

        ```python-repl
        &gt;&gt;&gt; size = [1, 0, -1, 0, 1]
        &gt;&gt;&gt; pf = vbt.Portfolio.from_orders(close, size, size_type=&#39;targetpercent&#39;)

        &gt;&gt;&gt; pf.assets()
        0    100.000000
        1      0.000000
        2    -66.666667
        3      0.000000
        4     26.666667
        dtype: float64
        &gt;&gt;&gt; pf.cash()
        0      0.000000
        1    200.000000
        2    400.000000
        3    133.333333
        4      0.000000
        dtype: float64
        ```

        Equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb` example:
        It&#39;s more compact but has less control over execution:

        ```python-repl
        &gt;&gt;&gt; import numpy as np

        &gt;&gt;&gt; np.random.seed(42)
        &gt;&gt;&gt; close = pd.DataFrame(np.random.uniform(1, 10, size=(5, 3)))
        &gt;&gt;&gt; size = pd.Series(np.full(5, 1/3))  # each column 33.3%
        &gt;&gt;&gt; size[1::2] = np.nan  # skip every second tick

        &gt;&gt;&gt; pf = vbt.Portfolio.from_orders(
        ...     close,  # acts both as reference and order price here
        ...     size,
        ...     size_type=&#39;targetpercent&#39;,
        ...     call_seq=&#39;auto&#39;,  # first sell then buy
        ...     group_by=True,  # one group
        ...     cash_sharing=True,  # assets share the same cash
        ...     fees=0.001, fixed_fees=1., slippage=0.001  # costs
        ... )

        &gt;&gt;&gt; pf.asset_value(group_by=False).vbt.plot()
        ```

        ![](/vectorbt/docs/img/simulate_nb.svg)
        &#34;&#34;&#34;
        # Get defaults
        from vectorbt._settings import settings
        portfolio_cfg = settings[&#39;portfolio&#39;]

        if size is None:
            size = portfolio_cfg[&#39;size&#39;]
        if size_type is None:
            size_type = portfolio_cfg[&#39;size_type&#39;]
        size_type = cast_enum_value(size_type, SizeType)
        if direction is None:
            direction = portfolio_cfg[&#39;order_direction&#39;]
        direction = cast_enum_value(direction, Direction)
        if price is None:
            price = np.inf
        if size is None:
            size = portfolio_cfg[&#39;size&#39;]
        if fees is None:
            fees = portfolio_cfg[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = portfolio_cfg[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = portfolio_cfg[&#39;slippage&#39;]
        if min_size is None:
            min_size = portfolio_cfg[&#39;min_size&#39;]
        if max_size is None:
            max_size = portfolio_cfg[&#39;max_size&#39;]
        if reject_prob is None:
            reject_prob = portfolio_cfg[&#39;reject_prob&#39;]
        if lock_cash is None:
            lock_cash = portfolio_cfg[&#39;lock_cash&#39;]
        if allow_partial is None:
            allow_partial = portfolio_cfg[&#39;allow_partial&#39;]
        if raise_reject is None:
            raise_reject = portfolio_cfg[&#39;raise_reject&#39;]
        if log is None:
            log = portfolio_cfg[&#39;log&#39;]
        if val_price is None:
            val_price = portfolio_cfg[&#39;val_price&#39;]
        if init_cash is None:
            init_cash = portfolio_cfg[&#39;init_cash&#39;]
        init_cash = cast_enum_value(init_cash, InitCashMode)
        if isinstance(init_cash, int) and init_cash in InitCashMode:
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = portfolio_cfg[&#39;cash_sharing&#39;]
        if cash_sharing and group_by is None:
            group_by = True
        if call_seq is None:
            call_seq = portfolio_cfg[&#39;call_seq&#39;]
        call_seq = cast_enum_value(call_seq, CallSeqType)
        auto_call_seq = False
        if isinstance(call_seq, int):
            if call_seq == CallSeqType.Auto:
                call_seq = CallSeqType.Default
                auto_call_seq = True
        if ffill_val_price is None:
            ffill_val_price = portfolio_cfg[&#39;ffill_val_price&#39;]
        if update_value is None:
            update_value = portfolio_cfg[&#39;update_value&#39;]
        if seed is None:
            seed = portfolio_cfg[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = portfolio_cfg[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Broadcast inputs
        # Only close is broadcast, others can remain unchanged thanks to flexible indexing
        broadcastable_args = (
            close,
            size,
            price,
            size_type,
            direction,
            fees,
            fixed_fees,
            slippage,
            min_size,
            max_size,
            reject_prob,
            lock_cash,
            allow_partial,
            raise_reject,
            log,
            val_price
        )
        broadcast_kwargs = merge_dicts(dict(
            keep_raw=[False] + [True] * (len(broadcastable_args) - 1),
            require_kwargs=dict(requirements=&#39;W&#39;)
        ), broadcast_kwargs)
        broadcasted_args = broadcast(*broadcastable_args, **broadcast_kwargs)
        close = broadcasted_args[0]
        if not checks.is_pandas(close):
            close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
        target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
        init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
        group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
        if checks.is_any_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
        if max_orders is None:
            max_orders = target_shape_2d[0] * target_shape_2d[1]
        if max_logs is None:
            max_logs = target_shape_2d[0] * target_shape_2d[1]
        if not np.any(log):
            max_logs = 1

        # Perform calculation
        order_records, log_records = nb.simulate_from_orders_nb(
            target_shape_2d,
            to_2d(close, raw=True),
            cs_group_lens,  # group only if cash sharing is enabled to speed up
            init_cash,
            call_seq,
            *map(np.asarray, broadcasted_args[1:]),
            auto_call_seq,
            ffill_val_price,
            update_value,
            max_orders,
            max_logs,
            close.ndim == 2
        )

        # Create an instance
        return cls(
            wrapper,
            close,
            order_records,
            log_records,
            init_cash if init_cash_mode is None else init_cash_mode,
            cash_sharing,
            call_seq,
            **kwargs
        )

    @classmethod
    def from_order_func(cls: tp.Type[PortfolioT],
                        close: tp.ArrayLike,
                        order_func_nb: nb.OrderFuncT,
                        *order_args,
                        target_shape: tp.Optional[tp.RelaxedShape] = None,
                        keys: tp.Optional[tp.IndexLike] = None,
                        init_cash: tp.Optional[tp.ArrayLike] = None,
                        cash_sharing: tp.Optional[bool] = None,
                        call_seq: tp.Optional[tp.ArrayLike] = None,
                        segment_mask: tp.Optional[tp.ArrayLike] = None,
                        pre_sim_func_nb: nb.PreSimFuncT = nb.no_pre_func_nb,
                        pre_sim_args: tp.Args = (),
                        post_sim_func_nb: nb.PostSimFuncT = nb.no_post_func_nb,
                        post_sim_args: tp.Args = (),
                        pre_group_func_nb: nb.PreGroupFuncT = nb.no_pre_func_nb,
                        pre_group_args: tp.Args = (),
                        post_group_func_nb: nb.PostGroupFuncT = nb.no_post_func_nb,
                        post_group_args: tp.Args = (),
                        pre_row_func_nb: nb.PreRowFuncT = nb.no_pre_func_nb,
                        pre_row_args: tp.Args = (),
                        post_row_func_nb: nb.PostRowFuncT = nb.no_post_func_nb,
                        post_row_args: tp.Args = (),
                        pre_segment_func_nb: nb.PreSegmentFuncT = nb.no_pre_func_nb,
                        pre_segment_args: tp.Args = (),
                        post_segment_func_nb: nb.PostSegmentFuncT = nb.no_post_func_nb,
                        post_segment_args: tp.Args = (),
                        post_order_func_nb: nb.PostOrderFuncT = nb.no_post_func_nb,
                        post_order_args: tp.Args = (),
                        call_pre_segment: tp.Optional[bool] = None,
                        call_post_segment: tp.Optional[bool] = None,
                        ffill_val_price: tp.Optional[bool] = None,
                        update_value: tp.Optional[bool] = None,
                        fill_pos_record: tp.Optional[bool] = None,
                        row_wise: tp.Optional[bool] = None,
                        use_numba: tp.Optional[bool] = None,
                        max_orders: tp.Optional[int] = None,
                        max_logs: tp.Optional[int] = None,
                        seed: tp.Optional[int] = None,
                        group_by: tp.GroupByLike = None,
                        broadcast_kwargs: tp.KwargsLike = None,
                        wrapper_kwargs: tp.KwargsLike = None,
                        freq: tp.Optional[tp.FrequencyLike] = None,
                        **kwargs) -&gt; PortfolioT:
        &#34;&#34;&#34;Build portfolio from a custom order function.

        For details, see `vectorbt.portfolio.nb.simulate_nb`.

        if `row_wise` is True, also see `vectorbt.portfolio.nb.simulate_row_wise_nb`.

        Args:
            close (array_like): Last asset price at each time step.
                Will broadcast to `target_shape`.

                Used for calculating unrealized P&amp;L and portfolio value.
            order_func_nb (callable): Order generation function.
            *order_args: Arguments passed to `order_func_nb`.
            target_shape (tuple): Target shape to iterate over. Defaults to `close.shape`.
            keys (sequence): Outermost column level.

                Each element should correspond to one iteration over columns in `close`.
                Should be set only if `target_shape` is bigger than `close.shape`.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                See `init_cash` in `Portfolio.from_orders`.
            cash_sharing (bool): Whether to share cash within the same group.

                If `group_by` is None, `group_by` becomes True to form a single group with cash sharing.

                !!! warning
                    Introduces cross-asset dependencies.
            call_seq (CallSeqType or array_like): Default sequence of calls per row and group.

                * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
                * Set to array to specify custom sequence. Will not broadcast.

                !!! note
                    CallSeqType.Auto should be implemented manually.
                    Use `sort_call_seq_nb` in `pre_segment_func_nb`.
            segment_mask (int or array_like of bool): Mask of whether a particular segment should be executed.

                Supplying an integer will activate every n-th row (just for convenience).
                Supplying a boolean will broadcast to the number of rows and groups.
            pre_sim_func_nb (callable): Function called before simulation.
                Defaults to `vectorbt.portfolio.nb.no_pre_func_nb`.
            pre_sim_args (tuple): Packed arguments passed to `pre_sim_func_nb`.
                Defaults to `()`.
            post_sim_func_nb (callable): Function called after simulation.
                Defaults to `vectorbt.portfolio.nb.no_post_func_nb`.
            post_sim_args (tuple): Packed arguments passed to `post_sim_func_nb`.
                Defaults to `()`.
            pre_group_func_nb (callable): Function called before each group.
                Defaults to `vectorbt.portfolio.nb.no_pre_func_nb`.

                Called only if `row_wise` is False.
            pre_group_args (tuple): Packed arguments passed to `pre_group_func_nb`.
                Defaults to `()`.
            post_group_func_nb (callable): Function called after each group.
                Defaults to `vectorbt.portfolio.nb.no_post_func_nb`.

                Called only if `row_wise` is False.
            post_group_args (tuple): Packed arguments passed to `post_group_func_nb`.
                Defaults to `()`.
            pre_row_func_nb (callable): Function called before each row.
                Defaults to `vectorbt.portfolio.nb.no_pre_func_nb`.

                Called only if `row_wise` is True.
            pre_row_args (tuple): Packed arguments passed to `pre_row_func_nb`.
                Defaults to `()`.
            post_row_func_nb (callable): Function called after each row.
                Defaults to `vectorbt.portfolio.nb.no_post_func_nb`.

                Called only if `row_wise` is True.
            post_row_args (tuple): Packed arguments passed to `post_row_func_nb`.
                Defaults to `()`.
            pre_segment_func_nb (callable): Function called before each segment.
                Defaults to `vectorbt.portfolio.nb.no_pre_func_nb`.
            pre_segment_args (tuple): Packed arguments passed to `pre_segment_func_nb`.
                Defaults to `()`.
            post_segment_func_nb (callable): Function called after each segment.
                Defaults to `vectorbt.portfolio.nb.no_post_func_nb`.
            post_segment_args (tuple): Packed arguments passed to `post_segment_func_nb`.
                Defaults to `()`.
            post_order_func_nb (callable): Callback that is called after the order has been processed.
            post_order_args (tuple): Packed arguments passed to `post_order_func_nb`.
                Defaults to `()`.
            call_pre_segment (bool): Whether to call `pre_segment_func_nb` regardless of `segment_mask`.
            call_post_segment (bool): Whether to call `post_segment_func_nb` regardless of `segment_mask`.
            ffill_val_price (bool): Whether to track valuation price only if it&#39;s known.

                Otherwise, unknown `close` will lead to NaN in valuation price at the next timestamp.
            update_value (bool): Whether to update group value after each filled order.
            fill_pos_record (bool): Whether to fill position record.

                Disable this to make simulation a bit faster for simple use cases.
            row_wise (bool): Whether to iterate over rows rather than columns/groups.

                See `vectorbt.portfolio.nb.simulate_row_wise_nb`.
            use_numba (bool): Whether to run the main simulation function using Numba.

                !!! note
                    Disabling it does not disable Numba for other functions.
                    If neccessary, you should ensure that every other function does not uses Numba as well.
                    You can do this by using the `py_func` attribute of that function.
                    Or, you could disable Numba globally by doing `os.environ[&#39;NUMBA_DISABLE_JIT&#39;] = &#39;1&#39;`.
            max_orders (int): Size of the order records array.
                Defaults to the number of elements in the broadcasted shape.

                Set to a lower number if you run out of memory.
            max_logs (int): Size of the log records array.
                Defaults to the number of elements in the broadcasted shape.

                Set to a lower number if you run out of memory.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            freq (any): Index frequency in case it cannot be parsed from `close`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `portfolio` in `vectorbt._settings.settings`.

        !!! note
            All passed functions should be Numba-compiled.

            Objects passed as arguments to both functions will not broadcast to `target_shape`
            as their purpose is unknown. You should broadcast manually or use flexible indexing.

            Also see notes on `Portfolio.from_orders`.

        !!! note
            In contrast to other methods, the valuation price is previous `close`
            instead of order price, since the price of an order is unknown before call.
            You can still set valuation price explicitly in `pre_segment_func_nb`.

        ## Example

        Buy 10 units each tick using closing price:

        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from numba import njit
        &gt;&gt;&gt; import vectorbt as vbt
        &gt;&gt;&gt; from vectorbt.portfolio.nb import order_nb

        &gt;&gt;&gt; @njit
        ... def order_func_nb(c, size):
        ...     return order_nb(size=size)

        &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(close, order_func_nb, 10)

        &gt;&gt;&gt; pf.assets()
        0    10.0
        1    20.0
        2    30.0
        3    40.0
        4    40.0
        dtype: float64
        &gt;&gt;&gt; pf.cash()
        0    90.0
        1    70.0
        2    40.0
        3     0.0
        4     0.0
        dtype: float64
        ```

        Reverse each position by first closing it. Keep state of last position to determine
        which position to open next (just as an example, there are easier ways to do this):

        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from vectorbt.portfolio.nb import close_position_nb

        &gt;&gt;&gt; @njit
        ... def pre_group_func_nb(c):
        ...     last_pos_state = np.array([-1])
        ...     return (last_pos_state,)

        &gt;&gt;&gt; @njit
        ... def order_func_nb(c, last_pos_state):
        ...     if c.position_now != 0:
        ...         return close_position_nb()
        ...
        ...     if last_pos_state[0] == 1:
        ...         size = -np.inf  # open short
        ...         last_pos_state[0] = -1
        ...     else:
        ...         size = np.inf  # open long
        ...         last_pos_state[0] = 1
        ...     return order_nb(size=size)

        &gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(
        ...     close, order_func_nb, pre_group_func_nb=pre_group_func_nb)

        &gt;&gt;&gt; pf.assets()
        0    100.000000
        1      0.000000
        2    -66.666667
        3      0.000000
        4     26.666667
        dtype: float64
        &gt;&gt;&gt; pf.cash()
        0      0.000000
        1    200.000000
        2    400.000000
        3    133.333333
        4      0.000000
        dtype: float64
        ```

        Equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb` example:

        ```python-repl
        &gt;&gt;&gt; from vectorbt.portfolio.nb import sort_call_seq_nb
        &gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, Direction

        &gt;&gt;&gt; @njit
        ... def pre_group_func_nb(c):
        ...     &#39;&#39;&#39;Define empty arrays for each group.&#39;&#39;&#39;
        ...     order_value_out = np.empty(c.group_len, dtype=np.float_)
        ...     return (order_value_out,)

        &gt;&gt;&gt; @njit
        ... def pre_segment_func_nb(c, order_value_out):
        ...     &#39;&#39;&#39;Perform rebalancing at each segment.&#39;&#39;&#39;
        ...     for col in range(c.from_col, c.to_col):
        ...         # Here we use order price for group valuation
        ...         c.last_val_price[col] = c.close[c.i, col]
        ...     # Reorder call sequence such that selling orders come first and buying last
        ...     size = 1 / c.group_len
        ...     size_type = SizeType.TargetPercent
        ...     direction = Direction.LongOnly  # long positions only
        ...     sort_call_seq_nb(c, size, size_type, direction, order_value_out)
        ...     return (size, size_type, direction)

        &gt;&gt;&gt; @njit
        ... def order_func_nb(c, size, size_type, direction, fees, fixed_fees, slippage):
        ...     &#39;&#39;&#39;Place an order.&#39;&#39;&#39;
        ...     return order_nb(
        ...         size=size,
        ...         size_type=size_type,
        ...         direction=direction,
        ...         fees=fees,
        ...         fixed_fees=fixed_fees,
        ...         slippage=slippage
        ...     )

        &gt;&gt;&gt; np.random.seed(42)
        &gt;&gt;&gt; close = np.random.uniform(1, 10, size=(5, 3))
        &gt;&gt;&gt; fees = 0.001
        &gt;&gt;&gt; fixed_fees = 1.
        &gt;&gt;&gt; slippage = 0.001

        &gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(
        ...     close,  # acts both as reference and order price here
        ...     order_func_nb, fees, fixed_fees, slippage,  # order_args as *args
        ...     segment_mask=2,  # rebalance every second tick
        ...     pre_group_func_nb=pre_group_func_nb,
        ...     pre_segment_func_nb=pre_segment_func_nb,
        ...     cash_sharing=True, group_by=True,  # one group with cash sharing
        ... )

        &gt;&gt;&gt; pf.asset_value(group_by=False).vbt.plot()
        ```

        ![](/vectorbt/docs/img/simulate_nb.svg)

        Combine multiple exit conditions. Exit early if the price hits some threshold before an actual exit
        (similar to the example under `Portfolio.from_signals`, but doesn&#39;t remove any information):

        ```python-repl
        &gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb, to_2d
        &gt;&gt;&gt; from vectorbt.portfolio.enums import NoOrder, OrderStatus, OrderSide

        &gt;&gt;&gt; @njit
        ... def pre_sim_func_nb(c):
        ...     # We need to define stop price per column once
        ...     stop_price = np.full(c.target_shape[1], np.nan, dtype=np.float_)
        ...     return (stop_price,)

        &gt;&gt;&gt; @njit
        ... def order_func_nb(c, stop_price, entries, exits, size, flex_2d):
        ...     # Select info related to this order
        ...     # flex_select_auto_nb allows us to pass size as single number, 1-dim or 2-dim array
        ...     # If flex_2d is True, 1-dim array will be per column, otherwise per row
        ...     size_now = flex_select_auto_nb(c.i, c.col, np.asarray(size), flex_2d)
        ...     price_now = c.close[c.i, c.col]  # close is always 2-dim array
        ...     stop_price_now = stop_price[c.col]
        ...
        ...     # Our logic
        ...     if entries[c.i, c.col]:
        ...         if c.position_now == 0:
        ...             return order_nb(
        ...                 size=size_now,
        ...                 price=price_now,
        ...                 direction=Direction.LongOnly)
        ...     elif exits[c.i, c.col] or price_now &gt;= stop_price_now:
        ...         if c.position_now &gt; 0:
        ...             return order_nb(
        ...                 size=-size_now,
        ...                 price=price_now,
        ...                 direction=Direction.LongOnly)
        ...     return NoOrder

        &gt;&gt;&gt; @njit
        ... def post_order_func_nb(c, stop_price, stop, flex_2d):
        ...     # Same broadcasting as for size
        ...     stop_now = flex_select_auto_nb(c.i, c.col, np.asarray(stop), flex_2d)
        ...
        ...     if c.order_result.status == OrderStatus.Filled:
        ...         if c.order_result.side == OrderSide.Buy:
        ...             # Position entered: Set stop condition
        ...             stop_price[c.col] = (1 + stop_now) * c.order_result.price
        ...         else:
        ...             # Position exited: Remove stop condition
        ...             stop_price[c.col] = np.nan

        &gt;&gt;&gt; def simulate(close, entries, exits, threshold):
        ...     return vbt.Portfolio.from_order_func(
        ...         close,
        ...         order_func_nb,
        ...         to_2d(entries, raw=True),  # 2-dim array
        ...         to_2d(exits, raw=True),  # 2-dim array
        ...         np.inf, # will broadcast
        ...         True,
        ...         pre_sim_func_nb=pre_sim_func_nb,
        ...         post_order_func_nb=post_order_func_nb,
        ...         post_order_args=(
        ...             threshold,  # will broadcast
        ...             True
        ...         )
        ...     )

        &gt;&gt;&gt; close = pd.Series([10, 11, 12, 13, 14])
        &gt;&gt;&gt; entries = pd.Series([True, True, False, False, False])
        &gt;&gt;&gt; exits = pd.Series([False, False, False, True, True])
        &gt;&gt;&gt; simulate(close, entries, exits, 0.1).asset_flow()
        0    10.0
        1     0.0
        2   -10.0
        3     0.0
        4     0.0
        dtype: float64
        &gt;&gt;&gt; simulate(close, entries, exits, 0.2).asset_flow()
        0    10.0
        1     0.0
        2   -10.0
        3     0.0
        4     0.0
        dtype: float64
        &gt;&gt;&gt; simulate(close, entries, exits, np.nan).asset_flow()
        0    10.0
        1     0.0
        2     0.0
        3   -10.0
        4     0.0
        dtype: float64
        ```

        The reason why stop of 10% does not result in an order at the second time step is because
        it comes at the same time as entry, so it must wait until no entry is present.
        This can be changed by replacing the statement &#34;elif&#34; with &#34;if&#34;, which would execute
        an exit regardless if an entry is present (similar to using `ConflictMode.Opposite` in
        `Portfolio.from_signals`).
        &#34;&#34;&#34;
        # Get defaults
        from vectorbt._settings import settings
        portfolio_cfg = settings[&#39;portfolio&#39;]

        close = to_pd_array(close)
        if target_shape is None:
            target_shape = close.shape
        if init_cash is None:
            init_cash = portfolio_cfg[&#39;init_cash&#39;]
        init_cash = cast_enum_value(init_cash, InitCashMode)
        if isinstance(init_cash, int) and init_cash in InitCashMode:
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = portfolio_cfg[&#39;cash_sharing&#39;]
        if cash_sharing and group_by is None:
            group_by = True
        if call_seq is None:
            call_seq = portfolio_cfg[&#39;call_seq&#39;]
        call_seq = cast_enum_value(call_seq, CallSeqType)
        if isinstance(call_seq, int):
            if call_seq == CallSeqType.Auto:
                raise ValueError(&#34;CallSeqType.Auto should be implemented manually. &#34;
                                 &#34;Use sort_call_seq_nb in pre_segment_func_nb.&#34;)
        if segment_mask is None:
            segment_mask = True
        if call_pre_segment is None:
            call_pre_segment = portfolio_cfg[&#39;call_pre_segment&#39;]
        if call_post_segment is None:
            call_post_segment = portfolio_cfg[&#39;call_post_segment&#39;]
        if ffill_val_price is None:
            ffill_val_price = portfolio_cfg[&#39;ffill_val_price&#39;]
        if update_value is None:
            update_value = portfolio_cfg[&#39;update_value&#39;]
        if fill_pos_record is None:
            fill_pos_record = portfolio_cfg[&#39;fill_pos_record&#39;]
        if row_wise is None:
            row_wise = portfolio_cfg[&#39;row_wise&#39;]
        if use_numba is None:
            use_numba = portfolio_cfg[&#39;use_numba&#39;]
        if seed is None:
            seed = portfolio_cfg[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = portfolio_cfg[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        require_kwargs = dict(require_kwargs=dict(requirements=&#39;W&#39;))
        broadcast_kwargs = merge_dicts(require_kwargs, broadcast_kwargs)
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Broadcast inputs
        if isinstance(target_shape, int):
            target_shape = (target_shape,)
        target_shape_2d = (target_shape[0], target_shape[1] if len(target_shape) &gt; 1 else 1)
        if close.shape != target_shape:
            if len(close.vbt.wrapper.columns) &lt;= target_shape_2d[1]:
                if target_shape_2d[1] % len(close.vbt.wrapper.columns) != 0:
                    raise ValueError(&#34;Cannot broadcast close to target_shape&#34;)
                if keys is None:
                    keys = pd.Index(np.arange(target_shape_2d[1]), name=&#39;iteration_idx&#39;)
                tile_times = target_shape_2d[1] // len(close.vbt.wrapper.columns)
                close = close.vbt.tile(tile_times, keys=keys)
        close = broadcast(close, to_shape=target_shape, **broadcast_kwargs)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
        init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
        group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
        if isinstance(segment_mask, int):
            _segment_mask = np.full((target_shape_2d[0], len(group_lens)), False)
            _segment_mask[0::segment_mask] = True
            segment_mask = _segment_mask
        else:
            segment_mask = broadcast(
                segment_mask,
                to_shape=(target_shape_2d[0], len(group_lens)),
                to_pd=False,
                **require_kwargs
            )
        if checks.is_any_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
        if max_orders is None:
            max_orders = target_shape_2d[0] * target_shape_2d[1]
        if max_logs is None:
            max_logs = target_shape_2d[0] * target_shape_2d[1]

        # Perform calculation
        if row_wise:
            simulate_func = nb.simulate_row_wise_nb
            if not use_numba and hasattr(simulate_func, &#39;py_func&#39;):
                simulate_func = simulate_func.py_func
            order_records, log_records = simulate_func(
                target_shape=target_shape_2d,
                close=to_2d(close, raw=True),
                group_lens=group_lens,
                init_cash=init_cash,
                cash_sharing=cash_sharing,
                call_seq=call_seq,
                segment_mask=segment_mask,
                pre_sim_func_nb=pre_sim_func_nb,
                pre_sim_args=pre_sim_args,
                post_sim_func_nb=post_sim_func_nb,
                post_sim_args=post_sim_args,
                pre_row_func_nb=pre_row_func_nb,
                pre_row_args=pre_row_args,
                post_row_func_nb=post_row_func_nb,
                post_row_args=post_row_args,
                pre_segment_func_nb=pre_segment_func_nb,
                pre_segment_args=pre_segment_args,
                post_segment_func_nb=post_segment_func_nb,
                post_segment_args=post_segment_args,
                order_func_nb=order_func_nb,
                order_args=order_args,
                post_order_func_nb=post_order_func_nb,
                post_order_args=post_order_args,
                call_pre_segment=call_pre_segment,
                call_post_segment=call_post_segment,
                ffill_val_price=ffill_val_price,
                update_value=update_value,
                fill_pos_record=fill_pos_record,
                max_orders=max_orders,
                max_logs=max_logs
            )
        else:
            simulate_func = nb.simulate_nb
            if not use_numba and hasattr(simulate_func, &#39;py_func&#39;):
                simulate_func = simulate_func.py_func
            order_records, log_records = simulate_func(
                target_shape=target_shape_2d,
                close=to_2d(close, raw=True),
                group_lens=group_lens,
                init_cash=init_cash,
                cash_sharing=cash_sharing,
                call_seq=call_seq,
                segment_mask=segment_mask,
                pre_sim_func_nb=pre_sim_func_nb,
                pre_sim_args=pre_sim_args,
                post_sim_func_nb=post_sim_func_nb,
                post_sim_args=post_sim_args,
                pre_group_func_nb=pre_group_func_nb,
                pre_group_args=pre_group_args,
                post_group_func_nb=post_group_func_nb,
                post_group_args=post_group_args,
                pre_segment_func_nb=pre_segment_func_nb,
                pre_segment_args=pre_segment_args,
                post_segment_func_nb=post_segment_func_nb,
                post_segment_args=post_segment_args,
                order_func_nb=order_func_nb,
                order_args=order_args,
                post_order_func_nb=post_order_func_nb,
                post_order_args=post_order_args,
                call_pre_segment=call_pre_segment,
                call_post_segment=call_post_segment,
                ffill_val_price=ffill_val_price,
                update_value=update_value,
                fill_pos_record=fill_pos_record,
                max_orders=max_orders,
                max_logs=max_logs
            )

        # Create an instance
        return cls(
            wrapper,
            close,
            order_records,
            log_records,
            init_cash if init_cash_mode is None else init_cash_mode,
            cash_sharing,
            call_seq,
            **kwargs
        )

    # ############# Properties ############# #

    @property
    def wrapper(self) -&gt; ArrayWrapper:
        &#34;&#34;&#34;Array wrapper.&#34;&#34;&#34;
        if self.cash_sharing:
            # Allow only disabling grouping when needed (but not globally, see regroup)
            return self._wrapper.copy(
                allow_enable=False,
                allow_modify=False
            )
        return self._wrapper

    def regroup(self: PortfolioT, group_by: tp.GroupByLike, **kwargs) -&gt; PortfolioT:
        &#34;&#34;&#34;Regroup this object.

        See `vectorbt.base.array_wrapper.Wrapping.regroup`.

        !!! note
            All cached objects will be lost.&#34;&#34;&#34;
        if self.cash_sharing:
            if self.wrapper.grouper.is_grouping_modified(group_by=group_by):
                raise ValueError(&#34;Cannot modify grouping globally when cash_sharing=True&#34;)
        return Wrapping.regroup(self, group_by, **kwargs)

    @property
    def cash_sharing(self) -&gt; bool:
        &#34;&#34;&#34;Whether to share cash within the same group.&#34;&#34;&#34;
        return self._cash_sharing

    @property
    def call_seq(self, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Sequence of calls per row and group.&#34;&#34;&#34;
        return self.wrapper.wrap(self._call_seq, group_by=False, **merge_dicts({}, wrap_kwargs))

    @property
    def fillna_close(self) -&gt; bool:
        &#34;&#34;&#34;Whether to forward-backward fill NaN values in `Portfolio.close`.&#34;&#34;&#34;
        return self._fillna_close

    # ############# Reference price ############# #

    @property
    def close(self) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Price per unit series.&#34;&#34;&#34;
        return self._close

    @cached_method
    def get_filled_close(self, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Forward-backward-fill NaN values in `Portfolio.close`&#34;&#34;&#34;
        close = to_2d(self.close.ffill().bfill(), raw=True)
        return self.wrapper.wrap(close, group_by=False, **merge_dicts({}, wrap_kwargs))

    # ############# Records ############# #

    @property
    def order_records(self) -&gt; tp.RecordArray:
        &#34;&#34;&#34;A structured NumPy array of order records.&#34;&#34;&#34;
        return self._order_records

    @cached_property
    def orders(self) -&gt; Orders:
        &#34;&#34;&#34;`Portfolio.get_orders` with default arguments.&#34;&#34;&#34;
        return Orders(self.wrapper, self.order_records, self.close)

    @cached_method
    def get_orders(self, group_by: tp.GroupByLike = None) -&gt; Orders:
        &#34;&#34;&#34;Get order records.

        See `vectorbt.portfolio.orders.Orders`.&#34;&#34;&#34;
        return self.orders.regroup(group_by)

    @property
    def log_records(self) -&gt; tp.RecordArray:
        &#34;&#34;&#34;A structured NumPy array of log records.&#34;&#34;&#34;
        return self._log_records

    @cached_property
    def logs(self) -&gt; Logs:
        &#34;&#34;&#34;`Portfolio.get_logs` with default arguments.&#34;&#34;&#34;
        return Logs(self.wrapper, self.log_records)

    @cached_method
    def get_logs(self, group_by: tp.GroupByLike = None) -&gt; Logs:
        &#34;&#34;&#34;Get log records.

        See `vectorbt.portfolio.logs.Logs`.&#34;&#34;&#34;
        return self.logs.regroup(group_by)

    @cached_property
    def trades(self) -&gt; Trades:
        &#34;&#34;&#34;`Portfolio.get_trades` with default arguments.&#34;&#34;&#34;
        return Trades.from_orders(self.orders)

    @cached_method
    def get_trades(self, group_by: tp.GroupByLike = None) -&gt; Trades:
        &#34;&#34;&#34;Get trade records.

        See `vectorbt.portfolio.trades.Trades`.&#34;&#34;&#34;
        return self.trades.regroup(group_by)

    @cached_property
    def positions(self) -&gt; Positions:
        &#34;&#34;&#34;`Portfolio.get_positions` with default arguments.&#34;&#34;&#34;
        return Positions.from_trades(self.trades)

    @cached_method
    def get_positions(self, group_by: tp.GroupByLike = None) -&gt; Positions:
        &#34;&#34;&#34;Get position records.

        See `vectorbt.portfolio.trades.Positions`.&#34;&#34;&#34;
        return self.positions.regroup(group_by)

    @cached_property
    def drawdowns(self) -&gt; Drawdowns:
        &#34;&#34;&#34;`Portfolio.get_drawdowns` with default arguments.&#34;&#34;&#34;
        return self.get_drawdowns()

    @cached_method
    def get_drawdowns(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; Drawdowns:
        &#34;&#34;&#34;Get drawdown records from `Portfolio.value`.

        See `vectorbt.generic.drawdowns.Drawdowns`.

        `**kwargs` are passed to `Portfolio.value`.&#34;&#34;&#34;
        return Drawdowns.from_ts(self.value(group_by=group_by, **kwargs), freq=self.wrapper.freq)

    # ############# Assets ############# #

    @cached_method
    def asset_flow(self, direction: str = &#39;all&#39;, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get asset flow series per column.

        Returns the total transacted amount of assets at each time step.&#34;&#34;&#34;
        direction = cast_enum_value(direction, Direction)
        asset_flow = nb.asset_flow_nb(
            self.wrapper.shape_2d,
            self.orders.values,
            self.orders.col_mapper.col_map,
            direction
        )
        return self.wrapper.wrap(asset_flow, group_by=False, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def assets(self, direction: str = &#39;all&#39;, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get asset series per column.

        Returns the current position at each time step.&#34;&#34;&#34;
        direction = cast_enum_value(direction, Direction)
        asset_flow = to_2d(self.asset_flow(direction=&#39;all&#39;), raw=True)
        assets = nb.assets_nb(asset_flow)
        if direction == Direction.LongOnly:
            assets = np.where(assets &gt; 0, assets, 0.)
        if direction == Direction.ShortOnly:
            assets = np.where(assets &lt; 0, -assets, 0.)
        return self.wrapper.wrap(assets, group_by=False, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def position_mask(self, direction: str = &#39;all&#39;, group_by: tp.GroupByLike = None,
                      wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get position mask per column/group.

        An element is True if the asset is in the market at this tick.&#34;&#34;&#34;
        direction = cast_enum_value(direction, Direction)
        assets = to_2d(self.assets(direction=direction), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            position_mask = to_2d(self.position_mask(direction=direction, group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            position_mask = nb.position_mask_grouped_nb(position_mask, group_lens)
        else:
            position_mask = assets != 0
        return self.wrapper.wrap(position_mask, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def position_coverage(self, direction: str = &#39;all&#39;, group_by: tp.GroupByLike = None,
                          wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get position coverage per column/group.&#34;&#34;&#34;
        direction = cast_enum_value(direction, Direction)
        assets = to_2d(self.assets(direction=direction), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            position_mask = to_2d(self.position_mask(direction=direction, group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            position_coverage = nb.position_coverage_grouped_nb(position_mask, group_lens)
        else:
            position_coverage = np.mean(assets != 0, axis=0)
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;position_coverage&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(position_coverage, group_by=group_by, **wrap_kwargs)

    # ############# Cash ############# #

    @cached_method
    def cash_flow(self, group_by: tp.GroupByLike = None, free: bool = False,
                  wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get cash flow series per column/group.

        Use `free` to return the flow of the free cash, which never goes above the initial level,
        because an operation always costs money.&#34;&#34;&#34;
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            cash_flow = to_2d(self.cash_flow(group_by=False, free=free), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            cash_flow = nb.cash_flow_grouped_nb(cash_flow, group_lens)
        else:
            cash_flow = nb.cash_flow_nb(
                self.wrapper.shape_2d,
                self.orders.values,
                self.orders.col_mapper.col_map,
                free
            )
        return self.wrapper.wrap(cash_flow, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_property
    def init_cash(self) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;`Portfolio.get_init_cash` with default arguments.&#34;&#34;&#34;
        return self.get_init_cash()

    @cached_method
    def get_init_cash(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Initial amount of cash per column/group with default arguments.

        !!! note
            If the initial cash balance was found automatically and no own cash is used throughout
            the simulation (for example, when shorting), it will be set to 1 instead of 0 to enable
            smooth calculation of returns.&#34;&#34;&#34;
        if isinstance(self._init_cash, int):
            cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
            cash_min = np.min(np.cumsum(cash_flow, axis=0), axis=0)
            init_cash = np.where(cash_min &lt; 0, np.abs(cash_min), 1.)
            if self._init_cash == InitCashMode.AutoAlign:
                init_cash = np.full(init_cash.shape, np.max(init_cash))
        else:
            init_cash = to_1d(self._init_cash, raw=True)
            if self.wrapper.grouper.is_grouped(group_by=group_by):
                group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
                init_cash = nb.init_cash_grouped_nb(init_cash, group_lens, self.cash_sharing)
            else:
                group_lens = self.wrapper.grouper.get_group_lens()
                init_cash = nb.init_cash_nb(init_cash, group_lens, self.cash_sharing)
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;init_cash&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(init_cash, group_by=group_by, **wrap_kwargs)

    @cached_method
    def cash(self, group_by: tp.GroupByLike = None, in_sim_order: bool = False, free: bool = False,
             wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get cash balance series per column/group.

        See the explanation on `in_sim_order` in `Portfolio.value`.
        For `free`, see `Portfolio.cash_flow`.&#34;&#34;&#34;
        if in_sim_order and not self.cash_sharing:
            raise ValueError(&#34;Cash sharing must be enabled for in_sim_order=True&#34;)

        cash_flow = to_2d(self.cash_flow(group_by=group_by, free=free), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
            cash = nb.cash_grouped_nb(
                self.wrapper.shape_2d,
                cash_flow,
                group_lens,
                init_cash
            )
        else:
            if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
                group_lens = self.wrapper.grouper.get_group_lens()
                init_cash = to_1d(self.init_cash, raw=True)
                call_seq = to_2d(self.call_seq, raw=True)
                cash = nb.cash_in_sim_order_nb(cash_flow, group_lens, init_cash, call_seq)
            else:
                init_cash = to_1d(self.get_init_cash(group_by=False), raw=True)
                cash = nb.cash_nb(cash_flow, init_cash)
        return self.wrapper.wrap(cash, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    # ############# Performance ############# #

    @cached_method
    def asset_value(self, direction: str = &#39;all&#39;, group_by: tp.GroupByLike = None,
                    wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get asset value series per column/group.&#34;&#34;&#34;
        direction = cast_enum_value(direction, Direction)
        if self.fillna_close:
            close = to_2d(self.get_filled_close(), raw=True).copy()
        else:
            close = to_2d(self.close, raw=True).copy()
        assets = to_2d(self.assets(direction=direction), raw=True)
        close[assets == 0] = 0.  # for price being NaN
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            asset_value = to_2d(self.asset_value(direction=direction, group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            asset_value = nb.asset_value_grouped_nb(asset_value, group_lens)
        else:
            asset_value = nb.asset_value_nb(close, assets)
        return self.wrapper.wrap(asset_value, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def gross_exposure(self, direction: str = &#39;all&#39;, group_by: tp.GroupByLike = None,
                       wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get gross exposure.&#34;&#34;&#34;
        asset_value = to_2d(self.asset_value(group_by=group_by, direction=direction), raw=True)
        cash = to_2d(self.cash(group_by=group_by, free=True), raw=True)
        gross_exposure = nb.gross_exposure_nb(asset_value, cash)
        return self.wrapper.wrap(gross_exposure, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def net_exposure(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get net exposure.&#34;&#34;&#34;
        long_exposure = to_2d(self.gross_exposure(direction=&#39;longonly&#39;, group_by=group_by), raw=True)
        short_exposure = to_2d(self.gross_exposure(direction=&#39;shortonly&#39;, group_by=group_by), raw=True)
        net_exposure = long_exposure - short_exposure
        return self.wrapper.wrap(net_exposure, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def value(self, group_by: tp.GroupByLike = None, in_sim_order: bool = False,
              wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get portfolio value series per column/group.

        By default, will generate portfolio value for each asset based on cash flows and thus
        independent from other assets, with the initial cash balance and position being that of the
        entire group. Useful for generating returns and comparing assets within the same group.

        When `group_by` is False and `in_sim_order` is True, returns value generated in
        simulation order (see [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
        This value cannot be used for generating returns as-is. Useful to analyze how value
        evolved throughout simulation.&#34;&#34;&#34;
        cash = to_2d(self.cash(group_by=group_by, in_sim_order=in_sim_order), raw=True)
        asset_value = to_2d(self.asset_value(group_by=group_by), raw=True)
        if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
            group_lens = self.wrapper.grouper.get_group_lens()
            call_seq = to_2d(self.call_seq, raw=True)
            value = nb.value_in_sim_order_nb(cash, asset_value, group_lens, call_seq)
            # price of NaN is already addressed by ungrouped_value_nb
        else:
            value = nb.value_nb(cash, asset_value)
        return self.wrapper.wrap(value, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def total_profit(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Get total profit per column/group.

        Calculated directly from order records (fast).&#34;&#34;&#34;
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            total_profit = to_1d(self.total_profit(group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            total_profit = nb.total_profit_grouped_nb(
                total_profit,
                group_lens
            )
        else:
            if self.fillna_close:
                close = to_2d(self.get_filled_close(), raw=True)
            else:
                close = to_2d(self.close, raw=True)
            total_profit = nb.total_profit_nb(
                self.wrapper.shape_2d,
                close,
                self.orders.values,
                self.orders.col_mapper.col_map
            )
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total_profit&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(total_profit, group_by=group_by, **wrap_kwargs)

    @cached_method
    def final_value(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        total_profit = to_1d(self.total_profit(group_by=group_by), raw=True)
        final_value = nb.final_value_nb(total_profit, init_cash)
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;final_value&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(final_value, group_by=group_by, **wrap_kwargs)

    @cached_method
    def total_return(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        total_profit = to_1d(self.total_profit(group_by=group_by), raw=True)
        total_return = nb.total_return_nb(total_profit, init_cash)
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total_return&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(total_return, group_by=group_by, **wrap_kwargs)

    @cached_method
    def returns(self, group_by: tp.GroupByLike = None, in_sim_order=False,
                wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get return series per column/group based on portfolio value.&#34;&#34;&#34;
        value = to_2d(self.value(group_by=group_by, in_sim_order=in_sim_order), raw=True)
        if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
            group_lens = self.wrapper.grouper.get_group_lens()
            init_cash_grouped = to_1d(self.init_cash, raw=True)
            call_seq = to_2d(self.call_seq, raw=True)
            returns = nb.returns_in_sim_order_nb(value, group_lens, init_cash_grouped, call_seq)
        else:
            init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
            returns = nb.returns_nb(value, init_cash)
        return self.wrapper.wrap(returns, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def asset_returns(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get asset return series per column/group.

        This type of returns is based solely on cash flows and asset value rather than portfolio
        value. It ignores passive cash and thus it will return the same numbers irrespective of the amount of
        cash currently available, even `np.inf`. The scale of returns is comparable to that of going
        all in and keeping available cash at zero.&#34;&#34;&#34;
        cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
        asset_value = to_2d(self.asset_value(group_by=group_by), raw=True)
        asset_returns = nb.asset_returns_nb(cash_flow, asset_value)
        return self.wrapper.wrap(asset_returns, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def returns_acc(self,
                    group_by: tp.GroupByLike = None,
                    freq: tp.Optional[tp.FrequencyLike] = None,
                    year_freq: tp.Optional[tp.FrequencyLike] = None,
                    use_asset_returns: bool = False) -&gt; ReturnsAccessor:
        &#34;&#34;&#34;Get returns accessor of type `vectorbt.returns.accessors.ReturnsAccessor`.

        !!! hint
            You can find most methods of this accessor as (cacheable) attributes of this portfolio.&#34;&#34;&#34;
        if freq is None:
            freq = self.wrapper.freq
        if use_asset_returns:
            returns = self.asset_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
        return returns.vbt.returns(freq=freq, year_freq=year_freq)

    @cached_method
    def market_value(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get market (benchmark) value series per column/group.

        If grouped, evenly distributes the initial cash among assets in the group.

        !!! note
            Does not take into account fees and slippage. For this, create a separate portfolio.&#34;&#34;&#34;
        if self.fillna_close:
            close = to_2d(self.get_filled_close(), raw=True)
        else:
            close = to_2d(self.close, raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            init_cash_grouped = to_1d(self.get_init_cash(group_by=group_by), raw=True)
            market_value = nb.market_value_grouped_nb(close, group_lens, init_cash_grouped)
        else:
            init_cash = to_1d(self.get_init_cash(group_by=False), raw=True)
            market_value = nb.market_value_nb(close, init_cash)
        return self.wrapper.wrap(market_value, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def market_returns(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get return series per column/group based on market (benchmark) value.&#34;&#34;&#34;
        market_value = to_2d(self.market_value(group_by=group_by), raw=True)
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        market_returns = nb.returns_nb(market_value, init_cash)
        return self.wrapper.wrap(market_returns, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    benchmark_rets = market_returns

    @cached_method
    def total_market_return(self, group_by: tp.GroupByLike = None,
                            wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Get total market (benchmark) return.&#34;&#34;&#34;
        market_value = to_2d(self.market_value(group_by=group_by), raw=True)
        total_market_return = nb.total_market_return_nb(market_value)
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total_market_return&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(total_market_return, group_by=group_by, **wrap_kwargs)

    # ############# Stats ############# #

    @property
    def common_settings(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Return dictionary of most commonly used settings.

        * freq: Index frequency in case it cannot be parsed from `close`.
        * year_freq: Year frequency for annualization purposes.
        * incl_unrealized: Whether to include open trades/positions in statistics.
        * use_asset_returns: Whether to use `Portfolio.asset_returns` when resolving `returns` argument.
        * use_positions: Whether to use `Portfolio.positions` when resolving `trades` argument.
        * use_caching: Whether to use built-in caching for resolved arguments.

            Works even if global caching is disabled.&#34;&#34;&#34;
        from vectorbt._settings import settings
        portfolio_stats_cfg = settings[&#39;portfolio&#39;][&#39;stats&#39;]
        returns_stats_cfg = settings[&#39;returns&#39;]

        return dict(
            freq=self.wrapper.freq,
            year_freq=returns_stats_cfg[&#39;year_freq&#39;],
            incl_unrealized=portfolio_stats_cfg[&#39;incl_unrealized&#39;],
            use_asset_returns=portfolio_stats_cfg[&#39;use_asset_returns&#39;],
            use_positions=portfolio_stats_cfg[&#39;use_positions&#39;],
            use_caching=portfolio_stats_cfg[&#39;use_caching&#39;]
        )

    def resolve_attr(self,
                     attr: str,
                     args: tp.ArgsLike = None,
                     cond_kwargs: tp.KwargsLike = None,
                     kwargs: tp.KwargsLike = None,
                     custom_arg_names: tp.Optional[tp.Container[str]] = None,
                     cache_dct: tp.KwargsLike = None) -&gt; tp.Any:
        &#34;&#34;&#34;Resolve attribute of the portfolio using keyword arguments and built-in caching.

        * If `attr` is a property, simply returns it.
        * If `attr` is a method, passes `*args`, `**kwargs`, and `**cond_kwargs` with keys found in the signature.
        * If `attr` is a property and there is a `get_{arg}` method, calls the `get_{arg}` method.

        Won&#39;t cache if any passed argument is in `custom_arg_names`.&#34;&#34;&#34;
        # Resolve defaults
        if custom_arg_names is None:
            custom_arg_names = list()
        if cache_dct is None:
            cache_dct = {}
        if args is None:
            args = ()
        if kwargs is None:
            kwargs = {}
        final_kwargs = merge_dicts(self.common_settings, cond_kwargs, kwargs)

        # Resolve attribute
        if attr == &#39;returns&#39; and final_kwargs[&#39;use_asset_returns&#39;]:
            attr = &#39;asset_returns&#39;
        if attr == &#39;trades&#39; and final_kwargs[&#39;use_positions&#39;]:
            attr = &#39;positions&#39;
        cls = type(self)
        _attr = attr
        if &#39;get_&#39; + attr in dir(cls):
            _attr = &#39;get_&#39; + attr
        if callable(getattr(cls, _attr)):
            attr_func = getattr(self, _attr)
            attr_func_kwargs = dict()
            attr_func_arg_names = get_func_arg_names(attr_func)
            custom_k = False
            for k, v in final_kwargs.items():
                if k in attr_func_arg_names or k in kwargs:
                    if k in custom_arg_names:
                        custom_k = True
                    attr_func_kwargs[k] = v
            if final_kwargs[&#39;use_caching&#39;] and not custom_k and attr in cache_dct:
                out = cache_dct[attr]
            else:
                out = attr_func(*args, **attr_func_kwargs)
                if attr in [&#39;trades&#39;, &#39;positions&#39;, &#39;drawdowns&#39;]:
                    if self.wrapper.freq != final_kwargs[&#39;freq&#39;]:
                        out = out.copy(wrapper=out.wrapper.copy(freq=final_kwargs[&#39;freq&#39;]))
                if attr in [&#39;trades&#39;, &#39;positions&#39;] and not final_kwargs[&#39;incl_unrealized&#39;]:
                    out = out.closed
                if final_kwargs[&#39;use_caching&#39;] and not custom_k:
                    cache_dct[attr] = out
        else:
            if final_kwargs[&#39;use_caching&#39;] and attr in cache_dct:
                out = cache_dct[attr]
            else:
                out = getattr(self, _attr)
                if final_kwargs[&#39;use_caching&#39;]:
                    cache_dct[attr] = out
        return out

    metrics: tp.ClassVar[Config] = Config(
        dict(
            bt_start=dict(
                title=&#39;Start&#39;,
                calc_func=lambda pf: pf.wrapper.index[0]
            ),
            bt_end=dict(
                title=&#39;End&#39;,
                calc_func=lambda pf: pf.wrapper.index[-1]
            ),
            bt_duration=dict(
                title=&#39;Duration&#39;,
                calc_func=lambda pf, freq: len(pf.wrapper.index) * (freq if freq is not None else 1)
            ),
            init_cash=dict(
                title=&#39;Initial Cash&#39;,
                calc_func=lambda pf, group_by: pf.get_init_cash(group_by=group_by)
            ),
            total_profit=dict(
                title=&#39;Total Profit&#39;,
                calc_func=lambda pf, group_by: pf.total_profit(group_by=group_by)
            ),
            total_return=dict(
                title=&#39;Total Return [%]&#39;,
                calc_func=lambda pf, group_by: pf.total_return(group_by=group_by) * 100
            ),
            benchmark_return=dict(
                title=&#39;Benchmark Return [%]&#39;,
                calc_func=lambda benchmark_rets: benchmark_rets.vbt.returns.total() * 100
            ),
            pos_coverage=dict(
                title=&#39;Position Coverage [%]&#39;,
                calc_func=lambda pf, group_by: pf.position_coverage(group_by=group_by) * 100
            ),
            max_dd=dict(
                title=&#39;Max Drawdown [%]&#39;,
                calc_func=lambda drawdowns: -drawdowns.max_drawdown() * 100
            ),
            avg_dd=dict(
                title=&#39;Avg Drawdown [%]&#39;,
                calc_func=lambda drawdowns: -drawdowns.avg_drawdown() * 100
            ),
            max_dd_duration=dict(
                title=&#39;Max Drawdown Duration&#39;,
                calc_func=lambda drawdowns, freq: drawdowns.max_duration(
                    wrap_kwargs=dict(time_units=freq is not None))
            ),
            avg_dd_duration=dict(
                title=&#39;Avg Drawdown Duration&#39;,
                calc_func=lambda drawdowns, freq: drawdowns.avg_duration(
                    wrap_kwargs=dict(time_units=freq is not None))
            ),
            trade_cnt=dict(
                title=&#39;Trade Count&#39;,
                calc_func=lambda trades: trades.count()
            ),
            win_rate=dict(
                title=&#39;Win Rate [%]&#39;,
                calc_func=lambda trades: trades.win_rate() * 100
            ),
            best_trade=dict(
                title=&#39;Best Trade [%]&#39;,
                calc_func=lambda trades: trades.returns.max() * 100
            ),
            worst_trade=dict(
                title=&#39;Worst Trade [%]&#39;,
                calc_func=lambda trades: trades.returns.min() * 100
            ),
            avg_trade=dict(
                title=&#39;Avg Trade [%]&#39;,
                calc_func=lambda trades: trades.returns.mean() * 100
            ),
            max_trade_duration=dict(
                title=&#39;Max Trade Duration&#39;,
                calc_func=lambda trades, freq: trades.duration.max(
                    wrap_kwargs=dict(time_units=freq is not None))
            ),
            avg_trade_duration=dict(
                title=&#39;Avg Trade Duration&#39;,
                calc_func=lambda trades, freq: trades.duration.mean(
                    wrap_kwargs=dict(time_units=freq is not None))
            ),
            expectancy=dict(
                title=&#39;Expectancy&#39;,
                calc_func=lambda trades: trades.expectancy()
            ),
            sqn=dict(
                title=&#39;SQN&#39;,
                calc_func=lambda trades: trades.sqn()
            ),
            gross_exposure=dict(
                title=&#39;Gross Exposure&#39;,
                calc_func=lambda pf, group_by: pf.gross_exposure(group_by=group_by).mean()
            ),
            sharpe_ratio=dict(
                title=&#39;Sharpe Ratio&#39;,
                req_freq=True,
                calc_func=&#39;returns_acc.sharpe_ratio&#39;
            ),
            sortino_ratio=dict(
                title=&#39;Sortino Ratio&#39;,
                req_freq=True,
                calc_func=&#39;returns_acc.sortino_ratio&#39;
            ),
            calmar_ratio=dict(
                title=&#39;Calmar Ratio&#39;,
                req_freq=True,
                calc_func=&#39;returns_acc.calmar_ratio&#39;
            )
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )
    &#34;&#34;&#34;Metrics supported by `Portfolio.stats`.
    
    !!! note
        It&#39;s safe to change this config - this instance variable is a (deep) copy of the class variable.
        
        Copying portfolio using `Portfolio.copy` won&#39;t create a copy of the config!&#34;&#34;&#34;

    def stats(self,
              metrics: tp.Optional[tp.MaybeIterable[tp.Union[str, tp.Tuple[str, tp.Kwargs]]]] = None,
              column: tp.Optional[tp.Label] = None,
              group_by: tp.GroupByLike = None,
              agg_func: tp.Optional[tp.Callable] = np.mean,
              silence_warnings: tp.Optional[bool] = None,
              template_mapping: tp.Optional[tp.Mapping] = None,
              global_settings: tp.DictLike = None,
              **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Compute various metrics on this portfolio.

        Args:
            metrics (str, tuple, iterable, or dict): List of metrics to calculate.

                Each element can be either:

                * a metric name (see keys in `Portfolio.metrics`)
                * a tuple of a metric name and a settings dict as in `Portfolio.metrics`.

                Each settings dict can contain the following keys:

                * `title`: title of the metric. Defaults to the name.
                * `allow_grouped`: whether this metric supports using grouped data. Defaults to True.
                    Must be known beforehand and cannot be provided as a template.
                * `req_freq`: whether this metric requires frequency. Defaults to False.
                    Must be known beforehand and cannot be provided as a template.
                * `calc_func`: calculation function for custom metrics. If the function can be accessed
                    by traversing attributes of this portfolio, you can pass the path to this function
                    as a string (see `vectorbt.utils.attr.deep_getattr` for the path format).
                    Should return either a scalar for one column/group or pd.Series for multiple columns/groups.
                * `pass_{arg}`: whether to pass a reserved argument (see below). Defaults to True if
                    this argument was found in the function&#39;s signature. Set to False to not pass.
                * `glob_pass_{arg}`: whether to pass an argument from `global_settings`. Defaults to True if
                    this argument was found both in `global_settings` and the function&#39;s signature.
                    Set to False to not pass.
                * `resolve_{arg}`: whether to resolve an argument that is meant to be an attribute of
                    the portfolio (see `Portfolio.resolve_attr`). Defaults to True if this argument was found
                    in the function&#39;s signature. Set to False to not resolve.
                * `template_mapping`: mapping to replace templates in metric settings and keyword arguments.
                    Used across all settings.
                * Any other keyword argument overrides reserved arguments or is passed directly to `calc_func`.

                A calculation function may accept any keyword argument. It may &#34;request&#34; any of the
                following reserved arguments by accepting them or if `pass_{arg}` was found in the settings dict:

                * `pf` or `portfolio`: original portfolio (ungrouped and with no column selected)
                * `column`
                * `group_by`
                * `metric_name`
                * `agg_func`
                * Any argument from `Portfolio.common_settings`
                * Any attribute of the portfolio if it meant to be resolved (see `Portfolio.resolve_attr`)

                Pass `metrics=&#39;all&#39;` to calculate all supported metrics.
            column (str): Name of the column/group.

                !!! hint
                    There are two ways to select a column: `pf[&#39;a&#39;].stats()` and `pf.stats(column=&#39;a&#39;)`.
                    They both accomplish the same thing but in different ways: `pf[&#39;a&#39;].stats()` computes
                    statistics of the column &#39;a&#39; only, while `pf.stats(column=&#39;a&#39;)` computes statistics of
                    all columns first and only then selects the column &#39;a&#39;. The first method is preferred
                    when you have a lot of data or caching is disabled. The second method is preferred when
                    most attributes have already been cached.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            agg_func (callable): Aggregation function to aggregate statistics across all columns.
                Defaults to mean.

                Should take `pd.Series` and return a const.

                Has only effect if `column` was specified or portfolio contains only one column of data.
                If `agg_func` has been overridden by a metric, it only takes effect if global `agg_func` is not None.
            silence_warnings (bool): Whether to silence all warnings.
            template_mapping (mapping): Global mapping to replace templates.

                Applied on `Portfolio.common_settings`, `global_settings`, and `kwargs`.
            global_settings (dict): Keyword arguments that override default settings for each metric.
                Additionally, passes any argument that has the matching key in the signature of `calc_func`.
                Use `glob_pass_{arg}` to force or ignore passing an argument.
            **kwargs: Additional keyword arguments.

                Can contain keyword arguments for each metric, specified as `{metric_name}_kwargs`.
                Can also contain keyword arguments that override arguments from `Portfolio.common_settings`.

        For template logic, see `vectorbt.utils.template`.

        For defaults, see `portfolio.stats` in `vectorbt._settings.settings`.

        !!! hint
            This method is very similar to `Portfolio.plot`.

            Make sure to resolve and then to re-use as many portfolio artifcats as possible to
            utilize built-in caching (even if global caching is disabled).

        !!! note
            This method is not cacheable as it depends on global defaults.
            But the portfolio artifacts it depends on are cacheable.

        ## Example

        Let&#39;s simulate a portfolio with two columns:

        ```python-repl
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; close = vbt.YFData.download(
        ...     &#34;BTC-USD&#34;,
        ...     start=&#39;2020-01-01 UTC&#39;,
        ...     end=&#39;2020-09-01 UTC&#39;
        ... ).get(&#39;Close&#39;)

        &gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(close, n=[10, 20], seed=42)
        &gt;&gt;&gt; pf.wrapper.columns
        Int64Index([10, 20], dtype=&#39;int64&#39;, name=&#39;rand_n&#39;)
        ```

        To return the statistics for a particular column/group, use the `column` argument:

        ```python-repl
        &gt;&gt;&gt; pf.stats(column=10)
        UserWarning: Metrics {&#39;calmar_ratio&#39;, &#39;sharpe_ratio&#39;, &#39;sortino_ratio&#39;} require frequency of index.
        Pass it as `freq` or define it globally under `settings.array_wrapper`.

        Start                    2020-01-01 00:00:00+00:00
        End                      2020-09-01 00:00:00+00:00
        Duration                                       244
        Initial Cash                                   100
        Total Profit                               6.72158
        Total Return [%]                           6.72158
        Benchmark Return [%]                       66.2526
        Position Coverage [%]                      51.2295
        Max Drawdown [%]                           22.1909
        Avg Drawdown [%]                           5.86559
        Max Drawdown Duration                          101
        Avg Drawdown Duration                       26.125
        Trade Count                                     10
        Win Rate [%]                                    60
        Best Trade [%]                             15.3196
        Worst Trade [%]                           -9.90422
        Avg Trade [%]                             0.862693
        Max Trade Duration                              23
        Avg Trade Duration                            12.5
        Expectancy                                0.672158
        SQN                                       0.324787
        Gross Exposure                            0.512295
        Name: 10, dtype: object
        ```

        If vectorbt couldn&#39;t parse the frequency of our `close`, it 1) won&#39;t return duration in
        time units and 2) won&#39;t return metrics that require annualization. We can provide the frequency
        manually either upon portfolio simulation or here:

        ```python-repl
        &gt;&gt;&gt; pf.stats(column=10, freq=&#39;d&#39;)
        Start                    2020-01-01 00:00:00+00:00
        End                      2020-09-01 00:00:00+00:00
        Duration                         244 days 00:00:00
        Initial Cash                                   100
        Total Profit                               6.72158
        Total Return [%]                           6.72158
        Benchmark Return [%]                       66.2526
        Position Coverage [%]                      51.2295
        Max Drawdown [%]                           22.1909
        Avg Drawdown [%]                           5.86559
        Max Drawdown Duration            101 days 00:00:00
        Avg Drawdown Duration             26 days 03:00:00
        Trade Count                                     10
        Win Rate [%]                                    60
        Best Trade [%]                             15.3196
        Worst Trade [%]                           -9.90422
        Avg Trade [%]                             0.862693
        Max Trade Duration                23 days 00:00:00
        Avg Trade Duration                12 days 12:00:00
        Expectancy                                0.672158
        SQN                                       0.324787
        Gross Exposure                            0.512295
        Sharpe Ratio                              0.369947
        Sortino Ratio                             0.587442
        Calmar Ratio                              0.313166
        Name: 10, dtype: object
        ```

        We can change the grouping of the portfolio on the fly. Let&#39;s form a single group:

        ```python-repl
        &gt;&gt;&gt; pf.stats(group_by=True, freq=&#39;d&#39;)
        Start                     2020-01-01 00:00:00+00:00
        End                       2020-09-01 00:00:00+00:00
        Duration                          244 days 00:00:00
        Initial Cash                                    200
        Total Profit                                 77.493
        Total Return [%]                            38.7465
        Benchmark Return [%]                        66.2526
        Position Coverage [%]                       48.9754
        Max Drawdown [%]                            14.2193
        Avg Drawdown [%]                            5.34082
        Max Drawdown Duration              86 days 00:00:00
        Avg Drawdown Duration    16 days 14:46:09.230769231
        Trade Count                                      30
        Win Rate [%]                                66.6667
        Best Trade [%]                              18.3326
        Worst Trade [%]                            -9.90422
        Avg Trade [%]                               2.26356
        Max Trade Duration                 23 days 00:00:00
        Avg Trade Duration                  7 days 23:12:00
        Expectancy                                   2.5831
        SQN                                         1.70984
        Gross Exposure                             0.488308
        Sharpe Ratio                                1.31206
        Sortino Ratio                               2.15761
        Calmar Ratio                                2.83025
        Name: group, dtype: object
        ```

        We can see how the initial cash has changed from $100 to $200, indicating that both columns
        contribute to the performance.

        If the portfolio consists of multiple columns/groups and no column/group has been selected,
        each metric is aggregated across all columns/groups based on `agg_func`, which is mean by default.

        ```python-repl
        &gt;&gt;&gt; pf.stats(freq=&#39;d&#39;)
        Taking mean across columns. To return a DataFrame, pass agg_func=None.

        Start                    2020-01-01 00:00:00+00:00
        End                      2020-09-01 00:00:00+00:00
        Duration                         244 days 00:00:00
        Initial Cash                                   100
        Total Profit                               38.7465
        Total Return [%]                           38.7465
        Benchmark Return [%]                       66.2526
        Position Coverage [%]                      48.9754
        Max Drawdown [%]                           20.3587
        Avg Drawdown [%]                           6.85197
        Max Drawdown Duration             93 days 00:00:00
        Avg Drawdown Duration             24 days 01:30:00
        Trade Count                                     15
        Win Rate [%]                                    65
        Best Trade [%]                             16.8261
        Worst Trade [%]                           -9.70127
        Avg Trade [%]                              1.91334
        Max Trade Duration                21 days 12:00:00
        Avg Trade Duration                 9 days 02:24:00
        Expectancy                                 2.10536
        SQN                                        1.03975
        Gross Exposure                            0.489754
        Sharpe Ratio                              0.968587
        Sortino Ratio                              1.73209
        Calmar Ratio                               2.14818
        Name: stats_mean, dtype: object
        ```

        Here, the Calmar ratio of 0.313166 (column=10) and 3.98318 (column=20) lead to the avarage of 2.14818.

        We can also return a DataFrame with statistics per column/group by passing `agg_func=None`:

        ```python-repl
        &gt;&gt;&gt; pf.stats(agg_func=None, freq=&#39;d&#39;)
                                   Start                       End Duration  ...  Calmar Ratio
        rand_n                                                               ...
        10     2020-01-01 00:00:00+00:00 2020-09-01 00:00:00+00:00 244 days  ...      0.313166
        20     2020-01-01 00:00:00+00:00 2020-09-01 00:00:00+00:00 244 days  ...      3.983185

        [2 rows x 25 columns]
        ```

        To select metrics, use the `metrics` argument (see `Portfolio.metrics` for supported metrics):

        ```python-repl
        &gt;&gt;&gt; pf.stats(metrics=[&#39;sharpe_ratio&#39;, &#39;sortino_ratio&#39;], column=10, freq=&#39;d&#39;)
        Sharpe Ratio     0.369947
        Sortino Ratio    0.587442
        Name: stats, dtype: float64
        ```

        To calculate a custom metric, we need to provide at least two things: short name and a settings
        dict with the title and calculation function (see arguments):

        ```python-repl
        &gt;&gt;&gt; profit_factor = (
        ...     &#39;profit_factor&#39;,
        ...     dict(
        ...         title=&#39;Profit Factor&#39;,
        ...         calc_func=lambda trades: trades.profit_factor()
        ...     )
        ... )
        &gt;&gt;&gt; pf.stats(metrics=profit_factor, column=10, freq=&#39;d&#39;)
        Profit Factor    1.347457
        Name: stats, dtype: float64
        ```

        Since `profit_factor` method can be expressed as a path from this portfolio, we can simply write:

        ```python-repl
        &gt;&gt;&gt; profit_factor = (
        ...     &#39;profit_factor&#39;,
        ...     dict(
        ...         title=&#39;Profit Factor&#39;,
        ...         calc_func=&#39;trades.profit_factor&#39;
        ...     )
        ... )
        ```

        In both cases, `trades` argument is an attribute of this portfolio and vectorbt automatically &#34;resolves&#34; it
        by passing any reserved argument that was found in its signature, such as `group_by`.
        If we want to stop `trades` (or any other attribute) from being resolved, just pass `resolve_trades=False`.
        In this case, vectorbt would simply call `portfolio.get_trades()` and give it to us.

        Any default metric setting or even global setting can be overridden by the user using metric-specific
        keyword arguments. Here, we override the global aggregation function for `max_trade_duration`:

        ```python-repl
        &gt;&gt;&gt; pf.stats(freq=&#39;d&#39;, agg_func=lambda sr: sr.mean(),
        ...     max_trade_duration_kwargs=dict(agg_func=lambda sr: sr.max()))
        ```

        Let&#39;s create a simple metric that returns frequency to demonstrate how vectorbt overrides settings,
        from least to most important:

        ```python-repl
        &gt;&gt;&gt; # common_defaults
        &gt;&gt;&gt; freq_metric = (&#39;freq_metric&#39;, dict(title=&#39;Freq&#39;, calc_func=lambda freq: freq))
        &gt;&gt;&gt; pf.stats(freq_metric, column=10)
        Freq    None
        Name: 10, dtype: object

        &gt;&gt;&gt; # kwargs with keys from common_defaults &gt;&gt;&gt; common_defaults
        &gt;&gt;&gt; pf.stats(freq_metric, column=10, freq=&#39;1m&#39;)
        Freq   0 days 00:01:00
        Name: 10, dtype: timedelta64[ns]

        &gt;&gt;&gt; # metric settings &gt;&gt;&gt; kwargs with keys from common_defaults
        &gt;&gt;&gt; def_freq_metric = (&#39;freq_metric&#39;, dict(title=&#39;Freq&#39;, freq=&#39;2m&#39;, calc_func=lambda freq: freq))
        &gt;&gt;&gt; pf.stats(def_freq_metric, column=10, freq=&#39;1m&#39;)
        Freq   0 days 00:02:00
        Name: 10, dtype: timedelta64[ns]

        &gt;&gt;&gt; # global_settings &gt;&gt;&gt; metric settings
        &gt;&gt;&gt; pf.stats(def_freq_metric, column=10, freq=&#39;1m&#39;,
        ...     global_settings=dict(freq=&#39;3m&#39;))
        Freq   0 days 00:03:00
        Name: 10, dtype: timedelta64[ns]

        &gt;&gt;&gt; # metric kwargs &gt;&gt;&gt; global_settings
        &gt;&gt;&gt; pf.stats(def_freq_metric, column=10, freq=&#39;1m&#39;,
        ...     global_settings=dict(freq=&#39;3m&#39;), freq_metric_kwargs=dict(freq=&#39;4m&#39;))
        Freq   0 days 00:04:00
        Name: 10, dtype: timedelta64[ns]
        ```

        Here&#39;s an example of a parametrized metric. Let&#39;s get the number of trades with P&amp;L over some amount:

        ```python-repl
        &gt;&gt;&gt; trade_min_pnl_cnt = (
        ...     &#39;trade_min_pnl_cnt&#39;,
        ...     dict(
        ...         title=vbt.Sub(&#39;Trades with P&amp;L over $$${min_pnl}&#39;),
        ...         calc_func=lambda trades, min_pnl: trades.filter_by_mask(
        ...             trades.pnl.values &gt;= min_pnl).count()
        ...     )
        ... )
        &gt;&gt;&gt; pf.stats(
        ...     metrics=trade_min_pnl_cnt, column=10, freq=&#39;d&#39;,
        ...     trade_min_pnl_cnt_kwargs=dict(min_pnl=0))
        Trades with P&amp;L over $0    6
        Name: stats, dtype: int64

        &gt;&gt;&gt; pf.stats(
        ...     metrics=trade_min_pnl_cnt, column=10, freq=&#39;d&#39;,
        ...     trade_min_pnl_cnt_kwargs=dict(min_pnl=10))
        Trades with P&amp;L over $10    1
        Name: stats, dtype: int64
        ```

        If the same metric name was encountered more than once, vectorbt automatically appends an
        underscore and its position, so we can pass keyword arguments to each metric separately:

        ```python-repl
        &gt;&gt;&gt; pf.stats(
        ...     metrics=[
        ...         trade_min_pnl_cnt,
        ...         trade_min_pnl_cnt,
        ...         trade_min_pnl_cnt
        ...     ],
        ...     column=10, freq=&#39;d&#39;,
        ...     trade_min_pnl_cnt_0_kwargs=dict(min_pnl=0),
        ...     trade_min_pnl_cnt_1_kwargs=dict(min_pnl=10),
        ...     trade_min_pnl_cnt_2_kwargs=dict(min_pnl=20))
        Trades with P&amp;L over $0     6
        Trades with P&amp;L over $10    1
        Trades with P&amp;L over $20    0
        Name: stats, dtype: int64
        ```

        To add a custom metric to the list of all metrics, we have three options.
        First, we can change the `Portfolio.metrics` dict in-place (this will append to the end):

        ```python-repl
        &gt;&gt;&gt; pf.metrics[&#39;profit_factor&#39;] = profit_factor[1]
        &gt;&gt;&gt; pf.stats(column=10, freq=&#39;d&#39;)
        Start                    2020-01-01 00:00:00+00:00
        End                      2020-09-01 00:00:00+00:00
        Duration                         244 days 00:00:00
        Initial Cash                                   100
        Total Profit                               6.72158
        Total Return [%]                           6.72158
        Benchmark Return [%]                       66.2526
        Position Coverage [%]                      51.2295
        Max Drawdown [%]                           22.1909
        Avg Drawdown [%]                           5.86559
        Max Drawdown Duration            101 days 00:00:00
        Avg Drawdown Duration             26 days 03:00:00
        Trade Count                                     10
        Win Rate [%]                                    60
        Best Trade [%]                             15.3196
        Worst Trade [%]                           -9.90422
        Avg Trade [%]                             0.862693
        Max Trade Duration                23 days 00:00:00
        Avg Trade Duration                12 days 12:00:00
        Expectancy                                0.672158
        SQN                                       0.324787
        Gross Exposure                            0.512295
        Sharpe Ratio                              0.369947
        Sortino Ratio                             0.587442
        Calmar Ratio                              0.313166
        Profit Factor                              1.34746   &lt;&lt; here
        Name: stats, dtype: object
        ```

        Since `Portfolio.metrics` is of type `vectorbt.utils.config.Config`, we can reset it at any time
        to get default metrics:

        ```python-repl
        &gt;&gt;&gt; pf.metrics.reset()
        ```

        The second option is to copy `Portfolio.metrics`, append our metric, and pass as `metrics` argument:

        ```python-repl
        &gt;&gt;&gt; my_metrics = list(pf.metrics.items()) + [profit_factor]
        &gt;&gt;&gt; pf.stats(metrics=my_metrics, column=10, freq=&#39;d&#39;)
        ```

        The last option is to set `metrics` globally under `portfolio.stats` in `vectorbt._settings.settings`.

        &gt;&gt;&gt; vbt.settings[&#39;portfolio&#39;][&#39;stats&#39;][&#39;metrics&#39;] = my_metrics
        &gt;&gt;&gt; pf.stats(column=10, freq=&#39;d&#39;)
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        portfolio_stats_cfg = settings[&#39;portfolio&#39;][&#39;stats&#39;]

        # Resolve defaults
        common_settings = self.common_settings
        for k in list(kwargs.keys()):
            if k in common_settings:
                common_settings[k] = kwargs.pop(k)
        if silence_warnings is None:
            silence_warnings = portfolio_stats_cfg[&#39;silence_warnings&#39;]
        template_mapping = merge_dicts(portfolio_stats_cfg[&#39;template_mapping&#39;], template_mapping)
        global_settings = merge_dicts(portfolio_stats_cfg[&#39;global_settings&#39;], global_settings)
        kwargs = merge_dicts(portfolio_stats_cfg[&#39;kwargs&#39;], kwargs)

        # Check if grouped
        is_grouped = self.wrapper.grouper.is_grouped(group_by=group_by)

        # Check if frequency is set
        has_freq = common_settings[&#39;freq&#39;] is not None

        # Replace templates globally
        if len(template_mapping) &gt; 0:
            common_settings = deep_substitute(common_settings, mapping=template_mapping)
            global_settings = deep_substitute(global_settings, mapping=template_mapping)
            kwargs = deep_substitute(kwargs, mapping=template_mapping)

        # Prepare metrics
        if metrics is None:
            metrics = portfolio_stats_cfg[&#39;metrics&#39;]
        if metrics == &#39;all&#39;:
            metrics = self.metrics
        if isinstance(metrics, dict):
            metrics = list(metrics.items())
        if isinstance(metrics, (str, tuple)):
            metrics = [metrics]
        # Bring to the same shape
        new_metrics = []
        for i, metric in enumerate(metrics):
            if isinstance(metric, str):
                metric = (metric, self.metrics[metric])
            if not isinstance(metric, tuple):
                raise TypeError(f&#34;Metric at index {i} must be either a string or a tuple&#34;)
            new_metrics.append(metric)
        metrics = new_metrics
        # Handle duplicate names
        metric_counts = Counter(list(map(lambda x: x[0], metrics)))
        metric_i = {k: -1 for k in metric_counts.keys()}
        metrics_dct = {}
        for i, (metric_name, metric_settings) in enumerate(metrics):
            if metric_counts[metric_name] &gt; 1:
                metric_i[metric_name] += 1
                metric_name = metric_name + &#39;_&#39; + str(metric_i[metric_name])
            metrics_dct[metric_name] = metric_settings
        # Merge settings
        custom_arg_names_dct = {}
        for metric_name, metric_settings in metrics_dct.items():
            passed_settings = kwargs.pop(f&#39;{metric_name}_kwargs&#39;, {})
            metrics_dct[metric_name] = merge_dicts(
                metric_settings,
                global_settings,
                passed_settings
            )
            custom_arg_names_dct[metric_name] = set(metric_settings.keys()).union(set(passed_settings.keys()))
        # Filter metrics
        if is_grouped:
            left_out_names = []
            for metric_name in list(metrics_dct.keys()):
                if not metrics_dct[metric_name].get(&#39;allow_grouped&#39;, True):
                    metrics_dct.pop(metric_name, None)
                    custom_arg_names_dct.pop(metric_name, None)
                    left_out_names.append(metric_name)
            if len(left_out_names) &gt; 0 and not silence_warnings:
                warnings.warn(f&#34;Metrics {left_out_names} do not support grouped data&#34;, stacklevel=2)
        if not has_freq:
            left_out_names = []
            for metric_name in list(metrics_dct.keys()):
                if metrics_dct[metric_name].get(&#39;req_freq&#39;, False):
                    metrics_dct.pop(metric_name, None)
                    custom_arg_names_dct.pop(metric_name, None)
                    left_out_names.append(metric_name)
            if len(left_out_names) &gt; 0 and not silence_warnings:
                warnings.warn(f&#34;Metrics {left_out_names} require frequency of index. &#34;
                              f&#34;Pass it as `freq` or define it globally under `settings.array_wrapper`.&#34;, stacklevel=2)
        if len(metrics_dct) == 0:
            raise ValueError(&#34;There is no metric to calculate&#34;)

        # Check kwargs
        if len(kwargs) &gt; 0:
            raise ValueError(f&#34;Keys {list(kwargs.keys())} could not be matched&#34;)

        # Run stats
        arg_cache_dct = {}
        stats_dct = {}
        for i, (metric_name, metric_settings) in enumerate(metrics_dct.items()):
            final_settings = metric_settings.copy()
            final_settings.pop(&#39;allow_grouped&#39;, None)
            final_settings.pop(&#39;req_freq&#39;, None)

            # Replace templates
            reserved_settings = merge_dicts(
                dict(
                    pf=self,
                    portfolio=self,
                    column=column,
                    group_by=group_by,
                    metric_name=metric_name,
                    agg_func=agg_func
                ),
                common_settings
            )
            reserved_arg_names = set(reserved_settings.keys())
            final_settings = merge_dicts(reserved_settings, final_settings)
            metric_template_mapping = final_settings.pop(&#39;template_mapping&#39;, {})
            mapping = merge_dicts(final_settings, template_mapping, metric_template_mapping)
            final_settings = deep_substitute(final_settings, mapping=mapping)
            if final_settings[&#39;freq&#39;] is not None:
                final_settings[&#39;freq&#39;] = freq_to_timedelta(final_settings[&#39;freq&#39;])

            # Get and pop values
            _column = final_settings.get(&#39;column&#39;)
            _group_by = final_settings.get(&#39;group_by&#39;)
            _agg_func = final_settings.get(&#39;agg_func&#39;)
            title = final_settings.pop(&#39;title&#39;, metric_name)
            calc_func = final_settings.pop(&#39;calc_func&#39;)

            # Prepare function and keyword arguments
            custom_arg_names = custom_arg_names_dct[metric_name]
            if not callable(calc_func):
                def _getattr_func(obj: tp.Any,
                                  attr: str,
                                  args: tp.ArgsLike = None,
                                  kwargs: tp.KwargsLike = None,
                                  call_attr: bool = True,
                                  _custom_arg_names: tp.Set[str] = custom_arg_names,
                                  _arg_cache_dct: tp.Kwargs = arg_cache_dct,
                                  _final_settings: tp.Kwargs = final_settings) -&gt; tp.Any:
                    if args is None:
                        args = ()
                    if kwargs is None:
                        kwargs = {}
                    if obj is self and _final_settings.pop(&#39;resolve_&#39; + attr, True):
                        if call_attr:
                            return self.resolve_attr(
                                attr,
                                args=args,
                                cond_kwargs=_final_settings,
                                kwargs=kwargs,
                                custom_arg_names=_custom_arg_names,
                                cache_dct=_arg_cache_dct
                            )
                        return getattr(obj, attr)
                    out = getattr(obj, attr)
                    if callable(out) and call_attr:
                        return out(*args, **kwargs)
                    return out

                calc_func = self.getattr(calc_func, getattr_func=_getattr_func, call_last_attr=False)
            if not callable(calc_func):
                raise TypeError(&#34;calc_func must be callable&#34;)

            func_arg_names = get_func_arg_names(calc_func)
            for k in func_arg_names:
                if k not in final_settings:
                    if final_settings.pop(&#39;resolve_&#39; + k, True):
                        try:
                            arg_out = self.resolve_attr(
                                k,
                                cond_kwargs=final_settings,
                                custom_arg_names=custom_arg_names,
                                cache_dct=arg_cache_dct
                            )
                        except AttributeError:
                            continue
                        final_settings[k] = arg_out

            for k in reserved_arg_names:
                if &#39;pass_&#39; + k in final_settings:
                    if not final_settings.pop(&#39;pass_&#39; + k):  # first priority
                        final_settings.pop(k, None)
                elif k not in func_arg_names:  # second priority
                    final_settings.pop(k, None)
            for k in list(final_settings.keys()):
                if &#39;glob_pass_&#39; + k in final_settings:
                    if k not in global_settings or not final_settings.pop(&#39;glob_pass_&#39; + k, True):
                        final_settings.pop(k, None)  # global setting should not be utilized
                else:
                    if k in global_settings and k not in custom_arg_names and k not in func_arg_names:
                        final_settings.pop(k, None)  # global setting not utilized
            for k in list(final_settings.keys()):
                if k.startswith(&#39;glob_pass_&#39;):
                    final_settings.pop(k, None)  # cleanup

            # Call calculation function
            out = calc_func(**final_settings)

            # Post-process and store the metric
            if checks.is_any_array(out) and not checks.is_series(out):
                raise TypeError(&#34;calc_func must return either a scalar for one column/group &#34;
                                &#34;or pd.Series for multiple columns/groups&#34;)
            if checks.is_series(out):
                if _column is not None:
                    out = self.select_one_from_obj(out, self.wrapper.regroup(_group_by), column=_column)
                elif _agg_func is not None and agg_func is not None:
                    out = _agg_func(out)
            stats_dct[title] = out

        # Return the stats
        if self.wrapper.get_ndim(group_by=group_by) == 1:
            return pd.Series(stats_dct, name=self.wrapper.get_columns(group_by=group_by)[0])
        if column is not None:
            return pd.Series(stats_dct, name=column)
        if agg_func is not None:
            return pd.Series(stats_dct, name=&#39;agg_func_&#39; + agg_func.__name__)
        new_index = self.wrapper.grouper.get_columns(group_by=group_by)
        stats_df = pd.DataFrame(stats_dct, index=new_index)
        return stats_df

    def returns_stats(self,
                      column: tp.Optional[tp.Label] = None,
                      group_by: tp.GroupByLike = None,
                      use_asset_returns: bool = False,
                      in_sim_order: bool = False,
                      agg_func: tp.Optional[tp.Callable] = np.mean,
                      year_freq: tp.Optional[tp.FrequencyLike] = None,
                      **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Compute various statistics on returns of this portfolio.

        For keyword arguments and notes, see `Portfolio.stats`.

        `kwargs` will be passed to `vectorbt.returns.accessors.ReturnsAccessor.stats` method.
        If `benchmark_rets` is not set, uses `Portfolio.market_returns`.&#34;&#34;&#34;
        # Pre-calculate
        if use_asset_returns:
            returns = self.asset_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)

        # Run stats
        if &#39;benchmark_rets&#39; not in kwargs:
            kwargs[&#39;benchmark_rets&#39;] = self.market_returns(group_by=group_by)
        stats_obj = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq).stats(**kwargs)

        # Select columns or reduce
        if checks.is_series(stats_obj):
            return stats_obj
        if column is not None:
            return stats_obj.loc[column]
        if agg_func is not None:
            if agg_func == np.mean:
                warnings.warn(&#34;Taking mean across columns. To return a DataFrame, pass agg_func=None.&#34;, stacklevel=2)
                func_name = &#39;stats_mean&#39;
            else:
                func_name = &#39;stats_&#39; + agg_func.__name__
            agg_stats_sr = pd.Series(index=stats_obj.columns, name=func_name)
            agg_stats_sr.iloc[:3] = stats_obj.iloc[0, :3]
            agg_stats_sr.iloc[3:] = agg_func(stats_obj.iloc[:, 3:])
            return agg_stats_sr
        return stats_obj

    # ############# Plotting ############# #

    def plot_asset_flow(self,
                        column: tp.Optional[tp.Label] = None,
                        direction: str = &#39;all&#39;,
                        xref: str = &#39;x&#39;,
                        yref: str = &#39;y&#39;,
                        hline_shape_kwargs: tp.KwargsLike = None,
                        **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column of asset flow.

        Args:
            column (str): Name of the column to plot.
            direction (Direction): See `vectorbt.portfolio.enums.Direction`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.plot`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;brown&#39;]
                ),
                name=&#39;Assets&#39;
            )
        ), kwargs)
        asset_flow = self.asset_flow(direction=direction)
        asset_flow = self.select_one_from_obj(asset_flow, self.wrapper.regroup(False), column=column)
        fig = asset_flow.vbt.plot(**kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=0,
            x1=x_domain[1],
            y1=0
        ), hline_shape_kwargs))
        return fig

    def plot_cash_flow(self,
                       column: tp.Optional[tp.Label] = None,
                       group_by: tp.GroupByLike = None,
                       free: bool = False,
                       xref: str = &#39;x&#39;,
                       yref: str = &#39;y&#39;,
                       hline_shape_kwargs: tp.KwargsLike = None,
                       **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of cash flow.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            free (bool): Whether to plot the flow of the free cash.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.plot`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;green&#39;]
                ),
                name=&#39;Cash&#39;
            )
        ), kwargs)
        cash_flow = self.cash_flow(group_by=group_by, free=free)
        cash_flow = self.select_one_from_obj(cash_flow, self.wrapper.regroup(group_by), column=column)
        fig = cash_flow.vbt.plot(**kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=0.,
            x1=x_domain[1],
            y1=0.
        ), hline_shape_kwargs))
        return fig

    def plot_assets(self,
                    column: tp.Optional[tp.Label] = None,
                    direction: str = &#39;all&#39;,
                    xref: str = &#39;x&#39;,
                    yref: str = &#39;y&#39;,
                    hline_shape_kwargs: tp.KwargsLike = None,
                    **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column of assets.

        Args:
            column (str): Name of the column to plot.
            direction (Direction): See `vectorbt.portfolio.enums.Direction`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;brown&#39;]
                ),
                name=&#39;Assets&#39;
            ),
            pos_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;brown&#39;], 0.3)
            ),
            neg_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;orange&#39;], 0.3)
            ),
            other_trace_kwargs=&#39;hidden&#39;
        ), kwargs)
        assets = self.assets(direction=direction)
        assets = self.select_one_from_obj(assets, self.wrapper.regroup(False), column=column)
        fig = assets.vbt.plot_against(0, **kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=0.,
            x1=x_domain[1],
            y1=0.
        ), hline_shape_kwargs))
        return fig

    def plot_cash(self,
                  column: tp.Optional[tp.Label] = None,
                  group_by: tp.GroupByLike = None,
                  free: bool = False,
                  xref: str = &#39;x&#39;,
                  yref: str = &#39;y&#39;,
                  hline_shape_kwargs: tp.KwargsLike = None,
                  **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of cash balance.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            free (bool): Whether to plot the flow of the free cash.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;green&#39;]
                ),
                name=&#39;Cash&#39;
            ),
            pos_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;green&#39;], 0.3)
            ),
            neg_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;red&#39;], 0.3)
            ),
            other_trace_kwargs=&#39;hidden&#39;
        ), kwargs)
        init_cash = self.get_init_cash(group_by=group_by)
        init_cash = self.select_one_from_obj(init_cash, self.wrapper.regroup(group_by), column=column)
        cash = self.cash(group_by=group_by, free=free)
        cash = self.select_one_from_obj(cash, self.wrapper.regroup(group_by), column=column)
        fig = cash.vbt.plot_against(init_cash, **kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=init_cash,
            x1=x_domain[1],
            y1=init_cash
        ), hline_shape_kwargs))
        return fig

    def plot_asset_value(self,
                         column: tp.Optional[tp.Label] = None,
                         group_by: tp.GroupByLike = None,
                         direction: str = &#39;all&#39;,
                         xref: str = &#39;x&#39;,
                         yref: str = &#39;y&#39;,
                         hline_shape_kwargs: tp.KwargsLike = None,
                         **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of asset value.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            direction (Direction): See `vectorbt.portfolio.enums.Direction`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;cyan&#39;]
                ),
                name=&#39;Asset Value&#39;
            ),
            pos_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;cyan&#39;], 0.3)
            ),
            neg_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;orange&#39;], 0.3)
            ),
            other_trace_kwargs=&#39;hidden&#39;
        ), kwargs)
        asset_value = self.asset_value(direction=direction, group_by=group_by)
        asset_value = self.select_one_from_obj(asset_value, self.wrapper.regroup(group_by), column=column)
        fig = asset_value.vbt.plot_against(0, **kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=0.,
            x1=x_domain[1],
            y1=0.
        ), hline_shape_kwargs))
        return fig

    def plot_value(self,
                   column: tp.Optional[tp.Label] = None,
                   group_by: tp.GroupByLike = None,
                   xref: str = &#39;x&#39;,
                   yref: str = &#39;y&#39;,
                   hline_shape_kwargs: tp.KwargsLike = None,
                   **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of value.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            free (bool): Whether to plot free cash flow.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;purple&#39;]
                ),
                name=&#39;Value&#39;
            ),
            other_trace_kwargs=&#39;hidden&#39;
        ), kwargs)
        init_cash = self.get_init_cash(group_by=group_by)
        init_cash = self.select_one_from_obj(init_cash, self.wrapper.regroup(group_by), column=column)
        value = self.value(group_by=group_by)
        value = self.select_one_from_obj(value, self.wrapper.regroup(group_by), column=column)
        fig = value.vbt.plot_against(init_cash, **kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=init_cash,
            x1=x_domain[1],
            y1=init_cash
        ), hline_shape_kwargs))
        return fig

    def plot_cum_returns(self,
                         column: tp.Optional[tp.Label] = None,
                         group_by: tp.GroupByLike = None,
                         asset_returns: bool = False,
                         **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of cumulative returns.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            asset_returns (bool): Whether to plot asset returns.
            **kwargs: Keyword arguments passed to `vectorbt.returns.accessors.ReturnsSRAccessor.plot_cum_returns`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        market_returns = self.market_returns(group_by=group_by)
        market_returns = self.select_one_from_obj(market_returns, self.wrapper.regroup(group_by), column=column)
        kwargs = merge_dicts(dict(
            benchmark_rets=market_returns,
            main_kwargs=dict(
                trace_kwargs=dict(
                    line=dict(
                        color=plotting_cfg[&#39;color_schema&#39;][&#39;purple&#39;]
                    ),
                    name=&#39;Value&#39;
                )
            ),
            hline_shape_kwargs=dict(
                type=&#39;line&#39;,
                line=dict(
                    color=&#39;gray&#39;,
                    dash=&#34;dash&#34;,
                )
            )
        ), kwargs)
        if asset_returns:
            returns = self.asset_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
        returns = self.select_one_from_obj(returns, self.wrapper.regroup(group_by), column=column)
        return returns.vbt.returns.plot_cum_returns(**kwargs)

    def plot_drawdowns(self,
                       column: tp.Optional[tp.Label] = None,
                       group_by: tp.GroupByLike = None,
                       **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of drawdowns.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            **kwargs: Keyword arguments passed to `vectorbt.generic.drawdowns.Drawdowns.plot`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            ts_trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;purple&#39;]
                ),
                name=&#39;Value&#39;
            )
        ), kwargs)
        return self.get_drawdowns(group_by=group_by).plot(column=column, **kwargs)

    def plot_underwater(self,
                        column: tp.Optional[tp.Label] = None,
                        group_by: tp.GroupByLike = None,
                        xref: str = &#39;x&#39;,
                        yref: str = &#39;y&#39;,
                        hline_shape_kwargs: tp.KwargsLike = None,
                        **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of underwater.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.plot`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;red&#39;]
                ),
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;red&#39;], 0.3),
                fill=&#39;tozeroy&#39;,
                name=&#39;Drawdown&#39;
            )
        ), kwargs)
        drawdown = self.drawdown(group_by=group_by)
        drawdown = self.select_one_from_obj(drawdown, self.wrapper.regroup(group_by), column=column)
        fig = drawdown.vbt.plot(**kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=0,
            x1=x_domain[1],
            y1=0
        ), hline_shape_kwargs))
        yaxis = &#39;yaxis&#39; + yref[1:]
        fig.layout[yaxis][&#39;tickformat&#39;] = &#39;%&#39;
        return fig

    def plot_gross_exposure(self,
                            column: tp.Optional[tp.Label] = None,
                            group_by: tp.GroupByLike = None,
                            direction: str = &#39;all&#39;,
                            xref: str = &#39;x&#39;,
                            yref: str = &#39;y&#39;,
                            hline_shape_kwargs: tp.KwargsLike = None,
                            **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of gross exposure.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            direction (Direction): See `vectorbt.portfolio.enums.Direction`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;pink&#39;]
                ),
                name=&#39;Exposure&#39;
            ),
            pos_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;orange&#39;], 0.3)
            ),
            neg_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;pink&#39;], 0.3)
            ),
            other_trace_kwargs=&#39;hidden&#39;
        ), kwargs)
        gross_exposure = self.gross_exposure(direction=direction, group_by=group_by)
        gross_exposure = self.select_one_from_obj(gross_exposure, self.wrapper.regroup(group_by), column=column)
        fig = gross_exposure.vbt.plot_against(1, **kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=1,
            x1=x_domain[1],
            y1=1
        ), hline_shape_kwargs))
        return fig

    def plot_net_exposure(self,
                          column: tp.Optional[tp.Label] = None,
                          group_by: tp.GroupByLike = None,
                          xref: str = &#39;x&#39;,
                          yref: str = &#39;y&#39;,
                          hline_shape_kwargs: tp.KwargsLike = None,
                          **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of net exposure.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;pink&#39;]
                ),
                name=&#39;Exposure&#39;
            ),
            pos_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;pink&#39;], 0.3)
            ),
            neg_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;orange&#39;], 0.3)
            ),
            other_trace_kwargs=&#39;hidden&#39;
        ), kwargs)
        net_exposure = self.net_exposure(group_by=group_by)
        net_exposure = self.select_one_from_obj(net_exposure, self.wrapper.regroup(group_by), column=column)
        fig = net_exposure.vbt.plot_against(0, **kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=0,
            x1=x_domain[1],
            y1=0
        ), hline_shape_kwargs))
        return fig

    subplots: tp.ClassVar[Config] = Config(
        dict(
            orders=dict(
                title=&#34;Orders&#34;,
                yaxis_title=&#34;Price&#34;,
                allow_grouped=False,
                plot_func=[(&#39;get_orders&#39;, (Rep(&#39;group_by&#39;),)), &#39;plot&#39;]
            ),
            trades=dict(
                title=&#34;Trades&#34;,
                yaxis_title=&#34;Price&#34;,
                allow_grouped=False,
                plot_func=[(&#39;get_trades&#39;, (Rep(&#39;group_by&#39;),)), &#39;plot&#39;]
            ),
            positions=dict(
                title=&#34;Positions&#34;,
                yaxis_title=&#34;Price&#34;,
                allow_grouped=False,
                plot_func=[(&#39;get_positions&#39;, (Rep(&#39;group_by&#39;),)), &#39;plot&#39;]
            ),
            trade_pnl=dict(
                title=&#34;Trade P&amp;L&#34;,
                yaxis_title=&#34;Trade P&amp;L&#34;,
                allow_grouped=False,
                plot_func=[(&#39;get_trades&#39;, (Rep(&#39;group_by&#39;),)), &#39;plot_pnl&#39;],
                pass_column=True,  # hidden behind **kwargs
                pass_hline_shape_kwargs=True,  # hidden behind **kwargs
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
                pass_xref=True,  # hidden behind **kwargs
                pass_yref=True  # hidden behind **kwargs
            ),
            position_pnl=dict(
                title=&#34;Position P&amp;L&#34;,
                yaxis_title=&#34;Position P&amp;L&#34;,
                allow_grouped=False,
                plot_func=[(&#39;get_positions&#39;, (Rep(&#39;group_by&#39;),)), &#39;plot_pnl&#39;],
                pass_column=True,  # hidden behind **kwargs
                pass_hline_shape_kwargs=True,  # hidden behind **kwargs
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
                pass_xref=True,  # hidden behind **kwargs
                pass_yref=True  # hidden behind **kwargs
            ),
            trade_returns=dict(
                title=&#34;Trade Returns&#34;,
                yaxis_title=&#34;Trade returns&#34;,
                allow_grouped=False,
                plot_func=[(&#39;get_trades&#39;, (Rep(&#39;group_by&#39;),)), &#39;plot_returns&#39;],
                pass_column=True,  # hidden behind **kwargs
                pass_hline_shape_kwargs=True,  # hidden behind **kwargs
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
                pass_xref=True,  # hidden behind **kwargs
                pass_yref=True  # hidden behind **kwargs
            ),
            position_returns=dict(
                title=&#34;Position Returns&#34;,
                yaxis_title=&#34;Position returns&#34;,
                allow_grouped=False,
                plot_func=[(&#39;get_positions&#39;, (Rep(&#39;group_by&#39;),)), &#39;plot_returns&#39;],
                pass_column=True,  # hidden behind **kwargs
                pass_hline_shape_kwargs=True,  # hidden behind **kwargs
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
                pass_xref=True,  # hidden behind **kwargs
                pass_yref=True  # hidden behind **kwargs
            ),
            asset_flow=dict(
                title=&#34;Asset Flow&#34;,
                yaxis_title=&#34;Asset flow&#34;,
                allow_grouped=False,
                plot_func=&#39;plot_asset_flow&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            cash_flow=dict(
                title=&#34;Cash Flow&#34;,
                yaxis_title=&#34;Cash flow&#34;,
                plot_func=&#39;plot_cash_flow&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            assets=dict(
                title=&#34;Assets&#34;,
                yaxis_title=&#34;Assets&#34;,
                allow_grouped=False,
                plot_func=&#39;plot_assets&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            cash=dict(
                title=&#34;Cash&#34;,
                yaxis_title=&#34;Cash&#34;,
                plot_func=&#39;plot_cash&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            asset_value=dict(
                title=&#34;Asset Value&#34;,
                yaxis_title=&#34;Asset value&#34;,
                plot_func=&#39;plot_asset_value&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            value=dict(
                title=&#34;Value&#34;,
                yaxis_title=&#34;Value&#34;,
                plot_func=&#39;plot_value&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            cum_returns=dict(
                title=&#34;Cumulative Returns&#34;,
                yaxis_title=&#34;Cumulative returns&#34;,
                plot_func=&#39;plot_cum_returns&#39;,
                pass_hline_shape_kwargs=True,  # hidden behind **kwargs
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
                pass_xref=True,  # hidden behind **kwargs
                pass_yref=True  # hidden behind **kwargs
            ),
            drawdowns=dict(
                title=&#34;Drawdowns&#34;,
                yaxis_title=&#34;Value&#34;,
                plot_func=&#39;plot_drawdowns&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
                pass_xref=True,  # hidden behind **kwargs
                pass_yref=True  # hidden behind **kwargs
            ),
            underwater=dict(
                title=&#34;Underwater&#34;,
                yaxis_title=&#34;Drawdown&#34;,
                plot_func=&#39;plot_underwater&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            gross_exposure=dict(
                title=&#34;Gross Exposure&#34;,
                yaxis_title=&#34;Gross exposure&#34;,
                plot_func=&#39;plot_gross_exposure&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            net_exposure=dict(
                title=&#34;Net Exposure&#34;,
                yaxis_title=&#34;Net exposure&#34;,
                plot_func=&#39;plot_net_exposure&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            )
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )
    &#34;&#34;&#34;Subplots supported by `Portfolio.plot`.
    
    !!! note
        It&#39;s safe to change this config - this instance variable is a (deep) copy of the class variable.
        
        Copying portfolio using `Portfolio.copy` won&#39;t create a copy of the config!&#34;&#34;&#34;

    def plot(self,
             subplots: tp.Optional[tp.MaybeIterable[tp.Union[str, tp.Tuple[str, tp.Kwargs]]]] = None,
             column: tp.Optional[tp.Label] = None,
             group_by: tp.GroupByLike = None,
             show_titles: bool = None,
             hide_id_labels: bool = None,
             group_id_labels: bool = None,
             make_subplots_kwargs: tp.KwargsLike = None,
             hline_shape_kwargs: tp.KwargsLike = None,
             silence_warnings: bool = None,
             template_mapping: tp.Optional[tp.Mapping] = None,
             **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
        &#34;&#34;&#34;Plot various parts of this portfolio.

        Args:
            subplots (str, tuple, iterable, or dict): List of subplots to plot.

                Each element can be either:

                * a subplot name (see keys in `Portfolio.subplots`)
                * a tuple of a subplot name and a settings dict as in `Portfolio.subplots`.

                Each settings dict can contain the following keys:

                * `title`: title of the subplot. Defaults to None.
                * `yaxis_title`: title of the y-axis. Defaults to `title`.
                * `xaxis_title`: title of the x-axis. Defaults to &#39;Date&#39;.
                * `allow_grouped`: whether this subplot supports grouped data. Defaults to True.
                    Must be known beforehand and cannot be provided as a template.
                * `plot_func`: plotting function for custom subplots. If the function can be accessed
                    by traversing attributes of this portfolio, you can pass the path to this function
                    as a string (see `vectorbt.utils.attr.deep_getattr` for the path format).
                * `pass_{arg}`: whether to pass a reserved argument (see below). Defaults to True if
                    this argument was found in the function&#39;s signature. Set to False to not pass.
                * `template_mapping`: mapping to replace templates in subplot settings and keyword arguments.
                    Used across all settings.
                * Any other keyword argument overrides reserved arguments or is passed directly to `plot_func`.

                A plotting function may accept any keyword argument, but it should accept the current figure via
                a `fig` keyword argument. It may also &#34;request&#34; any of the following reserved arguments by
                accepting them or if `pass_{arg}` was found in the settings dict:

                * `portfolio`: original portfolio (ungrouped and with no column selected)
                * `column`
                * `group_by`
                * `subplot_name`
                * `trace_names`: list with the subplot name
                * `add_trace_kwargs`
                * `xref`
                * `yref`
                * `xaxis`
                * `yaxis`
                * `x_domain`
                * `y_domain`
                * `hline_shape_kwargs`

                Pass `subplots=&#39;all&#39;` to plot all supported subplots.
            column (str): Name of the column/group to plot.

                Won&#39;t have effect on this portfolio, but passed down to each plotting function.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.

                Won&#39;t have effect on this portfolio, but passed down to each plotting function.
            show_titles (bool): Whether to show the title of each subplot.
            hide_id_labels (bool): Whether to hide identical legend labels.

                Two labels are identical if their name, marker style and line style match.
            group_id_labels (bool): Whether to group identical legend labels.
            make_subplots_kwargs (dict): Keyword arguments passed to `plotly.subplots.make_subplots`.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            silence_warnings (bool): Whether to silence all warnings.
            template_mapping (mapping): Global mapping to replace templates.

                Applied on both subplot settings and `kwargs`.
            **kwargs: Additional keyword arguments.

                Can contain keyword arguments for each subplot, specified as `{subplot_name}_kwargs`.
                Other keyword arguments are used to update the layout of the figure.

        For template logic, see `vectorbt.utils.template`.

        For defaults, see `portfolio.plot` in `vectorbt._settings.settings`.

        !!! hint
            This method is very similar to `Portfolio.stats`.

        ## Example

        Plot portfolio of a random strategy:

        ```python-repl
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; close = vbt.YFData.download(
        ...     &#34;BTC-USD&#34;,
        ...     start=&#39;2020-01-01 UTC&#39;,
        ...     end=&#39;2020-09-01 UTC&#39;
        ... ).get(&#39;Close&#39;)

        &gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(close, n=10, seed=42)
        &gt;&gt;&gt; pf.plot()
        ```

        ![](/vectorbt/docs/img/portfolio_plot.svg)

        You can choose any of the subplots in `Portfolio.subplots`, in any order, and
        control their appearance using keyword arguments:

        ```python-repl
        &gt;&gt;&gt; from vectorbt.utils.colors import adjust_opacity

        &gt;&gt;&gt; pf.plot(
        ...     subplots=[&#39;drawdowns&#39;, &#39;underwater&#39;],
        ...     drawdowns_kwargs=dict(top_n=3),
        ...     underwater_kwargs=dict(
        ...         trace_kwargs=dict(
        ...             line=dict(color=&#39;#FF6F00&#39;),
        ...             fillcolor=adjust_opacity(&#39;#FF6F00&#39;, 0.3)
        ...         )
        ...     )
        ... )
        ```

        ![](/vectorbt/docs/img/portfolio_plot_drawdowns.svg)

        To create a new subplot, a preferred way is to pass a plotting function:

        ```python-repl
        &gt;&gt;&gt; def plot_order_size(size, add_trace_kwargs=None, fig=None):
        ...     size.rename(&#39;Order Size&#39;).vbt.barplot(
        ...         add_trace_kwargs=add_trace_kwargs, fig=fig)

        &gt;&gt;&gt; order_size = pf.orders.size.to_pd(default_val=0.)
        &gt;&gt;&gt; pf.plot(subplots=[
        ...     &#39;orders&#39;,
        ...     (&#39;order_size&#39;, dict(
        ...         title=&#39;Order Size&#39;,
        ...         yaxis_title=&#39;Order size&#39;,
        ...         allow_grouped=False,
        ...         plot_func=plot_order_size
        ...     ))
        ... ], order_size_kwargs=dict(size=order_size))
        ```

        Alternatively, you can create a placeholder and overwrite it manually later:

        ```python-repl
        &gt;&gt;&gt; fig = pf.plot(subplots=[
        ...     &#39;orders&#39;,
        ...     (&#39;order_size&#39;, dict(
        ...         title=&#39;Order Size&#39;,
        ...         yaxis_title=&#39;Order size&#39;,
        ...         allow_grouped=False
        ...     ))  # placeholder
        ... ])
        &gt;&gt;&gt; order_size.rename(&#39;Order Size&#39;).vbt.barplot(
        ...     add_trace_kwargs=dict(row=2, col=1), fig=fig)
        ```

        ![](/vectorbt/docs/img/portfolio_plot_custom.svg)

        If a plotting function can in any way be accessed from the current portfolio, you can pass
        the path to this function (see `vectorbt.utils.attr.deep_getattr` for the path format).
        You can additionally use templates to make some parameters to depend upon passed keyword arguments:

        ```python-repl
        &gt;&gt;&gt; subplots = [
        ...     (&#39;cumulative_returns&#39;, dict(
        ...         title=&#39;Cumulative Returns&#39;,
        ...         yaxis_title=&#39;Cumulative returns&#39;,
        ...         plot_func=&#39;returns.vbt.returns.cumulative.vbt.plot&#39;,
        ...         pass_add_trace_kwargs=True  # hidden behind **kwargs in vbt.plot
        ...     )),
        ...     (&#39;rolling_drawdown&#39;, dict(
        ...         title=&#39;Rolling Drawdown&#39;,
        ...         yaxis_title=&#39;Rolling drawdown&#39;,
        ...         plot_func=[
        ...             &#39;returns.vbt.returns&#39;,  # returns accessor
        ...             (
        ...                 &#39;rolling_max_drawdown&#39;,  # function name
        ...                 (vbt.Rep(&#39;window&#39;),)),  # positional arguments
        ...             &#39;vbt.plot&#39;  # plotting function
        ...         ],
        ...         pass_add_trace_kwargs=True,
        ...         trace_names=[vbt.Sub(&#39;rolling_drawdown(${window})&#39;)],  # add window to the trace name
        ...     ))
        ... ]
        &gt;&gt;&gt; pf.plot(subplots, rolling_drawdown_kwargs=dict(template_mapping=dict(window=10)))
        ```

        You can also replace templates across all subplots by using the global template mapping:

        ```python-repl
        &gt;&gt;&gt; pf.plot(subplots, template_mapping=dict(window=10))
        ```

        ![](/vectorbt/docs/img/portfolio_plot_path.svg)
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]
        portfolio_plot_cfg = settings[&#39;portfolio&#39;][&#39;plot&#39;]

        # Resolve defaults
        if show_titles is None:
            show_titles = portfolio_plot_cfg[&#39;show_titles&#39;]
        if hide_id_labels is None:
            hide_id_labels = portfolio_plot_cfg[&#39;hide_id_labels&#39;]
        if group_id_labels is None:
            group_id_labels = portfolio_plot_cfg[&#39;group_id_labels&#39;]
        if silence_warnings is None:
            silence_warnings = portfolio_plot_cfg[&#39;silence_warnings&#39;]
        make_subplots_kwargs = merge_dicts(portfolio_plot_cfg[&#39;make_subplots_kwargs&#39;], make_subplots_kwargs)
        template_mapping = merge_dicts(portfolio_plot_cfg[&#39;template_mapping&#39;], template_mapping)
        hline_shape_kwargs = merge_dicts(portfolio_plot_cfg[&#39;hline_shape_kwargs&#39;], hline_shape_kwargs)
        kwargs = merge_dicts(portfolio_plot_cfg[&#39;kwargs&#39;], kwargs)

        # Check if grouped
        is_grouped = self.wrapper.grouper.is_grouped(group_by=group_by)

        # Replace templates globally
        if len(template_mapping) &gt; 0:
            kwargs = deep_substitute(kwargs, mapping=template_mapping)

        # Prepare subplots
        if subplots is None:
            subplots = portfolio_plot_cfg[&#39;subplots&#39;]
            if is_grouped:
                grouped_subplots = portfolio_plot_cfg[&#39;grouped_subplots&#39;]
                if grouped_subplots is None:
                    grouped_subplots = subplots
                subplots = grouped_subplots
        if subplots == &#39;all&#39;:
            subplots = self.subplots
        if isinstance(subplots, dict):
            subplots = list(subplots.items())
        if isinstance(subplots, (str, tuple)):
            subplots = [subplots]
        # Bring to the same shape
        new_subplots = []
        for i, subplot in enumerate(subplots):
            if isinstance(subplot, str):
                subplot = (subplot, self.subplots[subplot])
            if not isinstance(subplot, tuple):
                raise TypeError(f&#34;Subplot at index {i} must be either a string or a tuple&#34;)
            new_subplots.append(subplot)
        subplots = new_subplots
        # Handle duplicate names
        subplot_counts = Counter(list(map(lambda x: x[0], subplots)))
        subplot_i = {k: -1 for k in subplot_counts.keys()}
        new_subplots = []
        for i, (name, settings) in enumerate(subplots):
            if subplot_counts[name] &gt; 1:
                subplot_i[name] += 1
                name = name + &#39;_&#39; + str(subplot_i[name])
            new_subplots.append((name, settings))
        subplots = new_subplots
        # Merge settings
        new_subplots = []
        for i, subplot in enumerate(subplots):
            subplot = (subplot[0], merge_dicts(subplot[1], kwargs.pop(f&#39;{subplot[0]}_kwargs&#39;, {})))
            new_subplots.append(subplot)
        subplots = new_subplots
        # Filter subplots
        if is_grouped:
            def _filter_grouped(subplot: tp.Tuple[str, tp.Kwargs]) -&gt; bool:
                if &#39;allow_grouped&#39; not in subplot[1]:
                    return True
                if subplot[1][&#39;allow_grouped&#39;]:
                    return True
                return False

            new_subplots = list(filter(_filter_grouped, subplots))
            left_out_names = set(map(lambda x: x[0], subplots)).difference(set(map(lambda x: x[0], new_subplots)))
            if len(left_out_names) &gt; 0 and not silence_warnings:
                warnings.warn(f&#34;Subplots {left_out_names} do not support grouped data&#34;, stacklevel=2)
            subplots = new_subplots
        if len(subplots) == 0:
            raise ValueError(&#34;There is no subplot to plot&#34;)

        # Set up figure
        rows = make_subplots_kwargs.pop(&#39;rows&#39;, len(subplots))
        cols = make_subplots_kwargs.pop(&#39;cols&#39;, 1)
        specs = make_subplots_kwargs.pop(&#39;specs&#39;, [[{} for _ in range(cols)] for _ in range(rows)])
        row_col_tuples = []
        for row, row_spec in enumerate(specs):
            for col, col_spec in enumerate(row_spec):
                if col_spec is not None:
                    row_col_tuples.append((row + 1, col + 1))
        shared_xaxes = make_subplots_kwargs.pop(&#39;shared_xaxes&#39;, True)
        shared_yaxes = make_subplots_kwargs.pop(&#39;shared_yaxes&#39;, False)
        default_height = plotting_cfg[&#39;layout&#39;][&#39;height&#39;]
        default_width = plotting_cfg[&#39;layout&#39;][&#39;width&#39;] + 50
        min_space = 10  # space between subplots with no axis sharing
        max_title_spacing = 30
        max_xaxis_spacing = 50
        max_yaxis_spacing = 100
        legend_height = 50
        if show_titles:
            title_spacing = max_title_spacing
        else:
            title_spacing = 0
        if not shared_xaxes and rows &gt; 1:
            xaxis_spacing = max_xaxis_spacing
        else:
            xaxis_spacing = 0
        if not shared_yaxes and cols &gt; 1:
            yaxis_spacing = max_yaxis_spacing
        else:
            yaxis_spacing = 0
        if &#39;height&#39; in kwargs:
            height = kwargs.pop(&#39;height&#39;)
        else:
            height = default_height + title_spacing
            if rows &gt; 1:
                height *= rows
                height += min_space * rows - min_space
                height += legend_height - legend_height * rows
                if shared_xaxes:
                    height += max_xaxis_spacing - max_xaxis_spacing * rows
        if &#39;width&#39; in kwargs:
            width = kwargs.pop(&#39;width&#39;)
        else:
            width = default_width
            if cols &gt; 1:
                width *= cols
                width += min_space * cols - min_space
                if shared_yaxes:
                    width += max_yaxis_spacing - max_yaxis_spacing * cols
        if height is not None:
            if &#39;vertical_spacing&#39; in make_subplots_kwargs:
                vertical_spacing = make_subplots_kwargs.pop(&#39;vertical_spacing&#39;)
            else:
                vertical_spacing = min_space + title_spacing + xaxis_spacing
            if vertical_spacing is not None and vertical_spacing &gt; 1:
                vertical_spacing /= height
            legend_y = 1 + (min_space + title_spacing) / height
        else:
            vertical_spacing = make_subplots_kwargs.pop(&#39;vertical_spacing&#39;, None)
            legend_y = 1.02
        if width is not None:
            if &#39;horizontal_spacing&#39; in make_subplots_kwargs:
                horizontal_spacing = make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;)
            else:
                horizontal_spacing = min_space + yaxis_spacing
            if horizontal_spacing is not None and horizontal_spacing &gt; 1:
                horizontal_spacing /= width
        else:
            horizontal_spacing = make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;, None)
        if show_titles:
            _subplot_titles = []
            for name in subplots:
                _subplot_titles.append(name[1].get(&#39;title&#39;, None))
        else:
            _subplot_titles = None
        fig = make_subplots(
            rows=rows,
            cols=cols,
            specs=specs,
            shared_xaxes=shared_xaxes,
            shared_yaxes=shared_yaxes,
            subplot_titles=_subplot_titles,
            vertical_spacing=vertical_spacing,
            horizontal_spacing=horizontal_spacing,
            **make_subplots_kwargs
        )
        kwargs = merge_dicts(dict(
            width=width,
            height=height,
            legend=dict(
                orientation=&#34;h&#34;,
                yanchor=&#34;bottom&#34;,
                y=legend_y,
                xanchor=&#34;right&#34;,
                x=1,
                traceorder=&#39;normal&#39;
            )
        ), kwargs)
        fig.update_layout(**kwargs)  # final destination for kwargs

        # Show subplots
        for i, (name, settings) in enumerate(subplots):
            _settings = settings.copy()
            _settings.pop(&#39;allow_grouped&#39;, None)

            # Compute figure artifacts
            row, col = row_col_tuples[i]
            xref = &#39;x&#39; if i == 0 else &#39;x&#39; + str(i + 1)
            yref = &#39;y&#39; if i == 0 else &#39;y&#39; + str(i + 1)
            xaxis = &#39;xaxis&#39; + xref[1:]
            yaxis = &#39;yaxis&#39; + yref[1:]
            x_domain = get_domain(xref, fig)
            y_domain = get_domain(yref, fig)

            # Replace templates
            default_settings = dict(
                portfolio=self,
                column=column,
                group_by=group_by,
                subplot_name=name,
                trace_names=[name],
                add_trace_kwargs=dict(row=row, col=col),
                xref=xref,
                yref=yref,
                xaxis=xaxis,
                yaxis=yaxis,
                x_domain=x_domain,
                y_domain=y_domain,
                hline_shape_kwargs=hline_shape_kwargs,
                fig=fig
            )
            reserved_args = list(default_settings.keys())
            reserved_args.remove(&#39;fig&#39;)
            _settings = merge_dicts(default_settings, _settings)
            subplot_template_mapping = _settings.pop(&#39;template_mapping&#39;, {})
            mapping = merge_dicts(_settings, template_mapping, subplot_template_mapping)
            _settings = deep_substitute(_settings, mapping=mapping)

            # Pop values
            plot_func = _settings.pop(&#39;plot_func&#39;, None)
            xaxis_title = _settings.pop(&#39;xaxis_title&#39;, &#39;Date&#39;)
            yaxis_title = _settings.pop(&#39;yaxis_title&#39;, _settings.pop(&#39;title&#39;, None))

            # Prepare function and keyword arguments
            if plot_func is not None:
                if not callable(plot_func):
                    plot_func = self.getattr(plot_func, call_last_attr=False)
                if not callable(plot_func):
                    raise TypeError(&#34;plot_func must be callable&#34;)
                func_arg_names = get_func_arg_names(plot_func)
                for k in reserved_args:
                    if &#39;pass_&#39; + k in _settings:
                        if not _settings.pop(&#39;pass_&#39; + k):  # first priority
                            del _settings[k]
                    elif k not in func_arg_names:  # second priority
                        _settings.pop(k, None)

                # Call plotting function
                plot_func(**_settings)

            # Update global layout
            fig.layout[xaxis][&#39;title&#39;] = xaxis_title
            fig.layout[yaxis][&#39;title&#39;] = yaxis_title

        # Remove duplicate legend labels
        found_ids = dict()
        unique_idx = 0
        for trace in fig.data:
            if &#39;name&#39; in trace:
                name = trace[&#39;name&#39;]
            else:
                name = None
            if &#39;marker&#39; in trace:
                marker = trace[&#39;marker&#39;]
            else:
                marker = {}
            if &#39;symbol&#39; in marker:
                marker_symbol = marker[&#39;symbol&#39;]
            else:
                marker_symbol = None
            if &#39;color&#39; in marker:
                marker_color = marker[&#39;color&#39;]
            else:
                marker_color = None
            if &#39;line&#39; in trace:
                line = trace[&#39;line&#39;]
            else:
                line = {}
            if &#39;dash&#39; in line:
                line_dash = line[&#39;dash&#39;]
            else:
                line_dash = None
            if &#39;color&#39; in line:
                line_color = line[&#39;color&#39;]
            else:
                line_color = None

            id = (name, marker_symbol, marker_color, line_dash, line_color)
            if id in found_ids:
                if hide_id_labels:
                    trace[&#39;showlegend&#39;] = False
                if group_id_labels:
                    trace[&#39;legendgroup&#39;] = found_ids[id]
            else:
                if group_id_labels:
                    trace[&#39;legendgroup&#39;] = unique_idx
                found_ids[id] = unique_idx
                unique_idx += 1

        # Remove all except the last title if sharing the same axis
        if shared_xaxes:
            i = 0
            for row in range(rows):
                for col in range(cols):
                    if specs[row][col] is not None:
                        xaxis = &#39;xaxis&#39; if i == 0 else &#39;xaxis&#39; + str(i + 1)
                        if row &lt; rows - 1:
                            fig.layout[xaxis][&#39;title&#39;] = None
                        i += 1
        if shared_yaxes:
            i = 0
            for row in range(rows):
                for col in range(cols):
                    if specs[row][col] is not None:
                        yaxis = &#39;yaxis&#39; if i == 0 else &#39;yaxis&#39; + str(i + 1)
                        if col &gt; 0:
                            fig.layout[yaxis][&#39;title&#39;] = None
                        i += 1

        return fig</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.portfolio.base.add_returns_methods"><code class="name flex">
<span>def <span class="ident">add_returns_methods</span></span>(<span>func_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Class decorator to add <code><a title="vectorbt.returns.accessors.ReturnsAccessor" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor">ReturnsAccessor</a></code> methods to <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_returns_methods(func_names: tp.Iterable[tp.Union[str, tp.Tuple[str, str]]]) -&gt; WrapperFuncT:
    &#34;&#34;&#34;Class decorator to add `vectorbt.returns.accessors.ReturnsAccessor` methods to `Portfolio`.&#34;&#34;&#34;

    def wrapper(cls: tp.Type[tp.T]) -&gt; tp.Type[tp.T]:
        for func_name in func_names:
            if isinstance(func_name, tuple):
                ret_func_name = func_name[0]
            else:
                ret_func_name = func_name

            def returns_method(
                    self: &#34;Portfolio&#34;,
                    *args,
                    group_by: tp.GroupByLike = None,
                    freq: tp.Optional[tp.FrequencyLike] = None,
                    year_freq: tp.Optional[tp.FrequencyLike] = None,
                    _ret_func_name: str = ret_func_name,
                    use_asset_returns: bool = False,
                    **ret_func_kwargs) -&gt; tp.Any:
                returns_acc = self.returns_acc(
                    group_by=group_by,
                    freq=freq,
                    year_freq=year_freq,
                    use_asset_returns=use_asset_returns
                )
                # Select only those arguments in kwargs that are also in the method&#39;s signature
                # This is done for Portfolio.stats which passes the same kwargs to multiple methods
                method = getattr(returns_acc, _ret_func_name)
                arg_names = get_func_arg_names(method)
                new_kwargs = {}
                for arg_name in arg_names:
                    if arg_name in ret_func_kwargs:
                        new_kwargs[arg_name] = ret_func_kwargs[arg_name]
                return method(*args, **new_kwargs)

            if isinstance(func_name, tuple):
                func_name = func_name[1]
            returns_method.__name__ = func_name
            returns_method.__qualname__ = f&#34;{cls.__name__}.{func_name}&#34;
            returns_method.__doc__ = f&#34;See `vectorbt.returns.accessors.ReturnsAccessor.{ret_func_name}`.&#34;
            setattr(cls, func_name, cached_method(returns_method))
        return cls

    return wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio"><code class="flex name class">
<span>class <span class="ident">Portfolio</span></span>
<span>(</span><span>wrapper, close, order_records, log_records, init_cash, cash_sharing, call_seq, fillna_close=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for modeling portfolio and measuring its performance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrapper</code></strong> :&ensp;<code>ArrayWrapper</code></dt>
<dd>
<p>Array wrapper.</p>
<p>See <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</p>
</dd>
<dt><strong><code>close</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Last asset price at each time step.</dd>
<dt><strong><code>order_records</code></strong> :&ensp;<code>array_like</code></dt>
<dd>A structured NumPy array of order records.</dd>
<dt><strong><code>log_records</code></strong> :&ensp;<code>array_like</code></dt>
<dd>A structured NumPy array of log records.</dd>
<dt><strong><code>init_cash</code></strong> :&ensp;<code>InitCashMode, float</code> or <code>array_like</code> of <code>float</code></dt>
<dd>Initial capital.</dd>
<dt><strong><code>cash_sharing</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to share cash within the same group.</dd>
<dt><strong><code>call_seq</code></strong> :&ensp;<code>array_like</code> of <code>int</code></dt>
<dd>Sequence of calls per row and group.</dd>
<dt><strong><code>fillna_close</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to forward and backward fill NaN values in <code>close</code>.</p>
<p>Applied after the simulation to avoid NaNs in asset value.</p>
<p>See <code><a title="vectorbt.portfolio.base.Portfolio.get_filled_close" href="#vectorbt.portfolio.base.Portfolio.get_filled_close">Portfolio.get_filled_close()</a></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use class methods with <code>from_</code> prefix to build a portfolio.
The <code>__init__</code> method is reserved for indexing purposes.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is meant to be immutable. To change any attribute, use <code><a title="vectorbt.portfolio.base.Portfolio.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">Configured.copy()</a></code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Portfolio(Wrapping):
    &#34;&#34;&#34;Class for modeling portfolio and measuring its performance.

    Args:
        wrapper (ArrayWrapper): Array wrapper.

            See `vectorbt.base.array_wrapper.ArrayWrapper`.
        close (array_like): Last asset price at each time step.
        order_records (array_like): A structured NumPy array of order records.
        log_records (array_like): A structured NumPy array of log records.
        init_cash (InitCashMode, float or array_like of float): Initial capital.
        cash_sharing (bool): Whether to share cash within the same group.
        call_seq (array_like of int): Sequence of calls per row and group.
        fillna_close (bool): Whether to forward and backward fill NaN values in `close`.

            Applied after the simulation to avoid NaNs in asset value.

            See `Portfolio.get_filled_close`.

    !!! note
        Use class methods with `from_` prefix to build a portfolio.
        The `__init__` method is reserved for indexing purposes.

    !!! note
        This class is meant to be immutable. To change any attribute, use `Portfolio.copy`.&#34;&#34;&#34;

    writeable_attrs: tp.ClassVar[tp.List[str]] = [&#39;metrics&#39;, &#39;subplots&#39;]
    &#34;&#34;&#34;List of writeable attributes that will be saved/copied along with the config.&#34;&#34;&#34;

    def __init__(self,
                 wrapper: ArrayWrapper,
                 close: tp.ArrayLike,
                 order_records: tp.RecordArray,
                 log_records: tp.RecordArray,
                 init_cash: tp.ArrayLike,
                 cash_sharing: bool,
                 call_seq: tp.Array2d,
                 fillna_close: tp.Optional[bool] = None) -&gt; None:
        Wrapping.__init__(
            self,
            wrapper,
            close=close,
            order_records=order_records,
            log_records=log_records,
            init_cash=init_cash,
            cash_sharing=cash_sharing,
            call_seq=call_seq,
            fillna_close=fillna_close
        )
        # Get defaults
        from vectorbt._settings import settings
        portfolio_cfg = settings[&#39;portfolio&#39;]

        if fillna_close is None:
            fillna_close = portfolio_cfg[&#39;fillna_close&#39;]

        # Store passed arguments
        self._close = broadcast_to(close, wrapper.dummy(group_by=False))
        self._order_records = order_records
        self._log_records = log_records
        self._init_cash = init_cash
        self._cash_sharing = cash_sharing
        self._call_seq = call_seq
        self._fillna_close = fillna_close

        # Copy dicts
        self.metrics = self.__class__.metrics.copy()
        self.subplots = self.__class__.subplots.copy()

    def indexing_func(self: PortfolioT, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; PortfolioT:
        &#34;&#34;&#34;Perform indexing on `Portfolio`.&#34;&#34;&#34;
        new_wrapper, _, group_idxs, col_idxs = \
            self.wrapper.indexing_func_meta(pd_indexing_func, column_only_select=True, **kwargs)
        new_close = new_wrapper.wrap(to_2d(self.close, raw=True)[:, col_idxs], group_by=False)
        new_order_records = self.orders.get_by_col_idxs(col_idxs)
        new_log_records = self.logs.get_by_col_idxs(col_idxs)
        if isinstance(self._init_cash, int):
            new_init_cash = self._init_cash
        else:
            new_init_cash = to_1d(self._init_cash, raw=True)[group_idxs if self.cash_sharing else col_idxs]
        new_call_seq = self.call_seq.values[:, col_idxs]

        return self.copy(
            wrapper=new_wrapper,
            close=new_close,
            order_records=new_order_records,
            log_records=new_log_records,
            init_cash=new_init_cash,
            call_seq=new_call_seq
        )

    # ############# Class methods ############# #

    @classmethod
    def from_holding(cls: tp.Type[PortfolioT], close: tp.ArrayLike, **kwargs) -&gt; PortfolioT:
        &#34;&#34;&#34;Simulate portfolio from holding.

        Based on `Portfolio.from_signals`.&#34;&#34;&#34;
        return cls.from_signals(close, True, False, accumulate=False, **kwargs)

    @classmethod
    def from_random_signals(cls: tp.Type[PortfolioT],
                            close: tp.ArrayLike,
                            n: tp.Optional[tp.ArrayLike] = None,
                            prob: tp.Optional[tp.ArrayLike] = None,
                            entry_prob: tp.Optional[tp.ArrayLike] = None,
                            exit_prob: tp.Optional[tp.ArrayLike] = None,
                            param_product: bool = False,
                            seed: tp.Optional[int] = None,
                            run_kwargs: tp.KwargsLike = None,
                            **kwargs) -&gt; PortfolioT:
        &#34;&#34;&#34;Simulate portfolio from random entry and exit signals.

        Generates signals based either on the number of signals `n` or the probability
        of encountering a signal `prob`.

        If `n` is set, see `vectorbt.signals.generators.RAND`.
        If `prob` is set, see `vectorbt.signals.generators.RPROB`.

        Based on `Portfolio.from_signals`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        portfolio_cfg = settings[&#39;portfolio&#39;]

        close = to_pd_array(close)
        if entry_prob is None:
            entry_prob = prob
        if exit_prob is None:
            exit_prob = prob
        if seed is None:
            seed = portfolio_cfg[&#39;seed&#39;]
        if run_kwargs is None:
            run_kwargs = {}

        if n is not None and (entry_prob is not None or exit_prob is not None):
            raise ValueError(&#34;Either n or entry_prob and exit_prob should be set&#34;)
        if n is not None:
            rand = RAND.run(
                n=n,
                input_shape=close.shape,
                input_index=close.vbt.wrapper.index,
                input_columns=close.vbt.wrapper.columns,
                seed=seed,
                **run_kwargs
            )
            entries = rand.entries
            exits = rand.exits
        elif entry_prob is not None and exit_prob is not None:
            rprob = RPROB.run(
                entry_prob=entry_prob,
                exit_prob=exit_prob,
                param_product=param_product,
                input_shape=close.shape,
                input_index=close.vbt.wrapper.index,
                input_columns=close.vbt.wrapper.columns,
                seed=seed,
                **run_kwargs
            )
            entries = rprob.entries
            exits = rprob.exits
        else:
            raise ValueError(&#34;At least n or entry_prob and exit_prob should be set&#34;)

        return cls.from_signals(close, entries, exits, seed=seed, **kwargs)

    @classmethod
    def from_signals(cls: tp.Type[PortfolioT],
                     close: tp.ArrayLike,
                     entries: tp.Optional[tp.ArrayLike] = None,
                     exits: tp.Optional[tp.ArrayLike] = None,
                     size: tp.Optional[tp.ArrayLike] = None,
                     size_type: tp.Optional[tp.ArrayLike] = None,
                     direction: tp.Optional[tp.ArrayLike] = None,
                     price: tp.Optional[tp.ArrayLike] = None,
                     fees: tp.Optional[tp.ArrayLike] = None,
                     fixed_fees: tp.Optional[tp.ArrayLike] = None,
                     slippage: tp.Optional[tp.ArrayLike] = None,
                     min_size: tp.Optional[tp.ArrayLike] = None,
                     max_size: tp.Optional[tp.ArrayLike] = None,
                     reject_prob: tp.Optional[tp.ArrayLike] = None,
                     lock_cash: tp.Optional[tp.ArrayLike] = None,
                     allow_partial: tp.Optional[tp.ArrayLike] = None,
                     raise_reject: tp.Optional[tp.ArrayLike] = None,
                     log: tp.Optional[tp.ArrayLike] = None,
                     accumulate: tp.Optional[tp.ArrayLike] = None,
                     conflict_mode: tp.Optional[tp.ArrayLike] = None,
                     close_first: tp.Optional[tp.ArrayLike] = None,
                     val_price: tp.Optional[tp.ArrayLike] = None,
                     open: tp.Optional[tp.ArrayLike] = None,
                     high: tp.Optional[tp.ArrayLike] = None,
                     low: tp.Optional[tp.ArrayLike] = None,
                     sl_stop: tp.Optional[tp.ArrayLike] = None,
                     sl_trail: tp.Optional[tp.ArrayLike] = None,
                     tp_stop: tp.Optional[tp.ArrayLike] = None,
                     stop_entry_price: tp.Optional[tp.ArrayLike] = None,
                     stop_exit_price: tp.Optional[tp.ArrayLike] = None,
                     stop_conflict_mode: tp.Optional[tp.ArrayLike] = None,
                     stop_exit_mode: tp.Optional[tp.ArrayLike] = None,
                     stop_update_mode: tp.Optional[tp.ArrayLike] = None,
                     adjust_sl_func_nb: nb.AdjustSLFuncT = nb.no_adjust_sl_func_nb,
                     adjust_sl_args: tp.Args = (),
                     adjust_tp_func_nb: nb.AdjustTPFuncT = nb.no_adjust_tp_func_nb,
                     adjust_tp_args: tp.Args = (),
                     use_stops: tp.Optional[bool] = None,
                     init_cash: tp.Optional[tp.ArrayLike] = None,
                     cash_sharing: tp.Optional[bool] = None,
                     call_seq: tp.Optional[tp.ArrayLike] = None,
                     ffill_val_price: tp.Optional[bool] = None,
                     update_value: tp.Optional[bool] = None,
                     max_orders: tp.Optional[int] = None,
                     max_logs: tp.Optional[int] = None,
                     seed: tp.Optional[int] = None,
                     group_by: tp.GroupByLike = None,
                     broadcast_kwargs: tp.KwargsLike = None,
                     wrapper_kwargs: tp.KwargsLike = None,
                     freq: tp.Optional[tp.FrequencyLike] = None,
                     **kwargs) -&gt; PortfolioT:
        &#34;&#34;&#34;Simulate portfolio from entry and exit signals.

        Args:
            close (array_like): See `Portfolio.from_orders`.
            entries (array_like of bool): Boolean array of entry signals.
                Defaults to True. Will broadcast.

                Becomes a long signal if `direction` is `all` or `longonly`, otherwise short.
            exits (array_like of bool): Boolean array of exit signals.
                Defaults to False. Will broadcast.

                Becomes a short signal if `direction` is `all` or `longonly`, otherwise long.
            size (float or array_like): See `Portfolio.from_orders`.

                !!! note
                    Negative size is not allowed. You should express direction using signals.
            size_type (SizeType or array_like): See `Portfolio.from_orders`.

                Only `SizeType.Amount`, `SizeType.Value`, and `SizeType.Percent` are supported.
                Other modes such as target percentage are not compatible with signals since
                their logic may contradict the direction of the signal.

                !!! note
                    `SizeType.Percent` does not support position reversal. Switch to a single
                    direction or use `close_first`.

                See warning in `Portfolio.from_orders`.
            direction (Direction or array_like): See `Portfolio.from_orders`.
            price (array_like of float): See `Portfolio.from_orders`.
            fees (float or array_like): See `Portfolio.from_orders`.
            fixed_fees (float or array_like): See `Portfolio.from_orders`.
            slippage (float or array_like): See `Portfolio.from_orders`.
            min_size (float or array_like): See `Portfolio.from_orders`.
            max_size (float or array_like): See `Portfolio.from_orders`.

                Will be partially filled if exceeded. You might not be able to properly close
                the position if accumulation is enabled and `max_size` is too low.
            reject_prob (float or array_like): See `Portfolio.from_orders`.
            lock_cash (bool or array_like): See `Portfolio.from_orders`.
            allow_partial (bool or array_like): See `Portfolio.from_orders`.
            raise_reject (bool or array_like): See `Portfolio.from_orders`.
            log (bool or array_like): See `Portfolio.from_orders`.
            accumulate (bool or array_like): Whether to accumulate signals.
                Will broadcast.

                Allows gradually increasing and decreasing positions using `size`.
                When enabled, `Portfolio.from_signals` behaves like `Portfolio.from_orders`.
            conflict_mode (ConflictMode or array_like): See `vectorbt.portfolio.enums.ConflictMode`.
                Will broadcast.
            close_first (bool or array_like): Whether to close the position first before reversal.
                Will broadcast.

                Otherwise reverses the position with a single order and within the same tick.
                Takes only effect under `Direction.All`. Requires a second signal to enter
                the opposite position. This allows to define parameters such as `fixed_fees` for long
                and short positions separately.
            val_price (array_like of float): See `Portfolio.from_orders`.
            open (array_like of float): First asset price at each time step.
                Defaults to `np.nan`, which gets replaced by `close`. Will broadcast.

                Used solely for stop signals.
            high (array_like of float): Highest asset price at each time step.
                Defaults to `np.nan`, which gets replaced by the maximum out of `open` and `close`. Will broadcast.

                Used solely for stop signals.
            low (array_like of float): Lowest asset price at each time step.
                Defaults to `np.nan`, which gets replaced by the minimum out of `open` and `close`. Will broadcast.

                Used solely for stop signals.
            sl_stop (array_like of float): Stop loss.
                Will broadcast.

                A percentage below/above the acquisition price for long/short position.
                Note that 0.01 = 1%.
            sl_trail (array_like of bool): Whether `sl_stop` should be trailing.
                Will broadcast.
            tp_stop (array_like of float): Take profit.
                Will broadcast.

                A percentage above/below the acquisition price for long/short position.
                Note that 0.01 = 1%.
            stop_entry_price (StopEntryPrice or array_like): See `vectorbt.portfolio.enums.StopEntryPrice`.
                Will broadcast.

                If provided on per-element basis, gets applied upon entry.
            stop_exit_price (StopExitPrice or array_like): See `vectorbt.portfolio.enums.StopExitPrice`.
                Will broadcast.

                If provided on per-element basis, gets applied upon exit.
            stop_conflict_mode (StopConflictMode or array_like): See `vectorbt.portfolio.enums.StopConflictMode`.
                Will broadcast.

                If provided on per-element basis, gets applied upon exit.
            stop_exit_mode (StopExitMode or array_like): See `vectorbt.portfolio.enums.StopExitMode`.
                Will broadcast.

                If provided on per-element basis, gets applied upon exit.
            stop_update_mode (StopUpdateMode or array_like): See `vectorbt.portfolio.enums.StopUpdateMode`.
                Will broadcast.

                Only has effect is `accumulate` is True.

                If provided on per-element basis, gets applied upon repeated entry.
            adjust_sl_func_nb (callable): Function to adjust stop loss.
                Defaults to `vectorbt.portfolio.nb.no_adjust_sl_func_nb`.

                Called for each element before each row.

                Should accept index of the current row, index of the current column, the current position size,
                the latest asset price, initial index of the stop, initial price of the stop, initial value
                of the stop, initial trailing flag of the stop, and `*adjust_sl_args`.
                Should return a tuple of a new stop value and trailing flag.
            adjust_sl_args (tuple): Packed arguments passed to `adjust_sl_func_nb`.
                Defaults to `()`.
            adjust_tp_func_nb (callable): Function to adjust take profit.
                Defaults to `vectorbt.portfolio.nb.no_adjust_tp_func_nb`.

                Called for each element before each row.

                Should accept index of the current row, index of the current column, the current position size,
                the latest asset price, initial index of the stop, initial price of the stop, initial value
                of the stop, and `*adjust_tp_args`. Should return a new stop value.
            adjust_tp_args (tuple): Packed arguments passed to `adjust_tp_func_nb`.
                Defaults to `()`.
            use_stops (bool): Whether to use stops.
                Defaults to None, which becomes True if any of the stops are not NaN or
                any of the adjustment functions are custom.

                Disable this to make simulation a bit faster for simple use cases.
            init_cash (InitCashMode, float or array_like of float): See `Portfolio.from_orders`.
            cash_sharing (bool): See `Portfolio.from_orders`.
            call_seq (CallSeqType or array_like): See `Portfolio.from_orders`.
            ffill_val_price (bool): See `Portfolio.from_orders`.
            update_value (bool): See `Portfolio.from_orders`.
            max_orders (int): See `Portfolio.from_orders`.
            max_logs (int): See `Portfolio.from_orders`.
            seed (int): See `Portfolio.from_orders`.
            group_by (any): See `Portfolio.from_orders`.
            broadcast_kwargs (dict): See `Portfolio.from_orders`.
            wrapper_kwargs (dict): See `Portfolio.from_orders`.
            freq (any): See `Portfolio.from_orders`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        All broadcastable arguments will broadcast using `vectorbt.base.reshape_fns.broadcast`
        but keep original shape to utilize flexible indexing and to save memory.

        For defaults, see `portfolio` in `vectorbt._settings.settings`.

        !!! hint
            If you generated signals using close price, don&#39;t forget to shift your signals by one tick
            forward, for example, with `signals.vbt.fshift(1)`. In general, make sure to use a price
            that comes after the signal.

        Also see notes and hints for `Portfolio.from_orders`.

        ## Example

        Entry opens long, exit closes long:

        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; entries = pd.Series([True, True, True, False, False])
        &gt;&gt;&gt; exits = pd.Series([False, False, True, True, True])

        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;longonly&#39;)
        &gt;&gt;&gt; pf.asset_flow()
        0    1.0
        1    0.0
        2    0.0
        3   -1.0
        4    0.0
        dtype: float64
        ```

        Entry opens short, exit closes short:

        ```python-repl
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;shortonly&#39;)
        &gt;&gt;&gt; pf.asset_flow()
        0   -1.0
        1    0.0
        2    0.0
        3    1.0
        4    0.0
        dtype: float64
        ```

        Reversal within one tick. Entry opens long and closes short, exit closes long and opens short:

        ```python-repl
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;)
        &gt;&gt;&gt; pf.asset_flow()
        0    1.0
        1    0.0
        2    0.0
        3   -2.0
        4    0.0
        dtype: float64
        ```

        Reversal within two ticks. First signal closes position, second signal opens the opposite one:

        ```python-repl
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;,
        ...     close_first=True)
        &gt;&gt;&gt; pf.asset_flow()
        0    1.0
        1    0.0
        2    0.0
        3   -1.0
        4   -1.0
        dtype: float64
        ```

        If entry and exit, chooses exit:

        ```python-repl
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;,
        ...     close_first=True, conflict_mode=&#39;exit&#39;)
        &gt;&gt;&gt; pf.asset_flow()
        0    1.0
        1    0.0
        2   -1.0
        3   -1.0
        4    0.0
        dtype: float64
        ```

        Entry means long order, exit means short order (acts similar to `from_orders`):

        ```python-repl
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;,
        ...     accumulate=True)
        &gt;&gt;&gt; pf.asset_flow()
        0    1.0
        1    1.0
        2    0.0
        3   -1.0
        4   -1.0
        dtype: float64
        ```

        Testing multiple parameters (via broadcasting):

        ```python-repl
        &gt;&gt;&gt; from vectorbt.portfolio.enums import Direction

        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, direction=[list(Direction)],
        ...     broadcast_kwargs=dict(columns_from=Direction._fields))
        &gt;&gt;&gt; pf.asset_flow()
            Long  Short    All
        0  100.0 -100.0  100.0
        1    0.0    0.0    0.0
        2    0.0    0.0    0.0
        3 -100.0   50.0 -200.0
        4    0.0    0.0    0.0
        ```

        Specifying information in a more granular way thanks to broadcasting.
        Reverse the first long position by first closing it, and all other immediately:

        ```python-repl
        &gt;&gt;&gt; entries = pd.Series([True, False, False, True, False])
        &gt;&gt;&gt; exits = pd.Series([False, True, True, False, True])
        &gt;&gt;&gt; close_first = pd.Series([False, True, False, False, False])
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits, size=1., direction=&#39;all&#39;,
        ...     close_first=close_first)
        &gt;&gt;&gt; pf.asset_flow()
        0    1.0
        1   -1.0
        2   -1.0
        3    2.0
        4   -2.0
        dtype: float64
        ```

        Set risk/reward ratio by passing trailing stop loss and take profit thresholds:

        ```python-repl
        &gt;&gt;&gt; close = pd.Series([10, 11, 12, 11, 10, 9])
        &gt;&gt;&gt; entries = pd.Series([True, False, False, False, False, False])
        &gt;&gt;&gt; exits = pd.Series([False, False, False, False, False, True])
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits,
        ...     sl_stop=0.1, sl_trail=True, tp_stop=0.2)  # take profit hit
        &gt;&gt;&gt; pf.asset_flow()
        0    10.0
        1     0.0
        2   -10.0
        3     0.0
        4     0.0
        5     0.0
        dtype: float64

        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits,
        ...     sl_stop=0.1, sl_trail=True, tp_stop=0.3)  # stop loss hit
        &gt;&gt;&gt; pf.asset_flow()
        0    10.0
        1     0.0
        2     0.0
        3     0.0
        4   -10.0
        5     0.0
        dtype: float64

        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, entries, exits,
        ...     sl_stop=np.inf, sl_trail=True, tp_stop=np.inf)  # nothing hit, exit as usual
        &gt;&gt;&gt; pf.asset_flow()
        0    10.0
        1     0.0
        2     0.0
        3     0.0
        4     0.0
        5   -10.0
        dtype: float64
        ```

        We can implement our own stop loss or take profit, or adjust the existing one at each time step.
        Let&#39;s implement [stepped stop-loss](https://www.freqtrade.io/en/stable/strategy-advanced/#stepped-stoploss):

        ```python-repl
        &gt;&gt;&gt; from numba import njit

        &gt;&gt;&gt; @njit
        ... def adjust_sl_func_nb(i, col, position, val_price, init_i, init_price, init_stop, init_trail):
        ...     current_profit = (val_price - init_price) / init_price
        ...     if current_profit &gt;= 0.40:
        ...         return 0.25, True
        ...     elif current_profit &gt;= 0.25:
        ...         return 0.15, True
        ...     elif current_profit &gt;= 0.20:
        ...         return 0.07, True
        ...     return init_stop, init_trail

        &gt;&gt;&gt; close = pd.Series([10, 11, 12, 11, 10])
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
        ...     close, adjust_sl_func_nb=adjust_sl_func_nb)
        &gt;&gt;&gt; pf.asset_flow()
        0    10.0
        1     0.0
        2     0.0
        3   -10.0  # 7% from 12 hit
        4    11.0
        dtype: float64
        ```

        Combine multiple exit conditions. Exit early if the price hits some threshold before an actual exit:

        ```python-repl
        &gt;&gt;&gt; close = pd.Series([10, 11, 12, 13, 14, 15])
        &gt;&gt;&gt; entries = pd.Series([True, True, True, False, False, False])
        &gt;&gt;&gt; exits = pd.Series([False, False, False, True, True, True])

        &gt;&gt;&gt; # 1. Remove adjacent entries and exits
        &gt;&gt;&gt; # since stop condition refers only to the first signal
        &gt;&gt;&gt; entries, exits = entries.vbt.signals.clean(exits)
        &gt;&gt;&gt; entries
        0     True
        1    False
        2    False
        3    False
        4    False
        5    False
        dtype: bool
        &gt;&gt;&gt; exits
        0    False
        1    False
        2    False
        3     True
        4    False
        5    False
        dtype: bool

        &gt;&gt;&gt; # 2. Find stop exits
        &gt;&gt;&gt; stop_exits = entries.vbt.signals.generate_stop_exits(close, 0.1)
        &gt;&gt;&gt; stop_exits
        0    False
        1     True
        2    False
        3    False
        4    False
        5    False
        dtype: bool

        &gt;&gt;&gt; # 3. Combine exits
        &gt;&gt;&gt; exits = exits | stop_exits
        &gt;&gt;&gt; exits
        0    False
        1     True
        2    False
        3     True
        4    False
        5    False
        dtype: bool

        &gt;&gt;&gt; # 4. Pick the first exit after each entry
        &gt;&gt;&gt; exits = exits.vbt.signals.first(reset_by=entries, allow_gaps=True)
        &gt;&gt;&gt; exits
        0    False
        1     True
        2    False
        3    False
        4    False
        5    False
        dtype: bool

        &gt;&gt;&gt; # 5. Simulate portfolio
        &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(close, entries, exits)
        &gt;&gt;&gt; pf.asset_flow()
        0    10.0
        1   -10.0
        2     0.0
        3     0.0
        4     0.0
        5     0.0
        dtype: float64
        ```

        !!! note
            By cleaning signals, we lose information. Moreover, this automatically assumes
            that each entry/signal signal succeeds (= order gets filled). Use this with caution,
            and consider rewriting your strategy with `Portfolio.from_order_func`, which is a
            preferred way of defining a complex logic in vectorbt.
        &#34;&#34;&#34;
        # Get defaults
        from vectorbt._settings import settings
        portfolio_cfg = settings[&#39;portfolio&#39;]

        if entries is None:
            entries = True
        if exits is None:
            exits = False
        if size is None:
            size = portfolio_cfg[&#39;size&#39;]
        if size_type is None:
            size_type = portfolio_cfg[&#39;signal_size_type&#39;]
        size_type = cast_enum_value(size_type, SizeType)
        if direction is None:
            direction = portfolio_cfg[&#39;signal_direction&#39;]
        direction = cast_enum_value(direction, Direction)
        if price is None:
            price = np.inf
        if fees is None:
            fees = portfolio_cfg[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = portfolio_cfg[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = portfolio_cfg[&#39;slippage&#39;]
        if min_size is None:
            min_size = portfolio_cfg[&#39;min_size&#39;]
        if max_size is None:
            max_size = portfolio_cfg[&#39;max_size&#39;]
        if reject_prob is None:
            reject_prob = portfolio_cfg[&#39;reject_prob&#39;]
        if lock_cash is None:
            lock_cash = portfolio_cfg[&#39;lock_cash&#39;]
        if allow_partial is None:
            allow_partial = portfolio_cfg[&#39;allow_partial&#39;]
        if raise_reject is None:
            raise_reject = portfolio_cfg[&#39;raise_reject&#39;]
        if log is None:
            log = portfolio_cfg[&#39;log&#39;]
        if accumulate is None:
            accumulate = portfolio_cfg[&#39;accumulate&#39;]
        if conflict_mode is None:
            conflict_mode = portfolio_cfg[&#39;conflict_mode&#39;]
        conflict_mode = cast_enum_value(conflict_mode, ConflictMode)
        if close_first is None:
            close_first = portfolio_cfg[&#39;close_first&#39;]
        if val_price is None:
            val_price = portfolio_cfg[&#39;val_price&#39;]
        if open is None:
            open = np.nan
        if high is None:
            high = np.nan
        if low is None:
            low = np.nan
        if sl_stop is None:
            sl_stop = portfolio_cfg[&#39;sl_stop&#39;]
        if sl_trail is None:
            sl_trail = portfolio_cfg[&#39;sl_trail&#39;]
        if tp_stop is None:
            tp_stop = portfolio_cfg[&#39;tp_stop&#39;]
        if stop_entry_price is None:
            stop_entry_price = portfolio_cfg[&#39;stop_entry_price&#39;]
        stop_entry_price = cast_enum_value(stop_entry_price, StopEntryPrice)
        if stop_exit_price is None:
            stop_exit_price = portfolio_cfg[&#39;stop_exit_price&#39;]
        stop_exit_price = cast_enum_value(stop_exit_price, StopExitPrice)
        if stop_conflict_mode is None:
            stop_conflict_mode = portfolio_cfg[&#39;stop_conflict_mode&#39;]
        stop_conflict_mode = cast_enum_value(stop_conflict_mode, ConflictMode)
        if stop_exit_mode is None:
            stop_exit_mode = portfolio_cfg[&#39;stop_exit_mode&#39;]
        stop_exit_mode = cast_enum_value(stop_exit_mode, StopExitMode)
        if stop_update_mode is None:
            stop_update_mode = portfolio_cfg[&#39;stop_update_mode&#39;]
        stop_update_mode = cast_enum_value(stop_update_mode, StopUpdateMode)
        if use_stops is None:
            use_stops = portfolio_cfg[&#39;use_stops&#39;]
        if use_stops is None:
            if isinstance(sl_stop, float) and \
                    np.isnan(sl_stop) and \
                    isinstance(tp_stop, float) and \
                    np.isnan(tp_stop) and \
                    adjust_sl_func_nb == nb.no_adjust_sl_func_nb and \
                    adjust_tp_func_nb == nb.no_adjust_tp_func_nb:
                use_stops = False
            else:
                use_stops = True

        if init_cash is None:
            init_cash = portfolio_cfg[&#39;init_cash&#39;]
        init_cash = cast_enum_value(init_cash, InitCashMode)
        if isinstance(init_cash, int) and init_cash in InitCashMode:
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = portfolio_cfg[&#39;cash_sharing&#39;]
        if cash_sharing and group_by is None:
            group_by = True
        if call_seq is None:
            call_seq = portfolio_cfg[&#39;call_seq&#39;]
        call_seq = cast_enum_value(call_seq, CallSeqType)
        auto_call_seq = False
        if isinstance(call_seq, int):
            if call_seq == CallSeqType.Auto:
                call_seq = CallSeqType.Default
                auto_call_seq = True
        if ffill_val_price is None:
            ffill_val_price = portfolio_cfg[&#39;ffill_val_price&#39;]
        if update_value is None:
            update_value = portfolio_cfg[&#39;update_value&#39;]
        if seed is None:
            seed = portfolio_cfg[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = portfolio_cfg[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Broadcast inputs
        # Only close is broadcast, others can remain unchanged thanks to flexible indexing
        broadcastable_args = (
            close,
            entries,
            exits,
            size,
            price,
            size_type,
            direction,
            fees,
            fixed_fees,
            slippage,
            min_size,
            max_size,
            reject_prob,
            lock_cash,
            allow_partial,
            raise_reject,
            log,
            accumulate,
            conflict_mode,
            close_first,
            val_price,
            open,
            high,
            low,
            sl_stop,
            sl_trail,
            tp_stop,
            stop_entry_price,
            stop_exit_price,
            stop_conflict_mode,
            stop_exit_mode,
            stop_update_mode
        )
        broadcast_kwargs = merge_dicts(dict(
            keep_raw=[False] + [True] * (len(broadcastable_args) - 1),
            require_kwargs=dict(requirements=&#39;W&#39;)
        ), broadcast_kwargs)
        broadcasted_args = broadcast(*broadcastable_args, **broadcast_kwargs)
        close = broadcasted_args[0]
        if not checks.is_pandas(close):
            close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
        target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
        init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
        group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
        if checks.is_any_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
        if max_orders is None:
            max_orders = target_shape_2d[0] * target_shape_2d[1]
        if max_logs is None:
            max_logs = target_shape_2d[0] * target_shape_2d[1]
        if not np.any(log):
            max_logs = 1

        # Perform calculation
        order_records, log_records = nb.simulate_from_signals_nb(
            target_shape_2d,
            to_2d(close, raw=True),
            cs_group_lens,  # group only if cash sharing is enabled to speed up
            init_cash,
            call_seq,
            *map(np.asarray, broadcasted_args[1:]),
            adjust_sl_func_nb,
            adjust_sl_args,
            adjust_tp_func_nb,
            adjust_tp_args,
            use_stops,
            auto_call_seq,
            ffill_val_price,
            update_value,
            max_orders,
            max_logs,
            close.ndim == 2
        )

        # Create an instance
        return cls(
            wrapper,
            close,
            order_records,
            log_records,
            init_cash if init_cash_mode is None else init_cash_mode,
            cash_sharing,
            call_seq,
            **kwargs
        )

    @classmethod
    def from_orders(cls: tp.Type[PortfolioT],
                    close: tp.ArrayLike,
                    size: tp.Optional[tp.ArrayLike] = None,
                    size_type: tp.Optional[tp.ArrayLike] = None,
                    direction: tp.Optional[tp.ArrayLike] = None,
                    price: tp.Optional[tp.ArrayLike] = None,
                    fees: tp.Optional[tp.ArrayLike] = None,
                    fixed_fees: tp.Optional[tp.ArrayLike] = None,
                    slippage: tp.Optional[tp.ArrayLike] = None,
                    min_size: tp.Optional[tp.ArrayLike] = None,
                    max_size: tp.Optional[tp.ArrayLike] = None,
                    reject_prob: tp.Optional[tp.ArrayLike] = None,
                    lock_cash: tp.Optional[tp.ArrayLike] = None,
                    allow_partial: tp.Optional[tp.ArrayLike] = None,
                    raise_reject: tp.Optional[tp.ArrayLike] = None,
                    log: tp.Optional[tp.ArrayLike] = None,
                    val_price: tp.Optional[tp.ArrayLike] = None,
                    init_cash: tp.Optional[tp.ArrayLike] = None,
                    cash_sharing: tp.Optional[bool] = None,
                    call_seq: tp.Optional[tp.ArrayLike] = None,
                    ffill_val_price: tp.Optional[bool] = None,
                    update_value: tp.Optional[bool] = None,
                    max_orders: tp.Optional[int] = None,
                    max_logs: tp.Optional[int] = None,
                    seed: tp.Optional[int] = None,
                    group_by: tp.GroupByLike = None,
                    broadcast_kwargs: tp.KwargsLike = None,
                    wrapper_kwargs: tp.KwargsLike = None,
                    freq: tp.Optional[tp.FrequencyLike] = None,
                    **kwargs) -&gt; PortfolioT:
        &#34;&#34;&#34;Simulate portfolio from orders.

        Args:
            close (array_like): Last asset price at each time step.
                Will broadcast.

                Used for calculating unrealized P&amp;L and portfolio value.
            size (float or array_like): Size to order.
                See `vectorbt.portfolio.enums.Order.size`. Will broadcast.
            size_type (SizeType or array_like): See `vectorbt.portfolio.enums.SizeType`.
                See `vectorbt.portfolio.enums.Order.size_type`. Will broadcast.

                !!! note
                    `SizeType.Percent` does not support position reversal. Switch to a single direction.

                !!! warning
                    Be cautious using `SizeType.Percent` with `call_seq` set to &#39;auto&#39;.
                    To execute sell orders before buy orders, the value of each order in the group
                    needs to be approximated in advance. But since `SizeType.Percent` depends
                    upon the cash balance, which cannot be calculated in advance since it may change
                    after each order, this can yield a non-optimal call sequence.
            direction (Direction or array_like): See `vectorbt.portfolio.enums.Direction`.
                See `vectorbt.portfolio.enums.Order.direction`. Will broadcast.
            price (array_like of float): Order price.
                See `vectorbt.portfolio.enums.Order.price`. Defaults to `np.inf`. Will broadcast.

                !!! note
                    Make sure to use the same timestamp for all order prices in the group with cash sharing
                    and `call_seq` set to `CallSeqType.Auto`.
            fees (float or array_like): Fees in percentage of the order value.
                See `vectorbt.portfolio.enums.Order.fees`. Will broadcast.
            fixed_fees (float or array_like): Fixed amount of fees to pay per order.
                See `vectorbt.portfolio.enums.Order.fixed_fees`. Will broadcast.
            slippage (float or array_like): Slippage in percentage of price.
                See `vectorbt.portfolio.enums.Order.slippage`. Will broadcast.
            min_size (float or array_like): Minimum size for an order to be accepted.
                See `vectorbt.portfolio.enums.Order.min_size`. Will broadcast.
            max_size (float or array_like): Maximum size for an order.
                See `vectorbt.portfolio.enums.Order.max_size`. Will broadcast.

                Will be partially filled if exceeded.
            reject_prob (float or array_like): Order rejection probability.
                See `vectorbt.portfolio.enums.Order.reject_prob`. Will broadcast.
            lock_cash (bool or array_like): Whether to lock cash when shorting.
                See `vectorbt.portfolio.enums.Order.lock_cash`. Will broadcast.
            allow_partial (bool or array_like): Whether to allow partial fills.
                See `vectorbt.portfolio.enums.Order.allow_partial`. Will broadcast.

                Does not apply when size is `np.inf`.
            raise_reject (bool or array_like): Whether to raise an exception if order gets rejected.
                See `vectorbt.portfolio.enums.Order.raise_reject`. Will broadcast.
            log (bool or array_like): Whether to log orders.
                See `vectorbt.portfolio.enums.Order.log`. Will broadcast.
            val_price (array_like of float): Asset valuation price.
                Will broadcast.

                * Any `-np.inf` element is replaced by the latest valuation price (the previous `close` or
                    the latest known valuation price if `ffill_val_price`).
                * Any `np.inf` element is replaced by the current order price.

                Used at the time of decision making to calculate value of each asset in the group,
                for example, to convert target value into target amount.

                !!! note
                    In contrast to `Portfolio.from_order_func`, order price is known beforehand (kind of),
                    thus `val_price` is set to the current order price (using `np.inf`) by default.
                    To valuate using previous close, set it in the settings to `-np.inf`.

                !!! note
                    Make sure to use timestamp for `val_price` that comes before timestamps of
                    all orders in the group with cash sharing (previous `close` for example),
                    otherwise you&#39;re cheating yourself.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                By default, will broadcast to the number of columns.
                If cash sharing is enabled, will broadcast to the number of groups.
                See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

                !!! note
                    Mode `InitCashMode.AutoAlign` is applied after the portfolio is initialized
                    to set the same initial cash for all columns/groups. Changing grouping
                    will change the initial cash, so be aware when indexing.
            cash_sharing (bool): Whether to share cash within the same group.

                If `group_by` is None, `group_by` becomes True to form a single group with cash sharing.

                !!! warning
                    Introduces cross-asset dependencies.

                    This method presumes that in a group of assets that share the same capital all
                    orders will be executed within the same tick and retain their price regardless
                    of their position in the queue, even though they depend upon each other and thus
                    cannot be executed in parallel.
            call_seq (CallSeqType or array_like): Default sequence of calls per row and group.

                Each value in this sequence should indicate the position of column in the group to
                call next. Processing of `call_seq` goes always from left to right.
                For example, `[2, 0, 1]` would first call column &#39;c&#39;, then &#39;a&#39;, and finally &#39;b&#39;.

                * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
                * Set to array to specify custom sequence. Will not broadcast.

                If `CallSeqType.Auto` selected, rearranges calls dynamically based on order value.
                Calculates value of all orders per row and group, and sorts them by this value.
                Sell orders will be executed first to release funds for buy orders.

                !!! warning
                    `CallSeqType.Auto` should be used with caution:

                    * It not only presumes that order prices are known beforehand, but also that
                        orders can be executed in arbitrary order and still retain their price.
                        In reality, this is hardly the case: after processing one asset, some time
                        has passed and the price for other assets might have already changed.
                    * Even if you&#39;re able to specify a slippage large enough to compensate for
                        this behavior, slippage itself should depend upon execution order.
                        This method doesn&#39;t let you do that.
                    * If one order is rejected, it still may execute next orders and possibly
                        leave them without required funds.

                    For more control, use `Portfolio.from_order_func`.
            ffill_val_price (bool): Whether to track valuation price only if it&#39;s known.

                Otherwise, unknown `close` will lead to NaN in valuation price at the next timestamp.
            update_value (bool): Whether to update group value after each filled order.
            max_orders (int): Size of the order records array.
                Defaults to the number of elements in the broadcasted shape.

                Set to a lower number if you run out of memory.
            max_logs (int): Size of the log records array.
                Defaults to the number of elements in the broadcasted shape if any of the `log` is True,
                otherwise to 1.

                Set to a lower number if you run out of memory.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            freq (any): Index frequency in case it cannot be parsed from `close`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        All broadcastable arguments will broadcast using `vectorbt.base.reshape_fns.broadcast`
        but keep original shape to utilize flexible indexing and to save memory.

        For defaults, see `portfolio` in `vectorbt._settings.settings`.

        !!! note
            When `call_seq` is not `CallSeqType.Auto`, at each timestamp, processing of the assets in
            a group goes strictly in order defined in `call_seq`. This order can&#39;t be changed dynamically.

            This has one big implication for this particular method: the last asset in the call stack
            cannot be processed until other assets are processed. This is the reason why rebalancing
            cannot work properly in this setting: one has to specify percentages for all assets beforehand
            and then tweak the processing order to sell to-be-sold assets first in order to release funds
            for to-be-bought assets. This can be automatically done by using `CallSeqType.Auto`.

        !!! hint
            All broadcastable arguments can be set per frame, series, row, column, or element.

        ## Example

        Buy 10 units each tick:

        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; pf = vbt.Portfolio.from_orders(close, 10)

        &gt;&gt;&gt; pf.assets()
        0    10.0
        1    20.0
        2    30.0
        3    40.0
        4    40.0
        dtype: float64
        &gt;&gt;&gt; pf.cash()
        0    90.0
        1    70.0
        2    40.0
        3     0.0
        4     0.0
        dtype: float64
        ```

        Reverse each position by first closing it:

        ```python-repl
        &gt;&gt;&gt; size = [1, 0, -1, 0, 1]
        &gt;&gt;&gt; pf = vbt.Portfolio.from_orders(close, size, size_type=&#39;targetpercent&#39;)

        &gt;&gt;&gt; pf.assets()
        0    100.000000
        1      0.000000
        2    -66.666667
        3      0.000000
        4     26.666667
        dtype: float64
        &gt;&gt;&gt; pf.cash()
        0      0.000000
        1    200.000000
        2    400.000000
        3    133.333333
        4      0.000000
        dtype: float64
        ```

        Equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb` example:
        It&#39;s more compact but has less control over execution:

        ```python-repl
        &gt;&gt;&gt; import numpy as np

        &gt;&gt;&gt; np.random.seed(42)
        &gt;&gt;&gt; close = pd.DataFrame(np.random.uniform(1, 10, size=(5, 3)))
        &gt;&gt;&gt; size = pd.Series(np.full(5, 1/3))  # each column 33.3%
        &gt;&gt;&gt; size[1::2] = np.nan  # skip every second tick

        &gt;&gt;&gt; pf = vbt.Portfolio.from_orders(
        ...     close,  # acts both as reference and order price here
        ...     size,
        ...     size_type=&#39;targetpercent&#39;,
        ...     call_seq=&#39;auto&#39;,  # first sell then buy
        ...     group_by=True,  # one group
        ...     cash_sharing=True,  # assets share the same cash
        ...     fees=0.001, fixed_fees=1., slippage=0.001  # costs
        ... )

        &gt;&gt;&gt; pf.asset_value(group_by=False).vbt.plot()
        ```

        ![](/vectorbt/docs/img/simulate_nb.svg)
        &#34;&#34;&#34;
        # Get defaults
        from vectorbt._settings import settings
        portfolio_cfg = settings[&#39;portfolio&#39;]

        if size is None:
            size = portfolio_cfg[&#39;size&#39;]
        if size_type is None:
            size_type = portfolio_cfg[&#39;size_type&#39;]
        size_type = cast_enum_value(size_type, SizeType)
        if direction is None:
            direction = portfolio_cfg[&#39;order_direction&#39;]
        direction = cast_enum_value(direction, Direction)
        if price is None:
            price = np.inf
        if size is None:
            size = portfolio_cfg[&#39;size&#39;]
        if fees is None:
            fees = portfolio_cfg[&#39;fees&#39;]
        if fixed_fees is None:
            fixed_fees = portfolio_cfg[&#39;fixed_fees&#39;]
        if slippage is None:
            slippage = portfolio_cfg[&#39;slippage&#39;]
        if min_size is None:
            min_size = portfolio_cfg[&#39;min_size&#39;]
        if max_size is None:
            max_size = portfolio_cfg[&#39;max_size&#39;]
        if reject_prob is None:
            reject_prob = portfolio_cfg[&#39;reject_prob&#39;]
        if lock_cash is None:
            lock_cash = portfolio_cfg[&#39;lock_cash&#39;]
        if allow_partial is None:
            allow_partial = portfolio_cfg[&#39;allow_partial&#39;]
        if raise_reject is None:
            raise_reject = portfolio_cfg[&#39;raise_reject&#39;]
        if log is None:
            log = portfolio_cfg[&#39;log&#39;]
        if val_price is None:
            val_price = portfolio_cfg[&#39;val_price&#39;]
        if init_cash is None:
            init_cash = portfolio_cfg[&#39;init_cash&#39;]
        init_cash = cast_enum_value(init_cash, InitCashMode)
        if isinstance(init_cash, int) and init_cash in InitCashMode:
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = portfolio_cfg[&#39;cash_sharing&#39;]
        if cash_sharing and group_by is None:
            group_by = True
        if call_seq is None:
            call_seq = portfolio_cfg[&#39;call_seq&#39;]
        call_seq = cast_enum_value(call_seq, CallSeqType)
        auto_call_seq = False
        if isinstance(call_seq, int):
            if call_seq == CallSeqType.Auto:
                call_seq = CallSeqType.Default
                auto_call_seq = True
        if ffill_val_price is None:
            ffill_val_price = portfolio_cfg[&#39;ffill_val_price&#39;]
        if update_value is None:
            update_value = portfolio_cfg[&#39;update_value&#39;]
        if seed is None:
            seed = portfolio_cfg[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = portfolio_cfg[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Broadcast inputs
        # Only close is broadcast, others can remain unchanged thanks to flexible indexing
        broadcastable_args = (
            close,
            size,
            price,
            size_type,
            direction,
            fees,
            fixed_fees,
            slippage,
            min_size,
            max_size,
            reject_prob,
            lock_cash,
            allow_partial,
            raise_reject,
            log,
            val_price
        )
        broadcast_kwargs = merge_dicts(dict(
            keep_raw=[False] + [True] * (len(broadcastable_args) - 1),
            require_kwargs=dict(requirements=&#39;W&#39;)
        ), broadcast_kwargs)
        broadcasted_args = broadcast(*broadcastable_args, **broadcast_kwargs)
        close = broadcasted_args[0]
        if not checks.is_pandas(close):
            close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
        target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
        init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
        group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
        if checks.is_any_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
        if max_orders is None:
            max_orders = target_shape_2d[0] * target_shape_2d[1]
        if max_logs is None:
            max_logs = target_shape_2d[0] * target_shape_2d[1]
        if not np.any(log):
            max_logs = 1

        # Perform calculation
        order_records, log_records = nb.simulate_from_orders_nb(
            target_shape_2d,
            to_2d(close, raw=True),
            cs_group_lens,  # group only if cash sharing is enabled to speed up
            init_cash,
            call_seq,
            *map(np.asarray, broadcasted_args[1:]),
            auto_call_seq,
            ffill_val_price,
            update_value,
            max_orders,
            max_logs,
            close.ndim == 2
        )

        # Create an instance
        return cls(
            wrapper,
            close,
            order_records,
            log_records,
            init_cash if init_cash_mode is None else init_cash_mode,
            cash_sharing,
            call_seq,
            **kwargs
        )

    @classmethod
    def from_order_func(cls: tp.Type[PortfolioT],
                        close: tp.ArrayLike,
                        order_func_nb: nb.OrderFuncT,
                        *order_args,
                        target_shape: tp.Optional[tp.RelaxedShape] = None,
                        keys: tp.Optional[tp.IndexLike] = None,
                        init_cash: tp.Optional[tp.ArrayLike] = None,
                        cash_sharing: tp.Optional[bool] = None,
                        call_seq: tp.Optional[tp.ArrayLike] = None,
                        segment_mask: tp.Optional[tp.ArrayLike] = None,
                        pre_sim_func_nb: nb.PreSimFuncT = nb.no_pre_func_nb,
                        pre_sim_args: tp.Args = (),
                        post_sim_func_nb: nb.PostSimFuncT = nb.no_post_func_nb,
                        post_sim_args: tp.Args = (),
                        pre_group_func_nb: nb.PreGroupFuncT = nb.no_pre_func_nb,
                        pre_group_args: tp.Args = (),
                        post_group_func_nb: nb.PostGroupFuncT = nb.no_post_func_nb,
                        post_group_args: tp.Args = (),
                        pre_row_func_nb: nb.PreRowFuncT = nb.no_pre_func_nb,
                        pre_row_args: tp.Args = (),
                        post_row_func_nb: nb.PostRowFuncT = nb.no_post_func_nb,
                        post_row_args: tp.Args = (),
                        pre_segment_func_nb: nb.PreSegmentFuncT = nb.no_pre_func_nb,
                        pre_segment_args: tp.Args = (),
                        post_segment_func_nb: nb.PostSegmentFuncT = nb.no_post_func_nb,
                        post_segment_args: tp.Args = (),
                        post_order_func_nb: nb.PostOrderFuncT = nb.no_post_func_nb,
                        post_order_args: tp.Args = (),
                        call_pre_segment: tp.Optional[bool] = None,
                        call_post_segment: tp.Optional[bool] = None,
                        ffill_val_price: tp.Optional[bool] = None,
                        update_value: tp.Optional[bool] = None,
                        fill_pos_record: tp.Optional[bool] = None,
                        row_wise: tp.Optional[bool] = None,
                        use_numba: tp.Optional[bool] = None,
                        max_orders: tp.Optional[int] = None,
                        max_logs: tp.Optional[int] = None,
                        seed: tp.Optional[int] = None,
                        group_by: tp.GroupByLike = None,
                        broadcast_kwargs: tp.KwargsLike = None,
                        wrapper_kwargs: tp.KwargsLike = None,
                        freq: tp.Optional[tp.FrequencyLike] = None,
                        **kwargs) -&gt; PortfolioT:
        &#34;&#34;&#34;Build portfolio from a custom order function.

        For details, see `vectorbt.portfolio.nb.simulate_nb`.

        if `row_wise` is True, also see `vectorbt.portfolio.nb.simulate_row_wise_nb`.

        Args:
            close (array_like): Last asset price at each time step.
                Will broadcast to `target_shape`.

                Used for calculating unrealized P&amp;L and portfolio value.
            order_func_nb (callable): Order generation function.
            *order_args: Arguments passed to `order_func_nb`.
            target_shape (tuple): Target shape to iterate over. Defaults to `close.shape`.
            keys (sequence): Outermost column level.

                Each element should correspond to one iteration over columns in `close`.
                Should be set only if `target_shape` is bigger than `close.shape`.
            init_cash (InitCashMode, float or array_like of float): Initial capital.

                See `init_cash` in `Portfolio.from_orders`.
            cash_sharing (bool): Whether to share cash within the same group.

                If `group_by` is None, `group_by` becomes True to form a single group with cash sharing.

                !!! warning
                    Introduces cross-asset dependencies.
            call_seq (CallSeqType or array_like): Default sequence of calls per row and group.

                * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
                * Set to array to specify custom sequence. Will not broadcast.

                !!! note
                    CallSeqType.Auto should be implemented manually.
                    Use `sort_call_seq_nb` in `pre_segment_func_nb`.
            segment_mask (int or array_like of bool): Mask of whether a particular segment should be executed.

                Supplying an integer will activate every n-th row (just for convenience).
                Supplying a boolean will broadcast to the number of rows and groups.
            pre_sim_func_nb (callable): Function called before simulation.
                Defaults to `vectorbt.portfolio.nb.no_pre_func_nb`.
            pre_sim_args (tuple): Packed arguments passed to `pre_sim_func_nb`.
                Defaults to `()`.
            post_sim_func_nb (callable): Function called after simulation.
                Defaults to `vectorbt.portfolio.nb.no_post_func_nb`.
            post_sim_args (tuple): Packed arguments passed to `post_sim_func_nb`.
                Defaults to `()`.
            pre_group_func_nb (callable): Function called before each group.
                Defaults to `vectorbt.portfolio.nb.no_pre_func_nb`.

                Called only if `row_wise` is False.
            pre_group_args (tuple): Packed arguments passed to `pre_group_func_nb`.
                Defaults to `()`.
            post_group_func_nb (callable): Function called after each group.
                Defaults to `vectorbt.portfolio.nb.no_post_func_nb`.

                Called only if `row_wise` is False.
            post_group_args (tuple): Packed arguments passed to `post_group_func_nb`.
                Defaults to `()`.
            pre_row_func_nb (callable): Function called before each row.
                Defaults to `vectorbt.portfolio.nb.no_pre_func_nb`.

                Called only if `row_wise` is True.
            pre_row_args (tuple): Packed arguments passed to `pre_row_func_nb`.
                Defaults to `()`.
            post_row_func_nb (callable): Function called after each row.
                Defaults to `vectorbt.portfolio.nb.no_post_func_nb`.

                Called only if `row_wise` is True.
            post_row_args (tuple): Packed arguments passed to `post_row_func_nb`.
                Defaults to `()`.
            pre_segment_func_nb (callable): Function called before each segment.
                Defaults to `vectorbt.portfolio.nb.no_pre_func_nb`.
            pre_segment_args (tuple): Packed arguments passed to `pre_segment_func_nb`.
                Defaults to `()`.
            post_segment_func_nb (callable): Function called after each segment.
                Defaults to `vectorbt.portfolio.nb.no_post_func_nb`.
            post_segment_args (tuple): Packed arguments passed to `post_segment_func_nb`.
                Defaults to `()`.
            post_order_func_nb (callable): Callback that is called after the order has been processed.
            post_order_args (tuple): Packed arguments passed to `post_order_func_nb`.
                Defaults to `()`.
            call_pre_segment (bool): Whether to call `pre_segment_func_nb` regardless of `segment_mask`.
            call_post_segment (bool): Whether to call `post_segment_func_nb` regardless of `segment_mask`.
            ffill_val_price (bool): Whether to track valuation price only if it&#39;s known.

                Otherwise, unknown `close` will lead to NaN in valuation price at the next timestamp.
            update_value (bool): Whether to update group value after each filled order.
            fill_pos_record (bool): Whether to fill position record.

                Disable this to make simulation a bit faster for simple use cases.
            row_wise (bool): Whether to iterate over rows rather than columns/groups.

                See `vectorbt.portfolio.nb.simulate_row_wise_nb`.
            use_numba (bool): Whether to run the main simulation function using Numba.

                !!! note
                    Disabling it does not disable Numba for other functions.
                    If neccessary, you should ensure that every other function does not uses Numba as well.
                    You can do this by using the `py_func` attribute of that function.
                    Or, you could disable Numba globally by doing `os.environ[&#39;NUMBA_DISABLE_JIT&#39;] = &#39;1&#39;`.
            max_orders (int): Size of the order records array.
                Defaults to the number of elements in the broadcasted shape.

                Set to a lower number if you run out of memory.
            max_logs (int): Size of the log records array.
                Defaults to the number of elements in the broadcasted shape.

                Set to a lower number if you run out of memory.
            seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
            group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
            wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
            freq (any): Index frequency in case it cannot be parsed from `close`.
            **kwargs: Keyword arguments passed to the `__init__` method.

        For defaults, see `portfolio` in `vectorbt._settings.settings`.

        !!! note
            All passed functions should be Numba-compiled.

            Objects passed as arguments to both functions will not broadcast to `target_shape`
            as their purpose is unknown. You should broadcast manually or use flexible indexing.

            Also see notes on `Portfolio.from_orders`.

        !!! note
            In contrast to other methods, the valuation price is previous `close`
            instead of order price, since the price of an order is unknown before call.
            You can still set valuation price explicitly in `pre_segment_func_nb`.

        ## Example

        Buy 10 units each tick using closing price:

        ```python-repl
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from numba import njit
        &gt;&gt;&gt; import vectorbt as vbt
        &gt;&gt;&gt; from vectorbt.portfolio.nb import order_nb

        &gt;&gt;&gt; @njit
        ... def order_func_nb(c, size):
        ...     return order_nb(size=size)

        &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(close, order_func_nb, 10)

        &gt;&gt;&gt; pf.assets()
        0    10.0
        1    20.0
        2    30.0
        3    40.0
        4    40.0
        dtype: float64
        &gt;&gt;&gt; pf.cash()
        0    90.0
        1    70.0
        2    40.0
        3     0.0
        4     0.0
        dtype: float64
        ```

        Reverse each position by first closing it. Keep state of last position to determine
        which position to open next (just as an example, there are easier ways to do this):

        ```python-repl
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from vectorbt.portfolio.nb import close_position_nb

        &gt;&gt;&gt; @njit
        ... def pre_group_func_nb(c):
        ...     last_pos_state = np.array([-1])
        ...     return (last_pos_state,)

        &gt;&gt;&gt; @njit
        ... def order_func_nb(c, last_pos_state):
        ...     if c.position_now != 0:
        ...         return close_position_nb()
        ...
        ...     if last_pos_state[0] == 1:
        ...         size = -np.inf  # open short
        ...         last_pos_state[0] = -1
        ...     else:
        ...         size = np.inf  # open long
        ...         last_pos_state[0] = 1
        ...     return order_nb(size=size)

        &gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(
        ...     close, order_func_nb, pre_group_func_nb=pre_group_func_nb)

        &gt;&gt;&gt; pf.assets()
        0    100.000000
        1      0.000000
        2    -66.666667
        3      0.000000
        4     26.666667
        dtype: float64
        &gt;&gt;&gt; pf.cash()
        0      0.000000
        1    200.000000
        2    400.000000
        3    133.333333
        4      0.000000
        dtype: float64
        ```

        Equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb` example:

        ```python-repl
        &gt;&gt;&gt; from vectorbt.portfolio.nb import sort_call_seq_nb
        &gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, Direction

        &gt;&gt;&gt; @njit
        ... def pre_group_func_nb(c):
        ...     &#39;&#39;&#39;Define empty arrays for each group.&#39;&#39;&#39;
        ...     order_value_out = np.empty(c.group_len, dtype=np.float_)
        ...     return (order_value_out,)

        &gt;&gt;&gt; @njit
        ... def pre_segment_func_nb(c, order_value_out):
        ...     &#39;&#39;&#39;Perform rebalancing at each segment.&#39;&#39;&#39;
        ...     for col in range(c.from_col, c.to_col):
        ...         # Here we use order price for group valuation
        ...         c.last_val_price[col] = c.close[c.i, col]
        ...     # Reorder call sequence such that selling orders come first and buying last
        ...     size = 1 / c.group_len
        ...     size_type = SizeType.TargetPercent
        ...     direction = Direction.LongOnly  # long positions only
        ...     sort_call_seq_nb(c, size, size_type, direction, order_value_out)
        ...     return (size, size_type, direction)

        &gt;&gt;&gt; @njit
        ... def order_func_nb(c, size, size_type, direction, fees, fixed_fees, slippage):
        ...     &#39;&#39;&#39;Place an order.&#39;&#39;&#39;
        ...     return order_nb(
        ...         size=size,
        ...         size_type=size_type,
        ...         direction=direction,
        ...         fees=fees,
        ...         fixed_fees=fixed_fees,
        ...         slippage=slippage
        ...     )

        &gt;&gt;&gt; np.random.seed(42)
        &gt;&gt;&gt; close = np.random.uniform(1, 10, size=(5, 3))
        &gt;&gt;&gt; fees = 0.001
        &gt;&gt;&gt; fixed_fees = 1.
        &gt;&gt;&gt; slippage = 0.001

        &gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(
        ...     close,  # acts both as reference and order price here
        ...     order_func_nb, fees, fixed_fees, slippage,  # order_args as *args
        ...     segment_mask=2,  # rebalance every second tick
        ...     pre_group_func_nb=pre_group_func_nb,
        ...     pre_segment_func_nb=pre_segment_func_nb,
        ...     cash_sharing=True, group_by=True,  # one group with cash sharing
        ... )

        &gt;&gt;&gt; pf.asset_value(group_by=False).vbt.plot()
        ```

        ![](/vectorbt/docs/img/simulate_nb.svg)

        Combine multiple exit conditions. Exit early if the price hits some threshold before an actual exit
        (similar to the example under `Portfolio.from_signals`, but doesn&#39;t remove any information):

        ```python-repl
        &gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb, to_2d
        &gt;&gt;&gt; from vectorbt.portfolio.enums import NoOrder, OrderStatus, OrderSide

        &gt;&gt;&gt; @njit
        ... def pre_sim_func_nb(c):
        ...     # We need to define stop price per column once
        ...     stop_price = np.full(c.target_shape[1], np.nan, dtype=np.float_)
        ...     return (stop_price,)

        &gt;&gt;&gt; @njit
        ... def order_func_nb(c, stop_price, entries, exits, size, flex_2d):
        ...     # Select info related to this order
        ...     # flex_select_auto_nb allows us to pass size as single number, 1-dim or 2-dim array
        ...     # If flex_2d is True, 1-dim array will be per column, otherwise per row
        ...     size_now = flex_select_auto_nb(c.i, c.col, np.asarray(size), flex_2d)
        ...     price_now = c.close[c.i, c.col]  # close is always 2-dim array
        ...     stop_price_now = stop_price[c.col]
        ...
        ...     # Our logic
        ...     if entries[c.i, c.col]:
        ...         if c.position_now == 0:
        ...             return order_nb(
        ...                 size=size_now,
        ...                 price=price_now,
        ...                 direction=Direction.LongOnly)
        ...     elif exits[c.i, c.col] or price_now &gt;= stop_price_now:
        ...         if c.position_now &gt; 0:
        ...             return order_nb(
        ...                 size=-size_now,
        ...                 price=price_now,
        ...                 direction=Direction.LongOnly)
        ...     return NoOrder

        &gt;&gt;&gt; @njit
        ... def post_order_func_nb(c, stop_price, stop, flex_2d):
        ...     # Same broadcasting as for size
        ...     stop_now = flex_select_auto_nb(c.i, c.col, np.asarray(stop), flex_2d)
        ...
        ...     if c.order_result.status == OrderStatus.Filled:
        ...         if c.order_result.side == OrderSide.Buy:
        ...             # Position entered: Set stop condition
        ...             stop_price[c.col] = (1 + stop_now) * c.order_result.price
        ...         else:
        ...             # Position exited: Remove stop condition
        ...             stop_price[c.col] = np.nan

        &gt;&gt;&gt; def simulate(close, entries, exits, threshold):
        ...     return vbt.Portfolio.from_order_func(
        ...         close,
        ...         order_func_nb,
        ...         to_2d(entries, raw=True),  # 2-dim array
        ...         to_2d(exits, raw=True),  # 2-dim array
        ...         np.inf, # will broadcast
        ...         True,
        ...         pre_sim_func_nb=pre_sim_func_nb,
        ...         post_order_func_nb=post_order_func_nb,
        ...         post_order_args=(
        ...             threshold,  # will broadcast
        ...             True
        ...         )
        ...     )

        &gt;&gt;&gt; close = pd.Series([10, 11, 12, 13, 14])
        &gt;&gt;&gt; entries = pd.Series([True, True, False, False, False])
        &gt;&gt;&gt; exits = pd.Series([False, False, False, True, True])
        &gt;&gt;&gt; simulate(close, entries, exits, 0.1).asset_flow()
        0    10.0
        1     0.0
        2   -10.0
        3     0.0
        4     0.0
        dtype: float64
        &gt;&gt;&gt; simulate(close, entries, exits, 0.2).asset_flow()
        0    10.0
        1     0.0
        2   -10.0
        3     0.0
        4     0.0
        dtype: float64
        &gt;&gt;&gt; simulate(close, entries, exits, np.nan).asset_flow()
        0    10.0
        1     0.0
        2     0.0
        3   -10.0
        4     0.0
        dtype: float64
        ```

        The reason why stop of 10% does not result in an order at the second time step is because
        it comes at the same time as entry, so it must wait until no entry is present.
        This can be changed by replacing the statement &#34;elif&#34; with &#34;if&#34;, which would execute
        an exit regardless if an entry is present (similar to using `ConflictMode.Opposite` in
        `Portfolio.from_signals`).
        &#34;&#34;&#34;
        # Get defaults
        from vectorbt._settings import settings
        portfolio_cfg = settings[&#39;portfolio&#39;]

        close = to_pd_array(close)
        if target_shape is None:
            target_shape = close.shape
        if init_cash is None:
            init_cash = portfolio_cfg[&#39;init_cash&#39;]
        init_cash = cast_enum_value(init_cash, InitCashMode)
        if isinstance(init_cash, int) and init_cash in InitCashMode:
            init_cash_mode = init_cash
            init_cash = np.inf
        else:
            init_cash_mode = None
        if cash_sharing is None:
            cash_sharing = portfolio_cfg[&#39;cash_sharing&#39;]
        if cash_sharing and group_by is None:
            group_by = True
        if call_seq is None:
            call_seq = portfolio_cfg[&#39;call_seq&#39;]
        call_seq = cast_enum_value(call_seq, CallSeqType)
        if isinstance(call_seq, int):
            if call_seq == CallSeqType.Auto:
                raise ValueError(&#34;CallSeqType.Auto should be implemented manually. &#34;
                                 &#34;Use sort_call_seq_nb in pre_segment_func_nb.&#34;)
        if segment_mask is None:
            segment_mask = True
        if call_pre_segment is None:
            call_pre_segment = portfolio_cfg[&#39;call_pre_segment&#39;]
        if call_post_segment is None:
            call_post_segment = portfolio_cfg[&#39;call_post_segment&#39;]
        if ffill_val_price is None:
            ffill_val_price = portfolio_cfg[&#39;ffill_val_price&#39;]
        if update_value is None:
            update_value = portfolio_cfg[&#39;update_value&#39;]
        if fill_pos_record is None:
            fill_pos_record = portfolio_cfg[&#39;fill_pos_record&#39;]
        if row_wise is None:
            row_wise = portfolio_cfg[&#39;row_wise&#39;]
        if use_numba is None:
            use_numba = portfolio_cfg[&#39;use_numba&#39;]
        if seed is None:
            seed = portfolio_cfg[&#39;seed&#39;]
        if seed is not None:
            set_seed(seed)
        if freq is None:
            freq = portfolio_cfg[&#39;freq&#39;]
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        require_kwargs = dict(require_kwargs=dict(requirements=&#39;W&#39;))
        broadcast_kwargs = merge_dicts(require_kwargs, broadcast_kwargs)
        if wrapper_kwargs is None:
            wrapper_kwargs = {}
        if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
            raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

        # Broadcast inputs
        if isinstance(target_shape, int):
            target_shape = (target_shape,)
        target_shape_2d = (target_shape[0], target_shape[1] if len(target_shape) &gt; 1 else 1)
        if close.shape != target_shape:
            if len(close.vbt.wrapper.columns) &lt;= target_shape_2d[1]:
                if target_shape_2d[1] % len(close.vbt.wrapper.columns) != 0:
                    raise ValueError(&#34;Cannot broadcast close to target_shape&#34;)
                if keys is None:
                    keys = pd.Index(np.arange(target_shape_2d[1]), name=&#39;iteration_idx&#39;)
                tile_times = target_shape_2d[1] // len(close.vbt.wrapper.columns)
                close = close.vbt.tile(tile_times, keys=keys)
        close = broadcast(close, to_shape=target_shape, **broadcast_kwargs)
        wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
        cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
        init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
        group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
        if isinstance(segment_mask, int):
            _segment_mask = np.full((target_shape_2d[0], len(group_lens)), False)
            _segment_mask[0::segment_mask] = True
            segment_mask = _segment_mask
        else:
            segment_mask = broadcast(
                segment_mask,
                to_shape=(target_shape_2d[0], len(group_lens)),
                to_pd=False,
                **require_kwargs
            )
        if checks.is_any_array(call_seq):
            call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
        else:
            call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
        if max_orders is None:
            max_orders = target_shape_2d[0] * target_shape_2d[1]
        if max_logs is None:
            max_logs = target_shape_2d[0] * target_shape_2d[1]

        # Perform calculation
        if row_wise:
            simulate_func = nb.simulate_row_wise_nb
            if not use_numba and hasattr(simulate_func, &#39;py_func&#39;):
                simulate_func = simulate_func.py_func
            order_records, log_records = simulate_func(
                target_shape=target_shape_2d,
                close=to_2d(close, raw=True),
                group_lens=group_lens,
                init_cash=init_cash,
                cash_sharing=cash_sharing,
                call_seq=call_seq,
                segment_mask=segment_mask,
                pre_sim_func_nb=pre_sim_func_nb,
                pre_sim_args=pre_sim_args,
                post_sim_func_nb=post_sim_func_nb,
                post_sim_args=post_sim_args,
                pre_row_func_nb=pre_row_func_nb,
                pre_row_args=pre_row_args,
                post_row_func_nb=post_row_func_nb,
                post_row_args=post_row_args,
                pre_segment_func_nb=pre_segment_func_nb,
                pre_segment_args=pre_segment_args,
                post_segment_func_nb=post_segment_func_nb,
                post_segment_args=post_segment_args,
                order_func_nb=order_func_nb,
                order_args=order_args,
                post_order_func_nb=post_order_func_nb,
                post_order_args=post_order_args,
                call_pre_segment=call_pre_segment,
                call_post_segment=call_post_segment,
                ffill_val_price=ffill_val_price,
                update_value=update_value,
                fill_pos_record=fill_pos_record,
                max_orders=max_orders,
                max_logs=max_logs
            )
        else:
            simulate_func = nb.simulate_nb
            if not use_numba and hasattr(simulate_func, &#39;py_func&#39;):
                simulate_func = simulate_func.py_func
            order_records, log_records = simulate_func(
                target_shape=target_shape_2d,
                close=to_2d(close, raw=True),
                group_lens=group_lens,
                init_cash=init_cash,
                cash_sharing=cash_sharing,
                call_seq=call_seq,
                segment_mask=segment_mask,
                pre_sim_func_nb=pre_sim_func_nb,
                pre_sim_args=pre_sim_args,
                post_sim_func_nb=post_sim_func_nb,
                post_sim_args=post_sim_args,
                pre_group_func_nb=pre_group_func_nb,
                pre_group_args=pre_group_args,
                post_group_func_nb=post_group_func_nb,
                post_group_args=post_group_args,
                pre_segment_func_nb=pre_segment_func_nb,
                pre_segment_args=pre_segment_args,
                post_segment_func_nb=post_segment_func_nb,
                post_segment_args=post_segment_args,
                order_func_nb=order_func_nb,
                order_args=order_args,
                post_order_func_nb=post_order_func_nb,
                post_order_args=post_order_args,
                call_pre_segment=call_pre_segment,
                call_post_segment=call_post_segment,
                ffill_val_price=ffill_val_price,
                update_value=update_value,
                fill_pos_record=fill_pos_record,
                max_orders=max_orders,
                max_logs=max_logs
            )

        # Create an instance
        return cls(
            wrapper,
            close,
            order_records,
            log_records,
            init_cash if init_cash_mode is None else init_cash_mode,
            cash_sharing,
            call_seq,
            **kwargs
        )

    # ############# Properties ############# #

    @property
    def wrapper(self) -&gt; ArrayWrapper:
        &#34;&#34;&#34;Array wrapper.&#34;&#34;&#34;
        if self.cash_sharing:
            # Allow only disabling grouping when needed (but not globally, see regroup)
            return self._wrapper.copy(
                allow_enable=False,
                allow_modify=False
            )
        return self._wrapper

    def regroup(self: PortfolioT, group_by: tp.GroupByLike, **kwargs) -&gt; PortfolioT:
        &#34;&#34;&#34;Regroup this object.

        See `vectorbt.base.array_wrapper.Wrapping.regroup`.

        !!! note
            All cached objects will be lost.&#34;&#34;&#34;
        if self.cash_sharing:
            if self.wrapper.grouper.is_grouping_modified(group_by=group_by):
                raise ValueError(&#34;Cannot modify grouping globally when cash_sharing=True&#34;)
        return Wrapping.regroup(self, group_by, **kwargs)

    @property
    def cash_sharing(self) -&gt; bool:
        &#34;&#34;&#34;Whether to share cash within the same group.&#34;&#34;&#34;
        return self._cash_sharing

    @property
    def call_seq(self, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Sequence of calls per row and group.&#34;&#34;&#34;
        return self.wrapper.wrap(self._call_seq, group_by=False, **merge_dicts({}, wrap_kwargs))

    @property
    def fillna_close(self) -&gt; bool:
        &#34;&#34;&#34;Whether to forward-backward fill NaN values in `Portfolio.close`.&#34;&#34;&#34;
        return self._fillna_close

    # ############# Reference price ############# #

    @property
    def close(self) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Price per unit series.&#34;&#34;&#34;
        return self._close

    @cached_method
    def get_filled_close(self, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Forward-backward-fill NaN values in `Portfolio.close`&#34;&#34;&#34;
        close = to_2d(self.close.ffill().bfill(), raw=True)
        return self.wrapper.wrap(close, group_by=False, **merge_dicts({}, wrap_kwargs))

    # ############# Records ############# #

    @property
    def order_records(self) -&gt; tp.RecordArray:
        &#34;&#34;&#34;A structured NumPy array of order records.&#34;&#34;&#34;
        return self._order_records

    @cached_property
    def orders(self) -&gt; Orders:
        &#34;&#34;&#34;`Portfolio.get_orders` with default arguments.&#34;&#34;&#34;
        return Orders(self.wrapper, self.order_records, self.close)

    @cached_method
    def get_orders(self, group_by: tp.GroupByLike = None) -&gt; Orders:
        &#34;&#34;&#34;Get order records.

        See `vectorbt.portfolio.orders.Orders`.&#34;&#34;&#34;
        return self.orders.regroup(group_by)

    @property
    def log_records(self) -&gt; tp.RecordArray:
        &#34;&#34;&#34;A structured NumPy array of log records.&#34;&#34;&#34;
        return self._log_records

    @cached_property
    def logs(self) -&gt; Logs:
        &#34;&#34;&#34;`Portfolio.get_logs` with default arguments.&#34;&#34;&#34;
        return Logs(self.wrapper, self.log_records)

    @cached_method
    def get_logs(self, group_by: tp.GroupByLike = None) -&gt; Logs:
        &#34;&#34;&#34;Get log records.

        See `vectorbt.portfolio.logs.Logs`.&#34;&#34;&#34;
        return self.logs.regroup(group_by)

    @cached_property
    def trades(self) -&gt; Trades:
        &#34;&#34;&#34;`Portfolio.get_trades` with default arguments.&#34;&#34;&#34;
        return Trades.from_orders(self.orders)

    @cached_method
    def get_trades(self, group_by: tp.GroupByLike = None) -&gt; Trades:
        &#34;&#34;&#34;Get trade records.

        See `vectorbt.portfolio.trades.Trades`.&#34;&#34;&#34;
        return self.trades.regroup(group_by)

    @cached_property
    def positions(self) -&gt; Positions:
        &#34;&#34;&#34;`Portfolio.get_positions` with default arguments.&#34;&#34;&#34;
        return Positions.from_trades(self.trades)

    @cached_method
    def get_positions(self, group_by: tp.GroupByLike = None) -&gt; Positions:
        &#34;&#34;&#34;Get position records.

        See `vectorbt.portfolio.trades.Positions`.&#34;&#34;&#34;
        return self.positions.regroup(group_by)

    @cached_property
    def drawdowns(self) -&gt; Drawdowns:
        &#34;&#34;&#34;`Portfolio.get_drawdowns` with default arguments.&#34;&#34;&#34;
        return self.get_drawdowns()

    @cached_method
    def get_drawdowns(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; Drawdowns:
        &#34;&#34;&#34;Get drawdown records from `Portfolio.value`.

        See `vectorbt.generic.drawdowns.Drawdowns`.

        `**kwargs` are passed to `Portfolio.value`.&#34;&#34;&#34;
        return Drawdowns.from_ts(self.value(group_by=group_by, **kwargs), freq=self.wrapper.freq)

    # ############# Assets ############# #

    @cached_method
    def asset_flow(self, direction: str = &#39;all&#39;, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get asset flow series per column.

        Returns the total transacted amount of assets at each time step.&#34;&#34;&#34;
        direction = cast_enum_value(direction, Direction)
        asset_flow = nb.asset_flow_nb(
            self.wrapper.shape_2d,
            self.orders.values,
            self.orders.col_mapper.col_map,
            direction
        )
        return self.wrapper.wrap(asset_flow, group_by=False, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def assets(self, direction: str = &#39;all&#39;, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get asset series per column.

        Returns the current position at each time step.&#34;&#34;&#34;
        direction = cast_enum_value(direction, Direction)
        asset_flow = to_2d(self.asset_flow(direction=&#39;all&#39;), raw=True)
        assets = nb.assets_nb(asset_flow)
        if direction == Direction.LongOnly:
            assets = np.where(assets &gt; 0, assets, 0.)
        if direction == Direction.ShortOnly:
            assets = np.where(assets &lt; 0, -assets, 0.)
        return self.wrapper.wrap(assets, group_by=False, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def position_mask(self, direction: str = &#39;all&#39;, group_by: tp.GroupByLike = None,
                      wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get position mask per column/group.

        An element is True if the asset is in the market at this tick.&#34;&#34;&#34;
        direction = cast_enum_value(direction, Direction)
        assets = to_2d(self.assets(direction=direction), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            position_mask = to_2d(self.position_mask(direction=direction, group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            position_mask = nb.position_mask_grouped_nb(position_mask, group_lens)
        else:
            position_mask = assets != 0
        return self.wrapper.wrap(position_mask, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def position_coverage(self, direction: str = &#39;all&#39;, group_by: tp.GroupByLike = None,
                          wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get position coverage per column/group.&#34;&#34;&#34;
        direction = cast_enum_value(direction, Direction)
        assets = to_2d(self.assets(direction=direction), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            position_mask = to_2d(self.position_mask(direction=direction, group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            position_coverage = nb.position_coverage_grouped_nb(position_mask, group_lens)
        else:
            position_coverage = np.mean(assets != 0, axis=0)
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;position_coverage&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(position_coverage, group_by=group_by, **wrap_kwargs)

    # ############# Cash ############# #

    @cached_method
    def cash_flow(self, group_by: tp.GroupByLike = None, free: bool = False,
                  wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get cash flow series per column/group.

        Use `free` to return the flow of the free cash, which never goes above the initial level,
        because an operation always costs money.&#34;&#34;&#34;
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            cash_flow = to_2d(self.cash_flow(group_by=False, free=free), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            cash_flow = nb.cash_flow_grouped_nb(cash_flow, group_lens)
        else:
            cash_flow = nb.cash_flow_nb(
                self.wrapper.shape_2d,
                self.orders.values,
                self.orders.col_mapper.col_map,
                free
            )
        return self.wrapper.wrap(cash_flow, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_property
    def init_cash(self) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;`Portfolio.get_init_cash` with default arguments.&#34;&#34;&#34;
        return self.get_init_cash()

    @cached_method
    def get_init_cash(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Initial amount of cash per column/group with default arguments.

        !!! note
            If the initial cash balance was found automatically and no own cash is used throughout
            the simulation (for example, when shorting), it will be set to 1 instead of 0 to enable
            smooth calculation of returns.&#34;&#34;&#34;
        if isinstance(self._init_cash, int):
            cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
            cash_min = np.min(np.cumsum(cash_flow, axis=0), axis=0)
            init_cash = np.where(cash_min &lt; 0, np.abs(cash_min), 1.)
            if self._init_cash == InitCashMode.AutoAlign:
                init_cash = np.full(init_cash.shape, np.max(init_cash))
        else:
            init_cash = to_1d(self._init_cash, raw=True)
            if self.wrapper.grouper.is_grouped(group_by=group_by):
                group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
                init_cash = nb.init_cash_grouped_nb(init_cash, group_lens, self.cash_sharing)
            else:
                group_lens = self.wrapper.grouper.get_group_lens()
                init_cash = nb.init_cash_nb(init_cash, group_lens, self.cash_sharing)
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;init_cash&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(init_cash, group_by=group_by, **wrap_kwargs)

    @cached_method
    def cash(self, group_by: tp.GroupByLike = None, in_sim_order: bool = False, free: bool = False,
             wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get cash balance series per column/group.

        See the explanation on `in_sim_order` in `Portfolio.value`.
        For `free`, see `Portfolio.cash_flow`.&#34;&#34;&#34;
        if in_sim_order and not self.cash_sharing:
            raise ValueError(&#34;Cash sharing must be enabled for in_sim_order=True&#34;)

        cash_flow = to_2d(self.cash_flow(group_by=group_by, free=free), raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
            cash = nb.cash_grouped_nb(
                self.wrapper.shape_2d,
                cash_flow,
                group_lens,
                init_cash
            )
        else:
            if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
                group_lens = self.wrapper.grouper.get_group_lens()
                init_cash = to_1d(self.init_cash, raw=True)
                call_seq = to_2d(self.call_seq, raw=True)
                cash = nb.cash_in_sim_order_nb(cash_flow, group_lens, init_cash, call_seq)
            else:
                init_cash = to_1d(self.get_init_cash(group_by=False), raw=True)
                cash = nb.cash_nb(cash_flow, init_cash)
        return self.wrapper.wrap(cash, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    # ############# Performance ############# #

    @cached_method
    def asset_value(self, direction: str = &#39;all&#39;, group_by: tp.GroupByLike = None,
                    wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get asset value series per column/group.&#34;&#34;&#34;
        direction = cast_enum_value(direction, Direction)
        if self.fillna_close:
            close = to_2d(self.get_filled_close(), raw=True).copy()
        else:
            close = to_2d(self.close, raw=True).copy()
        assets = to_2d(self.assets(direction=direction), raw=True)
        close[assets == 0] = 0.  # for price being NaN
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            asset_value = to_2d(self.asset_value(direction=direction, group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            asset_value = nb.asset_value_grouped_nb(asset_value, group_lens)
        else:
            asset_value = nb.asset_value_nb(close, assets)
        return self.wrapper.wrap(asset_value, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def gross_exposure(self, direction: str = &#39;all&#39;, group_by: tp.GroupByLike = None,
                       wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get gross exposure.&#34;&#34;&#34;
        asset_value = to_2d(self.asset_value(group_by=group_by, direction=direction), raw=True)
        cash = to_2d(self.cash(group_by=group_by, free=True), raw=True)
        gross_exposure = nb.gross_exposure_nb(asset_value, cash)
        return self.wrapper.wrap(gross_exposure, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def net_exposure(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get net exposure.&#34;&#34;&#34;
        long_exposure = to_2d(self.gross_exposure(direction=&#39;longonly&#39;, group_by=group_by), raw=True)
        short_exposure = to_2d(self.gross_exposure(direction=&#39;shortonly&#39;, group_by=group_by), raw=True)
        net_exposure = long_exposure - short_exposure
        return self.wrapper.wrap(net_exposure, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def value(self, group_by: tp.GroupByLike = None, in_sim_order: bool = False,
              wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get portfolio value series per column/group.

        By default, will generate portfolio value for each asset based on cash flows and thus
        independent from other assets, with the initial cash balance and position being that of the
        entire group. Useful for generating returns and comparing assets within the same group.

        When `group_by` is False and `in_sim_order` is True, returns value generated in
        simulation order (see [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
        This value cannot be used for generating returns as-is. Useful to analyze how value
        evolved throughout simulation.&#34;&#34;&#34;
        cash = to_2d(self.cash(group_by=group_by, in_sim_order=in_sim_order), raw=True)
        asset_value = to_2d(self.asset_value(group_by=group_by), raw=True)
        if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
            group_lens = self.wrapper.grouper.get_group_lens()
            call_seq = to_2d(self.call_seq, raw=True)
            value = nb.value_in_sim_order_nb(cash, asset_value, group_lens, call_seq)
            # price of NaN is already addressed by ungrouped_value_nb
        else:
            value = nb.value_nb(cash, asset_value)
        return self.wrapper.wrap(value, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def total_profit(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Get total profit per column/group.

        Calculated directly from order records (fast).&#34;&#34;&#34;
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            total_profit = to_1d(self.total_profit(group_by=False), raw=True)
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            total_profit = nb.total_profit_grouped_nb(
                total_profit,
                group_lens
            )
        else:
            if self.fillna_close:
                close = to_2d(self.get_filled_close(), raw=True)
            else:
                close = to_2d(self.close, raw=True)
            total_profit = nb.total_profit_nb(
                self.wrapper.shape_2d,
                close,
                self.orders.values,
                self.orders.col_mapper.col_map
            )
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total_profit&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(total_profit, group_by=group_by, **wrap_kwargs)

    @cached_method
    def final_value(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        total_profit = to_1d(self.total_profit(group_by=group_by), raw=True)
        final_value = nb.final_value_nb(total_profit, init_cash)
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;final_value&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(final_value, group_by=group_by, **wrap_kwargs)

    @cached_method
    def total_return(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        total_profit = to_1d(self.total_profit(group_by=group_by), raw=True)
        total_return = nb.total_return_nb(total_profit, init_cash)
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total_return&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(total_return, group_by=group_by, **wrap_kwargs)

    @cached_method
    def returns(self, group_by: tp.GroupByLike = None, in_sim_order=False,
                wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get return series per column/group based on portfolio value.&#34;&#34;&#34;
        value = to_2d(self.value(group_by=group_by, in_sim_order=in_sim_order), raw=True)
        if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
            group_lens = self.wrapper.grouper.get_group_lens()
            init_cash_grouped = to_1d(self.init_cash, raw=True)
            call_seq = to_2d(self.call_seq, raw=True)
            returns = nb.returns_in_sim_order_nb(value, group_lens, init_cash_grouped, call_seq)
        else:
            init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
            returns = nb.returns_nb(value, init_cash)
        return self.wrapper.wrap(returns, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def asset_returns(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get asset return series per column/group.

        This type of returns is based solely on cash flows and asset value rather than portfolio
        value. It ignores passive cash and thus it will return the same numbers irrespective of the amount of
        cash currently available, even `np.inf`. The scale of returns is comparable to that of going
        all in and keeping available cash at zero.&#34;&#34;&#34;
        cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
        asset_value = to_2d(self.asset_value(group_by=group_by), raw=True)
        asset_returns = nb.asset_returns_nb(cash_flow, asset_value)
        return self.wrapper.wrap(asset_returns, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def returns_acc(self,
                    group_by: tp.GroupByLike = None,
                    freq: tp.Optional[tp.FrequencyLike] = None,
                    year_freq: tp.Optional[tp.FrequencyLike] = None,
                    use_asset_returns: bool = False) -&gt; ReturnsAccessor:
        &#34;&#34;&#34;Get returns accessor of type `vectorbt.returns.accessors.ReturnsAccessor`.

        !!! hint
            You can find most methods of this accessor as (cacheable) attributes of this portfolio.&#34;&#34;&#34;
        if freq is None:
            freq = self.wrapper.freq
        if use_asset_returns:
            returns = self.asset_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
        return returns.vbt.returns(freq=freq, year_freq=year_freq)

    @cached_method
    def market_value(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get market (benchmark) value series per column/group.

        If grouped, evenly distributes the initial cash among assets in the group.

        !!! note
            Does not take into account fees and slippage. For this, create a separate portfolio.&#34;&#34;&#34;
        if self.fillna_close:
            close = to_2d(self.get_filled_close(), raw=True)
        else:
            close = to_2d(self.close, raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            init_cash_grouped = to_1d(self.get_init_cash(group_by=group_by), raw=True)
            market_value = nb.market_value_grouped_nb(close, group_lens, init_cash_grouped)
        else:
            init_cash = to_1d(self.get_init_cash(group_by=False), raw=True)
            market_value = nb.market_value_nb(close, init_cash)
        return self.wrapper.wrap(market_value, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_method
    def market_returns(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Get return series per column/group based on market (benchmark) value.&#34;&#34;&#34;
        market_value = to_2d(self.market_value(group_by=group_by), raw=True)
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        market_returns = nb.returns_nb(market_value, init_cash)
        return self.wrapper.wrap(market_returns, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    benchmark_rets = market_returns

    @cached_method
    def total_market_return(self, group_by: tp.GroupByLike = None,
                            wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Get total market (benchmark) return.&#34;&#34;&#34;
        market_value = to_2d(self.market_value(group_by=group_by), raw=True)
        total_market_return = nb.total_market_return_nb(market_value)
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total_market_return&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(total_market_return, group_by=group_by, **wrap_kwargs)

    # ############# Stats ############# #

    @property
    def common_settings(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Return dictionary of most commonly used settings.

        * freq: Index frequency in case it cannot be parsed from `close`.
        * year_freq: Year frequency for annualization purposes.
        * incl_unrealized: Whether to include open trades/positions in statistics.
        * use_asset_returns: Whether to use `Portfolio.asset_returns` when resolving `returns` argument.
        * use_positions: Whether to use `Portfolio.positions` when resolving `trades` argument.
        * use_caching: Whether to use built-in caching for resolved arguments.

            Works even if global caching is disabled.&#34;&#34;&#34;
        from vectorbt._settings import settings
        portfolio_stats_cfg = settings[&#39;portfolio&#39;][&#39;stats&#39;]
        returns_stats_cfg = settings[&#39;returns&#39;]

        return dict(
            freq=self.wrapper.freq,
            year_freq=returns_stats_cfg[&#39;year_freq&#39;],
            incl_unrealized=portfolio_stats_cfg[&#39;incl_unrealized&#39;],
            use_asset_returns=portfolio_stats_cfg[&#39;use_asset_returns&#39;],
            use_positions=portfolio_stats_cfg[&#39;use_positions&#39;],
            use_caching=portfolio_stats_cfg[&#39;use_caching&#39;]
        )

    def resolve_attr(self,
                     attr: str,
                     args: tp.ArgsLike = None,
                     cond_kwargs: tp.KwargsLike = None,
                     kwargs: tp.KwargsLike = None,
                     custom_arg_names: tp.Optional[tp.Container[str]] = None,
                     cache_dct: tp.KwargsLike = None) -&gt; tp.Any:
        &#34;&#34;&#34;Resolve attribute of the portfolio using keyword arguments and built-in caching.

        * If `attr` is a property, simply returns it.
        * If `attr` is a method, passes `*args`, `**kwargs`, and `**cond_kwargs` with keys found in the signature.
        * If `attr` is a property and there is a `get_{arg}` method, calls the `get_{arg}` method.

        Won&#39;t cache if any passed argument is in `custom_arg_names`.&#34;&#34;&#34;
        # Resolve defaults
        if custom_arg_names is None:
            custom_arg_names = list()
        if cache_dct is None:
            cache_dct = {}
        if args is None:
            args = ()
        if kwargs is None:
            kwargs = {}
        final_kwargs = merge_dicts(self.common_settings, cond_kwargs, kwargs)

        # Resolve attribute
        if attr == &#39;returns&#39; and final_kwargs[&#39;use_asset_returns&#39;]:
            attr = &#39;asset_returns&#39;
        if attr == &#39;trades&#39; and final_kwargs[&#39;use_positions&#39;]:
            attr = &#39;positions&#39;
        cls = type(self)
        _attr = attr
        if &#39;get_&#39; + attr in dir(cls):
            _attr = &#39;get_&#39; + attr
        if callable(getattr(cls, _attr)):
            attr_func = getattr(self, _attr)
            attr_func_kwargs = dict()
            attr_func_arg_names = get_func_arg_names(attr_func)
            custom_k = False
            for k, v in final_kwargs.items():
                if k in attr_func_arg_names or k in kwargs:
                    if k in custom_arg_names:
                        custom_k = True
                    attr_func_kwargs[k] = v
            if final_kwargs[&#39;use_caching&#39;] and not custom_k and attr in cache_dct:
                out = cache_dct[attr]
            else:
                out = attr_func(*args, **attr_func_kwargs)
                if attr in [&#39;trades&#39;, &#39;positions&#39;, &#39;drawdowns&#39;]:
                    if self.wrapper.freq != final_kwargs[&#39;freq&#39;]:
                        out = out.copy(wrapper=out.wrapper.copy(freq=final_kwargs[&#39;freq&#39;]))
                if attr in [&#39;trades&#39;, &#39;positions&#39;] and not final_kwargs[&#39;incl_unrealized&#39;]:
                    out = out.closed
                if final_kwargs[&#39;use_caching&#39;] and not custom_k:
                    cache_dct[attr] = out
        else:
            if final_kwargs[&#39;use_caching&#39;] and attr in cache_dct:
                out = cache_dct[attr]
            else:
                out = getattr(self, _attr)
                if final_kwargs[&#39;use_caching&#39;]:
                    cache_dct[attr] = out
        return out

    metrics: tp.ClassVar[Config] = Config(
        dict(
            bt_start=dict(
                title=&#39;Start&#39;,
                calc_func=lambda pf: pf.wrapper.index[0]
            ),
            bt_end=dict(
                title=&#39;End&#39;,
                calc_func=lambda pf: pf.wrapper.index[-1]
            ),
            bt_duration=dict(
                title=&#39;Duration&#39;,
                calc_func=lambda pf, freq: len(pf.wrapper.index) * (freq if freq is not None else 1)
            ),
            init_cash=dict(
                title=&#39;Initial Cash&#39;,
                calc_func=lambda pf, group_by: pf.get_init_cash(group_by=group_by)
            ),
            total_profit=dict(
                title=&#39;Total Profit&#39;,
                calc_func=lambda pf, group_by: pf.total_profit(group_by=group_by)
            ),
            total_return=dict(
                title=&#39;Total Return [%]&#39;,
                calc_func=lambda pf, group_by: pf.total_return(group_by=group_by) * 100
            ),
            benchmark_return=dict(
                title=&#39;Benchmark Return [%]&#39;,
                calc_func=lambda benchmark_rets: benchmark_rets.vbt.returns.total() * 100
            ),
            pos_coverage=dict(
                title=&#39;Position Coverage [%]&#39;,
                calc_func=lambda pf, group_by: pf.position_coverage(group_by=group_by) * 100
            ),
            max_dd=dict(
                title=&#39;Max Drawdown [%]&#39;,
                calc_func=lambda drawdowns: -drawdowns.max_drawdown() * 100
            ),
            avg_dd=dict(
                title=&#39;Avg Drawdown [%]&#39;,
                calc_func=lambda drawdowns: -drawdowns.avg_drawdown() * 100
            ),
            max_dd_duration=dict(
                title=&#39;Max Drawdown Duration&#39;,
                calc_func=lambda drawdowns, freq: drawdowns.max_duration(
                    wrap_kwargs=dict(time_units=freq is not None))
            ),
            avg_dd_duration=dict(
                title=&#39;Avg Drawdown Duration&#39;,
                calc_func=lambda drawdowns, freq: drawdowns.avg_duration(
                    wrap_kwargs=dict(time_units=freq is not None))
            ),
            trade_cnt=dict(
                title=&#39;Trade Count&#39;,
                calc_func=lambda trades: trades.count()
            ),
            win_rate=dict(
                title=&#39;Win Rate [%]&#39;,
                calc_func=lambda trades: trades.win_rate() * 100
            ),
            best_trade=dict(
                title=&#39;Best Trade [%]&#39;,
                calc_func=lambda trades: trades.returns.max() * 100
            ),
            worst_trade=dict(
                title=&#39;Worst Trade [%]&#39;,
                calc_func=lambda trades: trades.returns.min() * 100
            ),
            avg_trade=dict(
                title=&#39;Avg Trade [%]&#39;,
                calc_func=lambda trades: trades.returns.mean() * 100
            ),
            max_trade_duration=dict(
                title=&#39;Max Trade Duration&#39;,
                calc_func=lambda trades, freq: trades.duration.max(
                    wrap_kwargs=dict(time_units=freq is not None))
            ),
            avg_trade_duration=dict(
                title=&#39;Avg Trade Duration&#39;,
                calc_func=lambda trades, freq: trades.duration.mean(
                    wrap_kwargs=dict(time_units=freq is not None))
            ),
            expectancy=dict(
                title=&#39;Expectancy&#39;,
                calc_func=lambda trades: trades.expectancy()
            ),
            sqn=dict(
                title=&#39;SQN&#39;,
                calc_func=lambda trades: trades.sqn()
            ),
            gross_exposure=dict(
                title=&#39;Gross Exposure&#39;,
                calc_func=lambda pf, group_by: pf.gross_exposure(group_by=group_by).mean()
            ),
            sharpe_ratio=dict(
                title=&#39;Sharpe Ratio&#39;,
                req_freq=True,
                calc_func=&#39;returns_acc.sharpe_ratio&#39;
            ),
            sortino_ratio=dict(
                title=&#39;Sortino Ratio&#39;,
                req_freq=True,
                calc_func=&#39;returns_acc.sortino_ratio&#39;
            ),
            calmar_ratio=dict(
                title=&#39;Calmar Ratio&#39;,
                req_freq=True,
                calc_func=&#39;returns_acc.calmar_ratio&#39;
            )
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )
    &#34;&#34;&#34;Metrics supported by `Portfolio.stats`.
    
    !!! note
        It&#39;s safe to change this config - this instance variable is a (deep) copy of the class variable.
        
        Copying portfolio using `Portfolio.copy` won&#39;t create a copy of the config!&#34;&#34;&#34;

    def stats(self,
              metrics: tp.Optional[tp.MaybeIterable[tp.Union[str, tp.Tuple[str, tp.Kwargs]]]] = None,
              column: tp.Optional[tp.Label] = None,
              group_by: tp.GroupByLike = None,
              agg_func: tp.Optional[tp.Callable] = np.mean,
              silence_warnings: tp.Optional[bool] = None,
              template_mapping: tp.Optional[tp.Mapping] = None,
              global_settings: tp.DictLike = None,
              **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Compute various metrics on this portfolio.

        Args:
            metrics (str, tuple, iterable, or dict): List of metrics to calculate.

                Each element can be either:

                * a metric name (see keys in `Portfolio.metrics`)
                * a tuple of a metric name and a settings dict as in `Portfolio.metrics`.

                Each settings dict can contain the following keys:

                * `title`: title of the metric. Defaults to the name.
                * `allow_grouped`: whether this metric supports using grouped data. Defaults to True.
                    Must be known beforehand and cannot be provided as a template.
                * `req_freq`: whether this metric requires frequency. Defaults to False.
                    Must be known beforehand and cannot be provided as a template.
                * `calc_func`: calculation function for custom metrics. If the function can be accessed
                    by traversing attributes of this portfolio, you can pass the path to this function
                    as a string (see `vectorbt.utils.attr.deep_getattr` for the path format).
                    Should return either a scalar for one column/group or pd.Series for multiple columns/groups.
                * `pass_{arg}`: whether to pass a reserved argument (see below). Defaults to True if
                    this argument was found in the function&#39;s signature. Set to False to not pass.
                * `glob_pass_{arg}`: whether to pass an argument from `global_settings`. Defaults to True if
                    this argument was found both in `global_settings` and the function&#39;s signature.
                    Set to False to not pass.
                * `resolve_{arg}`: whether to resolve an argument that is meant to be an attribute of
                    the portfolio (see `Portfolio.resolve_attr`). Defaults to True if this argument was found
                    in the function&#39;s signature. Set to False to not resolve.
                * `template_mapping`: mapping to replace templates in metric settings and keyword arguments.
                    Used across all settings.
                * Any other keyword argument overrides reserved arguments or is passed directly to `calc_func`.

                A calculation function may accept any keyword argument. It may &#34;request&#34; any of the
                following reserved arguments by accepting them or if `pass_{arg}` was found in the settings dict:

                * `pf` or `portfolio`: original portfolio (ungrouped and with no column selected)
                * `column`
                * `group_by`
                * `metric_name`
                * `agg_func`
                * Any argument from `Portfolio.common_settings`
                * Any attribute of the portfolio if it meant to be resolved (see `Portfolio.resolve_attr`)

                Pass `metrics=&#39;all&#39;` to calculate all supported metrics.
            column (str): Name of the column/group.

                !!! hint
                    There are two ways to select a column: `pf[&#39;a&#39;].stats()` and `pf.stats(column=&#39;a&#39;)`.
                    They both accomplish the same thing but in different ways: `pf[&#39;a&#39;].stats()` computes
                    statistics of the column &#39;a&#39; only, while `pf.stats(column=&#39;a&#39;)` computes statistics of
                    all columns first and only then selects the column &#39;a&#39;. The first method is preferred
                    when you have a lot of data or caching is disabled. The second method is preferred when
                    most attributes have already been cached.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            agg_func (callable): Aggregation function to aggregate statistics across all columns.
                Defaults to mean.

                Should take `pd.Series` and return a const.

                Has only effect if `column` was specified or portfolio contains only one column of data.
                If `agg_func` has been overridden by a metric, it only takes effect if global `agg_func` is not None.
            silence_warnings (bool): Whether to silence all warnings.
            template_mapping (mapping): Global mapping to replace templates.

                Applied on `Portfolio.common_settings`, `global_settings`, and `kwargs`.
            global_settings (dict): Keyword arguments that override default settings for each metric.
                Additionally, passes any argument that has the matching key in the signature of `calc_func`.
                Use `glob_pass_{arg}` to force or ignore passing an argument.
            **kwargs: Additional keyword arguments.

                Can contain keyword arguments for each metric, specified as `{metric_name}_kwargs`.
                Can also contain keyword arguments that override arguments from `Portfolio.common_settings`.

        For template logic, see `vectorbt.utils.template`.

        For defaults, see `portfolio.stats` in `vectorbt._settings.settings`.

        !!! hint
            This method is very similar to `Portfolio.plot`.

            Make sure to resolve and then to re-use as many portfolio artifcats as possible to
            utilize built-in caching (even if global caching is disabled).

        !!! note
            This method is not cacheable as it depends on global defaults.
            But the portfolio artifacts it depends on are cacheable.

        ## Example

        Let&#39;s simulate a portfolio with two columns:

        ```python-repl
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; close = vbt.YFData.download(
        ...     &#34;BTC-USD&#34;,
        ...     start=&#39;2020-01-01 UTC&#39;,
        ...     end=&#39;2020-09-01 UTC&#39;
        ... ).get(&#39;Close&#39;)

        &gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(close, n=[10, 20], seed=42)
        &gt;&gt;&gt; pf.wrapper.columns
        Int64Index([10, 20], dtype=&#39;int64&#39;, name=&#39;rand_n&#39;)
        ```

        To return the statistics for a particular column/group, use the `column` argument:

        ```python-repl
        &gt;&gt;&gt; pf.stats(column=10)
        UserWarning: Metrics {&#39;calmar_ratio&#39;, &#39;sharpe_ratio&#39;, &#39;sortino_ratio&#39;} require frequency of index.
        Pass it as `freq` or define it globally under `settings.array_wrapper`.

        Start                    2020-01-01 00:00:00+00:00
        End                      2020-09-01 00:00:00+00:00
        Duration                                       244
        Initial Cash                                   100
        Total Profit                               6.72158
        Total Return [%]                           6.72158
        Benchmark Return [%]                       66.2526
        Position Coverage [%]                      51.2295
        Max Drawdown [%]                           22.1909
        Avg Drawdown [%]                           5.86559
        Max Drawdown Duration                          101
        Avg Drawdown Duration                       26.125
        Trade Count                                     10
        Win Rate [%]                                    60
        Best Trade [%]                             15.3196
        Worst Trade [%]                           -9.90422
        Avg Trade [%]                             0.862693
        Max Trade Duration                              23
        Avg Trade Duration                            12.5
        Expectancy                                0.672158
        SQN                                       0.324787
        Gross Exposure                            0.512295
        Name: 10, dtype: object
        ```

        If vectorbt couldn&#39;t parse the frequency of our `close`, it 1) won&#39;t return duration in
        time units and 2) won&#39;t return metrics that require annualization. We can provide the frequency
        manually either upon portfolio simulation or here:

        ```python-repl
        &gt;&gt;&gt; pf.stats(column=10, freq=&#39;d&#39;)
        Start                    2020-01-01 00:00:00+00:00
        End                      2020-09-01 00:00:00+00:00
        Duration                         244 days 00:00:00
        Initial Cash                                   100
        Total Profit                               6.72158
        Total Return [%]                           6.72158
        Benchmark Return [%]                       66.2526
        Position Coverage [%]                      51.2295
        Max Drawdown [%]                           22.1909
        Avg Drawdown [%]                           5.86559
        Max Drawdown Duration            101 days 00:00:00
        Avg Drawdown Duration             26 days 03:00:00
        Trade Count                                     10
        Win Rate [%]                                    60
        Best Trade [%]                             15.3196
        Worst Trade [%]                           -9.90422
        Avg Trade [%]                             0.862693
        Max Trade Duration                23 days 00:00:00
        Avg Trade Duration                12 days 12:00:00
        Expectancy                                0.672158
        SQN                                       0.324787
        Gross Exposure                            0.512295
        Sharpe Ratio                              0.369947
        Sortino Ratio                             0.587442
        Calmar Ratio                              0.313166
        Name: 10, dtype: object
        ```

        We can change the grouping of the portfolio on the fly. Let&#39;s form a single group:

        ```python-repl
        &gt;&gt;&gt; pf.stats(group_by=True, freq=&#39;d&#39;)
        Start                     2020-01-01 00:00:00+00:00
        End                       2020-09-01 00:00:00+00:00
        Duration                          244 days 00:00:00
        Initial Cash                                    200
        Total Profit                                 77.493
        Total Return [%]                            38.7465
        Benchmark Return [%]                        66.2526
        Position Coverage [%]                       48.9754
        Max Drawdown [%]                            14.2193
        Avg Drawdown [%]                            5.34082
        Max Drawdown Duration              86 days 00:00:00
        Avg Drawdown Duration    16 days 14:46:09.230769231
        Trade Count                                      30
        Win Rate [%]                                66.6667
        Best Trade [%]                              18.3326
        Worst Trade [%]                            -9.90422
        Avg Trade [%]                               2.26356
        Max Trade Duration                 23 days 00:00:00
        Avg Trade Duration                  7 days 23:12:00
        Expectancy                                   2.5831
        SQN                                         1.70984
        Gross Exposure                             0.488308
        Sharpe Ratio                                1.31206
        Sortino Ratio                               2.15761
        Calmar Ratio                                2.83025
        Name: group, dtype: object
        ```

        We can see how the initial cash has changed from $100 to $200, indicating that both columns
        contribute to the performance.

        If the portfolio consists of multiple columns/groups and no column/group has been selected,
        each metric is aggregated across all columns/groups based on `agg_func`, which is mean by default.

        ```python-repl
        &gt;&gt;&gt; pf.stats(freq=&#39;d&#39;)
        Taking mean across columns. To return a DataFrame, pass agg_func=None.

        Start                    2020-01-01 00:00:00+00:00
        End                      2020-09-01 00:00:00+00:00
        Duration                         244 days 00:00:00
        Initial Cash                                   100
        Total Profit                               38.7465
        Total Return [%]                           38.7465
        Benchmark Return [%]                       66.2526
        Position Coverage [%]                      48.9754
        Max Drawdown [%]                           20.3587
        Avg Drawdown [%]                           6.85197
        Max Drawdown Duration             93 days 00:00:00
        Avg Drawdown Duration             24 days 01:30:00
        Trade Count                                     15
        Win Rate [%]                                    65
        Best Trade [%]                             16.8261
        Worst Trade [%]                           -9.70127
        Avg Trade [%]                              1.91334
        Max Trade Duration                21 days 12:00:00
        Avg Trade Duration                 9 days 02:24:00
        Expectancy                                 2.10536
        SQN                                        1.03975
        Gross Exposure                            0.489754
        Sharpe Ratio                              0.968587
        Sortino Ratio                              1.73209
        Calmar Ratio                               2.14818
        Name: stats_mean, dtype: object
        ```

        Here, the Calmar ratio of 0.313166 (column=10) and 3.98318 (column=20) lead to the avarage of 2.14818.

        We can also return a DataFrame with statistics per column/group by passing `agg_func=None`:

        ```python-repl
        &gt;&gt;&gt; pf.stats(agg_func=None, freq=&#39;d&#39;)
                                   Start                       End Duration  ...  Calmar Ratio
        rand_n                                                               ...
        10     2020-01-01 00:00:00+00:00 2020-09-01 00:00:00+00:00 244 days  ...      0.313166
        20     2020-01-01 00:00:00+00:00 2020-09-01 00:00:00+00:00 244 days  ...      3.983185

        [2 rows x 25 columns]
        ```

        To select metrics, use the `metrics` argument (see `Portfolio.metrics` for supported metrics):

        ```python-repl
        &gt;&gt;&gt; pf.stats(metrics=[&#39;sharpe_ratio&#39;, &#39;sortino_ratio&#39;], column=10, freq=&#39;d&#39;)
        Sharpe Ratio     0.369947
        Sortino Ratio    0.587442
        Name: stats, dtype: float64
        ```

        To calculate a custom metric, we need to provide at least two things: short name and a settings
        dict with the title and calculation function (see arguments):

        ```python-repl
        &gt;&gt;&gt; profit_factor = (
        ...     &#39;profit_factor&#39;,
        ...     dict(
        ...         title=&#39;Profit Factor&#39;,
        ...         calc_func=lambda trades: trades.profit_factor()
        ...     )
        ... )
        &gt;&gt;&gt; pf.stats(metrics=profit_factor, column=10, freq=&#39;d&#39;)
        Profit Factor    1.347457
        Name: stats, dtype: float64
        ```

        Since `profit_factor` method can be expressed as a path from this portfolio, we can simply write:

        ```python-repl
        &gt;&gt;&gt; profit_factor = (
        ...     &#39;profit_factor&#39;,
        ...     dict(
        ...         title=&#39;Profit Factor&#39;,
        ...         calc_func=&#39;trades.profit_factor&#39;
        ...     )
        ... )
        ```

        In both cases, `trades` argument is an attribute of this portfolio and vectorbt automatically &#34;resolves&#34; it
        by passing any reserved argument that was found in its signature, such as `group_by`.
        If we want to stop `trades` (or any other attribute) from being resolved, just pass `resolve_trades=False`.
        In this case, vectorbt would simply call `portfolio.get_trades()` and give it to us.

        Any default metric setting or even global setting can be overridden by the user using metric-specific
        keyword arguments. Here, we override the global aggregation function for `max_trade_duration`:

        ```python-repl
        &gt;&gt;&gt; pf.stats(freq=&#39;d&#39;, agg_func=lambda sr: sr.mean(),
        ...     max_trade_duration_kwargs=dict(agg_func=lambda sr: sr.max()))
        ```

        Let&#39;s create a simple metric that returns frequency to demonstrate how vectorbt overrides settings,
        from least to most important:

        ```python-repl
        &gt;&gt;&gt; # common_defaults
        &gt;&gt;&gt; freq_metric = (&#39;freq_metric&#39;, dict(title=&#39;Freq&#39;, calc_func=lambda freq: freq))
        &gt;&gt;&gt; pf.stats(freq_metric, column=10)
        Freq    None
        Name: 10, dtype: object

        &gt;&gt;&gt; # kwargs with keys from common_defaults &gt;&gt;&gt; common_defaults
        &gt;&gt;&gt; pf.stats(freq_metric, column=10, freq=&#39;1m&#39;)
        Freq   0 days 00:01:00
        Name: 10, dtype: timedelta64[ns]

        &gt;&gt;&gt; # metric settings &gt;&gt;&gt; kwargs with keys from common_defaults
        &gt;&gt;&gt; def_freq_metric = (&#39;freq_metric&#39;, dict(title=&#39;Freq&#39;, freq=&#39;2m&#39;, calc_func=lambda freq: freq))
        &gt;&gt;&gt; pf.stats(def_freq_metric, column=10, freq=&#39;1m&#39;)
        Freq   0 days 00:02:00
        Name: 10, dtype: timedelta64[ns]

        &gt;&gt;&gt; # global_settings &gt;&gt;&gt; metric settings
        &gt;&gt;&gt; pf.stats(def_freq_metric, column=10, freq=&#39;1m&#39;,
        ...     global_settings=dict(freq=&#39;3m&#39;))
        Freq   0 days 00:03:00
        Name: 10, dtype: timedelta64[ns]

        &gt;&gt;&gt; # metric kwargs &gt;&gt;&gt; global_settings
        &gt;&gt;&gt; pf.stats(def_freq_metric, column=10, freq=&#39;1m&#39;,
        ...     global_settings=dict(freq=&#39;3m&#39;), freq_metric_kwargs=dict(freq=&#39;4m&#39;))
        Freq   0 days 00:04:00
        Name: 10, dtype: timedelta64[ns]
        ```

        Here&#39;s an example of a parametrized metric. Let&#39;s get the number of trades with P&amp;L over some amount:

        ```python-repl
        &gt;&gt;&gt; trade_min_pnl_cnt = (
        ...     &#39;trade_min_pnl_cnt&#39;,
        ...     dict(
        ...         title=vbt.Sub(&#39;Trades with P&amp;L over $$${min_pnl}&#39;),
        ...         calc_func=lambda trades, min_pnl: trades.filter_by_mask(
        ...             trades.pnl.values &gt;= min_pnl).count()
        ...     )
        ... )
        &gt;&gt;&gt; pf.stats(
        ...     metrics=trade_min_pnl_cnt, column=10, freq=&#39;d&#39;,
        ...     trade_min_pnl_cnt_kwargs=dict(min_pnl=0))
        Trades with P&amp;L over $0    6
        Name: stats, dtype: int64

        &gt;&gt;&gt; pf.stats(
        ...     metrics=trade_min_pnl_cnt, column=10, freq=&#39;d&#39;,
        ...     trade_min_pnl_cnt_kwargs=dict(min_pnl=10))
        Trades with P&amp;L over $10    1
        Name: stats, dtype: int64
        ```

        If the same metric name was encountered more than once, vectorbt automatically appends an
        underscore and its position, so we can pass keyword arguments to each metric separately:

        ```python-repl
        &gt;&gt;&gt; pf.stats(
        ...     metrics=[
        ...         trade_min_pnl_cnt,
        ...         trade_min_pnl_cnt,
        ...         trade_min_pnl_cnt
        ...     ],
        ...     column=10, freq=&#39;d&#39;,
        ...     trade_min_pnl_cnt_0_kwargs=dict(min_pnl=0),
        ...     trade_min_pnl_cnt_1_kwargs=dict(min_pnl=10),
        ...     trade_min_pnl_cnt_2_kwargs=dict(min_pnl=20))
        Trades with P&amp;L over $0     6
        Trades with P&amp;L over $10    1
        Trades with P&amp;L over $20    0
        Name: stats, dtype: int64
        ```

        To add a custom metric to the list of all metrics, we have three options.
        First, we can change the `Portfolio.metrics` dict in-place (this will append to the end):

        ```python-repl
        &gt;&gt;&gt; pf.metrics[&#39;profit_factor&#39;] = profit_factor[1]
        &gt;&gt;&gt; pf.stats(column=10, freq=&#39;d&#39;)
        Start                    2020-01-01 00:00:00+00:00
        End                      2020-09-01 00:00:00+00:00
        Duration                         244 days 00:00:00
        Initial Cash                                   100
        Total Profit                               6.72158
        Total Return [%]                           6.72158
        Benchmark Return [%]                       66.2526
        Position Coverage [%]                      51.2295
        Max Drawdown [%]                           22.1909
        Avg Drawdown [%]                           5.86559
        Max Drawdown Duration            101 days 00:00:00
        Avg Drawdown Duration             26 days 03:00:00
        Trade Count                                     10
        Win Rate [%]                                    60
        Best Trade [%]                             15.3196
        Worst Trade [%]                           -9.90422
        Avg Trade [%]                             0.862693
        Max Trade Duration                23 days 00:00:00
        Avg Trade Duration                12 days 12:00:00
        Expectancy                                0.672158
        SQN                                       0.324787
        Gross Exposure                            0.512295
        Sharpe Ratio                              0.369947
        Sortino Ratio                             0.587442
        Calmar Ratio                              0.313166
        Profit Factor                              1.34746   &lt;&lt; here
        Name: stats, dtype: object
        ```

        Since `Portfolio.metrics` is of type `vectorbt.utils.config.Config`, we can reset it at any time
        to get default metrics:

        ```python-repl
        &gt;&gt;&gt; pf.metrics.reset()
        ```

        The second option is to copy `Portfolio.metrics`, append our metric, and pass as `metrics` argument:

        ```python-repl
        &gt;&gt;&gt; my_metrics = list(pf.metrics.items()) + [profit_factor]
        &gt;&gt;&gt; pf.stats(metrics=my_metrics, column=10, freq=&#39;d&#39;)
        ```

        The last option is to set `metrics` globally under `portfolio.stats` in `vectorbt._settings.settings`.

        &gt;&gt;&gt; vbt.settings[&#39;portfolio&#39;][&#39;stats&#39;][&#39;metrics&#39;] = my_metrics
        &gt;&gt;&gt; pf.stats(column=10, freq=&#39;d&#39;)
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        portfolio_stats_cfg = settings[&#39;portfolio&#39;][&#39;stats&#39;]

        # Resolve defaults
        common_settings = self.common_settings
        for k in list(kwargs.keys()):
            if k in common_settings:
                common_settings[k] = kwargs.pop(k)
        if silence_warnings is None:
            silence_warnings = portfolio_stats_cfg[&#39;silence_warnings&#39;]
        template_mapping = merge_dicts(portfolio_stats_cfg[&#39;template_mapping&#39;], template_mapping)
        global_settings = merge_dicts(portfolio_stats_cfg[&#39;global_settings&#39;], global_settings)
        kwargs = merge_dicts(portfolio_stats_cfg[&#39;kwargs&#39;], kwargs)

        # Check if grouped
        is_grouped = self.wrapper.grouper.is_grouped(group_by=group_by)

        # Check if frequency is set
        has_freq = common_settings[&#39;freq&#39;] is not None

        # Replace templates globally
        if len(template_mapping) &gt; 0:
            common_settings = deep_substitute(common_settings, mapping=template_mapping)
            global_settings = deep_substitute(global_settings, mapping=template_mapping)
            kwargs = deep_substitute(kwargs, mapping=template_mapping)

        # Prepare metrics
        if metrics is None:
            metrics = portfolio_stats_cfg[&#39;metrics&#39;]
        if metrics == &#39;all&#39;:
            metrics = self.metrics
        if isinstance(metrics, dict):
            metrics = list(metrics.items())
        if isinstance(metrics, (str, tuple)):
            metrics = [metrics]
        # Bring to the same shape
        new_metrics = []
        for i, metric in enumerate(metrics):
            if isinstance(metric, str):
                metric = (metric, self.metrics[metric])
            if not isinstance(metric, tuple):
                raise TypeError(f&#34;Metric at index {i} must be either a string or a tuple&#34;)
            new_metrics.append(metric)
        metrics = new_metrics
        # Handle duplicate names
        metric_counts = Counter(list(map(lambda x: x[0], metrics)))
        metric_i = {k: -1 for k in metric_counts.keys()}
        metrics_dct = {}
        for i, (metric_name, metric_settings) in enumerate(metrics):
            if metric_counts[metric_name] &gt; 1:
                metric_i[metric_name] += 1
                metric_name = metric_name + &#39;_&#39; + str(metric_i[metric_name])
            metrics_dct[metric_name] = metric_settings
        # Merge settings
        custom_arg_names_dct = {}
        for metric_name, metric_settings in metrics_dct.items():
            passed_settings = kwargs.pop(f&#39;{metric_name}_kwargs&#39;, {})
            metrics_dct[metric_name] = merge_dicts(
                metric_settings,
                global_settings,
                passed_settings
            )
            custom_arg_names_dct[metric_name] = set(metric_settings.keys()).union(set(passed_settings.keys()))
        # Filter metrics
        if is_grouped:
            left_out_names = []
            for metric_name in list(metrics_dct.keys()):
                if not metrics_dct[metric_name].get(&#39;allow_grouped&#39;, True):
                    metrics_dct.pop(metric_name, None)
                    custom_arg_names_dct.pop(metric_name, None)
                    left_out_names.append(metric_name)
            if len(left_out_names) &gt; 0 and not silence_warnings:
                warnings.warn(f&#34;Metrics {left_out_names} do not support grouped data&#34;, stacklevel=2)
        if not has_freq:
            left_out_names = []
            for metric_name in list(metrics_dct.keys()):
                if metrics_dct[metric_name].get(&#39;req_freq&#39;, False):
                    metrics_dct.pop(metric_name, None)
                    custom_arg_names_dct.pop(metric_name, None)
                    left_out_names.append(metric_name)
            if len(left_out_names) &gt; 0 and not silence_warnings:
                warnings.warn(f&#34;Metrics {left_out_names} require frequency of index. &#34;
                              f&#34;Pass it as `freq` or define it globally under `settings.array_wrapper`.&#34;, stacklevel=2)
        if len(metrics_dct) == 0:
            raise ValueError(&#34;There is no metric to calculate&#34;)

        # Check kwargs
        if len(kwargs) &gt; 0:
            raise ValueError(f&#34;Keys {list(kwargs.keys())} could not be matched&#34;)

        # Run stats
        arg_cache_dct = {}
        stats_dct = {}
        for i, (metric_name, metric_settings) in enumerate(metrics_dct.items()):
            final_settings = metric_settings.copy()
            final_settings.pop(&#39;allow_grouped&#39;, None)
            final_settings.pop(&#39;req_freq&#39;, None)

            # Replace templates
            reserved_settings = merge_dicts(
                dict(
                    pf=self,
                    portfolio=self,
                    column=column,
                    group_by=group_by,
                    metric_name=metric_name,
                    agg_func=agg_func
                ),
                common_settings
            )
            reserved_arg_names = set(reserved_settings.keys())
            final_settings = merge_dicts(reserved_settings, final_settings)
            metric_template_mapping = final_settings.pop(&#39;template_mapping&#39;, {})
            mapping = merge_dicts(final_settings, template_mapping, metric_template_mapping)
            final_settings = deep_substitute(final_settings, mapping=mapping)
            if final_settings[&#39;freq&#39;] is not None:
                final_settings[&#39;freq&#39;] = freq_to_timedelta(final_settings[&#39;freq&#39;])

            # Get and pop values
            _column = final_settings.get(&#39;column&#39;)
            _group_by = final_settings.get(&#39;group_by&#39;)
            _agg_func = final_settings.get(&#39;agg_func&#39;)
            title = final_settings.pop(&#39;title&#39;, metric_name)
            calc_func = final_settings.pop(&#39;calc_func&#39;)

            # Prepare function and keyword arguments
            custom_arg_names = custom_arg_names_dct[metric_name]
            if not callable(calc_func):
                def _getattr_func(obj: tp.Any,
                                  attr: str,
                                  args: tp.ArgsLike = None,
                                  kwargs: tp.KwargsLike = None,
                                  call_attr: bool = True,
                                  _custom_arg_names: tp.Set[str] = custom_arg_names,
                                  _arg_cache_dct: tp.Kwargs = arg_cache_dct,
                                  _final_settings: tp.Kwargs = final_settings) -&gt; tp.Any:
                    if args is None:
                        args = ()
                    if kwargs is None:
                        kwargs = {}
                    if obj is self and _final_settings.pop(&#39;resolve_&#39; + attr, True):
                        if call_attr:
                            return self.resolve_attr(
                                attr,
                                args=args,
                                cond_kwargs=_final_settings,
                                kwargs=kwargs,
                                custom_arg_names=_custom_arg_names,
                                cache_dct=_arg_cache_dct
                            )
                        return getattr(obj, attr)
                    out = getattr(obj, attr)
                    if callable(out) and call_attr:
                        return out(*args, **kwargs)
                    return out

                calc_func = self.getattr(calc_func, getattr_func=_getattr_func, call_last_attr=False)
            if not callable(calc_func):
                raise TypeError(&#34;calc_func must be callable&#34;)

            func_arg_names = get_func_arg_names(calc_func)
            for k in func_arg_names:
                if k not in final_settings:
                    if final_settings.pop(&#39;resolve_&#39; + k, True):
                        try:
                            arg_out = self.resolve_attr(
                                k,
                                cond_kwargs=final_settings,
                                custom_arg_names=custom_arg_names,
                                cache_dct=arg_cache_dct
                            )
                        except AttributeError:
                            continue
                        final_settings[k] = arg_out

            for k in reserved_arg_names:
                if &#39;pass_&#39; + k in final_settings:
                    if not final_settings.pop(&#39;pass_&#39; + k):  # first priority
                        final_settings.pop(k, None)
                elif k not in func_arg_names:  # second priority
                    final_settings.pop(k, None)
            for k in list(final_settings.keys()):
                if &#39;glob_pass_&#39; + k in final_settings:
                    if k not in global_settings or not final_settings.pop(&#39;glob_pass_&#39; + k, True):
                        final_settings.pop(k, None)  # global setting should not be utilized
                else:
                    if k in global_settings and k not in custom_arg_names and k not in func_arg_names:
                        final_settings.pop(k, None)  # global setting not utilized
            for k in list(final_settings.keys()):
                if k.startswith(&#39;glob_pass_&#39;):
                    final_settings.pop(k, None)  # cleanup

            # Call calculation function
            out = calc_func(**final_settings)

            # Post-process and store the metric
            if checks.is_any_array(out) and not checks.is_series(out):
                raise TypeError(&#34;calc_func must return either a scalar for one column/group &#34;
                                &#34;or pd.Series for multiple columns/groups&#34;)
            if checks.is_series(out):
                if _column is not None:
                    out = self.select_one_from_obj(out, self.wrapper.regroup(_group_by), column=_column)
                elif _agg_func is not None and agg_func is not None:
                    out = _agg_func(out)
            stats_dct[title] = out

        # Return the stats
        if self.wrapper.get_ndim(group_by=group_by) == 1:
            return pd.Series(stats_dct, name=self.wrapper.get_columns(group_by=group_by)[0])
        if column is not None:
            return pd.Series(stats_dct, name=column)
        if agg_func is not None:
            return pd.Series(stats_dct, name=&#39;agg_func_&#39; + agg_func.__name__)
        new_index = self.wrapper.grouper.get_columns(group_by=group_by)
        stats_df = pd.DataFrame(stats_dct, index=new_index)
        return stats_df

    def returns_stats(self,
                      column: tp.Optional[tp.Label] = None,
                      group_by: tp.GroupByLike = None,
                      use_asset_returns: bool = False,
                      in_sim_order: bool = False,
                      agg_func: tp.Optional[tp.Callable] = np.mean,
                      year_freq: tp.Optional[tp.FrequencyLike] = None,
                      **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Compute various statistics on returns of this portfolio.

        For keyword arguments and notes, see `Portfolio.stats`.

        `kwargs` will be passed to `vectorbt.returns.accessors.ReturnsAccessor.stats` method.
        If `benchmark_rets` is not set, uses `Portfolio.market_returns`.&#34;&#34;&#34;
        # Pre-calculate
        if use_asset_returns:
            returns = self.asset_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)

        # Run stats
        if &#39;benchmark_rets&#39; not in kwargs:
            kwargs[&#39;benchmark_rets&#39;] = self.market_returns(group_by=group_by)
        stats_obj = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq).stats(**kwargs)

        # Select columns or reduce
        if checks.is_series(stats_obj):
            return stats_obj
        if column is not None:
            return stats_obj.loc[column]
        if agg_func is not None:
            if agg_func == np.mean:
                warnings.warn(&#34;Taking mean across columns. To return a DataFrame, pass agg_func=None.&#34;, stacklevel=2)
                func_name = &#39;stats_mean&#39;
            else:
                func_name = &#39;stats_&#39; + agg_func.__name__
            agg_stats_sr = pd.Series(index=stats_obj.columns, name=func_name)
            agg_stats_sr.iloc[:3] = stats_obj.iloc[0, :3]
            agg_stats_sr.iloc[3:] = agg_func(stats_obj.iloc[:, 3:])
            return agg_stats_sr
        return stats_obj

    # ############# Plotting ############# #

    def plot_asset_flow(self,
                        column: tp.Optional[tp.Label] = None,
                        direction: str = &#39;all&#39;,
                        xref: str = &#39;x&#39;,
                        yref: str = &#39;y&#39;,
                        hline_shape_kwargs: tp.KwargsLike = None,
                        **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column of asset flow.

        Args:
            column (str): Name of the column to plot.
            direction (Direction): See `vectorbt.portfolio.enums.Direction`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.plot`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;brown&#39;]
                ),
                name=&#39;Assets&#39;
            )
        ), kwargs)
        asset_flow = self.asset_flow(direction=direction)
        asset_flow = self.select_one_from_obj(asset_flow, self.wrapper.regroup(False), column=column)
        fig = asset_flow.vbt.plot(**kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=0,
            x1=x_domain[1],
            y1=0
        ), hline_shape_kwargs))
        return fig

    def plot_cash_flow(self,
                       column: tp.Optional[tp.Label] = None,
                       group_by: tp.GroupByLike = None,
                       free: bool = False,
                       xref: str = &#39;x&#39;,
                       yref: str = &#39;y&#39;,
                       hline_shape_kwargs: tp.KwargsLike = None,
                       **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of cash flow.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            free (bool): Whether to plot the flow of the free cash.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.plot`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;green&#39;]
                ),
                name=&#39;Cash&#39;
            )
        ), kwargs)
        cash_flow = self.cash_flow(group_by=group_by, free=free)
        cash_flow = self.select_one_from_obj(cash_flow, self.wrapper.regroup(group_by), column=column)
        fig = cash_flow.vbt.plot(**kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=0.,
            x1=x_domain[1],
            y1=0.
        ), hline_shape_kwargs))
        return fig

    def plot_assets(self,
                    column: tp.Optional[tp.Label] = None,
                    direction: str = &#39;all&#39;,
                    xref: str = &#39;x&#39;,
                    yref: str = &#39;y&#39;,
                    hline_shape_kwargs: tp.KwargsLike = None,
                    **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column of assets.

        Args:
            column (str): Name of the column to plot.
            direction (Direction): See `vectorbt.portfolio.enums.Direction`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;brown&#39;]
                ),
                name=&#39;Assets&#39;
            ),
            pos_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;brown&#39;], 0.3)
            ),
            neg_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;orange&#39;], 0.3)
            ),
            other_trace_kwargs=&#39;hidden&#39;
        ), kwargs)
        assets = self.assets(direction=direction)
        assets = self.select_one_from_obj(assets, self.wrapper.regroup(False), column=column)
        fig = assets.vbt.plot_against(0, **kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=0.,
            x1=x_domain[1],
            y1=0.
        ), hline_shape_kwargs))
        return fig

    def plot_cash(self,
                  column: tp.Optional[tp.Label] = None,
                  group_by: tp.GroupByLike = None,
                  free: bool = False,
                  xref: str = &#39;x&#39;,
                  yref: str = &#39;y&#39;,
                  hline_shape_kwargs: tp.KwargsLike = None,
                  **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of cash balance.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            free (bool): Whether to plot the flow of the free cash.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;green&#39;]
                ),
                name=&#39;Cash&#39;
            ),
            pos_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;green&#39;], 0.3)
            ),
            neg_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;red&#39;], 0.3)
            ),
            other_trace_kwargs=&#39;hidden&#39;
        ), kwargs)
        init_cash = self.get_init_cash(group_by=group_by)
        init_cash = self.select_one_from_obj(init_cash, self.wrapper.regroup(group_by), column=column)
        cash = self.cash(group_by=group_by, free=free)
        cash = self.select_one_from_obj(cash, self.wrapper.regroup(group_by), column=column)
        fig = cash.vbt.plot_against(init_cash, **kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=init_cash,
            x1=x_domain[1],
            y1=init_cash
        ), hline_shape_kwargs))
        return fig

    def plot_asset_value(self,
                         column: tp.Optional[tp.Label] = None,
                         group_by: tp.GroupByLike = None,
                         direction: str = &#39;all&#39;,
                         xref: str = &#39;x&#39;,
                         yref: str = &#39;y&#39;,
                         hline_shape_kwargs: tp.KwargsLike = None,
                         **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of asset value.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            direction (Direction): See `vectorbt.portfolio.enums.Direction`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;cyan&#39;]
                ),
                name=&#39;Asset Value&#39;
            ),
            pos_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;cyan&#39;], 0.3)
            ),
            neg_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;orange&#39;], 0.3)
            ),
            other_trace_kwargs=&#39;hidden&#39;
        ), kwargs)
        asset_value = self.asset_value(direction=direction, group_by=group_by)
        asset_value = self.select_one_from_obj(asset_value, self.wrapper.regroup(group_by), column=column)
        fig = asset_value.vbt.plot_against(0, **kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=0.,
            x1=x_domain[1],
            y1=0.
        ), hline_shape_kwargs))
        return fig

    def plot_value(self,
                   column: tp.Optional[tp.Label] = None,
                   group_by: tp.GroupByLike = None,
                   xref: str = &#39;x&#39;,
                   yref: str = &#39;y&#39;,
                   hline_shape_kwargs: tp.KwargsLike = None,
                   **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of value.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            free (bool): Whether to plot free cash flow.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;purple&#39;]
                ),
                name=&#39;Value&#39;
            ),
            other_trace_kwargs=&#39;hidden&#39;
        ), kwargs)
        init_cash = self.get_init_cash(group_by=group_by)
        init_cash = self.select_one_from_obj(init_cash, self.wrapper.regroup(group_by), column=column)
        value = self.value(group_by=group_by)
        value = self.select_one_from_obj(value, self.wrapper.regroup(group_by), column=column)
        fig = value.vbt.plot_against(init_cash, **kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=init_cash,
            x1=x_domain[1],
            y1=init_cash
        ), hline_shape_kwargs))
        return fig

    def plot_cum_returns(self,
                         column: tp.Optional[tp.Label] = None,
                         group_by: tp.GroupByLike = None,
                         asset_returns: bool = False,
                         **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of cumulative returns.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            asset_returns (bool): Whether to plot asset returns.
            **kwargs: Keyword arguments passed to `vectorbt.returns.accessors.ReturnsSRAccessor.plot_cum_returns`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        market_returns = self.market_returns(group_by=group_by)
        market_returns = self.select_one_from_obj(market_returns, self.wrapper.regroup(group_by), column=column)
        kwargs = merge_dicts(dict(
            benchmark_rets=market_returns,
            main_kwargs=dict(
                trace_kwargs=dict(
                    line=dict(
                        color=plotting_cfg[&#39;color_schema&#39;][&#39;purple&#39;]
                    ),
                    name=&#39;Value&#39;
                )
            ),
            hline_shape_kwargs=dict(
                type=&#39;line&#39;,
                line=dict(
                    color=&#39;gray&#39;,
                    dash=&#34;dash&#34;,
                )
            )
        ), kwargs)
        if asset_returns:
            returns = self.asset_returns(group_by=group_by)
        else:
            returns = self.returns(group_by=group_by)
        returns = self.select_one_from_obj(returns, self.wrapper.regroup(group_by), column=column)
        return returns.vbt.returns.plot_cum_returns(**kwargs)

    def plot_drawdowns(self,
                       column: tp.Optional[tp.Label] = None,
                       group_by: tp.GroupByLike = None,
                       **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of drawdowns.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            **kwargs: Keyword arguments passed to `vectorbt.generic.drawdowns.Drawdowns.plot`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            ts_trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;purple&#39;]
                ),
                name=&#39;Value&#39;
            )
        ), kwargs)
        return self.get_drawdowns(group_by=group_by).plot(column=column, **kwargs)

    def plot_underwater(self,
                        column: tp.Optional[tp.Label] = None,
                        group_by: tp.GroupByLike = None,
                        xref: str = &#39;x&#39;,
                        yref: str = &#39;y&#39;,
                        hline_shape_kwargs: tp.KwargsLike = None,
                        **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of underwater.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.plot`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;red&#39;]
                ),
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;red&#39;], 0.3),
                fill=&#39;tozeroy&#39;,
                name=&#39;Drawdown&#39;
            )
        ), kwargs)
        drawdown = self.drawdown(group_by=group_by)
        drawdown = self.select_one_from_obj(drawdown, self.wrapper.regroup(group_by), column=column)
        fig = drawdown.vbt.plot(**kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=0,
            x1=x_domain[1],
            y1=0
        ), hline_shape_kwargs))
        yaxis = &#39;yaxis&#39; + yref[1:]
        fig.layout[yaxis][&#39;tickformat&#39;] = &#39;%&#39;
        return fig

    def plot_gross_exposure(self,
                            column: tp.Optional[tp.Label] = None,
                            group_by: tp.GroupByLike = None,
                            direction: str = &#39;all&#39;,
                            xref: str = &#39;x&#39;,
                            yref: str = &#39;y&#39;,
                            hline_shape_kwargs: tp.KwargsLike = None,
                            **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of gross exposure.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            direction (Direction): See `vectorbt.portfolio.enums.Direction`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;pink&#39;]
                ),
                name=&#39;Exposure&#39;
            ),
            pos_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;orange&#39;], 0.3)
            ),
            neg_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;pink&#39;], 0.3)
            ),
            other_trace_kwargs=&#39;hidden&#39;
        ), kwargs)
        gross_exposure = self.gross_exposure(direction=direction, group_by=group_by)
        gross_exposure = self.select_one_from_obj(gross_exposure, self.wrapper.regroup(group_by), column=column)
        fig = gross_exposure.vbt.plot_against(1, **kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=1,
            x1=x_domain[1],
            y1=1
        ), hline_shape_kwargs))
        return fig

    def plot_net_exposure(self,
                          column: tp.Optional[tp.Label] = None,
                          group_by: tp.GroupByLike = None,
                          xref: str = &#39;x&#39;,
                          yref: str = &#39;y&#39;,
                          hline_shape_kwargs: tp.KwargsLike = None,
                          **kwargs) -&gt; tp.BaseFigure:
        &#34;&#34;&#34;Plot one column/group of net exposure.

        Args:
            column (str): Name of the column/group to plot.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        kwargs = merge_dicts(dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;pink&#39;]
                ),
                name=&#39;Exposure&#39;
            ),
            pos_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;pink&#39;], 0.3)
            ),
            neg_trace_kwargs=dict(
                fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;orange&#39;], 0.3)
            ),
            other_trace_kwargs=&#39;hidden&#39;
        ), kwargs)
        net_exposure = self.net_exposure(group_by=group_by)
        net_exposure = self.select_one_from_obj(net_exposure, self.wrapper.regroup(group_by), column=column)
        fig = net_exposure.vbt.plot_against(0, **kwargs)
        x_domain = get_domain(xref, fig)
        fig.add_shape(**merge_dicts(dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            ),
            xref=&#34;paper&#34;,
            yref=yref,
            x0=x_domain[0],
            y0=0,
            x1=x_domain[1],
            y1=0
        ), hline_shape_kwargs))
        return fig

    subplots: tp.ClassVar[Config] = Config(
        dict(
            orders=dict(
                title=&#34;Orders&#34;,
                yaxis_title=&#34;Price&#34;,
                allow_grouped=False,
                plot_func=[(&#39;get_orders&#39;, (Rep(&#39;group_by&#39;),)), &#39;plot&#39;]
            ),
            trades=dict(
                title=&#34;Trades&#34;,
                yaxis_title=&#34;Price&#34;,
                allow_grouped=False,
                plot_func=[(&#39;get_trades&#39;, (Rep(&#39;group_by&#39;),)), &#39;plot&#39;]
            ),
            positions=dict(
                title=&#34;Positions&#34;,
                yaxis_title=&#34;Price&#34;,
                allow_grouped=False,
                plot_func=[(&#39;get_positions&#39;, (Rep(&#39;group_by&#39;),)), &#39;plot&#39;]
            ),
            trade_pnl=dict(
                title=&#34;Trade P&amp;L&#34;,
                yaxis_title=&#34;Trade P&amp;L&#34;,
                allow_grouped=False,
                plot_func=[(&#39;get_trades&#39;, (Rep(&#39;group_by&#39;),)), &#39;plot_pnl&#39;],
                pass_column=True,  # hidden behind **kwargs
                pass_hline_shape_kwargs=True,  # hidden behind **kwargs
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
                pass_xref=True,  # hidden behind **kwargs
                pass_yref=True  # hidden behind **kwargs
            ),
            position_pnl=dict(
                title=&#34;Position P&amp;L&#34;,
                yaxis_title=&#34;Position P&amp;L&#34;,
                allow_grouped=False,
                plot_func=[(&#39;get_positions&#39;, (Rep(&#39;group_by&#39;),)), &#39;plot_pnl&#39;],
                pass_column=True,  # hidden behind **kwargs
                pass_hline_shape_kwargs=True,  # hidden behind **kwargs
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
                pass_xref=True,  # hidden behind **kwargs
                pass_yref=True  # hidden behind **kwargs
            ),
            trade_returns=dict(
                title=&#34;Trade Returns&#34;,
                yaxis_title=&#34;Trade returns&#34;,
                allow_grouped=False,
                plot_func=[(&#39;get_trades&#39;, (Rep(&#39;group_by&#39;),)), &#39;plot_returns&#39;],
                pass_column=True,  # hidden behind **kwargs
                pass_hline_shape_kwargs=True,  # hidden behind **kwargs
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
                pass_xref=True,  # hidden behind **kwargs
                pass_yref=True  # hidden behind **kwargs
            ),
            position_returns=dict(
                title=&#34;Position Returns&#34;,
                yaxis_title=&#34;Position returns&#34;,
                allow_grouped=False,
                plot_func=[(&#39;get_positions&#39;, (Rep(&#39;group_by&#39;),)), &#39;plot_returns&#39;],
                pass_column=True,  # hidden behind **kwargs
                pass_hline_shape_kwargs=True,  # hidden behind **kwargs
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
                pass_xref=True,  # hidden behind **kwargs
                pass_yref=True  # hidden behind **kwargs
            ),
            asset_flow=dict(
                title=&#34;Asset Flow&#34;,
                yaxis_title=&#34;Asset flow&#34;,
                allow_grouped=False,
                plot_func=&#39;plot_asset_flow&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            cash_flow=dict(
                title=&#34;Cash Flow&#34;,
                yaxis_title=&#34;Cash flow&#34;,
                plot_func=&#39;plot_cash_flow&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            assets=dict(
                title=&#34;Assets&#34;,
                yaxis_title=&#34;Assets&#34;,
                allow_grouped=False,
                plot_func=&#39;plot_assets&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            cash=dict(
                title=&#34;Cash&#34;,
                yaxis_title=&#34;Cash&#34;,
                plot_func=&#39;plot_cash&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            asset_value=dict(
                title=&#34;Asset Value&#34;,
                yaxis_title=&#34;Asset value&#34;,
                plot_func=&#39;plot_asset_value&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            value=dict(
                title=&#34;Value&#34;,
                yaxis_title=&#34;Value&#34;,
                plot_func=&#39;plot_value&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            cum_returns=dict(
                title=&#34;Cumulative Returns&#34;,
                yaxis_title=&#34;Cumulative returns&#34;,
                plot_func=&#39;plot_cum_returns&#39;,
                pass_hline_shape_kwargs=True,  # hidden behind **kwargs
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
                pass_xref=True,  # hidden behind **kwargs
                pass_yref=True  # hidden behind **kwargs
            ),
            drawdowns=dict(
                title=&#34;Drawdowns&#34;,
                yaxis_title=&#34;Value&#34;,
                plot_func=&#39;plot_drawdowns&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
                pass_xref=True,  # hidden behind **kwargs
                pass_yref=True  # hidden behind **kwargs
            ),
            underwater=dict(
                title=&#34;Underwater&#34;,
                yaxis_title=&#34;Drawdown&#34;,
                plot_func=&#39;plot_underwater&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            gross_exposure=dict(
                title=&#34;Gross Exposure&#34;,
                yaxis_title=&#34;Gross exposure&#34;,
                plot_func=&#39;plot_gross_exposure&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            ),
            net_exposure=dict(
                title=&#34;Net Exposure&#34;,
                yaxis_title=&#34;Net exposure&#34;,
                plot_func=&#39;plot_net_exposure&#39;,
                pass_add_trace_kwargs=True,  # hidden behind **kwargs
            )
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )
    &#34;&#34;&#34;Subplots supported by `Portfolio.plot`.
    
    !!! note
        It&#39;s safe to change this config - this instance variable is a (deep) copy of the class variable.
        
        Copying portfolio using `Portfolio.copy` won&#39;t create a copy of the config!&#34;&#34;&#34;

    def plot(self,
             subplots: tp.Optional[tp.MaybeIterable[tp.Union[str, tp.Tuple[str, tp.Kwargs]]]] = None,
             column: tp.Optional[tp.Label] = None,
             group_by: tp.GroupByLike = None,
             show_titles: bool = None,
             hide_id_labels: bool = None,
             group_id_labels: bool = None,
             make_subplots_kwargs: tp.KwargsLike = None,
             hline_shape_kwargs: tp.KwargsLike = None,
             silence_warnings: bool = None,
             template_mapping: tp.Optional[tp.Mapping] = None,
             **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
        &#34;&#34;&#34;Plot various parts of this portfolio.

        Args:
            subplots (str, tuple, iterable, or dict): List of subplots to plot.

                Each element can be either:

                * a subplot name (see keys in `Portfolio.subplots`)
                * a tuple of a subplot name and a settings dict as in `Portfolio.subplots`.

                Each settings dict can contain the following keys:

                * `title`: title of the subplot. Defaults to None.
                * `yaxis_title`: title of the y-axis. Defaults to `title`.
                * `xaxis_title`: title of the x-axis. Defaults to &#39;Date&#39;.
                * `allow_grouped`: whether this subplot supports grouped data. Defaults to True.
                    Must be known beforehand and cannot be provided as a template.
                * `plot_func`: plotting function for custom subplots. If the function can be accessed
                    by traversing attributes of this portfolio, you can pass the path to this function
                    as a string (see `vectorbt.utils.attr.deep_getattr` for the path format).
                * `pass_{arg}`: whether to pass a reserved argument (see below). Defaults to True if
                    this argument was found in the function&#39;s signature. Set to False to not pass.
                * `template_mapping`: mapping to replace templates in subplot settings and keyword arguments.
                    Used across all settings.
                * Any other keyword argument overrides reserved arguments or is passed directly to `plot_func`.

                A plotting function may accept any keyword argument, but it should accept the current figure via
                a `fig` keyword argument. It may also &#34;request&#34; any of the following reserved arguments by
                accepting them or if `pass_{arg}` was found in the settings dict:

                * `portfolio`: original portfolio (ungrouped and with no column selected)
                * `column`
                * `group_by`
                * `subplot_name`
                * `trace_names`: list with the subplot name
                * `add_trace_kwargs`
                * `xref`
                * `yref`
                * `xaxis`
                * `yaxis`
                * `x_domain`
                * `y_domain`
                * `hline_shape_kwargs`

                Pass `subplots=&#39;all&#39;` to plot all supported subplots.
            column (str): Name of the column/group to plot.

                Won&#39;t have effect on this portfolio, but passed down to each plotting function.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.

                Won&#39;t have effect on this portfolio, but passed down to each plotting function.
            show_titles (bool): Whether to show the title of each subplot.
            hide_id_labels (bool): Whether to hide identical legend labels.

                Two labels are identical if their name, marker style and line style match.
            group_id_labels (bool): Whether to group identical legend labels.
            make_subplots_kwargs (dict): Keyword arguments passed to `plotly.subplots.make_subplots`.
            hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
            silence_warnings (bool): Whether to silence all warnings.
            template_mapping (mapping): Global mapping to replace templates.

                Applied on both subplot settings and `kwargs`.
            **kwargs: Additional keyword arguments.

                Can contain keyword arguments for each subplot, specified as `{subplot_name}_kwargs`.
                Other keyword arguments are used to update the layout of the figure.

        For template logic, see `vectorbt.utils.template`.

        For defaults, see `portfolio.plot` in `vectorbt._settings.settings`.

        !!! hint
            This method is very similar to `Portfolio.stats`.

        ## Example

        Plot portfolio of a random strategy:

        ```python-repl
        &gt;&gt;&gt; import vectorbt as vbt

        &gt;&gt;&gt; close = vbt.YFData.download(
        ...     &#34;BTC-USD&#34;,
        ...     start=&#39;2020-01-01 UTC&#39;,
        ...     end=&#39;2020-09-01 UTC&#39;
        ... ).get(&#39;Close&#39;)

        &gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(close, n=10, seed=42)
        &gt;&gt;&gt; pf.plot()
        ```

        ![](/vectorbt/docs/img/portfolio_plot.svg)

        You can choose any of the subplots in `Portfolio.subplots`, in any order, and
        control their appearance using keyword arguments:

        ```python-repl
        &gt;&gt;&gt; from vectorbt.utils.colors import adjust_opacity

        &gt;&gt;&gt; pf.plot(
        ...     subplots=[&#39;drawdowns&#39;, &#39;underwater&#39;],
        ...     drawdowns_kwargs=dict(top_n=3),
        ...     underwater_kwargs=dict(
        ...         trace_kwargs=dict(
        ...             line=dict(color=&#39;#FF6F00&#39;),
        ...             fillcolor=adjust_opacity(&#39;#FF6F00&#39;, 0.3)
        ...         )
        ...     )
        ... )
        ```

        ![](/vectorbt/docs/img/portfolio_plot_drawdowns.svg)

        To create a new subplot, a preferred way is to pass a plotting function:

        ```python-repl
        &gt;&gt;&gt; def plot_order_size(size, add_trace_kwargs=None, fig=None):
        ...     size.rename(&#39;Order Size&#39;).vbt.barplot(
        ...         add_trace_kwargs=add_trace_kwargs, fig=fig)

        &gt;&gt;&gt; order_size = pf.orders.size.to_pd(default_val=0.)
        &gt;&gt;&gt; pf.plot(subplots=[
        ...     &#39;orders&#39;,
        ...     (&#39;order_size&#39;, dict(
        ...         title=&#39;Order Size&#39;,
        ...         yaxis_title=&#39;Order size&#39;,
        ...         allow_grouped=False,
        ...         plot_func=plot_order_size
        ...     ))
        ... ], order_size_kwargs=dict(size=order_size))
        ```

        Alternatively, you can create a placeholder and overwrite it manually later:

        ```python-repl
        &gt;&gt;&gt; fig = pf.plot(subplots=[
        ...     &#39;orders&#39;,
        ...     (&#39;order_size&#39;, dict(
        ...         title=&#39;Order Size&#39;,
        ...         yaxis_title=&#39;Order size&#39;,
        ...         allow_grouped=False
        ...     ))  # placeholder
        ... ])
        &gt;&gt;&gt; order_size.rename(&#39;Order Size&#39;).vbt.barplot(
        ...     add_trace_kwargs=dict(row=2, col=1), fig=fig)
        ```

        ![](/vectorbt/docs/img/portfolio_plot_custom.svg)

        If a plotting function can in any way be accessed from the current portfolio, you can pass
        the path to this function (see `vectorbt.utils.attr.deep_getattr` for the path format).
        You can additionally use templates to make some parameters to depend upon passed keyword arguments:

        ```python-repl
        &gt;&gt;&gt; subplots = [
        ...     (&#39;cumulative_returns&#39;, dict(
        ...         title=&#39;Cumulative Returns&#39;,
        ...         yaxis_title=&#39;Cumulative returns&#39;,
        ...         plot_func=&#39;returns.vbt.returns.cumulative.vbt.plot&#39;,
        ...         pass_add_trace_kwargs=True  # hidden behind **kwargs in vbt.plot
        ...     )),
        ...     (&#39;rolling_drawdown&#39;, dict(
        ...         title=&#39;Rolling Drawdown&#39;,
        ...         yaxis_title=&#39;Rolling drawdown&#39;,
        ...         plot_func=[
        ...             &#39;returns.vbt.returns&#39;,  # returns accessor
        ...             (
        ...                 &#39;rolling_max_drawdown&#39;,  # function name
        ...                 (vbt.Rep(&#39;window&#39;),)),  # positional arguments
        ...             &#39;vbt.plot&#39;  # plotting function
        ...         ],
        ...         pass_add_trace_kwargs=True,
        ...         trace_names=[vbt.Sub(&#39;rolling_drawdown(${window})&#39;)],  # add window to the trace name
        ...     ))
        ... ]
        &gt;&gt;&gt; pf.plot(subplots, rolling_drawdown_kwargs=dict(template_mapping=dict(window=10)))
        ```

        You can also replace templates across all subplots by using the global template mapping:

        ```python-repl
        &gt;&gt;&gt; pf.plot(subplots, template_mapping=dict(window=10))
        ```

        ![](/vectorbt/docs/img/portfolio_plot_path.svg)
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]
        portfolio_plot_cfg = settings[&#39;portfolio&#39;][&#39;plot&#39;]

        # Resolve defaults
        if show_titles is None:
            show_titles = portfolio_plot_cfg[&#39;show_titles&#39;]
        if hide_id_labels is None:
            hide_id_labels = portfolio_plot_cfg[&#39;hide_id_labels&#39;]
        if group_id_labels is None:
            group_id_labels = portfolio_plot_cfg[&#39;group_id_labels&#39;]
        if silence_warnings is None:
            silence_warnings = portfolio_plot_cfg[&#39;silence_warnings&#39;]
        make_subplots_kwargs = merge_dicts(portfolio_plot_cfg[&#39;make_subplots_kwargs&#39;], make_subplots_kwargs)
        template_mapping = merge_dicts(portfolio_plot_cfg[&#39;template_mapping&#39;], template_mapping)
        hline_shape_kwargs = merge_dicts(portfolio_plot_cfg[&#39;hline_shape_kwargs&#39;], hline_shape_kwargs)
        kwargs = merge_dicts(portfolio_plot_cfg[&#39;kwargs&#39;], kwargs)

        # Check if grouped
        is_grouped = self.wrapper.grouper.is_grouped(group_by=group_by)

        # Replace templates globally
        if len(template_mapping) &gt; 0:
            kwargs = deep_substitute(kwargs, mapping=template_mapping)

        # Prepare subplots
        if subplots is None:
            subplots = portfolio_plot_cfg[&#39;subplots&#39;]
            if is_grouped:
                grouped_subplots = portfolio_plot_cfg[&#39;grouped_subplots&#39;]
                if grouped_subplots is None:
                    grouped_subplots = subplots
                subplots = grouped_subplots
        if subplots == &#39;all&#39;:
            subplots = self.subplots
        if isinstance(subplots, dict):
            subplots = list(subplots.items())
        if isinstance(subplots, (str, tuple)):
            subplots = [subplots]
        # Bring to the same shape
        new_subplots = []
        for i, subplot in enumerate(subplots):
            if isinstance(subplot, str):
                subplot = (subplot, self.subplots[subplot])
            if not isinstance(subplot, tuple):
                raise TypeError(f&#34;Subplot at index {i} must be either a string or a tuple&#34;)
            new_subplots.append(subplot)
        subplots = new_subplots
        # Handle duplicate names
        subplot_counts = Counter(list(map(lambda x: x[0], subplots)))
        subplot_i = {k: -1 for k in subplot_counts.keys()}
        new_subplots = []
        for i, (name, settings) in enumerate(subplots):
            if subplot_counts[name] &gt; 1:
                subplot_i[name] += 1
                name = name + &#39;_&#39; + str(subplot_i[name])
            new_subplots.append((name, settings))
        subplots = new_subplots
        # Merge settings
        new_subplots = []
        for i, subplot in enumerate(subplots):
            subplot = (subplot[0], merge_dicts(subplot[1], kwargs.pop(f&#39;{subplot[0]}_kwargs&#39;, {})))
            new_subplots.append(subplot)
        subplots = new_subplots
        # Filter subplots
        if is_grouped:
            def _filter_grouped(subplot: tp.Tuple[str, tp.Kwargs]) -&gt; bool:
                if &#39;allow_grouped&#39; not in subplot[1]:
                    return True
                if subplot[1][&#39;allow_grouped&#39;]:
                    return True
                return False

            new_subplots = list(filter(_filter_grouped, subplots))
            left_out_names = set(map(lambda x: x[0], subplots)).difference(set(map(lambda x: x[0], new_subplots)))
            if len(left_out_names) &gt; 0 and not silence_warnings:
                warnings.warn(f&#34;Subplots {left_out_names} do not support grouped data&#34;, stacklevel=2)
            subplots = new_subplots
        if len(subplots) == 0:
            raise ValueError(&#34;There is no subplot to plot&#34;)

        # Set up figure
        rows = make_subplots_kwargs.pop(&#39;rows&#39;, len(subplots))
        cols = make_subplots_kwargs.pop(&#39;cols&#39;, 1)
        specs = make_subplots_kwargs.pop(&#39;specs&#39;, [[{} for _ in range(cols)] for _ in range(rows)])
        row_col_tuples = []
        for row, row_spec in enumerate(specs):
            for col, col_spec in enumerate(row_spec):
                if col_spec is not None:
                    row_col_tuples.append((row + 1, col + 1))
        shared_xaxes = make_subplots_kwargs.pop(&#39;shared_xaxes&#39;, True)
        shared_yaxes = make_subplots_kwargs.pop(&#39;shared_yaxes&#39;, False)
        default_height = plotting_cfg[&#39;layout&#39;][&#39;height&#39;]
        default_width = plotting_cfg[&#39;layout&#39;][&#39;width&#39;] + 50
        min_space = 10  # space between subplots with no axis sharing
        max_title_spacing = 30
        max_xaxis_spacing = 50
        max_yaxis_spacing = 100
        legend_height = 50
        if show_titles:
            title_spacing = max_title_spacing
        else:
            title_spacing = 0
        if not shared_xaxes and rows &gt; 1:
            xaxis_spacing = max_xaxis_spacing
        else:
            xaxis_spacing = 0
        if not shared_yaxes and cols &gt; 1:
            yaxis_spacing = max_yaxis_spacing
        else:
            yaxis_spacing = 0
        if &#39;height&#39; in kwargs:
            height = kwargs.pop(&#39;height&#39;)
        else:
            height = default_height + title_spacing
            if rows &gt; 1:
                height *= rows
                height += min_space * rows - min_space
                height += legend_height - legend_height * rows
                if shared_xaxes:
                    height += max_xaxis_spacing - max_xaxis_spacing * rows
        if &#39;width&#39; in kwargs:
            width = kwargs.pop(&#39;width&#39;)
        else:
            width = default_width
            if cols &gt; 1:
                width *= cols
                width += min_space * cols - min_space
                if shared_yaxes:
                    width += max_yaxis_spacing - max_yaxis_spacing * cols
        if height is not None:
            if &#39;vertical_spacing&#39; in make_subplots_kwargs:
                vertical_spacing = make_subplots_kwargs.pop(&#39;vertical_spacing&#39;)
            else:
                vertical_spacing = min_space + title_spacing + xaxis_spacing
            if vertical_spacing is not None and vertical_spacing &gt; 1:
                vertical_spacing /= height
            legend_y = 1 + (min_space + title_spacing) / height
        else:
            vertical_spacing = make_subplots_kwargs.pop(&#39;vertical_spacing&#39;, None)
            legend_y = 1.02
        if width is not None:
            if &#39;horizontal_spacing&#39; in make_subplots_kwargs:
                horizontal_spacing = make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;)
            else:
                horizontal_spacing = min_space + yaxis_spacing
            if horizontal_spacing is not None and horizontal_spacing &gt; 1:
                horizontal_spacing /= width
        else:
            horizontal_spacing = make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;, None)
        if show_titles:
            _subplot_titles = []
            for name in subplots:
                _subplot_titles.append(name[1].get(&#39;title&#39;, None))
        else:
            _subplot_titles = None
        fig = make_subplots(
            rows=rows,
            cols=cols,
            specs=specs,
            shared_xaxes=shared_xaxes,
            shared_yaxes=shared_yaxes,
            subplot_titles=_subplot_titles,
            vertical_spacing=vertical_spacing,
            horizontal_spacing=horizontal_spacing,
            **make_subplots_kwargs
        )
        kwargs = merge_dicts(dict(
            width=width,
            height=height,
            legend=dict(
                orientation=&#34;h&#34;,
                yanchor=&#34;bottom&#34;,
                y=legend_y,
                xanchor=&#34;right&#34;,
                x=1,
                traceorder=&#39;normal&#39;
            )
        ), kwargs)
        fig.update_layout(**kwargs)  # final destination for kwargs

        # Show subplots
        for i, (name, settings) in enumerate(subplots):
            _settings = settings.copy()
            _settings.pop(&#39;allow_grouped&#39;, None)

            # Compute figure artifacts
            row, col = row_col_tuples[i]
            xref = &#39;x&#39; if i == 0 else &#39;x&#39; + str(i + 1)
            yref = &#39;y&#39; if i == 0 else &#39;y&#39; + str(i + 1)
            xaxis = &#39;xaxis&#39; + xref[1:]
            yaxis = &#39;yaxis&#39; + yref[1:]
            x_domain = get_domain(xref, fig)
            y_domain = get_domain(yref, fig)

            # Replace templates
            default_settings = dict(
                portfolio=self,
                column=column,
                group_by=group_by,
                subplot_name=name,
                trace_names=[name],
                add_trace_kwargs=dict(row=row, col=col),
                xref=xref,
                yref=yref,
                xaxis=xaxis,
                yaxis=yaxis,
                x_domain=x_domain,
                y_domain=y_domain,
                hline_shape_kwargs=hline_shape_kwargs,
                fig=fig
            )
            reserved_args = list(default_settings.keys())
            reserved_args.remove(&#39;fig&#39;)
            _settings = merge_dicts(default_settings, _settings)
            subplot_template_mapping = _settings.pop(&#39;template_mapping&#39;, {})
            mapping = merge_dicts(_settings, template_mapping, subplot_template_mapping)
            _settings = deep_substitute(_settings, mapping=mapping)

            # Pop values
            plot_func = _settings.pop(&#39;plot_func&#39;, None)
            xaxis_title = _settings.pop(&#39;xaxis_title&#39;, &#39;Date&#39;)
            yaxis_title = _settings.pop(&#39;yaxis_title&#39;, _settings.pop(&#39;title&#39;, None))

            # Prepare function and keyword arguments
            if plot_func is not None:
                if not callable(plot_func):
                    plot_func = self.getattr(plot_func, call_last_attr=False)
                if not callable(plot_func):
                    raise TypeError(&#34;plot_func must be callable&#34;)
                func_arg_names = get_func_arg_names(plot_func)
                for k in reserved_args:
                    if &#39;pass_&#39; + k in _settings:
                        if not _settings.pop(&#39;pass_&#39; + k):  # first priority
                            del _settings[k]
                    elif k not in func_arg_names:  # second priority
                        _settings.pop(k, None)

                # Call plotting function
                plot_func(**_settings)

            # Update global layout
            fig.layout[xaxis][&#39;title&#39;] = xaxis_title
            fig.layout[yaxis][&#39;title&#39;] = yaxis_title

        # Remove duplicate legend labels
        found_ids = dict()
        unique_idx = 0
        for trace in fig.data:
            if &#39;name&#39; in trace:
                name = trace[&#39;name&#39;]
            else:
                name = None
            if &#39;marker&#39; in trace:
                marker = trace[&#39;marker&#39;]
            else:
                marker = {}
            if &#39;symbol&#39; in marker:
                marker_symbol = marker[&#39;symbol&#39;]
            else:
                marker_symbol = None
            if &#39;color&#39; in marker:
                marker_color = marker[&#39;color&#39;]
            else:
                marker_color = None
            if &#39;line&#39; in trace:
                line = trace[&#39;line&#39;]
            else:
                line = {}
            if &#39;dash&#39; in line:
                line_dash = line[&#39;dash&#39;]
            else:
                line_dash = None
            if &#39;color&#39; in line:
                line_color = line[&#39;color&#39;]
            else:
                line_color = None

            id = (name, marker_symbol, marker_color, line_dash, line_color)
            if id in found_ids:
                if hide_id_labels:
                    trace[&#39;showlegend&#39;] = False
                if group_id_labels:
                    trace[&#39;legendgroup&#39;] = found_ids[id]
            else:
                if group_id_labels:
                    trace[&#39;legendgroup&#39;] = unique_idx
                found_ids[id] = unique_idx
                unique_idx += 1

        # Remove all except the last title if sharing the same axis
        if shared_xaxes:
            i = 0
            for row in range(rows):
                for col in range(cols):
                    if specs[row][col] is not None:
                        xaxis = &#39;xaxis&#39; if i == 0 else &#39;xaxis&#39; + str(i + 1)
                        if row &lt; rows - 1:
                            fig.layout[xaxis][&#39;title&#39;] = None
                        i += 1
        if shared_yaxes:
            i = 0
            for row in range(rows):
                for col in range(cols):
                    if specs[row][col] is not None:
                        yaxis = &#39;yaxis&#39; if i == 0 else &#39;yaxis&#39; + str(i + 1)
                        if col &gt; 0:
                            fig.layout[yaxis][&#39;title&#39;] = None
                        i += 1

        return fig</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio.metrics"><code class="name">var <span class="ident">metrics</span></code></dt>
<dd>
<div class="desc"><p>Metrics supported by <code><a title="vectorbt.portfolio.base.Portfolio.stats" href="#vectorbt.portfolio.base.Portfolio.stats">Portfolio.stats()</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It's safe to change this config - this instance variable is a (deep) copy of the class variable.</p>
<p>Copying portfolio using <code><a title="vectorbt.portfolio.base.Portfolio.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">Configured.copy()</a></code> won't create a copy of the config!</p>
</div></div>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.subplots"><code class="name">var <span class="ident">subplots</span></code></dt>
<dd>
<div class="desc"><p>Subplots supported by <code><a title="vectorbt.portfolio.base.Portfolio.plot" href="#vectorbt.portfolio.base.Portfolio.plot">Portfolio.plot()</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It's safe to change this config - this instance variable is a (deep) copy of the class variable.</p>
<p>Copying portfolio using <code><a title="vectorbt.portfolio.base.Portfolio.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">Configured.copy()</a></code> won't create a copy of the config!</p>
</div></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio.from_holding"><code class="name flex">
<span>def <span class="ident">from_holding</span></span>(<span>close, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate portfolio from holding.</p>
<p>Based on <code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">Portfolio.from_signals()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_holding(cls: tp.Type[PortfolioT], close: tp.ArrayLike, **kwargs) -&gt; PortfolioT:
    &#34;&#34;&#34;Simulate portfolio from holding.

    Based on `Portfolio.from_signals`.&#34;&#34;&#34;
    return cls.from_signals(close, True, False, accumulate=False, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.from_order_func"><code class="name flex">
<span>def <span class="ident">from_order_func</span></span>(<span>close, order_func_nb, *order_args, target_shape=None, keys=None, init_cash=None, cash_sharing=None, call_seq=None, segment_mask=None, pre_sim_func_nb=CPUDispatcher(&lt;function no_pre_func_nb&gt;), pre_sim_args=(), post_sim_func_nb=CPUDispatcher(&lt;function no_post_func_nb&gt;), post_sim_args=(), pre_group_func_nb=CPUDispatcher(&lt;function no_pre_func_nb&gt;), pre_group_args=(), post_group_func_nb=CPUDispatcher(&lt;function no_post_func_nb&gt;), post_group_args=(), pre_row_func_nb=CPUDispatcher(&lt;function no_pre_func_nb&gt;), pre_row_args=(), post_row_func_nb=CPUDispatcher(&lt;function no_post_func_nb&gt;), post_row_args=(), pre_segment_func_nb=CPUDispatcher(&lt;function no_pre_func_nb&gt;), pre_segment_args=(), post_segment_func_nb=CPUDispatcher(&lt;function no_post_func_nb&gt;), post_segment_args=(), post_order_func_nb=CPUDispatcher(&lt;function no_post_func_nb&gt;), post_order_args=(), call_pre_segment=None, call_post_segment=None, ffill_val_price=None, update_value=None, fill_pos_record=None, row_wise=None, use_numba=None, max_orders=None, max_logs=None, seed=None, group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build portfolio from a custom order function.</p>
<p>For details, see <code><a title="vectorbt.portfolio.nb.simulate_nb" href="nb.html#vectorbt.portfolio.nb.simulate_nb">simulate_nb()</a></code>.</p>
<p>if <code>row_wise</code> is True, also see <code><a title="vectorbt.portfolio.nb.simulate_row_wise_nb" href="nb.html#vectorbt.portfolio.nb.simulate_row_wise_nb">simulate_row_wise_nb()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>close</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>Last asset price at each time step.
Will broadcast to <code>target_shape</code>.</p>
<p>Used for calculating unrealized P&amp;L and portfolio value.</p>
</dd>
<dt><strong><code>order_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>Order generation function.</dd>
<dt><strong><code>*order_args</code></strong></dt>
<dd>Arguments passed to <code>order_func_nb</code>.</dd>
<dt><strong><code>target_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Target shape to iterate over. Defaults to <code>close.shape</code>.</dd>
<dt><strong><code>keys</code></strong> :&ensp;<code>sequence</code></dt>
<dd>
<p>Outermost column level.</p>
<p>Each element should correspond to one iteration over columns in <code>close</code>.
Should be set only if <code>target_shape</code> is bigger than <code>close.shape</code>.</p>
</dd>
<dt><strong><code>init_cash</code></strong> :&ensp;<code>InitCashMode, float</code> or <code>array_like</code> of <code>float</code></dt>
<dd>
<p>Initial capital.</p>
<p>See <code>init_cash</code> in <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
</dd>
<dt><strong><code>cash_sharing</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to share cash within the same group.</p>
<p>If <code>group_by</code> is None, <code>group_by</code> becomes True to form a single group with cash sharing.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Introduces cross-asset dependencies.</p>
</div>
</dd>
<dt><strong><code>call_seq</code></strong> :&ensp;<code>CallSeqType</code> or <code>array_like</code></dt>
<dd>
<p>Default sequence of calls per row and group.</p>
<ul>
<li>Use <code><a title="vectorbt.portfolio.enums.CallSeqType" href="enums.html#vectorbt.portfolio.enums.CallSeqType">CallSeqType</a></code> to select a sequence type.</li>
<li>Set to array to specify custom sequence. Will not broadcast.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CallSeqType.Auto should be implemented manually.
Use <code>sort_call_seq_nb</code> in <code>pre_segment_func_nb</code>.</p>
</div>
</dd>
<dt><strong><code>segment_mask</code></strong> :&ensp;<code>int</code> or <code>array_like</code> of <code>bool</code></dt>
<dd>
<p>Mask of whether a particular segment should be executed.</p>
<p>Supplying an integer will activate every n-th row (just for convenience).
Supplying a boolean will broadcast to the number of rows and groups.</p>
</dd>
<dt><strong><code>pre_sim_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>Function called before simulation.
Defaults to <code><a title="vectorbt.portfolio.nb.no_pre_func_nb" href="nb.html#vectorbt.portfolio.nb.no_pre_func_nb">no_pre_func_nb()</a></code>.</dd>
<dt><strong><code>pre_sim_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Packed arguments passed to <code>pre_sim_func_nb</code>.
Defaults to <code>()</code>.</dd>
<dt><strong><code>post_sim_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>Function called after simulation.
Defaults to <code><a title="vectorbt.portfolio.nb.no_post_func_nb" href="nb.html#vectorbt.portfolio.nb.no_post_func_nb">no_post_func_nb()</a></code>.</dd>
<dt><strong><code>post_sim_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Packed arguments passed to <code>post_sim_func_nb</code>.
Defaults to <code>()</code>.</dd>
<dt><strong><code>pre_group_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>
<p>Function called before each group.
Defaults to <code><a title="vectorbt.portfolio.nb.no_pre_func_nb" href="nb.html#vectorbt.portfolio.nb.no_pre_func_nb">no_pre_func_nb()</a></code>.</p>
<p>Called only if <code>row_wise</code> is False.</p>
</dd>
<dt><strong><code>pre_group_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Packed arguments passed to <code>pre_group_func_nb</code>.
Defaults to <code>()</code>.</dd>
<dt><strong><code>post_group_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>
<p>Function called after each group.
Defaults to <code><a title="vectorbt.portfolio.nb.no_post_func_nb" href="nb.html#vectorbt.portfolio.nb.no_post_func_nb">no_post_func_nb()</a></code>.</p>
<p>Called only if <code>row_wise</code> is False.</p>
</dd>
<dt><strong><code>post_group_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Packed arguments passed to <code>post_group_func_nb</code>.
Defaults to <code>()</code>.</dd>
<dt><strong><code>pre_row_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>
<p>Function called before each row.
Defaults to <code><a title="vectorbt.portfolio.nb.no_pre_func_nb" href="nb.html#vectorbt.portfolio.nb.no_pre_func_nb">no_pre_func_nb()</a></code>.</p>
<p>Called only if <code>row_wise</code> is True.</p>
</dd>
<dt><strong><code>pre_row_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Packed arguments passed to <code>pre_row_func_nb</code>.
Defaults to <code>()</code>.</dd>
<dt><strong><code>post_row_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>
<p>Function called after each row.
Defaults to <code><a title="vectorbt.portfolio.nb.no_post_func_nb" href="nb.html#vectorbt.portfolio.nb.no_post_func_nb">no_post_func_nb()</a></code>.</p>
<p>Called only if <code>row_wise</code> is True.</p>
</dd>
<dt><strong><code>post_row_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Packed arguments passed to <code>post_row_func_nb</code>.
Defaults to <code>()</code>.</dd>
<dt><strong><code>pre_segment_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>Function called before each segment.
Defaults to <code><a title="vectorbt.portfolio.nb.no_pre_func_nb" href="nb.html#vectorbt.portfolio.nb.no_pre_func_nb">no_pre_func_nb()</a></code>.</dd>
<dt><strong><code>pre_segment_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Packed arguments passed to <code>pre_segment_func_nb</code>.
Defaults to <code>()</code>.</dd>
<dt><strong><code>post_segment_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>Function called after each segment.
Defaults to <code><a title="vectorbt.portfolio.nb.no_post_func_nb" href="nb.html#vectorbt.portfolio.nb.no_post_func_nb">no_post_func_nb()</a></code>.</dd>
<dt><strong><code>post_segment_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Packed arguments passed to <code>post_segment_func_nb</code>.
Defaults to <code>()</code>.</dd>
<dt><strong><code>post_order_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>Callback that is called after the order has been processed.</dd>
<dt><strong><code>post_order_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Packed arguments passed to <code>post_order_func_nb</code>.
Defaults to <code>()</code>.</dd>
<dt><strong><code>call_pre_segment</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to call <code>pre_segment_func_nb</code> regardless of <code>segment_mask</code>.</dd>
<dt><strong><code>call_post_segment</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to call <code>post_segment_func_nb</code> regardless of <code>segment_mask</code>.</dd>
<dt><strong><code>ffill_val_price</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to track valuation price only if it's known.</p>
<p>Otherwise, unknown <code>close</code> will lead to NaN in valuation price at the next timestamp.</p>
</dd>
<dt><strong><code>update_value</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to update group value after each filled order.</dd>
<dt><strong><code>fill_pos_record</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to fill position record.</p>
<p>Disable this to make simulation a bit faster for simple use cases.</p>
</dd>
<dt><strong><code>row_wise</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to iterate over rows rather than columns/groups.</p>
<p>See <code><a title="vectorbt.portfolio.nb.simulate_row_wise_nb" href="nb.html#vectorbt.portfolio.nb.simulate_row_wise_nb">simulate_row_wise_nb()</a></code>.</p>
</dd>
<dt><strong><code>use_numba</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to run the main simulation function using Numba.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Disabling it does not disable Numba for other functions.
If neccessary, you should ensure that every other function does not uses Numba as well.
You can do this by using the <code>py_func</code> attribute of that function.
Or, you could disable Numba globally by doing <code>os.environ['NUMBA_DISABLE_JIT'] = '1'</code>.</p>
</div>
</dd>
<dt><strong><code>max_orders</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Size of the order records array.
Defaults to the number of elements in the broadcasted shape.</p>
<p>Set to a lower number if you run out of memory.</p>
</dd>
<dt><strong><code>max_logs</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Size of the log records array.
Defaults to the number of elements in the broadcasted shape.</p>
<p>Set to a lower number if you run out of memory.</p>
</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Seed to be set for both <code>call_seq</code> and at the beginning of the simulation.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>broadcast_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.</dd>
<dt><strong><code>wrapper_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Index frequency in case it cannot be parsed from <code>close</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>For defaults, see <code>portfolio</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All passed functions should be Numba-compiled.</p>
<p>Objects passed as arguments to both functions will not broadcast to <code>target_shape</code>
as their purpose is unknown. You should broadcast manually or use flexible indexing.</p>
<p>Also see notes on <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In contrast to other methods, the valuation price is previous <code>close</code>
instead of order price, since the price of an order is unknown before call.
You can still set valuation price explicitly in <code>pre_segment_func_nb</code>.</p>
</div>
<h2 id="example">Example</h2>
<p>Buy 10 units each tick using closing price:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; from vectorbt.portfolio.nb import order_nb

&gt;&gt;&gt; @njit
... def order_func_nb(c, size):
...     return order_nb(size=size)

&gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
&gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(close, order_func_nb, 10)

&gt;&gt;&gt; pf.assets()
0    10.0
1    20.0
2    30.0
3    40.0
4    40.0
dtype: float64
&gt;&gt;&gt; pf.cash()
0    90.0
1    70.0
2    40.0
3     0.0
4     0.0
dtype: float64
</code></pre>
<p>Reverse each position by first closing it. Keep state of last position to determine
which position to open next (just as an example, there are easier ways to do this):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from vectorbt.portfolio.nb import close_position_nb

&gt;&gt;&gt; @njit
... def pre_group_func_nb(c):
...     last_pos_state = np.array([-1])
...     return (last_pos_state,)

&gt;&gt;&gt; @njit
... def order_func_nb(c, last_pos_state):
...     if c.position_now != 0:
...         return close_position_nb()
...
...     if last_pos_state[0] == 1:
...         size = -np.inf  # open short
...         last_pos_state[0] = -1
...     else:
...         size = np.inf  # open long
...         last_pos_state[0] = 1
...     return order_nb(size=size)

&gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(
...     close, order_func_nb, pre_group_func_nb=pre_group_func_nb)

&gt;&gt;&gt; pf.assets()
0    100.000000
1      0.000000
2    -66.666667
3      0.000000
4     26.666667
dtype: float64
&gt;&gt;&gt; pf.cash()
0      0.000000
1    200.000000
2    400.000000
3    133.333333
4      0.000000
dtype: float64
</code></pre>
<p>Equal-weighted portfolio as in <code><a title="vectorbt.portfolio.nb.simulate_nb" href="nb.html#vectorbt.portfolio.nb.simulate_nb">simulate_nb()</a></code> example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from vectorbt.portfolio.nb import sort_call_seq_nb
&gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, Direction

&gt;&gt;&gt; @njit
... def pre_group_func_nb(c):
...     '''Define empty arrays for each group.'''
...     order_value_out = np.empty(c.group_len, dtype=np.float_)
...     return (order_value_out,)

&gt;&gt;&gt; @njit
... def pre_segment_func_nb(c, order_value_out):
...     '''Perform rebalancing at each segment.'''
...     for col in range(c.from_col, c.to_col):
...         # Here we use order price for group valuation
...         c.last_val_price[col] = c.close[c.i, col]
...     # Reorder call sequence such that selling orders come first and buying last
...     size = 1 / c.group_len
...     size_type = SizeType.TargetPercent
...     direction = Direction.LongOnly  # long positions only
...     sort_call_seq_nb(c, size, size_type, direction, order_value_out)
...     return (size, size_type, direction)

&gt;&gt;&gt; @njit
... def order_func_nb(c, size, size_type, direction, fees, fixed_fees, slippage):
...     '''Place an order.'''
...     return order_nb(
...         size=size,
...         size_type=size_type,
...         direction=direction,
...         fees=fees,
...         fixed_fees=fixed_fees,
...         slippage=slippage
...     )

&gt;&gt;&gt; np.random.seed(42)
&gt;&gt;&gt; close = np.random.uniform(1, 10, size=(5, 3))
&gt;&gt;&gt; fees = 0.001
&gt;&gt;&gt; fixed_fees = 1.
&gt;&gt;&gt; slippage = 0.001

&gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(
...     close,  # acts both as reference and order price here
...     order_func_nb, fees, fixed_fees, slippage,  # order_args as *args
...     segment_mask=2,  # rebalance every second tick
...     pre_group_func_nb=pre_group_func_nb,
...     pre_segment_func_nb=pre_segment_func_nb,
...     cash_sharing=True, group_by=True,  # one group with cash sharing
... )

&gt;&gt;&gt; pf.asset_value(group_by=False).vbt.plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/simulate_nb.svg"></p>
<p>Combine multiple exit conditions. Exit early if the price hits some threshold before an actual exit
(similar to the example under <code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">Portfolio.from_signals()</a></code>, but doesn't remove any information):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb, to_2d
&gt;&gt;&gt; from vectorbt.portfolio.enums import NoOrder, OrderStatus, OrderSide

&gt;&gt;&gt; @njit
... def pre_sim_func_nb(c):
...     # We need to define stop price per column once
...     stop_price = np.full(c.target_shape[1], np.nan, dtype=np.float_)
...     return (stop_price,)

&gt;&gt;&gt; @njit
... def order_func_nb(c, stop_price, entries, exits, size, flex_2d):
...     # Select info related to this order
...     # flex_select_auto_nb allows us to pass size as single number, 1-dim or 2-dim array
...     # If flex_2d is True, 1-dim array will be per column, otherwise per row
...     size_now = flex_select_auto_nb(c.i, c.col, np.asarray(size), flex_2d)
...     price_now = c.close[c.i, c.col]  # close is always 2-dim array
...     stop_price_now = stop_price[c.col]
...
...     # Our logic
...     if entries[c.i, c.col]:
...         if c.position_now == 0:
...             return order_nb(
...                 size=size_now,
...                 price=price_now,
...                 direction=Direction.LongOnly)
...     elif exits[c.i, c.col] or price_now &gt;= stop_price_now:
...         if c.position_now &gt; 0:
...             return order_nb(
...                 size=-size_now,
...                 price=price_now,
...                 direction=Direction.LongOnly)
...     return NoOrder

&gt;&gt;&gt; @njit
... def post_order_func_nb(c, stop_price, stop, flex_2d):
...     # Same broadcasting as for size
...     stop_now = flex_select_auto_nb(c.i, c.col, np.asarray(stop), flex_2d)
...
...     if c.order_result.status == OrderStatus.Filled:
...         if c.order_result.side == OrderSide.Buy:
...             # Position entered: Set stop condition
...             stop_price[c.col] = (1 + stop_now) * c.order_result.price
...         else:
...             # Position exited: Remove stop condition
...             stop_price[c.col] = np.nan

&gt;&gt;&gt; def simulate(close, entries, exits, threshold):
...     return vbt.Portfolio.from_order_func(
...         close,
...         order_func_nb,
...         to_2d(entries, raw=True),  # 2-dim array
...         to_2d(exits, raw=True),  # 2-dim array
...         np.inf, # will broadcast
...         True,
...         pre_sim_func_nb=pre_sim_func_nb,
...         post_order_func_nb=post_order_func_nb,
...         post_order_args=(
...             threshold,  # will broadcast
...             True
...         )
...     )

&gt;&gt;&gt; close = pd.Series([10, 11, 12, 13, 14])
&gt;&gt;&gt; entries = pd.Series([True, True, False, False, False])
&gt;&gt;&gt; exits = pd.Series([False, False, False, True, True])
&gt;&gt;&gt; simulate(close, entries, exits, 0.1).asset_flow()
0    10.0
1     0.0
2   -10.0
3     0.0
4     0.0
dtype: float64
&gt;&gt;&gt; simulate(close, entries, exits, 0.2).asset_flow()
0    10.0
1     0.0
2   -10.0
3     0.0
4     0.0
dtype: float64
&gt;&gt;&gt; simulate(close, entries, exits, np.nan).asset_flow()
0    10.0
1     0.0
2     0.0
3   -10.0
4     0.0
dtype: float64
</code></pre>
<p>The reason why stop of 10% does not result in an order at the second time step is because
it comes at the same time as entry, so it must wait until no entry is present.
This can be changed by replacing the statement "elif" with "if", which would execute
an exit regardless if an entry is present (similar to using <code>ConflictMode.Opposite</code> in
<code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">Portfolio.from_signals()</a></code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_order_func(cls: tp.Type[PortfolioT],
                    close: tp.ArrayLike,
                    order_func_nb: nb.OrderFuncT,
                    *order_args,
                    target_shape: tp.Optional[tp.RelaxedShape] = None,
                    keys: tp.Optional[tp.IndexLike] = None,
                    init_cash: tp.Optional[tp.ArrayLike] = None,
                    cash_sharing: tp.Optional[bool] = None,
                    call_seq: tp.Optional[tp.ArrayLike] = None,
                    segment_mask: tp.Optional[tp.ArrayLike] = None,
                    pre_sim_func_nb: nb.PreSimFuncT = nb.no_pre_func_nb,
                    pre_sim_args: tp.Args = (),
                    post_sim_func_nb: nb.PostSimFuncT = nb.no_post_func_nb,
                    post_sim_args: tp.Args = (),
                    pre_group_func_nb: nb.PreGroupFuncT = nb.no_pre_func_nb,
                    pre_group_args: tp.Args = (),
                    post_group_func_nb: nb.PostGroupFuncT = nb.no_post_func_nb,
                    post_group_args: tp.Args = (),
                    pre_row_func_nb: nb.PreRowFuncT = nb.no_pre_func_nb,
                    pre_row_args: tp.Args = (),
                    post_row_func_nb: nb.PostRowFuncT = nb.no_post_func_nb,
                    post_row_args: tp.Args = (),
                    pre_segment_func_nb: nb.PreSegmentFuncT = nb.no_pre_func_nb,
                    pre_segment_args: tp.Args = (),
                    post_segment_func_nb: nb.PostSegmentFuncT = nb.no_post_func_nb,
                    post_segment_args: tp.Args = (),
                    post_order_func_nb: nb.PostOrderFuncT = nb.no_post_func_nb,
                    post_order_args: tp.Args = (),
                    call_pre_segment: tp.Optional[bool] = None,
                    call_post_segment: tp.Optional[bool] = None,
                    ffill_val_price: tp.Optional[bool] = None,
                    update_value: tp.Optional[bool] = None,
                    fill_pos_record: tp.Optional[bool] = None,
                    row_wise: tp.Optional[bool] = None,
                    use_numba: tp.Optional[bool] = None,
                    max_orders: tp.Optional[int] = None,
                    max_logs: tp.Optional[int] = None,
                    seed: tp.Optional[int] = None,
                    group_by: tp.GroupByLike = None,
                    broadcast_kwargs: tp.KwargsLike = None,
                    wrapper_kwargs: tp.KwargsLike = None,
                    freq: tp.Optional[tp.FrequencyLike] = None,
                    **kwargs) -&gt; PortfolioT:
    &#34;&#34;&#34;Build portfolio from a custom order function.

    For details, see `vectorbt.portfolio.nb.simulate_nb`.

    if `row_wise` is True, also see `vectorbt.portfolio.nb.simulate_row_wise_nb`.

    Args:
        close (array_like): Last asset price at each time step.
            Will broadcast to `target_shape`.

            Used for calculating unrealized P&amp;L and portfolio value.
        order_func_nb (callable): Order generation function.
        *order_args: Arguments passed to `order_func_nb`.
        target_shape (tuple): Target shape to iterate over. Defaults to `close.shape`.
        keys (sequence): Outermost column level.

            Each element should correspond to one iteration over columns in `close`.
            Should be set only if `target_shape` is bigger than `close.shape`.
        init_cash (InitCashMode, float or array_like of float): Initial capital.

            See `init_cash` in `Portfolio.from_orders`.
        cash_sharing (bool): Whether to share cash within the same group.

            If `group_by` is None, `group_by` becomes True to form a single group with cash sharing.

            !!! warning
                Introduces cross-asset dependencies.
        call_seq (CallSeqType or array_like): Default sequence of calls per row and group.

            * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
            * Set to array to specify custom sequence. Will not broadcast.

            !!! note
                CallSeqType.Auto should be implemented manually.
                Use `sort_call_seq_nb` in `pre_segment_func_nb`.
        segment_mask (int or array_like of bool): Mask of whether a particular segment should be executed.

            Supplying an integer will activate every n-th row (just for convenience).
            Supplying a boolean will broadcast to the number of rows and groups.
        pre_sim_func_nb (callable): Function called before simulation.
            Defaults to `vectorbt.portfolio.nb.no_pre_func_nb`.
        pre_sim_args (tuple): Packed arguments passed to `pre_sim_func_nb`.
            Defaults to `()`.
        post_sim_func_nb (callable): Function called after simulation.
            Defaults to `vectorbt.portfolio.nb.no_post_func_nb`.
        post_sim_args (tuple): Packed arguments passed to `post_sim_func_nb`.
            Defaults to `()`.
        pre_group_func_nb (callable): Function called before each group.
            Defaults to `vectorbt.portfolio.nb.no_pre_func_nb`.

            Called only if `row_wise` is False.
        pre_group_args (tuple): Packed arguments passed to `pre_group_func_nb`.
            Defaults to `()`.
        post_group_func_nb (callable): Function called after each group.
            Defaults to `vectorbt.portfolio.nb.no_post_func_nb`.

            Called only if `row_wise` is False.
        post_group_args (tuple): Packed arguments passed to `post_group_func_nb`.
            Defaults to `()`.
        pre_row_func_nb (callable): Function called before each row.
            Defaults to `vectorbt.portfolio.nb.no_pre_func_nb`.

            Called only if `row_wise` is True.
        pre_row_args (tuple): Packed arguments passed to `pre_row_func_nb`.
            Defaults to `()`.
        post_row_func_nb (callable): Function called after each row.
            Defaults to `vectorbt.portfolio.nb.no_post_func_nb`.

            Called only if `row_wise` is True.
        post_row_args (tuple): Packed arguments passed to `post_row_func_nb`.
            Defaults to `()`.
        pre_segment_func_nb (callable): Function called before each segment.
            Defaults to `vectorbt.portfolio.nb.no_pre_func_nb`.
        pre_segment_args (tuple): Packed arguments passed to `pre_segment_func_nb`.
            Defaults to `()`.
        post_segment_func_nb (callable): Function called after each segment.
            Defaults to `vectorbt.portfolio.nb.no_post_func_nb`.
        post_segment_args (tuple): Packed arguments passed to `post_segment_func_nb`.
            Defaults to `()`.
        post_order_func_nb (callable): Callback that is called after the order has been processed.
        post_order_args (tuple): Packed arguments passed to `post_order_func_nb`.
            Defaults to `()`.
        call_pre_segment (bool): Whether to call `pre_segment_func_nb` regardless of `segment_mask`.
        call_post_segment (bool): Whether to call `post_segment_func_nb` regardless of `segment_mask`.
        ffill_val_price (bool): Whether to track valuation price only if it&#39;s known.

            Otherwise, unknown `close` will lead to NaN in valuation price at the next timestamp.
        update_value (bool): Whether to update group value after each filled order.
        fill_pos_record (bool): Whether to fill position record.

            Disable this to make simulation a bit faster for simple use cases.
        row_wise (bool): Whether to iterate over rows rather than columns/groups.

            See `vectorbt.portfolio.nb.simulate_row_wise_nb`.
        use_numba (bool): Whether to run the main simulation function using Numba.

            !!! note
                Disabling it does not disable Numba for other functions.
                If neccessary, you should ensure that every other function does not uses Numba as well.
                You can do this by using the `py_func` attribute of that function.
                Or, you could disable Numba globally by doing `os.environ[&#39;NUMBA_DISABLE_JIT&#39;] = &#39;1&#39;`.
        max_orders (int): Size of the order records array.
            Defaults to the number of elements in the broadcasted shape.

            Set to a lower number if you run out of memory.
        max_logs (int): Size of the log records array.
            Defaults to the number of elements in the broadcasted shape.

            Set to a lower number if you run out of memory.
        seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
        group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
        wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
        freq (any): Index frequency in case it cannot be parsed from `close`.
        **kwargs: Keyword arguments passed to the `__init__` method.

    For defaults, see `portfolio` in `vectorbt._settings.settings`.

    !!! note
        All passed functions should be Numba-compiled.

        Objects passed as arguments to both functions will not broadcast to `target_shape`
        as their purpose is unknown. You should broadcast manually or use flexible indexing.

        Also see notes on `Portfolio.from_orders`.

    !!! note
        In contrast to other methods, the valuation price is previous `close`
        instead of order price, since the price of an order is unknown before call.
        You can still set valuation price explicitly in `pre_segment_func_nb`.

    ## Example

    Buy 10 units each tick using closing price:

    ```python-repl
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from numba import njit
    &gt;&gt;&gt; import vectorbt as vbt
    &gt;&gt;&gt; from vectorbt.portfolio.nb import order_nb

    &gt;&gt;&gt; @njit
    ... def order_func_nb(c, size):
    ...     return order_nb(size=size)

    &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
    &gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(close, order_func_nb, 10)

    &gt;&gt;&gt; pf.assets()
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    40.0
    dtype: float64
    &gt;&gt;&gt; pf.cash()
    0    90.0
    1    70.0
    2    40.0
    3     0.0
    4     0.0
    dtype: float64
    ```

    Reverse each position by first closing it. Keep state of last position to determine
    which position to open next (just as an example, there are easier ways to do this):

    ```python-repl
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from vectorbt.portfolio.nb import close_position_nb

    &gt;&gt;&gt; @njit
    ... def pre_group_func_nb(c):
    ...     last_pos_state = np.array([-1])
    ...     return (last_pos_state,)

    &gt;&gt;&gt; @njit
    ... def order_func_nb(c, last_pos_state):
    ...     if c.position_now != 0:
    ...         return close_position_nb()
    ...
    ...     if last_pos_state[0] == 1:
    ...         size = -np.inf  # open short
    ...         last_pos_state[0] = -1
    ...     else:
    ...         size = np.inf  # open long
    ...         last_pos_state[0] = 1
    ...     return order_nb(size=size)

    &gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(
    ...     close, order_func_nb, pre_group_func_nb=pre_group_func_nb)

    &gt;&gt;&gt; pf.assets()
    0    100.000000
    1      0.000000
    2    -66.666667
    3      0.000000
    4     26.666667
    dtype: float64
    &gt;&gt;&gt; pf.cash()
    0      0.000000
    1    200.000000
    2    400.000000
    3    133.333333
    4      0.000000
    dtype: float64
    ```

    Equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb` example:

    ```python-repl
    &gt;&gt;&gt; from vectorbt.portfolio.nb import sort_call_seq_nb
    &gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, Direction

    &gt;&gt;&gt; @njit
    ... def pre_group_func_nb(c):
    ...     &#39;&#39;&#39;Define empty arrays for each group.&#39;&#39;&#39;
    ...     order_value_out = np.empty(c.group_len, dtype=np.float_)
    ...     return (order_value_out,)

    &gt;&gt;&gt; @njit
    ... def pre_segment_func_nb(c, order_value_out):
    ...     &#39;&#39;&#39;Perform rebalancing at each segment.&#39;&#39;&#39;
    ...     for col in range(c.from_col, c.to_col):
    ...         # Here we use order price for group valuation
    ...         c.last_val_price[col] = c.close[c.i, col]
    ...     # Reorder call sequence such that selling orders come first and buying last
    ...     size = 1 / c.group_len
    ...     size_type = SizeType.TargetPercent
    ...     direction = Direction.LongOnly  # long positions only
    ...     sort_call_seq_nb(c, size, size_type, direction, order_value_out)
    ...     return (size, size_type, direction)

    &gt;&gt;&gt; @njit
    ... def order_func_nb(c, size, size_type, direction, fees, fixed_fees, slippage):
    ...     &#39;&#39;&#39;Place an order.&#39;&#39;&#39;
    ...     return order_nb(
    ...         size=size,
    ...         size_type=size_type,
    ...         direction=direction,
    ...         fees=fees,
    ...         fixed_fees=fixed_fees,
    ...         slippage=slippage
    ...     )

    &gt;&gt;&gt; np.random.seed(42)
    &gt;&gt;&gt; close = np.random.uniform(1, 10, size=(5, 3))
    &gt;&gt;&gt; fees = 0.001
    &gt;&gt;&gt; fixed_fees = 1.
    &gt;&gt;&gt; slippage = 0.001

    &gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(
    ...     close,  # acts both as reference and order price here
    ...     order_func_nb, fees, fixed_fees, slippage,  # order_args as *args
    ...     segment_mask=2,  # rebalance every second tick
    ...     pre_group_func_nb=pre_group_func_nb,
    ...     pre_segment_func_nb=pre_segment_func_nb,
    ...     cash_sharing=True, group_by=True,  # one group with cash sharing
    ... )

    &gt;&gt;&gt; pf.asset_value(group_by=False).vbt.plot()
    ```

    ![](/vectorbt/docs/img/simulate_nb.svg)

    Combine multiple exit conditions. Exit early if the price hits some threshold before an actual exit
    (similar to the example under `Portfolio.from_signals`, but doesn&#39;t remove any information):

    ```python-repl
    &gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb, to_2d
    &gt;&gt;&gt; from vectorbt.portfolio.enums import NoOrder, OrderStatus, OrderSide

    &gt;&gt;&gt; @njit
    ... def pre_sim_func_nb(c):
    ...     # We need to define stop price per column once
    ...     stop_price = np.full(c.target_shape[1], np.nan, dtype=np.float_)
    ...     return (stop_price,)

    &gt;&gt;&gt; @njit
    ... def order_func_nb(c, stop_price, entries, exits, size, flex_2d):
    ...     # Select info related to this order
    ...     # flex_select_auto_nb allows us to pass size as single number, 1-dim or 2-dim array
    ...     # If flex_2d is True, 1-dim array will be per column, otherwise per row
    ...     size_now = flex_select_auto_nb(c.i, c.col, np.asarray(size), flex_2d)
    ...     price_now = c.close[c.i, c.col]  # close is always 2-dim array
    ...     stop_price_now = stop_price[c.col]
    ...
    ...     # Our logic
    ...     if entries[c.i, c.col]:
    ...         if c.position_now == 0:
    ...             return order_nb(
    ...                 size=size_now,
    ...                 price=price_now,
    ...                 direction=Direction.LongOnly)
    ...     elif exits[c.i, c.col] or price_now &gt;= stop_price_now:
    ...         if c.position_now &gt; 0:
    ...             return order_nb(
    ...                 size=-size_now,
    ...                 price=price_now,
    ...                 direction=Direction.LongOnly)
    ...     return NoOrder

    &gt;&gt;&gt; @njit
    ... def post_order_func_nb(c, stop_price, stop, flex_2d):
    ...     # Same broadcasting as for size
    ...     stop_now = flex_select_auto_nb(c.i, c.col, np.asarray(stop), flex_2d)
    ...
    ...     if c.order_result.status == OrderStatus.Filled:
    ...         if c.order_result.side == OrderSide.Buy:
    ...             # Position entered: Set stop condition
    ...             stop_price[c.col] = (1 + stop_now) * c.order_result.price
    ...         else:
    ...             # Position exited: Remove stop condition
    ...             stop_price[c.col] = np.nan

    &gt;&gt;&gt; def simulate(close, entries, exits, threshold):
    ...     return vbt.Portfolio.from_order_func(
    ...         close,
    ...         order_func_nb,
    ...         to_2d(entries, raw=True),  # 2-dim array
    ...         to_2d(exits, raw=True),  # 2-dim array
    ...         np.inf, # will broadcast
    ...         True,
    ...         pre_sim_func_nb=pre_sim_func_nb,
    ...         post_order_func_nb=post_order_func_nb,
    ...         post_order_args=(
    ...             threshold,  # will broadcast
    ...             True
    ...         )
    ...     )

    &gt;&gt;&gt; close = pd.Series([10, 11, 12, 13, 14])
    &gt;&gt;&gt; entries = pd.Series([True, True, False, False, False])
    &gt;&gt;&gt; exits = pd.Series([False, False, False, True, True])
    &gt;&gt;&gt; simulate(close, entries, exits, 0.1).asset_flow()
    0    10.0
    1     0.0
    2   -10.0
    3     0.0
    4     0.0
    dtype: float64
    &gt;&gt;&gt; simulate(close, entries, exits, 0.2).asset_flow()
    0    10.0
    1     0.0
    2   -10.0
    3     0.0
    4     0.0
    dtype: float64
    &gt;&gt;&gt; simulate(close, entries, exits, np.nan).asset_flow()
    0    10.0
    1     0.0
    2     0.0
    3   -10.0
    4     0.0
    dtype: float64
    ```

    The reason why stop of 10% does not result in an order at the second time step is because
    it comes at the same time as entry, so it must wait until no entry is present.
    This can be changed by replacing the statement &#34;elif&#34; with &#34;if&#34;, which would execute
    an exit regardless if an entry is present (similar to using `ConflictMode.Opposite` in
    `Portfolio.from_signals`).
    &#34;&#34;&#34;
    # Get defaults
    from vectorbt._settings import settings
    portfolio_cfg = settings[&#39;portfolio&#39;]

    close = to_pd_array(close)
    if target_shape is None:
        target_shape = close.shape
    if init_cash is None:
        init_cash = portfolio_cfg[&#39;init_cash&#39;]
    init_cash = cast_enum_value(init_cash, InitCashMode)
    if isinstance(init_cash, int) and init_cash in InitCashMode:
        init_cash_mode = init_cash
        init_cash = np.inf
    else:
        init_cash_mode = None
    if cash_sharing is None:
        cash_sharing = portfolio_cfg[&#39;cash_sharing&#39;]
    if cash_sharing and group_by is None:
        group_by = True
    if call_seq is None:
        call_seq = portfolio_cfg[&#39;call_seq&#39;]
    call_seq = cast_enum_value(call_seq, CallSeqType)
    if isinstance(call_seq, int):
        if call_seq == CallSeqType.Auto:
            raise ValueError(&#34;CallSeqType.Auto should be implemented manually. &#34;
                             &#34;Use sort_call_seq_nb in pre_segment_func_nb.&#34;)
    if segment_mask is None:
        segment_mask = True
    if call_pre_segment is None:
        call_pre_segment = portfolio_cfg[&#39;call_pre_segment&#39;]
    if call_post_segment is None:
        call_post_segment = portfolio_cfg[&#39;call_post_segment&#39;]
    if ffill_val_price is None:
        ffill_val_price = portfolio_cfg[&#39;ffill_val_price&#39;]
    if update_value is None:
        update_value = portfolio_cfg[&#39;update_value&#39;]
    if fill_pos_record is None:
        fill_pos_record = portfolio_cfg[&#39;fill_pos_record&#39;]
    if row_wise is None:
        row_wise = portfolio_cfg[&#39;row_wise&#39;]
    if use_numba is None:
        use_numba = portfolio_cfg[&#39;use_numba&#39;]
    if seed is None:
        seed = portfolio_cfg[&#39;seed&#39;]
    if seed is not None:
        set_seed(seed)
    if freq is None:
        freq = portfolio_cfg[&#39;freq&#39;]
    if broadcast_kwargs is None:
        broadcast_kwargs = {}
    require_kwargs = dict(require_kwargs=dict(requirements=&#39;W&#39;))
    broadcast_kwargs = merge_dicts(require_kwargs, broadcast_kwargs)
    if wrapper_kwargs is None:
        wrapper_kwargs = {}
    if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
        raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

    # Broadcast inputs
    if isinstance(target_shape, int):
        target_shape = (target_shape,)
    target_shape_2d = (target_shape[0], target_shape[1] if len(target_shape) &gt; 1 else 1)
    if close.shape != target_shape:
        if len(close.vbt.wrapper.columns) &lt;= target_shape_2d[1]:
            if target_shape_2d[1] % len(close.vbt.wrapper.columns) != 0:
                raise ValueError(&#34;Cannot broadcast close to target_shape&#34;)
            if keys is None:
                keys = pd.Index(np.arange(target_shape_2d[1]), name=&#39;iteration_idx&#39;)
            tile_times = target_shape_2d[1] // len(close.vbt.wrapper.columns)
            close = close.vbt.tile(tile_times, keys=keys)
    close = broadcast(close, to_shape=target_shape, **broadcast_kwargs)
    wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
    cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
    init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
    group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
    if isinstance(segment_mask, int):
        _segment_mask = np.full((target_shape_2d[0], len(group_lens)), False)
        _segment_mask[0::segment_mask] = True
        segment_mask = _segment_mask
    else:
        segment_mask = broadcast(
            segment_mask,
            to_shape=(target_shape_2d[0], len(group_lens)),
            to_pd=False,
            **require_kwargs
        )
    if checks.is_any_array(call_seq):
        call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
    else:
        call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
    if max_orders is None:
        max_orders = target_shape_2d[0] * target_shape_2d[1]
    if max_logs is None:
        max_logs = target_shape_2d[0] * target_shape_2d[1]

    # Perform calculation
    if row_wise:
        simulate_func = nb.simulate_row_wise_nb
        if not use_numba and hasattr(simulate_func, &#39;py_func&#39;):
            simulate_func = simulate_func.py_func
        order_records, log_records = simulate_func(
            target_shape=target_shape_2d,
            close=to_2d(close, raw=True),
            group_lens=group_lens,
            init_cash=init_cash,
            cash_sharing=cash_sharing,
            call_seq=call_seq,
            segment_mask=segment_mask,
            pre_sim_func_nb=pre_sim_func_nb,
            pre_sim_args=pre_sim_args,
            post_sim_func_nb=post_sim_func_nb,
            post_sim_args=post_sim_args,
            pre_row_func_nb=pre_row_func_nb,
            pre_row_args=pre_row_args,
            post_row_func_nb=post_row_func_nb,
            post_row_args=post_row_args,
            pre_segment_func_nb=pre_segment_func_nb,
            pre_segment_args=pre_segment_args,
            post_segment_func_nb=post_segment_func_nb,
            post_segment_args=post_segment_args,
            order_func_nb=order_func_nb,
            order_args=order_args,
            post_order_func_nb=post_order_func_nb,
            post_order_args=post_order_args,
            call_pre_segment=call_pre_segment,
            call_post_segment=call_post_segment,
            ffill_val_price=ffill_val_price,
            update_value=update_value,
            fill_pos_record=fill_pos_record,
            max_orders=max_orders,
            max_logs=max_logs
        )
    else:
        simulate_func = nb.simulate_nb
        if not use_numba and hasattr(simulate_func, &#39;py_func&#39;):
            simulate_func = simulate_func.py_func
        order_records, log_records = simulate_func(
            target_shape=target_shape_2d,
            close=to_2d(close, raw=True),
            group_lens=group_lens,
            init_cash=init_cash,
            cash_sharing=cash_sharing,
            call_seq=call_seq,
            segment_mask=segment_mask,
            pre_sim_func_nb=pre_sim_func_nb,
            pre_sim_args=pre_sim_args,
            post_sim_func_nb=post_sim_func_nb,
            post_sim_args=post_sim_args,
            pre_group_func_nb=pre_group_func_nb,
            pre_group_args=pre_group_args,
            post_group_func_nb=post_group_func_nb,
            post_group_args=post_group_args,
            pre_segment_func_nb=pre_segment_func_nb,
            pre_segment_args=pre_segment_args,
            post_segment_func_nb=post_segment_func_nb,
            post_segment_args=post_segment_args,
            order_func_nb=order_func_nb,
            order_args=order_args,
            post_order_func_nb=post_order_func_nb,
            post_order_args=post_order_args,
            call_pre_segment=call_pre_segment,
            call_post_segment=call_post_segment,
            ffill_val_price=ffill_val_price,
            update_value=update_value,
            fill_pos_record=fill_pos_record,
            max_orders=max_orders,
            max_logs=max_logs
        )

    # Create an instance
    return cls(
        wrapper,
        close,
        order_records,
        log_records,
        init_cash if init_cash_mode is None else init_cash_mode,
        cash_sharing,
        call_seq,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.from_orders"><code class="name flex">
<span>def <span class="ident">from_orders</span></span>(<span>close, size=None, size_type=None, direction=None, price=None, fees=None, fixed_fees=None, slippage=None, min_size=None, max_size=None, reject_prob=None, lock_cash=None, allow_partial=None, raise_reject=None, log=None, val_price=None, init_cash=None, cash_sharing=None, call_seq=None, ffill_val_price=None, update_value=None, max_orders=None, max_logs=None, seed=None, group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate portfolio from orders.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>close</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>Last asset price at each time step.
Will broadcast.</p>
<p>Used for calculating unrealized P&amp;L and portfolio value.</p>
</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Size to order.
See <code><a title="vectorbt.portfolio.enums.Order.size" href="enums.html#vectorbt.portfolio.enums.Order.size">Order.size</a></code>. Will broadcast.</dd>
<dt><strong><code>size_type</code></strong> :&ensp;<code>SizeType</code> or <code>array_like</code></dt>
<dd>
<p>See <code><a title="vectorbt.portfolio.enums.SizeType" href="enums.html#vectorbt.portfolio.enums.SizeType">SizeType</a></code>.
See <code><a title="vectorbt.portfolio.enums.Order.size_type" href="enums.html#vectorbt.portfolio.enums.Order.size_type">Order.size_type</a></code>. Will broadcast.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>SizeType.Percent</code> does not support position reversal. Switch to a single direction.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Be cautious using <code>SizeType.Percent</code> with <code>call_seq</code> set to 'auto'.
To execute sell orders before buy orders, the value of each order in the group
needs to be approximated in advance. But since <code>SizeType.Percent</code> depends
upon the cash balance, which cannot be calculated in advance since it may change
after each order, this can yield a non-optimal call sequence.</p>
</div>
</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>Direction</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.enums.Direction" href="enums.html#vectorbt.portfolio.enums.Direction">Direction</a></code>.
See <code><a title="vectorbt.portfolio.enums.Order.direction" href="enums.html#vectorbt.portfolio.enums.Order.direction">Order.direction</a></code>. Will broadcast.</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>
<p>Order price.
See <code><a title="vectorbt.portfolio.enums.Order.price" href="enums.html#vectorbt.portfolio.enums.Order.price">Order.price</a></code>. Defaults to <code>np.inf</code>. Will broadcast.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Make sure to use the same timestamp for all order prices in the group with cash sharing
and <code>call_seq</code> set to <code>CallSeqType.Auto</code>.</p>
</div>
</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fees in percentage of the order value.
See <code><a title="vectorbt.portfolio.enums.Order.fees" href="enums.html#vectorbt.portfolio.enums.Order.fees">Order.fees</a></code>. Will broadcast.</dd>
<dt><strong><code>fixed_fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Fixed amount of fees to pay per order.
See <code><a title="vectorbt.portfolio.enums.Order.fixed_fees" href="enums.html#vectorbt.portfolio.enums.Order.fixed_fees">Order.fixed_fees</a></code>. Will broadcast.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Slippage in percentage of price.
See <code><a title="vectorbt.portfolio.enums.Order.slippage" href="enums.html#vectorbt.portfolio.enums.Order.slippage">Order.slippage</a></code>. Will broadcast.</dd>
<dt><strong><code>min_size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Minimum size for an order to be accepted.
See <code><a title="vectorbt.portfolio.enums.Order.min_size" href="enums.html#vectorbt.portfolio.enums.Order.min_size">Order.min_size</a></code>. Will broadcast.</dd>
<dt><strong><code>max_size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>
<p>Maximum size for an order.
See <code><a title="vectorbt.portfolio.enums.Order.max_size" href="enums.html#vectorbt.portfolio.enums.Order.max_size">Order.max_size</a></code>. Will broadcast.</p>
<p>Will be partially filled if exceeded.</p>
</dd>
<dt><strong><code>reject_prob</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Order rejection probability.
See <code><a title="vectorbt.portfolio.enums.Order.reject_prob" href="enums.html#vectorbt.portfolio.enums.Order.reject_prob">Order.reject_prob</a></code>. Will broadcast.</dd>
<dt><strong><code>lock_cash</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>Whether to lock cash when shorting.
See <code><a title="vectorbt.portfolio.enums.Order.lock_cash" href="enums.html#vectorbt.portfolio.enums.Order.lock_cash">Order.lock_cash</a></code>. Will broadcast.</dd>
<dt><strong><code>allow_partial</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>
<p>Whether to allow partial fills.
See <code><a title="vectorbt.portfolio.enums.Order.allow_partial" href="enums.html#vectorbt.portfolio.enums.Order.allow_partial">Order.allow_partial</a></code>. Will broadcast.</p>
<p>Does not apply when size is <code>np.inf</code>.</p>
</dd>
<dt><strong><code>raise_reject</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>Whether to raise an exception if order gets rejected.
See <code><a title="vectorbt.portfolio.enums.Order.raise_reject" href="enums.html#vectorbt.portfolio.enums.Order.raise_reject">Order.raise_reject</a></code>. Will broadcast.</dd>
<dt><strong><code>log</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>Whether to log orders.
See <code><a title="vectorbt.portfolio.enums.Order.log" href="enums.html#vectorbt.portfolio.enums.Order.log">Order.log</a></code>. Will broadcast.</dd>
<dt><strong><code>val_price</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>
<p>Asset valuation price.
Will broadcast.</p>
<ul>
<li>Any <code>-np.inf</code> element is replaced by the latest valuation price (the previous <code>close</code> or
the latest known valuation price if <code>ffill_val_price</code>).</li>
<li>Any <code>np.inf</code> element is replaced by the current order price.</li>
</ul>
<p>Used at the time of decision making to calculate value of each asset in the group,
for example, to convert target value into target amount.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In contrast to <code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">Portfolio.from_order_func()</a></code>, order price is known beforehand (kind of),
thus <code>val_price</code> is set to the current order price (using <code>np.inf</code>) by default.
To valuate using previous close, set it in the settings to <code>-np.inf</code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Make sure to use timestamp for <code>val_price</code> that comes before timestamps of
all orders in the group with cash sharing (previous <code>close</code> for example),
otherwise you're cheating yourself.</p>
</div>
</dd>
<dt><strong><code>init_cash</code></strong> :&ensp;<code>InitCashMode, float</code> or <code>array_like</code> of <code>float</code></dt>
<dd>
<p>Initial capital.</p>
<p>By default, will broadcast to the number of columns.
If cash sharing is enabled, will broadcast to the number of groups.
See <code><a title="vectorbt.portfolio.enums.InitCashMode" href="enums.html#vectorbt.portfolio.enums.InitCashMode">InitCashMode</a></code> to find optimal initial cash.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mode <code>InitCashMode.AutoAlign</code> is applied after the portfolio is initialized
to set the same initial cash for all columns/groups. Changing grouping
will change the initial cash, so be aware when indexing.</p>
</div>
</dd>
<dt><strong><code>cash_sharing</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to share cash within the same group.</p>
<p>If <code>group_by</code> is None, <code>group_by</code> becomes True to form a single group with cash sharing.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Introduces cross-asset dependencies.</p>
<p>This method presumes that in a group of assets that share the same capital all
orders will be executed within the same tick and retain their price regardless
of their position in the queue, even though they depend upon each other and thus
cannot be executed in parallel.</p>
</div>
</dd>
<dt><strong><code>call_seq</code></strong> :&ensp;<code>CallSeqType</code> or <code>array_like</code></dt>
<dd>
<p>Default sequence of calls per row and group.</p>
<p>Each value in this sequence should indicate the position of column in the group to
call next. Processing of <code>call_seq</code> goes always from left to right.
For example, <code>[2, 0, 1]</code> would first call column 'c', then 'a', and finally 'b'.</p>
<ul>
<li>Use <code><a title="vectorbt.portfolio.enums.CallSeqType" href="enums.html#vectorbt.portfolio.enums.CallSeqType">CallSeqType</a></code> to select a sequence type.</li>
<li>Set to array to specify custom sequence. Will not broadcast.</li>
</ul>
<p>If <code>CallSeqType.Auto</code> selected, rearranges calls dynamically based on order value.
Calculates value of all orders per row and group, and sorts them by this value.
Sell orders will be executed first to release funds for buy orders.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code>CallSeqType.Auto</code> should be used with caution:</p>
<ul>
<li>It not only presumes that order prices are known beforehand, but also that
orders can be executed in arbitrary order and still retain their price.
In reality, this is hardly the case: after processing one asset, some time
has passed and the price for other assets might have already changed.</li>
<li>Even if you're able to specify a slippage large enough to compensate for
this behavior, slippage itself should depend upon execution order.
This method doesn't let you do that.</li>
<li>If one order is rejected, it still may execute next orders and possibly
leave them without required funds.</li>
</ul>
<p>For more control, use <code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">Portfolio.from_order_func()</a></code>.</p>
</div>
</dd>
<dt><strong><code>ffill_val_price</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to track valuation price only if it's known.</p>
<p>Otherwise, unknown <code>close</code> will lead to NaN in valuation price at the next timestamp.</p>
</dd>
<dt><strong><code>update_value</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to update group value after each filled order.</dd>
<dt><strong><code>max_orders</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Size of the order records array.
Defaults to the number of elements in the broadcasted shape.</p>
<p>Set to a lower number if you run out of memory.</p>
</dd>
<dt><strong><code>max_logs</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Size of the log records array.
Defaults to the number of elements in the broadcasted shape if any of the <code>log</code> is True,
otherwise to 1.</p>
<p>Set to a lower number if you run out of memory.</p>
</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Seed to be set for both <code>call_seq</code> and at the beginning of the simulation.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>broadcast_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>.</dd>
<dt><strong><code>wrapper_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>any</code></dt>
<dd>Index frequency in case it cannot be parsed from <code>close</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>All broadcastable arguments will broadcast using <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>
but keep original shape to utilize flexible indexing and to save memory.</p>
<p>For defaults, see <code>portfolio</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When <code>call_seq</code> is not <code>CallSeqType.Auto</code>, at each timestamp, processing of the assets in
a group goes strictly in order defined in <code>call_seq</code>. This order can't be changed dynamically.</p>
<p>This has one big implication for this particular method: the last asset in the call stack
cannot be processed until other assets are processed. This is the reason why rebalancing
cannot work properly in this setting: one has to specify percentages for all assets beforehand
and then tweak the processing order to sell to-be-sold assets first in order to release funds
for to-be-bought assets. This can be automatically done by using <code>CallSeqType.Auto</code>.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>All broadcastable arguments can be set per frame, series, row, column, or element.</p>
</div>
<h2 id="example">Example</h2>
<p>Buy 10 units each tick:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(close, 10)

&gt;&gt;&gt; pf.assets()
0    10.0
1    20.0
2    30.0
3    40.0
4    40.0
dtype: float64
&gt;&gt;&gt; pf.cash()
0    90.0
1    70.0
2    40.0
3     0.0
4     0.0
dtype: float64
</code></pre>
<p>Reverse each position by first closing it:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; size = [1, 0, -1, 0, 1]
&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(close, size, size_type='targetpercent')

&gt;&gt;&gt; pf.assets()
0    100.000000
1      0.000000
2    -66.666667
3      0.000000
4     26.666667
dtype: float64
&gt;&gt;&gt; pf.cash()
0      0.000000
1    200.000000
2    400.000000
3    133.333333
4      0.000000
dtype: float64
</code></pre>
<p>Equal-weighted portfolio as in <code><a title="vectorbt.portfolio.nb.simulate_nb" href="nb.html#vectorbt.portfolio.nb.simulate_nb">simulate_nb()</a></code> example:
It's more compact but has less control over execution:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np

&gt;&gt;&gt; np.random.seed(42)
&gt;&gt;&gt; close = pd.DataFrame(np.random.uniform(1, 10, size=(5, 3)))
&gt;&gt;&gt; size = pd.Series(np.full(5, 1/3))  # each column 33.3%
&gt;&gt;&gt; size[1::2] = np.nan  # skip every second tick

&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(
...     close,  # acts both as reference and order price here
...     size,
...     size_type='targetpercent',
...     call_seq='auto',  # first sell then buy
...     group_by=True,  # one group
...     cash_sharing=True,  # assets share the same cash
...     fees=0.001, fixed_fees=1., slippage=0.001  # costs
... )

&gt;&gt;&gt; pf.asset_value(group_by=False).vbt.plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/simulate_nb.svg"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_orders(cls: tp.Type[PortfolioT],
                close: tp.ArrayLike,
                size: tp.Optional[tp.ArrayLike] = None,
                size_type: tp.Optional[tp.ArrayLike] = None,
                direction: tp.Optional[tp.ArrayLike] = None,
                price: tp.Optional[tp.ArrayLike] = None,
                fees: tp.Optional[tp.ArrayLike] = None,
                fixed_fees: tp.Optional[tp.ArrayLike] = None,
                slippage: tp.Optional[tp.ArrayLike] = None,
                min_size: tp.Optional[tp.ArrayLike] = None,
                max_size: tp.Optional[tp.ArrayLike] = None,
                reject_prob: tp.Optional[tp.ArrayLike] = None,
                lock_cash: tp.Optional[tp.ArrayLike] = None,
                allow_partial: tp.Optional[tp.ArrayLike] = None,
                raise_reject: tp.Optional[tp.ArrayLike] = None,
                log: tp.Optional[tp.ArrayLike] = None,
                val_price: tp.Optional[tp.ArrayLike] = None,
                init_cash: tp.Optional[tp.ArrayLike] = None,
                cash_sharing: tp.Optional[bool] = None,
                call_seq: tp.Optional[tp.ArrayLike] = None,
                ffill_val_price: tp.Optional[bool] = None,
                update_value: tp.Optional[bool] = None,
                max_orders: tp.Optional[int] = None,
                max_logs: tp.Optional[int] = None,
                seed: tp.Optional[int] = None,
                group_by: tp.GroupByLike = None,
                broadcast_kwargs: tp.KwargsLike = None,
                wrapper_kwargs: tp.KwargsLike = None,
                freq: tp.Optional[tp.FrequencyLike] = None,
                **kwargs) -&gt; PortfolioT:
    &#34;&#34;&#34;Simulate portfolio from orders.

    Args:
        close (array_like): Last asset price at each time step.
            Will broadcast.

            Used for calculating unrealized P&amp;L and portfolio value.
        size (float or array_like): Size to order.
            See `vectorbt.portfolio.enums.Order.size`. Will broadcast.
        size_type (SizeType or array_like): See `vectorbt.portfolio.enums.SizeType`.
            See `vectorbt.portfolio.enums.Order.size_type`. Will broadcast.

            !!! note
                `SizeType.Percent` does not support position reversal. Switch to a single direction.

            !!! warning
                Be cautious using `SizeType.Percent` with `call_seq` set to &#39;auto&#39;.
                To execute sell orders before buy orders, the value of each order in the group
                needs to be approximated in advance. But since `SizeType.Percent` depends
                upon the cash balance, which cannot be calculated in advance since it may change
                after each order, this can yield a non-optimal call sequence.
        direction (Direction or array_like): See `vectorbt.portfolio.enums.Direction`.
            See `vectorbt.portfolio.enums.Order.direction`. Will broadcast.
        price (array_like of float): Order price.
            See `vectorbt.portfolio.enums.Order.price`. Defaults to `np.inf`. Will broadcast.

            !!! note
                Make sure to use the same timestamp for all order prices in the group with cash sharing
                and `call_seq` set to `CallSeqType.Auto`.
        fees (float or array_like): Fees in percentage of the order value.
            See `vectorbt.portfolio.enums.Order.fees`. Will broadcast.
        fixed_fees (float or array_like): Fixed amount of fees to pay per order.
            See `vectorbt.portfolio.enums.Order.fixed_fees`. Will broadcast.
        slippage (float or array_like): Slippage in percentage of price.
            See `vectorbt.portfolio.enums.Order.slippage`. Will broadcast.
        min_size (float or array_like): Minimum size for an order to be accepted.
            See `vectorbt.portfolio.enums.Order.min_size`. Will broadcast.
        max_size (float or array_like): Maximum size for an order.
            See `vectorbt.portfolio.enums.Order.max_size`. Will broadcast.

            Will be partially filled if exceeded.
        reject_prob (float or array_like): Order rejection probability.
            See `vectorbt.portfolio.enums.Order.reject_prob`. Will broadcast.
        lock_cash (bool or array_like): Whether to lock cash when shorting.
            See `vectorbt.portfolio.enums.Order.lock_cash`. Will broadcast.
        allow_partial (bool or array_like): Whether to allow partial fills.
            See `vectorbt.portfolio.enums.Order.allow_partial`. Will broadcast.

            Does not apply when size is `np.inf`.
        raise_reject (bool or array_like): Whether to raise an exception if order gets rejected.
            See `vectorbt.portfolio.enums.Order.raise_reject`. Will broadcast.
        log (bool or array_like): Whether to log orders.
            See `vectorbt.portfolio.enums.Order.log`. Will broadcast.
        val_price (array_like of float): Asset valuation price.
            Will broadcast.

            * Any `-np.inf` element is replaced by the latest valuation price (the previous `close` or
                the latest known valuation price if `ffill_val_price`).
            * Any `np.inf` element is replaced by the current order price.

            Used at the time of decision making to calculate value of each asset in the group,
            for example, to convert target value into target amount.

            !!! note
                In contrast to `Portfolio.from_order_func`, order price is known beforehand (kind of),
                thus `val_price` is set to the current order price (using `np.inf`) by default.
                To valuate using previous close, set it in the settings to `-np.inf`.

            !!! note
                Make sure to use timestamp for `val_price` that comes before timestamps of
                all orders in the group with cash sharing (previous `close` for example),
                otherwise you&#39;re cheating yourself.
        init_cash (InitCashMode, float or array_like of float): Initial capital.

            By default, will broadcast to the number of columns.
            If cash sharing is enabled, will broadcast to the number of groups.
            See `vectorbt.portfolio.enums.InitCashMode` to find optimal initial cash.

            !!! note
                Mode `InitCashMode.AutoAlign` is applied after the portfolio is initialized
                to set the same initial cash for all columns/groups. Changing grouping
                will change the initial cash, so be aware when indexing.
        cash_sharing (bool): Whether to share cash within the same group.

            If `group_by` is None, `group_by` becomes True to form a single group with cash sharing.

            !!! warning
                Introduces cross-asset dependencies.

                This method presumes that in a group of assets that share the same capital all
                orders will be executed within the same tick and retain their price regardless
                of their position in the queue, even though they depend upon each other and thus
                cannot be executed in parallel.
        call_seq (CallSeqType or array_like): Default sequence of calls per row and group.

            Each value in this sequence should indicate the position of column in the group to
            call next. Processing of `call_seq` goes always from left to right.
            For example, `[2, 0, 1]` would first call column &#39;c&#39;, then &#39;a&#39;, and finally &#39;b&#39;.

            * Use `vectorbt.portfolio.enums.CallSeqType` to select a sequence type.
            * Set to array to specify custom sequence. Will not broadcast.

            If `CallSeqType.Auto` selected, rearranges calls dynamically based on order value.
            Calculates value of all orders per row and group, and sorts them by this value.
            Sell orders will be executed first to release funds for buy orders.

            !!! warning
                `CallSeqType.Auto` should be used with caution:

                * It not only presumes that order prices are known beforehand, but also that
                    orders can be executed in arbitrary order and still retain their price.
                    In reality, this is hardly the case: after processing one asset, some time
                    has passed and the price for other assets might have already changed.
                * Even if you&#39;re able to specify a slippage large enough to compensate for
                    this behavior, slippage itself should depend upon execution order.
                    This method doesn&#39;t let you do that.
                * If one order is rejected, it still may execute next orders and possibly
                    leave them without required funds.

                For more control, use `Portfolio.from_order_func`.
        ffill_val_price (bool): Whether to track valuation price only if it&#39;s known.

            Otherwise, unknown `close` will lead to NaN in valuation price at the next timestamp.
        update_value (bool): Whether to update group value after each filled order.
        max_orders (int): Size of the order records array.
            Defaults to the number of elements in the broadcasted shape.

            Set to a lower number if you run out of memory.
        max_logs (int): Size of the log records array.
            Defaults to the number of elements in the broadcasted shape if any of the `log` is True,
            otherwise to 1.

            Set to a lower number if you run out of memory.
        seed (int): Seed to be set for both `call_seq` and at the beginning of the simulation.
        group_by (any): Group columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        broadcast_kwargs (dict): Keyword arguments passed to `vectorbt.base.reshape_fns.broadcast`.
        wrapper_kwargs (dict): Keyword arguments passed to `vectorbt.base.array_wrapper.ArrayWrapper`.
        freq (any): Index frequency in case it cannot be parsed from `close`.
        **kwargs: Keyword arguments passed to the `__init__` method.

    All broadcastable arguments will broadcast using `vectorbt.base.reshape_fns.broadcast`
    but keep original shape to utilize flexible indexing and to save memory.

    For defaults, see `portfolio` in `vectorbt._settings.settings`.

    !!! note
        When `call_seq` is not `CallSeqType.Auto`, at each timestamp, processing of the assets in
        a group goes strictly in order defined in `call_seq`. This order can&#39;t be changed dynamically.

        This has one big implication for this particular method: the last asset in the call stack
        cannot be processed until other assets are processed. This is the reason why rebalancing
        cannot work properly in this setting: one has to specify percentages for all assets beforehand
        and then tweak the processing order to sell to-be-sold assets first in order to release funds
        for to-be-bought assets. This can be automatically done by using `CallSeqType.Auto`.

    !!! hint
        All broadcastable arguments can be set per frame, series, row, column, or element.

    ## Example

    Buy 10 units each tick:

    ```python-repl
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
    &gt;&gt;&gt; pf = vbt.Portfolio.from_orders(close, 10)

    &gt;&gt;&gt; pf.assets()
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    40.0
    dtype: float64
    &gt;&gt;&gt; pf.cash()
    0    90.0
    1    70.0
    2    40.0
    3     0.0
    4     0.0
    dtype: float64
    ```

    Reverse each position by first closing it:

    ```python-repl
    &gt;&gt;&gt; size = [1, 0, -1, 0, 1]
    &gt;&gt;&gt; pf = vbt.Portfolio.from_orders(close, size, size_type=&#39;targetpercent&#39;)

    &gt;&gt;&gt; pf.assets()
    0    100.000000
    1      0.000000
    2    -66.666667
    3      0.000000
    4     26.666667
    dtype: float64
    &gt;&gt;&gt; pf.cash()
    0      0.000000
    1    200.000000
    2    400.000000
    3    133.333333
    4      0.000000
    dtype: float64
    ```

    Equal-weighted portfolio as in `vectorbt.portfolio.nb.simulate_nb` example:
    It&#39;s more compact but has less control over execution:

    ```python-repl
    &gt;&gt;&gt; import numpy as np

    &gt;&gt;&gt; np.random.seed(42)
    &gt;&gt;&gt; close = pd.DataFrame(np.random.uniform(1, 10, size=(5, 3)))
    &gt;&gt;&gt; size = pd.Series(np.full(5, 1/3))  # each column 33.3%
    &gt;&gt;&gt; size[1::2] = np.nan  # skip every second tick

    &gt;&gt;&gt; pf = vbt.Portfolio.from_orders(
    ...     close,  # acts both as reference and order price here
    ...     size,
    ...     size_type=&#39;targetpercent&#39;,
    ...     call_seq=&#39;auto&#39;,  # first sell then buy
    ...     group_by=True,  # one group
    ...     cash_sharing=True,  # assets share the same cash
    ...     fees=0.001, fixed_fees=1., slippage=0.001  # costs
    ... )

    &gt;&gt;&gt; pf.asset_value(group_by=False).vbt.plot()
    ```

    ![](/vectorbt/docs/img/simulate_nb.svg)
    &#34;&#34;&#34;
    # Get defaults
    from vectorbt._settings import settings
    portfolio_cfg = settings[&#39;portfolio&#39;]

    if size is None:
        size = portfolio_cfg[&#39;size&#39;]
    if size_type is None:
        size_type = portfolio_cfg[&#39;size_type&#39;]
    size_type = cast_enum_value(size_type, SizeType)
    if direction is None:
        direction = portfolio_cfg[&#39;order_direction&#39;]
    direction = cast_enum_value(direction, Direction)
    if price is None:
        price = np.inf
    if size is None:
        size = portfolio_cfg[&#39;size&#39;]
    if fees is None:
        fees = portfolio_cfg[&#39;fees&#39;]
    if fixed_fees is None:
        fixed_fees = portfolio_cfg[&#39;fixed_fees&#39;]
    if slippage is None:
        slippage = portfolio_cfg[&#39;slippage&#39;]
    if min_size is None:
        min_size = portfolio_cfg[&#39;min_size&#39;]
    if max_size is None:
        max_size = portfolio_cfg[&#39;max_size&#39;]
    if reject_prob is None:
        reject_prob = portfolio_cfg[&#39;reject_prob&#39;]
    if lock_cash is None:
        lock_cash = portfolio_cfg[&#39;lock_cash&#39;]
    if allow_partial is None:
        allow_partial = portfolio_cfg[&#39;allow_partial&#39;]
    if raise_reject is None:
        raise_reject = portfolio_cfg[&#39;raise_reject&#39;]
    if log is None:
        log = portfolio_cfg[&#39;log&#39;]
    if val_price is None:
        val_price = portfolio_cfg[&#39;val_price&#39;]
    if init_cash is None:
        init_cash = portfolio_cfg[&#39;init_cash&#39;]
    init_cash = cast_enum_value(init_cash, InitCashMode)
    if isinstance(init_cash, int) and init_cash in InitCashMode:
        init_cash_mode = init_cash
        init_cash = np.inf
    else:
        init_cash_mode = None
    if cash_sharing is None:
        cash_sharing = portfolio_cfg[&#39;cash_sharing&#39;]
    if cash_sharing and group_by is None:
        group_by = True
    if call_seq is None:
        call_seq = portfolio_cfg[&#39;call_seq&#39;]
    call_seq = cast_enum_value(call_seq, CallSeqType)
    auto_call_seq = False
    if isinstance(call_seq, int):
        if call_seq == CallSeqType.Auto:
            call_seq = CallSeqType.Default
            auto_call_seq = True
    if ffill_val_price is None:
        ffill_val_price = portfolio_cfg[&#39;ffill_val_price&#39;]
    if update_value is None:
        update_value = portfolio_cfg[&#39;update_value&#39;]
    if seed is None:
        seed = portfolio_cfg[&#39;seed&#39;]
    if seed is not None:
        set_seed(seed)
    if freq is None:
        freq = portfolio_cfg[&#39;freq&#39;]
    if broadcast_kwargs is None:
        broadcast_kwargs = {}
    if wrapper_kwargs is None:
        wrapper_kwargs = {}
    if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
        raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

    # Broadcast inputs
    # Only close is broadcast, others can remain unchanged thanks to flexible indexing
    broadcastable_args = (
        close,
        size,
        price,
        size_type,
        direction,
        fees,
        fixed_fees,
        slippage,
        min_size,
        max_size,
        reject_prob,
        lock_cash,
        allow_partial,
        raise_reject,
        log,
        val_price
    )
    broadcast_kwargs = merge_dicts(dict(
        keep_raw=[False] + [True] * (len(broadcastable_args) - 1),
        require_kwargs=dict(requirements=&#39;W&#39;)
    ), broadcast_kwargs)
    broadcasted_args = broadcast(*broadcastable_args, **broadcast_kwargs)
    close = broadcasted_args[0]
    if not checks.is_pandas(close):
        close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
    target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
    wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
    cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
    init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
    group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
    if checks.is_any_array(call_seq):
        call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
    else:
        call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
    if max_orders is None:
        max_orders = target_shape_2d[0] * target_shape_2d[1]
    if max_logs is None:
        max_logs = target_shape_2d[0] * target_shape_2d[1]
    if not np.any(log):
        max_logs = 1

    # Perform calculation
    order_records, log_records = nb.simulate_from_orders_nb(
        target_shape_2d,
        to_2d(close, raw=True),
        cs_group_lens,  # group only if cash sharing is enabled to speed up
        init_cash,
        call_seq,
        *map(np.asarray, broadcasted_args[1:]),
        auto_call_seq,
        ffill_val_price,
        update_value,
        max_orders,
        max_logs,
        close.ndim == 2
    )

    # Create an instance
    return cls(
        wrapper,
        close,
        order_records,
        log_records,
        init_cash if init_cash_mode is None else init_cash_mode,
        cash_sharing,
        call_seq,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.from_random_signals"><code class="name flex">
<span>def <span class="ident">from_random_signals</span></span>(<span>close, n=None, prob=None, entry_prob=None, exit_prob=None, param_product=False, seed=None, run_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate portfolio from random entry and exit signals.</p>
<p>Generates signals based either on the number of signals <code>n</code> or the probability
of encountering a signal <code>prob</code>.</p>
<p>If <code>n</code> is set, see <code><a title="vectorbt.signals.generators.RAND" href="../signals/generators.html#vectorbt.signals.generators.RAND">RAND</a></code>.
If <code>prob</code> is set, see <code><a title="vectorbt.signals.generators.RPROB" href="../signals/generators.html#vectorbt.signals.generators.RPROB">RPROB</a></code>.</p>
<p>Based on <code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">Portfolio.from_signals()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_random_signals(cls: tp.Type[PortfolioT],
                        close: tp.ArrayLike,
                        n: tp.Optional[tp.ArrayLike] = None,
                        prob: tp.Optional[tp.ArrayLike] = None,
                        entry_prob: tp.Optional[tp.ArrayLike] = None,
                        exit_prob: tp.Optional[tp.ArrayLike] = None,
                        param_product: bool = False,
                        seed: tp.Optional[int] = None,
                        run_kwargs: tp.KwargsLike = None,
                        **kwargs) -&gt; PortfolioT:
    &#34;&#34;&#34;Simulate portfolio from random entry and exit signals.

    Generates signals based either on the number of signals `n` or the probability
    of encountering a signal `prob`.

    If `n` is set, see `vectorbt.signals.generators.RAND`.
    If `prob` is set, see `vectorbt.signals.generators.RPROB`.

    Based on `Portfolio.from_signals`.&#34;&#34;&#34;
    from vectorbt._settings import settings
    portfolio_cfg = settings[&#39;portfolio&#39;]

    close = to_pd_array(close)
    if entry_prob is None:
        entry_prob = prob
    if exit_prob is None:
        exit_prob = prob
    if seed is None:
        seed = portfolio_cfg[&#39;seed&#39;]
    if run_kwargs is None:
        run_kwargs = {}

    if n is not None and (entry_prob is not None or exit_prob is not None):
        raise ValueError(&#34;Either n or entry_prob and exit_prob should be set&#34;)
    if n is not None:
        rand = RAND.run(
            n=n,
            input_shape=close.shape,
            input_index=close.vbt.wrapper.index,
            input_columns=close.vbt.wrapper.columns,
            seed=seed,
            **run_kwargs
        )
        entries = rand.entries
        exits = rand.exits
    elif entry_prob is not None and exit_prob is not None:
        rprob = RPROB.run(
            entry_prob=entry_prob,
            exit_prob=exit_prob,
            param_product=param_product,
            input_shape=close.shape,
            input_index=close.vbt.wrapper.index,
            input_columns=close.vbt.wrapper.columns,
            seed=seed,
            **run_kwargs
        )
        entries = rprob.entries
        exits = rprob.exits
    else:
        raise ValueError(&#34;At least n or entry_prob and exit_prob should be set&#34;)

    return cls.from_signals(close, entries, exits, seed=seed, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.from_signals"><code class="name flex">
<span>def <span class="ident">from_signals</span></span>(<span>close, entries=None, exits=None, size=None, size_type=None, direction=None, price=None, fees=None, fixed_fees=None, slippage=None, min_size=None, max_size=None, reject_prob=None, lock_cash=None, allow_partial=None, raise_reject=None, log=None, accumulate=None, conflict_mode=None, close_first=None, val_price=None, open=None, high=None, low=None, sl_stop=None, sl_trail=None, tp_stop=None, stop_entry_price=None, stop_exit_price=None, stop_conflict_mode=None, stop_exit_mode=None, stop_update_mode=None, adjust_sl_func_nb=CPUDispatcher(&lt;function no_adjust_sl_func_nb&gt;), adjust_sl_args=(), adjust_tp_func_nb=CPUDispatcher(&lt;function no_adjust_tp_func_nb&gt;), adjust_tp_args=(), use_stops=None, init_cash=None, cash_sharing=None, call_seq=None, ffill_val_price=None, update_value=None, max_orders=None, max_logs=None, seed=None, group_by=None, broadcast_kwargs=None, wrapper_kwargs=None, freq=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate portfolio from entry and exit signals.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>close</code></strong> :&ensp;<code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>entries</code></strong> :&ensp;<code>array_like</code> of <code>bool</code></dt>
<dd>
<p>Boolean array of entry signals.
Defaults to True. Will broadcast.</p>
<p>Becomes a long signal if <code>direction</code> is <code>all</code> or <code>longonly</code>, otherwise short.</p>
</dd>
<dt><strong><code>exits</code></strong> :&ensp;<code>array_like</code> of <code>bool</code></dt>
<dd>
<p>Boolean array of exit signals.
Defaults to False. Will broadcast.</p>
<p>Becomes a short signal if <code>direction</code> is <code>all</code> or <code>longonly</code>, otherwise long.</p>
</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>
<p>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Negative size is not allowed. You should express direction using signals.</p>
</div>
</dd>
<dt><strong><code>size_type</code></strong> :&ensp;<code>SizeType</code> or <code>array_like</code></dt>
<dd>
<p>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
<p>Only <code>SizeType.Amount</code>, <code>SizeType.Value</code>, and <code>SizeType.Percent</code> are supported.
Other modes such as target percentage are not compatible with signals since
their logic may contradict the direction of the signal.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>SizeType.Percent</code> does not support position reversal. Switch to a single
direction or use <code>close_first</code>.</p>
</div>
<p>See warning in <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>Direction</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>fixed_fees</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>slippage</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>min_size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>max_size</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>
<p>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
<p>Will be partially filled if exceeded. You might not be able to properly close
the position if accumulation is enabled and <code>max_size</code> is too low.</p>
</dd>
<dt><strong><code>reject_prob</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>lock_cash</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>allow_partial</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>raise_reject</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>log</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>accumulate</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>
<p>Whether to accumulate signals.
Will broadcast.</p>
<p>Allows gradually increasing and decreasing positions using <code>size</code>.
When enabled, <code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">Portfolio.from_signals()</a></code> behaves like <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
</dd>
<dt><strong><code>conflict_mode</code></strong> :&ensp;<code>ConflictMode</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.enums.ConflictMode" href="enums.html#vectorbt.portfolio.enums.ConflictMode">ConflictMode</a></code>.
Will broadcast.</dd>
<dt><strong><code>close_first</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>
<p>Whether to close the position first before reversal.
Will broadcast.</p>
<p>Otherwise reverses the position with a single order and within the same tick.
Takes only effect under <code>Direction.All</code>. Requires a second signal to enter
the opposite position. This allows to define parameters such as <code>fixed_fees</code> for long
and short positions separately.</p>
</dd>
<dt><strong><code>val_price</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>open</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>
<p>First asset price at each time step.
Defaults to <code>np.nan</code>, which gets replaced by <code>close</code>. Will broadcast.</p>
<p>Used solely for stop signals.</p>
</dd>
<dt><strong><code>high</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>
<p>Highest asset price at each time step.
Defaults to <code>np.nan</code>, which gets replaced by the maximum out of <code>open</code> and <code>close</code>. Will broadcast.</p>
<p>Used solely for stop signals.</p>
</dd>
<dt><strong><code>low</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>
<p>Lowest asset price at each time step.
Defaults to <code>np.nan</code>, which gets replaced by the minimum out of <code>open</code> and <code>close</code>. Will broadcast.</p>
<p>Used solely for stop signals.</p>
</dd>
<dt><strong><code>sl_stop</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>
<p>Stop loss.
Will broadcast.</p>
<p>A percentage below/above the acquisition price for long/short position.
Note that 0.01 = 1%.</p>
</dd>
<dt><strong><code>sl_trail</code></strong> :&ensp;<code>array_like</code> of <code>bool</code></dt>
<dd>Whether <code>sl_stop</code> should be trailing.
Will broadcast.</dd>
<dt><strong><code>tp_stop</code></strong> :&ensp;<code>array_like</code> of <code>float</code></dt>
<dd>
<p>Take profit.
Will broadcast.</p>
<p>A percentage above/below the acquisition price for long/short position.
Note that 0.01 = 1%.</p>
</dd>
<dt><strong><code>stop_entry_price</code></strong> :&ensp;<code>StopEntryPrice</code> or <code>array_like</code></dt>
<dd>
<p>See <code><a title="vectorbt.portfolio.enums.StopEntryPrice" href="enums.html#vectorbt.portfolio.enums.StopEntryPrice">StopEntryPrice</a></code>.
Will broadcast.</p>
<p>If provided on per-element basis, gets applied upon entry.</p>
</dd>
<dt><strong><code>stop_exit_price</code></strong> :&ensp;<code>StopExitPrice</code> or <code>array_like</code></dt>
<dd>
<p>See <code><a title="vectorbt.portfolio.enums.StopExitPrice" href="enums.html#vectorbt.portfolio.enums.StopExitPrice">StopExitPrice</a></code>.
Will broadcast.</p>
<p>If provided on per-element basis, gets applied upon exit.</p>
</dd>
<dt><strong><code>stop_conflict_mode</code></strong> :&ensp;<code>StopConflictMode</code> or <code>array_like</code></dt>
<dd>
<p>See <code>vectorbt.portfolio.enums.StopConflictMode</code>.
Will broadcast.</p>
<p>If provided on per-element basis, gets applied upon exit.</p>
</dd>
<dt><strong><code>stop_exit_mode</code></strong> :&ensp;<code>StopExitMode</code> or <code>array_like</code></dt>
<dd>
<p>See <code><a title="vectorbt.portfolio.enums.StopExitMode" href="enums.html#vectorbt.portfolio.enums.StopExitMode">StopExitMode</a></code>.
Will broadcast.</p>
<p>If provided on per-element basis, gets applied upon exit.</p>
</dd>
<dt><strong><code>stop_update_mode</code></strong> :&ensp;<code>StopUpdateMode</code> or <code>array_like</code></dt>
<dd>
<p>See <code><a title="vectorbt.portfolio.enums.StopUpdateMode" href="enums.html#vectorbt.portfolio.enums.StopUpdateMode">StopUpdateMode</a></code>.
Will broadcast.</p>
<p>Only has effect is <code>accumulate</code> is True.</p>
<p>If provided on per-element basis, gets applied upon repeated entry.</p>
</dd>
<dt><strong><code>adjust_sl_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>
<p>Function to adjust stop loss.
Defaults to <code><a title="vectorbt.portfolio.nb.no_adjust_sl_func_nb" href="nb.html#vectorbt.portfolio.nb.no_adjust_sl_func_nb">no_adjust_sl_func_nb()</a></code>.</p>
<p>Called for each element before each row.</p>
<p>Should accept index of the current row, index of the current column, the current position size,
the latest asset price, initial index of the stop, initial price of the stop, initial value
of the stop, initial trailing flag of the stop, and <code>*adjust_sl_args</code>.
Should return a tuple of a new stop value and trailing flag.</p>
</dd>
<dt><strong><code>adjust_sl_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Packed arguments passed to <code>adjust_sl_func_nb</code>.
Defaults to <code>()</code>.</dd>
<dt><strong><code>adjust_tp_func_nb</code></strong> :&ensp;<code>callable</code></dt>
<dd>
<p>Function to adjust take profit.
Defaults to <code><a title="vectorbt.portfolio.nb.no_adjust_tp_func_nb" href="nb.html#vectorbt.portfolio.nb.no_adjust_tp_func_nb">no_adjust_tp_func_nb()</a></code>.</p>
<p>Called for each element before each row.</p>
<p>Should accept index of the current row, index of the current column, the current position size,
the latest asset price, initial index of the stop, initial price of the stop, initial value
of the stop, and <code>*adjust_tp_args</code>. Should return a new stop value.</p>
</dd>
<dt><strong><code>adjust_tp_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Packed arguments passed to <code>adjust_tp_func_nb</code>.
Defaults to <code>()</code>.</dd>
<dt><strong><code>use_stops</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to use stops.
Defaults to None, which becomes True if any of the stops are not NaN or
any of the adjustment functions are custom.</p>
<p>Disable this to make simulation a bit faster for simple use cases.</p>
</dd>
<dt><strong><code>init_cash</code></strong> :&ensp;<code>InitCashMode, float</code> or <code>array_like</code> of <code>float</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>cash_sharing</code></strong> :&ensp;<code>bool</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>call_seq</code></strong> :&ensp;<code>CallSeqType</code> or <code>array_like</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>ffill_val_price</code></strong> :&ensp;<code>bool</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>update_value</code></strong> :&ensp;<code>bool</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>max_orders</code></strong> :&ensp;<code>int</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>max_logs</code></strong> :&ensp;<code>int</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>broadcast_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>wrapper_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>any</code></dt>
<dd>See <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the <code>__init__</code> method.</dd>
</dl>
<p>All broadcastable arguments will broadcast using <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>
but keep original shape to utilize flexible indexing and to save memory.</p>
<p>For defaults, see <code>portfolio</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>If you generated signals using close price, don't forget to shift your signals by one tick
forward, for example, with <code>signals.vbt.fshift(1)</code>. In general, make sure to use a price
that comes after the signal.</p>
</div>
<p>Also see notes and hints for <code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">Portfolio.from_orders()</a></code>.</p>
<h2 id="example">Example</h2>
<p>Entry opens long, exit closes long:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
&gt;&gt;&gt; entries = pd.Series([True, True, True, False, False])
&gt;&gt;&gt; exits = pd.Series([False, False, True, True, True])

&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
...     close, entries, exits, size=1., direction='longonly')
&gt;&gt;&gt; pf.asset_flow()
0    1.0
1    0.0
2    0.0
3   -1.0
4    0.0
dtype: float64
</code></pre>
<p>Entry opens short, exit closes short:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
...     close, entries, exits, size=1., direction='shortonly')
&gt;&gt;&gt; pf.asset_flow()
0   -1.0
1    0.0
2    0.0
3    1.0
4    0.0
dtype: float64
</code></pre>
<p>Reversal within one tick. Entry opens long and closes short, exit closes long and opens short:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
...     close, entries, exits, size=1., direction='all')
&gt;&gt;&gt; pf.asset_flow()
0    1.0
1    0.0
2    0.0
3   -2.0
4    0.0
dtype: float64
</code></pre>
<p>Reversal within two ticks. First signal closes position, second signal opens the opposite one:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
...     close, entries, exits, size=1., direction='all',
...     close_first=True)
&gt;&gt;&gt; pf.asset_flow()
0    1.0
1    0.0
2    0.0
3   -1.0
4   -1.0
dtype: float64
</code></pre>
<p>If entry and exit, chooses exit:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
...     close, entries, exits, size=1., direction='all',
...     close_first=True, conflict_mode='exit')
&gt;&gt;&gt; pf.asset_flow()
0    1.0
1    0.0
2   -1.0
3   -1.0
4    0.0
dtype: float64
</code></pre>
<p>Entry means long order, exit means short order (acts similar to <code>from_orders</code>):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
...     close, entries, exits, size=1., direction='all',
...     accumulate=True)
&gt;&gt;&gt; pf.asset_flow()
0    1.0
1    1.0
2    0.0
3   -1.0
4   -1.0
dtype: float64
</code></pre>
<p>Testing multiple parameters (via broadcasting):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from vectorbt.portfolio.enums import Direction

&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
...     close, entries, exits, direction=[list(Direction)],
...     broadcast_kwargs=dict(columns_from=Direction._fields))
&gt;&gt;&gt; pf.asset_flow()
    Long  Short    All
0  100.0 -100.0  100.0
1    0.0    0.0    0.0
2    0.0    0.0    0.0
3 -100.0   50.0 -200.0
4    0.0    0.0    0.0
</code></pre>
<p>Specifying information in a more granular way thanks to broadcasting.
Reverse the first long position by first closing it, and all other immediately:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; entries = pd.Series([True, False, False, True, False])
&gt;&gt;&gt; exits = pd.Series([False, True, True, False, True])
&gt;&gt;&gt; close_first = pd.Series([False, True, False, False, False])
&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
...     close, entries, exits, size=1., direction='all',
...     close_first=close_first)
&gt;&gt;&gt; pf.asset_flow()
0    1.0
1   -1.0
2   -1.0
3    2.0
4   -2.0
dtype: float64
</code></pre>
<p>Set risk/reward ratio by passing trailing stop loss and take profit thresholds:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; close = pd.Series([10, 11, 12, 11, 10, 9])
&gt;&gt;&gt; entries = pd.Series([True, False, False, False, False, False])
&gt;&gt;&gt; exits = pd.Series([False, False, False, False, False, True])
&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
...     close, entries, exits,
...     sl_stop=0.1, sl_trail=True, tp_stop=0.2)  # take profit hit
&gt;&gt;&gt; pf.asset_flow()
0    10.0
1     0.0
2   -10.0
3     0.0
4     0.0
5     0.0
dtype: float64

&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
...     close, entries, exits,
...     sl_stop=0.1, sl_trail=True, tp_stop=0.3)  # stop loss hit
&gt;&gt;&gt; pf.asset_flow()
0    10.0
1     0.0
2     0.0
3     0.0
4   -10.0
5     0.0
dtype: float64

&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
...     close, entries, exits,
...     sl_stop=np.inf, sl_trail=True, tp_stop=np.inf)  # nothing hit, exit as usual
&gt;&gt;&gt; pf.asset_flow()
0    10.0
1     0.0
2     0.0
3     0.0
4     0.0
5   -10.0
dtype: float64
</code></pre>
<p>We can implement our own stop loss or take profit, or adjust the existing one at each time step.
Let's implement <a href="https://www.freqtrade.io/en/stable/strategy-advanced/#stepped-stoploss">stepped stop-loss</a>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from numba import njit

&gt;&gt;&gt; @njit
... def adjust_sl_func_nb(i, col, position, val_price, init_i, init_price, init_stop, init_trail):
...     current_profit = (val_price - init_price) / init_price
...     if current_profit &gt;= 0.40:
...         return 0.25, True
...     elif current_profit &gt;= 0.25:
...         return 0.15, True
...     elif current_profit &gt;= 0.20:
...         return 0.07, True
...     return init_stop, init_trail

&gt;&gt;&gt; close = pd.Series([10, 11, 12, 11, 10])
&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
...     close, adjust_sl_func_nb=adjust_sl_func_nb)
&gt;&gt;&gt; pf.asset_flow()
0    10.0
1     0.0
2     0.0
3   -10.0  # 7% from 12 hit
4    11.0
dtype: float64
</code></pre>
<p>Combine multiple exit conditions. Exit early if the price hits some threshold before an actual exit:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; close = pd.Series([10, 11, 12, 13, 14, 15])
&gt;&gt;&gt; entries = pd.Series([True, True, True, False, False, False])
&gt;&gt;&gt; exits = pd.Series([False, False, False, True, True, True])

&gt;&gt;&gt; # 1. Remove adjacent entries and exits
&gt;&gt;&gt; # since stop condition refers only to the first signal
&gt;&gt;&gt; entries, exits = entries.vbt.signals.clean(exits)
&gt;&gt;&gt; entries
0     True
1    False
2    False
3    False
4    False
5    False
dtype: bool
&gt;&gt;&gt; exits
0    False
1    False
2    False
3     True
4    False
5    False
dtype: bool

&gt;&gt;&gt; # 2. Find stop exits
&gt;&gt;&gt; stop_exits = entries.vbt.signals.generate_stop_exits(close, 0.1)
&gt;&gt;&gt; stop_exits
0    False
1     True
2    False
3    False
4    False
5    False
dtype: bool

&gt;&gt;&gt; # 3. Combine exits
&gt;&gt;&gt; exits = exits | stop_exits
&gt;&gt;&gt; exits
0    False
1     True
2    False
3     True
4    False
5    False
dtype: bool

&gt;&gt;&gt; # 4. Pick the first exit after each entry
&gt;&gt;&gt; exits = exits.vbt.signals.first(reset_by=entries, allow_gaps=True)
&gt;&gt;&gt; exits
0    False
1     True
2    False
3    False
4    False
5    False
dtype: bool

&gt;&gt;&gt; # 5. Simulate portfolio
&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(close, entries, exits)
&gt;&gt;&gt; pf.asset_flow()
0    10.0
1   -10.0
2     0.0
3     0.0
4     0.0
5     0.0
dtype: float64
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>By cleaning signals, we lose information. Moreover, this automatically assumes
that each entry/signal signal succeeds (= order gets filled). Use this with caution,
and consider rewriting your strategy with <code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">Portfolio.from_order_func()</a></code>, which is a
preferred way of defining a complex logic in vectorbt.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_signals(cls: tp.Type[PortfolioT],
                 close: tp.ArrayLike,
                 entries: tp.Optional[tp.ArrayLike] = None,
                 exits: tp.Optional[tp.ArrayLike] = None,
                 size: tp.Optional[tp.ArrayLike] = None,
                 size_type: tp.Optional[tp.ArrayLike] = None,
                 direction: tp.Optional[tp.ArrayLike] = None,
                 price: tp.Optional[tp.ArrayLike] = None,
                 fees: tp.Optional[tp.ArrayLike] = None,
                 fixed_fees: tp.Optional[tp.ArrayLike] = None,
                 slippage: tp.Optional[tp.ArrayLike] = None,
                 min_size: tp.Optional[tp.ArrayLike] = None,
                 max_size: tp.Optional[tp.ArrayLike] = None,
                 reject_prob: tp.Optional[tp.ArrayLike] = None,
                 lock_cash: tp.Optional[tp.ArrayLike] = None,
                 allow_partial: tp.Optional[tp.ArrayLike] = None,
                 raise_reject: tp.Optional[tp.ArrayLike] = None,
                 log: tp.Optional[tp.ArrayLike] = None,
                 accumulate: tp.Optional[tp.ArrayLike] = None,
                 conflict_mode: tp.Optional[tp.ArrayLike] = None,
                 close_first: tp.Optional[tp.ArrayLike] = None,
                 val_price: tp.Optional[tp.ArrayLike] = None,
                 open: tp.Optional[tp.ArrayLike] = None,
                 high: tp.Optional[tp.ArrayLike] = None,
                 low: tp.Optional[tp.ArrayLike] = None,
                 sl_stop: tp.Optional[tp.ArrayLike] = None,
                 sl_trail: tp.Optional[tp.ArrayLike] = None,
                 tp_stop: tp.Optional[tp.ArrayLike] = None,
                 stop_entry_price: tp.Optional[tp.ArrayLike] = None,
                 stop_exit_price: tp.Optional[tp.ArrayLike] = None,
                 stop_conflict_mode: tp.Optional[tp.ArrayLike] = None,
                 stop_exit_mode: tp.Optional[tp.ArrayLike] = None,
                 stop_update_mode: tp.Optional[tp.ArrayLike] = None,
                 adjust_sl_func_nb: nb.AdjustSLFuncT = nb.no_adjust_sl_func_nb,
                 adjust_sl_args: tp.Args = (),
                 adjust_tp_func_nb: nb.AdjustTPFuncT = nb.no_adjust_tp_func_nb,
                 adjust_tp_args: tp.Args = (),
                 use_stops: tp.Optional[bool] = None,
                 init_cash: tp.Optional[tp.ArrayLike] = None,
                 cash_sharing: tp.Optional[bool] = None,
                 call_seq: tp.Optional[tp.ArrayLike] = None,
                 ffill_val_price: tp.Optional[bool] = None,
                 update_value: tp.Optional[bool] = None,
                 max_orders: tp.Optional[int] = None,
                 max_logs: tp.Optional[int] = None,
                 seed: tp.Optional[int] = None,
                 group_by: tp.GroupByLike = None,
                 broadcast_kwargs: tp.KwargsLike = None,
                 wrapper_kwargs: tp.KwargsLike = None,
                 freq: tp.Optional[tp.FrequencyLike] = None,
                 **kwargs) -&gt; PortfolioT:
    &#34;&#34;&#34;Simulate portfolio from entry and exit signals.

    Args:
        close (array_like): See `Portfolio.from_orders`.
        entries (array_like of bool): Boolean array of entry signals.
            Defaults to True. Will broadcast.

            Becomes a long signal if `direction` is `all` or `longonly`, otherwise short.
        exits (array_like of bool): Boolean array of exit signals.
            Defaults to False. Will broadcast.

            Becomes a short signal if `direction` is `all` or `longonly`, otherwise long.
        size (float or array_like): See `Portfolio.from_orders`.

            !!! note
                Negative size is not allowed. You should express direction using signals.
        size_type (SizeType or array_like): See `Portfolio.from_orders`.

            Only `SizeType.Amount`, `SizeType.Value`, and `SizeType.Percent` are supported.
            Other modes such as target percentage are not compatible with signals since
            their logic may contradict the direction of the signal.

            !!! note
                `SizeType.Percent` does not support position reversal. Switch to a single
                direction or use `close_first`.

            See warning in `Portfolio.from_orders`.
        direction (Direction or array_like): See `Portfolio.from_orders`.
        price (array_like of float): See `Portfolio.from_orders`.
        fees (float or array_like): See `Portfolio.from_orders`.
        fixed_fees (float or array_like): See `Portfolio.from_orders`.
        slippage (float or array_like): See `Portfolio.from_orders`.
        min_size (float or array_like): See `Portfolio.from_orders`.
        max_size (float or array_like): See `Portfolio.from_orders`.

            Will be partially filled if exceeded. You might not be able to properly close
            the position if accumulation is enabled and `max_size` is too low.
        reject_prob (float or array_like): See `Portfolio.from_orders`.
        lock_cash (bool or array_like): See `Portfolio.from_orders`.
        allow_partial (bool or array_like): See `Portfolio.from_orders`.
        raise_reject (bool or array_like): See `Portfolio.from_orders`.
        log (bool or array_like): See `Portfolio.from_orders`.
        accumulate (bool or array_like): Whether to accumulate signals.
            Will broadcast.

            Allows gradually increasing and decreasing positions using `size`.
            When enabled, `Portfolio.from_signals` behaves like `Portfolio.from_orders`.
        conflict_mode (ConflictMode or array_like): See `vectorbt.portfolio.enums.ConflictMode`.
            Will broadcast.
        close_first (bool or array_like): Whether to close the position first before reversal.
            Will broadcast.

            Otherwise reverses the position with a single order and within the same tick.
            Takes only effect under `Direction.All`. Requires a second signal to enter
            the opposite position. This allows to define parameters such as `fixed_fees` for long
            and short positions separately.
        val_price (array_like of float): See `Portfolio.from_orders`.
        open (array_like of float): First asset price at each time step.
            Defaults to `np.nan`, which gets replaced by `close`. Will broadcast.

            Used solely for stop signals.
        high (array_like of float): Highest asset price at each time step.
            Defaults to `np.nan`, which gets replaced by the maximum out of `open` and `close`. Will broadcast.

            Used solely for stop signals.
        low (array_like of float): Lowest asset price at each time step.
            Defaults to `np.nan`, which gets replaced by the minimum out of `open` and `close`. Will broadcast.

            Used solely for stop signals.
        sl_stop (array_like of float): Stop loss.
            Will broadcast.

            A percentage below/above the acquisition price for long/short position.
            Note that 0.01 = 1%.
        sl_trail (array_like of bool): Whether `sl_stop` should be trailing.
            Will broadcast.
        tp_stop (array_like of float): Take profit.
            Will broadcast.

            A percentage above/below the acquisition price for long/short position.
            Note that 0.01 = 1%.
        stop_entry_price (StopEntryPrice or array_like): See `vectorbt.portfolio.enums.StopEntryPrice`.
            Will broadcast.

            If provided on per-element basis, gets applied upon entry.
        stop_exit_price (StopExitPrice or array_like): See `vectorbt.portfolio.enums.StopExitPrice`.
            Will broadcast.

            If provided on per-element basis, gets applied upon exit.
        stop_conflict_mode (StopConflictMode or array_like): See `vectorbt.portfolio.enums.StopConflictMode`.
            Will broadcast.

            If provided on per-element basis, gets applied upon exit.
        stop_exit_mode (StopExitMode or array_like): See `vectorbt.portfolio.enums.StopExitMode`.
            Will broadcast.

            If provided on per-element basis, gets applied upon exit.
        stop_update_mode (StopUpdateMode or array_like): See `vectorbt.portfolio.enums.StopUpdateMode`.
            Will broadcast.

            Only has effect is `accumulate` is True.

            If provided on per-element basis, gets applied upon repeated entry.
        adjust_sl_func_nb (callable): Function to adjust stop loss.
            Defaults to `vectorbt.portfolio.nb.no_adjust_sl_func_nb`.

            Called for each element before each row.

            Should accept index of the current row, index of the current column, the current position size,
            the latest asset price, initial index of the stop, initial price of the stop, initial value
            of the stop, initial trailing flag of the stop, and `*adjust_sl_args`.
            Should return a tuple of a new stop value and trailing flag.
        adjust_sl_args (tuple): Packed arguments passed to `adjust_sl_func_nb`.
            Defaults to `()`.
        adjust_tp_func_nb (callable): Function to adjust take profit.
            Defaults to `vectorbt.portfolio.nb.no_adjust_tp_func_nb`.

            Called for each element before each row.

            Should accept index of the current row, index of the current column, the current position size,
            the latest asset price, initial index of the stop, initial price of the stop, initial value
            of the stop, and `*adjust_tp_args`. Should return a new stop value.
        adjust_tp_args (tuple): Packed arguments passed to `adjust_tp_func_nb`.
            Defaults to `()`.
        use_stops (bool): Whether to use stops.
            Defaults to None, which becomes True if any of the stops are not NaN or
            any of the adjustment functions are custom.

            Disable this to make simulation a bit faster for simple use cases.
        init_cash (InitCashMode, float or array_like of float): See `Portfolio.from_orders`.
        cash_sharing (bool): See `Portfolio.from_orders`.
        call_seq (CallSeqType or array_like): See `Portfolio.from_orders`.
        ffill_val_price (bool): See `Portfolio.from_orders`.
        update_value (bool): See `Portfolio.from_orders`.
        max_orders (int): See `Portfolio.from_orders`.
        max_logs (int): See `Portfolio.from_orders`.
        seed (int): See `Portfolio.from_orders`.
        group_by (any): See `Portfolio.from_orders`.
        broadcast_kwargs (dict): See `Portfolio.from_orders`.
        wrapper_kwargs (dict): See `Portfolio.from_orders`.
        freq (any): See `Portfolio.from_orders`.
        **kwargs: Keyword arguments passed to the `__init__` method.

    All broadcastable arguments will broadcast using `vectorbt.base.reshape_fns.broadcast`
    but keep original shape to utilize flexible indexing and to save memory.

    For defaults, see `portfolio` in `vectorbt._settings.settings`.

    !!! hint
        If you generated signals using close price, don&#39;t forget to shift your signals by one tick
        forward, for example, with `signals.vbt.fshift(1)`. In general, make sure to use a price
        that comes after the signal.

    Also see notes and hints for `Portfolio.from_orders`.

    ## Example

    Entry opens long, exit closes long:

    ```python-repl
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])
    &gt;&gt;&gt; entries = pd.Series([True, True, True, False, False])
    &gt;&gt;&gt; exits = pd.Series([False, False, True, True, True])

    &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
    ...     close, entries, exits, size=1., direction=&#39;longonly&#39;)
    &gt;&gt;&gt; pf.asset_flow()
    0    1.0
    1    0.0
    2    0.0
    3   -1.0
    4    0.0
    dtype: float64
    ```

    Entry opens short, exit closes short:

    ```python-repl
    &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
    ...     close, entries, exits, size=1., direction=&#39;shortonly&#39;)
    &gt;&gt;&gt; pf.asset_flow()
    0   -1.0
    1    0.0
    2    0.0
    3    1.0
    4    0.0
    dtype: float64
    ```

    Reversal within one tick. Entry opens long and closes short, exit closes long and opens short:

    ```python-repl
    &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
    ...     close, entries, exits, size=1., direction=&#39;all&#39;)
    &gt;&gt;&gt; pf.asset_flow()
    0    1.0
    1    0.0
    2    0.0
    3   -2.0
    4    0.0
    dtype: float64
    ```

    Reversal within two ticks. First signal closes position, second signal opens the opposite one:

    ```python-repl
    &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
    ...     close, entries, exits, size=1., direction=&#39;all&#39;,
    ...     close_first=True)
    &gt;&gt;&gt; pf.asset_flow()
    0    1.0
    1    0.0
    2    0.0
    3   -1.0
    4   -1.0
    dtype: float64
    ```

    If entry and exit, chooses exit:

    ```python-repl
    &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
    ...     close, entries, exits, size=1., direction=&#39;all&#39;,
    ...     close_first=True, conflict_mode=&#39;exit&#39;)
    &gt;&gt;&gt; pf.asset_flow()
    0    1.0
    1    0.0
    2   -1.0
    3   -1.0
    4    0.0
    dtype: float64
    ```

    Entry means long order, exit means short order (acts similar to `from_orders`):

    ```python-repl
    &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
    ...     close, entries, exits, size=1., direction=&#39;all&#39;,
    ...     accumulate=True)
    &gt;&gt;&gt; pf.asset_flow()
    0    1.0
    1    1.0
    2    0.0
    3   -1.0
    4   -1.0
    dtype: float64
    ```

    Testing multiple parameters (via broadcasting):

    ```python-repl
    &gt;&gt;&gt; from vectorbt.portfolio.enums import Direction

    &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
    ...     close, entries, exits, direction=[list(Direction)],
    ...     broadcast_kwargs=dict(columns_from=Direction._fields))
    &gt;&gt;&gt; pf.asset_flow()
        Long  Short    All
    0  100.0 -100.0  100.0
    1    0.0    0.0    0.0
    2    0.0    0.0    0.0
    3 -100.0   50.0 -200.0
    4    0.0    0.0    0.0
    ```

    Specifying information in a more granular way thanks to broadcasting.
    Reverse the first long position by first closing it, and all other immediately:

    ```python-repl
    &gt;&gt;&gt; entries = pd.Series([True, False, False, True, False])
    &gt;&gt;&gt; exits = pd.Series([False, True, True, False, True])
    &gt;&gt;&gt; close_first = pd.Series([False, True, False, False, False])
    &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
    ...     close, entries, exits, size=1., direction=&#39;all&#39;,
    ...     close_first=close_first)
    &gt;&gt;&gt; pf.asset_flow()
    0    1.0
    1   -1.0
    2   -1.0
    3    2.0
    4   -2.0
    dtype: float64
    ```

    Set risk/reward ratio by passing trailing stop loss and take profit thresholds:

    ```python-repl
    &gt;&gt;&gt; close = pd.Series([10, 11, 12, 11, 10, 9])
    &gt;&gt;&gt; entries = pd.Series([True, False, False, False, False, False])
    &gt;&gt;&gt; exits = pd.Series([False, False, False, False, False, True])
    &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
    ...     close, entries, exits,
    ...     sl_stop=0.1, sl_trail=True, tp_stop=0.2)  # take profit hit
    &gt;&gt;&gt; pf.asset_flow()
    0    10.0
    1     0.0
    2   -10.0
    3     0.0
    4     0.0
    5     0.0
    dtype: float64

    &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
    ...     close, entries, exits,
    ...     sl_stop=0.1, sl_trail=True, tp_stop=0.3)  # stop loss hit
    &gt;&gt;&gt; pf.asset_flow()
    0    10.0
    1     0.0
    2     0.0
    3     0.0
    4   -10.0
    5     0.0
    dtype: float64

    &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
    ...     close, entries, exits,
    ...     sl_stop=np.inf, sl_trail=True, tp_stop=np.inf)  # nothing hit, exit as usual
    &gt;&gt;&gt; pf.asset_flow()
    0    10.0
    1     0.0
    2     0.0
    3     0.0
    4     0.0
    5   -10.0
    dtype: float64
    ```

    We can implement our own stop loss or take profit, or adjust the existing one at each time step.
    Let&#39;s implement [stepped stop-loss](https://www.freqtrade.io/en/stable/strategy-advanced/#stepped-stoploss):

    ```python-repl
    &gt;&gt;&gt; from numba import njit

    &gt;&gt;&gt; @njit
    ... def adjust_sl_func_nb(i, col, position, val_price, init_i, init_price, init_stop, init_trail):
    ...     current_profit = (val_price - init_price) / init_price
    ...     if current_profit &gt;= 0.40:
    ...         return 0.25, True
    ...     elif current_profit &gt;= 0.25:
    ...         return 0.15, True
    ...     elif current_profit &gt;= 0.20:
    ...         return 0.07, True
    ...     return init_stop, init_trail

    &gt;&gt;&gt; close = pd.Series([10, 11, 12, 11, 10])
    &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(
    ...     close, adjust_sl_func_nb=adjust_sl_func_nb)
    &gt;&gt;&gt; pf.asset_flow()
    0    10.0
    1     0.0
    2     0.0
    3   -10.0  # 7% from 12 hit
    4    11.0
    dtype: float64
    ```

    Combine multiple exit conditions. Exit early if the price hits some threshold before an actual exit:

    ```python-repl
    &gt;&gt;&gt; close = pd.Series([10, 11, 12, 13, 14, 15])
    &gt;&gt;&gt; entries = pd.Series([True, True, True, False, False, False])
    &gt;&gt;&gt; exits = pd.Series([False, False, False, True, True, True])

    &gt;&gt;&gt; # 1. Remove adjacent entries and exits
    &gt;&gt;&gt; # since stop condition refers only to the first signal
    &gt;&gt;&gt; entries, exits = entries.vbt.signals.clean(exits)
    &gt;&gt;&gt; entries
    0     True
    1    False
    2    False
    3    False
    4    False
    5    False
    dtype: bool
    &gt;&gt;&gt; exits
    0    False
    1    False
    2    False
    3     True
    4    False
    5    False
    dtype: bool

    &gt;&gt;&gt; # 2. Find stop exits
    &gt;&gt;&gt; stop_exits = entries.vbt.signals.generate_stop_exits(close, 0.1)
    &gt;&gt;&gt; stop_exits
    0    False
    1     True
    2    False
    3    False
    4    False
    5    False
    dtype: bool

    &gt;&gt;&gt; # 3. Combine exits
    &gt;&gt;&gt; exits = exits | stop_exits
    &gt;&gt;&gt; exits
    0    False
    1     True
    2    False
    3     True
    4    False
    5    False
    dtype: bool

    &gt;&gt;&gt; # 4. Pick the first exit after each entry
    &gt;&gt;&gt; exits = exits.vbt.signals.first(reset_by=entries, allow_gaps=True)
    &gt;&gt;&gt; exits
    0    False
    1     True
    2    False
    3    False
    4    False
    5    False
    dtype: bool

    &gt;&gt;&gt; # 5. Simulate portfolio
    &gt;&gt;&gt; pf = vbt.Portfolio.from_signals(close, entries, exits)
    &gt;&gt;&gt; pf.asset_flow()
    0    10.0
    1   -10.0
    2     0.0
    3     0.0
    4     0.0
    5     0.0
    dtype: float64
    ```

    !!! note
        By cleaning signals, we lose information. Moreover, this automatically assumes
        that each entry/signal signal succeeds (= order gets filled). Use this with caution,
        and consider rewriting your strategy with `Portfolio.from_order_func`, which is a
        preferred way of defining a complex logic in vectorbt.
    &#34;&#34;&#34;
    # Get defaults
    from vectorbt._settings import settings
    portfolio_cfg = settings[&#39;portfolio&#39;]

    if entries is None:
        entries = True
    if exits is None:
        exits = False
    if size is None:
        size = portfolio_cfg[&#39;size&#39;]
    if size_type is None:
        size_type = portfolio_cfg[&#39;signal_size_type&#39;]
    size_type = cast_enum_value(size_type, SizeType)
    if direction is None:
        direction = portfolio_cfg[&#39;signal_direction&#39;]
    direction = cast_enum_value(direction, Direction)
    if price is None:
        price = np.inf
    if fees is None:
        fees = portfolio_cfg[&#39;fees&#39;]
    if fixed_fees is None:
        fixed_fees = portfolio_cfg[&#39;fixed_fees&#39;]
    if slippage is None:
        slippage = portfolio_cfg[&#39;slippage&#39;]
    if min_size is None:
        min_size = portfolio_cfg[&#39;min_size&#39;]
    if max_size is None:
        max_size = portfolio_cfg[&#39;max_size&#39;]
    if reject_prob is None:
        reject_prob = portfolio_cfg[&#39;reject_prob&#39;]
    if lock_cash is None:
        lock_cash = portfolio_cfg[&#39;lock_cash&#39;]
    if allow_partial is None:
        allow_partial = portfolio_cfg[&#39;allow_partial&#39;]
    if raise_reject is None:
        raise_reject = portfolio_cfg[&#39;raise_reject&#39;]
    if log is None:
        log = portfolio_cfg[&#39;log&#39;]
    if accumulate is None:
        accumulate = portfolio_cfg[&#39;accumulate&#39;]
    if conflict_mode is None:
        conflict_mode = portfolio_cfg[&#39;conflict_mode&#39;]
    conflict_mode = cast_enum_value(conflict_mode, ConflictMode)
    if close_first is None:
        close_first = portfolio_cfg[&#39;close_first&#39;]
    if val_price is None:
        val_price = portfolio_cfg[&#39;val_price&#39;]
    if open is None:
        open = np.nan
    if high is None:
        high = np.nan
    if low is None:
        low = np.nan
    if sl_stop is None:
        sl_stop = portfolio_cfg[&#39;sl_stop&#39;]
    if sl_trail is None:
        sl_trail = portfolio_cfg[&#39;sl_trail&#39;]
    if tp_stop is None:
        tp_stop = portfolio_cfg[&#39;tp_stop&#39;]
    if stop_entry_price is None:
        stop_entry_price = portfolio_cfg[&#39;stop_entry_price&#39;]
    stop_entry_price = cast_enum_value(stop_entry_price, StopEntryPrice)
    if stop_exit_price is None:
        stop_exit_price = portfolio_cfg[&#39;stop_exit_price&#39;]
    stop_exit_price = cast_enum_value(stop_exit_price, StopExitPrice)
    if stop_conflict_mode is None:
        stop_conflict_mode = portfolio_cfg[&#39;stop_conflict_mode&#39;]
    stop_conflict_mode = cast_enum_value(stop_conflict_mode, ConflictMode)
    if stop_exit_mode is None:
        stop_exit_mode = portfolio_cfg[&#39;stop_exit_mode&#39;]
    stop_exit_mode = cast_enum_value(stop_exit_mode, StopExitMode)
    if stop_update_mode is None:
        stop_update_mode = portfolio_cfg[&#39;stop_update_mode&#39;]
    stop_update_mode = cast_enum_value(stop_update_mode, StopUpdateMode)
    if use_stops is None:
        use_stops = portfolio_cfg[&#39;use_stops&#39;]
    if use_stops is None:
        if isinstance(sl_stop, float) and \
                np.isnan(sl_stop) and \
                isinstance(tp_stop, float) and \
                np.isnan(tp_stop) and \
                adjust_sl_func_nb == nb.no_adjust_sl_func_nb and \
                adjust_tp_func_nb == nb.no_adjust_tp_func_nb:
            use_stops = False
        else:
            use_stops = True

    if init_cash is None:
        init_cash = portfolio_cfg[&#39;init_cash&#39;]
    init_cash = cast_enum_value(init_cash, InitCashMode)
    if isinstance(init_cash, int) and init_cash in InitCashMode:
        init_cash_mode = init_cash
        init_cash = np.inf
    else:
        init_cash_mode = None
    if cash_sharing is None:
        cash_sharing = portfolio_cfg[&#39;cash_sharing&#39;]
    if cash_sharing and group_by is None:
        group_by = True
    if call_seq is None:
        call_seq = portfolio_cfg[&#39;call_seq&#39;]
    call_seq = cast_enum_value(call_seq, CallSeqType)
    auto_call_seq = False
    if isinstance(call_seq, int):
        if call_seq == CallSeqType.Auto:
            call_seq = CallSeqType.Default
            auto_call_seq = True
    if ffill_val_price is None:
        ffill_val_price = portfolio_cfg[&#39;ffill_val_price&#39;]
    if update_value is None:
        update_value = portfolio_cfg[&#39;update_value&#39;]
    if seed is None:
        seed = portfolio_cfg[&#39;seed&#39;]
    if seed is not None:
        set_seed(seed)
    if freq is None:
        freq = portfolio_cfg[&#39;freq&#39;]
    if broadcast_kwargs is None:
        broadcast_kwargs = {}
    if wrapper_kwargs is None:
        wrapper_kwargs = {}
    if not wrapper_kwargs.get(&#39;group_select&#39;, True) and cash_sharing:
        raise ValueError(&#34;group_select cannot be disabled if cash_sharing=True&#34;)

    # Broadcast inputs
    # Only close is broadcast, others can remain unchanged thanks to flexible indexing
    broadcastable_args = (
        close,
        entries,
        exits,
        size,
        price,
        size_type,
        direction,
        fees,
        fixed_fees,
        slippage,
        min_size,
        max_size,
        reject_prob,
        lock_cash,
        allow_partial,
        raise_reject,
        log,
        accumulate,
        conflict_mode,
        close_first,
        val_price,
        open,
        high,
        low,
        sl_stop,
        sl_trail,
        tp_stop,
        stop_entry_price,
        stop_exit_price,
        stop_conflict_mode,
        stop_exit_mode,
        stop_update_mode
    )
    broadcast_kwargs = merge_dicts(dict(
        keep_raw=[False] + [True] * (len(broadcastable_args) - 1),
        require_kwargs=dict(requirements=&#39;W&#39;)
    ), broadcast_kwargs)
    broadcasted_args = broadcast(*broadcastable_args, **broadcast_kwargs)
    close = broadcasted_args[0]
    if not checks.is_pandas(close):
        close = pd.Series(close) if close.ndim == 1 else pd.DataFrame(close)
    target_shape_2d = (close.shape[0], close.shape[1] if close.ndim &gt; 1 else 1)
    wrapper = ArrayWrapper.from_obj(close, freq=freq, group_by=group_by, **wrapper_kwargs)
    cs_group_lens = wrapper.grouper.get_group_lens(group_by=None if cash_sharing else False)
    init_cash = np.require(np.broadcast_to(init_cash, (len(cs_group_lens),)), dtype=np.float_)
    group_lens = wrapper.grouper.get_group_lens(group_by=group_by)
    if checks.is_any_array(call_seq):
        call_seq = nb.require_call_seq(broadcast(call_seq, to_shape=target_shape_2d, to_pd=False))
    else:
        call_seq = nb.build_call_seq(target_shape_2d, group_lens, call_seq_type=call_seq)
    if max_orders is None:
        max_orders = target_shape_2d[0] * target_shape_2d[1]
    if max_logs is None:
        max_logs = target_shape_2d[0] * target_shape_2d[1]
    if not np.any(log):
        max_logs = 1

    # Perform calculation
    order_records, log_records = nb.simulate_from_signals_nb(
        target_shape_2d,
        to_2d(close, raw=True),
        cs_group_lens,  # group only if cash sharing is enabled to speed up
        init_cash,
        call_seq,
        *map(np.asarray, broadcasted_args[1:]),
        adjust_sl_func_nb,
        adjust_sl_args,
        adjust_tp_func_nb,
        adjust_tp_args,
        use_stops,
        auto_call_seq,
        ffill_val_price,
        update_value,
        max_orders,
        max_logs,
        close.ndim == 2
    )

    # Create an instance
    return cls(
        wrapper,
        close,
        order_records,
        log_records,
        init_cash if init_cash_mode is None else init_cash_mode,
        cash_sharing,
        call_seq,
        **kwargs
    )</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio.call_seq"><code class="name">var <span class="ident">call_seq</span></code></dt>
<dd>
<div class="desc"><p>Sequence of calls per row and group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def call_seq(self, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Sequence of calls per row and group.&#34;&#34;&#34;
    return self.wrapper.wrap(self._call_seq, group_by=False, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cash_sharing"><code class="name">var <span class="ident">cash_sharing</span></code></dt>
<dd>
<div class="desc"><p>Whether to share cash within the same group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cash_sharing(self) -&gt; bool:
    &#34;&#34;&#34;Whether to share cash within the same group.&#34;&#34;&#34;
    return self._cash_sharing</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.close"><code class="name">var <span class="ident">close</span></code></dt>
<dd>
<div class="desc"><p>Price per unit series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def close(self) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Price per unit series.&#34;&#34;&#34;
    return self._close</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.common_settings"><code class="name">var <span class="ident">common_settings</span></code></dt>
<dd>
<div class="desc"><p>Return dictionary of most commonly used settings.</p>
<ul>
<li>freq: Index frequency in case it cannot be parsed from <code>close</code>.</li>
<li>year_freq: Year frequency for annualization purposes.</li>
<li>incl_unrealized: Whether to include open trades/positions in statistics.</li>
<li>use_asset_returns: Whether to use <code><a title="vectorbt.portfolio.base.Portfolio.asset_returns" href="#vectorbt.portfolio.base.Portfolio.asset_returns">Portfolio.asset_returns()</a></code> when resolving <code>returns</code> argument.</li>
<li>use_positions: Whether to use <code><a title="vectorbt.portfolio.base.Portfolio.positions" href="#vectorbt.portfolio.base.Portfolio.positions">Portfolio.positions</a></code> when resolving <code>trades</code> argument.</li>
<li>
<p>use_caching: Whether to use built-in caching for resolved arguments.</p>
<p>Works even if global caching is disabled.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def common_settings(self) -&gt; tp.Kwargs:
    &#34;&#34;&#34;Return dictionary of most commonly used settings.

    * freq: Index frequency in case it cannot be parsed from `close`.
    * year_freq: Year frequency for annualization purposes.
    * incl_unrealized: Whether to include open trades/positions in statistics.
    * use_asset_returns: Whether to use `Portfolio.asset_returns` when resolving `returns` argument.
    * use_positions: Whether to use `Portfolio.positions` when resolving `trades` argument.
    * use_caching: Whether to use built-in caching for resolved arguments.

        Works even if global caching is disabled.&#34;&#34;&#34;
    from vectorbt._settings import settings
    portfolio_stats_cfg = settings[&#39;portfolio&#39;][&#39;stats&#39;]
    returns_stats_cfg = settings[&#39;returns&#39;]

    return dict(
        freq=self.wrapper.freq,
        year_freq=returns_stats_cfg[&#39;year_freq&#39;],
        incl_unrealized=portfolio_stats_cfg[&#39;incl_unrealized&#39;],
        use_asset_returns=portfolio_stats_cfg[&#39;use_asset_returns&#39;],
        use_positions=portfolio_stats_cfg[&#39;use_positions&#39;],
        use_caching=portfolio_stats_cfg[&#39;use_caching&#39;]
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.drawdowns"><code class="name">var <span class="ident">drawdowns</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.portfolio.base.Portfolio.get_drawdowns" href="#vectorbt.portfolio.base.Portfolio.get_drawdowns">Portfolio.get_drawdowns()</a></code> with default arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.fillna_close"><code class="name">var <span class="ident">fillna_close</span></code></dt>
<dd>
<div class="desc"><p>Whether to forward-backward fill NaN values in <code><a title="vectorbt.portfolio.base.Portfolio.close" href="#vectorbt.portfolio.base.Portfolio.close">Portfolio.close</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fillna_close(self) -&gt; bool:
    &#34;&#34;&#34;Whether to forward-backward fill NaN values in `Portfolio.close`.&#34;&#34;&#34;
    return self._fillna_close</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.init_cash"><code class="name">var <span class="ident">init_cash</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.portfolio.base.Portfolio.get_init_cash" href="#vectorbt.portfolio.base.Portfolio.get_init_cash">Portfolio.get_init_cash()</a></code> with default arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.log_records"><code class="name">var <span class="ident">log_records</span></code></dt>
<dd>
<div class="desc"><p>A structured NumPy array of log records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def log_records(self) -&gt; tp.RecordArray:
    &#34;&#34;&#34;A structured NumPy array of log records.&#34;&#34;&#34;
    return self._log_records</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.logs"><code class="name">var <span class="ident">logs</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.portfolio.base.Portfolio.get_logs" href="#vectorbt.portfolio.base.Portfolio.get_logs">Portfolio.get_logs()</a></code> with default arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.order_records"><code class="name">var <span class="ident">order_records</span></code></dt>
<dd>
<div class="desc"><p>A structured NumPy array of order records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def order_records(self) -&gt; tp.RecordArray:
    &#34;&#34;&#34;A structured NumPy array of order records.&#34;&#34;&#34;
    return self._order_records</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.orders"><code class="name">var <span class="ident">orders</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.portfolio.base.Portfolio.get_orders" href="#vectorbt.portfolio.base.Portfolio.get_orders">Portfolio.get_orders()</a></code> with default arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.positions"><code class="name">var <span class="ident">positions</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.portfolio.base.Portfolio.get_positions" href="#vectorbt.portfolio.base.Portfolio.get_positions">Portfolio.get_positions()</a></code> with default arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.trades"><code class="name">var <span class="ident">trades</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.portfolio.base.Portfolio.get_trades" href="#vectorbt.portfolio.base.Portfolio.get_trades">Portfolio.get_trades()</a></code> with default arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.portfolio.base.Portfolio.alpha"><code class="name flex">
<span>def <span class="ident">alpha</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.alpha" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.alpha">ReturnsAccessor.alpha()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.annual_returns"><code class="name flex">
<span>def <span class="ident">annual_returns</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.annual" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.annual">ReturnsAccessor.annual()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.annualized_return"><code class="name flex">
<span>def <span class="ident">annualized_return</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.annualized" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.annualized">ReturnsAccessor.annualized()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.annualized_volatility"><code class="name flex">
<span>def <span class="ident">annualized_volatility</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.annualized_volatility" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.annualized_volatility">ReturnsAccessor.annualized_volatility()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.asset_flow"><code class="name flex">
<span>def <span class="ident">asset_flow</span></span>(<span>self, direction='all', wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get asset flow series per column.</p>
<p>Returns the total transacted amount of assets at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def asset_flow(self, direction: str = &#39;all&#39;, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get asset flow series per column.

    Returns the total transacted amount of assets at each time step.&#34;&#34;&#34;
    direction = cast_enum_value(direction, Direction)
    asset_flow = nb.asset_flow_nb(
        self.wrapper.shape_2d,
        self.orders.values,
        self.orders.col_mapper.col_map,
        direction
    )
    return self.wrapper.wrap(asset_flow, group_by=False, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.asset_returns"><code class="name flex">
<span>def <span class="ident">asset_returns</span></span>(<span>self, group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get asset return series per column/group.</p>
<p>This type of returns is based solely on cash flows and asset value rather than portfolio
value. It ignores passive cash and thus it will return the same numbers irrespective of the amount of
cash currently available, even <code>np.inf</code>. The scale of returns is comparable to that of going
all in and keeping available cash at zero.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def asset_returns(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get asset return series per column/group.

    This type of returns is based solely on cash flows and asset value rather than portfolio
    value. It ignores passive cash and thus it will return the same numbers irrespective of the amount of
    cash currently available, even `np.inf`. The scale of returns is comparable to that of going
    all in and keeping available cash at zero.&#34;&#34;&#34;
    cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
    asset_value = to_2d(self.asset_value(group_by=group_by), raw=True)
    asset_returns = nb.asset_returns_nb(cash_flow, asset_value)
    return self.wrapper.wrap(asset_returns, group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.asset_value"><code class="name flex">
<span>def <span class="ident">asset_value</span></span>(<span>self, direction='all', group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get asset value series per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def asset_value(self, direction: str = &#39;all&#39;, group_by: tp.GroupByLike = None,
                wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get asset value series per column/group.&#34;&#34;&#34;
    direction = cast_enum_value(direction, Direction)
    if self.fillna_close:
        close = to_2d(self.get_filled_close(), raw=True).copy()
    else:
        close = to_2d(self.close, raw=True).copy()
    assets = to_2d(self.assets(direction=direction), raw=True)
    close[assets == 0] = 0.  # for price being NaN
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        asset_value = to_2d(self.asset_value(direction=direction, group_by=False), raw=True)
        group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
        asset_value = nb.asset_value_grouped_nb(asset_value, group_lens)
    else:
        asset_value = nb.asset_value_nb(close, assets)
    return self.wrapper.wrap(asset_value, group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.assets"><code class="name flex">
<span>def <span class="ident">assets</span></span>(<span>self, direction='all', wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get asset series per column.</p>
<p>Returns the current position at each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def assets(self, direction: str = &#39;all&#39;, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get asset series per column.

    Returns the current position at each time step.&#34;&#34;&#34;
    direction = cast_enum_value(direction, Direction)
    asset_flow = to_2d(self.asset_flow(direction=&#39;all&#39;), raw=True)
    assets = nb.assets_nb(asset_flow)
    if direction == Direction.LongOnly:
        assets = np.where(assets &gt; 0, assets, 0.)
    if direction == Direction.ShortOnly:
        assets = np.where(assets &lt; 0, -assets, 0.)
    return self.wrapper.wrap(assets, group_by=False, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.benchmark_rets"><code class="name flex">
<span>def <span class="ident">benchmark_rets</span></span>(<span>self, group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get return series per column/group based on market (benchmark) value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def market_returns(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get return series per column/group based on market (benchmark) value.&#34;&#34;&#34;
    market_value = to_2d(self.market_value(group_by=group_by), raw=True)
    init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
    market_returns = nb.returns_nb(market_value, init_cash)
    return self.wrapper.wrap(market_returns, group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.beta"><code class="name flex">
<span>def <span class="ident">beta</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.beta" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.beta">ReturnsAccessor.beta()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.calmar_ratio"><code class="name flex">
<span>def <span class="ident">calmar_ratio</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.calmar_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.calmar_ratio">ReturnsAccessor.calmar_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.capture"><code class="name flex">
<span>def <span class="ident">capture</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.capture" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.capture">ReturnsAccessor.capture()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cash"><code class="name flex">
<span>def <span class="ident">cash</span></span>(<span>self, group_by=None, in_sim_order=False, free=False, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get cash balance series per column/group.</p>
<p>See the explanation on <code>in_sim_order</code> in <code><a title="vectorbt.portfolio.base.Portfolio.value" href="#vectorbt.portfolio.base.Portfolio.value">Portfolio.value()</a></code>.
For <code>free</code>, see <code><a title="vectorbt.portfolio.base.Portfolio.cash_flow" href="#vectorbt.portfolio.base.Portfolio.cash_flow">Portfolio.cash_flow()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def cash(self, group_by: tp.GroupByLike = None, in_sim_order: bool = False, free: bool = False,
         wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get cash balance series per column/group.

    See the explanation on `in_sim_order` in `Portfolio.value`.
    For `free`, see `Portfolio.cash_flow`.&#34;&#34;&#34;
    if in_sim_order and not self.cash_sharing:
        raise ValueError(&#34;Cash sharing must be enabled for in_sim_order=True&#34;)

    cash_flow = to_2d(self.cash_flow(group_by=group_by, free=free), raw=True)
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        cash = nb.cash_grouped_nb(
            self.wrapper.shape_2d,
            cash_flow,
            group_lens,
            init_cash
        )
    else:
        if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
            group_lens = self.wrapper.grouper.get_group_lens()
            init_cash = to_1d(self.init_cash, raw=True)
            call_seq = to_2d(self.call_seq, raw=True)
            cash = nb.cash_in_sim_order_nb(cash_flow, group_lens, init_cash, call_seq)
        else:
            init_cash = to_1d(self.get_init_cash(group_by=False), raw=True)
            cash = nb.cash_nb(cash_flow, init_cash)
    return self.wrapper.wrap(cash, group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cash_flow"><code class="name flex">
<span>def <span class="ident">cash_flow</span></span>(<span>self, group_by=None, free=False, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get cash flow series per column/group.</p>
<p>Use <code>free</code> to return the flow of the free cash, which never goes above the initial level,
because an operation always costs money.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def cash_flow(self, group_by: tp.GroupByLike = None, free: bool = False,
              wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get cash flow series per column/group.

    Use `free` to return the flow of the free cash, which never goes above the initial level,
    because an operation always costs money.&#34;&#34;&#34;
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        cash_flow = to_2d(self.cash_flow(group_by=False, free=free), raw=True)
        group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
        cash_flow = nb.cash_flow_grouped_nb(cash_flow, group_lens)
    else:
        cash_flow = nb.cash_flow_nb(
            self.wrapper.shape_2d,
            self.orders.values,
            self.orders.col_mapper.col_map,
            free
        )
    return self.wrapper.wrap(cash_flow, group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cond_value_at_risk"><code class="name flex">
<span>def <span class="ident">cond_value_at_risk</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.cond_value_at_risk" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.cond_value_at_risk">ReturnsAccessor.cond_value_at_risk()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.cumulative_returns"><code class="name flex">
<span>def <span class="ident">cumulative_returns</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.cumulative" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.cumulative">ReturnsAccessor.cumulative()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.daily_returns"><code class="name flex">
<span>def <span class="ident">daily_returns</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.daily" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.daily">ReturnsAccessor.daily()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.deflated_sharpe_ratio"><code class="name flex">
<span>def <span class="ident">deflated_sharpe_ratio</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.deflated_sharpe_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.deflated_sharpe_ratio">ReturnsAccessor.deflated_sharpe_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.down_capture"><code class="name flex">
<span>def <span class="ident">down_capture</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.down_capture" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.down_capture">ReturnsAccessor.down_capture()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.downside_risk"><code class="name flex">
<span>def <span class="ident">downside_risk</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.downside_risk" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.downside_risk">ReturnsAccessor.downside_risk()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.drawdown"><code class="name flex">
<span>def <span class="ident">drawdown</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.drawdown" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.drawdown">ReturnsAccessor.drawdown()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.final_value"><code class="name flex">
<span>def <span class="ident">final_value</span></span>(<span>self, group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get total profit per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def final_value(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
    init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
    total_profit = to_1d(self.total_profit(group_by=group_by), raw=True)
    final_value = nb.final_value_nb(total_profit, init_cash)
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;final_value&#39;), wrap_kwargs)
    return self.wrapper.wrap_reduced(final_value, group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.get_drawdowns"><code class="name flex">
<span>def <span class="ident">get_drawdowns</span></span>(<span>self, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get drawdown records from <code><a title="vectorbt.portfolio.base.Portfolio.value" href="#vectorbt.portfolio.base.Portfolio.value">Portfolio.value()</a></code>.</p>
<p>See <code><a title="vectorbt.generic.drawdowns.Drawdowns" href="../generic/drawdowns.html#vectorbt.generic.drawdowns.Drawdowns">Drawdowns</a></code>.</p>
<p><code>**kwargs</code> are passed to <code><a title="vectorbt.portfolio.base.Portfolio.value" href="#vectorbt.portfolio.base.Portfolio.value">Portfolio.value()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def get_drawdowns(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; Drawdowns:
    &#34;&#34;&#34;Get drawdown records from `Portfolio.value`.

    See `vectorbt.generic.drawdowns.Drawdowns`.

    `**kwargs` are passed to `Portfolio.value`.&#34;&#34;&#34;
    return Drawdowns.from_ts(self.value(group_by=group_by, **kwargs), freq=self.wrapper.freq)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.get_filled_close"><code class="name flex">
<span>def <span class="ident">get_filled_close</span></span>(<span>self, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Forward-backward-fill NaN values in <code><a title="vectorbt.portfolio.base.Portfolio.close" href="#vectorbt.portfolio.base.Portfolio.close">Portfolio.close</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def get_filled_close(self, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Forward-backward-fill NaN values in `Portfolio.close`&#34;&#34;&#34;
    close = to_2d(self.close.ffill().bfill(), raw=True)
    return self.wrapper.wrap(close, group_by=False, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.get_init_cash"><code class="name flex">
<span>def <span class="ident">get_init_cash</span></span>(<span>self, group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initial amount of cash per column/group with default arguments.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the initial cash balance was found automatically and no own cash is used throughout
the simulation (for example, when shorting), it will be set to 1 instead of 0 to enable
smooth calculation of returns.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def get_init_cash(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;Initial amount of cash per column/group with default arguments.

    !!! note
        If the initial cash balance was found automatically and no own cash is used throughout
        the simulation (for example, when shorting), it will be set to 1 instead of 0 to enable
        smooth calculation of returns.&#34;&#34;&#34;
    if isinstance(self._init_cash, int):
        cash_flow = to_2d(self.cash_flow(group_by=group_by), raw=True)
        cash_min = np.min(np.cumsum(cash_flow, axis=0), axis=0)
        init_cash = np.where(cash_min &lt; 0, np.abs(cash_min), 1.)
        if self._init_cash == InitCashMode.AutoAlign:
            init_cash = np.full(init_cash.shape, np.max(init_cash))
    else:
        init_cash = to_1d(self._init_cash, raw=True)
        if self.wrapper.grouper.is_grouped(group_by=group_by):
            group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
            init_cash = nb.init_cash_grouped_nb(init_cash, group_lens, self.cash_sharing)
        else:
            group_lens = self.wrapper.grouper.get_group_lens()
            init_cash = nb.init_cash_nb(init_cash, group_lens, self.cash_sharing)
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;init_cash&#39;), wrap_kwargs)
    return self.wrapper.wrap_reduced(init_cash, group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.get_logs"><code class="name flex">
<span>def <span class="ident">get_logs</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get log records.</p>
<p>See <code><a title="vectorbt.portfolio.logs.Logs" href="logs.html#vectorbt.portfolio.logs.Logs">Logs</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def get_logs(self, group_by: tp.GroupByLike = None) -&gt; Logs:
    &#34;&#34;&#34;Get log records.

    See `vectorbt.portfolio.logs.Logs`.&#34;&#34;&#34;
    return self.logs.regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.get_orders"><code class="name flex">
<span>def <span class="ident">get_orders</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get order records.</p>
<p>See <code><a title="vectorbt.portfolio.orders.Orders" href="orders.html#vectorbt.portfolio.orders.Orders">Orders</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def get_orders(self, group_by: tp.GroupByLike = None) -&gt; Orders:
    &#34;&#34;&#34;Get order records.

    See `vectorbt.portfolio.orders.Orders`.&#34;&#34;&#34;
    return self.orders.regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.get_positions"><code class="name flex">
<span>def <span class="ident">get_positions</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get position records.</p>
<p>See <code><a title="vectorbt.portfolio.trades.Positions" href="trades.html#vectorbt.portfolio.trades.Positions">Positions</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def get_positions(self, group_by: tp.GroupByLike = None) -&gt; Positions:
    &#34;&#34;&#34;Get position records.

    See `vectorbt.portfolio.trades.Positions`.&#34;&#34;&#34;
    return self.positions.regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.get_trades"><code class="name flex">
<span>def <span class="ident">get_trades</span></span>(<span>self, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get trade records.</p>
<p>See <code><a title="vectorbt.portfolio.trades.Trades" href="trades.html#vectorbt.portfolio.trades.Trades">Trades</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def get_trades(self, group_by: tp.GroupByLike = None) -&gt; Trades:
    &#34;&#34;&#34;Get trade records.

    See `vectorbt.portfolio.trades.Trades`.&#34;&#34;&#34;
    return self.trades.regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.gross_exposure"><code class="name flex">
<span>def <span class="ident">gross_exposure</span></span>(<span>self, direction='all', group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get gross exposure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def gross_exposure(self, direction: str = &#39;all&#39;, group_by: tp.GroupByLike = None,
                   wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get gross exposure.&#34;&#34;&#34;
    asset_value = to_2d(self.asset_value(group_by=group_by, direction=direction), raw=True)
    cash = to_2d(self.cash(group_by=group_by, free=True), raw=True)
    gross_exposure = nb.gross_exposure_nb(asset_value, cash)
    return self.wrapper.wrap(gross_exposure, group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.indexing_func"><code class="name flex">
<span>def <span class="ident">indexing_func</span></span>(<span>self, pd_indexing_func, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform indexing on <code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indexing_func(self: PortfolioT, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; PortfolioT:
    &#34;&#34;&#34;Perform indexing on `Portfolio`.&#34;&#34;&#34;
    new_wrapper, _, group_idxs, col_idxs = \
        self.wrapper.indexing_func_meta(pd_indexing_func, column_only_select=True, **kwargs)
    new_close = new_wrapper.wrap(to_2d(self.close, raw=True)[:, col_idxs], group_by=False)
    new_order_records = self.orders.get_by_col_idxs(col_idxs)
    new_log_records = self.logs.get_by_col_idxs(col_idxs)
    if isinstance(self._init_cash, int):
        new_init_cash = self._init_cash
    else:
        new_init_cash = to_1d(self._init_cash, raw=True)[group_idxs if self.cash_sharing else col_idxs]
    new_call_seq = self.call_seq.values[:, col_idxs]

    return self.copy(
        wrapper=new_wrapper,
        close=new_close,
        order_records=new_order_records,
        log_records=new_log_records,
        init_cash=new_init_cash,
        call_seq=new_call_seq
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.information_ratio"><code class="name flex">
<span>def <span class="ident">information_ratio</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.information_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.information_ratio">ReturnsAccessor.information_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.market_returns"><code class="name flex">
<span>def <span class="ident">market_returns</span></span>(<span>self, group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get return series per column/group based on market (benchmark) value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def market_returns(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get return series per column/group based on market (benchmark) value.&#34;&#34;&#34;
    market_value = to_2d(self.market_value(group_by=group_by), raw=True)
    init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
    market_returns = nb.returns_nb(market_value, init_cash)
    return self.wrapper.wrap(market_returns, group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.market_value"><code class="name flex">
<span>def <span class="ident">market_value</span></span>(<span>self, group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get market (benchmark) value series per column/group.</p>
<p>If grouped, evenly distributes the initial cash among assets in the group.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Does not take into account fees and slippage. For this, create a separate portfolio.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def market_value(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get market (benchmark) value series per column/group.

    If grouped, evenly distributes the initial cash among assets in the group.

    !!! note
        Does not take into account fees and slippage. For this, create a separate portfolio.&#34;&#34;&#34;
    if self.fillna_close:
        close = to_2d(self.get_filled_close(), raw=True)
    else:
        close = to_2d(self.close, raw=True)
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
        init_cash_grouped = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        market_value = nb.market_value_grouped_nb(close, group_lens, init_cash_grouped)
    else:
        init_cash = to_1d(self.get_init_cash(group_by=False), raw=True)
        market_value = nb.market_value_nb(close, init_cash)
    return self.wrapper.wrap(market_value, group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.max_drawdown"><code class="name flex">
<span>def <span class="ident">max_drawdown</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.max_drawdown" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.max_drawdown">ReturnsAccessor.max_drawdown()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.net_exposure"><code class="name flex">
<span>def <span class="ident">net_exposure</span></span>(<span>self, group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get net exposure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def net_exposure(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get net exposure.&#34;&#34;&#34;
    long_exposure = to_2d(self.gross_exposure(direction=&#39;longonly&#39;, group_by=group_by), raw=True)
    short_exposure = to_2d(self.gross_exposure(direction=&#39;shortonly&#39;, group_by=group_by), raw=True)
    net_exposure = long_exposure - short_exposure
    return self.wrapper.wrap(net_exposure, group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.omega_ratio"><code class="name flex">
<span>def <span class="ident">omega_ratio</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.omega_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.omega_ratio">ReturnsAccessor.omega_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, subplots=None, column=None, group_by=None, show_titles=None, hide_id_labels=None, group_id_labels=None, make_subplots_kwargs=None, hline_shape_kwargs=None, silence_warnings=None, template_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot various parts of this portfolio.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>subplots</code></strong> :&ensp;<code>str, tuple, iterable,</code> or <code>dict</code></dt>
<dd>
<p>List of subplots to plot.</p>
<p>Each element can be either:</p>
<ul>
<li>a subplot name (see keys in <code><a title="vectorbt.portfolio.base.Portfolio.subplots" href="#vectorbt.portfolio.base.Portfolio.subplots">Portfolio.subplots</a></code>)</li>
<li>a tuple of a subplot name and a settings dict as in <code><a title="vectorbt.portfolio.base.Portfolio.subplots" href="#vectorbt.portfolio.base.Portfolio.subplots">Portfolio.subplots</a></code>.</li>
</ul>
<p>Each settings dict can contain the following keys:</p>
<ul>
<li><code>title</code>: title of the subplot. Defaults to None.</li>
<li><code>yaxis_title</code>: title of the y-axis. Defaults to <code>title</code>.</li>
<li><code>xaxis_title</code>: title of the x-axis. Defaults to 'Date'.</li>
<li><code>allow_grouped</code>: whether this subplot supports grouped data. Defaults to True.
Must be known beforehand and cannot be provided as a template.</li>
<li><code>plot_func</code>: plotting function for custom subplots. If the function can be accessed
by traversing attributes of this portfolio, you can pass the path to this function
as a string (see <code><a title="vectorbt.utils.attr.deep_getattr" href="../utils/attr.html#vectorbt.utils.attr.deep_getattr">deep_getattr()</a></code> for the path format).</li>
<li><code>pass_{arg}</code>: whether to pass a reserved argument (see below). Defaults to True if
this argument was found in the function's signature. Set to False to not pass.</li>
<li><code>template_mapping</code>: mapping to replace templates in subplot settings and keyword arguments.
Used across all settings.</li>
<li>Any other keyword argument overrides reserved arguments or is passed directly to <code>plot_func</code>.</li>
</ul>
<p>A plotting function may accept any keyword argument, but it should accept the current figure via
a <code>fig</code> keyword argument. It may also "request" any of the following reserved arguments by
accepting them or if <code>pass_{arg}</code> was found in the settings dict:</p>
<ul>
<li><code>portfolio</code>: original portfolio (ungrouped and with no column selected)</li>
<li><code>column</code></li>
<li><code>group_by</code></li>
<li><code>subplot_name</code></li>
<li><code>trace_names</code>: list with the subplot name</li>
<li><code>add_trace_kwargs</code></li>
<li><code>xref</code></li>
<li><code>yref</code></li>
<li><code>xaxis</code></li>
<li><code>yaxis</code></li>
<li><code>x_domain</code></li>
<li><code>y_domain</code></li>
<li><code>hline_shape_kwargs</code></li>
</ul>
<p>Pass <code>subplots='all'</code> to plot all supported subplots.</p>
</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Name of the column/group to plot.</p>
<p>Won't have effect on this portfolio, but passed down to each plotting function.</p>
</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>
<p>Group or ungroup columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</p>
<p>Won't have effect on this portfolio, but passed down to each plotting function.</p>
</dd>
<dt><strong><code>show_titles</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the title of each subplot.</dd>
<dt><strong><code>hide_id_labels</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to hide identical legend labels.</p>
<p>Two labels are identical if their name, marker style and line style match.</p>
</dd>
<dt><strong><code>group_id_labels</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to group identical legend labels.</dd>
<dt><strong><code>make_subplots_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.subplots.make_subplots</code>.</dd>
<dt><strong><code>hline_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline.</dd>
<dt><strong><code>silence_warnings</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to silence all warnings.</dd>
<dt><strong><code>template_mapping</code></strong> :&ensp;<code>mapping</code></dt>
<dd>
<p>Global mapping to replace templates.</p>
<p>Applied on both subplot settings and <code>kwargs</code>.</p>
</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>
<p>Additional keyword arguments.</p>
<p>Can contain keyword arguments for each subplot, specified as <code>{subplot_name}_kwargs</code>.
Other keyword arguments are used to update the layout of the figure.</p>
</dd>
</dl>
<p>For template logic, see <code><a title="vectorbt.utils.template" href="../utils/template.html">vectorbt.utils.template</a></code>.</p>
<p>For defaults, see <code>portfolio.plot</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>This method is very similar to <code><a title="vectorbt.portfolio.base.Portfolio.stats" href="#vectorbt.portfolio.base.Portfolio.stats">Portfolio.stats()</a></code>.</p>
</div>
<h2 id="example">Example</h2>
<p>Plot portfolio of a random strategy:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; close = vbt.YFData.download(
...     &quot;BTC-USD&quot;,
...     start='2020-01-01 UTC',
...     end='2020-09-01 UTC'
... ).get('Close')

&gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(close, n=10, seed=42)
&gt;&gt;&gt; pf.plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/portfolio_plot.svg"></p>
<p>You can choose any of the subplots in <code><a title="vectorbt.portfolio.base.Portfolio.subplots" href="#vectorbt.portfolio.base.Portfolio.subplots">Portfolio.subplots</a></code>, in any order, and
control their appearance using keyword arguments:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from vectorbt.utils.colors import adjust_opacity

&gt;&gt;&gt; pf.plot(
...     subplots=['drawdowns', 'underwater'],
...     drawdowns_kwargs=dict(top_n=3),
...     underwater_kwargs=dict(
...         trace_kwargs=dict(
...             line=dict(color='#FF6F00'),
...             fillcolor=adjust_opacity('#FF6F00', 0.3)
...         )
...     )
... )
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/portfolio_plot_drawdowns.svg"></p>
<p>To create a new subplot, a preferred way is to pass a plotting function:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def plot_order_size(size, add_trace_kwargs=None, fig=None):
...     size.rename('Order Size').vbt.barplot(
...         add_trace_kwargs=add_trace_kwargs, fig=fig)

&gt;&gt;&gt; order_size = pf.orders.size.to_pd(default_val=0.)
&gt;&gt;&gt; pf.plot(subplots=[
...     'orders',
...     ('order_size', dict(
...         title='Order Size',
...         yaxis_title='Order size',
...         allow_grouped=False,
...         plot_func=plot_order_size
...     ))
... ], order_size_kwargs=dict(size=order_size))
</code></pre>
<p>Alternatively, you can create a placeholder and overwrite it manually later:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fig = pf.plot(subplots=[
...     'orders',
...     ('order_size', dict(
...         title='Order Size',
...         yaxis_title='Order size',
...         allow_grouped=False
...     ))  # placeholder
... ])
&gt;&gt;&gt; order_size.rename('Order Size').vbt.barplot(
...     add_trace_kwargs=dict(row=2, col=1), fig=fig)
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/portfolio_plot_custom.svg"></p>
<p>If a plotting function can in any way be accessed from the current portfolio, you can pass
the path to this function (see <code><a title="vectorbt.utils.attr.deep_getattr" href="../utils/attr.html#vectorbt.utils.attr.deep_getattr">deep_getattr()</a></code> for the path format).
You can additionally use templates to make some parameters to depend upon passed keyword arguments:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; subplots = [
...     ('cumulative_returns', dict(
...         title='Cumulative Returns',
...         yaxis_title='Cumulative returns',
...         plot_func='returns.vbt.returns.cumulative.vbt.plot',
...         pass_add_trace_kwargs=True  # hidden behind **kwargs in vbt.plot
...     )),
...     ('rolling_drawdown', dict(
...         title='Rolling Drawdown',
...         yaxis_title='Rolling drawdown',
...         plot_func=[
...             'returns.vbt.returns',  # returns accessor
...             (
...                 'rolling_max_drawdown',  # function name
...                 (vbt.Rep('window'),)),  # positional arguments
...             'vbt.plot'  # plotting function
...         ],
...         pass_add_trace_kwargs=True,
...         trace_names=[vbt.Sub('rolling_drawdown(${window})')],  # add window to the trace name
...     ))
... ]
&gt;&gt;&gt; pf.plot(subplots, rolling_drawdown_kwargs=dict(template_mapping=dict(window=10)))
</code></pre>
<p>You can also replace templates across all subplots by using the global template mapping:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf.plot(subplots, template_mapping=dict(window=10))
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/portfolio_plot_path.svg"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         subplots: tp.Optional[tp.MaybeIterable[tp.Union[str, tp.Tuple[str, tp.Kwargs]]]] = None,
         column: tp.Optional[tp.Label] = None,
         group_by: tp.GroupByLike = None,
         show_titles: bool = None,
         hide_id_labels: bool = None,
         group_id_labels: bool = None,
         make_subplots_kwargs: tp.KwargsLike = None,
         hline_shape_kwargs: tp.KwargsLike = None,
         silence_warnings: bool = None,
         template_mapping: tp.Optional[tp.Mapping] = None,
         **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    &#34;&#34;&#34;Plot various parts of this portfolio.

    Args:
        subplots (str, tuple, iterable, or dict): List of subplots to plot.

            Each element can be either:

            * a subplot name (see keys in `Portfolio.subplots`)
            * a tuple of a subplot name and a settings dict as in `Portfolio.subplots`.

            Each settings dict can contain the following keys:

            * `title`: title of the subplot. Defaults to None.
            * `yaxis_title`: title of the y-axis. Defaults to `title`.
            * `xaxis_title`: title of the x-axis. Defaults to &#39;Date&#39;.
            * `allow_grouped`: whether this subplot supports grouped data. Defaults to True.
                Must be known beforehand and cannot be provided as a template.
            * `plot_func`: plotting function for custom subplots. If the function can be accessed
                by traversing attributes of this portfolio, you can pass the path to this function
                as a string (see `vectorbt.utils.attr.deep_getattr` for the path format).
            * `pass_{arg}`: whether to pass a reserved argument (see below). Defaults to True if
                this argument was found in the function&#39;s signature. Set to False to not pass.
            * `template_mapping`: mapping to replace templates in subplot settings and keyword arguments.
                Used across all settings.
            * Any other keyword argument overrides reserved arguments or is passed directly to `plot_func`.

            A plotting function may accept any keyword argument, but it should accept the current figure via
            a `fig` keyword argument. It may also &#34;request&#34; any of the following reserved arguments by
            accepting them or if `pass_{arg}` was found in the settings dict:

            * `portfolio`: original portfolio (ungrouped and with no column selected)
            * `column`
            * `group_by`
            * `subplot_name`
            * `trace_names`: list with the subplot name
            * `add_trace_kwargs`
            * `xref`
            * `yref`
            * `xaxis`
            * `yaxis`
            * `x_domain`
            * `y_domain`
            * `hline_shape_kwargs`

            Pass `subplots=&#39;all&#39;` to plot all supported subplots.
        column (str): Name of the column/group to plot.

            Won&#39;t have effect on this portfolio, but passed down to each plotting function.
        group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.

            Won&#39;t have effect on this portfolio, but passed down to each plotting function.
        show_titles (bool): Whether to show the title of each subplot.
        hide_id_labels (bool): Whether to hide identical legend labels.

            Two labels are identical if their name, marker style and line style match.
        group_id_labels (bool): Whether to group identical legend labels.
        make_subplots_kwargs (dict): Keyword arguments passed to `plotly.subplots.make_subplots`.
        hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
        silence_warnings (bool): Whether to silence all warnings.
        template_mapping (mapping): Global mapping to replace templates.

            Applied on both subplot settings and `kwargs`.
        **kwargs: Additional keyword arguments.

            Can contain keyword arguments for each subplot, specified as `{subplot_name}_kwargs`.
            Other keyword arguments are used to update the layout of the figure.

    For template logic, see `vectorbt.utils.template`.

    For defaults, see `portfolio.plot` in `vectorbt._settings.settings`.

    !!! hint
        This method is very similar to `Portfolio.stats`.

    ## Example

    Plot portfolio of a random strategy:

    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; close = vbt.YFData.download(
    ...     &#34;BTC-USD&#34;,
    ...     start=&#39;2020-01-01 UTC&#39;,
    ...     end=&#39;2020-09-01 UTC&#39;
    ... ).get(&#39;Close&#39;)

    &gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(close, n=10, seed=42)
    &gt;&gt;&gt; pf.plot()
    ```

    ![](/vectorbt/docs/img/portfolio_plot.svg)

    You can choose any of the subplots in `Portfolio.subplots`, in any order, and
    control their appearance using keyword arguments:

    ```python-repl
    &gt;&gt;&gt; from vectorbt.utils.colors import adjust_opacity

    &gt;&gt;&gt; pf.plot(
    ...     subplots=[&#39;drawdowns&#39;, &#39;underwater&#39;],
    ...     drawdowns_kwargs=dict(top_n=3),
    ...     underwater_kwargs=dict(
    ...         trace_kwargs=dict(
    ...             line=dict(color=&#39;#FF6F00&#39;),
    ...             fillcolor=adjust_opacity(&#39;#FF6F00&#39;, 0.3)
    ...         )
    ...     )
    ... )
    ```

    ![](/vectorbt/docs/img/portfolio_plot_drawdowns.svg)

    To create a new subplot, a preferred way is to pass a plotting function:

    ```python-repl
    &gt;&gt;&gt; def plot_order_size(size, add_trace_kwargs=None, fig=None):
    ...     size.rename(&#39;Order Size&#39;).vbt.barplot(
    ...         add_trace_kwargs=add_trace_kwargs, fig=fig)

    &gt;&gt;&gt; order_size = pf.orders.size.to_pd(default_val=0.)
    &gt;&gt;&gt; pf.plot(subplots=[
    ...     &#39;orders&#39;,
    ...     (&#39;order_size&#39;, dict(
    ...         title=&#39;Order Size&#39;,
    ...         yaxis_title=&#39;Order size&#39;,
    ...         allow_grouped=False,
    ...         plot_func=plot_order_size
    ...     ))
    ... ], order_size_kwargs=dict(size=order_size))
    ```

    Alternatively, you can create a placeholder and overwrite it manually later:

    ```python-repl
    &gt;&gt;&gt; fig = pf.plot(subplots=[
    ...     &#39;orders&#39;,
    ...     (&#39;order_size&#39;, dict(
    ...         title=&#39;Order Size&#39;,
    ...         yaxis_title=&#39;Order size&#39;,
    ...         allow_grouped=False
    ...     ))  # placeholder
    ... ])
    &gt;&gt;&gt; order_size.rename(&#39;Order Size&#39;).vbt.barplot(
    ...     add_trace_kwargs=dict(row=2, col=1), fig=fig)
    ```

    ![](/vectorbt/docs/img/portfolio_plot_custom.svg)

    If a plotting function can in any way be accessed from the current portfolio, you can pass
    the path to this function (see `vectorbt.utils.attr.deep_getattr` for the path format).
    You can additionally use templates to make some parameters to depend upon passed keyword arguments:

    ```python-repl
    &gt;&gt;&gt; subplots = [
    ...     (&#39;cumulative_returns&#39;, dict(
    ...         title=&#39;Cumulative Returns&#39;,
    ...         yaxis_title=&#39;Cumulative returns&#39;,
    ...         plot_func=&#39;returns.vbt.returns.cumulative.vbt.plot&#39;,
    ...         pass_add_trace_kwargs=True  # hidden behind **kwargs in vbt.plot
    ...     )),
    ...     (&#39;rolling_drawdown&#39;, dict(
    ...         title=&#39;Rolling Drawdown&#39;,
    ...         yaxis_title=&#39;Rolling drawdown&#39;,
    ...         plot_func=[
    ...             &#39;returns.vbt.returns&#39;,  # returns accessor
    ...             (
    ...                 &#39;rolling_max_drawdown&#39;,  # function name
    ...                 (vbt.Rep(&#39;window&#39;),)),  # positional arguments
    ...             &#39;vbt.plot&#39;  # plotting function
    ...         ],
    ...         pass_add_trace_kwargs=True,
    ...         trace_names=[vbt.Sub(&#39;rolling_drawdown(${window})&#39;)],  # add window to the trace name
    ...     ))
    ... ]
    &gt;&gt;&gt; pf.plot(subplots, rolling_drawdown_kwargs=dict(template_mapping=dict(window=10)))
    ```

    You can also replace templates across all subplots by using the global template mapping:

    ```python-repl
    &gt;&gt;&gt; pf.plot(subplots, template_mapping=dict(window=10))
    ```

    ![](/vectorbt/docs/img/portfolio_plot_path.svg)
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]
    portfolio_plot_cfg = settings[&#39;portfolio&#39;][&#39;plot&#39;]

    # Resolve defaults
    if show_titles is None:
        show_titles = portfolio_plot_cfg[&#39;show_titles&#39;]
    if hide_id_labels is None:
        hide_id_labels = portfolio_plot_cfg[&#39;hide_id_labels&#39;]
    if group_id_labels is None:
        group_id_labels = portfolio_plot_cfg[&#39;group_id_labels&#39;]
    if silence_warnings is None:
        silence_warnings = portfolio_plot_cfg[&#39;silence_warnings&#39;]
    make_subplots_kwargs = merge_dicts(portfolio_plot_cfg[&#39;make_subplots_kwargs&#39;], make_subplots_kwargs)
    template_mapping = merge_dicts(portfolio_plot_cfg[&#39;template_mapping&#39;], template_mapping)
    hline_shape_kwargs = merge_dicts(portfolio_plot_cfg[&#39;hline_shape_kwargs&#39;], hline_shape_kwargs)
    kwargs = merge_dicts(portfolio_plot_cfg[&#39;kwargs&#39;], kwargs)

    # Check if grouped
    is_grouped = self.wrapper.grouper.is_grouped(group_by=group_by)

    # Replace templates globally
    if len(template_mapping) &gt; 0:
        kwargs = deep_substitute(kwargs, mapping=template_mapping)

    # Prepare subplots
    if subplots is None:
        subplots = portfolio_plot_cfg[&#39;subplots&#39;]
        if is_grouped:
            grouped_subplots = portfolio_plot_cfg[&#39;grouped_subplots&#39;]
            if grouped_subplots is None:
                grouped_subplots = subplots
            subplots = grouped_subplots
    if subplots == &#39;all&#39;:
        subplots = self.subplots
    if isinstance(subplots, dict):
        subplots = list(subplots.items())
    if isinstance(subplots, (str, tuple)):
        subplots = [subplots]
    # Bring to the same shape
    new_subplots = []
    for i, subplot in enumerate(subplots):
        if isinstance(subplot, str):
            subplot = (subplot, self.subplots[subplot])
        if not isinstance(subplot, tuple):
            raise TypeError(f&#34;Subplot at index {i} must be either a string or a tuple&#34;)
        new_subplots.append(subplot)
    subplots = new_subplots
    # Handle duplicate names
    subplot_counts = Counter(list(map(lambda x: x[0], subplots)))
    subplot_i = {k: -1 for k in subplot_counts.keys()}
    new_subplots = []
    for i, (name, settings) in enumerate(subplots):
        if subplot_counts[name] &gt; 1:
            subplot_i[name] += 1
            name = name + &#39;_&#39; + str(subplot_i[name])
        new_subplots.append((name, settings))
    subplots = new_subplots
    # Merge settings
    new_subplots = []
    for i, subplot in enumerate(subplots):
        subplot = (subplot[0], merge_dicts(subplot[1], kwargs.pop(f&#39;{subplot[0]}_kwargs&#39;, {})))
        new_subplots.append(subplot)
    subplots = new_subplots
    # Filter subplots
    if is_grouped:
        def _filter_grouped(subplot: tp.Tuple[str, tp.Kwargs]) -&gt; bool:
            if &#39;allow_grouped&#39; not in subplot[1]:
                return True
            if subplot[1][&#39;allow_grouped&#39;]:
                return True
            return False

        new_subplots = list(filter(_filter_grouped, subplots))
        left_out_names = set(map(lambda x: x[0], subplots)).difference(set(map(lambda x: x[0], new_subplots)))
        if len(left_out_names) &gt; 0 and not silence_warnings:
            warnings.warn(f&#34;Subplots {left_out_names} do not support grouped data&#34;, stacklevel=2)
        subplots = new_subplots
    if len(subplots) == 0:
        raise ValueError(&#34;There is no subplot to plot&#34;)

    # Set up figure
    rows = make_subplots_kwargs.pop(&#39;rows&#39;, len(subplots))
    cols = make_subplots_kwargs.pop(&#39;cols&#39;, 1)
    specs = make_subplots_kwargs.pop(&#39;specs&#39;, [[{} for _ in range(cols)] for _ in range(rows)])
    row_col_tuples = []
    for row, row_spec in enumerate(specs):
        for col, col_spec in enumerate(row_spec):
            if col_spec is not None:
                row_col_tuples.append((row + 1, col + 1))
    shared_xaxes = make_subplots_kwargs.pop(&#39;shared_xaxes&#39;, True)
    shared_yaxes = make_subplots_kwargs.pop(&#39;shared_yaxes&#39;, False)
    default_height = plotting_cfg[&#39;layout&#39;][&#39;height&#39;]
    default_width = plotting_cfg[&#39;layout&#39;][&#39;width&#39;] + 50
    min_space = 10  # space between subplots with no axis sharing
    max_title_spacing = 30
    max_xaxis_spacing = 50
    max_yaxis_spacing = 100
    legend_height = 50
    if show_titles:
        title_spacing = max_title_spacing
    else:
        title_spacing = 0
    if not shared_xaxes and rows &gt; 1:
        xaxis_spacing = max_xaxis_spacing
    else:
        xaxis_spacing = 0
    if not shared_yaxes and cols &gt; 1:
        yaxis_spacing = max_yaxis_spacing
    else:
        yaxis_spacing = 0
    if &#39;height&#39; in kwargs:
        height = kwargs.pop(&#39;height&#39;)
    else:
        height = default_height + title_spacing
        if rows &gt; 1:
            height *= rows
            height += min_space * rows - min_space
            height += legend_height - legend_height * rows
            if shared_xaxes:
                height += max_xaxis_spacing - max_xaxis_spacing * rows
    if &#39;width&#39; in kwargs:
        width = kwargs.pop(&#39;width&#39;)
    else:
        width = default_width
        if cols &gt; 1:
            width *= cols
            width += min_space * cols - min_space
            if shared_yaxes:
                width += max_yaxis_spacing - max_yaxis_spacing * cols
    if height is not None:
        if &#39;vertical_spacing&#39; in make_subplots_kwargs:
            vertical_spacing = make_subplots_kwargs.pop(&#39;vertical_spacing&#39;)
        else:
            vertical_spacing = min_space + title_spacing + xaxis_spacing
        if vertical_spacing is not None and vertical_spacing &gt; 1:
            vertical_spacing /= height
        legend_y = 1 + (min_space + title_spacing) / height
    else:
        vertical_spacing = make_subplots_kwargs.pop(&#39;vertical_spacing&#39;, None)
        legend_y = 1.02
    if width is not None:
        if &#39;horizontal_spacing&#39; in make_subplots_kwargs:
            horizontal_spacing = make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;)
        else:
            horizontal_spacing = min_space + yaxis_spacing
        if horizontal_spacing is not None and horizontal_spacing &gt; 1:
            horizontal_spacing /= width
    else:
        horizontal_spacing = make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;, None)
    if show_titles:
        _subplot_titles = []
        for name in subplots:
            _subplot_titles.append(name[1].get(&#39;title&#39;, None))
    else:
        _subplot_titles = None
    fig = make_subplots(
        rows=rows,
        cols=cols,
        specs=specs,
        shared_xaxes=shared_xaxes,
        shared_yaxes=shared_yaxes,
        subplot_titles=_subplot_titles,
        vertical_spacing=vertical_spacing,
        horizontal_spacing=horizontal_spacing,
        **make_subplots_kwargs
    )
    kwargs = merge_dicts(dict(
        width=width,
        height=height,
        legend=dict(
            orientation=&#34;h&#34;,
            yanchor=&#34;bottom&#34;,
            y=legend_y,
            xanchor=&#34;right&#34;,
            x=1,
            traceorder=&#39;normal&#39;
        )
    ), kwargs)
    fig.update_layout(**kwargs)  # final destination for kwargs

    # Show subplots
    for i, (name, settings) in enumerate(subplots):
        _settings = settings.copy()
        _settings.pop(&#39;allow_grouped&#39;, None)

        # Compute figure artifacts
        row, col = row_col_tuples[i]
        xref = &#39;x&#39; if i == 0 else &#39;x&#39; + str(i + 1)
        yref = &#39;y&#39; if i == 0 else &#39;y&#39; + str(i + 1)
        xaxis = &#39;xaxis&#39; + xref[1:]
        yaxis = &#39;yaxis&#39; + yref[1:]
        x_domain = get_domain(xref, fig)
        y_domain = get_domain(yref, fig)

        # Replace templates
        default_settings = dict(
            portfolio=self,
            column=column,
            group_by=group_by,
            subplot_name=name,
            trace_names=[name],
            add_trace_kwargs=dict(row=row, col=col),
            xref=xref,
            yref=yref,
            xaxis=xaxis,
            yaxis=yaxis,
            x_domain=x_domain,
            y_domain=y_domain,
            hline_shape_kwargs=hline_shape_kwargs,
            fig=fig
        )
        reserved_args = list(default_settings.keys())
        reserved_args.remove(&#39;fig&#39;)
        _settings = merge_dicts(default_settings, _settings)
        subplot_template_mapping = _settings.pop(&#39;template_mapping&#39;, {})
        mapping = merge_dicts(_settings, template_mapping, subplot_template_mapping)
        _settings = deep_substitute(_settings, mapping=mapping)

        # Pop values
        plot_func = _settings.pop(&#39;plot_func&#39;, None)
        xaxis_title = _settings.pop(&#39;xaxis_title&#39;, &#39;Date&#39;)
        yaxis_title = _settings.pop(&#39;yaxis_title&#39;, _settings.pop(&#39;title&#39;, None))

        # Prepare function and keyword arguments
        if plot_func is not None:
            if not callable(plot_func):
                plot_func = self.getattr(plot_func, call_last_attr=False)
            if not callable(plot_func):
                raise TypeError(&#34;plot_func must be callable&#34;)
            func_arg_names = get_func_arg_names(plot_func)
            for k in reserved_args:
                if &#39;pass_&#39; + k in _settings:
                    if not _settings.pop(&#39;pass_&#39; + k):  # first priority
                        del _settings[k]
                elif k not in func_arg_names:  # second priority
                    _settings.pop(k, None)

            # Call plotting function
            plot_func(**_settings)

        # Update global layout
        fig.layout[xaxis][&#39;title&#39;] = xaxis_title
        fig.layout[yaxis][&#39;title&#39;] = yaxis_title

    # Remove duplicate legend labels
    found_ids = dict()
    unique_idx = 0
    for trace in fig.data:
        if &#39;name&#39; in trace:
            name = trace[&#39;name&#39;]
        else:
            name = None
        if &#39;marker&#39; in trace:
            marker = trace[&#39;marker&#39;]
        else:
            marker = {}
        if &#39;symbol&#39; in marker:
            marker_symbol = marker[&#39;symbol&#39;]
        else:
            marker_symbol = None
        if &#39;color&#39; in marker:
            marker_color = marker[&#39;color&#39;]
        else:
            marker_color = None
        if &#39;line&#39; in trace:
            line = trace[&#39;line&#39;]
        else:
            line = {}
        if &#39;dash&#39; in line:
            line_dash = line[&#39;dash&#39;]
        else:
            line_dash = None
        if &#39;color&#39; in line:
            line_color = line[&#39;color&#39;]
        else:
            line_color = None

        id = (name, marker_symbol, marker_color, line_dash, line_color)
        if id in found_ids:
            if hide_id_labels:
                trace[&#39;showlegend&#39;] = False
            if group_id_labels:
                trace[&#39;legendgroup&#39;] = found_ids[id]
        else:
            if group_id_labels:
                trace[&#39;legendgroup&#39;] = unique_idx
            found_ids[id] = unique_idx
            unique_idx += 1

    # Remove all except the last title if sharing the same axis
    if shared_xaxes:
        i = 0
        for row in range(rows):
            for col in range(cols):
                if specs[row][col] is not None:
                    xaxis = &#39;xaxis&#39; if i == 0 else &#39;xaxis&#39; + str(i + 1)
                    if row &lt; rows - 1:
                        fig.layout[xaxis][&#39;title&#39;] = None
                    i += 1
    if shared_yaxes:
        i = 0
        for row in range(rows):
            for col in range(cols):
                if specs[row][col] is not None:
                    yaxis = &#39;yaxis&#39; if i == 0 else &#39;yaxis&#39; + str(i + 1)
                    if col &gt; 0:
                        fig.layout[yaxis][&#39;title&#39;] = None
                    i += 1

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.plot_asset_flow"><code class="name flex">
<span>def <span class="ident">plot_asset_flow</span></span>(<span>self, column=None, direction='all', xref='x', yref='y', hline_shape_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot one column of asset flow.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column to plot.</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>Direction</code></dt>
<dd>See <code><a title="vectorbt.portfolio.enums.Direction" href="enums.html#vectorbt.portfolio.enums.Direction">Direction</a></code>.</dd>
<dt><strong><code>xref</code></strong> :&ensp;<code>str</code></dt>
<dd>X coordinate axis.</dd>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>hline_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.generic.accessors.GenericAccessor.plot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.plot">GenericAccessor.plot()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_asset_flow(self,
                    column: tp.Optional[tp.Label] = None,
                    direction: str = &#39;all&#39;,
                    xref: str = &#39;x&#39;,
                    yref: str = &#39;y&#39;,
                    hline_shape_kwargs: tp.KwargsLike = None,
                    **kwargs) -&gt; tp.BaseFigure:
    &#34;&#34;&#34;Plot one column of asset flow.

    Args:
        column (str): Name of the column to plot.
        direction (Direction): See `vectorbt.portfolio.enums.Direction`.
        xref (str): X coordinate axis.
        yref (str): Y coordinate axis.
        hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
        **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.plot`.
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    kwargs = merge_dicts(dict(
        trace_kwargs=dict(
            line=dict(
                color=plotting_cfg[&#39;color_schema&#39;][&#39;brown&#39;]
            ),
            name=&#39;Assets&#39;
        )
    ), kwargs)
    asset_flow = self.asset_flow(direction=direction)
    asset_flow = self.select_one_from_obj(asset_flow, self.wrapper.regroup(False), column=column)
    fig = asset_flow.vbt.plot(**kwargs)
    x_domain = get_domain(xref, fig)
    fig.add_shape(**merge_dicts(dict(
        type=&#39;line&#39;,
        line=dict(
            color=&#39;gray&#39;,
            dash=&#34;dash&#34;,
        ),
        xref=&#34;paper&#34;,
        yref=yref,
        x0=x_domain[0],
        y0=0,
        x1=x_domain[1],
        y1=0
    ), hline_shape_kwargs))
    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.plot_asset_value"><code class="name flex">
<span>def <span class="ident">plot_asset_value</span></span>(<span>self, column=None, group_by=None, direction='all', xref='x', yref='y', hline_shape_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot one column/group of asset value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column/group to plot.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group or ungroup columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>Direction</code></dt>
<dd>See <code><a title="vectorbt.portfolio.enums.Direction" href="enums.html#vectorbt.portfolio.enums.Direction">Direction</a></code>.</dd>
<dt><strong><code>xref</code></strong> :&ensp;<code>str</code></dt>
<dd>X coordinate axis.</dd>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>hline_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.generic.accessors.GenericSRAccessor.plot_against" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.plot_against">GenericSRAccessor.plot_against()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_asset_value(self,
                     column: tp.Optional[tp.Label] = None,
                     group_by: tp.GroupByLike = None,
                     direction: str = &#39;all&#39;,
                     xref: str = &#39;x&#39;,
                     yref: str = &#39;y&#39;,
                     hline_shape_kwargs: tp.KwargsLike = None,
                     **kwargs) -&gt; tp.BaseFigure:
    &#34;&#34;&#34;Plot one column/group of asset value.

    Args:
        column (str): Name of the column/group to plot.
        group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        direction (Direction): See `vectorbt.portfolio.enums.Direction`.
        xref (str): X coordinate axis.
        yref (str): Y coordinate axis.
        hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
        **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    kwargs = merge_dicts(dict(
        trace_kwargs=dict(
            line=dict(
                color=plotting_cfg[&#39;color_schema&#39;][&#39;cyan&#39;]
            ),
            name=&#39;Asset Value&#39;
        ),
        pos_trace_kwargs=dict(
            fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;cyan&#39;], 0.3)
        ),
        neg_trace_kwargs=dict(
            fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;orange&#39;], 0.3)
        ),
        other_trace_kwargs=&#39;hidden&#39;
    ), kwargs)
    asset_value = self.asset_value(direction=direction, group_by=group_by)
    asset_value = self.select_one_from_obj(asset_value, self.wrapper.regroup(group_by), column=column)
    fig = asset_value.vbt.plot_against(0, **kwargs)
    x_domain = get_domain(xref, fig)
    fig.add_shape(**merge_dicts(dict(
        type=&#39;line&#39;,
        line=dict(
            color=&#39;gray&#39;,
            dash=&#34;dash&#34;,
        ),
        xref=&#34;paper&#34;,
        yref=yref,
        x0=x_domain[0],
        y0=0.,
        x1=x_domain[1],
        y1=0.
    ), hline_shape_kwargs))
    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.plot_assets"><code class="name flex">
<span>def <span class="ident">plot_assets</span></span>(<span>self, column=None, direction='all', xref='x', yref='y', hline_shape_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot one column of assets.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column to plot.</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>Direction</code></dt>
<dd>See <code><a title="vectorbt.portfolio.enums.Direction" href="enums.html#vectorbt.portfolio.enums.Direction">Direction</a></code>.</dd>
<dt><strong><code>xref</code></strong> :&ensp;<code>str</code></dt>
<dd>X coordinate axis.</dd>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>hline_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.generic.accessors.GenericSRAccessor.plot_against" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.plot_against">GenericSRAccessor.plot_against()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_assets(self,
                column: tp.Optional[tp.Label] = None,
                direction: str = &#39;all&#39;,
                xref: str = &#39;x&#39;,
                yref: str = &#39;y&#39;,
                hline_shape_kwargs: tp.KwargsLike = None,
                **kwargs) -&gt; tp.BaseFigure:
    &#34;&#34;&#34;Plot one column of assets.

    Args:
        column (str): Name of the column to plot.
        direction (Direction): See `vectorbt.portfolio.enums.Direction`.
        xref (str): X coordinate axis.
        yref (str): Y coordinate axis.
        hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
        **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    kwargs = merge_dicts(dict(
        trace_kwargs=dict(
            line=dict(
                color=plotting_cfg[&#39;color_schema&#39;][&#39;brown&#39;]
            ),
            name=&#39;Assets&#39;
        ),
        pos_trace_kwargs=dict(
            fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;brown&#39;], 0.3)
        ),
        neg_trace_kwargs=dict(
            fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;orange&#39;], 0.3)
        ),
        other_trace_kwargs=&#39;hidden&#39;
    ), kwargs)
    assets = self.assets(direction=direction)
    assets = self.select_one_from_obj(assets, self.wrapper.regroup(False), column=column)
    fig = assets.vbt.plot_against(0, **kwargs)
    x_domain = get_domain(xref, fig)
    fig.add_shape(**merge_dicts(dict(
        type=&#39;line&#39;,
        line=dict(
            color=&#39;gray&#39;,
            dash=&#34;dash&#34;,
        ),
        xref=&#34;paper&#34;,
        yref=yref,
        x0=x_domain[0],
        y0=0.,
        x1=x_domain[1],
        y1=0.
    ), hline_shape_kwargs))
    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.plot_cash"><code class="name flex">
<span>def <span class="ident">plot_cash</span></span>(<span>self, column=None, group_by=None, free=False, xref='x', yref='y', hline_shape_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot one column/group of cash balance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column/group to plot.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group or ungroup columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>free</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to plot the flow of the free cash.</dd>
<dt><strong><code>xref</code></strong> :&ensp;<code>str</code></dt>
<dd>X coordinate axis.</dd>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>hline_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.generic.accessors.GenericSRAccessor.plot_against" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.plot_against">GenericSRAccessor.plot_against()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_cash(self,
              column: tp.Optional[tp.Label] = None,
              group_by: tp.GroupByLike = None,
              free: bool = False,
              xref: str = &#39;x&#39;,
              yref: str = &#39;y&#39;,
              hline_shape_kwargs: tp.KwargsLike = None,
              **kwargs) -&gt; tp.BaseFigure:
    &#34;&#34;&#34;Plot one column/group of cash balance.

    Args:
        column (str): Name of the column/group to plot.
        group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        free (bool): Whether to plot the flow of the free cash.
        xref (str): X coordinate axis.
        yref (str): Y coordinate axis.
        hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
        **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    kwargs = merge_dicts(dict(
        trace_kwargs=dict(
            line=dict(
                color=plotting_cfg[&#39;color_schema&#39;][&#39;green&#39;]
            ),
            name=&#39;Cash&#39;
        ),
        pos_trace_kwargs=dict(
            fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;green&#39;], 0.3)
        ),
        neg_trace_kwargs=dict(
            fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;red&#39;], 0.3)
        ),
        other_trace_kwargs=&#39;hidden&#39;
    ), kwargs)
    init_cash = self.get_init_cash(group_by=group_by)
    init_cash = self.select_one_from_obj(init_cash, self.wrapper.regroup(group_by), column=column)
    cash = self.cash(group_by=group_by, free=free)
    cash = self.select_one_from_obj(cash, self.wrapper.regroup(group_by), column=column)
    fig = cash.vbt.plot_against(init_cash, **kwargs)
    x_domain = get_domain(xref, fig)
    fig.add_shape(**merge_dicts(dict(
        type=&#39;line&#39;,
        line=dict(
            color=&#39;gray&#39;,
            dash=&#34;dash&#34;,
        ),
        xref=&#34;paper&#34;,
        yref=yref,
        x0=x_domain[0],
        y0=init_cash,
        x1=x_domain[1],
        y1=init_cash
    ), hline_shape_kwargs))
    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.plot_cash_flow"><code class="name flex">
<span>def <span class="ident">plot_cash_flow</span></span>(<span>self, column=None, group_by=None, free=False, xref='x', yref='y', hline_shape_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot one column/group of cash flow.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column/group to plot.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group or ungroup columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>free</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to plot the flow of the free cash.</dd>
<dt><strong><code>xref</code></strong> :&ensp;<code>str</code></dt>
<dd>X coordinate axis.</dd>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>hline_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.generic.accessors.GenericAccessor.plot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.plot">GenericAccessor.plot()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_cash_flow(self,
                   column: tp.Optional[tp.Label] = None,
                   group_by: tp.GroupByLike = None,
                   free: bool = False,
                   xref: str = &#39;x&#39;,
                   yref: str = &#39;y&#39;,
                   hline_shape_kwargs: tp.KwargsLike = None,
                   **kwargs) -&gt; tp.BaseFigure:
    &#34;&#34;&#34;Plot one column/group of cash flow.

    Args:
        column (str): Name of the column/group to plot.
        group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        free (bool): Whether to plot the flow of the free cash.
        xref (str): X coordinate axis.
        yref (str): Y coordinate axis.
        hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
        **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.plot`.
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    kwargs = merge_dicts(dict(
        trace_kwargs=dict(
            line=dict(
                color=plotting_cfg[&#39;color_schema&#39;][&#39;green&#39;]
            ),
            name=&#39;Cash&#39;
        )
    ), kwargs)
    cash_flow = self.cash_flow(group_by=group_by, free=free)
    cash_flow = self.select_one_from_obj(cash_flow, self.wrapper.regroup(group_by), column=column)
    fig = cash_flow.vbt.plot(**kwargs)
    x_domain = get_domain(xref, fig)
    fig.add_shape(**merge_dicts(dict(
        type=&#39;line&#39;,
        line=dict(
            color=&#39;gray&#39;,
            dash=&#34;dash&#34;,
        ),
        xref=&#34;paper&#34;,
        yref=yref,
        x0=x_domain[0],
        y0=0.,
        x1=x_domain[1],
        y1=0.
    ), hline_shape_kwargs))
    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.plot_cum_returns"><code class="name flex">
<span>def <span class="ident">plot_cum_returns</span></span>(<span>self, column=None, group_by=None, asset_returns=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot one column/group of cumulative returns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column/group to plot.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group or ungroup columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>asset_returns</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to plot asset returns.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.returns.accessors.ReturnsSRAccessor.plot_cum_returns" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsSRAccessor.plot_cum_returns">ReturnsSRAccessor.plot_cum_returns()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_cum_returns(self,
                     column: tp.Optional[tp.Label] = None,
                     group_by: tp.GroupByLike = None,
                     asset_returns: bool = False,
                     **kwargs) -&gt; tp.BaseFigure:
    &#34;&#34;&#34;Plot one column/group of cumulative returns.

    Args:
        column (str): Name of the column/group to plot.
        group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        asset_returns (bool): Whether to plot asset returns.
        **kwargs: Keyword arguments passed to `vectorbt.returns.accessors.ReturnsSRAccessor.plot_cum_returns`.
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    market_returns = self.market_returns(group_by=group_by)
    market_returns = self.select_one_from_obj(market_returns, self.wrapper.regroup(group_by), column=column)
    kwargs = merge_dicts(dict(
        benchmark_rets=market_returns,
        main_kwargs=dict(
            trace_kwargs=dict(
                line=dict(
                    color=plotting_cfg[&#39;color_schema&#39;][&#39;purple&#39;]
                ),
                name=&#39;Value&#39;
            )
        ),
        hline_shape_kwargs=dict(
            type=&#39;line&#39;,
            line=dict(
                color=&#39;gray&#39;,
                dash=&#34;dash&#34;,
            )
        )
    ), kwargs)
    if asset_returns:
        returns = self.asset_returns(group_by=group_by)
    else:
        returns = self.returns(group_by=group_by)
    returns = self.select_one_from_obj(returns, self.wrapper.regroup(group_by), column=column)
    return returns.vbt.returns.plot_cum_returns(**kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.plot_drawdowns"><code class="name flex">
<span>def <span class="ident">plot_drawdowns</span></span>(<span>self, column=None, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot one column/group of drawdowns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column/group to plot.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group or ungroup columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.generic.drawdowns.Drawdowns.plot" href="../generic/drawdowns.html#vectorbt.generic.drawdowns.Drawdowns.plot">Drawdowns.plot()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_drawdowns(self,
                   column: tp.Optional[tp.Label] = None,
                   group_by: tp.GroupByLike = None,
                   **kwargs) -&gt; tp.BaseFigure:
    &#34;&#34;&#34;Plot one column/group of drawdowns.

    Args:
        column (str): Name of the column/group to plot.
        group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        **kwargs: Keyword arguments passed to `vectorbt.generic.drawdowns.Drawdowns.plot`.
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    kwargs = merge_dicts(dict(
        ts_trace_kwargs=dict(
            line=dict(
                color=plotting_cfg[&#39;color_schema&#39;][&#39;purple&#39;]
            ),
            name=&#39;Value&#39;
        )
    ), kwargs)
    return self.get_drawdowns(group_by=group_by).plot(column=column, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.plot_gross_exposure"><code class="name flex">
<span>def <span class="ident">plot_gross_exposure</span></span>(<span>self, column=None, group_by=None, direction='all', xref='x', yref='y', hline_shape_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot one column/group of gross exposure.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column/group to plot.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group or ungroup columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>Direction</code></dt>
<dd>See <code><a title="vectorbt.portfolio.enums.Direction" href="enums.html#vectorbt.portfolio.enums.Direction">Direction</a></code>.</dd>
<dt><strong><code>xref</code></strong> :&ensp;<code>str</code></dt>
<dd>X coordinate axis.</dd>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>hline_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.generic.accessors.GenericSRAccessor.plot_against" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.plot_against">GenericSRAccessor.plot_against()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_gross_exposure(self,
                        column: tp.Optional[tp.Label] = None,
                        group_by: tp.GroupByLike = None,
                        direction: str = &#39;all&#39;,
                        xref: str = &#39;x&#39;,
                        yref: str = &#39;y&#39;,
                        hline_shape_kwargs: tp.KwargsLike = None,
                        **kwargs) -&gt; tp.BaseFigure:
    &#34;&#34;&#34;Plot one column/group of gross exposure.

    Args:
        column (str): Name of the column/group to plot.
        group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        direction (Direction): See `vectorbt.portfolio.enums.Direction`.
        xref (str): X coordinate axis.
        yref (str): Y coordinate axis.
        hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
        **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    kwargs = merge_dicts(dict(
        trace_kwargs=dict(
            line=dict(
                color=plotting_cfg[&#39;color_schema&#39;][&#39;pink&#39;]
            ),
            name=&#39;Exposure&#39;
        ),
        pos_trace_kwargs=dict(
            fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;orange&#39;], 0.3)
        ),
        neg_trace_kwargs=dict(
            fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;pink&#39;], 0.3)
        ),
        other_trace_kwargs=&#39;hidden&#39;
    ), kwargs)
    gross_exposure = self.gross_exposure(direction=direction, group_by=group_by)
    gross_exposure = self.select_one_from_obj(gross_exposure, self.wrapper.regroup(group_by), column=column)
    fig = gross_exposure.vbt.plot_against(1, **kwargs)
    x_domain = get_domain(xref, fig)
    fig.add_shape(**merge_dicts(dict(
        type=&#39;line&#39;,
        line=dict(
            color=&#39;gray&#39;,
            dash=&#34;dash&#34;,
        ),
        xref=&#34;paper&#34;,
        yref=yref,
        x0=x_domain[0],
        y0=1,
        x1=x_domain[1],
        y1=1
    ), hline_shape_kwargs))
    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.plot_net_exposure"><code class="name flex">
<span>def <span class="ident">plot_net_exposure</span></span>(<span>self, column=None, group_by=None, xref='x', yref='y', hline_shape_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot one column/group of net exposure.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column/group to plot.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group or ungroup columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>xref</code></strong> :&ensp;<code>str</code></dt>
<dd>X coordinate axis.</dd>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>hline_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.generic.accessors.GenericSRAccessor.plot_against" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.plot_against">GenericSRAccessor.plot_against()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_net_exposure(self,
                      column: tp.Optional[tp.Label] = None,
                      group_by: tp.GroupByLike = None,
                      xref: str = &#39;x&#39;,
                      yref: str = &#39;y&#39;,
                      hline_shape_kwargs: tp.KwargsLike = None,
                      **kwargs) -&gt; tp.BaseFigure:
    &#34;&#34;&#34;Plot one column/group of net exposure.

    Args:
        column (str): Name of the column/group to plot.
        group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        xref (str): X coordinate axis.
        yref (str): Y coordinate axis.
        hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
        **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    kwargs = merge_dicts(dict(
        trace_kwargs=dict(
            line=dict(
                color=plotting_cfg[&#39;color_schema&#39;][&#39;pink&#39;]
            ),
            name=&#39;Exposure&#39;
        ),
        pos_trace_kwargs=dict(
            fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;pink&#39;], 0.3)
        ),
        neg_trace_kwargs=dict(
            fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;orange&#39;], 0.3)
        ),
        other_trace_kwargs=&#39;hidden&#39;
    ), kwargs)
    net_exposure = self.net_exposure(group_by=group_by)
    net_exposure = self.select_one_from_obj(net_exposure, self.wrapper.regroup(group_by), column=column)
    fig = net_exposure.vbt.plot_against(0, **kwargs)
    x_domain = get_domain(xref, fig)
    fig.add_shape(**merge_dicts(dict(
        type=&#39;line&#39;,
        line=dict(
            color=&#39;gray&#39;,
            dash=&#34;dash&#34;,
        ),
        xref=&#34;paper&#34;,
        yref=yref,
        x0=x_domain[0],
        y0=0,
        x1=x_domain[1],
        y1=0
    ), hline_shape_kwargs))
    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.plot_underwater"><code class="name flex">
<span>def <span class="ident">plot_underwater</span></span>(<span>self, column=None, group_by=None, xref='x', yref='y', hline_shape_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot one column/group of underwater.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column/group to plot.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group or ungroup columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>xref</code></strong> :&ensp;<code>str</code></dt>
<dd>X coordinate axis.</dd>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>hline_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.generic.accessors.GenericAccessor.plot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.plot">GenericAccessor.plot()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_underwater(self,
                    column: tp.Optional[tp.Label] = None,
                    group_by: tp.GroupByLike = None,
                    xref: str = &#39;x&#39;,
                    yref: str = &#39;y&#39;,
                    hline_shape_kwargs: tp.KwargsLike = None,
                    **kwargs) -&gt; tp.BaseFigure:
    &#34;&#34;&#34;Plot one column/group of underwater.

    Args:
        column (str): Name of the column/group to plot.
        group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        xref (str): X coordinate axis.
        yref (str): Y coordinate axis.
        hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
        **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.plot`.
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    kwargs = merge_dicts(dict(
        trace_kwargs=dict(
            line=dict(
                color=plotting_cfg[&#39;color_schema&#39;][&#39;red&#39;]
            ),
            fillcolor=adjust_opacity(plotting_cfg[&#39;color_schema&#39;][&#39;red&#39;], 0.3),
            fill=&#39;tozeroy&#39;,
            name=&#39;Drawdown&#39;
        )
    ), kwargs)
    drawdown = self.drawdown(group_by=group_by)
    drawdown = self.select_one_from_obj(drawdown, self.wrapper.regroup(group_by), column=column)
    fig = drawdown.vbt.plot(**kwargs)
    x_domain = get_domain(xref, fig)
    fig.add_shape(**merge_dicts(dict(
        type=&#39;line&#39;,
        line=dict(
            color=&#39;gray&#39;,
            dash=&#34;dash&#34;,
        ),
        xref=&#34;paper&#34;,
        yref=yref,
        x0=x_domain[0],
        y0=0,
        x1=x_domain[1],
        y1=0
    ), hline_shape_kwargs))
    yaxis = &#39;yaxis&#39; + yref[1:]
    fig.layout[yaxis][&#39;tickformat&#39;] = &#39;%&#39;
    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.plot_value"><code class="name flex">
<span>def <span class="ident">plot_value</span></span>(<span>self, column=None, group_by=None, xref='x', yref='y', hline_shape_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot one column/group of value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column/group to plot.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group or ungroup columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>free</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to plot free cash flow.</dd>
<dt><strong><code>xref</code></strong> :&ensp;<code>str</code></dt>
<dd>X coordinate axis.</dd>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>hline_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.generic.accessors.GenericSRAccessor.plot_against" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.plot_against">GenericSRAccessor.plot_against()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_value(self,
               column: tp.Optional[tp.Label] = None,
               group_by: tp.GroupByLike = None,
               xref: str = &#39;x&#39;,
               yref: str = &#39;y&#39;,
               hline_shape_kwargs: tp.KwargsLike = None,
               **kwargs) -&gt; tp.BaseFigure:
    &#34;&#34;&#34;Plot one column/group of value.

    Args:
        column (str): Name of the column/group to plot.
        group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        free (bool): Whether to plot free cash flow.
        xref (str): X coordinate axis.
        yref (str): Y coordinate axis.
        hline_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for zeroline.
        **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericSRAccessor.plot_against`.
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    kwargs = merge_dicts(dict(
        trace_kwargs=dict(
            line=dict(
                color=plotting_cfg[&#39;color_schema&#39;][&#39;purple&#39;]
            ),
            name=&#39;Value&#39;
        ),
        other_trace_kwargs=&#39;hidden&#39;
    ), kwargs)
    init_cash = self.get_init_cash(group_by=group_by)
    init_cash = self.select_one_from_obj(init_cash, self.wrapper.regroup(group_by), column=column)
    value = self.value(group_by=group_by)
    value = self.select_one_from_obj(value, self.wrapper.regroup(group_by), column=column)
    fig = value.vbt.plot_against(init_cash, **kwargs)
    x_domain = get_domain(xref, fig)
    fig.add_shape(**merge_dicts(dict(
        type=&#39;line&#39;,
        line=dict(
            color=&#39;gray&#39;,
            dash=&#34;dash&#34;,
        ),
        xref=&#34;paper&#34;,
        yref=yref,
        x0=x_domain[0],
        y0=init_cash,
        x1=x_domain[1],
        y1=init_cash
    ), hline_shape_kwargs))
    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.position_coverage"><code class="name flex">
<span>def <span class="ident">position_coverage</span></span>(<span>self, direction='all', group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get position coverage per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def position_coverage(self, direction: str = &#39;all&#39;, group_by: tp.GroupByLike = None,
                      wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get position coverage per column/group.&#34;&#34;&#34;
    direction = cast_enum_value(direction, Direction)
    assets = to_2d(self.assets(direction=direction), raw=True)
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        position_mask = to_2d(self.position_mask(direction=direction, group_by=False), raw=True)
        group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
        position_coverage = nb.position_coverage_grouped_nb(position_mask, group_lens)
    else:
        position_coverage = np.mean(assets != 0, axis=0)
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;position_coverage&#39;), wrap_kwargs)
    return self.wrapper.wrap_reduced(position_coverage, group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.position_mask"><code class="name flex">
<span>def <span class="ident">position_mask</span></span>(<span>self, direction='all', group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get position mask per column/group.</p>
<p>An element is True if the asset is in the market at this tick.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def position_mask(self, direction: str = &#39;all&#39;, group_by: tp.GroupByLike = None,
                  wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get position mask per column/group.

    An element is True if the asset is in the market at this tick.&#34;&#34;&#34;
    direction = cast_enum_value(direction, Direction)
    assets = to_2d(self.assets(direction=direction), raw=True)
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        position_mask = to_2d(self.position_mask(direction=direction, group_by=False), raw=True)
        group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
        position_mask = nb.position_mask_grouped_nb(position_mask, group_lens)
    else:
        position_mask = assets != 0
    return self.wrapper.wrap(position_mask, group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.regroup"><code class="name flex">
<span>def <span class="ident">regroup</span></span>(<span>self, group_by, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Regroup this object.</p>
<p>See <code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">Wrapping.regroup()</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All cached objects will be lost.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regroup(self: PortfolioT, group_by: tp.GroupByLike, **kwargs) -&gt; PortfolioT:
    &#34;&#34;&#34;Regroup this object.

    See `vectorbt.base.array_wrapper.Wrapping.regroup`.

    !!! note
        All cached objects will be lost.&#34;&#34;&#34;
    if self.cash_sharing:
        if self.wrapper.grouper.is_grouping_modified(group_by=group_by):
            raise ValueError(&#34;Cannot modify grouping globally when cash_sharing=True&#34;)
    return Wrapping.regroup(self, group_by, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.resolve_attr"><code class="name flex">
<span>def <span class="ident">resolve_attr</span></span>(<span>self, attr, args=None, cond_kwargs=None, kwargs=None, custom_arg_names=None, cache_dct=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Resolve attribute of the portfolio using keyword arguments and built-in caching.</p>
<ul>
<li>If <code>attr</code> is a property, simply returns it.</li>
<li>If <code>attr</code> is a method, passes <code>*args</code>, <code>**kwargs</code>, and <code>**cond_kwargs</code> with keys found in the signature.</li>
<li>If <code>attr</code> is a property and there is a <code>get_{arg}</code> method, calls the <code>get_{arg}</code> method.</li>
</ul>
<p>Won't cache if any passed argument is in <code>custom_arg_names</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_attr(self,
                 attr: str,
                 args: tp.ArgsLike = None,
                 cond_kwargs: tp.KwargsLike = None,
                 kwargs: tp.KwargsLike = None,
                 custom_arg_names: tp.Optional[tp.Container[str]] = None,
                 cache_dct: tp.KwargsLike = None) -&gt; tp.Any:
    &#34;&#34;&#34;Resolve attribute of the portfolio using keyword arguments and built-in caching.

    * If `attr` is a property, simply returns it.
    * If `attr` is a method, passes `*args`, `**kwargs`, and `**cond_kwargs` with keys found in the signature.
    * If `attr` is a property and there is a `get_{arg}` method, calls the `get_{arg}` method.

    Won&#39;t cache if any passed argument is in `custom_arg_names`.&#34;&#34;&#34;
    # Resolve defaults
    if custom_arg_names is None:
        custom_arg_names = list()
    if cache_dct is None:
        cache_dct = {}
    if args is None:
        args = ()
    if kwargs is None:
        kwargs = {}
    final_kwargs = merge_dicts(self.common_settings, cond_kwargs, kwargs)

    # Resolve attribute
    if attr == &#39;returns&#39; and final_kwargs[&#39;use_asset_returns&#39;]:
        attr = &#39;asset_returns&#39;
    if attr == &#39;trades&#39; and final_kwargs[&#39;use_positions&#39;]:
        attr = &#39;positions&#39;
    cls = type(self)
    _attr = attr
    if &#39;get_&#39; + attr in dir(cls):
        _attr = &#39;get_&#39; + attr
    if callable(getattr(cls, _attr)):
        attr_func = getattr(self, _attr)
        attr_func_kwargs = dict()
        attr_func_arg_names = get_func_arg_names(attr_func)
        custom_k = False
        for k, v in final_kwargs.items():
            if k in attr_func_arg_names or k in kwargs:
                if k in custom_arg_names:
                    custom_k = True
                attr_func_kwargs[k] = v
        if final_kwargs[&#39;use_caching&#39;] and not custom_k and attr in cache_dct:
            out = cache_dct[attr]
        else:
            out = attr_func(*args, **attr_func_kwargs)
            if attr in [&#39;trades&#39;, &#39;positions&#39;, &#39;drawdowns&#39;]:
                if self.wrapper.freq != final_kwargs[&#39;freq&#39;]:
                    out = out.copy(wrapper=out.wrapper.copy(freq=final_kwargs[&#39;freq&#39;]))
            if attr in [&#39;trades&#39;, &#39;positions&#39;] and not final_kwargs[&#39;incl_unrealized&#39;]:
                out = out.closed
            if final_kwargs[&#39;use_caching&#39;] and not custom_k:
                cache_dct[attr] = out
    else:
        if final_kwargs[&#39;use_caching&#39;] and attr in cache_dct:
            out = cache_dct[attr]
        else:
            out = getattr(self, _attr)
            if final_kwargs[&#39;use_caching&#39;]:
                cache_dct[attr] = out
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.returns"><code class="name flex">
<span>def <span class="ident">returns</span></span>(<span>self, group_by=None, in_sim_order=False, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get return series per column/group based on portfolio value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def returns(self, group_by: tp.GroupByLike = None, in_sim_order=False,
            wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get return series per column/group based on portfolio value.&#34;&#34;&#34;
    value = to_2d(self.value(group_by=group_by, in_sim_order=in_sim_order), raw=True)
    if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
        group_lens = self.wrapper.grouper.get_group_lens()
        init_cash_grouped = to_1d(self.init_cash, raw=True)
        call_seq = to_2d(self.call_seq, raw=True)
        returns = nb.returns_in_sim_order_nb(value, group_lens, init_cash_grouped, call_seq)
    else:
        init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
        returns = nb.returns_nb(value, init_cash)
    return self.wrapper.wrap(returns, group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.returns_acc"><code class="name flex">
<span>def <span class="ident">returns_acc</span></span>(<span>self, group_by=None, freq=None, year_freq=None, use_asset_returns=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get returns accessor of type <code><a title="vectorbt.returns.accessors.ReturnsAccessor" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor">ReturnsAccessor</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>You can find most methods of this accessor as (cacheable) attributes of this portfolio.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def returns_acc(self,
                group_by: tp.GroupByLike = None,
                freq: tp.Optional[tp.FrequencyLike] = None,
                year_freq: tp.Optional[tp.FrequencyLike] = None,
                use_asset_returns: bool = False) -&gt; ReturnsAccessor:
    &#34;&#34;&#34;Get returns accessor of type `vectorbt.returns.accessors.ReturnsAccessor`.

    !!! hint
        You can find most methods of this accessor as (cacheable) attributes of this portfolio.&#34;&#34;&#34;
    if freq is None:
        freq = self.wrapper.freq
    if use_asset_returns:
        returns = self.asset_returns(group_by=group_by)
    else:
        returns = self.returns(group_by=group_by)
    return returns.vbt.returns(freq=freq, year_freq=year_freq)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.returns_stats"><code class="name flex">
<span>def <span class="ident">returns_stats</span></span>(<span>self, column=None, group_by=None, use_asset_returns=False, in_sim_order=False, agg_func=&lt;function mean&gt;, year_freq=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute various statistics on returns of this portfolio.</p>
<p>For keyword arguments and notes, see <code><a title="vectorbt.portfolio.base.Portfolio.stats" href="#vectorbt.portfolio.base.Portfolio.stats">Portfolio.stats()</a></code>.</p>
<p><code>kwargs</code> will be passed to <code><a title="vectorbt.returns.accessors.ReturnsAccessor.stats" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.stats">ReturnsAccessor.stats()</a></code> method.
If <code>benchmark_rets</code> is not set, uses <code><a title="vectorbt.portfolio.base.Portfolio.market_returns" href="#vectorbt.portfolio.base.Portfolio.market_returns">Portfolio.market_returns()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_stats(self,
                  column: tp.Optional[tp.Label] = None,
                  group_by: tp.GroupByLike = None,
                  use_asset_returns: bool = False,
                  in_sim_order: bool = False,
                  agg_func: tp.Optional[tp.Callable] = np.mean,
                  year_freq: tp.Optional[tp.FrequencyLike] = None,
                  **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Compute various statistics on returns of this portfolio.

    For keyword arguments and notes, see `Portfolio.stats`.

    `kwargs` will be passed to `vectorbt.returns.accessors.ReturnsAccessor.stats` method.
    If `benchmark_rets` is not set, uses `Portfolio.market_returns`.&#34;&#34;&#34;
    # Pre-calculate
    if use_asset_returns:
        returns = self.asset_returns(group_by=group_by)
    else:
        returns = self.returns(group_by=group_by, in_sim_order=in_sim_order)

    # Run stats
    if &#39;benchmark_rets&#39; not in kwargs:
        kwargs[&#39;benchmark_rets&#39;] = self.market_returns(group_by=group_by)
    stats_obj = returns.vbt.returns(freq=self.wrapper.freq, year_freq=year_freq).stats(**kwargs)

    # Select columns or reduce
    if checks.is_series(stats_obj):
        return stats_obj
    if column is not None:
        return stats_obj.loc[column]
    if agg_func is not None:
        if agg_func == np.mean:
            warnings.warn(&#34;Taking mean across columns. To return a DataFrame, pass agg_func=None.&#34;, stacklevel=2)
            func_name = &#39;stats_mean&#39;
        else:
            func_name = &#39;stats_&#39; + agg_func.__name__
        agg_stats_sr = pd.Series(index=stats_obj.columns, name=func_name)
        agg_stats_sr.iloc[:3] = stats_obj.iloc[0, :3]
        agg_stats_sr.iloc[3:] = agg_func(stats_obj.iloc[:, 3:])
        return agg_stats_sr
    return stats_obj</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.sharpe_ratio"><code class="name flex">
<span>def <span class="ident">sharpe_ratio</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.sharpe_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.sharpe_ratio">ReturnsAccessor.sharpe_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.sortino_ratio"><code class="name flex">
<span>def <span class="ident">sortino_ratio</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.sortino_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.sortino_ratio">ReturnsAccessor.sortino_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.stats"><code class="name flex">
<span>def <span class="ident">stats</span></span>(<span>self, metrics=None, column=None, group_by=None, agg_func=&lt;function mean&gt;, silence_warnings=None, template_mapping=None, global_settings=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute various metrics on this portfolio.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metrics</code></strong> :&ensp;<code>str, tuple, iterable,</code> or <code>dict</code></dt>
<dd>
<p>List of metrics to calculate.</p>
<p>Each element can be either:</p>
<ul>
<li>a metric name (see keys in <code><a title="vectorbt.portfolio.base.Portfolio.metrics" href="#vectorbt.portfolio.base.Portfolio.metrics">Portfolio.metrics</a></code>)</li>
<li>a tuple of a metric name and a settings dict as in <code><a title="vectorbt.portfolio.base.Portfolio.metrics" href="#vectorbt.portfolio.base.Portfolio.metrics">Portfolio.metrics</a></code>.</li>
</ul>
<p>Each settings dict can contain the following keys:</p>
<ul>
<li><code>title</code>: title of the metric. Defaults to the name.</li>
<li><code>allow_grouped</code>: whether this metric supports using grouped data. Defaults to True.
Must be known beforehand and cannot be provided as a template.</li>
<li><code>req_freq</code>: whether this metric requires frequency. Defaults to False.
Must be known beforehand and cannot be provided as a template.</li>
<li><code>calc_func</code>: calculation function for custom metrics. If the function can be accessed
by traversing attributes of this portfolio, you can pass the path to this function
as a string (see <code><a title="vectorbt.utils.attr.deep_getattr" href="../utils/attr.html#vectorbt.utils.attr.deep_getattr">deep_getattr()</a></code> for the path format).
Should return either a scalar for one column/group or pd.Series for multiple columns/groups.</li>
<li><code>pass_{arg}</code>: whether to pass a reserved argument (see below). Defaults to True if
this argument was found in the function's signature. Set to False to not pass.</li>
<li><code>glob_pass_{arg}</code>: whether to pass an argument from <code>global_settings</code>. Defaults to True if
this argument was found both in <code>global_settings</code> and the function's signature.
Set to False to not pass.</li>
<li><code>resolve_{arg}</code>: whether to resolve an argument that is meant to be an attribute of
the portfolio (see <code><a title="vectorbt.portfolio.base.Portfolio.resolve_attr" href="#vectorbt.portfolio.base.Portfolio.resolve_attr">Portfolio.resolve_attr()</a></code>). Defaults to True if this argument was found
in the function's signature. Set to False to not resolve.</li>
<li><code>template_mapping</code>: mapping to replace templates in metric settings and keyword arguments.
Used across all settings.</li>
<li>Any other keyword argument overrides reserved arguments or is passed directly to <code>calc_func</code>.</li>
</ul>
<p>A calculation function may accept any keyword argument. It may "request" any of the
following reserved arguments by accepting them or if <code>pass_{arg}</code> was found in the settings dict:</p>
<ul>
<li><code>pf</code> or <code>portfolio</code>: original portfolio (ungrouped and with no column selected)</li>
<li><code>column</code></li>
<li><code>group_by</code></li>
<li><code>metric_name</code></li>
<li><code>agg_func</code></li>
<li>Any argument from <code><a title="vectorbt.portfolio.base.Portfolio.common_settings" href="#vectorbt.portfolio.base.Portfolio.common_settings">Portfolio.common_settings</a></code></li>
<li>Any attribute of the portfolio if it meant to be resolved (see <code><a title="vectorbt.portfolio.base.Portfolio.resolve_attr" href="#vectorbt.portfolio.base.Portfolio.resolve_attr">Portfolio.resolve_attr()</a></code>)</li>
</ul>
<p>Pass <code>metrics='all'</code> to calculate all supported metrics.</p>
</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Name of the column/group.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>There are two ways to select a column: <code>pf['a'].stats()</code> and <code>pf.stats(column='a')</code>.
They both accomplish the same thing but in different ways: <code>pf['a'].stats()</code> computes
statistics of the column 'a' only, while <code>pf.stats(column='a')</code> computes statistics of
all columns first and only then selects the column 'a'. The first method is preferred
when you have a lot of data or caching is disabled. The second method is preferred when
most attributes have already been cached.</p>
</div>
</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group or ungroup columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>agg_func</code></strong> :&ensp;<code>callable</code></dt>
<dd>
<p>Aggregation function to aggregate statistics across all columns.
Defaults to mean.</p>
<p>Should take <code>pd.Series</code> and return a const.</p>
<p>Has only effect if <code>column</code> was specified or portfolio contains only one column of data.
If <code>agg_func</code> has been overridden by a metric, it only takes effect if global <code>agg_func</code> is not None.</p>
</dd>
<dt><strong><code>silence_warnings</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to silence all warnings.</dd>
<dt><strong><code>template_mapping</code></strong> :&ensp;<code>mapping</code></dt>
<dd>
<p>Global mapping to replace templates.</p>
<p>Applied on <code><a title="vectorbt.portfolio.base.Portfolio.common_settings" href="#vectorbt.portfolio.base.Portfolio.common_settings">Portfolio.common_settings</a></code>, <code>global_settings</code>, and <code>kwargs</code>.</p>
</dd>
<dt><strong><code>global_settings</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments that override default settings for each metric.
Additionally, passes any argument that has the matching key in the signature of <code>calc_func</code>.
Use <code>glob_pass_{arg}</code> to force or ignore passing an argument.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>
<p>Additional keyword arguments.</p>
<p>Can contain keyword arguments for each metric, specified as <code>{metric_name}_kwargs</code>.
Can also contain keyword arguments that override arguments from <code><a title="vectorbt.portfolio.base.Portfolio.common_settings" href="#vectorbt.portfolio.base.Portfolio.common_settings">Portfolio.common_settings</a></code>.</p>
</dd>
</dl>
<p>For template logic, see <code><a title="vectorbt.utils.template" href="../utils/template.html">vectorbt.utils.template</a></code>.</p>
<p>For defaults, see <code>portfolio.stats</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>This method is very similar to <code><a title="vectorbt.portfolio.base.Portfolio.plot" href="#vectorbt.portfolio.base.Portfolio.plot">Portfolio.plot()</a></code>.</p>
<p>Make sure to resolve and then to re-use as many portfolio artifcats as possible to
utilize built-in caching (even if global caching is disabled).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not cacheable as it depends on global defaults.
But the portfolio artifacts it depends on are cacheable.</p>
</div>
<h2 id="example">Example</h2>
<p>Let's simulate a portfolio with two columns:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; close = vbt.YFData.download(
...     &quot;BTC-USD&quot;,
...     start='2020-01-01 UTC',
...     end='2020-09-01 UTC'
... ).get('Close')

&gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(close, n=[10, 20], seed=42)
&gt;&gt;&gt; pf.wrapper.columns
Int64Index([10, 20], dtype='int64', name='rand_n')
</code></pre>
<p>To return the statistics for a particular column/group, use the <code>column</code> argument:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf.stats(column=10)
UserWarning: Metrics {'calmar_ratio', 'sharpe_ratio', 'sortino_ratio'} require frequency of index.
Pass it as `freq` or define it globally under `settings.array_wrapper`.

Start                    2020-01-01 00:00:00+00:00
End                      2020-09-01 00:00:00+00:00
Duration                                       244
Initial Cash                                   100
Total Profit                               6.72158
Total Return [%]                           6.72158
Benchmark Return [%]                       66.2526
Position Coverage [%]                      51.2295
Max Drawdown [%]                           22.1909
Avg Drawdown [%]                           5.86559
Max Drawdown Duration                          101
Avg Drawdown Duration                       26.125
Trade Count                                     10
Win Rate [%]                                    60
Best Trade [%]                             15.3196
Worst Trade [%]                           -9.90422
Avg Trade [%]                             0.862693
Max Trade Duration                              23
Avg Trade Duration                            12.5
Expectancy                                0.672158
SQN                                       0.324787
Gross Exposure                            0.512295
Name: 10, dtype: object
</code></pre>
<p>If vectorbt couldn't parse the frequency of our <code>close</code>, it 1) won't return duration in
time units and 2) won't return metrics that require annualization. We can provide the frequency
manually either upon portfolio simulation or here:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf.stats(column=10, freq='d')
Start                    2020-01-01 00:00:00+00:00
End                      2020-09-01 00:00:00+00:00
Duration                         244 days 00:00:00
Initial Cash                                   100
Total Profit                               6.72158
Total Return [%]                           6.72158
Benchmark Return [%]                       66.2526
Position Coverage [%]                      51.2295
Max Drawdown [%]                           22.1909
Avg Drawdown [%]                           5.86559
Max Drawdown Duration            101 days 00:00:00
Avg Drawdown Duration             26 days 03:00:00
Trade Count                                     10
Win Rate [%]                                    60
Best Trade [%]                             15.3196
Worst Trade [%]                           -9.90422
Avg Trade [%]                             0.862693
Max Trade Duration                23 days 00:00:00
Avg Trade Duration                12 days 12:00:00
Expectancy                                0.672158
SQN                                       0.324787
Gross Exposure                            0.512295
Sharpe Ratio                              0.369947
Sortino Ratio                             0.587442
Calmar Ratio                              0.313166
Name: 10, dtype: object
</code></pre>
<p>We can change the grouping of the portfolio on the fly. Let's form a single group:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf.stats(group_by=True, freq='d')
Start                     2020-01-01 00:00:00+00:00
End                       2020-09-01 00:00:00+00:00
Duration                          244 days 00:00:00
Initial Cash                                    200
Total Profit                                 77.493
Total Return [%]                            38.7465
Benchmark Return [%]                        66.2526
Position Coverage [%]                       48.9754
Max Drawdown [%]                            14.2193
Avg Drawdown [%]                            5.34082
Max Drawdown Duration              86 days 00:00:00
Avg Drawdown Duration    16 days 14:46:09.230769231
Trade Count                                      30
Win Rate [%]                                66.6667
Best Trade [%]                              18.3326
Worst Trade [%]                            -9.90422
Avg Trade [%]                               2.26356
Max Trade Duration                 23 days 00:00:00
Avg Trade Duration                  7 days 23:12:00
Expectancy                                   2.5831
SQN                                         1.70984
Gross Exposure                             0.488308
Sharpe Ratio                                1.31206
Sortino Ratio                               2.15761
Calmar Ratio                                2.83025
Name: group, dtype: object
</code></pre>
<p>We can see how the initial cash has changed from $100 to $200, indicating that both columns
contribute to the performance.</p>
<p>If the portfolio consists of multiple columns/groups and no column/group has been selected,
each metric is aggregated across all columns/groups based on <code>agg_func</code>, which is mean by default.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf.stats(freq='d')
Taking mean across columns. To return a DataFrame, pass agg_func=None.

Start                    2020-01-01 00:00:00+00:00
End                      2020-09-01 00:00:00+00:00
Duration                         244 days 00:00:00
Initial Cash                                   100
Total Profit                               38.7465
Total Return [%]                           38.7465
Benchmark Return [%]                       66.2526
Position Coverage [%]                      48.9754
Max Drawdown [%]                           20.3587
Avg Drawdown [%]                           6.85197
Max Drawdown Duration             93 days 00:00:00
Avg Drawdown Duration             24 days 01:30:00
Trade Count                                     15
Win Rate [%]                                    65
Best Trade [%]                             16.8261
Worst Trade [%]                           -9.70127
Avg Trade [%]                              1.91334
Max Trade Duration                21 days 12:00:00
Avg Trade Duration                 9 days 02:24:00
Expectancy                                 2.10536
SQN                                        1.03975
Gross Exposure                            0.489754
Sharpe Ratio                              0.968587
Sortino Ratio                              1.73209
Calmar Ratio                               2.14818
Name: stats_mean, dtype: object
</code></pre>
<p>Here, the Calmar ratio of 0.313166 (column=10) and 3.98318 (column=20) lead to the avarage of 2.14818.</p>
<p>We can also return a DataFrame with statistics per column/group by passing <code>agg_func=None</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf.stats(agg_func=None, freq='d')
                           Start                       End Duration  ...  Calmar Ratio
rand_n                                                               ...
10     2020-01-01 00:00:00+00:00 2020-09-01 00:00:00+00:00 244 days  ...      0.313166
20     2020-01-01 00:00:00+00:00 2020-09-01 00:00:00+00:00 244 days  ...      3.983185

[2 rows x 25 columns]
</code></pre>
<p>To select metrics, use the <code>metrics</code> argument (see <code><a title="vectorbt.portfolio.base.Portfolio.metrics" href="#vectorbt.portfolio.base.Portfolio.metrics">Portfolio.metrics</a></code> for supported metrics):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf.stats(metrics=['sharpe_ratio', 'sortino_ratio'], column=10, freq='d')
Sharpe Ratio     0.369947
Sortino Ratio    0.587442
Name: stats, dtype: float64
</code></pre>
<p>To calculate a custom metric, we need to provide at least two things: short name and a settings
dict with the title and calculation function (see arguments):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; profit_factor = (
...     'profit_factor',
...     dict(
...         title='Profit Factor',
...         calc_func=lambda trades: trades.profit_factor()
...     )
... )
&gt;&gt;&gt; pf.stats(metrics=profit_factor, column=10, freq='d')
Profit Factor    1.347457
Name: stats, dtype: float64
</code></pre>
<p>Since <code>profit_factor</code> method can be expressed as a path from this portfolio, we can simply write:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; profit_factor = (
...     'profit_factor',
...     dict(
...         title='Profit Factor',
...         calc_func='trades.profit_factor'
...     )
... )
</code></pre>
<p>In both cases, <code>trades</code> argument is an attribute of this portfolio and vectorbt automatically "resolves" it
by passing any reserved argument that was found in its signature, such as <code>group_by</code>.
If we want to stop <code>trades</code> (or any other attribute) from being resolved, just pass <code>resolve_trades=False</code>.
In this case, vectorbt would simply call <code>portfolio.get_trades()</code> and give it to us.</p>
<p>Any default metric setting or even global setting can be overridden by the user using metric-specific
keyword arguments. Here, we override the global aggregation function for <code>max_trade_duration</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf.stats(freq='d', agg_func=lambda sr: sr.mean(),
...     max_trade_duration_kwargs=dict(agg_func=lambda sr: sr.max()))
</code></pre>
<p>Let's create a simple metric that returns frequency to demonstrate how vectorbt overrides settings,
from least to most important:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # common_defaults
&gt;&gt;&gt; freq_metric = ('freq_metric', dict(title='Freq', calc_func=lambda freq: freq))
&gt;&gt;&gt; pf.stats(freq_metric, column=10)
Freq    None
Name: 10, dtype: object

&gt;&gt;&gt; # kwargs with keys from common_defaults &gt;&gt;&gt; common_defaults
&gt;&gt;&gt; pf.stats(freq_metric, column=10, freq='1m')
Freq   0 days 00:01:00
Name: 10, dtype: timedelta64[ns]

&gt;&gt;&gt; # metric settings &gt;&gt;&gt; kwargs with keys from common_defaults
&gt;&gt;&gt; def_freq_metric = ('freq_metric', dict(title='Freq', freq='2m', calc_func=lambda freq: freq))
&gt;&gt;&gt; pf.stats(def_freq_metric, column=10, freq='1m')
Freq   0 days 00:02:00
Name: 10, dtype: timedelta64[ns]

&gt;&gt;&gt; # global_settings &gt;&gt;&gt; metric settings
&gt;&gt;&gt; pf.stats(def_freq_metric, column=10, freq='1m',
...     global_settings=dict(freq='3m'))
Freq   0 days 00:03:00
Name: 10, dtype: timedelta64[ns]

&gt;&gt;&gt; # metric kwargs &gt;&gt;&gt; global_settings
&gt;&gt;&gt; pf.stats(def_freq_metric, column=10, freq='1m',
...     global_settings=dict(freq='3m'), freq_metric_kwargs=dict(freq='4m'))
Freq   0 days 00:04:00
Name: 10, dtype: timedelta64[ns]
</code></pre>
<p>Here's an example of a parametrized metric. Let's get the number of trades with P&amp;L over some amount:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; trade_min_pnl_cnt = (
...     'trade_min_pnl_cnt',
...     dict(
...         title=vbt.Sub('Trades with P&amp;L over $$${min_pnl}'),
...         calc_func=lambda trades, min_pnl: trades.filter_by_mask(
...             trades.pnl.values &gt;= min_pnl).count()
...     )
... )
&gt;&gt;&gt; pf.stats(
...     metrics=trade_min_pnl_cnt, column=10, freq='d',
...     trade_min_pnl_cnt_kwargs=dict(min_pnl=0))
Trades with P&amp;L over $0    6
Name: stats, dtype: int64

&gt;&gt;&gt; pf.stats(
...     metrics=trade_min_pnl_cnt, column=10, freq='d',
...     trade_min_pnl_cnt_kwargs=dict(min_pnl=10))
Trades with P&amp;L over $10    1
Name: stats, dtype: int64
</code></pre>
<p>If the same metric name was encountered more than once, vectorbt automatically appends an
underscore and its position, so we can pass keyword arguments to each metric separately:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf.stats(
...     metrics=[
...         trade_min_pnl_cnt,
...         trade_min_pnl_cnt,
...         trade_min_pnl_cnt
...     ],
...     column=10, freq='d',
...     trade_min_pnl_cnt_0_kwargs=dict(min_pnl=0),
...     trade_min_pnl_cnt_1_kwargs=dict(min_pnl=10),
...     trade_min_pnl_cnt_2_kwargs=dict(min_pnl=20))
Trades with P&amp;L over $0     6
Trades with P&amp;L over $10    1
Trades with P&amp;L over $20    0
Name: stats, dtype: int64
</code></pre>
<p>To add a custom metric to the list of all metrics, we have three options.
First, we can change the <code><a title="vectorbt.portfolio.base.Portfolio.metrics" href="#vectorbt.portfolio.base.Portfolio.metrics">Portfolio.metrics</a></code> dict in-place (this will append to the end):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf.metrics['profit_factor'] = profit_factor[1]
&gt;&gt;&gt; pf.stats(column=10, freq='d')
Start                    2020-01-01 00:00:00+00:00
End                      2020-09-01 00:00:00+00:00
Duration                         244 days 00:00:00
Initial Cash                                   100
Total Profit                               6.72158
Total Return [%]                           6.72158
Benchmark Return [%]                       66.2526
Position Coverage [%]                      51.2295
Max Drawdown [%]                           22.1909
Avg Drawdown [%]                           5.86559
Max Drawdown Duration            101 days 00:00:00
Avg Drawdown Duration             26 days 03:00:00
Trade Count                                     10
Win Rate [%]                                    60
Best Trade [%]                             15.3196
Worst Trade [%]                           -9.90422
Avg Trade [%]                             0.862693
Max Trade Duration                23 days 00:00:00
Avg Trade Duration                12 days 12:00:00
Expectancy                                0.672158
SQN                                       0.324787
Gross Exposure                            0.512295
Sharpe Ratio                              0.369947
Sortino Ratio                             0.587442
Calmar Ratio                              0.313166
Profit Factor                              1.34746   &lt;&lt; here
Name: stats, dtype: object
</code></pre>
<p>Since <code><a title="vectorbt.portfolio.base.Portfolio.metrics" href="#vectorbt.portfolio.base.Portfolio.metrics">Portfolio.metrics</a></code> is of type <code><a title="vectorbt.utils.config.Config" href="../utils/config.html#vectorbt.utils.config.Config">Config</a></code>, we can reset it at any time
to get default metrics:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pf.metrics.reset()
</code></pre>
<p>The second option is to copy <code><a title="vectorbt.portfolio.base.Portfolio.metrics" href="#vectorbt.portfolio.base.Portfolio.metrics">Portfolio.metrics</a></code>, append our metric, and pass as <code>metrics</code> argument:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; my_metrics = list(pf.metrics.items()) + [profit_factor]
&gt;&gt;&gt; pf.stats(metrics=my_metrics, column=10, freq='d')
</code></pre>
<p>The last option is to set <code>metrics</code> globally under <code>portfolio.stats</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vbt.settings['portfolio']['stats']['metrics'] = my_metrics
&gt;&gt;&gt; pf.stats(column=10, freq='d')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stats(self,
          metrics: tp.Optional[tp.MaybeIterable[tp.Union[str, tp.Tuple[str, tp.Kwargs]]]] = None,
          column: tp.Optional[tp.Label] = None,
          group_by: tp.GroupByLike = None,
          agg_func: tp.Optional[tp.Callable] = np.mean,
          silence_warnings: tp.Optional[bool] = None,
          template_mapping: tp.Optional[tp.Mapping] = None,
          global_settings: tp.DictLike = None,
          **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Compute various metrics on this portfolio.

    Args:
        metrics (str, tuple, iterable, or dict): List of metrics to calculate.

            Each element can be either:

            * a metric name (see keys in `Portfolio.metrics`)
            * a tuple of a metric name and a settings dict as in `Portfolio.metrics`.

            Each settings dict can contain the following keys:

            * `title`: title of the metric. Defaults to the name.
            * `allow_grouped`: whether this metric supports using grouped data. Defaults to True.
                Must be known beforehand and cannot be provided as a template.
            * `req_freq`: whether this metric requires frequency. Defaults to False.
                Must be known beforehand and cannot be provided as a template.
            * `calc_func`: calculation function for custom metrics. If the function can be accessed
                by traversing attributes of this portfolio, you can pass the path to this function
                as a string (see `vectorbt.utils.attr.deep_getattr` for the path format).
                Should return either a scalar for one column/group or pd.Series for multiple columns/groups.
            * `pass_{arg}`: whether to pass a reserved argument (see below). Defaults to True if
                this argument was found in the function&#39;s signature. Set to False to not pass.
            * `glob_pass_{arg}`: whether to pass an argument from `global_settings`. Defaults to True if
                this argument was found both in `global_settings` and the function&#39;s signature.
                Set to False to not pass.
            * `resolve_{arg}`: whether to resolve an argument that is meant to be an attribute of
                the portfolio (see `Portfolio.resolve_attr`). Defaults to True if this argument was found
                in the function&#39;s signature. Set to False to not resolve.
            * `template_mapping`: mapping to replace templates in metric settings and keyword arguments.
                Used across all settings.
            * Any other keyword argument overrides reserved arguments or is passed directly to `calc_func`.

            A calculation function may accept any keyword argument. It may &#34;request&#34; any of the
            following reserved arguments by accepting them or if `pass_{arg}` was found in the settings dict:

            * `pf` or `portfolio`: original portfolio (ungrouped and with no column selected)
            * `column`
            * `group_by`
            * `metric_name`
            * `agg_func`
            * Any argument from `Portfolio.common_settings`
            * Any attribute of the portfolio if it meant to be resolved (see `Portfolio.resolve_attr`)

            Pass `metrics=&#39;all&#39;` to calculate all supported metrics.
        column (str): Name of the column/group.

            !!! hint
                There are two ways to select a column: `pf[&#39;a&#39;].stats()` and `pf.stats(column=&#39;a&#39;)`.
                They both accomplish the same thing but in different ways: `pf[&#39;a&#39;].stats()` computes
                statistics of the column &#39;a&#39; only, while `pf.stats(column=&#39;a&#39;)` computes statistics of
                all columns first and only then selects the column &#39;a&#39;. The first method is preferred
                when you have a lot of data or caching is disabled. The second method is preferred when
                most attributes have already been cached.
        group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        agg_func (callable): Aggregation function to aggregate statistics across all columns.
            Defaults to mean.

            Should take `pd.Series` and return a const.

            Has only effect if `column` was specified or portfolio contains only one column of data.
            If `agg_func` has been overridden by a metric, it only takes effect if global `agg_func` is not None.
        silence_warnings (bool): Whether to silence all warnings.
        template_mapping (mapping): Global mapping to replace templates.

            Applied on `Portfolio.common_settings`, `global_settings`, and `kwargs`.
        global_settings (dict): Keyword arguments that override default settings for each metric.
            Additionally, passes any argument that has the matching key in the signature of `calc_func`.
            Use `glob_pass_{arg}` to force or ignore passing an argument.
        **kwargs: Additional keyword arguments.

            Can contain keyword arguments for each metric, specified as `{metric_name}_kwargs`.
            Can also contain keyword arguments that override arguments from `Portfolio.common_settings`.

    For template logic, see `vectorbt.utils.template`.

    For defaults, see `portfolio.stats` in `vectorbt._settings.settings`.

    !!! hint
        This method is very similar to `Portfolio.plot`.

        Make sure to resolve and then to re-use as many portfolio artifcats as possible to
        utilize built-in caching (even if global caching is disabled).

    !!! note
        This method is not cacheable as it depends on global defaults.
        But the portfolio artifacts it depends on are cacheable.

    ## Example

    Let&#39;s simulate a portfolio with two columns:

    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; close = vbt.YFData.download(
    ...     &#34;BTC-USD&#34;,
    ...     start=&#39;2020-01-01 UTC&#39;,
    ...     end=&#39;2020-09-01 UTC&#39;
    ... ).get(&#39;Close&#39;)

    &gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(close, n=[10, 20], seed=42)
    &gt;&gt;&gt; pf.wrapper.columns
    Int64Index([10, 20], dtype=&#39;int64&#39;, name=&#39;rand_n&#39;)
    ```

    To return the statistics for a particular column/group, use the `column` argument:

    ```python-repl
    &gt;&gt;&gt; pf.stats(column=10)
    UserWarning: Metrics {&#39;calmar_ratio&#39;, &#39;sharpe_ratio&#39;, &#39;sortino_ratio&#39;} require frequency of index.
    Pass it as `freq` or define it globally under `settings.array_wrapper`.

    Start                    2020-01-01 00:00:00+00:00
    End                      2020-09-01 00:00:00+00:00
    Duration                                       244
    Initial Cash                                   100
    Total Profit                               6.72158
    Total Return [%]                           6.72158
    Benchmark Return [%]                       66.2526
    Position Coverage [%]                      51.2295
    Max Drawdown [%]                           22.1909
    Avg Drawdown [%]                           5.86559
    Max Drawdown Duration                          101
    Avg Drawdown Duration                       26.125
    Trade Count                                     10
    Win Rate [%]                                    60
    Best Trade [%]                             15.3196
    Worst Trade [%]                           -9.90422
    Avg Trade [%]                             0.862693
    Max Trade Duration                              23
    Avg Trade Duration                            12.5
    Expectancy                                0.672158
    SQN                                       0.324787
    Gross Exposure                            0.512295
    Name: 10, dtype: object
    ```

    If vectorbt couldn&#39;t parse the frequency of our `close`, it 1) won&#39;t return duration in
    time units and 2) won&#39;t return metrics that require annualization. We can provide the frequency
    manually either upon portfolio simulation or here:

    ```python-repl
    &gt;&gt;&gt; pf.stats(column=10, freq=&#39;d&#39;)
    Start                    2020-01-01 00:00:00+00:00
    End                      2020-09-01 00:00:00+00:00
    Duration                         244 days 00:00:00
    Initial Cash                                   100
    Total Profit                               6.72158
    Total Return [%]                           6.72158
    Benchmark Return [%]                       66.2526
    Position Coverage [%]                      51.2295
    Max Drawdown [%]                           22.1909
    Avg Drawdown [%]                           5.86559
    Max Drawdown Duration            101 days 00:00:00
    Avg Drawdown Duration             26 days 03:00:00
    Trade Count                                     10
    Win Rate [%]                                    60
    Best Trade [%]                             15.3196
    Worst Trade [%]                           -9.90422
    Avg Trade [%]                             0.862693
    Max Trade Duration                23 days 00:00:00
    Avg Trade Duration                12 days 12:00:00
    Expectancy                                0.672158
    SQN                                       0.324787
    Gross Exposure                            0.512295
    Sharpe Ratio                              0.369947
    Sortino Ratio                             0.587442
    Calmar Ratio                              0.313166
    Name: 10, dtype: object
    ```

    We can change the grouping of the portfolio on the fly. Let&#39;s form a single group:

    ```python-repl
    &gt;&gt;&gt; pf.stats(group_by=True, freq=&#39;d&#39;)
    Start                     2020-01-01 00:00:00+00:00
    End                       2020-09-01 00:00:00+00:00
    Duration                          244 days 00:00:00
    Initial Cash                                    200
    Total Profit                                 77.493
    Total Return [%]                            38.7465
    Benchmark Return [%]                        66.2526
    Position Coverage [%]                       48.9754
    Max Drawdown [%]                            14.2193
    Avg Drawdown [%]                            5.34082
    Max Drawdown Duration              86 days 00:00:00
    Avg Drawdown Duration    16 days 14:46:09.230769231
    Trade Count                                      30
    Win Rate [%]                                66.6667
    Best Trade [%]                              18.3326
    Worst Trade [%]                            -9.90422
    Avg Trade [%]                               2.26356
    Max Trade Duration                 23 days 00:00:00
    Avg Trade Duration                  7 days 23:12:00
    Expectancy                                   2.5831
    SQN                                         1.70984
    Gross Exposure                             0.488308
    Sharpe Ratio                                1.31206
    Sortino Ratio                               2.15761
    Calmar Ratio                                2.83025
    Name: group, dtype: object
    ```

    We can see how the initial cash has changed from $100 to $200, indicating that both columns
    contribute to the performance.

    If the portfolio consists of multiple columns/groups and no column/group has been selected,
    each metric is aggregated across all columns/groups based on `agg_func`, which is mean by default.

    ```python-repl
    &gt;&gt;&gt; pf.stats(freq=&#39;d&#39;)
    Taking mean across columns. To return a DataFrame, pass agg_func=None.

    Start                    2020-01-01 00:00:00+00:00
    End                      2020-09-01 00:00:00+00:00
    Duration                         244 days 00:00:00
    Initial Cash                                   100
    Total Profit                               38.7465
    Total Return [%]                           38.7465
    Benchmark Return [%]                       66.2526
    Position Coverage [%]                      48.9754
    Max Drawdown [%]                           20.3587
    Avg Drawdown [%]                           6.85197
    Max Drawdown Duration             93 days 00:00:00
    Avg Drawdown Duration             24 days 01:30:00
    Trade Count                                     15
    Win Rate [%]                                    65
    Best Trade [%]                             16.8261
    Worst Trade [%]                           -9.70127
    Avg Trade [%]                              1.91334
    Max Trade Duration                21 days 12:00:00
    Avg Trade Duration                 9 days 02:24:00
    Expectancy                                 2.10536
    SQN                                        1.03975
    Gross Exposure                            0.489754
    Sharpe Ratio                              0.968587
    Sortino Ratio                              1.73209
    Calmar Ratio                               2.14818
    Name: stats_mean, dtype: object
    ```

    Here, the Calmar ratio of 0.313166 (column=10) and 3.98318 (column=20) lead to the avarage of 2.14818.

    We can also return a DataFrame with statistics per column/group by passing `agg_func=None`:

    ```python-repl
    &gt;&gt;&gt; pf.stats(agg_func=None, freq=&#39;d&#39;)
                               Start                       End Duration  ...  Calmar Ratio
    rand_n                                                               ...
    10     2020-01-01 00:00:00+00:00 2020-09-01 00:00:00+00:00 244 days  ...      0.313166
    20     2020-01-01 00:00:00+00:00 2020-09-01 00:00:00+00:00 244 days  ...      3.983185

    [2 rows x 25 columns]
    ```

    To select metrics, use the `metrics` argument (see `Portfolio.metrics` for supported metrics):

    ```python-repl
    &gt;&gt;&gt; pf.stats(metrics=[&#39;sharpe_ratio&#39;, &#39;sortino_ratio&#39;], column=10, freq=&#39;d&#39;)
    Sharpe Ratio     0.369947
    Sortino Ratio    0.587442
    Name: stats, dtype: float64
    ```

    To calculate a custom metric, we need to provide at least two things: short name and a settings
    dict with the title and calculation function (see arguments):

    ```python-repl
    &gt;&gt;&gt; profit_factor = (
    ...     &#39;profit_factor&#39;,
    ...     dict(
    ...         title=&#39;Profit Factor&#39;,
    ...         calc_func=lambda trades: trades.profit_factor()
    ...     )
    ... )
    &gt;&gt;&gt; pf.stats(metrics=profit_factor, column=10, freq=&#39;d&#39;)
    Profit Factor    1.347457
    Name: stats, dtype: float64
    ```

    Since `profit_factor` method can be expressed as a path from this portfolio, we can simply write:

    ```python-repl
    &gt;&gt;&gt; profit_factor = (
    ...     &#39;profit_factor&#39;,
    ...     dict(
    ...         title=&#39;Profit Factor&#39;,
    ...         calc_func=&#39;trades.profit_factor&#39;
    ...     )
    ... )
    ```

    In both cases, `trades` argument is an attribute of this portfolio and vectorbt automatically &#34;resolves&#34; it
    by passing any reserved argument that was found in its signature, such as `group_by`.
    If we want to stop `trades` (or any other attribute) from being resolved, just pass `resolve_trades=False`.
    In this case, vectorbt would simply call `portfolio.get_trades()` and give it to us.

    Any default metric setting or even global setting can be overridden by the user using metric-specific
    keyword arguments. Here, we override the global aggregation function for `max_trade_duration`:

    ```python-repl
    &gt;&gt;&gt; pf.stats(freq=&#39;d&#39;, agg_func=lambda sr: sr.mean(),
    ...     max_trade_duration_kwargs=dict(agg_func=lambda sr: sr.max()))
    ```

    Let&#39;s create a simple metric that returns frequency to demonstrate how vectorbt overrides settings,
    from least to most important:

    ```python-repl
    &gt;&gt;&gt; # common_defaults
    &gt;&gt;&gt; freq_metric = (&#39;freq_metric&#39;, dict(title=&#39;Freq&#39;, calc_func=lambda freq: freq))
    &gt;&gt;&gt; pf.stats(freq_metric, column=10)
    Freq    None
    Name: 10, dtype: object

    &gt;&gt;&gt; # kwargs with keys from common_defaults &gt;&gt;&gt; common_defaults
    &gt;&gt;&gt; pf.stats(freq_metric, column=10, freq=&#39;1m&#39;)
    Freq   0 days 00:01:00
    Name: 10, dtype: timedelta64[ns]

    &gt;&gt;&gt; # metric settings &gt;&gt;&gt; kwargs with keys from common_defaults
    &gt;&gt;&gt; def_freq_metric = (&#39;freq_metric&#39;, dict(title=&#39;Freq&#39;, freq=&#39;2m&#39;, calc_func=lambda freq: freq))
    &gt;&gt;&gt; pf.stats(def_freq_metric, column=10, freq=&#39;1m&#39;)
    Freq   0 days 00:02:00
    Name: 10, dtype: timedelta64[ns]

    &gt;&gt;&gt; # global_settings &gt;&gt;&gt; metric settings
    &gt;&gt;&gt; pf.stats(def_freq_metric, column=10, freq=&#39;1m&#39;,
    ...     global_settings=dict(freq=&#39;3m&#39;))
    Freq   0 days 00:03:00
    Name: 10, dtype: timedelta64[ns]

    &gt;&gt;&gt; # metric kwargs &gt;&gt;&gt; global_settings
    &gt;&gt;&gt; pf.stats(def_freq_metric, column=10, freq=&#39;1m&#39;,
    ...     global_settings=dict(freq=&#39;3m&#39;), freq_metric_kwargs=dict(freq=&#39;4m&#39;))
    Freq   0 days 00:04:00
    Name: 10, dtype: timedelta64[ns]
    ```

    Here&#39;s an example of a parametrized metric. Let&#39;s get the number of trades with P&amp;L over some amount:

    ```python-repl
    &gt;&gt;&gt; trade_min_pnl_cnt = (
    ...     &#39;trade_min_pnl_cnt&#39;,
    ...     dict(
    ...         title=vbt.Sub(&#39;Trades with P&amp;L over $$${min_pnl}&#39;),
    ...         calc_func=lambda trades, min_pnl: trades.filter_by_mask(
    ...             trades.pnl.values &gt;= min_pnl).count()
    ...     )
    ... )
    &gt;&gt;&gt; pf.stats(
    ...     metrics=trade_min_pnl_cnt, column=10, freq=&#39;d&#39;,
    ...     trade_min_pnl_cnt_kwargs=dict(min_pnl=0))
    Trades with P&amp;L over $0    6
    Name: stats, dtype: int64

    &gt;&gt;&gt; pf.stats(
    ...     metrics=trade_min_pnl_cnt, column=10, freq=&#39;d&#39;,
    ...     trade_min_pnl_cnt_kwargs=dict(min_pnl=10))
    Trades with P&amp;L over $10    1
    Name: stats, dtype: int64
    ```

    If the same metric name was encountered more than once, vectorbt automatically appends an
    underscore and its position, so we can pass keyword arguments to each metric separately:

    ```python-repl
    &gt;&gt;&gt; pf.stats(
    ...     metrics=[
    ...         trade_min_pnl_cnt,
    ...         trade_min_pnl_cnt,
    ...         trade_min_pnl_cnt
    ...     ],
    ...     column=10, freq=&#39;d&#39;,
    ...     trade_min_pnl_cnt_0_kwargs=dict(min_pnl=0),
    ...     trade_min_pnl_cnt_1_kwargs=dict(min_pnl=10),
    ...     trade_min_pnl_cnt_2_kwargs=dict(min_pnl=20))
    Trades with P&amp;L over $0     6
    Trades with P&amp;L over $10    1
    Trades with P&amp;L over $20    0
    Name: stats, dtype: int64
    ```

    To add a custom metric to the list of all metrics, we have three options.
    First, we can change the `Portfolio.metrics` dict in-place (this will append to the end):

    ```python-repl
    &gt;&gt;&gt; pf.metrics[&#39;profit_factor&#39;] = profit_factor[1]
    &gt;&gt;&gt; pf.stats(column=10, freq=&#39;d&#39;)
    Start                    2020-01-01 00:00:00+00:00
    End                      2020-09-01 00:00:00+00:00
    Duration                         244 days 00:00:00
    Initial Cash                                   100
    Total Profit                               6.72158
    Total Return [%]                           6.72158
    Benchmark Return [%]                       66.2526
    Position Coverage [%]                      51.2295
    Max Drawdown [%]                           22.1909
    Avg Drawdown [%]                           5.86559
    Max Drawdown Duration            101 days 00:00:00
    Avg Drawdown Duration             26 days 03:00:00
    Trade Count                                     10
    Win Rate [%]                                    60
    Best Trade [%]                             15.3196
    Worst Trade [%]                           -9.90422
    Avg Trade [%]                             0.862693
    Max Trade Duration                23 days 00:00:00
    Avg Trade Duration                12 days 12:00:00
    Expectancy                                0.672158
    SQN                                       0.324787
    Gross Exposure                            0.512295
    Sharpe Ratio                              0.369947
    Sortino Ratio                             0.587442
    Calmar Ratio                              0.313166
    Profit Factor                              1.34746   &lt;&lt; here
    Name: stats, dtype: object
    ```

    Since `Portfolio.metrics` is of type `vectorbt.utils.config.Config`, we can reset it at any time
    to get default metrics:

    ```python-repl
    &gt;&gt;&gt; pf.metrics.reset()
    ```

    The second option is to copy `Portfolio.metrics`, append our metric, and pass as `metrics` argument:

    ```python-repl
    &gt;&gt;&gt; my_metrics = list(pf.metrics.items()) + [profit_factor]
    &gt;&gt;&gt; pf.stats(metrics=my_metrics, column=10, freq=&#39;d&#39;)
    ```

    The last option is to set `metrics` globally under `portfolio.stats` in `vectorbt._settings.settings`.

    &gt;&gt;&gt; vbt.settings[&#39;portfolio&#39;][&#39;stats&#39;][&#39;metrics&#39;] = my_metrics
    &gt;&gt;&gt; pf.stats(column=10, freq=&#39;d&#39;)
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    portfolio_stats_cfg = settings[&#39;portfolio&#39;][&#39;stats&#39;]

    # Resolve defaults
    common_settings = self.common_settings
    for k in list(kwargs.keys()):
        if k in common_settings:
            common_settings[k] = kwargs.pop(k)
    if silence_warnings is None:
        silence_warnings = portfolio_stats_cfg[&#39;silence_warnings&#39;]
    template_mapping = merge_dicts(portfolio_stats_cfg[&#39;template_mapping&#39;], template_mapping)
    global_settings = merge_dicts(portfolio_stats_cfg[&#39;global_settings&#39;], global_settings)
    kwargs = merge_dicts(portfolio_stats_cfg[&#39;kwargs&#39;], kwargs)

    # Check if grouped
    is_grouped = self.wrapper.grouper.is_grouped(group_by=group_by)

    # Check if frequency is set
    has_freq = common_settings[&#39;freq&#39;] is not None

    # Replace templates globally
    if len(template_mapping) &gt; 0:
        common_settings = deep_substitute(common_settings, mapping=template_mapping)
        global_settings = deep_substitute(global_settings, mapping=template_mapping)
        kwargs = deep_substitute(kwargs, mapping=template_mapping)

    # Prepare metrics
    if metrics is None:
        metrics = portfolio_stats_cfg[&#39;metrics&#39;]
    if metrics == &#39;all&#39;:
        metrics = self.metrics
    if isinstance(metrics, dict):
        metrics = list(metrics.items())
    if isinstance(metrics, (str, tuple)):
        metrics = [metrics]
    # Bring to the same shape
    new_metrics = []
    for i, metric in enumerate(metrics):
        if isinstance(metric, str):
            metric = (metric, self.metrics[metric])
        if not isinstance(metric, tuple):
            raise TypeError(f&#34;Metric at index {i} must be either a string or a tuple&#34;)
        new_metrics.append(metric)
    metrics = new_metrics
    # Handle duplicate names
    metric_counts = Counter(list(map(lambda x: x[0], metrics)))
    metric_i = {k: -1 for k in metric_counts.keys()}
    metrics_dct = {}
    for i, (metric_name, metric_settings) in enumerate(metrics):
        if metric_counts[metric_name] &gt; 1:
            metric_i[metric_name] += 1
            metric_name = metric_name + &#39;_&#39; + str(metric_i[metric_name])
        metrics_dct[metric_name] = metric_settings
    # Merge settings
    custom_arg_names_dct = {}
    for metric_name, metric_settings in metrics_dct.items():
        passed_settings = kwargs.pop(f&#39;{metric_name}_kwargs&#39;, {})
        metrics_dct[metric_name] = merge_dicts(
            metric_settings,
            global_settings,
            passed_settings
        )
        custom_arg_names_dct[metric_name] = set(metric_settings.keys()).union(set(passed_settings.keys()))
    # Filter metrics
    if is_grouped:
        left_out_names = []
        for metric_name in list(metrics_dct.keys()):
            if not metrics_dct[metric_name].get(&#39;allow_grouped&#39;, True):
                metrics_dct.pop(metric_name, None)
                custom_arg_names_dct.pop(metric_name, None)
                left_out_names.append(metric_name)
        if len(left_out_names) &gt; 0 and not silence_warnings:
            warnings.warn(f&#34;Metrics {left_out_names} do not support grouped data&#34;, stacklevel=2)
    if not has_freq:
        left_out_names = []
        for metric_name in list(metrics_dct.keys()):
            if metrics_dct[metric_name].get(&#39;req_freq&#39;, False):
                metrics_dct.pop(metric_name, None)
                custom_arg_names_dct.pop(metric_name, None)
                left_out_names.append(metric_name)
        if len(left_out_names) &gt; 0 and not silence_warnings:
            warnings.warn(f&#34;Metrics {left_out_names} require frequency of index. &#34;
                          f&#34;Pass it as `freq` or define it globally under `settings.array_wrapper`.&#34;, stacklevel=2)
    if len(metrics_dct) == 0:
        raise ValueError(&#34;There is no metric to calculate&#34;)

    # Check kwargs
    if len(kwargs) &gt; 0:
        raise ValueError(f&#34;Keys {list(kwargs.keys())} could not be matched&#34;)

    # Run stats
    arg_cache_dct = {}
    stats_dct = {}
    for i, (metric_name, metric_settings) in enumerate(metrics_dct.items()):
        final_settings = metric_settings.copy()
        final_settings.pop(&#39;allow_grouped&#39;, None)
        final_settings.pop(&#39;req_freq&#39;, None)

        # Replace templates
        reserved_settings = merge_dicts(
            dict(
                pf=self,
                portfolio=self,
                column=column,
                group_by=group_by,
                metric_name=metric_name,
                agg_func=agg_func
            ),
            common_settings
        )
        reserved_arg_names = set(reserved_settings.keys())
        final_settings = merge_dicts(reserved_settings, final_settings)
        metric_template_mapping = final_settings.pop(&#39;template_mapping&#39;, {})
        mapping = merge_dicts(final_settings, template_mapping, metric_template_mapping)
        final_settings = deep_substitute(final_settings, mapping=mapping)
        if final_settings[&#39;freq&#39;] is not None:
            final_settings[&#39;freq&#39;] = freq_to_timedelta(final_settings[&#39;freq&#39;])

        # Get and pop values
        _column = final_settings.get(&#39;column&#39;)
        _group_by = final_settings.get(&#39;group_by&#39;)
        _agg_func = final_settings.get(&#39;agg_func&#39;)
        title = final_settings.pop(&#39;title&#39;, metric_name)
        calc_func = final_settings.pop(&#39;calc_func&#39;)

        # Prepare function and keyword arguments
        custom_arg_names = custom_arg_names_dct[metric_name]
        if not callable(calc_func):
            def _getattr_func(obj: tp.Any,
                              attr: str,
                              args: tp.ArgsLike = None,
                              kwargs: tp.KwargsLike = None,
                              call_attr: bool = True,
                              _custom_arg_names: tp.Set[str] = custom_arg_names,
                              _arg_cache_dct: tp.Kwargs = arg_cache_dct,
                              _final_settings: tp.Kwargs = final_settings) -&gt; tp.Any:
                if args is None:
                    args = ()
                if kwargs is None:
                    kwargs = {}
                if obj is self and _final_settings.pop(&#39;resolve_&#39; + attr, True):
                    if call_attr:
                        return self.resolve_attr(
                            attr,
                            args=args,
                            cond_kwargs=_final_settings,
                            kwargs=kwargs,
                            custom_arg_names=_custom_arg_names,
                            cache_dct=_arg_cache_dct
                        )
                    return getattr(obj, attr)
                out = getattr(obj, attr)
                if callable(out) and call_attr:
                    return out(*args, **kwargs)
                return out

            calc_func = self.getattr(calc_func, getattr_func=_getattr_func, call_last_attr=False)
        if not callable(calc_func):
            raise TypeError(&#34;calc_func must be callable&#34;)

        func_arg_names = get_func_arg_names(calc_func)
        for k in func_arg_names:
            if k not in final_settings:
                if final_settings.pop(&#39;resolve_&#39; + k, True):
                    try:
                        arg_out = self.resolve_attr(
                            k,
                            cond_kwargs=final_settings,
                            custom_arg_names=custom_arg_names,
                            cache_dct=arg_cache_dct
                        )
                    except AttributeError:
                        continue
                    final_settings[k] = arg_out

        for k in reserved_arg_names:
            if &#39;pass_&#39; + k in final_settings:
                if not final_settings.pop(&#39;pass_&#39; + k):  # first priority
                    final_settings.pop(k, None)
            elif k not in func_arg_names:  # second priority
                final_settings.pop(k, None)
        for k in list(final_settings.keys()):
            if &#39;glob_pass_&#39; + k in final_settings:
                if k not in global_settings or not final_settings.pop(&#39;glob_pass_&#39; + k, True):
                    final_settings.pop(k, None)  # global setting should not be utilized
            else:
                if k in global_settings and k not in custom_arg_names and k not in func_arg_names:
                    final_settings.pop(k, None)  # global setting not utilized
        for k in list(final_settings.keys()):
            if k.startswith(&#39;glob_pass_&#39;):
                final_settings.pop(k, None)  # cleanup

        # Call calculation function
        out = calc_func(**final_settings)

        # Post-process and store the metric
        if checks.is_any_array(out) and not checks.is_series(out):
            raise TypeError(&#34;calc_func must return either a scalar for one column/group &#34;
                            &#34;or pd.Series for multiple columns/groups&#34;)
        if checks.is_series(out):
            if _column is not None:
                out = self.select_one_from_obj(out, self.wrapper.regroup(_group_by), column=_column)
            elif _agg_func is not None and agg_func is not None:
                out = _agg_func(out)
        stats_dct[title] = out

    # Return the stats
    if self.wrapper.get_ndim(group_by=group_by) == 1:
        return pd.Series(stats_dct, name=self.wrapper.get_columns(group_by=group_by)[0])
    if column is not None:
        return pd.Series(stats_dct, name=column)
    if agg_func is not None:
        return pd.Series(stats_dct, name=&#39;agg_func_&#39; + agg_func.__name__)
    new_index = self.wrapper.grouper.get_columns(group_by=group_by)
    stats_df = pd.DataFrame(stats_dct, index=new_index)
    return stats_df</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.tail_ratio"><code class="name flex">
<span>def <span class="ident">tail_ratio</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.tail_ratio" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.tail_ratio">ReturnsAccessor.tail_ratio()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.total_market_return"><code class="name flex">
<span>def <span class="ident">total_market_return</span></span>(<span>self, group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get total market (benchmark) return.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def total_market_return(self, group_by: tp.GroupByLike = None,
                        wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;Get total market (benchmark) return.&#34;&#34;&#34;
    market_value = to_2d(self.market_value(group_by=group_by), raw=True)
    total_market_return = nb.total_market_return_nb(market_value)
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total_market_return&#39;), wrap_kwargs)
    return self.wrapper.wrap_reduced(total_market_return, group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.total_profit"><code class="name flex">
<span>def <span class="ident">total_profit</span></span>(<span>self, group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get total profit per column/group.</p>
<p>Calculated directly from order records (fast).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def total_profit(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;Get total profit per column/group.

    Calculated directly from order records (fast).&#34;&#34;&#34;
    if self.wrapper.grouper.is_grouped(group_by=group_by):
        total_profit = to_1d(self.total_profit(group_by=False), raw=True)
        group_lens = self.wrapper.grouper.get_group_lens(group_by=group_by)
        total_profit = nb.total_profit_grouped_nb(
            total_profit,
            group_lens
        )
    else:
        if self.fillna_close:
            close = to_2d(self.get_filled_close(), raw=True)
        else:
            close = to_2d(self.close, raw=True)
        total_profit = nb.total_profit_nb(
            self.wrapper.shape_2d,
            close,
            self.orders.values,
            self.orders.col_mapper.col_map
        )
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total_profit&#39;), wrap_kwargs)
    return self.wrapper.wrap_reduced(total_profit, group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.total_return"><code class="name flex">
<span>def <span class="ident">total_return</span></span>(<span>self, group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get total profit per column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def total_return(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;Get total profit per column/group.&#34;&#34;&#34;
    init_cash = to_1d(self.get_init_cash(group_by=group_by), raw=True)
    total_profit = to_1d(self.total_profit(group_by=group_by), raw=True)
    total_return = nb.total_return_nb(total_profit, init_cash)
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total_return&#39;), wrap_kwargs)
    return self.wrapper.wrap_reduced(total_return, group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.up_capture"><code class="name flex">
<span>def <span class="ident">up_capture</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.up_capture" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.up_capture">ReturnsAccessor.up_capture()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.value"><code class="name flex">
<span>def <span class="ident">value</span></span>(<span>self, group_by=None, in_sim_order=False, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get portfolio value series per column/group.</p>
<p>By default, will generate portfolio value for each asset based on cash flows and thus
independent from other assets, with the initial cash balance and position being that of the
entire group. Useful for generating returns and comparing assets within the same group.</p>
<p>When <code>group_by</code> is False and <code>in_sim_order</code> is True, returns value generated in
simulation order (see <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">row-major order</a>.
This value cannot be used for generating returns as-is. Useful to analyze how value
evolved throughout simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def value(self, group_by: tp.GroupByLike = None, in_sim_order: bool = False,
          wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Get portfolio value series per column/group.

    By default, will generate portfolio value for each asset based on cash flows and thus
    independent from other assets, with the initial cash balance and position being that of the
    entire group. Useful for generating returns and comparing assets within the same group.

    When `group_by` is False and `in_sim_order` is True, returns value generated in
    simulation order (see [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
    This value cannot be used for generating returns as-is. Useful to analyze how value
    evolved throughout simulation.&#34;&#34;&#34;
    cash = to_2d(self.cash(group_by=group_by, in_sim_order=in_sim_order), raw=True)
    asset_value = to_2d(self.asset_value(group_by=group_by), raw=True)
    if self.wrapper.grouper.is_grouping_disabled(group_by=group_by) and in_sim_order:
        group_lens = self.wrapper.grouper.get_group_lens()
        call_seq = to_2d(self.call_seq, raw=True)
        value = nb.value_in_sim_order_nb(cash, asset_value, group_lens, call_seq)
        # price of NaN is already addressed by ungrouped_value_nb
    else:
        value = nb.value_nb(cash, asset_value)
    return self.wrapper.wrap(value, group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.portfolio.base.Portfolio.value_at_risk"><code class="name flex">
<span>def <span class="ident">value_at_risk</span></span>(<span>self, *args, group_by=None, freq=None, year_freq=None, use_asset_returns=False, **ret_func_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.returns.accessors.ReturnsAccessor.value_at_risk" href="../returns/accessors.html#vectorbt.returns.accessors.ReturnsAccessor.value_at_risk">ReturnsAccessor.value_at_risk()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returns_method(
        self: &#34;Portfolio&#34;,
        *args,
        group_by: tp.GroupByLike = None,
        freq: tp.Optional[tp.FrequencyLike] = None,
        year_freq: tp.Optional[tp.FrequencyLike] = None,
        _ret_func_name: str = ret_func_name,
        use_asset_returns: bool = False,
        **ret_func_kwargs) -&gt; tp.Any:
    returns_acc = self.returns_acc(
        group_by=group_by,
        freq=freq,
        year_freq=year_freq,
        use_asset_returns=use_asset_returns
    )
    # Select only those arguments in kwargs that are also in the method&#39;s signature
    # This is done for Portfolio.stats which passes the same kwargs to multiple methods
    method = getattr(returns_acc, _ret_func_name)
    arg_names = get_func_arg_names(method)
    new_kwargs = {}
    for arg_name in arg_names:
        if arg_name in ret_func_kwargs:
            new_kwargs[arg_name] = ret_func_kwargs[arg_name]
    return method(*args, **new_kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
<li><code><b><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.utils.config.Configured.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRUYwMDAwO30KCS5zdDF7ZmlsbDojRkY5MDAwO30KCS5zdDJ7ZmlsbDojRkZERjAwO30KCS5zdDN7ZmlsbDojMjgyQzM0O30KPC9zdHlsZT4KPGc+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNTUuMywzMDAuMSAyODMuMSwwIDIwOCwwIDExMC44LDAgMzUuOCwwIDEuMiw0NTAuMiA3Ni4zLDQ1MC4yIAkJCSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjIzMC40LDMwMC4xIDM1OC4xLDAgMjgzLjEsMCAxODUuOCwwIDExMC44LDAgNzYuMyw0NTAuMiAxNTEuMyw0NTAuMiAJCQkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIzMDUuNCwzMDAuMSA0MzMuMSwwIDM1OC4xLDAgMzMxLjYsNjIuMyAyNjAuOCwwIDE4NS44LDAgMTUxLjMsNDUwLjIgMjI2LjQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iNTEwLjgsMCA0MzMuMSwwIDMwNS40LDMwMC4xIDMzOC40LDAgMjYwLjgsMCAyMjYuNCw0NTAuMiAzMDQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="/>
vectorbt <span class="version">0.19.1</span></a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul>
<li><a href="#workflow">Workflow</a><ul>
<li><a href="#example">Example</a></li>
</ul>
</li>
<li><a href="#broadcasting">Broadcasting</a></li>
<li><a href="#grouping">Grouping</a></li>
<li><a href="#indexing">Indexing</a></li>
<li><a href="#logging">Logging</a></li>
<li><a href="#caching">Caching</a></li>
<li><a href="#saving-and-loading">Saving and loading</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.portfolio" href="index.html">vectorbt.portfolio</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.portfolio.base.add_returns_methods" href="#vectorbt.portfolio.base.add_returns_methods">add_returns_methods</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.portfolio.base.Portfolio" href="#vectorbt.portfolio.base.Portfolio">Portfolio</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.portfolio.base.Portfolio.alpha" href="#vectorbt.portfolio.base.Portfolio.alpha">alpha</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.annual_returns" href="#vectorbt.portfolio.base.Portfolio.annual_returns">annual_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.annualized_return" href="#vectorbt.portfolio.base.Portfolio.annualized_return">annualized_return</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.annualized_volatility" href="#vectorbt.portfolio.base.Portfolio.annualized_volatility">annualized_volatility</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.asset_flow" href="#vectorbt.portfolio.base.Portfolio.asset_flow">asset_flow</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.asset_returns" href="#vectorbt.portfolio.base.Portfolio.asset_returns">asset_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.asset_value" href="#vectorbt.portfolio.base.Portfolio.asset_value">asset_value</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.assets" href="#vectorbt.portfolio.base.Portfolio.assets">assets</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.benchmark_rets" href="#vectorbt.portfolio.base.Portfolio.benchmark_rets">benchmark_rets</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.beta" href="#vectorbt.portfolio.base.Portfolio.beta">beta</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.call_seq" href="#vectorbt.portfolio.base.Portfolio.call_seq">call_seq</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.calmar_ratio" href="#vectorbt.portfolio.base.Portfolio.calmar_ratio">calmar_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.capture" href="#vectorbt.portfolio.base.Portfolio.capture">capture</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cash" href="#vectorbt.portfolio.base.Portfolio.cash">cash</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cash_flow" href="#vectorbt.portfolio.base.Portfolio.cash_flow">cash_flow</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cash_sharing" href="#vectorbt.portfolio.base.Portfolio.cash_sharing">cash_sharing</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.close" href="#vectorbt.portfolio.base.Portfolio.close">close</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.common_settings" href="#vectorbt.portfolio.base.Portfolio.common_settings">common_settings</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cond_value_at_risk" href="#vectorbt.portfolio.base.Portfolio.cond_value_at_risk">cond_value_at_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.cumulative_returns" href="#vectorbt.portfolio.base.Portfolio.cumulative_returns">cumulative_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.daily_returns" href="#vectorbt.portfolio.base.Portfolio.daily_returns">daily_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.deflated_sharpe_ratio" href="#vectorbt.portfolio.base.Portfolio.deflated_sharpe_ratio">deflated_sharpe_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.down_capture" href="#vectorbt.portfolio.base.Portfolio.down_capture">down_capture</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.downside_risk" href="#vectorbt.portfolio.base.Portfolio.downside_risk">downside_risk</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.drawdown" href="#vectorbt.portfolio.base.Portfolio.drawdown">drawdown</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.drawdowns" href="#vectorbt.portfolio.base.Portfolio.drawdowns">drawdowns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.fillna_close" href="#vectorbt.portfolio.base.Portfolio.fillna_close">fillna_close</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.final_value" href="#vectorbt.portfolio.base.Portfolio.final_value">final_value</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_holding" href="#vectorbt.portfolio.base.Portfolio.from_holding">from_holding</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_order_func" href="#vectorbt.portfolio.base.Portfolio.from_order_func">from_order_func</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_orders" href="#vectorbt.portfolio.base.Portfolio.from_orders">from_orders</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_random_signals" href="#vectorbt.portfolio.base.Portfolio.from_random_signals">from_random_signals</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="#vectorbt.portfolio.base.Portfolio.from_signals">from_signals</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.get_drawdowns" href="#vectorbt.portfolio.base.Portfolio.get_drawdowns">get_drawdowns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.get_filled_close" href="#vectorbt.portfolio.base.Portfolio.get_filled_close">get_filled_close</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.get_init_cash" href="#vectorbt.portfolio.base.Portfolio.get_init_cash">get_init_cash</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.get_logs" href="#vectorbt.portfolio.base.Portfolio.get_logs">get_logs</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.get_orders" href="#vectorbt.portfolio.base.Portfolio.get_orders">get_orders</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.get_positions" href="#vectorbt.portfolio.base.Portfolio.get_positions">get_positions</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.get_trades" href="#vectorbt.portfolio.base.Portfolio.get_trades">get_trades</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.gross_exposure" href="#vectorbt.portfolio.base.Portfolio.gross_exposure">gross_exposure</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.indexing_func" href="#vectorbt.portfolio.base.Portfolio.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.information_ratio" href="#vectorbt.portfolio.base.Portfolio.information_ratio">information_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.init_cash" href="#vectorbt.portfolio.base.Portfolio.init_cash">init_cash</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.log_records" href="#vectorbt.portfolio.base.Portfolio.log_records">log_records</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.logs" href="#vectorbt.portfolio.base.Portfolio.logs">logs</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.market_returns" href="#vectorbt.portfolio.base.Portfolio.market_returns">market_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.market_value" href="#vectorbt.portfolio.base.Portfolio.market_value">market_value</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.max_drawdown" href="#vectorbt.portfolio.base.Portfolio.max_drawdown">max_drawdown</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.metrics" href="#vectorbt.portfolio.base.Portfolio.metrics">metrics</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.net_exposure" href="#vectorbt.portfolio.base.Portfolio.net_exposure">net_exposure</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.omega_ratio" href="#vectorbt.portfolio.base.Portfolio.omega_ratio">omega_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.order_records" href="#vectorbt.portfolio.base.Portfolio.order_records">order_records</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.orders" href="#vectorbt.portfolio.base.Portfolio.orders">orders</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.plot" href="#vectorbt.portfolio.base.Portfolio.plot">plot</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.plot_asset_flow" href="#vectorbt.portfolio.base.Portfolio.plot_asset_flow">plot_asset_flow</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.plot_asset_value" href="#vectorbt.portfolio.base.Portfolio.plot_asset_value">plot_asset_value</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.plot_assets" href="#vectorbt.portfolio.base.Portfolio.plot_assets">plot_assets</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.plot_cash" href="#vectorbt.portfolio.base.Portfolio.plot_cash">plot_cash</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.plot_cash_flow" href="#vectorbt.portfolio.base.Portfolio.plot_cash_flow">plot_cash_flow</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.plot_cum_returns" href="#vectorbt.portfolio.base.Portfolio.plot_cum_returns">plot_cum_returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.plot_drawdowns" href="#vectorbt.portfolio.base.Portfolio.plot_drawdowns">plot_drawdowns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.plot_gross_exposure" href="#vectorbt.portfolio.base.Portfolio.plot_gross_exposure">plot_gross_exposure</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.plot_net_exposure" href="#vectorbt.portfolio.base.Portfolio.plot_net_exposure">plot_net_exposure</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.plot_underwater" href="#vectorbt.portfolio.base.Portfolio.plot_underwater">plot_underwater</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.plot_value" href="#vectorbt.portfolio.base.Portfolio.plot_value">plot_value</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.position_coverage" href="#vectorbt.portfolio.base.Portfolio.position_coverage">position_coverage</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.position_mask" href="#vectorbt.portfolio.base.Portfolio.position_mask">position_mask</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.positions" href="#vectorbt.portfolio.base.Portfolio.positions">positions</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.regroup" href="#vectorbt.portfolio.base.Portfolio.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.resolve_attr" href="#vectorbt.portfolio.base.Portfolio.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.returns" href="#vectorbt.portfolio.base.Portfolio.returns">returns</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.returns_acc" href="#vectorbt.portfolio.base.Portfolio.returns_acc">returns_acc</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.returns_stats" href="#vectorbt.portfolio.base.Portfolio.returns_stats">returns_stats</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.sharpe_ratio" href="#vectorbt.portfolio.base.Portfolio.sharpe_ratio">sharpe_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.sortino_ratio" href="#vectorbt.portfolio.base.Portfolio.sortino_ratio">sortino_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.stats" href="#vectorbt.portfolio.base.Portfolio.stats">stats</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.subplots" href="#vectorbt.portfolio.base.Portfolio.subplots">subplots</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.tail_ratio" href="#vectorbt.portfolio.base.Portfolio.tail_ratio">tail_ratio</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.total_market_return" href="#vectorbt.portfolio.base.Portfolio.total_market_return">total_market_return</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.total_profit" href="#vectorbt.portfolio.base.Portfolio.total_profit">total_profit</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.total_return" href="#vectorbt.portfolio.base.Portfolio.total_return">total_return</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.trades" href="#vectorbt.portfolio.base.Portfolio.trades">trades</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.up_capture" href="#vectorbt.portfolio.base.Portfolio.up_capture">up_capture</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.value" href="#vectorbt.portfolio.base.Portfolio.value">value</a></code></li>
<li><code><a title="vectorbt.portfolio.base.Portfolio.value_at_risk" href="#vectorbt.portfolio.base.Portfolio.value_at_risk">value_at_risk</a></code></li>
</ul>
</li>
</ul>
</li>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>