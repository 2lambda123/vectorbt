<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.signals.generators API documentation</title>
<meta name="description" content="Signal generators built with `vectorbt.signals.factory.SignalFactory`." />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#e82}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-weight:400;font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:100px;max-height:100px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.signals.generators</code></h1>
</header>
<section id="section-intro">
<p>Signal generators built with <code><a title="vectorbt.signals.factory.SignalFactory" href="factory.html#vectorbt.signals.factory.SignalFactory">SignalFactory</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Signal generators built with `vectorbt.signals.factory.SignalFactory`.&#34;&#34;&#34;

import numpy as np
import plotly.graph_objects as go

from vectorbt import _typing as tp
from vectorbt.utils.config import Config
from vectorbt.utils.figure import make_figure
from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config
from vectorbt.signals.enums import StopType
from vectorbt.signals.factory import SignalFactory
from vectorbt.signals.nb import (
    rand_enex_apply_nb,
    rand_by_prob_choice_nb,
    stop_choice_nb,
    ohlc_stop_choice_nb
)

# ############# Random signals ############# #


RAND = SignalFactory(
    class_name=&#39;RAND&#39;,
    module_name=__name__,
    short_name=&#39;rand&#39;,
    param_names=[&#39;n&#39;]
).from_apply_func(  # apply_func since function is (almost) vectorized
    rand_enex_apply_nb,
    require_input_shape=True,
    param_settings=dict(
        n=flex_col_param_config
    ),
    kwargs_to_args=[&#39;entry_wait&#39;, &#39;exit_wait&#39;],
    entry_wait=1,
    exit_wait=1,
    seed=None
)


class _RAND(RAND):
    &#34;&#34;&#34;Random entry and exit signal generator based on the number of signals.

    Generates `entries` and `exits` based on `vectorbt.signals.nb.rand_enex_apply_nb`.

    !!! hint
        Parameter `n` can be either a single value (per frame) or a NumPy array (per column).
        To generate multiple combinations, pass it as a list.

    ## Example

    Test three different `n` values:
    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; rand = vbt.RAND.run(
    ...     input_shape=(6,),
    ...     n=[1, 2, 3],
    ...     seed=42)

    &gt;&gt;&gt; rand.entries
    rand_n      1      2      3
    0        True   True   True
    1       False  False  False
    2       False   True   True
    3       False  False  False
    4       False  False   True
    5       False  False  False

    &gt;&gt;&gt; rand.exits
    rand_n      1      2      3
    0       False  False  False
    1        True   True   True
    2       False  False  False
    3       False   True   True
    4       False  False  False
    5       False  False   True
    ```

    `n` can also be set per column:
    ```python-repl
    &gt;&gt;&gt; import numpy as np

    &gt;&gt;&gt; rand = vbt.RAND.run(
    ...     input_shape=(8, 2),
    ...     n=[np.array([1, 2]), 3],
    ...     seed=42)

    &gt;&gt;&gt; rand.entries
    rand_n      1      2             3
                0      1      0      1
    0       False   True   True   True
    1        True  False  False  False
    2       False  False  False  False
    3       False  False   True  False
    4       False   True  False   True
    5       False  False   True  False
    6       False  False  False   True
    7       False  False  False  False

    &gt;&gt;&gt; rand.exits
    rand_n      1      2             3
                0      1      0      1
    0       False  False  False  False
    1       False  False   True  False
    2       False  False  False   True
    3       False   True  False  False
    4       False  False   True  False
    5        True  False  False   True
    6       False  False   True  False
    7       False   True  False   True
    ```
    &#34;&#34;&#34;
    pass


setattr(RAND, &#39;__doc__&#39;, _RAND.__doc__)

RPROB = SignalFactory(
    class_name=&#39;RPROB&#39;,
    module_name=__name__,
    short_name=&#39;rprob&#39;,
    param_names=[&#39;entry_prob&#39;, &#39;exit_prob&#39;]
).from_choice_func(
    require_input_shape=True,
    entry_choice_func=rand_by_prob_choice_nb,
    entry_settings=dict(
        pass_params=[&#39;entry_prob&#39;],
        pass_kwargs=[&#39;first&#39;, &#39;temp_idx_arr&#39;, &#39;flex_2d&#39;]
    ),
    exit_choice_func=rand_by_prob_choice_nb,
    exit_settings=dict(
        pass_params=[&#39;exit_prob&#39;],
        pass_kwargs=[&#39;first&#39;, &#39;temp_idx_arr&#39;, &#39;flex_2d&#39;]
    ),
    pass_flex_2d=True,
    param_settings=dict(
        entry_prob=flex_elem_param_config,
        exit_prob=flex_elem_param_config
    ),
    seed=None
)


class _RPROB(RPROB):
    &#34;&#34;&#34;Random entry and exit signal generator based on probabilities.

    Generates `entries` and `exits` based on `vectorbt.signals.nb.rand_by_prob_choice_nb`.

    !!! hint
        All parameters can be either a single value (per frame) or a NumPy array (per row, column,
        or element). To generate multiple combinations, pass them as lists.

    ## Example

    Test all probability combinations:
    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; rprob = vbt.RPROB.run(
    ...     input_shape=(5,),
    ...     entry_prob=[0.5, 1.],
    ...     exit_prob=[0.5, 1.],
    ...     param_product=True,
    ...     seed=42)

    &gt;&gt;&gt; rprob.entries
    rprob_entry_prob           0.5           1.0
    rprob_exit_prob     0.5    1.0    0.5    1.0
    0                  True   True   True   True
    1                 False  False  False  False
    2                 False  False  False   True
    3                 False  False  False  False
    4                 False  False   True   True

    &gt;&gt;&gt; rprob.exits
    rprob_entry_prob           0.5           1.0
    rprob_exit_prob     0.5    1.0    0.5    1.0
    0                 False  False  False  False
    1                 False   True  False   True
    2                 False  False  False  False
    3                 False  False   True   True
    4                  True  False  False  False
    ```

    `entry_prob` and `exit_prob` can also be set per row, column, or element:
    ```python-repl
    &gt;&gt;&gt; import numpy as np

    &gt;&gt;&gt; entry_prob1 = np.asarray([1., 0., 1., 0., 1.])
    &gt;&gt;&gt; entry_prob2 = np.asarray([0., 1., 0., 1., 0.])
    &gt;&gt;&gt; rprob = vbt.RPROB.run(
    ...     input_shape=(5,),
    ...     entry_prob=[entry_prob1, entry_prob2],
    ...     exit_prob=1.,
    ...     seed=42)

    &gt;&gt;&gt; rprob.entries
    rprob_entry_prob array_0 array_1
    rprob_exit_prob      1.0     1.0
    0                   True   False
    1                  False    True
    2                   True   False
    3                  False    True
    4                   True   False

    &gt;&gt;&gt; rprob.exits
    rprob_entry_prob array_0 array_1
    rprob_exit_prob      1.0     1.0
    0                  False   False
    1                   True   False
    2                  False    True
    3                   True   False
    4                  False    True
    ```
    &#34;&#34;&#34;
    pass


setattr(RPROB, &#39;__doc__&#39;, _RPROB.__doc__)

rprobex_config = Config(
    dict(
        class_name=&#39;RPROBEX&#39;,
        module_name=__name__,
        short_name=&#39;rprobex&#39;,
        param_names=[&#39;prob&#39;],
        exit_only=True,
        iteratively=False
    )
)
&#34;&#34;&#34;Factory config for `RPROBEX`.&#34;&#34;&#34;

rprobex_func_config = Config(
    dict(
        exit_choice_func=rand_by_prob_choice_nb,
        exit_settings=dict(
            pass_params=[&#39;prob&#39;],
            pass_kwargs=[&#39;first&#39;, &#39;temp_idx_arr&#39;, &#39;flex_2d&#39;]
        ),
        pass_flex_2d=True,
        param_settings=dict(
            prob=flex_elem_param_config
        ),
        seed=None
    )
)
&#34;&#34;&#34;Exit function config for `RPROBEX`.&#34;&#34;&#34;

RPROBEX = SignalFactory(
    **rprobex_config
).from_choice_func(
    **rprobex_func_config
)


class _RPROBEX(RPROBEX):
    &#34;&#34;&#34;Random exit signal generator based on probabilities.

    Generates `exits` based on `entries` and `vectorbt.signals.nb.rand_by_prob_choice_nb`.

    See `RPROB` for notes on parameters.&#34;&#34;&#34;
    pass


setattr(RPROBEX, &#39;__doc__&#39;, _RPROBEX.__doc__)

IRPROBEX = SignalFactory(
    **rprobex_config.merge_with(
        dict(
            class_name=&#39;IRPROBEX&#39;,
            short_name=&#39;irprobex&#39;,
            iteratively=True
        )
    )
).from_choice_func(
    **rprobex_func_config
)


class _IRPROBEX(IRPROBEX):
    &#34;&#34;&#34;Random exit signal generator based on probabilities.

    Iteratively generates `new_entries` and `exits` based on `entries` and
    `vectorbt.signals.nb.rand_by_prob_choice_nb`.

    See `RPROB` for notes on parameters.&#34;&#34;&#34;
    pass


setattr(IRPROBEX, &#39;__doc__&#39;, _IRPROBEX.__doc__)

# ############# Stop signals ############# #

stex_config = Config(
    dict(
        class_name=&#39;STEX&#39;,
        module_name=__name__,
        short_name=&#39;stex&#39;,
        input_names=[&#39;ts&#39;],
        param_names=[&#39;stop&#39;, &#39;trailing&#39;],
        exit_only=True,
        iteratively=False
    )
)
&#34;&#34;&#34;Factory config for `STEX`.&#34;&#34;&#34;

stex_func_config = Config(
    dict(
        exit_choice_func=stop_choice_nb,
        exit_settings=dict(
            pass_inputs=[&#39;ts&#39;],
            pass_params=[&#39;stop&#39;, &#39;trailing&#39;],
            pass_kwargs=[&#39;wait&#39;, &#39;first&#39;, &#39;temp_idx_arr&#39;, &#39;flex_2d&#39;]
        ),
        pass_flex_2d=True,
        param_settings=dict(
            stop=flex_elem_param_config,
            trailing=flex_elem_param_config
        ),
        trailing=False
    )
)
&#34;&#34;&#34;Exit function config for `STEX`.&#34;&#34;&#34;

STEX = SignalFactory(
    **stex_config
).from_choice_func(
    **stex_func_config
)


class _STEX(STEX):
    &#34;&#34;&#34;Exit signal generator based on stop values.

    Generates `exits` based on `entries` and `vectorbt.signals.nb.stop_choice_nb`.

    !!! hint
        All parameters can be either a single value (per frame) or a NumPy array (per row, column,
        or element). To generate multiple combinations, pass them as lists.&#34;&#34;&#34;
    pass


setattr(STEX, &#39;__doc__&#39;, _STEX.__doc__)

ISTEX = SignalFactory(
    **stex_config.merge_with(
        dict(
            class_name=&#39;ISTEX&#39;,
            short_name=&#39;istex&#39;,
            iteratively=True
        )
    )
).from_choice_func(
    **stex_func_config
)


class _ISTEX(ISTEX):
    &#34;&#34;&#34;Exit signal generator based on stop values.

    Iteratively generates `new_entries` and `exits` based on `entries` and
    `vectorbt.signals.nb.stop_choice_nb`.

    See `STEX` for notes on parameters.&#34;&#34;&#34;
    pass


setattr(ISTEX, &#39;__doc__&#39;, _ISTEX.__doc__)

# ############# OHLC stop signals ############# #

ohlcstex_config = Config(
    dict(
        class_name=&#39;OHLCSTEX&#39;,
        module_name=__name__,
        short_name=&#39;ohlcstex&#39;,
        input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
        in_output_names=[&#39;hit_price&#39;, &#39;stop_type&#39;],
        param_names=[&#39;sl_stop&#39;, &#39;ts_stop&#39;, &#39;tp_stop&#39;],
        attr_settings=dict(
            stop_type=dict(dtype=StopType)  # creates rand_type_readable
        ),
        exit_only=True,
        iteratively=False
    )
)
&#34;&#34;&#34;Factory config for `OHLCSTEX`.&#34;&#34;&#34;

ohlcstex_func_config = Config(
    dict(
        exit_choice_func=ohlc_stop_choice_nb,
        exit_settings=dict(
            pass_inputs=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;],  # do not pass entries
            pass_in_outputs=[&#39;hit_price&#39;, &#39;stop_type&#39;],
            pass_params=[&#39;sl_stop&#39;, &#39;ts_stop&#39;, &#39;tp_stop&#39;],
            pass_kwargs=[(&#39;is_open_safe&#39;, True), &#39;wait&#39;, &#39;first&#39;, &#39;temp_idx_arr&#39;, &#39;flex_2d&#39;],
        ),
        pass_flex_2d=True,
        in_output_settings=dict(
            hit_price=dict(
                dtype=np.float_
            ),
            stop_type=dict(
                dtype=np.int_
            )
        ),
        param_settings=dict(
            sl_stop=flex_elem_param_config,
            ts_stop=flex_elem_param_config,
            tp_stop=flex_elem_param_config
        ),
        sl_stop=np.nan,
        ts_stop=np.nan,
        tp_stop=np.nan,
        hit_price=np.nan,
        stop_type=-1
    )
)
&#34;&#34;&#34;Exit function config for `OHLCSTEX`.&#34;&#34;&#34;

OHLCSTEX = SignalFactory(
    **ohlcstex_config
).from_choice_func(
    **ohlcstex_func_config
)


def _bind_ohlcstex_plot(base_cls: type, entries_attr: str) -&gt; tp.Callable:  # pragma: no cover

    base_cls_plot = base_cls.plot

    def plot(self,
             plot_type: tp.Union[None, str, tp.BaseTraceType] = None,
             ohlc_kwargs: tp.KwargsLike = None,
             entry_trace_kwargs: tp.KwargsLike = None,
             exit_trace_kwargs: tp.KwargsLike = None,
             add_trace_kwargs: tp.KwargsLike = None,
             fig: tp.Optional[tp.BaseFigure] = None,
             _base_cls_plot: tp.Callable = base_cls_plot,
             **layout_kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
        from vectorbt._settings import settings
        ohlcv_cfg = settings[&#39;ohlcv&#39;]
        plotting_cfg = settings[&#39;plotting&#39;]

        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;Select a column first. Use indexing.&#34;)

        if ohlc_kwargs is None:
            ohlc_kwargs = {}
        if add_trace_kwargs is None:
            add_trace_kwargs = {}

        if fig is None:
            fig = make_figure()
            fig.update_layout(
                showlegend=True,
                xaxis_rangeslider_visible=False,
                xaxis_showgrid=True,
                yaxis_showgrid=True
            )
        fig.update_layout(**layout_kwargs)

        if plot_type is None:
            plot_type = ohlcv_cfg[&#39;plot_type&#39;]
        if isinstance(plot_type, str):
            if plot_type.lower() == &#39;ohlc&#39;:
                plot_type = &#39;OHLC&#39;
                plot_obj = go.Ohlc
            elif plot_type.lower() == &#39;candlestick&#39;:
                plot_type = &#39;Candlestick&#39;
                plot_obj = go.Candlestick
            else:
                raise ValueError(&#34;Plot type can be either &#39;OHLC&#39; or &#39;Candlestick&#39;&#34;)
        else:
            plot_obj = plot_type
        ohlc = plot_obj(
            x=self.wrapper.index,
            open=self.open,
            high=self.high,
            low=self.low,
            close=self.close,
            name=plot_type,
            increasing_line_color=plotting_cfg[&#39;color_schema&#39;][&#39;increasing&#39;],
            decreasing_line_color=plotting_cfg[&#39;color_schema&#39;][&#39;decreasing&#39;]
        )
        ohlc.update(**ohlc_kwargs)
        fig.add_trace(ohlc, **add_trace_kwargs)

        # Plot entry and exit markers
        _base_cls_plot(
            self,
            entry_y=self.open,
            exit_y=self.hit_price,
            exit_types=self.stop_type_readable,
            entry_trace_kwargs=entry_trace_kwargs,
            exit_trace_kwargs=exit_trace_kwargs,
            add_trace_kwargs=add_trace_kwargs,
            fig=fig
        )
        return fig

    plot.__doc__ = &#34;&#34;&#34;Plot OHLC, `{0}.{1}` and `{0}.exits`.
    
    Args:
        plot_type: Either &#39;OHLC&#39;, &#39;Candlestick&#39; or Plotly trace.
        ohlc_kwargs (dict): Keyword arguments passed to `plot_type`.
        entry_trace_kwargs (dict): Keyword arguments passed to \
        `vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers` for `{0}.{1}`.
        exit_trace_kwargs (dict): Keyword arguments passed to \
        `vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers` for `{0}.exits`.
        fig (Figure or FigureWidget): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.&#34;&#34;&#34;.format(base_cls.__name__, entries_attr)

    if entries_attr == &#39;entries&#39;:
        plot.__doc__ += &#34;&#34;&#34;
    ## Example
        
    ```python-repl
    &gt;&gt;&gt; ohlcstex.iloc[:, 0].plot()
    ```
    
    ![](/vectorbt/docs/img/ohlcstex.svg)
    &#34;&#34;&#34;
    return plot


class _OHLCSTEX(OHLCSTEX):
    &#34;&#34;&#34;Advanced exit signal generator based on stop values.

    Generates `exits` based on `entries` and `vectorbt.signals.nb.ohlc_stop_choice_nb`.

    !!! hint
        All parameters can be either a single value (per frame) or a NumPy array (per row, column,
        or element). To generate multiple combinations, pass them as lists.

    ## Example

    Test each stop type individually:
    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt
    &gt;&gt;&gt; import pandas as pd

    &gt;&gt;&gt; entries = pd.Series([True, False, False, False, False])
    &gt;&gt;&gt; price = pd.DataFrame({
    ...     &#39;open&#39;: [10, 11, 12, 11, 10],
    ...     &#39;high&#39;: [11, 12, 13, 12, 11],
    ...     &#39;low&#39;: [9, 10, 11, 10, 9],
    ...     &#39;close&#39;: [10, 11, 12, 11, 10]
    ... })
    &gt;&gt;&gt; ohlcstex = vbt.OHLCSTEX.run(
    ...     entries, price[&#39;open&#39;], price[&#39;high&#39;], price[&#39;low&#39;], price[&#39;close&#39;],
    ...     sl_stop=[0.1, 0., 0.], ts_stop=[0., 0.1, 0.], tp_stop=[0., 0., 0.1])

    &gt;&gt;&gt; ohlcstex.entries
    ohlcstex_sl_stop    0.1    0.0    0.0
    ohlcstex_ts_stop    0.0    0.1    0.0
    ohlcstex_tp_stop    0.0    0.0    0.1
    0                  True   True   True
    1                 False  False  False
    2                 False  False  False
    3                 False  False  False
    4                 False  False  False

    &gt;&gt;&gt; ohlcstex.exits
    ohlcstex_sl_stop    0.1    0.0    0.0
    ohlcstex_ts_stop    0.0    0.1    0.0
    ohlcstex_tp_stop    0.0    0.0    0.1
    0                 False  False  False
    1                 False  False   True
    2                 False  False  False
    3                 False   True  False
    4                  True  False  False

    &gt;&gt;&gt; ohlcstex.hit_price
    ohlcstex_sl_stop  0.1   0.0   0.0
    ohlcstex_ts_stop  0.0   0.1   0.0
    ohlcstex_tp_stop  0.0   0.0   0.1
    0                 NaN   NaN   NaN
    1                 NaN   NaN  11.0
    2                 NaN   NaN   NaN
    3                 NaN  11.7   NaN
    4                 9.0   NaN   NaN

    &gt;&gt;&gt; ohlcstex.stop_type_readable
    ohlcstex_sl_stop       0.1        0.0         0.0
    ohlcstex_ts_stop       0.0        0.1         0.0
    ohlcstex_tp_stop       0.0        0.0         0.1
    0
    1                                      TakeProfit
    2
    3                           TrailStop
    4                 StopLoss
    ```
    &#34;&#34;&#34;

    plot = _bind_ohlcstex_plot(OHLCSTEX, &#39;entries&#39;)


setattr(OHLCSTEX, &#39;__doc__&#39;, _OHLCSTEX.__doc__)
setattr(OHLCSTEX, &#39;plot&#39;, _OHLCSTEX.plot)

IOHLCSTEX = SignalFactory(
    **ohlcstex_config.merge_with(
        dict(
            class_name=&#39;IOHLCSTEX&#39;,
            short_name=&#39;iohlcstex&#39;,
            iteratively=True
        )
    )
).from_choice_func(
    **ohlcstex_func_config
)


class _IOHLCSTEX(IOHLCSTEX):
    &#34;&#34;&#34;Advanced exit signal generator based on stop values.

    Iteratively generates `new_entries` and `exits` based on `entries` and
    `vectorbt.signals.nb.ohlc_stop_choice_nb`.

    See `OHLCSTEX` for notes on parameters.&#34;&#34;&#34;

    plot = _bind_ohlcstex_plot(IOHLCSTEX, &#39;new_entries&#39;)


setattr(IOHLCSTEX, &#39;__doc__&#39;, _IOHLCSTEX.__doc__)
setattr(IOHLCSTEX, &#39;plot&#39;, _IOHLCSTEX.plot)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="vectorbt.signals.generators.ohlcstex_config"><code class="name">var <span class="ident">ohlcstex_config</span></code></dt>
<dd>
<div class="desc"><p>Factory config for <code><a title="vectorbt.signals.generators.OHLCSTEX" href="#vectorbt.signals.generators.OHLCSTEX">OHLCSTEX</a></code>.</p></div>
</dd>
<dt id="vectorbt.signals.generators.ohlcstex_func_config"><code class="name">var <span class="ident">ohlcstex_func_config</span></code></dt>
<dd>
<div class="desc"><p>Exit function config for <code><a title="vectorbt.signals.generators.OHLCSTEX" href="#vectorbt.signals.generators.OHLCSTEX">OHLCSTEX</a></code>.</p></div>
</dd>
<dt id="vectorbt.signals.generators.rprobex_config"><code class="name">var <span class="ident">rprobex_config</span></code></dt>
<dd>
<div class="desc"><p>Factory config for <code><a title="vectorbt.signals.generators.RPROBEX" href="#vectorbt.signals.generators.RPROBEX">RPROBEX</a></code>.</p></div>
</dd>
<dt id="vectorbt.signals.generators.rprobex_func_config"><code class="name">var <span class="ident">rprobex_func_config</span></code></dt>
<dd>
<div class="desc"><p>Exit function config for <code><a title="vectorbt.signals.generators.RPROBEX" href="#vectorbt.signals.generators.RPROBEX">RPROBEX</a></code>.</p></div>
</dd>
<dt id="vectorbt.signals.generators.stex_config"><code class="name">var <span class="ident">stex_config</span></code></dt>
<dd>
<div class="desc"><p>Factory config for <code><a title="vectorbt.signals.generators.STEX" href="#vectorbt.signals.generators.STEX">STEX</a></code>.</p></div>
</dd>
<dt id="vectorbt.signals.generators.stex_func_config"><code class="name">var <span class="ident">stex_func_config</span></code></dt>
<dd>
<div class="desc"><p>Exit function config for <code><a title="vectorbt.signals.generators.STEX" href="#vectorbt.signals.generators.STEX">STEX</a></code>.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.signals.generators.IOHLCSTEX"><code class="flex name class">
<span>class <span class="ident">IOHLCSTEX</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Advanced exit signal generator based on stop values.</p>
<p>Iteratively generates <code>new_entries</code> and <code>exits</code> based on <code>entries</code> and
<code><a title="vectorbt.signals.nb.ohlc_stop_choice_nb" href="nb.html#vectorbt.signals.nb.ohlc_stop_choice_nb">ohlc_stop_choice_nb()</a></code>.</p>
<p>See <code><a title="vectorbt.signals.generators.OHLCSTEX" href="#vectorbt.signals.generators.OHLCSTEX">OHLCSTEX</a></code> for notes on parameters.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.signals.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.signals.generators._IOHLCSTEX</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.generators.IOHLCSTEX.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>entries, open, high, low, close, sl_stop=nan, ts_stop=nan, tp_stop=nan, hit_price=nan, stop_type=-1, short_name='iohlcstex', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.signals.generators.IOHLCSTEX" href="#vectorbt.signals.generators.IOHLCSTEX">IOHLCSTEX</a></code> indicator.</p>
<ul>
<li>Inputs: <code>entries</code>, <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code></li>
<li>In-place outputs: <code>hit_price</code>, <code>stop_type</code></li>
<li>Parameters: <code>sl_stop</code>, <code>ts_stop</code>, <code>tp_stop</code></li>
<li>Outputs: <code>new_entries</code>, <code>exits</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.run_combs"><code class="name flex">
<span>def <span class="ident">run_combs</span></span>(<span>entries, open, high, low, close, sl_stop=nan, ts_stop=nan, tp_stop=nan, hit_price=nan, stop_type=-1, r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.signals.generators.IOHLCSTEX" href="#vectorbt.signals.generators.IOHLCSTEX">IOHLCSTEX</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>entries</code>, <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code></li>
<li>In-place outputs: <code>hit_price</code>, <code>stop_type</code></li>
<li>Parameters: <code>sl_stop</code>, <code>ts_stop</code>, <code>tp_stop</code></li>
<li>Outputs: <code>new_entries</code>, <code>exits</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.generators.IOHLCSTEX.run" href="#vectorbt.signals.generators.IOHLCSTEX.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.generators.IOHLCSTEX.close"><code class="name">var <span class="ident">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.entries"><code class="name">var <span class="ident">entries</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.exits"><code class="name">var <span class="ident">exits</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.high"><code class="name">var <span class="ident">high</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.hit_price"><code class="name">var <span class="ident">hit_price</span></code></dt>
<dd>
<div class="desc"><p>In-place output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.low"><code class="name">var <span class="ident">low</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.new_entries"><code class="name">var <span class="ident">new_entries</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.open"><code class="name">var <span class="ident">open</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.sl_stop_list"><code class="name">var <span class="ident">sl_stop_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>sl_stop</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.stop_type"><code class="name">var <span class="ident">stop_type</span></code></dt>
<dd>
<div class="desc"><p>In-place output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.stop_type_readable"><code class="name">var <span class="ident">stop_type_readable</span></code></dt>
<dd>
<div class="desc"><p>stop_type in readable format based on enum StopTypeT(StopLoss=0, TrailStop=1, TakeProfit=2).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_readable(self, _attr_name: str = attr_name, enum: tp.NamedTuple = dtype) -&gt; tp.SeriesFrame:
    if self.wrapper.ndim == 1:
        return getattr(self, _attr_name).map(lambda x: &#39;&#39; if x == -1 else enum._fields[x])
    return getattr(self, _attr_name).applymap(lambda x: &#39;&#39; if x == -1 else enum._fields[x])</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.tp_stop_list"><code class="name">var <span class="ident">tp_stop_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>tp_stop</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.ts_stop_list"><code class="name">var <span class="ident">ts_stop_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>ts_stop</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.generators.IOHLCSTEX.close_above"><code class="name flex">
<span>def <span class="ident">close_above</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.close_below"><code class="name flex">
<span>def <span class="ident">close_below</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.close_equal"><code class="name flex">
<span>def <span class="ident">close_equal</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.custom_func"><code class="name flex">
<span>def <span class="ident">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, flex_2d=None, entry_args=None, exit_args=None, cache_args=None, entry_kwargs=None, exit_kwargs=None, cache_kwargs=None, return_cache=False, use_cache=None, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                flex_2d: tp.Optional[bool] = None,
                entry_args: tp.Optional[tp.Args] = None,
                exit_args: tp.Optional[tp.Args] = None,
                cache_args: tp.Optional[tp.Args] = None,
                entry_kwargs: tp.KwargsLike = None,
                exit_kwargs: tp.KwargsLike = None,
                cache_kwargs: tp.KwargsLike = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                **_kwargs) -&gt; tp.Union[CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    # Get arguments
    if len(input_list) == 0:
        if input_shape is None:
            raise ValueError(&#34;Pass input_shape if no input time series passed&#34;)
    else:
        input_shape = input_list[0].shape

    if entry_args is None:
        entry_args = ()
    if exit_args is None:
        exit_args = ()
    if cache_args is None:
        cache_args = ()
    if exit_only:
        if len(exit_args) &gt; 0:
            raise ValueError(&#34;Use *args instead of exit_args when exit_only=True&#34;)
        exit_args = args
    else:
        if len(args) &gt; 0:
            raise ValueError(&#34;*args can be only used when exit_only=True&#34;)

    if entry_kwargs is None:
        entry_kwargs = {}
    if exit_kwargs is None:
        exit_kwargs = {}
    if cache_kwargs is None:
        cache_kwargs = {}
    if exit_only:
        if len(exit_kwargs) &gt; 0:
            raise ValueError(&#34;Use **kwargs instead of exit_kwargs when exit_only=True&#34;)
        exit_kwargs = _kwargs
    else:
        if len(_kwargs) &gt; 0:
            raise ValueError(&#34;**kwargs can be only used when exit_only=True&#34;)

    kwargs_defaults = dict(
        input_shape=input_shape,
        wait=1,
        first=True,
        flex_2d=flex_2d,
    )
    entry_kwargs = merge_dicts(kwargs_defaults, entry_kwargs)
    exit_kwargs = merge_dicts(kwargs_defaults, exit_kwargs)
    cache_kwargs = merge_dicts(kwargs_defaults, cache_kwargs)
    entry_wait = entry_kwargs[&#39;wait&#39;]
    exit_wait = exit_kwargs[&#39;wait&#39;]

    # Distribute arguments across functions
    entry_input_tuple = ()
    exit_input_tuple = ()
    cache_input_tuple = ()
    for input_name in entry_input_names:
        entry_input_tuple += (input_list[input_names.index(input_name)],)
    for input_name in exit_input_names:
        exit_input_tuple += (input_list[input_names.index(input_name)],)
    for input_name in cache_input_names:
        cache_input_tuple += (input_list[input_names.index(input_name)],)

    entry_in_output_list = []
    exit_in_output_list = []
    cache_in_output_list = []
    for in_output_name in entry_in_output_names:
        entry_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
    for in_output_name in exit_in_output_names:
        exit_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
    for in_output_name in cache_in_output_names:
        cache_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])

    entry_param_list = []
    exit_param_list = []
    cache_param_list = []
    for param_name in entry_param_names:
        entry_param_list.append(param_list[param_names.index(param_name)])
    for param_name in exit_param_names:
        exit_param_list.append(param_list[param_names.index(param_name)])
    for param_name in cache_param_names:
        cache_param_list.append(param_list[param_names.index(param_name)])

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    entry_in_output_tuples = list(zip(*entry_in_output_list))
    exit_in_output_tuples = list(zip(*exit_in_output_list))
    entry_param_tuples = list(zip(*entry_param_list))
    exit_param_tuples = list(zip(*exit_param_list))

    def _build_more_args(func_settings: tp.Kwargs, func_kwargs: tp.Kwargs) -&gt; tp.Args:
        pass_kwargs = func_settings.get(&#39;pass_kwargs&#39;, [])
        more_args = ()
        for key in pass_kwargs:
            value = None
            if isinstance(key, tuple):
                key, value = key
            else:
                if key.startswith(&#39;temp_idx_arr&#39;):
                    value = np.empty((input_shape[0],), dtype=np.int_)
            value = func_kwargs.get(key, value)
            more_args += (value,)
        return more_args

    entry_more_args = _build_more_args(entry_settings, entry_kwargs)
    exit_more_args = _build_more_args(exit_settings, exit_kwargs)
    cache_more_args = _build_more_args(cache_settings, cache_kwargs)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _cache_in_output_list = cache_in_output_list
        _cache_param_list = cache_param_list
        if checks.is_numba_func(cache_func):
            if len(_cache_in_output_list) &gt; 0:
                _cache_in_output_list = [to_typed_list(in_outputs) for in_outputs in _cache_in_output_list]
            if len(_cache_param_list) &gt; 0:
                _cache_param_list = [to_typed_list(params) for params in _cache_param_list]

        cache = cache_func(
            *cache_input_tuple,
            *_cache_in_output_list,
            *_cache_param_list,
            *cache_args,
            *cache_more_args
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    entry_cache = ()
    exit_cache = ()
    if entry_settings.get(&#39;pass_cache&#39;, False):
        entry_cache = cache
    if exit_settings.get(&#39;pass_cache&#39;, False):
        exit_cache = cache

    # Apply and concatenate
    if exit_only and not iteratively:
        if len(exit_in_output_names) &gt; 0:
            if numba_loop:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = (exit_in_output_tuples,)
        else:
            _exit_in_output_tuples = ()
        if len(exit_param_names) &gt; 0:
            if numba_loop:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = (exit_param_tuples,)
        else:
            _exit_param_tuples = ()

        return apply_and_concat_func(
            n_params,
            apply_func,
            input_list[0],
            exit_wait,
            exit_input_tuple,
            *_exit_in_output_tuples,
            *_exit_param_tuples,
            exit_args + exit_more_args + exit_cache
        )

    else:
        if len(entry_in_output_names) &gt; 0:
            if numba_loop:
                _entry_in_output_tuples = (to_typed_list(entry_in_output_tuples),)
            else:
                _entry_in_output_tuples = (entry_in_output_tuples,)
        else:
            _entry_in_output_tuples = ()
        if len(entry_param_names) &gt; 0:
            if numba_loop:
                _entry_param_tuples = (to_typed_list(entry_param_tuples),)
            else:
                _entry_param_tuples = (entry_param_tuples,)
        else:
            _entry_param_tuples = ()
        if len(exit_in_output_names) &gt; 0:
            if numba_loop:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = (exit_in_output_tuples,)
        else:
            _exit_in_output_tuples = ()
        if len(exit_param_names) &gt; 0:
            if numba_loop:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = (exit_param_tuples,)
        else:
            _exit_param_tuples = ()

        return apply_and_concat_func(
            n_params,
            apply_func,
            input_shape,
            entry_wait,
            exit_wait,
            entry_input_tuple,
            exit_input_tuple,
            *_entry_in_output_tuples,
            *_exit_in_output_tuples,
            *_entry_param_tuples,
            *_exit_param_tuples,
            entry_args + entry_more_args + entry_cache,
            exit_args + exit_more_args + exit_cache
        )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.entries_and"><code class="name flex">
<span>def <span class="ident">entries_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.entries_or"><code class="name flex">
<span>def <span class="ident">entries_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.entries_xor"><code class="name flex">
<span>def <span class="ident">entries_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.exits_and"><code class="name flex">
<span>def <span class="ident">exits_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.exits_or"><code class="name flex">
<span>def <span class="ident">exits_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.exits_xor"><code class="name flex">
<span>def <span class="ident">exits_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.high_above"><code class="name flex">
<span>def <span class="ident">high_above</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.high_below"><code class="name flex">
<span>def <span class="ident">high_below</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.high_equal"><code class="name flex">
<span>def <span class="ident">high_equal</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.hit_price_above"><code class="name flex">
<span>def <span class="ident">hit_price_above</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hit_price</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hit_price</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.hit_price_below"><code class="name flex">
<span>def <span class="ident">hit_price_below</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hit_price</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hit_price</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.hit_price_equal"><code class="name flex">
<span>def <span class="ident">hit_price_equal</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hit_price</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hit_price</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.low_above"><code class="name flex">
<span>def <span class="ident">low_above</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.low_below"><code class="name flex">
<span>def <span class="ident">low_below</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.low_equal"><code class="name flex">
<span>def <span class="ident">low_equal</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.new_entries_and"><code class="name flex">
<span>def <span class="ident">new_entries_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.new_entries_or"><code class="name flex">
<span>def <span class="ident">new_entries_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.new_entries_xor"><code class="name flex">
<span>def <span class="ident">new_entries_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.open_above"><code class="name flex">
<span>def <span class="ident">open_above</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>open</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>open</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.open_below"><code class="name flex">
<span>def <span class="ident">open_below</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>open</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>open</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.open_equal"><code class="name flex">
<span>def <span class="ident">open_equal</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>open</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>open</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IOHLCSTEX.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, plot_type=None, ohlc_kwargs=None, entry_trace_kwargs=None, exit_trace_kwargs=None, add_trace_kwargs=None, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot OHLC, <code><a title="vectorbt.signals.generators.IOHLCSTEX.new_entries" href="#vectorbt.signals.generators.IOHLCSTEX.new_entries">IOHLCSTEX.new_entries</a></code> and <code><a title="vectorbt.signals.generators.IOHLCSTEX.exits" href="#vectorbt.signals.generators.IOHLCSTEX.exits">IOHLCSTEX.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plot_type</code></strong></dt>
<dd>Either 'OHLC', 'Candlestick' or Plotly trace.</dd>
<dt><strong><code>ohlc_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plot_type</code>.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers">SignalsSRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.generators.IOHLCSTEX.new_entries" href="#vectorbt.signals.generators.IOHLCSTEX.new_entries">IOHLCSTEX.new_entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers">SignalsSRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.generators.IOHLCSTEX.exits" href="#vectorbt.signals.generators.IOHLCSTEX.exits">IOHLCSTEX.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>Figure</code> or <code>FigureWidget</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         plot_type: tp.Union[None, str, tp.BaseTraceType] = None,
         ohlc_kwargs: tp.KwargsLike = None,
         entry_trace_kwargs: tp.KwargsLike = None,
         exit_trace_kwargs: tp.KwargsLike = None,
         add_trace_kwargs: tp.KwargsLike = None,
         fig: tp.Optional[tp.BaseFigure] = None,
         _base_cls_plot: tp.Callable = base_cls_plot,
         **layout_kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    from vectorbt._settings import settings
    ohlcv_cfg = settings[&#39;ohlcv&#39;]
    plotting_cfg = settings[&#39;plotting&#39;]

    if self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if ohlc_kwargs is None:
        ohlc_kwargs = {}
    if add_trace_kwargs is None:
        add_trace_kwargs = {}

    if fig is None:
        fig = make_figure()
        fig.update_layout(
            showlegend=True,
            xaxis_rangeslider_visible=False,
            xaxis_showgrid=True,
            yaxis_showgrid=True
        )
    fig.update_layout(**layout_kwargs)

    if plot_type is None:
        plot_type = ohlcv_cfg[&#39;plot_type&#39;]
    if isinstance(plot_type, str):
        if plot_type.lower() == &#39;ohlc&#39;:
            plot_type = &#39;OHLC&#39;
            plot_obj = go.Ohlc
        elif plot_type.lower() == &#39;candlestick&#39;:
            plot_type = &#39;Candlestick&#39;
            plot_obj = go.Candlestick
        else:
            raise ValueError(&#34;Plot type can be either &#39;OHLC&#39; or &#39;Candlestick&#39;&#34;)
    else:
        plot_obj = plot_type
    ohlc = plot_obj(
        x=self.wrapper.index,
        open=self.open,
        high=self.high,
        low=self.low,
        close=self.close,
        name=plot_type,
        increasing_line_color=plotting_cfg[&#39;color_schema&#39;][&#39;increasing&#39;],
        decreasing_line_color=plotting_cfg[&#39;color_schema&#39;][&#39;decreasing&#39;]
    )
    ohlc.update(**ohlc_kwargs)
    fig.add_trace(ohlc, **add_trace_kwargs)

    # Plot entry and exit markers
    _base_cls_plot(
        self,
        entry_y=self.open,
        exit_y=self.hit_price,
        exit_types=self.stop_type_readable,
        entry_trace_kwargs=entry_trace_kwargs,
        exit_trace_kwargs=exit_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs,
        fig=fig
    )
    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX"><code class="flex name class">
<span>class <span class="ident">IRPROBEX</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Random exit signal generator based on probabilities.</p>
<p>Iteratively generates <code>new_entries</code> and <code>exits</code> based on <code>entries</code> and
<code><a title="vectorbt.signals.nb.rand_by_prob_choice_nb" href="nb.html#vectorbt.signals.nb.rand_by_prob_choice_nb">rand_by_prob_choice_nb()</a></code>.</p>
<p>See <code><a title="vectorbt.signals.generators.RPROB" href="#vectorbt.signals.generators.RPROB">RPROB</a></code> for notes on parameters.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.signals.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.signals.generators._IRPROBEX</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.generators.IRPROBEX.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>entries, prob, short_name='irprobex', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.signals.generators.IRPROBEX" href="#vectorbt.signals.generators.IRPROBEX">IRPROBEX</a></code> indicator.</p>
<ul>
<li>Inputs: <code>entries</code></li>
<li>Parameters: <code>prob</code></li>
<li>Outputs: <code>new_entries</code>, <code>exits</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX.run_combs"><code class="name flex">
<span>def <span class="ident">run_combs</span></span>(<span>entries, prob, r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.signals.generators.IRPROBEX" href="#vectorbt.signals.generators.IRPROBEX">IRPROBEX</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>entries</code></li>
<li>Parameters: <code>prob</code></li>
<li>Outputs: <code>new_entries</code>, <code>exits</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.generators.IRPROBEX.run" href="#vectorbt.signals.generators.IRPROBEX.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.generators.IRPROBEX.entries"><code class="name">var <span class="ident">entries</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX.exits"><code class="name">var <span class="ident">exits</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX.new_entries"><code class="name">var <span class="ident">new_entries</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX.prob_list"><code class="name">var <span class="ident">prob_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>prob</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.generators.IRPROBEX.custom_func"><code class="name flex">
<span>def <span class="ident">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, flex_2d=None, entry_args=None, exit_args=None, cache_args=None, entry_kwargs=None, exit_kwargs=None, cache_kwargs=None, return_cache=False, use_cache=None, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                flex_2d: tp.Optional[bool] = None,
                entry_args: tp.Optional[tp.Args] = None,
                exit_args: tp.Optional[tp.Args] = None,
                cache_args: tp.Optional[tp.Args] = None,
                entry_kwargs: tp.KwargsLike = None,
                exit_kwargs: tp.KwargsLike = None,
                cache_kwargs: tp.KwargsLike = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                **_kwargs) -&gt; tp.Union[CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    # Get arguments
    if len(input_list) == 0:
        if input_shape is None:
            raise ValueError(&#34;Pass input_shape if no input time series passed&#34;)
    else:
        input_shape = input_list[0].shape

    if entry_args is None:
        entry_args = ()
    if exit_args is None:
        exit_args = ()
    if cache_args is None:
        cache_args = ()
    if exit_only:
        if len(exit_args) &gt; 0:
            raise ValueError(&#34;Use *args instead of exit_args when exit_only=True&#34;)
        exit_args = args
    else:
        if len(args) &gt; 0:
            raise ValueError(&#34;*args can be only used when exit_only=True&#34;)

    if entry_kwargs is None:
        entry_kwargs = {}
    if exit_kwargs is None:
        exit_kwargs = {}
    if cache_kwargs is None:
        cache_kwargs = {}
    if exit_only:
        if len(exit_kwargs) &gt; 0:
            raise ValueError(&#34;Use **kwargs instead of exit_kwargs when exit_only=True&#34;)
        exit_kwargs = _kwargs
    else:
        if len(_kwargs) &gt; 0:
            raise ValueError(&#34;**kwargs can be only used when exit_only=True&#34;)

    kwargs_defaults = dict(
        input_shape=input_shape,
        wait=1,
        first=True,
        flex_2d=flex_2d,
    )
    entry_kwargs = merge_dicts(kwargs_defaults, entry_kwargs)
    exit_kwargs = merge_dicts(kwargs_defaults, exit_kwargs)
    cache_kwargs = merge_dicts(kwargs_defaults, cache_kwargs)
    entry_wait = entry_kwargs[&#39;wait&#39;]
    exit_wait = exit_kwargs[&#39;wait&#39;]

    # Distribute arguments across functions
    entry_input_tuple = ()
    exit_input_tuple = ()
    cache_input_tuple = ()
    for input_name in entry_input_names:
        entry_input_tuple += (input_list[input_names.index(input_name)],)
    for input_name in exit_input_names:
        exit_input_tuple += (input_list[input_names.index(input_name)],)
    for input_name in cache_input_names:
        cache_input_tuple += (input_list[input_names.index(input_name)],)

    entry_in_output_list = []
    exit_in_output_list = []
    cache_in_output_list = []
    for in_output_name in entry_in_output_names:
        entry_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
    for in_output_name in exit_in_output_names:
        exit_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
    for in_output_name in cache_in_output_names:
        cache_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])

    entry_param_list = []
    exit_param_list = []
    cache_param_list = []
    for param_name in entry_param_names:
        entry_param_list.append(param_list[param_names.index(param_name)])
    for param_name in exit_param_names:
        exit_param_list.append(param_list[param_names.index(param_name)])
    for param_name in cache_param_names:
        cache_param_list.append(param_list[param_names.index(param_name)])

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    entry_in_output_tuples = list(zip(*entry_in_output_list))
    exit_in_output_tuples = list(zip(*exit_in_output_list))
    entry_param_tuples = list(zip(*entry_param_list))
    exit_param_tuples = list(zip(*exit_param_list))

    def _build_more_args(func_settings: tp.Kwargs, func_kwargs: tp.Kwargs) -&gt; tp.Args:
        pass_kwargs = func_settings.get(&#39;pass_kwargs&#39;, [])
        more_args = ()
        for key in pass_kwargs:
            value = None
            if isinstance(key, tuple):
                key, value = key
            else:
                if key.startswith(&#39;temp_idx_arr&#39;):
                    value = np.empty((input_shape[0],), dtype=np.int_)
            value = func_kwargs.get(key, value)
            more_args += (value,)
        return more_args

    entry_more_args = _build_more_args(entry_settings, entry_kwargs)
    exit_more_args = _build_more_args(exit_settings, exit_kwargs)
    cache_more_args = _build_more_args(cache_settings, cache_kwargs)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _cache_in_output_list = cache_in_output_list
        _cache_param_list = cache_param_list
        if checks.is_numba_func(cache_func):
            if len(_cache_in_output_list) &gt; 0:
                _cache_in_output_list = [to_typed_list(in_outputs) for in_outputs in _cache_in_output_list]
            if len(_cache_param_list) &gt; 0:
                _cache_param_list = [to_typed_list(params) for params in _cache_param_list]

        cache = cache_func(
            *cache_input_tuple,
            *_cache_in_output_list,
            *_cache_param_list,
            *cache_args,
            *cache_more_args
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    entry_cache = ()
    exit_cache = ()
    if entry_settings.get(&#39;pass_cache&#39;, False):
        entry_cache = cache
    if exit_settings.get(&#39;pass_cache&#39;, False):
        exit_cache = cache

    # Apply and concatenate
    if exit_only and not iteratively:
        if len(exit_in_output_names) &gt; 0:
            if numba_loop:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = (exit_in_output_tuples,)
        else:
            _exit_in_output_tuples = ()
        if len(exit_param_names) &gt; 0:
            if numba_loop:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = (exit_param_tuples,)
        else:
            _exit_param_tuples = ()

        return apply_and_concat_func(
            n_params,
            apply_func,
            input_list[0],
            exit_wait,
            exit_input_tuple,
            *_exit_in_output_tuples,
            *_exit_param_tuples,
            exit_args + exit_more_args + exit_cache
        )

    else:
        if len(entry_in_output_names) &gt; 0:
            if numba_loop:
                _entry_in_output_tuples = (to_typed_list(entry_in_output_tuples),)
            else:
                _entry_in_output_tuples = (entry_in_output_tuples,)
        else:
            _entry_in_output_tuples = ()
        if len(entry_param_names) &gt; 0:
            if numba_loop:
                _entry_param_tuples = (to_typed_list(entry_param_tuples),)
            else:
                _entry_param_tuples = (entry_param_tuples,)
        else:
            _entry_param_tuples = ()
        if len(exit_in_output_names) &gt; 0:
            if numba_loop:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = (exit_in_output_tuples,)
        else:
            _exit_in_output_tuples = ()
        if len(exit_param_names) &gt; 0:
            if numba_loop:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = (exit_param_tuples,)
        else:
            _exit_param_tuples = ()

        return apply_and_concat_func(
            n_params,
            apply_func,
            input_shape,
            entry_wait,
            exit_wait,
            entry_input_tuple,
            exit_input_tuple,
            *_entry_in_output_tuples,
            *_exit_in_output_tuples,
            *_entry_param_tuples,
            *_exit_param_tuples,
            entry_args + entry_more_args + entry_cache,
            exit_args + exit_more_args + exit_cache
        )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX.entries_and"><code class="name flex">
<span>def <span class="ident">entries_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX.entries_or"><code class="name flex">
<span>def <span class="ident">entries_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX.entries_xor"><code class="name flex">
<span>def <span class="ident">entries_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX.exits_and"><code class="name flex">
<span>def <span class="ident">exits_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX.exits_or"><code class="name flex">
<span>def <span class="ident">exits_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX.exits_xor"><code class="name flex">
<span>def <span class="ident">exits_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX.new_entries_and"><code class="name flex">
<span>def <span class="ident">new_entries_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX.new_entries_or"><code class="name flex">
<span>def <span class="ident">new_entries_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX.new_entries_xor"><code class="name flex">
<span>def <span class="ident">new_entries_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.IRPROBEX.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>_self, entry_y=None, exit_y=None, entry_types=None, exit_types=None, entry_trace_kwargs=None, exit_trace_kwargs=None, fig=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.signals.generators.IRPROBEX.new_entries" href="#vectorbt.signals.generators.IRPROBEX.new_entries">IRPROBEX.new_entries</a></code> and <code><a title="vectorbt.signals.generators.IRPROBEX.exits" href="#vectorbt.signals.generators.IRPROBEX.exits">IRPROBEX.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entry_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot entry markers on.</dd>
<dt><strong><code>exit_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot exit markers on.</dd>
<dt><strong><code>entry_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Entry types in string format.</dd>
<dt><strong><code>exit_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Exit types in string format.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers">SignalsSRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.generators.IRPROBEX.new_entries" href="#vectorbt.signals.generators.IRPROBEX.new_entries">IRPROBEX.new_entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers">SignalsSRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.generators.IRPROBEX.exits" href="#vectorbt.signals.generators.IRPROBEX.exits">IRPROBEX.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>Figure</code> or <code>FigureWidget</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers">SignalsSRAccessor.plot_as_markers()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(_self,
         entry_y: tp.Optional[tp.ArrayLike] = None,
         exit_y: tp.Optional[tp.ArrayLike] = None,
         entry_types: tp.Optional[tp.ArrayLikeSequence] = None,
         exit_types: tp.Optional[tp.ArrayLikeSequence] = None,
         entry_trace_kwargs: tp.KwargsLike = None,
         exit_trace_kwargs: tp.KwargsLike = None,
         fig: tp.Optional[tp.BaseFigure] = None,
         **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    if _self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if entry_trace_kwargs is None:
        entry_trace_kwargs = {}
    if exit_trace_kwargs is None:
        exit_trace_kwargs = {}
    if entry_types is not None:
        entry_types = np.asarray(entry_types)
        entry_trace_kwargs = merge_dicts(dict(
            customdata=entry_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), entry_trace_kwargs)
    if exit_types is not None:
        exit_types = np.asarray(exit_types)
        exit_trace_kwargs = merge_dicts(dict(
            customdata=exit_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), exit_trace_kwargs)
    if exit_only and iteratively:
        entries = _self.new_entries
    else:
        entries = _self.entries
    exits = _self.exits
    fig = entries.vbt.signals.plot_as_entry_markers(
        y=entry_y, trace_kwargs=entry_trace_kwargs, fig=fig, **kwargs)
    fig = exits.vbt.signals.plot_as_exit_markers(
        y=exit_y, trace_kwargs=exit_trace_kwargs, fig=fig, **kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.generators.ISTEX"><code class="flex name class">
<span>class <span class="ident">ISTEX</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Exit signal generator based on stop values.</p>
<p>Iteratively generates <code>new_entries</code> and <code>exits</code> based on <code>entries</code> and
<code><a title="vectorbt.signals.nb.stop_choice_nb" href="nb.html#vectorbt.signals.nb.stop_choice_nb">stop_choice_nb()</a></code>.</p>
<p>See <code><a title="vectorbt.signals.generators.STEX" href="#vectorbt.signals.generators.STEX">STEX</a></code> for notes on parameters.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.signals.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.signals.generators._ISTEX</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.generators.ISTEX.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>entries, ts, stop, trailing=False, short_name='istex', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.signals.generators.ISTEX" href="#vectorbt.signals.generators.ISTEX">ISTEX</a></code> indicator.</p>
<ul>
<li>Inputs: <code>entries</code>, <code>ts</code></li>
<li>Parameters: <code>stop</code>, <code>trailing</code></li>
<li>Outputs: <code>new_entries</code>, <code>exits</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.run_combs"><code class="name flex">
<span>def <span class="ident">run_combs</span></span>(<span>entries, ts, stop, trailing=False, r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.signals.generators.ISTEX" href="#vectorbt.signals.generators.ISTEX">ISTEX</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>entries</code>, <code>ts</code></li>
<li>Parameters: <code>stop</code>, <code>trailing</code></li>
<li>Outputs: <code>new_entries</code>, <code>exits</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.generators.ISTEX.run" href="#vectorbt.signals.generators.ISTEX.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.generators.ISTEX.entries"><code class="name">var <span class="ident">entries</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.exits"><code class="name">var <span class="ident">exits</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.new_entries"><code class="name">var <span class="ident">new_entries</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.stop_list"><code class="name">var <span class="ident">stop_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>stop</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.trailing_list"><code class="name">var <span class="ident">trailing_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>trailing</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.ts"><code class="name">var <span class="ident">ts</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.generators.ISTEX.custom_func"><code class="name flex">
<span>def <span class="ident">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, flex_2d=None, entry_args=None, exit_args=None, cache_args=None, entry_kwargs=None, exit_kwargs=None, cache_kwargs=None, return_cache=False, use_cache=None, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                flex_2d: tp.Optional[bool] = None,
                entry_args: tp.Optional[tp.Args] = None,
                exit_args: tp.Optional[tp.Args] = None,
                cache_args: tp.Optional[tp.Args] = None,
                entry_kwargs: tp.KwargsLike = None,
                exit_kwargs: tp.KwargsLike = None,
                cache_kwargs: tp.KwargsLike = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                **_kwargs) -&gt; tp.Union[CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    # Get arguments
    if len(input_list) == 0:
        if input_shape is None:
            raise ValueError(&#34;Pass input_shape if no input time series passed&#34;)
    else:
        input_shape = input_list[0].shape

    if entry_args is None:
        entry_args = ()
    if exit_args is None:
        exit_args = ()
    if cache_args is None:
        cache_args = ()
    if exit_only:
        if len(exit_args) &gt; 0:
            raise ValueError(&#34;Use *args instead of exit_args when exit_only=True&#34;)
        exit_args = args
    else:
        if len(args) &gt; 0:
            raise ValueError(&#34;*args can be only used when exit_only=True&#34;)

    if entry_kwargs is None:
        entry_kwargs = {}
    if exit_kwargs is None:
        exit_kwargs = {}
    if cache_kwargs is None:
        cache_kwargs = {}
    if exit_only:
        if len(exit_kwargs) &gt; 0:
            raise ValueError(&#34;Use **kwargs instead of exit_kwargs when exit_only=True&#34;)
        exit_kwargs = _kwargs
    else:
        if len(_kwargs) &gt; 0:
            raise ValueError(&#34;**kwargs can be only used when exit_only=True&#34;)

    kwargs_defaults = dict(
        input_shape=input_shape,
        wait=1,
        first=True,
        flex_2d=flex_2d,
    )
    entry_kwargs = merge_dicts(kwargs_defaults, entry_kwargs)
    exit_kwargs = merge_dicts(kwargs_defaults, exit_kwargs)
    cache_kwargs = merge_dicts(kwargs_defaults, cache_kwargs)
    entry_wait = entry_kwargs[&#39;wait&#39;]
    exit_wait = exit_kwargs[&#39;wait&#39;]

    # Distribute arguments across functions
    entry_input_tuple = ()
    exit_input_tuple = ()
    cache_input_tuple = ()
    for input_name in entry_input_names:
        entry_input_tuple += (input_list[input_names.index(input_name)],)
    for input_name in exit_input_names:
        exit_input_tuple += (input_list[input_names.index(input_name)],)
    for input_name in cache_input_names:
        cache_input_tuple += (input_list[input_names.index(input_name)],)

    entry_in_output_list = []
    exit_in_output_list = []
    cache_in_output_list = []
    for in_output_name in entry_in_output_names:
        entry_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
    for in_output_name in exit_in_output_names:
        exit_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
    for in_output_name in cache_in_output_names:
        cache_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])

    entry_param_list = []
    exit_param_list = []
    cache_param_list = []
    for param_name in entry_param_names:
        entry_param_list.append(param_list[param_names.index(param_name)])
    for param_name in exit_param_names:
        exit_param_list.append(param_list[param_names.index(param_name)])
    for param_name in cache_param_names:
        cache_param_list.append(param_list[param_names.index(param_name)])

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    entry_in_output_tuples = list(zip(*entry_in_output_list))
    exit_in_output_tuples = list(zip(*exit_in_output_list))
    entry_param_tuples = list(zip(*entry_param_list))
    exit_param_tuples = list(zip(*exit_param_list))

    def _build_more_args(func_settings: tp.Kwargs, func_kwargs: tp.Kwargs) -&gt; tp.Args:
        pass_kwargs = func_settings.get(&#39;pass_kwargs&#39;, [])
        more_args = ()
        for key in pass_kwargs:
            value = None
            if isinstance(key, tuple):
                key, value = key
            else:
                if key.startswith(&#39;temp_idx_arr&#39;):
                    value = np.empty((input_shape[0],), dtype=np.int_)
            value = func_kwargs.get(key, value)
            more_args += (value,)
        return more_args

    entry_more_args = _build_more_args(entry_settings, entry_kwargs)
    exit_more_args = _build_more_args(exit_settings, exit_kwargs)
    cache_more_args = _build_more_args(cache_settings, cache_kwargs)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _cache_in_output_list = cache_in_output_list
        _cache_param_list = cache_param_list
        if checks.is_numba_func(cache_func):
            if len(_cache_in_output_list) &gt; 0:
                _cache_in_output_list = [to_typed_list(in_outputs) for in_outputs in _cache_in_output_list]
            if len(_cache_param_list) &gt; 0:
                _cache_param_list = [to_typed_list(params) for params in _cache_param_list]

        cache = cache_func(
            *cache_input_tuple,
            *_cache_in_output_list,
            *_cache_param_list,
            *cache_args,
            *cache_more_args
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    entry_cache = ()
    exit_cache = ()
    if entry_settings.get(&#39;pass_cache&#39;, False):
        entry_cache = cache
    if exit_settings.get(&#39;pass_cache&#39;, False):
        exit_cache = cache

    # Apply and concatenate
    if exit_only and not iteratively:
        if len(exit_in_output_names) &gt; 0:
            if numba_loop:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = (exit_in_output_tuples,)
        else:
            _exit_in_output_tuples = ()
        if len(exit_param_names) &gt; 0:
            if numba_loop:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = (exit_param_tuples,)
        else:
            _exit_param_tuples = ()

        return apply_and_concat_func(
            n_params,
            apply_func,
            input_list[0],
            exit_wait,
            exit_input_tuple,
            *_exit_in_output_tuples,
            *_exit_param_tuples,
            exit_args + exit_more_args + exit_cache
        )

    else:
        if len(entry_in_output_names) &gt; 0:
            if numba_loop:
                _entry_in_output_tuples = (to_typed_list(entry_in_output_tuples),)
            else:
                _entry_in_output_tuples = (entry_in_output_tuples,)
        else:
            _entry_in_output_tuples = ()
        if len(entry_param_names) &gt; 0:
            if numba_loop:
                _entry_param_tuples = (to_typed_list(entry_param_tuples),)
            else:
                _entry_param_tuples = (entry_param_tuples,)
        else:
            _entry_param_tuples = ()
        if len(exit_in_output_names) &gt; 0:
            if numba_loop:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = (exit_in_output_tuples,)
        else:
            _exit_in_output_tuples = ()
        if len(exit_param_names) &gt; 0:
            if numba_loop:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = (exit_param_tuples,)
        else:
            _exit_param_tuples = ()

        return apply_and_concat_func(
            n_params,
            apply_func,
            input_shape,
            entry_wait,
            exit_wait,
            entry_input_tuple,
            exit_input_tuple,
            *_entry_in_output_tuples,
            *_exit_in_output_tuples,
            *_entry_param_tuples,
            *_exit_param_tuples,
            entry_args + entry_more_args + entry_cache,
            exit_args + exit_more_args + exit_cache
        )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.entries_and"><code class="name flex">
<span>def <span class="ident">entries_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.entries_or"><code class="name flex">
<span>def <span class="ident">entries_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.entries_xor"><code class="name flex">
<span>def <span class="ident">entries_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.exits_and"><code class="name flex">
<span>def <span class="ident">exits_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.exits_or"><code class="name flex">
<span>def <span class="ident">exits_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.exits_xor"><code class="name flex">
<span>def <span class="ident">exits_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.new_entries_and"><code class="name flex">
<span>def <span class="ident">new_entries_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.new_entries_or"><code class="name flex">
<span>def <span class="ident">new_entries_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.new_entries_xor"><code class="name flex">
<span>def <span class="ident">new_entries_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>_self, entry_y=None, exit_y=None, entry_types=None, exit_types=None, entry_trace_kwargs=None, exit_trace_kwargs=None, fig=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.signals.generators.ISTEX.new_entries" href="#vectorbt.signals.generators.ISTEX.new_entries">ISTEX.new_entries</a></code> and <code><a title="vectorbt.signals.generators.ISTEX.exits" href="#vectorbt.signals.generators.ISTEX.exits">ISTEX.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entry_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot entry markers on.</dd>
<dt><strong><code>exit_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot exit markers on.</dd>
<dt><strong><code>entry_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Entry types in string format.</dd>
<dt><strong><code>exit_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Exit types in string format.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers">SignalsSRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.generators.ISTEX.new_entries" href="#vectorbt.signals.generators.ISTEX.new_entries">ISTEX.new_entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers">SignalsSRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.generators.ISTEX.exits" href="#vectorbt.signals.generators.ISTEX.exits">ISTEX.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>Figure</code> or <code>FigureWidget</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers">SignalsSRAccessor.plot_as_markers()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(_self,
         entry_y: tp.Optional[tp.ArrayLike] = None,
         exit_y: tp.Optional[tp.ArrayLike] = None,
         entry_types: tp.Optional[tp.ArrayLikeSequence] = None,
         exit_types: tp.Optional[tp.ArrayLikeSequence] = None,
         entry_trace_kwargs: tp.KwargsLike = None,
         exit_trace_kwargs: tp.KwargsLike = None,
         fig: tp.Optional[tp.BaseFigure] = None,
         **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    if _self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if entry_trace_kwargs is None:
        entry_trace_kwargs = {}
    if exit_trace_kwargs is None:
        exit_trace_kwargs = {}
    if entry_types is not None:
        entry_types = np.asarray(entry_types)
        entry_trace_kwargs = merge_dicts(dict(
            customdata=entry_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), entry_trace_kwargs)
    if exit_types is not None:
        exit_types = np.asarray(exit_types)
        exit_trace_kwargs = merge_dicts(dict(
            customdata=exit_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), exit_trace_kwargs)
    if exit_only and iteratively:
        entries = _self.new_entries
    else:
        entries = _self.entries
    exits = _self.exits
    fig = entries.vbt.signals.plot_as_entry_markers(
        y=entry_y, trace_kwargs=entry_trace_kwargs, fig=fig, **kwargs)
    fig = exits.vbt.signals.plot_as_exit_markers(
        y=exit_y, trace_kwargs=exit_trace_kwargs, fig=fig, **kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.ts_above"><code class="name flex">
<span>def <span class="ident">ts_above</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.ts_below"><code class="name flex">
<span>def <span class="ident">ts_below</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.ISTEX.ts_equal"><code class="name flex">
<span>def <span class="ident">ts_equal</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX"><code class="flex name class">
<span>class <span class="ident">OHLCSTEX</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Advanced exit signal generator based on stop values.</p>
<p>Generates <code>exits</code> based on <code>entries</code> and <code><a title="vectorbt.signals.nb.ohlc_stop_choice_nb" href="nb.html#vectorbt.signals.nb.ohlc_stop_choice_nb">ohlc_stop_choice_nb()</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>All parameters can be either a single value (per frame) or a NumPy array (per row, column,
or element). To generate multiple combinations, pass them as lists.</p>
</div>
<h2 id="example">Example</h2>
<p>Test each stop type individually:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import pandas as pd

&gt;&gt;&gt; entries = pd.Series([True, False, False, False, False])
&gt;&gt;&gt; price = pd.DataFrame({
...     'open': [10, 11, 12, 11, 10],
...     'high': [11, 12, 13, 12, 11],
...     'low': [9, 10, 11, 10, 9],
...     'close': [10, 11, 12, 11, 10]
... })
&gt;&gt;&gt; ohlcstex = vbt.OHLCSTEX.run(
...     entries, price['open'], price['high'], price['low'], price['close'],
...     sl_stop=[0.1, 0., 0.], ts_stop=[0., 0.1, 0.], tp_stop=[0., 0., 0.1])

&gt;&gt;&gt; ohlcstex.entries
ohlcstex_sl_stop    0.1    0.0    0.0
ohlcstex_ts_stop    0.0    0.1    0.0
ohlcstex_tp_stop    0.0    0.0    0.1
0                  True   True   True
1                 False  False  False
2                 False  False  False
3                 False  False  False
4                 False  False  False

&gt;&gt;&gt; ohlcstex.exits
ohlcstex_sl_stop    0.1    0.0    0.0
ohlcstex_ts_stop    0.0    0.1    0.0
ohlcstex_tp_stop    0.0    0.0    0.1
0                 False  False  False
1                 False  False   True
2                 False  False  False
3                 False   True  False
4                  True  False  False

&gt;&gt;&gt; ohlcstex.hit_price
ohlcstex_sl_stop  0.1   0.0   0.0
ohlcstex_ts_stop  0.0   0.1   0.0
ohlcstex_tp_stop  0.0   0.0   0.1
0                 NaN   NaN   NaN
1                 NaN   NaN  11.0
2                 NaN   NaN   NaN
3                 NaN  11.7   NaN
4                 9.0   NaN   NaN

&gt;&gt;&gt; ohlcstex.stop_type_readable
ohlcstex_sl_stop       0.1        0.0         0.0
ohlcstex_ts_stop       0.0        0.1         0.0
ohlcstex_tp_stop       0.0        0.0         0.1
0
1                                      TakeProfit
2
3                           TrailStop
4                 StopLoss
</code></pre></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.signals.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.signals.generators._OHLCSTEX</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.generators.OHLCSTEX.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>entries, open, high, low, close, sl_stop=nan, ts_stop=nan, tp_stop=nan, hit_price=nan, stop_type=-1, short_name='ohlcstex', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.signals.generators.OHLCSTEX" href="#vectorbt.signals.generators.OHLCSTEX">OHLCSTEX</a></code> indicator.</p>
<ul>
<li>Inputs: <code>entries</code>, <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code></li>
<li>In-place outputs: <code>hit_price</code>, <code>stop_type</code></li>
<li>Parameters: <code>sl_stop</code>, <code>ts_stop</code>, <code>tp_stop</code></li>
<li>Outputs: <code>exits</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.run_combs"><code class="name flex">
<span>def <span class="ident">run_combs</span></span>(<span>entries, open, high, low, close, sl_stop=nan, ts_stop=nan, tp_stop=nan, hit_price=nan, stop_type=-1, r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.signals.generators.OHLCSTEX" href="#vectorbt.signals.generators.OHLCSTEX">OHLCSTEX</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>entries</code>, <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code></li>
<li>In-place outputs: <code>hit_price</code>, <code>stop_type</code></li>
<li>Parameters: <code>sl_stop</code>, <code>ts_stop</code>, <code>tp_stop</code></li>
<li>Outputs: <code>exits</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.generators.OHLCSTEX.run" href="#vectorbt.signals.generators.OHLCSTEX.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.generators.OHLCSTEX.close"><code class="name">var <span class="ident">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.entries"><code class="name">var <span class="ident">entries</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.exits"><code class="name">var <span class="ident">exits</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.high"><code class="name">var <span class="ident">high</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.hit_price"><code class="name">var <span class="ident">hit_price</span></code></dt>
<dd>
<div class="desc"><p>In-place output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.low"><code class="name">var <span class="ident">low</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.open"><code class="name">var <span class="ident">open</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.sl_stop_list"><code class="name">var <span class="ident">sl_stop_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>sl_stop</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.stop_type"><code class="name">var <span class="ident">stop_type</span></code></dt>
<dd>
<div class="desc"><p>In-place output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.stop_type_readable"><code class="name">var <span class="ident">stop_type_readable</span></code></dt>
<dd>
<div class="desc"><p>stop_type in readable format based on enum StopTypeT(StopLoss=0, TrailStop=1, TakeProfit=2).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_readable(self, _attr_name: str = attr_name, enum: tp.NamedTuple = dtype) -&gt; tp.SeriesFrame:
    if self.wrapper.ndim == 1:
        return getattr(self, _attr_name).map(lambda x: &#39;&#39; if x == -1 else enum._fields[x])
    return getattr(self, _attr_name).applymap(lambda x: &#39;&#39; if x == -1 else enum._fields[x])</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.tp_stop_list"><code class="name">var <span class="ident">tp_stop_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>tp_stop</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.ts_stop_list"><code class="name">var <span class="ident">ts_stop_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>ts_stop</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.generators.OHLCSTEX.close_above"><code class="name flex">
<span>def <span class="ident">close_above</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.close_below"><code class="name flex">
<span>def <span class="ident">close_below</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.close_equal"><code class="name flex">
<span>def <span class="ident">close_equal</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.custom_func"><code class="name flex">
<span>def <span class="ident">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, flex_2d=None, entry_args=None, exit_args=None, cache_args=None, entry_kwargs=None, exit_kwargs=None, cache_kwargs=None, return_cache=False, use_cache=None, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                flex_2d: tp.Optional[bool] = None,
                entry_args: tp.Optional[tp.Args] = None,
                exit_args: tp.Optional[tp.Args] = None,
                cache_args: tp.Optional[tp.Args] = None,
                entry_kwargs: tp.KwargsLike = None,
                exit_kwargs: tp.KwargsLike = None,
                cache_kwargs: tp.KwargsLike = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                **_kwargs) -&gt; tp.Union[CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    # Get arguments
    if len(input_list) == 0:
        if input_shape is None:
            raise ValueError(&#34;Pass input_shape if no input time series passed&#34;)
    else:
        input_shape = input_list[0].shape

    if entry_args is None:
        entry_args = ()
    if exit_args is None:
        exit_args = ()
    if cache_args is None:
        cache_args = ()
    if exit_only:
        if len(exit_args) &gt; 0:
            raise ValueError(&#34;Use *args instead of exit_args when exit_only=True&#34;)
        exit_args = args
    else:
        if len(args) &gt; 0:
            raise ValueError(&#34;*args can be only used when exit_only=True&#34;)

    if entry_kwargs is None:
        entry_kwargs = {}
    if exit_kwargs is None:
        exit_kwargs = {}
    if cache_kwargs is None:
        cache_kwargs = {}
    if exit_only:
        if len(exit_kwargs) &gt; 0:
            raise ValueError(&#34;Use **kwargs instead of exit_kwargs when exit_only=True&#34;)
        exit_kwargs = _kwargs
    else:
        if len(_kwargs) &gt; 0:
            raise ValueError(&#34;**kwargs can be only used when exit_only=True&#34;)

    kwargs_defaults = dict(
        input_shape=input_shape,
        wait=1,
        first=True,
        flex_2d=flex_2d,
    )
    entry_kwargs = merge_dicts(kwargs_defaults, entry_kwargs)
    exit_kwargs = merge_dicts(kwargs_defaults, exit_kwargs)
    cache_kwargs = merge_dicts(kwargs_defaults, cache_kwargs)
    entry_wait = entry_kwargs[&#39;wait&#39;]
    exit_wait = exit_kwargs[&#39;wait&#39;]

    # Distribute arguments across functions
    entry_input_tuple = ()
    exit_input_tuple = ()
    cache_input_tuple = ()
    for input_name in entry_input_names:
        entry_input_tuple += (input_list[input_names.index(input_name)],)
    for input_name in exit_input_names:
        exit_input_tuple += (input_list[input_names.index(input_name)],)
    for input_name in cache_input_names:
        cache_input_tuple += (input_list[input_names.index(input_name)],)

    entry_in_output_list = []
    exit_in_output_list = []
    cache_in_output_list = []
    for in_output_name in entry_in_output_names:
        entry_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
    for in_output_name in exit_in_output_names:
        exit_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
    for in_output_name in cache_in_output_names:
        cache_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])

    entry_param_list = []
    exit_param_list = []
    cache_param_list = []
    for param_name in entry_param_names:
        entry_param_list.append(param_list[param_names.index(param_name)])
    for param_name in exit_param_names:
        exit_param_list.append(param_list[param_names.index(param_name)])
    for param_name in cache_param_names:
        cache_param_list.append(param_list[param_names.index(param_name)])

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    entry_in_output_tuples = list(zip(*entry_in_output_list))
    exit_in_output_tuples = list(zip(*exit_in_output_list))
    entry_param_tuples = list(zip(*entry_param_list))
    exit_param_tuples = list(zip(*exit_param_list))

    def _build_more_args(func_settings: tp.Kwargs, func_kwargs: tp.Kwargs) -&gt; tp.Args:
        pass_kwargs = func_settings.get(&#39;pass_kwargs&#39;, [])
        more_args = ()
        for key in pass_kwargs:
            value = None
            if isinstance(key, tuple):
                key, value = key
            else:
                if key.startswith(&#39;temp_idx_arr&#39;):
                    value = np.empty((input_shape[0],), dtype=np.int_)
            value = func_kwargs.get(key, value)
            more_args += (value,)
        return more_args

    entry_more_args = _build_more_args(entry_settings, entry_kwargs)
    exit_more_args = _build_more_args(exit_settings, exit_kwargs)
    cache_more_args = _build_more_args(cache_settings, cache_kwargs)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _cache_in_output_list = cache_in_output_list
        _cache_param_list = cache_param_list
        if checks.is_numba_func(cache_func):
            if len(_cache_in_output_list) &gt; 0:
                _cache_in_output_list = [to_typed_list(in_outputs) for in_outputs in _cache_in_output_list]
            if len(_cache_param_list) &gt; 0:
                _cache_param_list = [to_typed_list(params) for params in _cache_param_list]

        cache = cache_func(
            *cache_input_tuple,
            *_cache_in_output_list,
            *_cache_param_list,
            *cache_args,
            *cache_more_args
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    entry_cache = ()
    exit_cache = ()
    if entry_settings.get(&#39;pass_cache&#39;, False):
        entry_cache = cache
    if exit_settings.get(&#39;pass_cache&#39;, False):
        exit_cache = cache

    # Apply and concatenate
    if exit_only and not iteratively:
        if len(exit_in_output_names) &gt; 0:
            if numba_loop:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = (exit_in_output_tuples,)
        else:
            _exit_in_output_tuples = ()
        if len(exit_param_names) &gt; 0:
            if numba_loop:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = (exit_param_tuples,)
        else:
            _exit_param_tuples = ()

        return apply_and_concat_func(
            n_params,
            apply_func,
            input_list[0],
            exit_wait,
            exit_input_tuple,
            *_exit_in_output_tuples,
            *_exit_param_tuples,
            exit_args + exit_more_args + exit_cache
        )

    else:
        if len(entry_in_output_names) &gt; 0:
            if numba_loop:
                _entry_in_output_tuples = (to_typed_list(entry_in_output_tuples),)
            else:
                _entry_in_output_tuples = (entry_in_output_tuples,)
        else:
            _entry_in_output_tuples = ()
        if len(entry_param_names) &gt; 0:
            if numba_loop:
                _entry_param_tuples = (to_typed_list(entry_param_tuples),)
            else:
                _entry_param_tuples = (entry_param_tuples,)
        else:
            _entry_param_tuples = ()
        if len(exit_in_output_names) &gt; 0:
            if numba_loop:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = (exit_in_output_tuples,)
        else:
            _exit_in_output_tuples = ()
        if len(exit_param_names) &gt; 0:
            if numba_loop:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = (exit_param_tuples,)
        else:
            _exit_param_tuples = ()

        return apply_and_concat_func(
            n_params,
            apply_func,
            input_shape,
            entry_wait,
            exit_wait,
            entry_input_tuple,
            exit_input_tuple,
            *_entry_in_output_tuples,
            *_exit_in_output_tuples,
            *_entry_param_tuples,
            *_exit_param_tuples,
            entry_args + entry_more_args + entry_cache,
            exit_args + exit_more_args + exit_cache
        )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.entries_and"><code class="name flex">
<span>def <span class="ident">entries_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.entries_or"><code class="name flex">
<span>def <span class="ident">entries_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.entries_xor"><code class="name flex">
<span>def <span class="ident">entries_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.exits_and"><code class="name flex">
<span>def <span class="ident">exits_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.exits_or"><code class="name flex">
<span>def <span class="ident">exits_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.exits_xor"><code class="name flex">
<span>def <span class="ident">exits_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.high_above"><code class="name flex">
<span>def <span class="ident">high_above</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.high_below"><code class="name flex">
<span>def <span class="ident">high_below</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.high_equal"><code class="name flex">
<span>def <span class="ident">high_equal</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.hit_price_above"><code class="name flex">
<span>def <span class="ident">hit_price_above</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hit_price</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hit_price</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.hit_price_below"><code class="name flex">
<span>def <span class="ident">hit_price_below</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hit_price</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hit_price</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.hit_price_equal"><code class="name flex">
<span>def <span class="ident">hit_price_equal</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hit_price</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hit_price</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.low_above"><code class="name flex">
<span>def <span class="ident">low_above</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.low_below"><code class="name flex">
<span>def <span class="ident">low_below</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.low_equal"><code class="name flex">
<span>def <span class="ident">low_equal</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.open_above"><code class="name flex">
<span>def <span class="ident">open_above</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>open</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>open</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.open_below"><code class="name flex">
<span>def <span class="ident">open_below</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>open</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>open</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.open_equal"><code class="name flex">
<span>def <span class="ident">open_equal</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>open</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>open</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.OHLCSTEX.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, plot_type=None, ohlc_kwargs=None, entry_trace_kwargs=None, exit_trace_kwargs=None, add_trace_kwargs=None, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot OHLC, <code><a title="vectorbt.signals.generators.OHLCSTEX.entries" href="#vectorbt.signals.generators.OHLCSTEX.entries">OHLCSTEX.entries</a></code> and <code><a title="vectorbt.signals.generators.OHLCSTEX.exits" href="#vectorbt.signals.generators.OHLCSTEX.exits">OHLCSTEX.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plot_type</code></strong></dt>
<dd>Either 'OHLC', 'Candlestick' or Plotly trace.</dd>
<dt><strong><code>ohlc_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plot_type</code>.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers">SignalsSRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.generators.OHLCSTEX.entries" href="#vectorbt.signals.generators.OHLCSTEX.entries">OHLCSTEX.entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers">SignalsSRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.generators.OHLCSTEX.exits" href="#vectorbt.signals.generators.OHLCSTEX.exits">OHLCSTEX.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>Figure</code> or <code>FigureWidget</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ohlcstex.iloc[:, 0].plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/ohlcstex.svg"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         plot_type: tp.Union[None, str, tp.BaseTraceType] = None,
         ohlc_kwargs: tp.KwargsLike = None,
         entry_trace_kwargs: tp.KwargsLike = None,
         exit_trace_kwargs: tp.KwargsLike = None,
         add_trace_kwargs: tp.KwargsLike = None,
         fig: tp.Optional[tp.BaseFigure] = None,
         _base_cls_plot: tp.Callable = base_cls_plot,
         **layout_kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    from vectorbt._settings import settings
    ohlcv_cfg = settings[&#39;ohlcv&#39;]
    plotting_cfg = settings[&#39;plotting&#39;]

    if self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if ohlc_kwargs is None:
        ohlc_kwargs = {}
    if add_trace_kwargs is None:
        add_trace_kwargs = {}

    if fig is None:
        fig = make_figure()
        fig.update_layout(
            showlegend=True,
            xaxis_rangeslider_visible=False,
            xaxis_showgrid=True,
            yaxis_showgrid=True
        )
    fig.update_layout(**layout_kwargs)

    if plot_type is None:
        plot_type = ohlcv_cfg[&#39;plot_type&#39;]
    if isinstance(plot_type, str):
        if plot_type.lower() == &#39;ohlc&#39;:
            plot_type = &#39;OHLC&#39;
            plot_obj = go.Ohlc
        elif plot_type.lower() == &#39;candlestick&#39;:
            plot_type = &#39;Candlestick&#39;
            plot_obj = go.Candlestick
        else:
            raise ValueError(&#34;Plot type can be either &#39;OHLC&#39; or &#39;Candlestick&#39;&#34;)
    else:
        plot_obj = plot_type
    ohlc = plot_obj(
        x=self.wrapper.index,
        open=self.open,
        high=self.high,
        low=self.low,
        close=self.close,
        name=plot_type,
        increasing_line_color=plotting_cfg[&#39;color_schema&#39;][&#39;increasing&#39;],
        decreasing_line_color=plotting_cfg[&#39;color_schema&#39;][&#39;decreasing&#39;]
    )
    ohlc.update(**ohlc_kwargs)
    fig.add_trace(ohlc, **add_trace_kwargs)

    # Plot entry and exit markers
    _base_cls_plot(
        self,
        entry_y=self.open,
        exit_y=self.hit_price,
        exit_types=self.stop_type_readable,
        entry_trace_kwargs=entry_trace_kwargs,
        exit_trace_kwargs=exit_trace_kwargs,
        add_trace_kwargs=add_trace_kwargs,
        fig=fig
    )
    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.generators.RAND"><code class="flex name class">
<span>class <span class="ident">RAND</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Random entry and exit signal generator based on the number of signals.</p>
<p>Generates <code>entries</code> and <code>exits</code> based on <code><a title="vectorbt.signals.nb.rand_enex_apply_nb" href="nb.html#vectorbt.signals.nb.rand_enex_apply_nb">rand_enex_apply_nb()</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Parameter <code>n</code> can be either a single value (per frame) or a NumPy array (per column).
To generate multiple combinations, pass it as a list.</p>
</div>
<h2 id="example">Example</h2>
<p>Test three different <code>n</code> values:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; rand = vbt.RAND.run(
...     input_shape=(6,),
...     n=[1, 2, 3],
...     seed=42)

&gt;&gt;&gt; rand.entries
rand_n      1      2      3
0        True   True   True
1       False  False  False
2       False   True   True
3       False  False  False
4       False  False   True
5       False  False  False

&gt;&gt;&gt; rand.exits
rand_n      1      2      3
0       False  False  False
1        True   True   True
2       False  False  False
3       False   True   True
4       False  False  False
5       False  False   True
</code></pre>
<p><code>n</code> can also be set per column:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np

&gt;&gt;&gt; rand = vbt.RAND.run(
...     input_shape=(8, 2),
...     n=[np.array([1, 2]), 3],
...     seed=42)

&gt;&gt;&gt; rand.entries
rand_n      1      2             3
            0      1      0      1
0       False   True   True   True
1        True  False  False  False
2       False  False  False  False
3       False  False   True  False
4       False   True  False   True
5       False  False   True  False
6       False  False  False   True
7       False  False  False  False

&gt;&gt;&gt; rand.exits
rand_n      1      2             3
            0      1      0      1
0       False  False  False  False
1       False  False   True  False
2       False  False  False   True
3       False   True  False  False
4       False  False   True  False
5        True  False  False   True
6       False  False   True  False
7       False   True  False   True
</code></pre></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.signals.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.signals.generators._RAND</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.generators.RAND.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>input_shape, n, short_name='rand', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.signals.generators.RAND" href="#vectorbt.signals.generators.RAND">RAND</a></code> indicator.</p>
<ul>
<li>Parameters: <code>n</code></li>
<li>Outputs: <code>entries</code>, <code>exits</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RAND.run_combs"><code class="name flex">
<span>def <span class="ident">run_combs</span></span>(<span>input_shape, n, r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.signals.generators.RAND" href="#vectorbt.signals.generators.RAND">RAND</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Parameters: <code>n</code></li>
<li>Outputs: <code>entries</code>, <code>exits</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.generators.RAND.run" href="#vectorbt.signals.generators.RAND.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.generators.RAND.entries"><code class="name">var <span class="ident">entries</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RAND.exits"><code class="name">var <span class="ident">exits</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RAND.n_list"><code class="name">var <span class="ident">n_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>n</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.generators.RAND.apply_func"><code class="name flex">
<span>def <span class="ident">apply_func</span></span>(<span>input_shape, n, entry_wait, exit_wait)</span>
</code></dt>
<dd>
<div class="desc"><p><code>apply_func_nb</code> that calls <code>generate_rand_enex_nb</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rand_enex_apply_nb(input_shape: tp.Shape,
                       n: tp.MaybeArray[int],
                       entry_wait: int,
                       exit_wait: int) -&gt; tp.Tuple[tp.Array2d, tp.Array2d]:
    &#34;&#34;&#34;`apply_func_nb` that calls `generate_rand_enex_nb`.&#34;&#34;&#34;
    return generate_rand_enex_nb(input_shape, n, entry_wait, exit_wait)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RAND.custom_func"><code class="name flex">
<span>def <span class="ident">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                col: tp.Optional[int] = None,
                flex_2d: tp.Optional[bool] = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                use_ray: bool = False,
                **_kwargs) -&gt; tp.Union[None, CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RAND.entries_and"><code class="name flex">
<span>def <span class="ident">entries_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RAND.entries_or"><code class="name flex">
<span>def <span class="ident">entries_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RAND.entries_xor"><code class="name flex">
<span>def <span class="ident">entries_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RAND.exits_and"><code class="name flex">
<span>def <span class="ident">exits_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RAND.exits_or"><code class="name flex">
<span>def <span class="ident">exits_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RAND.exits_xor"><code class="name flex">
<span>def <span class="ident">exits_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RAND.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>_self, entry_y=None, exit_y=None, entry_types=None, exit_types=None, entry_trace_kwargs=None, exit_trace_kwargs=None, fig=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.signals.generators.RAND.entries" href="#vectorbt.signals.generators.RAND.entries">RAND.entries</a></code> and <code><a title="vectorbt.signals.generators.RAND.exits" href="#vectorbt.signals.generators.RAND.exits">RAND.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entry_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot entry markers on.</dd>
<dt><strong><code>exit_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot exit markers on.</dd>
<dt><strong><code>entry_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Entry types in string format.</dd>
<dt><strong><code>exit_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Exit types in string format.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers">SignalsSRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.generators.RAND.entries" href="#vectorbt.signals.generators.RAND.entries">RAND.entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers">SignalsSRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.generators.RAND.exits" href="#vectorbt.signals.generators.RAND.exits">RAND.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>Figure</code> or <code>FigureWidget</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers">SignalsSRAccessor.plot_as_markers()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(_self,
         entry_y: tp.Optional[tp.ArrayLike] = None,
         exit_y: tp.Optional[tp.ArrayLike] = None,
         entry_types: tp.Optional[tp.ArrayLikeSequence] = None,
         exit_types: tp.Optional[tp.ArrayLikeSequence] = None,
         entry_trace_kwargs: tp.KwargsLike = None,
         exit_trace_kwargs: tp.KwargsLike = None,
         fig: tp.Optional[tp.BaseFigure] = None,
         **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    if _self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if entry_trace_kwargs is None:
        entry_trace_kwargs = {}
    if exit_trace_kwargs is None:
        exit_trace_kwargs = {}
    if entry_types is not None:
        entry_types = np.asarray(entry_types)
        entry_trace_kwargs = merge_dicts(dict(
            customdata=entry_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), entry_trace_kwargs)
    if exit_types is not None:
        exit_types = np.asarray(exit_types)
        exit_trace_kwargs = merge_dicts(dict(
            customdata=exit_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), exit_trace_kwargs)
    if exit_only and iteratively:
        entries = _self.new_entries
    else:
        entries = _self.entries
    exits = _self.exits
    fig = entries.vbt.signals.plot_as_entry_markers(
        y=entry_y, trace_kwargs=entry_trace_kwargs, fig=fig, **kwargs)
    fig = exits.vbt.signals.plot_as_exit_markers(
        y=exit_y, trace_kwargs=exit_trace_kwargs, fig=fig, **kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.generators.RPROB"><code class="flex name class">
<span>class <span class="ident">RPROB</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Random entry and exit signal generator based on probabilities.</p>
<p>Generates <code>entries</code> and <code>exits</code> based on <code><a title="vectorbt.signals.nb.rand_by_prob_choice_nb" href="nb.html#vectorbt.signals.nb.rand_by_prob_choice_nb">rand_by_prob_choice_nb()</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>All parameters can be either a single value (per frame) or a NumPy array (per row, column,
or element). To generate multiple combinations, pass them as lists.</p>
</div>
<h2 id="example">Example</h2>
<p>Test all probability combinations:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; rprob = vbt.RPROB.run(
...     input_shape=(5,),
...     entry_prob=[0.5, 1.],
...     exit_prob=[0.5, 1.],
...     param_product=True,
...     seed=42)

&gt;&gt;&gt; rprob.entries
rprob_entry_prob           0.5           1.0
rprob_exit_prob     0.5    1.0    0.5    1.0
0                  True   True   True   True
1                 False  False  False  False
2                 False  False  False   True
3                 False  False  False  False
4                 False  False   True   True

&gt;&gt;&gt; rprob.exits
rprob_entry_prob           0.5           1.0
rprob_exit_prob     0.5    1.0    0.5    1.0
0                 False  False  False  False
1                 False   True  False   True
2                 False  False  False  False
3                 False  False   True   True
4                  True  False  False  False
</code></pre>
<p><code>entry_prob</code> and <code>exit_prob</code> can also be set per row, column, or element:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np

&gt;&gt;&gt; entry_prob1 = np.asarray([1., 0., 1., 0., 1.])
&gt;&gt;&gt; entry_prob2 = np.asarray([0., 1., 0., 1., 0.])
&gt;&gt;&gt; rprob = vbt.RPROB.run(
...     input_shape=(5,),
...     entry_prob=[entry_prob1, entry_prob2],
...     exit_prob=1.,
...     seed=42)

&gt;&gt;&gt; rprob.entries
rprob_entry_prob array_0 array_1
rprob_exit_prob      1.0     1.0
0                   True   False
1                  False    True
2                   True   False
3                  False    True
4                   True   False

&gt;&gt;&gt; rprob.exits
rprob_entry_prob array_0 array_1
rprob_exit_prob      1.0     1.0
0                  False   False
1                   True   False
2                  False    True
3                   True   False
4                  False    True
</code></pre></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.signals.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.signals.generators._RPROB</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.generators.RPROB.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>input_shape, entry_prob, exit_prob, short_name='rprob', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.signals.generators.RPROB" href="#vectorbt.signals.generators.RPROB">RPROB</a></code> indicator.</p>
<ul>
<li>Parameters: <code>entry_prob</code>, <code>exit_prob</code></li>
<li>Outputs: <code>entries</code>, <code>exits</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROB.run_combs"><code class="name flex">
<span>def <span class="ident">run_combs</span></span>(<span>input_shape, entry_prob, exit_prob, r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.signals.generators.RPROB" href="#vectorbt.signals.generators.RPROB">RPROB</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Parameters: <code>entry_prob</code>, <code>exit_prob</code></li>
<li>Outputs: <code>entries</code>, <code>exits</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.generators.RPROB.run" href="#vectorbt.signals.generators.RPROB.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.generators.RPROB.entries"><code class="name">var <span class="ident">entries</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROB.entry_prob_list"><code class="name">var <span class="ident">entry_prob_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>entry_prob</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROB.exit_prob_list"><code class="name">var <span class="ident">exit_prob_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>exit_prob</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROB.exits"><code class="name">var <span class="ident">exits</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.generators.RPROB.custom_func"><code class="name flex">
<span>def <span class="ident">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, flex_2d=None, entry_args=None, exit_args=None, cache_args=None, entry_kwargs=None, exit_kwargs=None, cache_kwargs=None, return_cache=False, use_cache=None, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                flex_2d: tp.Optional[bool] = None,
                entry_args: tp.Optional[tp.Args] = None,
                exit_args: tp.Optional[tp.Args] = None,
                cache_args: tp.Optional[tp.Args] = None,
                entry_kwargs: tp.KwargsLike = None,
                exit_kwargs: tp.KwargsLike = None,
                cache_kwargs: tp.KwargsLike = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                **_kwargs) -&gt; tp.Union[CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    # Get arguments
    if len(input_list) == 0:
        if input_shape is None:
            raise ValueError(&#34;Pass input_shape if no input time series passed&#34;)
    else:
        input_shape = input_list[0].shape

    if entry_args is None:
        entry_args = ()
    if exit_args is None:
        exit_args = ()
    if cache_args is None:
        cache_args = ()
    if exit_only:
        if len(exit_args) &gt; 0:
            raise ValueError(&#34;Use *args instead of exit_args when exit_only=True&#34;)
        exit_args = args
    else:
        if len(args) &gt; 0:
            raise ValueError(&#34;*args can be only used when exit_only=True&#34;)

    if entry_kwargs is None:
        entry_kwargs = {}
    if exit_kwargs is None:
        exit_kwargs = {}
    if cache_kwargs is None:
        cache_kwargs = {}
    if exit_only:
        if len(exit_kwargs) &gt; 0:
            raise ValueError(&#34;Use **kwargs instead of exit_kwargs when exit_only=True&#34;)
        exit_kwargs = _kwargs
    else:
        if len(_kwargs) &gt; 0:
            raise ValueError(&#34;**kwargs can be only used when exit_only=True&#34;)

    kwargs_defaults = dict(
        input_shape=input_shape,
        wait=1,
        first=True,
        flex_2d=flex_2d,
    )
    entry_kwargs = merge_dicts(kwargs_defaults, entry_kwargs)
    exit_kwargs = merge_dicts(kwargs_defaults, exit_kwargs)
    cache_kwargs = merge_dicts(kwargs_defaults, cache_kwargs)
    entry_wait = entry_kwargs[&#39;wait&#39;]
    exit_wait = exit_kwargs[&#39;wait&#39;]

    # Distribute arguments across functions
    entry_input_tuple = ()
    exit_input_tuple = ()
    cache_input_tuple = ()
    for input_name in entry_input_names:
        entry_input_tuple += (input_list[input_names.index(input_name)],)
    for input_name in exit_input_names:
        exit_input_tuple += (input_list[input_names.index(input_name)],)
    for input_name in cache_input_names:
        cache_input_tuple += (input_list[input_names.index(input_name)],)

    entry_in_output_list = []
    exit_in_output_list = []
    cache_in_output_list = []
    for in_output_name in entry_in_output_names:
        entry_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
    for in_output_name in exit_in_output_names:
        exit_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
    for in_output_name in cache_in_output_names:
        cache_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])

    entry_param_list = []
    exit_param_list = []
    cache_param_list = []
    for param_name in entry_param_names:
        entry_param_list.append(param_list[param_names.index(param_name)])
    for param_name in exit_param_names:
        exit_param_list.append(param_list[param_names.index(param_name)])
    for param_name in cache_param_names:
        cache_param_list.append(param_list[param_names.index(param_name)])

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    entry_in_output_tuples = list(zip(*entry_in_output_list))
    exit_in_output_tuples = list(zip(*exit_in_output_list))
    entry_param_tuples = list(zip(*entry_param_list))
    exit_param_tuples = list(zip(*exit_param_list))

    def _build_more_args(func_settings: tp.Kwargs, func_kwargs: tp.Kwargs) -&gt; tp.Args:
        pass_kwargs = func_settings.get(&#39;pass_kwargs&#39;, [])
        more_args = ()
        for key in pass_kwargs:
            value = None
            if isinstance(key, tuple):
                key, value = key
            else:
                if key.startswith(&#39;temp_idx_arr&#39;):
                    value = np.empty((input_shape[0],), dtype=np.int_)
            value = func_kwargs.get(key, value)
            more_args += (value,)
        return more_args

    entry_more_args = _build_more_args(entry_settings, entry_kwargs)
    exit_more_args = _build_more_args(exit_settings, exit_kwargs)
    cache_more_args = _build_more_args(cache_settings, cache_kwargs)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _cache_in_output_list = cache_in_output_list
        _cache_param_list = cache_param_list
        if checks.is_numba_func(cache_func):
            if len(_cache_in_output_list) &gt; 0:
                _cache_in_output_list = [to_typed_list(in_outputs) for in_outputs in _cache_in_output_list]
            if len(_cache_param_list) &gt; 0:
                _cache_param_list = [to_typed_list(params) for params in _cache_param_list]

        cache = cache_func(
            *cache_input_tuple,
            *_cache_in_output_list,
            *_cache_param_list,
            *cache_args,
            *cache_more_args
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    entry_cache = ()
    exit_cache = ()
    if entry_settings.get(&#39;pass_cache&#39;, False):
        entry_cache = cache
    if exit_settings.get(&#39;pass_cache&#39;, False):
        exit_cache = cache

    # Apply and concatenate
    if exit_only and not iteratively:
        if len(exit_in_output_names) &gt; 0:
            if numba_loop:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = (exit_in_output_tuples,)
        else:
            _exit_in_output_tuples = ()
        if len(exit_param_names) &gt; 0:
            if numba_loop:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = (exit_param_tuples,)
        else:
            _exit_param_tuples = ()

        return apply_and_concat_func(
            n_params,
            apply_func,
            input_list[0],
            exit_wait,
            exit_input_tuple,
            *_exit_in_output_tuples,
            *_exit_param_tuples,
            exit_args + exit_more_args + exit_cache
        )

    else:
        if len(entry_in_output_names) &gt; 0:
            if numba_loop:
                _entry_in_output_tuples = (to_typed_list(entry_in_output_tuples),)
            else:
                _entry_in_output_tuples = (entry_in_output_tuples,)
        else:
            _entry_in_output_tuples = ()
        if len(entry_param_names) &gt; 0:
            if numba_loop:
                _entry_param_tuples = (to_typed_list(entry_param_tuples),)
            else:
                _entry_param_tuples = (entry_param_tuples,)
        else:
            _entry_param_tuples = ()
        if len(exit_in_output_names) &gt; 0:
            if numba_loop:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = (exit_in_output_tuples,)
        else:
            _exit_in_output_tuples = ()
        if len(exit_param_names) &gt; 0:
            if numba_loop:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = (exit_param_tuples,)
        else:
            _exit_param_tuples = ()

        return apply_and_concat_func(
            n_params,
            apply_func,
            input_shape,
            entry_wait,
            exit_wait,
            entry_input_tuple,
            exit_input_tuple,
            *_entry_in_output_tuples,
            *_exit_in_output_tuples,
            *_entry_param_tuples,
            *_exit_param_tuples,
            entry_args + entry_more_args + entry_cache,
            exit_args + exit_more_args + exit_cache
        )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROB.entries_and"><code class="name flex">
<span>def <span class="ident">entries_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROB.entries_or"><code class="name flex">
<span>def <span class="ident">entries_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROB.entries_xor"><code class="name flex">
<span>def <span class="ident">entries_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROB.exits_and"><code class="name flex">
<span>def <span class="ident">exits_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROB.exits_or"><code class="name flex">
<span>def <span class="ident">exits_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROB.exits_xor"><code class="name flex">
<span>def <span class="ident">exits_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROB.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>_self, entry_y=None, exit_y=None, entry_types=None, exit_types=None, entry_trace_kwargs=None, exit_trace_kwargs=None, fig=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.signals.generators.RPROB.entries" href="#vectorbt.signals.generators.RPROB.entries">RPROB.entries</a></code> and <code><a title="vectorbt.signals.generators.RPROB.exits" href="#vectorbt.signals.generators.RPROB.exits">RPROB.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entry_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot entry markers on.</dd>
<dt><strong><code>exit_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot exit markers on.</dd>
<dt><strong><code>entry_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Entry types in string format.</dd>
<dt><strong><code>exit_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Exit types in string format.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers">SignalsSRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.generators.RPROB.entries" href="#vectorbt.signals.generators.RPROB.entries">RPROB.entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers">SignalsSRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.generators.RPROB.exits" href="#vectorbt.signals.generators.RPROB.exits">RPROB.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>Figure</code> or <code>FigureWidget</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers">SignalsSRAccessor.plot_as_markers()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(_self,
         entry_y: tp.Optional[tp.ArrayLike] = None,
         exit_y: tp.Optional[tp.ArrayLike] = None,
         entry_types: tp.Optional[tp.ArrayLikeSequence] = None,
         exit_types: tp.Optional[tp.ArrayLikeSequence] = None,
         entry_trace_kwargs: tp.KwargsLike = None,
         exit_trace_kwargs: tp.KwargsLike = None,
         fig: tp.Optional[tp.BaseFigure] = None,
         **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    if _self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if entry_trace_kwargs is None:
        entry_trace_kwargs = {}
    if exit_trace_kwargs is None:
        exit_trace_kwargs = {}
    if entry_types is not None:
        entry_types = np.asarray(entry_types)
        entry_trace_kwargs = merge_dicts(dict(
            customdata=entry_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), entry_trace_kwargs)
    if exit_types is not None:
        exit_types = np.asarray(exit_types)
        exit_trace_kwargs = merge_dicts(dict(
            customdata=exit_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), exit_trace_kwargs)
    if exit_only and iteratively:
        entries = _self.new_entries
    else:
        entries = _self.entries
    exits = _self.exits
    fig = entries.vbt.signals.plot_as_entry_markers(
        y=entry_y, trace_kwargs=entry_trace_kwargs, fig=fig, **kwargs)
    fig = exits.vbt.signals.plot_as_exit_markers(
        y=exit_y, trace_kwargs=exit_trace_kwargs, fig=fig, **kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.generators.RPROBEX"><code class="flex name class">
<span>class <span class="ident">RPROBEX</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Random exit signal generator based on probabilities.</p>
<p>Generates <code>exits</code> based on <code>entries</code> and <code><a title="vectorbt.signals.nb.rand_by_prob_choice_nb" href="nb.html#vectorbt.signals.nb.rand_by_prob_choice_nb">rand_by_prob_choice_nb()</a></code>.</p>
<p>See <code><a title="vectorbt.signals.generators.RPROB" href="#vectorbt.signals.generators.RPROB">RPROB</a></code> for notes on parameters.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.signals.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.signals.generators._RPROBEX</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.generators.RPROBEX.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>entries, prob, short_name='rprobex', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.signals.generators.RPROBEX" href="#vectorbt.signals.generators.RPROBEX">RPROBEX</a></code> indicator.</p>
<ul>
<li>Inputs: <code>entries</code></li>
<li>Parameters: <code>prob</code></li>
<li>Outputs: <code>exits</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROBEX.run_combs"><code class="name flex">
<span>def <span class="ident">run_combs</span></span>(<span>entries, prob, r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.signals.generators.RPROBEX" href="#vectorbt.signals.generators.RPROBEX">RPROBEX</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>entries</code></li>
<li>Parameters: <code>prob</code></li>
<li>Outputs: <code>exits</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.generators.RPROBEX.run" href="#vectorbt.signals.generators.RPROBEX.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.generators.RPROBEX.entries"><code class="name">var <span class="ident">entries</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROBEX.exits"><code class="name">var <span class="ident">exits</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROBEX.prob_list"><code class="name">var <span class="ident">prob_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>prob</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.generators.RPROBEX.custom_func"><code class="name flex">
<span>def <span class="ident">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, flex_2d=None, entry_args=None, exit_args=None, cache_args=None, entry_kwargs=None, exit_kwargs=None, cache_kwargs=None, return_cache=False, use_cache=None, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                flex_2d: tp.Optional[bool] = None,
                entry_args: tp.Optional[tp.Args] = None,
                exit_args: tp.Optional[tp.Args] = None,
                cache_args: tp.Optional[tp.Args] = None,
                entry_kwargs: tp.KwargsLike = None,
                exit_kwargs: tp.KwargsLike = None,
                cache_kwargs: tp.KwargsLike = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                **_kwargs) -&gt; tp.Union[CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    # Get arguments
    if len(input_list) == 0:
        if input_shape is None:
            raise ValueError(&#34;Pass input_shape if no input time series passed&#34;)
    else:
        input_shape = input_list[0].shape

    if entry_args is None:
        entry_args = ()
    if exit_args is None:
        exit_args = ()
    if cache_args is None:
        cache_args = ()
    if exit_only:
        if len(exit_args) &gt; 0:
            raise ValueError(&#34;Use *args instead of exit_args when exit_only=True&#34;)
        exit_args = args
    else:
        if len(args) &gt; 0:
            raise ValueError(&#34;*args can be only used when exit_only=True&#34;)

    if entry_kwargs is None:
        entry_kwargs = {}
    if exit_kwargs is None:
        exit_kwargs = {}
    if cache_kwargs is None:
        cache_kwargs = {}
    if exit_only:
        if len(exit_kwargs) &gt; 0:
            raise ValueError(&#34;Use **kwargs instead of exit_kwargs when exit_only=True&#34;)
        exit_kwargs = _kwargs
    else:
        if len(_kwargs) &gt; 0:
            raise ValueError(&#34;**kwargs can be only used when exit_only=True&#34;)

    kwargs_defaults = dict(
        input_shape=input_shape,
        wait=1,
        first=True,
        flex_2d=flex_2d,
    )
    entry_kwargs = merge_dicts(kwargs_defaults, entry_kwargs)
    exit_kwargs = merge_dicts(kwargs_defaults, exit_kwargs)
    cache_kwargs = merge_dicts(kwargs_defaults, cache_kwargs)
    entry_wait = entry_kwargs[&#39;wait&#39;]
    exit_wait = exit_kwargs[&#39;wait&#39;]

    # Distribute arguments across functions
    entry_input_tuple = ()
    exit_input_tuple = ()
    cache_input_tuple = ()
    for input_name in entry_input_names:
        entry_input_tuple += (input_list[input_names.index(input_name)],)
    for input_name in exit_input_names:
        exit_input_tuple += (input_list[input_names.index(input_name)],)
    for input_name in cache_input_names:
        cache_input_tuple += (input_list[input_names.index(input_name)],)

    entry_in_output_list = []
    exit_in_output_list = []
    cache_in_output_list = []
    for in_output_name in entry_in_output_names:
        entry_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
    for in_output_name in exit_in_output_names:
        exit_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
    for in_output_name in cache_in_output_names:
        cache_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])

    entry_param_list = []
    exit_param_list = []
    cache_param_list = []
    for param_name in entry_param_names:
        entry_param_list.append(param_list[param_names.index(param_name)])
    for param_name in exit_param_names:
        exit_param_list.append(param_list[param_names.index(param_name)])
    for param_name in cache_param_names:
        cache_param_list.append(param_list[param_names.index(param_name)])

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    entry_in_output_tuples = list(zip(*entry_in_output_list))
    exit_in_output_tuples = list(zip(*exit_in_output_list))
    entry_param_tuples = list(zip(*entry_param_list))
    exit_param_tuples = list(zip(*exit_param_list))

    def _build_more_args(func_settings: tp.Kwargs, func_kwargs: tp.Kwargs) -&gt; tp.Args:
        pass_kwargs = func_settings.get(&#39;pass_kwargs&#39;, [])
        more_args = ()
        for key in pass_kwargs:
            value = None
            if isinstance(key, tuple):
                key, value = key
            else:
                if key.startswith(&#39;temp_idx_arr&#39;):
                    value = np.empty((input_shape[0],), dtype=np.int_)
            value = func_kwargs.get(key, value)
            more_args += (value,)
        return more_args

    entry_more_args = _build_more_args(entry_settings, entry_kwargs)
    exit_more_args = _build_more_args(exit_settings, exit_kwargs)
    cache_more_args = _build_more_args(cache_settings, cache_kwargs)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _cache_in_output_list = cache_in_output_list
        _cache_param_list = cache_param_list
        if checks.is_numba_func(cache_func):
            if len(_cache_in_output_list) &gt; 0:
                _cache_in_output_list = [to_typed_list(in_outputs) for in_outputs in _cache_in_output_list]
            if len(_cache_param_list) &gt; 0:
                _cache_param_list = [to_typed_list(params) for params in _cache_param_list]

        cache = cache_func(
            *cache_input_tuple,
            *_cache_in_output_list,
            *_cache_param_list,
            *cache_args,
            *cache_more_args
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    entry_cache = ()
    exit_cache = ()
    if entry_settings.get(&#39;pass_cache&#39;, False):
        entry_cache = cache
    if exit_settings.get(&#39;pass_cache&#39;, False):
        exit_cache = cache

    # Apply and concatenate
    if exit_only and not iteratively:
        if len(exit_in_output_names) &gt; 0:
            if numba_loop:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = (exit_in_output_tuples,)
        else:
            _exit_in_output_tuples = ()
        if len(exit_param_names) &gt; 0:
            if numba_loop:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = (exit_param_tuples,)
        else:
            _exit_param_tuples = ()

        return apply_and_concat_func(
            n_params,
            apply_func,
            input_list[0],
            exit_wait,
            exit_input_tuple,
            *_exit_in_output_tuples,
            *_exit_param_tuples,
            exit_args + exit_more_args + exit_cache
        )

    else:
        if len(entry_in_output_names) &gt; 0:
            if numba_loop:
                _entry_in_output_tuples = (to_typed_list(entry_in_output_tuples),)
            else:
                _entry_in_output_tuples = (entry_in_output_tuples,)
        else:
            _entry_in_output_tuples = ()
        if len(entry_param_names) &gt; 0:
            if numba_loop:
                _entry_param_tuples = (to_typed_list(entry_param_tuples),)
            else:
                _entry_param_tuples = (entry_param_tuples,)
        else:
            _entry_param_tuples = ()
        if len(exit_in_output_names) &gt; 0:
            if numba_loop:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = (exit_in_output_tuples,)
        else:
            _exit_in_output_tuples = ()
        if len(exit_param_names) &gt; 0:
            if numba_loop:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = (exit_param_tuples,)
        else:
            _exit_param_tuples = ()

        return apply_and_concat_func(
            n_params,
            apply_func,
            input_shape,
            entry_wait,
            exit_wait,
            entry_input_tuple,
            exit_input_tuple,
            *_entry_in_output_tuples,
            *_exit_in_output_tuples,
            *_entry_param_tuples,
            *_exit_param_tuples,
            entry_args + entry_more_args + entry_cache,
            exit_args + exit_more_args + exit_cache
        )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROBEX.entries_and"><code class="name flex">
<span>def <span class="ident">entries_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROBEX.entries_or"><code class="name flex">
<span>def <span class="ident">entries_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROBEX.entries_xor"><code class="name flex">
<span>def <span class="ident">entries_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROBEX.exits_and"><code class="name flex">
<span>def <span class="ident">exits_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROBEX.exits_or"><code class="name flex">
<span>def <span class="ident">exits_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROBEX.exits_xor"><code class="name flex">
<span>def <span class="ident">exits_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.RPROBEX.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>_self, entry_y=None, exit_y=None, entry_types=None, exit_types=None, entry_trace_kwargs=None, exit_trace_kwargs=None, fig=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.signals.generators.RPROBEX.entries" href="#vectorbt.signals.generators.RPROBEX.entries">RPROBEX.entries</a></code> and <code><a title="vectorbt.signals.generators.RPROBEX.exits" href="#vectorbt.signals.generators.RPROBEX.exits">RPROBEX.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entry_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot entry markers on.</dd>
<dt><strong><code>exit_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot exit markers on.</dd>
<dt><strong><code>entry_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Entry types in string format.</dd>
<dt><strong><code>exit_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Exit types in string format.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers">SignalsSRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.generators.RPROBEX.entries" href="#vectorbt.signals.generators.RPROBEX.entries">RPROBEX.entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers">SignalsSRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.generators.RPROBEX.exits" href="#vectorbt.signals.generators.RPROBEX.exits">RPROBEX.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>Figure</code> or <code>FigureWidget</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers">SignalsSRAccessor.plot_as_markers()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(_self,
         entry_y: tp.Optional[tp.ArrayLike] = None,
         exit_y: tp.Optional[tp.ArrayLike] = None,
         entry_types: tp.Optional[tp.ArrayLikeSequence] = None,
         exit_types: tp.Optional[tp.ArrayLikeSequence] = None,
         entry_trace_kwargs: tp.KwargsLike = None,
         exit_trace_kwargs: tp.KwargsLike = None,
         fig: tp.Optional[tp.BaseFigure] = None,
         **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    if _self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if entry_trace_kwargs is None:
        entry_trace_kwargs = {}
    if exit_trace_kwargs is None:
        exit_trace_kwargs = {}
    if entry_types is not None:
        entry_types = np.asarray(entry_types)
        entry_trace_kwargs = merge_dicts(dict(
            customdata=entry_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), entry_trace_kwargs)
    if exit_types is not None:
        exit_types = np.asarray(exit_types)
        exit_trace_kwargs = merge_dicts(dict(
            customdata=exit_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), exit_trace_kwargs)
    if exit_only and iteratively:
        entries = _self.new_entries
    else:
        entries = _self.entries
    exits = _self.exits
    fig = entries.vbt.signals.plot_as_entry_markers(
        y=entry_y, trace_kwargs=entry_trace_kwargs, fig=fig, **kwargs)
    fig = exits.vbt.signals.plot_as_exit_markers(
        y=exit_y, trace_kwargs=exit_trace_kwargs, fig=fig, **kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.generators.STEX"><code class="flex name class">
<span>class <span class="ident">STEX</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Exit signal generator based on stop values.</p>
<p>Generates <code>exits</code> based on <code>entries</code> and <code><a title="vectorbt.signals.nb.stop_choice_nb" href="nb.html#vectorbt.signals.nb.stop_choice_nb">stop_choice_nb()</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>All parameters can be either a single value (per frame) or a NumPy array (per row, column,
or element). To generate multiple combinations, pass them as lists.</p>
</div></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.signals.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.signals.generators._STEX</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.generators.STEX.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>entries, ts, stop, trailing=False, short_name='stex', hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.signals.generators.STEX" href="#vectorbt.signals.generators.STEX">STEX</a></code> indicator.</p>
<ul>
<li>Inputs: <code>entries</code>, <code>ts</code></li>
<li>Parameters: <code>stop</code>, <code>trailing</code></li>
<li>Outputs: <code>exits</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.run_combs"><code class="name flex">
<span>def <span class="ident">run_combs</span></span>(<span>entries, ts, stop, trailing=False, r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.signals.generators.STEX" href="#vectorbt.signals.generators.STEX">STEX</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>entries</code>, <code>ts</code></li>
<li>Parameters: <code>stop</code>, <code>trailing</code></li>
<li>Outputs: <code>exits</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.generators.STEX.run" href="#vectorbt.signals.generators.STEX.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_above(myind.ma, crossover=True)
&gt;&gt;&gt; below_signals = myind.price_below(myind.ma, crossover=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_above(myind2.ma, crossover=True)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1      p2            result
0       0       1          [(0, 1)]
1  [0, 1]     [2]  [(0, 2), (1, 2)]
2  [0, 1]  [2, 3]  [(0, 2), (1, 3)]
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(0, col, window, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(i, col, lower, flex_2d)
...             _upper = flex_select_auto_nb(i, col, upper, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.cumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms ± 4.76 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms ± 4.55 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations anymore, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_series(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/vectorbt/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict
import warnings
from datetime import datetime, timedelta
from types import ModuleType
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, resolve_dict
from vectorbt.utils.random import set_seed
from vectorbt.utils.params import (
    to_typed_list,
    broadcast_params,
    create_param_product,
    DefaultParam
)
from vectorbt.utils.enum import prepare_enum_value
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import build_param_indexer
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.accessors import BaseAccessor

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.generators.STEX.entries"><code class="name">var <span class="ident">entries</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.exits"><code class="name">var <span class="ident">exits</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.stop_list"><code class="name">var <span class="ident">stop_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>stop</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.trailing_list"><code class="name">var <span class="ident">trailing_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>trailing</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.ts"><code class="name">var <span class="ident">ts</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: tp.Any, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.generators.STEX.custom_func"><code class="name flex">
<span>def <span class="ident">custom_func</span></span>(<span>input_list, in_output_list, param_list, *args, input_shape=None, flex_2d=None, entry_args=None, exit_args=None, cache_args=None, entry_kwargs=None, exit_kwargs=None, cache_kwargs=None, return_cache=False, use_cache=None, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                flex_2d: tp.Optional[bool] = None,
                entry_args: tp.Optional[tp.Args] = None,
                exit_args: tp.Optional[tp.Args] = None,
                cache_args: tp.Optional[tp.Args] = None,
                entry_kwargs: tp.KwargsLike = None,
                exit_kwargs: tp.KwargsLike = None,
                cache_kwargs: tp.KwargsLike = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                **_kwargs) -&gt; tp.Union[CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    # Get arguments
    if len(input_list) == 0:
        if input_shape is None:
            raise ValueError(&#34;Pass input_shape if no input time series passed&#34;)
    else:
        input_shape = input_list[0].shape

    if entry_args is None:
        entry_args = ()
    if exit_args is None:
        exit_args = ()
    if cache_args is None:
        cache_args = ()
    if exit_only:
        if len(exit_args) &gt; 0:
            raise ValueError(&#34;Use *args instead of exit_args when exit_only=True&#34;)
        exit_args = args
    else:
        if len(args) &gt; 0:
            raise ValueError(&#34;*args can be only used when exit_only=True&#34;)

    if entry_kwargs is None:
        entry_kwargs = {}
    if exit_kwargs is None:
        exit_kwargs = {}
    if cache_kwargs is None:
        cache_kwargs = {}
    if exit_only:
        if len(exit_kwargs) &gt; 0:
            raise ValueError(&#34;Use **kwargs instead of exit_kwargs when exit_only=True&#34;)
        exit_kwargs = _kwargs
    else:
        if len(_kwargs) &gt; 0:
            raise ValueError(&#34;**kwargs can be only used when exit_only=True&#34;)

    kwargs_defaults = dict(
        input_shape=input_shape,
        wait=1,
        first=True,
        flex_2d=flex_2d,
    )
    entry_kwargs = merge_dicts(kwargs_defaults, entry_kwargs)
    exit_kwargs = merge_dicts(kwargs_defaults, exit_kwargs)
    cache_kwargs = merge_dicts(kwargs_defaults, cache_kwargs)
    entry_wait = entry_kwargs[&#39;wait&#39;]
    exit_wait = exit_kwargs[&#39;wait&#39;]

    # Distribute arguments across functions
    entry_input_tuple = ()
    exit_input_tuple = ()
    cache_input_tuple = ()
    for input_name in entry_input_names:
        entry_input_tuple += (input_list[input_names.index(input_name)],)
    for input_name in exit_input_names:
        exit_input_tuple += (input_list[input_names.index(input_name)],)
    for input_name in cache_input_names:
        cache_input_tuple += (input_list[input_names.index(input_name)],)

    entry_in_output_list = []
    exit_in_output_list = []
    cache_in_output_list = []
    for in_output_name in entry_in_output_names:
        entry_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
    for in_output_name in exit_in_output_names:
        exit_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
    for in_output_name in cache_in_output_names:
        cache_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])

    entry_param_list = []
    exit_param_list = []
    cache_param_list = []
    for param_name in entry_param_names:
        entry_param_list.append(param_list[param_names.index(param_name)])
    for param_name in exit_param_names:
        exit_param_list.append(param_list[param_names.index(param_name)])
    for param_name in cache_param_names:
        cache_param_list.append(param_list[param_names.index(param_name)])

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    entry_in_output_tuples = list(zip(*entry_in_output_list))
    exit_in_output_tuples = list(zip(*exit_in_output_list))
    entry_param_tuples = list(zip(*entry_param_list))
    exit_param_tuples = list(zip(*exit_param_list))

    def _build_more_args(func_settings: tp.Kwargs, func_kwargs: tp.Kwargs) -&gt; tp.Args:
        pass_kwargs = func_settings.get(&#39;pass_kwargs&#39;, [])
        more_args = ()
        for key in pass_kwargs:
            value = None
            if isinstance(key, tuple):
                key, value = key
            else:
                if key.startswith(&#39;temp_idx_arr&#39;):
                    value = np.empty((input_shape[0],), dtype=np.int_)
            value = func_kwargs.get(key, value)
            more_args += (value,)
        return more_args

    entry_more_args = _build_more_args(entry_settings, entry_kwargs)
    exit_more_args = _build_more_args(exit_settings, exit_kwargs)
    cache_more_args = _build_more_args(cache_settings, cache_kwargs)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _cache_in_output_list = cache_in_output_list
        _cache_param_list = cache_param_list
        if checks.is_numba_func(cache_func):
            if len(_cache_in_output_list) &gt; 0:
                _cache_in_output_list = [to_typed_list(in_outputs) for in_outputs in _cache_in_output_list]
            if len(_cache_param_list) &gt; 0:
                _cache_param_list = [to_typed_list(params) for params in _cache_param_list]

        cache = cache_func(
            *cache_input_tuple,
            *_cache_in_output_list,
            *_cache_param_list,
            *cache_args,
            *cache_more_args
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    entry_cache = ()
    exit_cache = ()
    if entry_settings.get(&#39;pass_cache&#39;, False):
        entry_cache = cache
    if exit_settings.get(&#39;pass_cache&#39;, False):
        exit_cache = cache

    # Apply and concatenate
    if exit_only and not iteratively:
        if len(exit_in_output_names) &gt; 0:
            if numba_loop:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = (exit_in_output_tuples,)
        else:
            _exit_in_output_tuples = ()
        if len(exit_param_names) &gt; 0:
            if numba_loop:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = (exit_param_tuples,)
        else:
            _exit_param_tuples = ()

        return apply_and_concat_func(
            n_params,
            apply_func,
            input_list[0],
            exit_wait,
            exit_input_tuple,
            *_exit_in_output_tuples,
            *_exit_param_tuples,
            exit_args + exit_more_args + exit_cache
        )

    else:
        if len(entry_in_output_names) &gt; 0:
            if numba_loop:
                _entry_in_output_tuples = (to_typed_list(entry_in_output_tuples),)
            else:
                _entry_in_output_tuples = (entry_in_output_tuples,)
        else:
            _entry_in_output_tuples = ()
        if len(entry_param_names) &gt; 0:
            if numba_loop:
                _entry_param_tuples = (to_typed_list(entry_param_tuples),)
            else:
                _entry_param_tuples = (entry_param_tuples,)
        else:
            _entry_param_tuples = ()
        if len(exit_in_output_names) &gt; 0:
            if numba_loop:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = (exit_in_output_tuples,)
        else:
            _exit_in_output_tuples = ()
        if len(exit_param_names) &gt; 0:
            if numba_loop:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = (exit_param_tuples,)
        else:
            _exit_param_tuples = ()

        return apply_and_concat_func(
            n_params,
            apply_func,
            input_shape,
            entry_wait,
            exit_wait,
            entry_input_tuple,
            exit_input_tuple,
            *_entry_in_output_tuples,
            *_exit_in_output_tuples,
            *_entry_param_tuples,
            *_exit_param_tuples,
            entry_args + entry_more_args + entry_cache,
            exit_args + exit_more_args + exit_cache
        )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.entries_and"><code class="name flex">
<span>def <span class="ident">entries_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.entries_or"><code class="name flex">
<span>def <span class="ident">entries_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.entries_xor"><code class="name flex">
<span>def <span class="ident">entries_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.exits_and"><code class="name flex">
<span>def <span class="ident">exits_and</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.exits_or"><code class="name flex">
<span>def <span class="ident">exits_or</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.exits_xor"><code class="name flex">
<span>def <span class="ident">exits_xor</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>_self, entry_y=None, exit_y=None, entry_types=None, exit_types=None, entry_trace_kwargs=None, exit_trace_kwargs=None, fig=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.signals.generators.STEX.entries" href="#vectorbt.signals.generators.STEX.entries">STEX.entries</a></code> and <code><a title="vectorbt.signals.generators.STEX.exits" href="#vectorbt.signals.generators.STEX.exits">STEX.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entry_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot entry markers on.</dd>
<dt><strong><code>exit_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot exit markers on.</dd>
<dt><strong><code>entry_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Entry types in string format.</dd>
<dt><strong><code>exit_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Exit types in string format.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers">SignalsSRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.generators.STEX.entries" href="#vectorbt.signals.generators.STEX.entries">STEX.entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers">SignalsSRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.generators.STEX.exits" href="#vectorbt.signals.generators.STEX.exits">STEX.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>Figure</code> or <code>FigureWidget</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers" href="accessors.html#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers">SignalsSRAccessor.plot_as_markers()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(_self,
         entry_y: tp.Optional[tp.ArrayLike] = None,
         exit_y: tp.Optional[tp.ArrayLike] = None,
         entry_types: tp.Optional[tp.ArrayLikeSequence] = None,
         exit_types: tp.Optional[tp.ArrayLikeSequence] = None,
         entry_trace_kwargs: tp.KwargsLike = None,
         exit_trace_kwargs: tp.KwargsLike = None,
         fig: tp.Optional[tp.BaseFigure] = None,
         **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    if _self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if entry_trace_kwargs is None:
        entry_trace_kwargs = {}
    if exit_trace_kwargs is None:
        exit_trace_kwargs = {}
    if entry_types is not None:
        entry_types = np.asarray(entry_types)
        entry_trace_kwargs = merge_dicts(dict(
            customdata=entry_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), entry_trace_kwargs)
    if exit_types is not None:
        exit_types = np.asarray(exit_types)
        exit_trace_kwargs = merge_dicts(dict(
            customdata=exit_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), exit_trace_kwargs)
    if exit_only and iteratively:
        entries = _self.new_entries
    else:
        entries = _self.entries
    exits = _self.exits
    fig = entries.vbt.signals.plot_as_entry_markers(
        y=entry_y, trace_kwargs=entry_trace_kwargs, fig=fig, **kwargs)
    fig = exits.vbt.signals.plot_as_exit_markers(
        y=exit_y, trace_kwargs=exit_trace_kwargs, fig=fig, **kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.ts_above"><code class="name flex">
<span>def <span class="ident">ts_above</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.ts_below"><code class="name flex">
<span>def <span class="ident">ts_below</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.generators.STEX.ts_equal"><code class="name flex">
<span>def <span class="ident">ts_equal</span></span>(<span>self, other, crossover=False, wait=0, after_false=True, level_name=None, allow_multiple=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   crossover: bool = False,
                   wait: int = 0,
                   after_false: bool = True,
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **kwargs
    )
    if crossover:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRUYwMDAwO30KCS5zdDF7ZmlsbDojRkY5MDAwO30KCS5zdDJ7ZmlsbDojRkZERjAwO30KCS5zdDN7ZmlsbDojMjgyQzM0O30KPC9zdHlsZT4KPGc+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNTUuMywzMDAuMSAyODMuMSwwIDIwOCwwIDExMC44LDAgMzUuOCwwIDEuMiw0NTAuMiA3Ni4zLDQ1MC4yIAkJCSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjIzMC40LDMwMC4xIDM1OC4xLDAgMjgzLjEsMCAxODUuOCwwIDExMC44LDAgNzYuMyw0NTAuMiAxNTEuMyw0NTAuMiAJCQkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIzMDUuNCwzMDAuMSA0MzMuMSwwIDM1OC4xLDAgMzMxLjYsNjIuMyAyNjAuOCwwIDE4NS44LDAgMTUxLjMsNDUwLjIgMjI2LjQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iNTEwLjgsMCA0MzMuMSwwIDMwNS40LDMwMC4xIDMzOC40LDAgMjYwLjgsMCAyMjYuNCw0NTAuMiAzMDQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.signals" href="index.html">vectorbt.signals</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="vectorbt.signals.generators.ohlcstex_config" href="#vectorbt.signals.generators.ohlcstex_config">ohlcstex_config</a></code></li>
<li><code><a title="vectorbt.signals.generators.ohlcstex_func_config" href="#vectorbt.signals.generators.ohlcstex_func_config">ohlcstex_func_config</a></code></li>
<li><code><a title="vectorbt.signals.generators.rprobex_config" href="#vectorbt.signals.generators.rprobex_config">rprobex_config</a></code></li>
<li><code><a title="vectorbt.signals.generators.rprobex_func_config" href="#vectorbt.signals.generators.rprobex_func_config">rprobex_func_config</a></code></li>
<li><code><a title="vectorbt.signals.generators.stex_config" href="#vectorbt.signals.generators.stex_config">stex_config</a></code></li>
<li><code><a title="vectorbt.signals.generators.stex_func_config" href="#vectorbt.signals.generators.stex_func_config">stex_func_config</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.signals.generators.IOHLCSTEX" href="#vectorbt.signals.generators.IOHLCSTEX">IOHLCSTEX</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.close" href="#vectorbt.signals.generators.IOHLCSTEX.close">close</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.close_above" href="#vectorbt.signals.generators.IOHLCSTEX.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.close_below" href="#vectorbt.signals.generators.IOHLCSTEX.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.close_equal" href="#vectorbt.signals.generators.IOHLCSTEX.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.custom_func" href="#vectorbt.signals.generators.IOHLCSTEX.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.entries" href="#vectorbt.signals.generators.IOHLCSTEX.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.entries_and" href="#vectorbt.signals.generators.IOHLCSTEX.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.entries_or" href="#vectorbt.signals.generators.IOHLCSTEX.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.entries_xor" href="#vectorbt.signals.generators.IOHLCSTEX.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.exits" href="#vectorbt.signals.generators.IOHLCSTEX.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.exits_and" href="#vectorbt.signals.generators.IOHLCSTEX.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.exits_or" href="#vectorbt.signals.generators.IOHLCSTEX.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.exits_xor" href="#vectorbt.signals.generators.IOHLCSTEX.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.high" href="#vectorbt.signals.generators.IOHLCSTEX.high">high</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.high_above" href="#vectorbt.signals.generators.IOHLCSTEX.high_above">high_above</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.high_below" href="#vectorbt.signals.generators.IOHLCSTEX.high_below">high_below</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.high_equal" href="#vectorbt.signals.generators.IOHLCSTEX.high_equal">high_equal</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.hit_price" href="#vectorbt.signals.generators.IOHLCSTEX.hit_price">hit_price</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.hit_price_above" href="#vectorbt.signals.generators.IOHLCSTEX.hit_price_above">hit_price_above</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.hit_price_below" href="#vectorbt.signals.generators.IOHLCSTEX.hit_price_below">hit_price_below</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.hit_price_equal" href="#vectorbt.signals.generators.IOHLCSTEX.hit_price_equal">hit_price_equal</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.low" href="#vectorbt.signals.generators.IOHLCSTEX.low">low</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.low_above" href="#vectorbt.signals.generators.IOHLCSTEX.low_above">low_above</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.low_below" href="#vectorbt.signals.generators.IOHLCSTEX.low_below">low_below</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.low_equal" href="#vectorbt.signals.generators.IOHLCSTEX.low_equal">low_equal</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.new_entries" href="#vectorbt.signals.generators.IOHLCSTEX.new_entries">new_entries</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.new_entries_and" href="#vectorbt.signals.generators.IOHLCSTEX.new_entries_and">new_entries_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.new_entries_or" href="#vectorbt.signals.generators.IOHLCSTEX.new_entries_or">new_entries_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.new_entries_xor" href="#vectorbt.signals.generators.IOHLCSTEX.new_entries_xor">new_entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.open" href="#vectorbt.signals.generators.IOHLCSTEX.open">open</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.open_above" href="#vectorbt.signals.generators.IOHLCSTEX.open_above">open_above</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.open_below" href="#vectorbt.signals.generators.IOHLCSTEX.open_below">open_below</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.open_equal" href="#vectorbt.signals.generators.IOHLCSTEX.open_equal">open_equal</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.plot" href="#vectorbt.signals.generators.IOHLCSTEX.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.run" href="#vectorbt.signals.generators.IOHLCSTEX.run">run</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.run_combs" href="#vectorbt.signals.generators.IOHLCSTEX.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.sl_stop_list" href="#vectorbt.signals.generators.IOHLCSTEX.sl_stop_list">sl_stop_list</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.stop_type" href="#vectorbt.signals.generators.IOHLCSTEX.stop_type">stop_type</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.stop_type_readable" href="#vectorbt.signals.generators.IOHLCSTEX.stop_type_readable">stop_type_readable</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.tp_stop_list" href="#vectorbt.signals.generators.IOHLCSTEX.tp_stop_list">tp_stop_list</a></code></li>
<li><code><a title="vectorbt.signals.generators.IOHLCSTEX.ts_stop_list" href="#vectorbt.signals.generators.IOHLCSTEX.ts_stop_list">ts_stop_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.generators.IRPROBEX" href="#vectorbt.signals.generators.IRPROBEX">IRPROBEX</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.generators.IRPROBEX.custom_func" href="#vectorbt.signals.generators.IRPROBEX.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.entries" href="#vectorbt.signals.generators.IRPROBEX.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.entries_and" href="#vectorbt.signals.generators.IRPROBEX.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.entries_or" href="#vectorbt.signals.generators.IRPROBEX.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.entries_xor" href="#vectorbt.signals.generators.IRPROBEX.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.exits" href="#vectorbt.signals.generators.IRPROBEX.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.exits_and" href="#vectorbt.signals.generators.IRPROBEX.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.exits_or" href="#vectorbt.signals.generators.IRPROBEX.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.exits_xor" href="#vectorbt.signals.generators.IRPROBEX.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.new_entries" href="#vectorbt.signals.generators.IRPROBEX.new_entries">new_entries</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.new_entries_and" href="#vectorbt.signals.generators.IRPROBEX.new_entries_and">new_entries_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.new_entries_or" href="#vectorbt.signals.generators.IRPROBEX.new_entries_or">new_entries_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.new_entries_xor" href="#vectorbt.signals.generators.IRPROBEX.new_entries_xor">new_entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.plot" href="#vectorbt.signals.generators.IRPROBEX.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.prob_list" href="#vectorbt.signals.generators.IRPROBEX.prob_list">prob_list</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.run" href="#vectorbt.signals.generators.IRPROBEX.run">run</a></code></li>
<li><code><a title="vectorbt.signals.generators.IRPROBEX.run_combs" href="#vectorbt.signals.generators.IRPROBEX.run_combs">run_combs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.generators.ISTEX" href="#vectorbt.signals.generators.ISTEX">ISTEX</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.generators.ISTEX.custom_func" href="#vectorbt.signals.generators.ISTEX.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.entries" href="#vectorbt.signals.generators.ISTEX.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.entries_and" href="#vectorbt.signals.generators.ISTEX.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.entries_or" href="#vectorbt.signals.generators.ISTEX.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.entries_xor" href="#vectorbt.signals.generators.ISTEX.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.exits" href="#vectorbt.signals.generators.ISTEX.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.exits_and" href="#vectorbt.signals.generators.ISTEX.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.exits_or" href="#vectorbt.signals.generators.ISTEX.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.exits_xor" href="#vectorbt.signals.generators.ISTEX.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.new_entries" href="#vectorbt.signals.generators.ISTEX.new_entries">new_entries</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.new_entries_and" href="#vectorbt.signals.generators.ISTEX.new_entries_and">new_entries_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.new_entries_or" href="#vectorbt.signals.generators.ISTEX.new_entries_or">new_entries_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.new_entries_xor" href="#vectorbt.signals.generators.ISTEX.new_entries_xor">new_entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.plot" href="#vectorbt.signals.generators.ISTEX.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.run" href="#vectorbt.signals.generators.ISTEX.run">run</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.run_combs" href="#vectorbt.signals.generators.ISTEX.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.stop_list" href="#vectorbt.signals.generators.ISTEX.stop_list">stop_list</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.trailing_list" href="#vectorbt.signals.generators.ISTEX.trailing_list">trailing_list</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.ts" href="#vectorbt.signals.generators.ISTEX.ts">ts</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.ts_above" href="#vectorbt.signals.generators.ISTEX.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.ts_below" href="#vectorbt.signals.generators.ISTEX.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.signals.generators.ISTEX.ts_equal" href="#vectorbt.signals.generators.ISTEX.ts_equal">ts_equal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.generators.OHLCSTEX" href="#vectorbt.signals.generators.OHLCSTEX">OHLCSTEX</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.close" href="#vectorbt.signals.generators.OHLCSTEX.close">close</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.close_above" href="#vectorbt.signals.generators.OHLCSTEX.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.close_below" href="#vectorbt.signals.generators.OHLCSTEX.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.close_equal" href="#vectorbt.signals.generators.OHLCSTEX.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.custom_func" href="#vectorbt.signals.generators.OHLCSTEX.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.entries" href="#vectorbt.signals.generators.OHLCSTEX.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.entries_and" href="#vectorbt.signals.generators.OHLCSTEX.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.entries_or" href="#vectorbt.signals.generators.OHLCSTEX.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.entries_xor" href="#vectorbt.signals.generators.OHLCSTEX.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.exits" href="#vectorbt.signals.generators.OHLCSTEX.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.exits_and" href="#vectorbt.signals.generators.OHLCSTEX.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.exits_or" href="#vectorbt.signals.generators.OHLCSTEX.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.exits_xor" href="#vectorbt.signals.generators.OHLCSTEX.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.high" href="#vectorbt.signals.generators.OHLCSTEX.high">high</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.high_above" href="#vectorbt.signals.generators.OHLCSTEX.high_above">high_above</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.high_below" href="#vectorbt.signals.generators.OHLCSTEX.high_below">high_below</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.high_equal" href="#vectorbt.signals.generators.OHLCSTEX.high_equal">high_equal</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.hit_price" href="#vectorbt.signals.generators.OHLCSTEX.hit_price">hit_price</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.hit_price_above" href="#vectorbt.signals.generators.OHLCSTEX.hit_price_above">hit_price_above</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.hit_price_below" href="#vectorbt.signals.generators.OHLCSTEX.hit_price_below">hit_price_below</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.hit_price_equal" href="#vectorbt.signals.generators.OHLCSTEX.hit_price_equal">hit_price_equal</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.low" href="#vectorbt.signals.generators.OHLCSTEX.low">low</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.low_above" href="#vectorbt.signals.generators.OHLCSTEX.low_above">low_above</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.low_below" href="#vectorbt.signals.generators.OHLCSTEX.low_below">low_below</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.low_equal" href="#vectorbt.signals.generators.OHLCSTEX.low_equal">low_equal</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.open" href="#vectorbt.signals.generators.OHLCSTEX.open">open</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.open_above" href="#vectorbt.signals.generators.OHLCSTEX.open_above">open_above</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.open_below" href="#vectorbt.signals.generators.OHLCSTEX.open_below">open_below</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.open_equal" href="#vectorbt.signals.generators.OHLCSTEX.open_equal">open_equal</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.plot" href="#vectorbt.signals.generators.OHLCSTEX.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.run" href="#vectorbt.signals.generators.OHLCSTEX.run">run</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.run_combs" href="#vectorbt.signals.generators.OHLCSTEX.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.sl_stop_list" href="#vectorbt.signals.generators.OHLCSTEX.sl_stop_list">sl_stop_list</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.stop_type" href="#vectorbt.signals.generators.OHLCSTEX.stop_type">stop_type</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.stop_type_readable" href="#vectorbt.signals.generators.OHLCSTEX.stop_type_readable">stop_type_readable</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.tp_stop_list" href="#vectorbt.signals.generators.OHLCSTEX.tp_stop_list">tp_stop_list</a></code></li>
<li><code><a title="vectorbt.signals.generators.OHLCSTEX.ts_stop_list" href="#vectorbt.signals.generators.OHLCSTEX.ts_stop_list">ts_stop_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.generators.RAND" href="#vectorbt.signals.generators.RAND">RAND</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.generators.RAND.apply_func" href="#vectorbt.signals.generators.RAND.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.signals.generators.RAND.custom_func" href="#vectorbt.signals.generators.RAND.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.signals.generators.RAND.entries" href="#vectorbt.signals.generators.RAND.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.generators.RAND.entries_and" href="#vectorbt.signals.generators.RAND.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.RAND.entries_or" href="#vectorbt.signals.generators.RAND.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.RAND.entries_xor" href="#vectorbt.signals.generators.RAND.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.RAND.exits" href="#vectorbt.signals.generators.RAND.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.generators.RAND.exits_and" href="#vectorbt.signals.generators.RAND.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.RAND.exits_or" href="#vectorbt.signals.generators.RAND.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.RAND.exits_xor" href="#vectorbt.signals.generators.RAND.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.RAND.n_list" href="#vectorbt.signals.generators.RAND.n_list">n_list</a></code></li>
<li><code><a title="vectorbt.signals.generators.RAND.plot" href="#vectorbt.signals.generators.RAND.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.generators.RAND.run" href="#vectorbt.signals.generators.RAND.run">run</a></code></li>
<li><code><a title="vectorbt.signals.generators.RAND.run_combs" href="#vectorbt.signals.generators.RAND.run_combs">run_combs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.generators.RPROB" href="#vectorbt.signals.generators.RPROB">RPROB</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.generators.RPROB.custom_func" href="#vectorbt.signals.generators.RPROB.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROB.entries" href="#vectorbt.signals.generators.RPROB.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROB.entries_and" href="#vectorbt.signals.generators.RPROB.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROB.entries_or" href="#vectorbt.signals.generators.RPROB.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROB.entries_xor" href="#vectorbt.signals.generators.RPROB.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROB.entry_prob_list" href="#vectorbt.signals.generators.RPROB.entry_prob_list">entry_prob_list</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROB.exit_prob_list" href="#vectorbt.signals.generators.RPROB.exit_prob_list">exit_prob_list</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROB.exits" href="#vectorbt.signals.generators.RPROB.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROB.exits_and" href="#vectorbt.signals.generators.RPROB.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROB.exits_or" href="#vectorbt.signals.generators.RPROB.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROB.exits_xor" href="#vectorbt.signals.generators.RPROB.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROB.plot" href="#vectorbt.signals.generators.RPROB.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROB.run" href="#vectorbt.signals.generators.RPROB.run">run</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROB.run_combs" href="#vectorbt.signals.generators.RPROB.run_combs">run_combs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.generators.RPROBEX" href="#vectorbt.signals.generators.RPROBEX">RPROBEX</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.generators.RPROBEX.custom_func" href="#vectorbt.signals.generators.RPROBEX.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROBEX.entries" href="#vectorbt.signals.generators.RPROBEX.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROBEX.entries_and" href="#vectorbt.signals.generators.RPROBEX.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROBEX.entries_or" href="#vectorbt.signals.generators.RPROBEX.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROBEX.entries_xor" href="#vectorbt.signals.generators.RPROBEX.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROBEX.exits" href="#vectorbt.signals.generators.RPROBEX.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROBEX.exits_and" href="#vectorbt.signals.generators.RPROBEX.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROBEX.exits_or" href="#vectorbt.signals.generators.RPROBEX.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROBEX.exits_xor" href="#vectorbt.signals.generators.RPROBEX.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROBEX.plot" href="#vectorbt.signals.generators.RPROBEX.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROBEX.prob_list" href="#vectorbt.signals.generators.RPROBEX.prob_list">prob_list</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROBEX.run" href="#vectorbt.signals.generators.RPROBEX.run">run</a></code></li>
<li><code><a title="vectorbt.signals.generators.RPROBEX.run_combs" href="#vectorbt.signals.generators.RPROBEX.run_combs">run_combs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.generators.STEX" href="#vectorbt.signals.generators.STEX">STEX</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.generators.STEX.custom_func" href="#vectorbt.signals.generators.STEX.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.entries" href="#vectorbt.signals.generators.STEX.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.entries_and" href="#vectorbt.signals.generators.STEX.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.entries_or" href="#vectorbt.signals.generators.STEX.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.entries_xor" href="#vectorbt.signals.generators.STEX.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.exits" href="#vectorbt.signals.generators.STEX.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.exits_and" href="#vectorbt.signals.generators.STEX.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.exits_or" href="#vectorbt.signals.generators.STEX.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.exits_xor" href="#vectorbt.signals.generators.STEX.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.plot" href="#vectorbt.signals.generators.STEX.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.run" href="#vectorbt.signals.generators.STEX.run">run</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.run_combs" href="#vectorbt.signals.generators.STEX.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.stop_list" href="#vectorbt.signals.generators.STEX.stop_list">stop_list</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.trailing_list" href="#vectorbt.signals.generators.STEX.trailing_list">trailing_list</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.ts" href="#vectorbt.signals.generators.STEX.ts">ts</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.ts_above" href="#vectorbt.signals.generators.STEX.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.ts_below" href="#vectorbt.signals.generators.STEX.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.signals.generators.STEX.ts_equal" href="#vectorbt.signals.generators.STEX.ts_equal">ts_equal</a></code></li>
</ul>
</li>
</ul>
</li>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>