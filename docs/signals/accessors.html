<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>vectorbt.signals.accessors API documentation</title>
<meta name="description" content="Custom pandas accessors for signals data â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#e82}body{line-height:1.5em}.version{font-weight:normal;font-style:italic;font-size:.75em;color:#8b949e}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}h2[id^="header-"]{margin-top:2em}.ident{color:#900}.headerlink{color:inherit}.headerlink:hover{color:inherit}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important;word-break:normal}.hljs-keyword{color:#ff7b72 !important}.hljs-comment{color:#8b949e !important}.hljs-meta{color:#8b949e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 1.5em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:1em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-weight:400;font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{min-width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}.hljs{margin-left:-15px;margin-right:-15px}.source pre code{margin-left:0px;margin-right:0px}dd{margin:0 0 1em 3em}dd dd{margin-left:2em}.flex{display:flex !important}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4QLCS0J048"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4QLCS0J048');
</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:100px;max-height:100px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.signals.accessors</code></h1>
</header>
<section id="section-intro">
<p>Custom pandas accessors for signals data.</p>
<p>Methods can be accessed as follows:</p>
<ul>
<li><code><a title="vectorbt.signals.accessors.SignalsSRAccessor" href="#vectorbt.signals.accessors.SignalsSRAccessor">SignalsSRAccessor</a></code> -&gt; <code>pd.Series.vbt.signals.*</code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsDFAccessor" href="#vectorbt.signals.accessors.SignalsDFAccessor">SignalsDFAccessor</a></code> -&gt; <code>pd.DataFrame.vbt.signals.*</code></li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; # vectorbt.signals.accessors.SignalsAccessor.pos_rank
&gt;&gt;&gt; pd.Series([False, True, True, True, False]).vbt.signals.pos_rank()
0    0
1    1
2    2
3    3
4    0
dtype: int64
</code></pre>
<p>The accessors extend <code><a title="vectorbt.generic.accessors" href="../generic/accessors.html">vectorbt.generic.accessors</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The underlying Series/DataFrame should already be a signal series.</p>
<p>Input arrays should be <code>np.bool_</code>.</p>
<p>Grouping is only supported by the methods that accept the <code>group_by</code> argument.</p>
<p>Accessors do not utilize caching.</p>
</div>
<p>Run for the examples below:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; mask = pd.DataFrame({
...     'a': [True, False, False, False, False],
...     'b': [True, False, True, False, True],
...     'c': [True, True, True, False, False]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5)
... ]))
&gt;&gt;&gt; mask
                a      b      c
2020-01-01   True   True   True
2020-01-02  False  False   True
2020-01-03  False   True   True
2020-01-04  False  False  False
2020-01-05  False   True  False
</code></pre>
<h2 id="stats">Stats</h2>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>See <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code> and <code><a title="vectorbt.signals.accessors.SignalsAccessor.metrics" href="#vectorbt.signals.accessors.SignalsAccessor.metrics">SignalsAccessor.metrics</a></code>.</p>
</div>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask.vbt.signals.stats(column='a')
Start                       2020-01-01 00:00:00
End                         2020-01-05 00:00:00
Period                          5 days 00:00:00
Total                                         1
Rate [%]                                     20
First Index                 2020-01-01 00:00:00
Last Index                  2020-01-01 00:00:00
Norm Avg Index [-1, 1]                       -1
Distance: Min                               NaT
Distance: Max                               NaT
Distance: Mean                              NaT
Distance: Std                               NaT
Total Partitions                              1
Partition Rate [%]                          100
Partition Length: Min           1 days 00:00:00
Partition Length: Max           1 days 00:00:00
Partition Length: Mean          1 days 00:00:00
Partition Length: Std                       NaT
Partition Distance: Min                     NaT
Partition Distance: Max                     NaT
Partition Distance: Mean                    NaT
Partition Distance: Std                     NaT
Name: a, dtype: object
</code></pre>
<p>We can pass another signal array to compare this array with:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask.vbt.signals.stats(column='a', settings=dict(other=mask['b']))
Start                       2020-01-01 00:00:00
End                         2020-01-05 00:00:00
Period                          5 days 00:00:00
Total                                         1
Rate [%]                                     20
Total Overlapping                             1
Overlapping Rate [%]                    33.3333
First Index                 2020-01-01 00:00:00
Last Index                  2020-01-01 00:00:00
Norm Avg Index [-1, 1]                       -1
Distance -&gt; Other: Min          0 days 00:00:00
Distance -&gt; Other: Max          0 days 00:00:00
Distance -&gt; Other: Mean         0 days 00:00:00
Distance -&gt; Other: Std                      NaT
Total Partitions                              1
Partition Rate [%]                          100
Partition Length: Min           1 days 00:00:00
Partition Length: Max           1 days 00:00:00
Partition Length: Mean          1 days 00:00:00
Partition Length: Std                       NaT
Partition Distance: Min                     NaT
Partition Distance: Max                     NaT
Partition Distance: Mean                    NaT
Partition Distance: Std                     NaT
Name: a, dtype: object
</code></pre>
<p>We can also return duration as a floating number rather than a timedelta:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask.vbt.signals.stats(column='a', settings=dict(to_timedelta=False))
Start                       2020-01-01 00:00:00
End                         2020-01-05 00:00:00
Period                                        5
Total                                         1
Rate [%]                                     20
First Index                 2020-01-01 00:00:00
Last Index                  2020-01-01 00:00:00
Norm Avg Index [-1, 1]                       -1
Distance: Min                               NaN
Distance: Max                               NaN
Distance: Mean                              NaN
Distance: Std                               NaN
Total Partitions                              1
Partition Rate [%]                          100
Partition Length: Min                         1
Partition Length: Max                         1
Partition Length: Mean                        1
Partition Length: Std                       NaN
Partition Distance: Min                     NaN
Partition Distance: Max                     NaN
Partition Distance: Mean                    NaN
Partition Distance: Std                     NaN
Name: a, dtype: object
</code></pre>
<p><code><a title="vectorbt.signals.accessors.SignalsAccessor.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code> also supports (re-)grouping:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask.vbt.signals.stats(column=0, group_by=[0, 0, 1])
Start                       2020-01-01 00:00:00
End                         2020-01-05 00:00:00
Period                          5 days 00:00:00
Total                                         4
Rate [%]                                     40
First Index                 2020-01-01 00:00:00
Last Index                  2020-01-05 00:00:00
Norm Avg Index [-1, 1]                    -0.25
Distance: Min                   2 days 00:00:00
Distance: Max                   2 days 00:00:00
Distance: Mean                  2 days 00:00:00
Distance: Std                   0 days 00:00:00
Total Partitions                              4
Partition Rate [%]                          100
Partition Length: Min           1 days 00:00:00
Partition Length: Max           1 days 00:00:00
Partition Length: Mean          1 days 00:00:00
Partition Length: Std           0 days 00:00:00
Partition Distance: Min         2 days 00:00:00
Partition Distance: Max         2 days 00:00:00
Partition Distance: Mean        2 days 00:00:00
Partition Distance: Std         0 days 00:00:00
Name: 0, dtype: object
</code></pre>
<h2 id="plots">Plots</h2>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>See <code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">PlotsBuilderMixin.plots()</a></code> and <code><a title="vectorbt.signals.accessors.SignalsAccessor.subplots" href="#vectorbt.signals.accessors.SignalsAccessor.subplots">SignalsAccessor.subplots</a></code>.</p>
</div>
<p>This class inherits subplots from <code><a title="vectorbt.generic.accessors.GenericAccessor" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor">GenericAccessor</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;Custom pandas accessors for signals data.

Methods can be accessed as follows:

* `SignalsSRAccessor` -&gt; `pd.Series.vbt.signals.*`
* `SignalsDFAccessor` -&gt; `pd.DataFrame.vbt.signals.*`

```python-repl
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; # vectorbt.signals.accessors.SignalsAccessor.pos_rank
&gt;&gt;&gt; pd.Series([False, True, True, True, False]).vbt.signals.pos_rank()
0    0
1    1
2    2
3    3
4    0
dtype: int64
```

The accessors extend `vectorbt.generic.accessors`.

!!! note
    The underlying Series/DataFrame should already be a signal series.

    Input arrays should be `np.bool_`.

    Grouping is only supported by the methods that accept the `group_by` argument.

    Accessors do not utilize caching.

Run for the examples below:
    
```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; mask = pd.DataFrame({
...     &#39;a&#39;: [True, False, False, False, False],
...     &#39;b&#39;: [True, False, True, False, True],
...     &#39;c&#39;: [True, True, True, False, False]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5)
... ]))
&gt;&gt;&gt; mask
                a      b      c
2020-01-01   True   True   True
2020-01-02  False  False   True
2020-01-03  False   True   True
2020-01-04  False  False  False
2020-01-05  False   True  False
```

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats` and `SignalsAccessor.metrics`.

```python-repl
&gt;&gt;&gt; mask.vbt.signals.stats(column=&#39;a&#39;)
Start                       2020-01-01 00:00:00
End                         2020-01-05 00:00:00
Period                          5 days 00:00:00
Total                                         1
Rate [%]                                     20
First Index                 2020-01-01 00:00:00
Last Index                  2020-01-01 00:00:00
Norm Avg Index [-1, 1]                       -1
Distance: Min                               NaT
Distance: Max                               NaT
Distance: Mean                              NaT
Distance: Std                               NaT
Total Partitions                              1
Partition Rate [%]                          100
Partition Length: Min           1 days 00:00:00
Partition Length: Max           1 days 00:00:00
Partition Length: Mean          1 days 00:00:00
Partition Length: Std                       NaT
Partition Distance: Min                     NaT
Partition Distance: Max                     NaT
Partition Distance: Mean                    NaT
Partition Distance: Std                     NaT
Name: a, dtype: object
```

We can pass another signal array to compare this array with:

```python-repl
&gt;&gt;&gt; mask.vbt.signals.stats(column=&#39;a&#39;, settings=dict(other=mask[&#39;b&#39;]))
Start                       2020-01-01 00:00:00
End                         2020-01-05 00:00:00
Period                          5 days 00:00:00
Total                                         1
Rate [%]                                     20
Total Overlapping                             1
Overlapping Rate [%]                    33.3333
First Index                 2020-01-01 00:00:00
Last Index                  2020-01-01 00:00:00
Norm Avg Index [-1, 1]                       -1
Distance -&gt; Other: Min          0 days 00:00:00
Distance -&gt; Other: Max          0 days 00:00:00
Distance -&gt; Other: Mean         0 days 00:00:00
Distance -&gt; Other: Std                      NaT
Total Partitions                              1
Partition Rate [%]                          100
Partition Length: Min           1 days 00:00:00
Partition Length: Max           1 days 00:00:00
Partition Length: Mean          1 days 00:00:00
Partition Length: Std                       NaT
Partition Distance: Min                     NaT
Partition Distance: Max                     NaT
Partition Distance: Mean                    NaT
Partition Distance: Std                     NaT
Name: a, dtype: object
```

We can also return duration as a floating number rather than a timedelta:

```python-repl
&gt;&gt;&gt; mask.vbt.signals.stats(column=&#39;a&#39;, settings=dict(to_timedelta=False))
Start                       2020-01-01 00:00:00
End                         2020-01-05 00:00:00
Period                                        5
Total                                         1
Rate [%]                                     20
First Index                 2020-01-01 00:00:00
Last Index                  2020-01-01 00:00:00
Norm Avg Index [-1, 1]                       -1
Distance: Min                               NaN
Distance: Max                               NaN
Distance: Mean                              NaN
Distance: Std                               NaN
Total Partitions                              1
Partition Rate [%]                          100
Partition Length: Min                         1
Partition Length: Max                         1
Partition Length: Mean                        1
Partition Length: Std                       NaN
Partition Distance: Min                     NaN
Partition Distance: Max                     NaN
Partition Distance: Mean                    NaN
Partition Distance: Std                     NaN
Name: a, dtype: object
```

`SignalsAccessor.stats` also supports (re-)grouping:

```python-repl
&gt;&gt;&gt; mask.vbt.signals.stats(column=0, group_by=[0, 0, 1])
Start                       2020-01-01 00:00:00
End                         2020-01-05 00:00:00
Period                          5 days 00:00:00
Total                                         4
Rate [%]                                     40
First Index                 2020-01-01 00:00:00
Last Index                  2020-01-05 00:00:00
Norm Avg Index [-1, 1]                    -0.25
Distance: Min                   2 days 00:00:00
Distance: Max                   2 days 00:00:00
Distance: Mean                  2 days 00:00:00
Distance: Std                   0 days 00:00:00
Total Partitions                              4
Partition Rate [%]                          100
Partition Length: Min           1 days 00:00:00
Partition Length: Max           1 days 00:00:00
Partition Length: Mean          1 days 00:00:00
Partition Length: Std           0 days 00:00:00
Partition Distance: Min         2 days 00:00:00
Partition Distance: Max         2 days 00:00:00
Partition Distance: Mean        2 days 00:00:00
Partition Distance: Std         0 days 00:00:00
Name: 0, dtype: object
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots` and `SignalsAccessor.subplots`.

This class inherits subplots from `vectorbt.generic.accessors.GenericAccessor`.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
import warnings

from vectorbt import _typing as tp
from vectorbt.root_accessors import register_dataframe_vbt_accessor, register_series_vbt_accessor
from vectorbt.utils import checks
from vectorbt.utils.decorators import class_or_instancemethod
from vectorbt.utils.config import merge_dicts, Config
from vectorbt.utils.colors import adjust_lightness
from vectorbt.utils.template import RepEval
from vectorbt.base import reshape_fns
from vectorbt.base.array_wrapper import ArrayWrapper
from vectorbt.records.mapped_array import MappedArray
from vectorbt.generic.accessors import GenericAccessor, GenericSRAccessor, GenericDFAccessor
from vectorbt.generic import plotting
from vectorbt.generic.ranges import Ranges
from vectorbt.generic import nb as generic_nb
from vectorbt.signals import nb

__pdoc__ = {}


class SignalsAccessor(GenericAccessor):
    &#34;&#34;&#34;Accessor on top of signal series. For both, Series and DataFrames.

    Accessible through `pd.Series.vbt.signals` and `pd.DataFrame.vbt.signals`.&#34;&#34;&#34;

    def __init__(self, obj: tp.SeriesFrame, **kwargs) -&gt; None:
        checks.assert_dtype(obj, np.bool_)

        GenericAccessor.__init__(self, obj, **kwargs)

    @property
    def sr_accessor_cls(self) -&gt; tp.Type[&#34;SignalsSRAccessor&#34;]:
        &#34;&#34;&#34;Accessor class for `pd.Series`.&#34;&#34;&#34;
        return SignalsSRAccessor

    @property
    def df_accessor_cls(self) -&gt; tp.Type[&#34;SignalsDFAccessor&#34;]:
        &#34;&#34;&#34;Accessor class for `pd.DataFrame`.&#34;&#34;&#34;
        return SignalsDFAccessor

    # ############# Overriding ############# #

    def bshift(self, *args, fill_value: bool = False, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;`vectorbt.generic.accessors.GenericAccessor.bshift` with `fill_value=False`.&#34;&#34;&#34;
        return GenericAccessor.bshift(self, *args, fill_value=fill_value, **kwargs)

    def fshift(self, *args, fill_value: bool = False, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;`vectorbt.generic.accessors.GenericAccessor.fshift` with `fill_value=False`.&#34;&#34;&#34;
        return GenericAccessor.fshift(self, *args, fill_value=fill_value, **kwargs)

    @classmethod
    def empty(cls, *args, fill_value: bool = False, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;`vectorbt.base.accessors.BaseAccessor.empty` with `fill_value=False`.&#34;&#34;&#34;
        return GenericAccessor.empty(*args, fill_value=fill_value, dtype=np.bool_, **kwargs)

    @classmethod
    def empty_like(cls, *args, fill_value: bool = False, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;`vectorbt.base.accessors.BaseAccessor.empty_like` with `fill_value=False`.&#34;&#34;&#34;
        return GenericAccessor.empty_like(*args, fill_value=fill_value, dtype=np.bool_, **kwargs)

    # ############# Generation ############# #

    @classmethod
    def generate(cls,
                 shape: tp.RelaxedShape,
                 choice_func_nb: tp.ChoiceFunc, *args,
                 pick_first: bool = False,
                 **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;See `vectorbt.signals.nb.generate_nb`.

        `**kwargs` will be passed to pandas constructor.

        ## Example

        Generate random signals manually:

        ```python-repl
        &gt;&gt;&gt; @njit
        ... def choice_func_nb(from_i, to_i, col):
        ...     return col + from_i

        &gt;&gt;&gt; pd.DataFrame.vbt.signals.generate((5, 3),
        ...     choice_func_nb, index=mask.index, columns=mask.columns)
                        a      b      c
        2020-01-01   True  False  False
        2020-01-02  False   True  False
        2020-01-03  False  False   True
        2020-01-04  False  False  False
        2020-01-05  False  False  False
        ```
        &#34;&#34;&#34;
        checks.assert_numba_func(choice_func_nb)

        if not isinstance(shape, tuple):
            shape = (shape, 1)
        elif isinstance(shape, tuple) and len(shape) == 1:
            shape = (shape[0], 1)

        result = nb.generate_nb(shape, pick_first, choice_func_nb, *args)

        if cls.is_series():
            if shape[1] &gt; 1:
                raise ValueError(&#34;Use DataFrame accessor&#34;)
            return pd.Series(result[:, 0], **kwargs)
        return pd.DataFrame(result, **kwargs)

    @classmethod
    def generate_both(cls,
                      shape: tp.RelaxedShape,
                      entry_choice_func_nb: tp.Optional[tp.ChoiceFunc] = None,
                      entry_args: tp.ArgsLike = None,
                      exit_choice_func_nb: tp.Optional[tp.ChoiceFunc] = None,
                      exit_args: tp.ArgsLike = None,
                      entry_wait: int = 1,
                      exit_wait: int = 1,
                      entry_pick_first: bool = True,
                      exit_pick_first: bool = True,
                      **kwargs) -&gt; tp.Tuple[tp.SeriesFrame, tp.SeriesFrame]:
        &#34;&#34;&#34;See `vectorbt.signals.nb.generate_enex_nb`.

        `**kwargs` will be passed to pandas constructor.

        ## Example

        Generate entry and exit signals one after another. Each column increment
        the number of ticks to wait before placing the exit signal.

        ```python-repl
        &gt;&gt;&gt; @njit
        ... def entry_choice_func_nb(from_i, to_i, col, temp_idx_arr):
        ...     temp_idx_arr[0] = from_i
        ...     return temp_idx_arr[:1]  # array with one signal

        &gt;&gt;&gt; @njit
        ... def exit_choice_func_nb(from_i, to_i, col, temp_idx_arr):
        ...     wait = col
        ...     temp_idx_arr[0] = from_i + wait
        ...     if temp_idx_arr[0] &lt; to_i:
        ...         return temp_idx_arr[:1]  # array with one signal
        ...     return temp_idx_arr[:0]  # empty array

        &gt;&gt;&gt; temp_idx_arr = np.empty((1,), dtype=np.int_)  # reuse memory
        &gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_both(
        ...     (5, 3),
        ...     entry_choice_func_nb, (temp_idx_arr,),
        ...     exit_choice_func_nb, (temp_idx_arr,),
        ...     index=mask.index, columns=mask.columns)
        &gt;&gt;&gt; en
                        a      b      c
        2020-01-01   True   True   True
        2020-01-02  False  False  False
        2020-01-03   True  False  False
        2020-01-04  False   True  False
        2020-01-05   True  False   True
        &gt;&gt;&gt; ex
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True  False  False
        2020-01-03  False   True  False
        2020-01-04   True  False   True
        2020-01-05  False  False  False
        ```
        &#34;&#34;&#34;
        checks.assert_not_none(entry_choice_func_nb)
        checks.assert_not_none(exit_choice_func_nb)
        checks.assert_numba_func(entry_choice_func_nb)
        checks.assert_numba_func(exit_choice_func_nb)
        if entry_args is None:
            entry_args = ()
        if exit_args is None:
            exit_args = ()

        if not isinstance(shape, tuple):
            shape = (shape, 1)
        elif isinstance(shape, tuple) and len(shape) == 1:
            shape = (shape[0], 1)

        result1, result2 = nb.generate_enex_nb(
            shape,
            entry_wait,
            exit_wait,
            entry_pick_first,
            exit_pick_first,
            entry_choice_func_nb, entry_args,
            exit_choice_func_nb, exit_args
        )
        if cls.is_series():
            if shape[1] &gt; 1:
                raise ValueError(&#34;Use DataFrame accessor&#34;)
            return pd.Series(result1[:, 0], **kwargs), pd.Series(result2[:, 0], **kwargs)
        return pd.DataFrame(result1, **kwargs), pd.DataFrame(result2, **kwargs)

    def generate_exits(self,
                       exit_choice_func_nb: tp.ChoiceFunc, *args,
                       wait: int = 1,
                       until_next: bool = True,
                       skip_until_exit: bool = False,
                       pick_first: bool = False,
                       wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;See `vectorbt.signals.nb.generate_ex_nb`.

        ## Example

        Fill all space after signals in `mask`:

        ```python-repl
        &gt;&gt;&gt; @njit
        ... def exit_choice_func_nb(from_i, to_i, col, temp_range):
        ...     return temp_range[from_i:to_i]

        &gt;&gt;&gt; temp_range = np.arange(mask.shape[0])  # reuse memory
        &gt;&gt;&gt; mask.vbt.signals.generate_exits(exit_choice_func_nb, temp_range)
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True   True  False
        2020-01-03   True  False  False
        2020-01-04   True   True   True
        2020-01-05   True  False   True
        ```
        &#34;&#34;&#34;
        checks.assert_numba_func(exit_choice_func_nb)

        exits = nb.generate_ex_nb(
            self.to_2d_array(),
            wait,
            until_next,
            skip_until_exit,
            pick_first,
            exit_choice_func_nb,
            *args
        )
        return self.wrapper.wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))

    # ############# Filtering ############# #

    @class_or_instancemethod
    def clean(cls_or_self,
              *args,
              entry_first: bool = True,
              broadcast_kwargs: tp.KwargsLike = None,
              wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeTuple[tp.SeriesFrame]:
        &#34;&#34;&#34;Clean signals.

        If one array passed, see `SignalsAccessor.first`.
        If two arrays passed, entries and exits, see `vectorbt.signals.nb.clean_enex_nb`.&#34;&#34;&#34;
        if not isinstance(cls_or_self, type):
            args = (cls_or_self.obj, *args)
        if len(args) == 1:
            obj = args[0]
            if not isinstance(obj, (pd.Series, pd.DataFrame)):
                wrapper = ArrayWrapper.from_shape(np.asarray(obj).shape)
                obj = wrapper.wrap(obj)
            return obj.vbt.signals.first(wrap_kwargs=wrap_kwargs)
        elif len(args) == 2:
            if broadcast_kwargs is None:
                broadcast_kwargs = {}
            entries, exits = reshape_fns.broadcast(*args, **broadcast_kwargs)
            entries_out, exits_out = nb.clean_enex_nb(
                reshape_fns.to_2d_array(entries),
                reshape_fns.to_2d_array(exits),
                entry_first
            )
            return (
                ArrayWrapper.from_obj(entries).wrap(entries_out, group_by=False, **merge_dicts({}, wrap_kwargs)),
                ArrayWrapper.from_obj(exits).wrap(exits_out, group_by=False, **merge_dicts({}, wrap_kwargs))
            )
        else:
            raise ValueError(&#34;Either one or two arrays must be passed&#34;)

    # ############# Random ############# #

    @classmethod
    def generate_random(cls,
                        shape: tp.RelaxedShape,
                        n: tp.Optional[tp.ArrayLike] = None,
                        prob: tp.Optional[tp.ArrayLike] = None,
                        pick_first: bool = False,
                        seed: tp.Optional[int] = None,
                        **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Generate signals randomly.

        If `n` is set, see `vectorbt.signals.nb.generate_rand_nb`.
        If `prob` is set, see `vectorbt.signals.nb.generate_rand_by_prob_nb`.

        `n` should be either a scalar or an array that will broadcast to the number of columns.
        `prob` should be either a single number or an array that will broadcast to match `shape`.
        `**kwargs` will be passed to pandas constructor.

        ## Example

        For each column, generate a variable number of signals:

        ```python-repl
        &gt;&gt;&gt; pd.DataFrame.vbt.signals.generate_random((5, 3), n=[0, 1, 2],
        ...     seed=42, index=mask.index, columns=mask.columns)
                        a      b      c
        2020-01-01  False  False   True
        2020-01-02  False  False   True
        2020-01-03  False  False  False
        2020-01-04  False   True  False
        2020-01-05  False  False  False
        ```

        For each column and time step, pick a signal with 50% probability:

        ```python-repl
        &gt;&gt;&gt; pd.DataFrame.vbt.signals.generate_random((5, 3), prob=0.5,
        ...     seed=42, index=mask.index, columns=mask.columns)
                        a      b      c
        2020-01-01   True   True   True
        2020-01-02  False   True  False
        2020-01-03  False  False  False
        2020-01-04  False  False   True
        2020-01-05   True  False   True
        ```
        &#34;&#34;&#34;
        flex_2d = True
        if not isinstance(shape, tuple):
            flex_2d = False
            shape = (shape, 1)
        elif isinstance(shape, tuple) and len(shape) == 1:
            flex_2d = False
            shape = (shape[0], 1)

        if n is not None and prob is not None:
            raise ValueError(&#34;Either n or prob should be set, not both&#34;)
        if n is not None:
            n = np.broadcast_to(n, shape[1])
            result = nb.generate_rand_nb(shape, n, seed=seed)
        elif prob is not None:
            prob = np.broadcast_to(prob, shape)
            result = nb.generate_rand_by_prob_nb(shape, prob, pick_first, flex_2d, seed=seed)
        else:
            raise ValueError(&#34;At least n or prob should be set&#34;)

        if cls.is_series():
            if shape[1] &gt; 1:
                raise ValueError(&#34;Use DataFrame accessor&#34;)
            return pd.Series(result[:, 0], **kwargs)
        return pd.DataFrame(result, **kwargs)

    # ############# Exits ############# #

    @classmethod
    def generate_random_both(cls,
                             shape: tp.RelaxedShape,
                             n: tp.Optional[tp.ArrayLike] = None,
                             entry_prob: tp.Optional[tp.ArrayLike] = None,
                             exit_prob: tp.Optional[tp.ArrayLike] = None,
                             seed: tp.Optional[int] = None,
                             entry_wait: int = 1,
                             exit_wait: int = 1,
                             entry_pick_first: bool = True,
                             exit_pick_first: bool = True,
                             **kwargs) -&gt; tp.Tuple[tp.SeriesFrame, tp.SeriesFrame]:
        &#34;&#34;&#34;Generate chain of entry and exit signals randomly.

        If `n` is set, see `vectorbt.signals.nb.generate_rand_enex_nb`.
        If `entry_prob` and `exit_prob` are set, see `vectorbt.signals.nb.generate_rand_enex_by_prob_nb`.

        For arguments, see `SignalsAccessor.generate_random`.

        ## Example

        For each column, generate two entries and exits randomly:

        ```python-repl
        &gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_random_both(
        ...     (5, 3), n=2, seed=42, index=mask.index, columns=mask.columns)
        &gt;&gt;&gt; en
                        a      b      c
        2020-01-01   True   True   True
        2020-01-02  False  False  False
        2020-01-03   True   True  False
        2020-01-04  False  False   True
        2020-01-05  False  False  False
        &gt;&gt;&gt; ex
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True   True   True
        2020-01-03  False  False  False
        2020-01-04  False   True  False
        2020-01-05   True  False   True
        ```

        For each column and time step, pick entry with 50% probability and exit right after:

        ```python-repl
        &gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_random_both(
        ...     (5, 3), entry_prob=0.5, exit_prob=1.,
        ...     seed=42, index=mask.index, columns=mask.columns)
        &gt;&gt;&gt; en
                        a      b      c
        2020-01-01   True   True   True
        2020-01-02  False  False  False
        2020-01-03  False  False  False
        2020-01-04  False  False   True
        2020-01-05   True  False  False
        &gt;&gt;&gt; ex
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True   True  False
        2020-01-03  False  False   True
        2020-01-04  False   True  False
        2020-01-05   True  False   True
        ```
        &#34;&#34;&#34;
        flex_2d = True
        if not isinstance(shape, tuple):
            flex_2d = False
            shape = (shape, 1)
        elif isinstance(shape, tuple) and len(shape) == 1:
            flex_2d = False
            shape = (shape[0], 1)

        if n is not None and (entry_prob is not None or exit_prob is not None):
            raise ValueError(&#34;Either n or any of the entry_prob and exit_prob should be set, not both&#34;)
        if n is not None:
            n = np.broadcast_to(n, shape[1])
            entries, exits = nb.generate_rand_enex_nb(shape, n, entry_wait, exit_wait, seed=seed)
        elif entry_prob is not None and exit_prob is not None:
            entry_prob = np.broadcast_to(entry_prob, shape)
            exit_prob = np.broadcast_to(exit_prob, shape)
            entries, exits = nb.generate_rand_enex_by_prob_nb(
                shape,
                entry_prob,
                exit_prob,
                entry_wait,
                exit_wait,
                entry_pick_first,
                exit_pick_first,
                flex_2d,
                seed=seed
            )
        else:
            raise ValueError(&#34;At least n, or entry_prob and exit_prob should be set&#34;)

        if cls.is_series():
            if shape[1] &gt; 1:
                raise ValueError(&#34;Use DataFrame accessor&#34;)
            return pd.Series(entries[:, 0], **kwargs), pd.Series(exits[:, 0], **kwargs)
        return pd.DataFrame(entries, **kwargs), pd.DataFrame(exits, **kwargs)

    def generate_random_exits(self,
                              prob: tp.Optional[tp.ArrayLike] = None,
                              seed: tp.Optional[int] = None,
                              wait: int = 1,
                              until_next: bool = True,
                              skip_until_exit: bool = False,
                              wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Generate exit signals randomly.

        If `prob` is None, see `vectorbt.signals.nb.generate_rand_ex_nb`.
        Otherwise, see `vectorbt.signals.nb.generate_rand_ex_by_prob_nb`.

        ## Example

        After each entry in `mask`, generate exactly one exit:

        ```python-repl
        &gt;&gt;&gt; mask.vbt.signals.generate_random_exits(seed=42)
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02  False   True  False
        2020-01-03   True  False  False
        2020-01-04  False   True  False
        2020-01-05  False  False   True
        ```

        After each entry in `mask` and at each time step, generate exit with 50% probability:

        ```python-repl
        &gt;&gt;&gt; mask.vbt.signals.generate_random_exits(prob=0.5, seed=42)
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True  False  False
        2020-01-03  False  False  False
        2020-01-04  False  False  False
        2020-01-05  False  False   True
        ```
        &#34;&#34;&#34;
        if prob is not None:
            obj, prob = reshape_fns.broadcast(self.obj, prob, keep_raw=[False, True])
            exits = nb.generate_rand_ex_by_prob_nb(
                reshape_fns.to_2d_array(obj),
                prob,
                wait,
                until_next,
                skip_until_exit,
                obj.ndim == 2,
                seed=seed
            )
            return ArrayWrapper.from_obj(obj).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))
        exits = nb.generate_rand_ex_nb(
            self.to_2d_array(),
            wait,
            until_next,
            skip_until_exit,
            seed=seed
        )
        return self.wrapper.wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))

    def generate_stop_exits(self,
                            ts: tp.ArrayLike,
                            stop: tp.ArrayLike,
                            trailing: tp.ArrayLike = False,
                            entry_wait: int = 1,
                            exit_wait: int = 1,
                            until_next: bool = True,
                            skip_until_exit: bool = False,
                            pick_first: bool = True,
                            chain: bool = False,
                            broadcast_kwargs: tp.KwargsLike = None,
                            wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeTuple[tp.SeriesFrame]:
        &#34;&#34;&#34;Generate exits based on when `ts` hits the stop.

        For arguments, see `vectorbt.signals.nb.stop_choice_nb`.
        If `chain` is True, see `vectorbt.signals.nb.generate_stop_enex_nb`.
        Otherwise, see `vectorbt.signals.nb.generate_stop_ex_nb`.

        Arguments `entries`, `ts` and `stop` will broadcast using `vectorbt.base.reshape_fns.broadcast`
        and `broadcast_kwargs`.

        For arguments, see `vectorbt.signals.nb.stop_choice_nb`.

        !!! hint
            Default arguments will generate an exit signal strictly between two entry signals.
            If both entry signals are too close to each other, no exit will be generated.

            To ignore all entries that come between an entry and its exit,
            set `until_next` to False and `skip_until_exit` to True.

            To remove all entries that come between an entry and its exit,
            set `chain` to True. This will return two arrays: new entries and exits.

        ## Example

        ```python-repl
        &gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1])

        &gt;&gt;&gt; # stop loss
        &gt;&gt;&gt; mask.vbt.signals.generate_stop_exits(ts, -0.1)
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02  False  False  False
        2020-01-03  False  False  False
        2020-01-04  False   True   True
        2020-01-05  False  False  False

        &gt;&gt;&gt; # trailing stop loss
        &gt;&gt;&gt; mask.vbt.signals.generate_stop_exits(ts, -0.1, trailing=True)
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02  False  False  False
        2020-01-03  False  False  False
        2020-01-04   True   True   True
        2020-01-05  False  False  False
        ```
        &#34;&#34;&#34;
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        entries = self.obj

        keep_raw = (False, True, True, True)
        broadcast_kwargs = merge_dicts(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
        entries, ts, stop, trailing = reshape_fns.broadcast(
            entries, ts, stop, trailing, **broadcast_kwargs, keep_raw=keep_raw)

        # Perform generation
        if chain:
            new_entries, exits = nb.generate_stop_enex_nb(
                reshape_fns.to_2d_array(entries),
                ts,
                stop,
                trailing,
                entry_wait,
                exit_wait,
                pick_first,
                entries.ndim == 2
            )
            return ArrayWrapper.from_obj(entries).wrap(new_entries, group_by=False, **merge_dicts({}, wrap_kwargs)), \
                   ArrayWrapper.from_obj(entries).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))
        else:
            if skip_until_exit and until_next:
                warnings.warn(&#34;skip_until_exit=True has only effect when until_next=False&#34;, stacklevel=2)
            exits = nb.generate_stop_ex_nb(
                reshape_fns.to_2d_array(entries),
                ts,
                stop,
                trailing,
                exit_wait,
                until_next,
                skip_until_exit,
                pick_first,
                entries.ndim == 2
            )
            return ArrayWrapper.from_obj(entries).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))

    def generate_ohlc_stop_exits(self,
                                 open: tp.ArrayLike,
                                 high: tp.Optional[tp.ArrayLike] = None,
                                 low: tp.Optional[tp.ArrayLike] = None,
                                 close: tp.Optional[tp.ArrayLike] = None,
                                 is_open_safe: bool = True,
                                 out_dict: tp.Optional[tp.Dict[str, tp.ArrayLike]] = None,
                                 sl_stop: tp.ArrayLike = np.nan,
                                 sl_trail: tp.ArrayLike = False,
                                 tp_stop: tp.ArrayLike = np.nan,
                                 reverse: tp.ArrayLike = False,
                                 entry_wait: int = 1,
                                 exit_wait: int = 1,
                                 until_next: bool = True,
                                 skip_until_exit: bool = False,
                                 pick_first: bool = True,
                                 chain: bool = False,
                                 broadcast_kwargs: tp.KwargsLike = None,
                                 wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeTuple[tp.SeriesFrame]:
        &#34;&#34;&#34;Generate exits based on when the price hits (trailing) stop loss or take profit.

        !!! hint
            This function is meant for signal analysis. For backtesting, consider using
            the stop logic integrated into `vectorbt.portfolio.base.Portfolio.from_signals`.

        If any of `high`, `low` or `close` is None, it will be set to `open`.

        Use `out_dict` as a dict to pass `stop_price` and `stop_type` arrays. You can also
        set `out_dict` to {} to produce these arrays automatically and still have access to them.

        For arguments, see `vectorbt.signals.nb.ohlc_stop_choice_nb`.
        If `chain` is True, see `vectorbt.signals.nb.generate_ohlc_stop_enex_nb`.
        Otherwise, see `vectorbt.signals.nb.generate_ohlc_stop_ex_nb`.

        All array-like arguments including stops and `out_dict` will broadcast using
        `vectorbt.base.reshape_fns.broadcast` and `broadcast_kwargs`.

        For arguments, see `vectorbt.signals.nb.ohlc_stop_choice_nb`.

        !!! note
            `open` isn&#39;t necessarily open price, but can be any entry price (even previous close).
            Stop price is calculated based solely on the entry price.

        !!! hint
            Default arguments will generate an exit signal strictly between two entry signals.
            If both entry signals are too close to each other, no exit will be generated.

            To ignore all entries that come between an entry and its exit,
            set `until_next` to False and `skip_until_exit` to True.

            To remove all entries that come between an entry and its exit,
            set `chain` to True. This will return two arrays: new entries and exits.

        ## Example

        The same example as under `vectorbt.signals.nb.generate_ohlc_stop_ex_nb`:

        ```python-repl
        &gt;&gt;&gt; from vectorbt.signals.enums import StopType

        &gt;&gt;&gt; price = pd.DataFrame({
        ...     &#39;open&#39;: [10, 11, 12, 11, 10],
        ...     &#39;high&#39;: [11, 12, 13, 12, 11],
        ...     &#39;low&#39;: [9, 10, 11, 10, 9],
        ...     &#39;close&#39;: [10, 11, 12, 11, 10]
        ... })
        &gt;&gt;&gt; out_dict = {}
        &gt;&gt;&gt; exits = mask.vbt.signals.generate_ohlc_stop_exits(
        ...     price[&#39;open&#39;], price[&#39;high&#39;], price[&#39;low&#39;], price[&#39;close&#39;],
        ...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict)
        &gt;&gt;&gt; exits
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True   True  False
        2020-01-03  False  False  False
        2020-01-04  False   True   True
        2020-01-05  False  False  False

        &gt;&gt;&gt; out_dict[&#39;stop_price&#39;]
                       a     b     c
        2020-01-01   NaN   NaN   NaN
        2020-01-02  11.0  11.0   NaN
        2020-01-03   NaN   NaN   NaN
        2020-01-04   NaN  10.8  10.8
        2020-01-05   NaN   NaN   NaN

        &gt;&gt;&gt; out_dict[&#39;stop_type&#39;].vbt(mapping=StopType).apply_mapping()
                             a           b          c
        2020-01-01        None        None       None
        2020-01-02  TakeProfit  TakeProfit       None
        2020-01-03        None        None       None
        2020-01-04        None   TrailStop  TrailStop
        2020-01-05        None        None       None
        ```

        Notice how the first two entry signals in the third column have no exit signal - there is
        no room between them for an exit signal. To find an exit for the first entry and ignore all
        entries that are in-between them, we can pass `until_next=False` and `skip_until_exit=True`:

        ```python-repl
        &gt;&gt;&gt; out_dict = {}
        &gt;&gt;&gt; exits = mask.vbt.signals.generate_ohlc_stop_exits(
        ...     price[&#39;open&#39;], price[&#39;high&#39;], price[&#39;low&#39;], price[&#39;close&#39;],
        ...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict,
        ...     until_next=False, skip_until_exit=True)
        &gt;&gt;&gt; exits
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True   True   True
        2020-01-03  False  False  False
        2020-01-04  False   True   True
        2020-01-05  False  False  False

        &gt;&gt;&gt; out_dict[&#39;stop_price&#39;]
        2020-01-01   NaN   NaN   NaN
        2020-01-02  11.0  11.0  11.0
        2020-01-03   NaN   NaN   NaN
        2020-01-04   NaN  10.8  10.8
        2020-01-05   NaN   NaN   NaN

        &gt;&gt;&gt; out_dict[&#39;stop_type&#39;].vbt(mapping=StopType).apply_mapping()
                             a           b           c
        2020-01-01        None        None        None
        2020-01-02  TakeProfit  TakeProfit  TakeProfit
        2020-01-03        None        None        None
        2020-01-04        None   TrailStop   TrailStop
        2020-01-05        None        None        None
        ```

        Now, the first signal in the third column gets executed regardless of the entries that come next,
        which is very similar to the logic that is implemented in `vectorbt.portfolio.base.Portfolio.from_signals`.

        To automatically remove all ignored entry signals, pass `chain=True`.
        This will return a new entries array:

        ```python-repl
        &gt;&gt;&gt; out_dict = {}
        &gt;&gt;&gt; new_entries, exits = mask.vbt.signals.generate_ohlc_stop_exits(
        ...     price[&#39;open&#39;], price[&#39;high&#39;], price[&#39;low&#39;], price[&#39;close&#39;],
        ...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict,
        ...     chain=True)
        &gt;&gt;&gt; new_entries
                        a      b      c
        2020-01-01   True   True   True
        2020-01-02  False  False  False  &lt;&lt; removed entry in the third column
        2020-01-03  False   True   True
        2020-01-04  False  False  False
        2020-01-05  False   True  False
        &gt;&gt;&gt; exits
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True   True   True
        2020-01-03  False  False  False
        2020-01-04  False   True   True
        2020-01-05  False  False  False
        ```

        !!! warning
            The last two examples above make entries dependent upon exits - this makes only sense
            if you have no other exit arrays to combine this stop exit array with.
        &#34;&#34;&#34;
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        entries = self.obj
        if high is None:
            high = open
        if low is None:
            low = open
        if close is None:
            close = open
        if out_dict is None:
            out_dict_passed = False
            out_dict = {}
        else:
            out_dict_passed = True
        stop_price_out = out_dict.get(&#39;stop_price&#39;, np.nan if out_dict_passed else None)
        stop_type_out = out_dict.get(&#39;stop_type&#39;, -1 if out_dict_passed else None)
        out_args = ()
        if stop_price_out is not None:
            out_args += (stop_price_out,)
        if stop_type_out is not None:
            out_args += (stop_type_out,)

        keep_raw = (False, True, True, True, True, True, True, True, True) + (False,) * len(out_args)
        broadcast_kwargs = merge_dicts(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
        entries, open, high, low, close, sl_stop, sl_trail, tp_stop, reverse, *out_args = reshape_fns.broadcast(
            entries, open, high, low, close, sl_stop, sl_trail, tp_stop, reverse, *out_args,
            **broadcast_kwargs, keep_raw=keep_raw)
        if stop_price_out is None:
            stop_price_out = np.empty_like(entries, dtype=np.float_)
        else:
            stop_price_out = out_args[0]
            out_args = out_args[1:]
        if stop_type_out is None:
            stop_type_out = np.empty_like(entries, dtype=np.int_)
        else:
            stop_type_out = out_args[0]
        stop_price_out = reshape_fns.to_2d_array(stop_price_out)
        stop_type_out = reshape_fns.to_2d_array(stop_type_out)

        # Perform generation
        if chain:
            new_entries, exits = nb.generate_ohlc_stop_enex_nb(
                reshape_fns.to_2d_array(entries),
                open,
                high,
                low,
                close,
                stop_price_out,
                stop_type_out,
                sl_stop,
                sl_trail,
                tp_stop,
                reverse,
                is_open_safe,
                entry_wait,
                exit_wait,
                pick_first,
                entries.ndim == 2
            )
            out_dict[&#39;stop_price&#39;] = ArrayWrapper.from_obj(entries).wrap(
                stop_price_out, group_by=False, **merge_dicts({}, wrap_kwargs))
            out_dict[&#39;stop_type&#39;] = ArrayWrapper.from_obj(entries).wrap(
                stop_type_out, group_by=False, **merge_dicts({}, wrap_kwargs))
            return ArrayWrapper.from_obj(entries).wrap(new_entries, group_by=False, **merge_dicts({}, wrap_kwargs)), \
                   ArrayWrapper.from_obj(entries).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))
        else:
            if skip_until_exit and until_next:
                warnings.warn(&#34;skip_until_exit=True has only effect when until_next=False&#34;, stacklevel=2)
            exits = nb.generate_ohlc_stop_ex_nb(
                reshape_fns.to_2d_array(entries),
                open,
                high,
                low,
                close,
                stop_price_out,
                stop_type_out,
                sl_stop,
                sl_trail,
                tp_stop,
                reverse,
                is_open_safe,
                exit_wait,
                until_next,
                skip_until_exit,
                pick_first,
                entries.ndim == 2
            )
            out_dict[&#39;stop_price&#39;] = ArrayWrapper.from_obj(entries).wrap(
                stop_price_out, group_by=False, **merge_dicts({}, wrap_kwargs))
            out_dict[&#39;stop_type&#39;] = ArrayWrapper.from_obj(entries).wrap(
                stop_type_out, group_by=False, **merge_dicts({}, wrap_kwargs))
            return ArrayWrapper.from_obj(entries).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))

    # ############# Ranges ############# #

    def between_ranges(self,
                       other: tp.Optional[tp.ArrayLike] = None,
                       from_other: bool = False,
                       broadcast_kwargs: tp.KwargsLike = None,
                       group_by: tp.GroupByLike = None,
                       attach_ts: bool = True,
                       attach_other: bool = False,
                       **kwargs) -&gt; Ranges:
        &#34;&#34;&#34;Wrap the result of `vectorbt.signals.nb.between_ranges_nb`
        with `vectorbt.generic.ranges.Ranges`.

        If `other` specified, see `vectorbt.signals.nb.between_two_ranges_nb`.
        Both will broadcast using `vectorbt.base.reshape_fns.broadcast` and `broadcast_kwargs`.

        ## Example

        One array:

        ```python-repl
        &gt;&gt;&gt; mask_sr = pd.Series([True, False, False, True, False, True, True])
        &gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges()
        &gt;&gt;&gt; ranges
        &lt;vectorbt.generic.ranges.Ranges at 0x7ff29ea7c7b8&gt;

        &gt;&gt;&gt; ranges.records_readable
           Range Id  Column  Start Timestamp  End Timestamp  Status
        0         0       0                0              3  Closed
        1         1       0                3              5  Closed
        2         2       0                5              6  Closed

        &gt;&gt;&gt; ranges.duration.values
        array([3, 2, 1])
        ```

        Two arrays, traversing the signals of the first array:

        ```python-repl
        &gt;&gt;&gt; mask_sr = pd.Series([True, True, True, False, False])
        &gt;&gt;&gt; mask_sr2 = pd.Series([False, False, True, False, True])
        &gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges(other=mask_sr2)
        &gt;&gt;&gt; ranges
        &lt;vectorbt.generic.ranges.Ranges at 0x7ff29e3b80f0&gt;

        &gt;&gt;&gt; ranges.records_readable
           Range Id  Column  Start Timestamp  End Timestamp  Status
        0         0       0                0              2  Closed
        1         1       0                1              2  Closed
        2         2       0                2              2  Closed

        &gt;&gt;&gt; ranges.duration.values
        array([2, 1, 0])
        ```

        Two arrays, traversing the signals of the second array:

        ```python-repl
        &gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges(other=mask_sr2, from_other=True)
        &gt;&gt;&gt; ranges
        &lt;vectorbt.generic.ranges.Ranges at 0x7ff29eccbd68&gt;

        &gt;&gt;&gt; ranges.records_readable
           Range Id  Column  Start Timestamp  End Timestamp  Status
        0         0       0                2              2  Closed
        1         1       0                2              4  Closed

        &gt;&gt;&gt; ranges.duration.values
        array([0, 2])
        ```
        &#34;&#34;&#34;
        if broadcast_kwargs is None:
            broadcast_kwargs = {}

        if other is None:
            # One input array
            range_records = nb.between_ranges_nb(self.to_2d_array())
            wrapper = self.wrapper
            to_attach = self.obj
        else:
            # Two input arrays
            obj, other = reshape_fns.broadcast(self.obj, other, **broadcast_kwargs)
            range_records = nb.between_two_ranges_nb(
                reshape_fns.to_2d_array(obj),
                reshape_fns.to_2d_array(other),
                from_other=from_other
            )
            wrapper = ArrayWrapper.from_obj(obj)
            to_attach = other if attach_other else obj
        return Ranges(
            wrapper,
            range_records,
            ts=to_attach if attach_ts else None,
            **kwargs
        ).regroup(group_by)

    def partition_ranges(self, group_by: tp.GroupByLike = None, attach_ts: bool = True, **kwargs) -&gt; Ranges:
        &#34;&#34;&#34;Wrap the result of `vectorbt.signals.nb.partition_ranges_nb`
        with `vectorbt.generic.ranges.Ranges`.

        If `use_end_idxs` is True, uses the index of the last signal in each partition as `idx_arr`.
        Otherwise, uses the index of the first signal.

        ## Example

        ```python-repl
        &gt;&gt;&gt; mask_sr = pd.Series([True, True, True, False, True, True])
        &gt;&gt;&gt; mask_sr.vbt.signals.partition_ranges().records_readable
           Range Id  Column  Start Timestamp  End Timestamp  Status
        0         0       0                0              3  Closed
        1         1       0                4              5    Open
        ```&#34;&#34;&#34;
        range_records = nb.partition_ranges_nb(self.to_2d_array())
        return Ranges(
            self.wrapper,
            range_records,
            ts=self.obj if attach_ts else None,
            **kwargs
        ).regroup(group_by)

    def between_partition_ranges(self, group_by: tp.GroupByLike = None, attach_ts: bool = True, **kwargs) -&gt; Ranges:
        &#34;&#34;&#34;Wrap the result of `vectorbt.signals.nb.between_partition_ranges_nb`
        with `vectorbt.generic.ranges.Ranges`.

        ## Example

        ```python-repl
        &gt;&gt;&gt; mask_sr = pd.Series([True, False, False, True, False, True, True])
        &gt;&gt;&gt; mask_sr.vbt.signals.between_partition_ranges().records_readable
           Range Id  Column  Start Timestamp  End Timestamp  Status
        0         0       0                0              3  Closed
        1         1       0                3              5  Closed
         ```&#34;&#34;&#34;
        range_records = nb.between_partition_ranges_nb(self.to_2d_array())
        return Ranges(
            self.wrapper,
            range_records,
            ts=self.obj if attach_ts else None,
            **kwargs
        ).regroup(group_by)

    # ############# Ranking ############# #

    def rank(self,
             rank_func_nb: tp.RankFunc, *args,
             prepare_func: tp.Optional[tp.Callable] = None,
             reset_by: tp.Optional[tp.ArrayLike] = None,
             after_false: bool = False,
             broadcast_kwargs: tp.KwargsLike = None,
             wrap_kwargs: tp.KwargsLike = None,
             as_mapped: bool = False,
             **kwargs) -&gt; tp.Union[tp.SeriesFrame, MappedArray]:
        &#34;&#34;&#34;See `vectorbt.signals.nb.rank_nb`.

        Will broadcast with `reset_by` using `vectorbt.base.reshape_fns.broadcast` and `broadcast_kwargs`.

        Use `prepare_func` to prepare further arguments to be passed before `*args`, such as temporary arrays.
        It should take both broadcasted arrays (`reset_by` can be None) and return a tuple.

        Set `as_mapped` to True to return an instance of `vectorbt.records.mapped_array.MappedArray`.&#34;&#34;&#34;
        checks.assert_not_none(rank_func_nb)
        checks.assert_numba_func(rank_func_nb)
        if broadcast_kwargs is None:
            broadcast_kwargs = {}

        if reset_by is not None:
            obj, reset_by = reshape_fns.broadcast(self.obj, reset_by, **broadcast_kwargs)
            reset_by = reshape_fns.to_2d_array(reset_by)
        else:
            obj = self.obj
        obj_arr = reshape_fns.to_2d_array(obj)
        if prepare_func is not None:
            temp_arrs = prepare_func(obj_arr, reset_by)
        else:
            temp_arrs = ()
        rank = nb.rank_nb(
            obj_arr,
            reset_by,
            after_false,
            rank_func_nb,
            *temp_arrs,
            *args
        )
        rank_wrapped = ArrayWrapper.from_obj(obj).wrap(rank, group_by=False, **merge_dicts({}, wrap_kwargs))
        if as_mapped:
            rank_wrapped = rank_wrapped.replace(-1, np.nan)
            return rank_wrapped.vbt.to_mapped(
                dropna=True,
                dtype=np.int_,
                **kwargs
            )
        return rank_wrapped

    def pos_rank(self, allow_gaps: bool = False, **kwargs) -&gt; tp.Union[tp.SeriesFrame, MappedArray]:
        &#34;&#34;&#34;Get signal position ranks.

        Uses `SignalsAccessor.rank` with `vectorbt.signals.nb.sig_pos_rank_nb`.

        ## Example

        Rank each True value in each partition in `mask`:

        ```python-repl
        &gt;&gt;&gt; mask.vbt.signals.pos_rank()
                    a  b  c
        2020-01-01  0  0  0
        2020-01-02 -1 -1  1
        2020-01-03 -1  0  2
        2020-01-04 -1 -1 -1
        2020-01-05 -1  0 -1

        &gt;&gt;&gt; mask.vbt.signals.pos_rank(after_false=True)
                    a  b  c
        2020-01-01 -1 -1 -1
        2020-01-02 -1 -1 -1
        2020-01-03 -1  0 -1
        2020-01-04 -1 -1 -1
        2020-01-05 -1  0 -1

        &gt;&gt;&gt; mask.vbt.signals.pos_rank(allow_gaps=True)
                    a  b  c
        2020-01-01  0  0  0
        2020-01-02 -1 -1  1
        2020-01-03 -1  1  2
        2020-01-04 -1 -1 -1
        2020-01-05 -1  2 -1

        &gt;&gt;&gt; mask.vbt.signals.pos_rank(reset_by=~mask, allow_gaps=True)
                    a  b  c
        2020-01-01  0  0  0
        2020-01-02 -1 -1  1
        2020-01-03 -1  0  2
        2020-01-04 -1 -1 -1
        2020-01-05 -1  0 -1
        ```
        &#34;&#34;&#34;
        prepare_func = lambda obj, reset_by: (np.full(obj.shape[1], -1, dtype=np.int_),)
        return self.rank(
            nb.sig_pos_rank_nb,
            allow_gaps,
            prepare_func=prepare_func,
            **kwargs
        )

    def partition_pos_rank(self, **kwargs) -&gt; tp.Union[tp.SeriesFrame, MappedArray]:
        &#34;&#34;&#34;Get partition position ranks.

        Uses `SignalsAccessor.rank` with `vectorbt.signals.nb.part_pos_rank_nb`.

        ## Example

        Rank each partition of True values in `mask`:

        ```python-repl
        &gt;&gt;&gt; mask.vbt.signals.partition_pos_rank()
                    a  b  c
        2020-01-01  0  0  0
        2020-01-02 -1 -1  0
        2020-01-03 -1  1  0
        2020-01-04 -1 -1 -1
        2020-01-05 -1  2 -1

        &gt;&gt;&gt; mask.vbt.signals.partition_pos_rank(after_false=True)
                    a  b  c
        2020-01-01 -1 -1 -1
        2020-01-02 -1 -1 -1
        2020-01-03 -1  0 -1
        2020-01-04 -1 -1 -1
        2020-01-05 -1  1 -1

        &gt;&gt;&gt; mask.vbt.signals.partition_pos_rank(reset_by=mask)
                    a  b  c
        2020-01-01  0  0  0
        2020-01-02 -1 -1  0
        2020-01-03 -1  0  0
        2020-01-04 -1 -1 -1
        2020-01-05 -1  0 -1
        ```
        &#34;&#34;&#34;
        prepare_func = lambda obj, reset_by: (np.full(obj.shape[1], -1, dtype=np.int_),)
        return self.rank(
            nb.part_pos_rank_nb,
            prepare_func=prepare_func,
            **kwargs
        )

    def first(self, wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Select signals that satisfy the condition `pos_rank == 0`.&#34;&#34;&#34;
        pos_rank = self.pos_rank(**kwargs).values
        return self.wrapper.wrap(pos_rank == 0, group_by=False, **merge_dicts({}, wrap_kwargs))

    def nth(self, n: int, wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Select signals that satisfy the condition `pos_rank == n`.&#34;&#34;&#34;
        pos_rank = self.pos_rank(**kwargs).values
        return self.wrapper.wrap(pos_rank == n, group_by=False, **merge_dicts({}, wrap_kwargs))

    def from_nth(self, n: int, wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Select signals that satisfy the condition `pos_rank &gt;= n`.&#34;&#34;&#34;
        pos_rank = self.pos_rank(**kwargs).values
        return self.wrapper.wrap(pos_rank &gt;= n, group_by=False, **merge_dicts({}, wrap_kwargs))

    def pos_rank_mapped(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Get a mapped array of signal position ranks.

        See `SignalsAccessor.pos_rank`.&#34;&#34;&#34;
        return self.pos_rank(as_mapped=True, group_by=group_by, **kwargs)

    def partition_pos_rank_mapped(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Get a mapped array of partition position ranks.

        See `SignalsAccessor.partition_pos_rank`.&#34;&#34;&#34;
        return self.partition_pos_rank(as_mapped=True, group_by=group_by, **kwargs)

    # ############# Index ############# #

    def nth_index(self, n: int, return_labels: bool = True, group_by: tp.GroupByLike = None,
                  wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;See `vectorbt.signals.nb.nth_index_nb`.

        ## Example

        ```python-repl
        &gt;&gt;&gt; mask.vbt.signals.nth_index(0)
        a   2020-01-01
        b   2020-01-01
        c   2020-01-01
        Name: nth_index, dtype: datetime64[ns]

        &gt;&gt;&gt; mask.vbt.signals.nth_index(2)
        a          NaT
        b   2020-01-05
        c   2020-01-03
        Name: nth_index, dtype: datetime64[ns]

        &gt;&gt;&gt; mask.vbt.signals.nth_index(-1)
        a   2020-01-01
        b   2020-01-05
        c   2020-01-03
        Name: nth_index, dtype: datetime64[ns]

        &gt;&gt;&gt; mask.vbt.signals.nth_index(-1, group_by=True)
        Timestamp(&#39;2020-01-05 00:00:00&#39;)
        ```&#34;&#34;&#34;
        if self.is_frame() and self.wrapper.grouper.is_grouped(group_by=group_by):
            squeezed = self.squeeze_grouped(generic_nb.any_squeeze_nb, group_by=group_by)
            arr = reshape_fns.to_2d_array(squeezed)
        else:
            arr = self.to_2d_array()
        nth_index = nb.nth_index_nb(arr, n)
        if return_labels:
            minus_one_mask = nth_index == -1
            nth_index = nth_index.astype(object)
            nth_index[minus_one_mask] = np.nan
            nth_index[~minus_one_mask] = self.wrapper.index[nth_index[~minus_one_mask].astype(np.int_)]
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;nth_index&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(nth_index, group_by=group_by, **wrap_kwargs)

    def norm_avg_index(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;See `vectorbt.signals.nb.norm_avg_index_nb`.

        Normalized average index measures the average signal location relative to the middle of the column.
        This way, we can quickly see where the majority of signals are located.

        Common values are:

        * -1.0: only the first signal is set
        * 1.0: only the last signal is set
        * 0.0: symmetric distribution around the middle
        * [-1.0, 0.0): average signal is on the left
        * (0.0, 1.0]: average signal is on the right

        ## Example

        ```python-repl
        &gt;&gt;&gt; pd.Series([True, False, False, False]).vbt.signals.norm_avg_index()
        -1.0

        &gt;&gt;&gt; pd.Series([False, False, False, True]).vbt.signals.norm_avg_index()
        1.0

        &gt;&gt;&gt; pd.Series([True, False, False, True]).vbt.signals.norm_avg_index()
        0.0
        ```&#34;&#34;&#34;
        norm_avg_index = nb.norm_avg_index_nb(self.to_2d_array())
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;norm_avg_index&#39;), wrap_kwargs)
        norm_avg_index = self.wrapper.wrap_reduced(norm_avg_index, group_by=False, **wrap_kwargs)
        if self.is_frame() and self.wrapper.grouper.is_grouped(group_by=group_by):
            # Group index is a weighted average of column indexes in the group
            if group_by is None:
                group_by = self.wrapper.grouper.group_by
            col_total = self.total(group_by=False)
            norm_avg_index *= col_total
            norm_avg_index = norm_avg_index.vbt.squeeze_grouped(
                generic_nb.sum_squeeze_nb, group_by=group_by)
            group_total = col_total.vbt.squeeze_grouped(
                generic_nb.sum_squeeze_nb, group_by=group_by)
            norm_avg_index /= group_total
        return norm_avg_index

    def index_mapped(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Get a mapped array of indices.

        See `vectorbt.generic.accessors.GenericAccessor.to_mapped`.

        Only True values will be considered.&#34;&#34;&#34;
        indices = np.arange(len(self.wrapper.index), dtype=np.float_)[:, None]
        indices = np.tile(indices, (1, len(self.wrapper.columns)))
        indices = reshape_fns.soft_to_ndim(indices, self.wrapper.ndim)
        indices[~self.obj.values] = np.nan
        return self.wrapper.wrap(indices).vbt.to_mapped(
            dropna=True,
            dtype=np.int_,
            group_by=group_by,
            **kwargs
        )

    def total(self, wrap_kwargs: tp.KwargsLike = None,
              group_by: tp.GroupByLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Total number of True values in each column/group.&#34;&#34;&#34;
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total&#39;), wrap_kwargs)
        return self.sum(group_by=group_by, wrap_kwargs=wrap_kwargs)

    def rate(self, wrap_kwargs: tp.KwargsLike = None,
             group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;`SignalsAccessor.total` divided by the total index length in each column/group.&#34;&#34;&#34;
        total = reshape_fns.to_1d_array(self.total(group_by=group_by, **kwargs))
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;rate&#39;), wrap_kwargs)
        total_steps = self.wrapper.grouper.get_group_lens(group_by=group_by) * self.wrapper.shape[0]
        return self.wrapper.wrap_reduced(total / total_steps, group_by=group_by, **wrap_kwargs)

    def total_partitions(self, wrap_kwargs: tp.KwargsLike = None,
                         group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Total number of partitions of True values in each column/group.&#34;&#34;&#34;
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total_partitions&#39;), wrap_kwargs)
        return self.partition_ranges(**kwargs).count(group_by=group_by, wrap_kwargs=wrap_kwargs)

    def partition_rate(self, wrap_kwargs: tp.KwargsLike = None,
                       group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;`SignalsAccessor.total_partitions` divided by `SignalsAccessor.total` in each column/group.&#34;&#34;&#34;
        total_partitions = reshape_fns.to_1d_array(self.total_partitions(group_by=group_by, *kwargs))
        total = reshape_fns.to_1d_array(self.total(group_by=group_by, *kwargs))
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;partition_rate&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(total_partitions / total, group_by=group_by, **wrap_kwargs)

    # ############# Logical operations ############# #

    def AND(self, other: tp.ArrayLike, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Combine with `other` using logical AND.

        See `vectorbt.base.accessors.BaseAccessor.combine`.

        &#34;&#34;&#34;
        return self.combine(other, combine_func=np.logical_and, **kwargs)

    def OR(self, other: tp.ArrayLike, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Combine with `other` using logical OR.

        See `vectorbt.base.accessors.BaseAccessor.combine`.

        ## Example

        Perform two OR operations and concatenate them:

        ```python-repl
        &gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1])
        &gt;&gt;&gt; mask.vbt.signals.OR([ts &gt; 1, ts &gt; 2], concat=True, keys=[&#39;&gt;1&#39;, &#39;&gt;2&#39;])
                                    &gt;1                   &gt;2
                        a     b      c      a      b      c
        2020-01-01   True  True   True   True   True   True
        2020-01-02   True  True   True  False  False   True
        2020-01-03   True  True   True   True   True   True
        2020-01-04   True  True   True  False  False  False
        2020-01-05  False  True  False  False   True  False
        ```
        &#34;&#34;&#34;
        return self.combine(other, combine_func=np.logical_or, **kwargs)

    def XOR(self, other: tp.ArrayLike, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Combine with `other` using logical XOR.

        See `vectorbt.base.accessors.BaseAccessor.combine`.&#34;&#34;&#34;
        return self.combine(other, combine_func=np.logical_xor, **kwargs)

    # ############# Stats ############# #

    @property
    def stats_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `SignalsAccessor.stats`.

        Merges `vectorbt.generic.accessors.GenericAccessor.stats_defaults` and
        `signals.stats` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        signals_stats_cfg = settings[&#39;signals&#39;][&#39;stats&#39;]

        return merge_dicts(
            GenericAccessor.stats_defaults.__get__(self),
            signals_stats_cfg
        )

    _metrics: tp.ClassVar[Config] = Config(
        dict(
            start=dict(
                title=&#39;Start&#39;,
                calc_func=lambda self: self.wrapper.index[0],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            end=dict(
                title=&#39;End&#39;,
                calc_func=lambda self: self.wrapper.index[-1],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            period=dict(
                title=&#39;Period&#39;,
                calc_func=lambda self: len(self.wrapper.index),
                apply_to_timedelta=True,
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            total=dict(
                title=&#39;Total&#39;,
                calc_func=&#39;total&#39;,
                tags=&#39;signals&#39;
            ),
            rate=dict(
                title=&#39;Rate [%]&#39;,
                calc_func=&#39;rate&#39;,
                post_calc_func=lambda self, out, settings: out * 100,
                tags=&#39;signals&#39;
            ),
            total_overlapping=dict(
                title=&#39;Total Overlapping&#39;,
                calc_func=lambda self, other, group_by:
                (self &amp; other).vbt.signals.total(group_by=group_by),
                check_silent_has_other=True,
                tags=[&#39;signals&#39;, &#39;other&#39;]
            ),
            overlapping_rate=dict(
                title=&#39;Overlapping Rate [%]&#39;,
                calc_func=lambda self, other, group_by:
                (self &amp; other).vbt.signals.total(group_by=group_by) /
                (self | other).vbt.signals.total(group_by=group_by),
                post_calc_func=lambda self, out, settings: out * 100,
                check_silent_has_other=True,
                tags=[&#39;signals&#39;, &#39;other&#39;]
            ),
            first_index=dict(
                title=&#39;First Index&#39;,
                calc_func=&#39;nth_index&#39;,
                n=0,
                return_labels=True,
                tags=[&#39;signals&#39;, &#39;index&#39;]
            ),
            last_index=dict(
                title=&#39;Last Index&#39;,
                calc_func=&#39;nth_index&#39;,
                n=-1,
                return_labels=True,
                tags=[&#39;signals&#39;, &#39;index&#39;]
            ),
            norm_avg_index=dict(
                title=&#39;Norm Avg Index [-1, 1]&#39;,
                calc_func=&#39;norm_avg_index&#39;,
                tags=[&#39;signals&#39;, &#39;index&#39;]
            ),
            distance=dict(
                title=RepEval(&#34;f&#39;Distance {\&#34;&lt;-\&#34; if from_other else \&#34;-&gt;\&#34;} {other_name}&#39; &#34;
                              &#34;if other is not None else &#39;Distance&#39;&#34;),
                calc_func=&#39;between_ranges.duration&#39;,
                post_calc_func=lambda self, out, settings: {
                    &#39;Min&#39;: out.min(),
                    &#39;Max&#39;: out.max(),
                    &#39;Mean&#39;: out.mean(),
                    &#39;Std&#39;: out.std(ddof=settings.get(&#39;ddof&#39;, 1))
                },
                apply_to_timedelta=True,
                tags=RepEval(&#34;[&#39;signals&#39;, &#39;distance&#39;, &#39;other&#39;] if other is not None else [&#39;signals&#39;, &#39;distance&#39;]&#34;)
            ),
            total_partitions=dict(
                title=&#39;Total Partitions&#39;,
                calc_func=&#39;total_partitions&#39;,
                tags=[&#39;signals&#39;, &#39;partitions&#39;]
            ),
            partition_rate=dict(
                title=&#39;Partition Rate [%]&#39;,
                calc_func=&#39;partition_rate&#39;,
                post_calc_func=lambda self, out, settings: out * 100,
                tags=[&#39;signals&#39;, &#39;partitions&#39;]
            ),
            partition_len=dict(
                title=&#39;Partition Length&#39;,
                calc_func=&#39;partition_ranges.duration&#39;,
                post_calc_func=lambda self, out, settings: {
                    &#39;Min&#39;: out.min(),
                    &#39;Max&#39;: out.max(),
                    &#39;Mean&#39;: out.mean(),
                    &#39;Std&#39;: out.std(ddof=settings.get(&#39;ddof&#39;, 1))
                },
                apply_to_timedelta=True,
                tags=[&#39;signals&#39;, &#39;partitions&#39;, &#39;distance&#39;]
            ),
            partition_distance=dict(
                title=&#39;Partition Distance&#39;,
                calc_func=&#39;between_partition_ranges.duration&#39;,
                post_calc_func=lambda self, out, settings: {
                    &#39;Min&#39;: out.min(),
                    &#39;Max&#39;: out.max(),
                    &#39;Mean&#39;: out.mean(),
                    &#39;Std&#39;: out.std(ddof=settings.get(&#39;ddof&#39;, 1))
                },
                apply_to_timedelta=True,
                tags=[&#39;signals&#39;, &#39;partitions&#39;, &#39;distance&#39;]
            ),
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def metrics(self) -&gt; Config:
        return self._metrics

    # ############# Plotting ############# #

    def plot(self, yref: str = &#39;y&#39;, **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
        &#34;&#34;&#34;Plot signals.

        Args:
            yref (str): Y coordinate axis.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.lineplot`.

        ## Example

        ```python-repl
        &gt;&gt;&gt; mask[[&#39;a&#39;, &#39;c&#39;]].vbt.signals.plot()
        ```

        ![](/docs/img/signals_df_plot.svg)
        &#34;&#34;&#34;
        default_layout = dict()
        default_layout[&#39;yaxis&#39; + yref[1:]] = dict(
            tickmode=&#39;array&#39;,
            tickvals=[0, 1],
            ticktext=[&#39;false&#39;, &#39;true&#39;]
        )
        return self.obj.vbt.lineplot(**merge_dicts(default_layout, kwargs))

    @property
    def plots_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `SignalsAccessor.plots`.

        Merges `vectorbt.generic.accessors.GenericAccessor.plots_defaults` and
        `signals.plots` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        signals_plots_cfg = settings[&#39;signals&#39;][&#39;plots&#39;]

        return merge_dicts(
            GenericAccessor.plots_defaults.__get__(self),
            signals_plots_cfg
        )

    @property
    def subplots(self) -&gt; Config:
        return self._subplots


SignalsAccessor.override_metrics_doc(__pdoc__)
SignalsAccessor.override_subplots_doc(__pdoc__)


@register_series_vbt_accessor(&#39;signals&#39;)
class SignalsSRAccessor(SignalsAccessor, GenericSRAccessor):
    &#34;&#34;&#34;Accessor on top of signal series. For Series only.

    Accessible through `pd.Series.vbt.signals`.&#34;&#34;&#34;

    def __init__(self, obj: tp.Series, **kwargs) -&gt; None:
        GenericSRAccessor.__init__(self, obj, **kwargs)
        SignalsAccessor.__init__(self, obj, **kwargs)

    def plot_as_markers(self, y: tp.Optional[tp.ArrayLike] = None,
                        **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
        &#34;&#34;&#34;Plot Series as markers.

        Args:
            y (array_like): Y-axis values to plot markers on.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.scatterplot`.

        ## Example

        ```python-repl
        &gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1], index=mask.index)
        &gt;&gt;&gt; fig = ts.vbt.lineplot()
        &gt;&gt;&gt; mask[&#39;b&#39;].vbt.signals.plot_as_entry_markers(y=ts, fig=fig)
        &gt;&gt;&gt; (~mask[&#39;b&#39;]).vbt.signals.plot_as_exit_markers(y=ts, fig=fig)
        ```

        ![](/docs/img/signals_plot_as_markers.svg)
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        if y is None:
            y = pd.Series.vbt.empty_like(self.obj, 1)
        else:
            y = reshape_fns.to_pd_array(y)

        return y[self.obj].vbt.scatterplot(**merge_dicts(dict(
            trace_kwargs=dict(
                marker=dict(
                    symbol=&#39;circle&#39;,
                    color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;blue&#39;],
                    size=7,
                    line=dict(
                        width=1,
                        color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;blue&#39;])
                    )
                )
            )
        ), kwargs))

    def plot_as_entry_markers(self, y: tp.Optional[tp.ArrayLike] = None,
                              **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
        &#34;&#34;&#34;Plot signals as entry markers.

        See `SignalsSRAccessor.plot_as_markers`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        return self.plot_as_markers(y=y, **merge_dicts(dict(
            trace_kwargs=dict(
                marker=dict(
                    symbol=&#39;triangle-up&#39;,
                    color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;green&#39;],
                    size=8,
                    line=dict(
                        width=1,
                        color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;green&#39;])
                    )
                ),
                name=&#39;Entry&#39;
            )
        ), kwargs))

    def plot_as_exit_markers(self, y: tp.Optional[tp.ArrayLike] = None,
                             **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
        &#34;&#34;&#34;Plot signals as exit markers.

        See `SignalsSRAccessor.plot_as_markers`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        return self.plot_as_markers(y=y, **merge_dicts(dict(
            trace_kwargs=dict(
                marker=dict(
                    symbol=&#39;triangle-down&#39;,
                    color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;red&#39;],
                    size=8,
                    line=dict(
                        width=1,
                        color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;red&#39;])
                    )
                ),
                name=&#39;Exit&#39;
            )
        ), kwargs))


@register_dataframe_vbt_accessor(&#39;signals&#39;)
class SignalsDFAccessor(SignalsAccessor, GenericDFAccessor):
    &#34;&#34;&#34;Accessor on top of signal series. For DataFrames only.

    Accessible through `pd.DataFrame.vbt.signals`.&#34;&#34;&#34;

    def __init__(self, obj: tp.Frame, **kwargs) -&gt; None:
        GenericDFAccessor.__init__(self, obj, **kwargs)
        SignalsAccessor.__init__(self, obj, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.signals.accessors.SignalsAccessor"><code class="flex name class">
<span>class <span class="ident parent-name">SignalsAccessor</span></span>
(<span class="params">obj, **kwargs</span>)
</code></dt>
<dd>
<div class="desc"><p>Accessor on top of signal series. For both, Series and DataFrames.</p>
<p>Accessible through <code>pd.Series.vbt.signals</code> and <code>pd.DataFrame.vbt.signals</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignalsAccessor(GenericAccessor):
    &#34;&#34;&#34;Accessor on top of signal series. For both, Series and DataFrames.

    Accessible through `pd.Series.vbt.signals` and `pd.DataFrame.vbt.signals`.&#34;&#34;&#34;

    def __init__(self, obj: tp.SeriesFrame, **kwargs) -&gt; None:
        checks.assert_dtype(obj, np.bool_)

        GenericAccessor.__init__(self, obj, **kwargs)

    @property
    def sr_accessor_cls(self) -&gt; tp.Type[&#34;SignalsSRAccessor&#34;]:
        &#34;&#34;&#34;Accessor class for `pd.Series`.&#34;&#34;&#34;
        return SignalsSRAccessor

    @property
    def df_accessor_cls(self) -&gt; tp.Type[&#34;SignalsDFAccessor&#34;]:
        &#34;&#34;&#34;Accessor class for `pd.DataFrame`.&#34;&#34;&#34;
        return SignalsDFAccessor

    # ############# Overriding ############# #

    def bshift(self, *args, fill_value: bool = False, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;`vectorbt.generic.accessors.GenericAccessor.bshift` with `fill_value=False`.&#34;&#34;&#34;
        return GenericAccessor.bshift(self, *args, fill_value=fill_value, **kwargs)

    def fshift(self, *args, fill_value: bool = False, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;`vectorbt.generic.accessors.GenericAccessor.fshift` with `fill_value=False`.&#34;&#34;&#34;
        return GenericAccessor.fshift(self, *args, fill_value=fill_value, **kwargs)

    @classmethod
    def empty(cls, *args, fill_value: bool = False, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;`vectorbt.base.accessors.BaseAccessor.empty` with `fill_value=False`.&#34;&#34;&#34;
        return GenericAccessor.empty(*args, fill_value=fill_value, dtype=np.bool_, **kwargs)

    @classmethod
    def empty_like(cls, *args, fill_value: bool = False, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;`vectorbt.base.accessors.BaseAccessor.empty_like` with `fill_value=False`.&#34;&#34;&#34;
        return GenericAccessor.empty_like(*args, fill_value=fill_value, dtype=np.bool_, **kwargs)

    # ############# Generation ############# #

    @classmethod
    def generate(cls,
                 shape: tp.RelaxedShape,
                 choice_func_nb: tp.ChoiceFunc, *args,
                 pick_first: bool = False,
                 **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;See `vectorbt.signals.nb.generate_nb`.

        `**kwargs` will be passed to pandas constructor.

        ## Example

        Generate random signals manually:

        ```python-repl
        &gt;&gt;&gt; @njit
        ... def choice_func_nb(from_i, to_i, col):
        ...     return col + from_i

        &gt;&gt;&gt; pd.DataFrame.vbt.signals.generate((5, 3),
        ...     choice_func_nb, index=mask.index, columns=mask.columns)
                        a      b      c
        2020-01-01   True  False  False
        2020-01-02  False   True  False
        2020-01-03  False  False   True
        2020-01-04  False  False  False
        2020-01-05  False  False  False
        ```
        &#34;&#34;&#34;
        checks.assert_numba_func(choice_func_nb)

        if not isinstance(shape, tuple):
            shape = (shape, 1)
        elif isinstance(shape, tuple) and len(shape) == 1:
            shape = (shape[0], 1)

        result = nb.generate_nb(shape, pick_first, choice_func_nb, *args)

        if cls.is_series():
            if shape[1] &gt; 1:
                raise ValueError(&#34;Use DataFrame accessor&#34;)
            return pd.Series(result[:, 0], **kwargs)
        return pd.DataFrame(result, **kwargs)

    @classmethod
    def generate_both(cls,
                      shape: tp.RelaxedShape,
                      entry_choice_func_nb: tp.Optional[tp.ChoiceFunc] = None,
                      entry_args: tp.ArgsLike = None,
                      exit_choice_func_nb: tp.Optional[tp.ChoiceFunc] = None,
                      exit_args: tp.ArgsLike = None,
                      entry_wait: int = 1,
                      exit_wait: int = 1,
                      entry_pick_first: bool = True,
                      exit_pick_first: bool = True,
                      **kwargs) -&gt; tp.Tuple[tp.SeriesFrame, tp.SeriesFrame]:
        &#34;&#34;&#34;See `vectorbt.signals.nb.generate_enex_nb`.

        `**kwargs` will be passed to pandas constructor.

        ## Example

        Generate entry and exit signals one after another. Each column increment
        the number of ticks to wait before placing the exit signal.

        ```python-repl
        &gt;&gt;&gt; @njit
        ... def entry_choice_func_nb(from_i, to_i, col, temp_idx_arr):
        ...     temp_idx_arr[0] = from_i
        ...     return temp_idx_arr[:1]  # array with one signal

        &gt;&gt;&gt; @njit
        ... def exit_choice_func_nb(from_i, to_i, col, temp_idx_arr):
        ...     wait = col
        ...     temp_idx_arr[0] = from_i + wait
        ...     if temp_idx_arr[0] &lt; to_i:
        ...         return temp_idx_arr[:1]  # array with one signal
        ...     return temp_idx_arr[:0]  # empty array

        &gt;&gt;&gt; temp_idx_arr = np.empty((1,), dtype=np.int_)  # reuse memory
        &gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_both(
        ...     (5, 3),
        ...     entry_choice_func_nb, (temp_idx_arr,),
        ...     exit_choice_func_nb, (temp_idx_arr,),
        ...     index=mask.index, columns=mask.columns)
        &gt;&gt;&gt; en
                        a      b      c
        2020-01-01   True   True   True
        2020-01-02  False  False  False
        2020-01-03   True  False  False
        2020-01-04  False   True  False
        2020-01-05   True  False   True
        &gt;&gt;&gt; ex
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True  False  False
        2020-01-03  False   True  False
        2020-01-04   True  False   True
        2020-01-05  False  False  False
        ```
        &#34;&#34;&#34;
        checks.assert_not_none(entry_choice_func_nb)
        checks.assert_not_none(exit_choice_func_nb)
        checks.assert_numba_func(entry_choice_func_nb)
        checks.assert_numba_func(exit_choice_func_nb)
        if entry_args is None:
            entry_args = ()
        if exit_args is None:
            exit_args = ()

        if not isinstance(shape, tuple):
            shape = (shape, 1)
        elif isinstance(shape, tuple) and len(shape) == 1:
            shape = (shape[0], 1)

        result1, result2 = nb.generate_enex_nb(
            shape,
            entry_wait,
            exit_wait,
            entry_pick_first,
            exit_pick_first,
            entry_choice_func_nb, entry_args,
            exit_choice_func_nb, exit_args
        )
        if cls.is_series():
            if shape[1] &gt; 1:
                raise ValueError(&#34;Use DataFrame accessor&#34;)
            return pd.Series(result1[:, 0], **kwargs), pd.Series(result2[:, 0], **kwargs)
        return pd.DataFrame(result1, **kwargs), pd.DataFrame(result2, **kwargs)

    def generate_exits(self,
                       exit_choice_func_nb: tp.ChoiceFunc, *args,
                       wait: int = 1,
                       until_next: bool = True,
                       skip_until_exit: bool = False,
                       pick_first: bool = False,
                       wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;See `vectorbt.signals.nb.generate_ex_nb`.

        ## Example

        Fill all space after signals in `mask`:

        ```python-repl
        &gt;&gt;&gt; @njit
        ... def exit_choice_func_nb(from_i, to_i, col, temp_range):
        ...     return temp_range[from_i:to_i]

        &gt;&gt;&gt; temp_range = np.arange(mask.shape[0])  # reuse memory
        &gt;&gt;&gt; mask.vbt.signals.generate_exits(exit_choice_func_nb, temp_range)
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True   True  False
        2020-01-03   True  False  False
        2020-01-04   True   True   True
        2020-01-05   True  False   True
        ```
        &#34;&#34;&#34;
        checks.assert_numba_func(exit_choice_func_nb)

        exits = nb.generate_ex_nb(
            self.to_2d_array(),
            wait,
            until_next,
            skip_until_exit,
            pick_first,
            exit_choice_func_nb,
            *args
        )
        return self.wrapper.wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))

    # ############# Filtering ############# #

    @class_or_instancemethod
    def clean(cls_or_self,
              *args,
              entry_first: bool = True,
              broadcast_kwargs: tp.KwargsLike = None,
              wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeTuple[tp.SeriesFrame]:
        &#34;&#34;&#34;Clean signals.

        If one array passed, see `SignalsAccessor.first`.
        If two arrays passed, entries and exits, see `vectorbt.signals.nb.clean_enex_nb`.&#34;&#34;&#34;
        if not isinstance(cls_or_self, type):
            args = (cls_or_self.obj, *args)
        if len(args) == 1:
            obj = args[0]
            if not isinstance(obj, (pd.Series, pd.DataFrame)):
                wrapper = ArrayWrapper.from_shape(np.asarray(obj).shape)
                obj = wrapper.wrap(obj)
            return obj.vbt.signals.first(wrap_kwargs=wrap_kwargs)
        elif len(args) == 2:
            if broadcast_kwargs is None:
                broadcast_kwargs = {}
            entries, exits = reshape_fns.broadcast(*args, **broadcast_kwargs)
            entries_out, exits_out = nb.clean_enex_nb(
                reshape_fns.to_2d_array(entries),
                reshape_fns.to_2d_array(exits),
                entry_first
            )
            return (
                ArrayWrapper.from_obj(entries).wrap(entries_out, group_by=False, **merge_dicts({}, wrap_kwargs)),
                ArrayWrapper.from_obj(exits).wrap(exits_out, group_by=False, **merge_dicts({}, wrap_kwargs))
            )
        else:
            raise ValueError(&#34;Either one or two arrays must be passed&#34;)

    # ############# Random ############# #

    @classmethod
    def generate_random(cls,
                        shape: tp.RelaxedShape,
                        n: tp.Optional[tp.ArrayLike] = None,
                        prob: tp.Optional[tp.ArrayLike] = None,
                        pick_first: bool = False,
                        seed: tp.Optional[int] = None,
                        **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Generate signals randomly.

        If `n` is set, see `vectorbt.signals.nb.generate_rand_nb`.
        If `prob` is set, see `vectorbt.signals.nb.generate_rand_by_prob_nb`.

        `n` should be either a scalar or an array that will broadcast to the number of columns.
        `prob` should be either a single number or an array that will broadcast to match `shape`.
        `**kwargs` will be passed to pandas constructor.

        ## Example

        For each column, generate a variable number of signals:

        ```python-repl
        &gt;&gt;&gt; pd.DataFrame.vbt.signals.generate_random((5, 3), n=[0, 1, 2],
        ...     seed=42, index=mask.index, columns=mask.columns)
                        a      b      c
        2020-01-01  False  False   True
        2020-01-02  False  False   True
        2020-01-03  False  False  False
        2020-01-04  False   True  False
        2020-01-05  False  False  False
        ```

        For each column and time step, pick a signal with 50% probability:

        ```python-repl
        &gt;&gt;&gt; pd.DataFrame.vbt.signals.generate_random((5, 3), prob=0.5,
        ...     seed=42, index=mask.index, columns=mask.columns)
                        a      b      c
        2020-01-01   True   True   True
        2020-01-02  False   True  False
        2020-01-03  False  False  False
        2020-01-04  False  False   True
        2020-01-05   True  False   True
        ```
        &#34;&#34;&#34;
        flex_2d = True
        if not isinstance(shape, tuple):
            flex_2d = False
            shape = (shape, 1)
        elif isinstance(shape, tuple) and len(shape) == 1:
            flex_2d = False
            shape = (shape[0], 1)

        if n is not None and prob is not None:
            raise ValueError(&#34;Either n or prob should be set, not both&#34;)
        if n is not None:
            n = np.broadcast_to(n, shape[1])
            result = nb.generate_rand_nb(shape, n, seed=seed)
        elif prob is not None:
            prob = np.broadcast_to(prob, shape)
            result = nb.generate_rand_by_prob_nb(shape, prob, pick_first, flex_2d, seed=seed)
        else:
            raise ValueError(&#34;At least n or prob should be set&#34;)

        if cls.is_series():
            if shape[1] &gt; 1:
                raise ValueError(&#34;Use DataFrame accessor&#34;)
            return pd.Series(result[:, 0], **kwargs)
        return pd.DataFrame(result, **kwargs)

    # ############# Exits ############# #

    @classmethod
    def generate_random_both(cls,
                             shape: tp.RelaxedShape,
                             n: tp.Optional[tp.ArrayLike] = None,
                             entry_prob: tp.Optional[tp.ArrayLike] = None,
                             exit_prob: tp.Optional[tp.ArrayLike] = None,
                             seed: tp.Optional[int] = None,
                             entry_wait: int = 1,
                             exit_wait: int = 1,
                             entry_pick_first: bool = True,
                             exit_pick_first: bool = True,
                             **kwargs) -&gt; tp.Tuple[tp.SeriesFrame, tp.SeriesFrame]:
        &#34;&#34;&#34;Generate chain of entry and exit signals randomly.

        If `n` is set, see `vectorbt.signals.nb.generate_rand_enex_nb`.
        If `entry_prob` and `exit_prob` are set, see `vectorbt.signals.nb.generate_rand_enex_by_prob_nb`.

        For arguments, see `SignalsAccessor.generate_random`.

        ## Example

        For each column, generate two entries and exits randomly:

        ```python-repl
        &gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_random_both(
        ...     (5, 3), n=2, seed=42, index=mask.index, columns=mask.columns)
        &gt;&gt;&gt; en
                        a      b      c
        2020-01-01   True   True   True
        2020-01-02  False  False  False
        2020-01-03   True   True  False
        2020-01-04  False  False   True
        2020-01-05  False  False  False
        &gt;&gt;&gt; ex
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True   True   True
        2020-01-03  False  False  False
        2020-01-04  False   True  False
        2020-01-05   True  False   True
        ```

        For each column and time step, pick entry with 50% probability and exit right after:

        ```python-repl
        &gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_random_both(
        ...     (5, 3), entry_prob=0.5, exit_prob=1.,
        ...     seed=42, index=mask.index, columns=mask.columns)
        &gt;&gt;&gt; en
                        a      b      c
        2020-01-01   True   True   True
        2020-01-02  False  False  False
        2020-01-03  False  False  False
        2020-01-04  False  False   True
        2020-01-05   True  False  False
        &gt;&gt;&gt; ex
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True   True  False
        2020-01-03  False  False   True
        2020-01-04  False   True  False
        2020-01-05   True  False   True
        ```
        &#34;&#34;&#34;
        flex_2d = True
        if not isinstance(shape, tuple):
            flex_2d = False
            shape = (shape, 1)
        elif isinstance(shape, tuple) and len(shape) == 1:
            flex_2d = False
            shape = (shape[0], 1)

        if n is not None and (entry_prob is not None or exit_prob is not None):
            raise ValueError(&#34;Either n or any of the entry_prob and exit_prob should be set, not both&#34;)
        if n is not None:
            n = np.broadcast_to(n, shape[1])
            entries, exits = nb.generate_rand_enex_nb(shape, n, entry_wait, exit_wait, seed=seed)
        elif entry_prob is not None and exit_prob is not None:
            entry_prob = np.broadcast_to(entry_prob, shape)
            exit_prob = np.broadcast_to(exit_prob, shape)
            entries, exits = nb.generate_rand_enex_by_prob_nb(
                shape,
                entry_prob,
                exit_prob,
                entry_wait,
                exit_wait,
                entry_pick_first,
                exit_pick_first,
                flex_2d,
                seed=seed
            )
        else:
            raise ValueError(&#34;At least n, or entry_prob and exit_prob should be set&#34;)

        if cls.is_series():
            if shape[1] &gt; 1:
                raise ValueError(&#34;Use DataFrame accessor&#34;)
            return pd.Series(entries[:, 0], **kwargs), pd.Series(exits[:, 0], **kwargs)
        return pd.DataFrame(entries, **kwargs), pd.DataFrame(exits, **kwargs)

    def generate_random_exits(self,
                              prob: tp.Optional[tp.ArrayLike] = None,
                              seed: tp.Optional[int] = None,
                              wait: int = 1,
                              until_next: bool = True,
                              skip_until_exit: bool = False,
                              wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Generate exit signals randomly.

        If `prob` is None, see `vectorbt.signals.nb.generate_rand_ex_nb`.
        Otherwise, see `vectorbt.signals.nb.generate_rand_ex_by_prob_nb`.

        ## Example

        After each entry in `mask`, generate exactly one exit:

        ```python-repl
        &gt;&gt;&gt; mask.vbt.signals.generate_random_exits(seed=42)
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02  False   True  False
        2020-01-03   True  False  False
        2020-01-04  False   True  False
        2020-01-05  False  False   True
        ```

        After each entry in `mask` and at each time step, generate exit with 50% probability:

        ```python-repl
        &gt;&gt;&gt; mask.vbt.signals.generate_random_exits(prob=0.5, seed=42)
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True  False  False
        2020-01-03  False  False  False
        2020-01-04  False  False  False
        2020-01-05  False  False   True
        ```
        &#34;&#34;&#34;
        if prob is not None:
            obj, prob = reshape_fns.broadcast(self.obj, prob, keep_raw=[False, True])
            exits = nb.generate_rand_ex_by_prob_nb(
                reshape_fns.to_2d_array(obj),
                prob,
                wait,
                until_next,
                skip_until_exit,
                obj.ndim == 2,
                seed=seed
            )
            return ArrayWrapper.from_obj(obj).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))
        exits = nb.generate_rand_ex_nb(
            self.to_2d_array(),
            wait,
            until_next,
            skip_until_exit,
            seed=seed
        )
        return self.wrapper.wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))

    def generate_stop_exits(self,
                            ts: tp.ArrayLike,
                            stop: tp.ArrayLike,
                            trailing: tp.ArrayLike = False,
                            entry_wait: int = 1,
                            exit_wait: int = 1,
                            until_next: bool = True,
                            skip_until_exit: bool = False,
                            pick_first: bool = True,
                            chain: bool = False,
                            broadcast_kwargs: tp.KwargsLike = None,
                            wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeTuple[tp.SeriesFrame]:
        &#34;&#34;&#34;Generate exits based on when `ts` hits the stop.

        For arguments, see `vectorbt.signals.nb.stop_choice_nb`.
        If `chain` is True, see `vectorbt.signals.nb.generate_stop_enex_nb`.
        Otherwise, see `vectorbt.signals.nb.generate_stop_ex_nb`.

        Arguments `entries`, `ts` and `stop` will broadcast using `vectorbt.base.reshape_fns.broadcast`
        and `broadcast_kwargs`.

        For arguments, see `vectorbt.signals.nb.stop_choice_nb`.

        !!! hint
            Default arguments will generate an exit signal strictly between two entry signals.
            If both entry signals are too close to each other, no exit will be generated.

            To ignore all entries that come between an entry and its exit,
            set `until_next` to False and `skip_until_exit` to True.

            To remove all entries that come between an entry and its exit,
            set `chain` to True. This will return two arrays: new entries and exits.

        ## Example

        ```python-repl
        &gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1])

        &gt;&gt;&gt; # stop loss
        &gt;&gt;&gt; mask.vbt.signals.generate_stop_exits(ts, -0.1)
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02  False  False  False
        2020-01-03  False  False  False
        2020-01-04  False   True   True
        2020-01-05  False  False  False

        &gt;&gt;&gt; # trailing stop loss
        &gt;&gt;&gt; mask.vbt.signals.generate_stop_exits(ts, -0.1, trailing=True)
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02  False  False  False
        2020-01-03  False  False  False
        2020-01-04   True   True   True
        2020-01-05  False  False  False
        ```
        &#34;&#34;&#34;
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        entries = self.obj

        keep_raw = (False, True, True, True)
        broadcast_kwargs = merge_dicts(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
        entries, ts, stop, trailing = reshape_fns.broadcast(
            entries, ts, stop, trailing, **broadcast_kwargs, keep_raw=keep_raw)

        # Perform generation
        if chain:
            new_entries, exits = nb.generate_stop_enex_nb(
                reshape_fns.to_2d_array(entries),
                ts,
                stop,
                trailing,
                entry_wait,
                exit_wait,
                pick_first,
                entries.ndim == 2
            )
            return ArrayWrapper.from_obj(entries).wrap(new_entries, group_by=False, **merge_dicts({}, wrap_kwargs)), \
                   ArrayWrapper.from_obj(entries).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))
        else:
            if skip_until_exit and until_next:
                warnings.warn(&#34;skip_until_exit=True has only effect when until_next=False&#34;, stacklevel=2)
            exits = nb.generate_stop_ex_nb(
                reshape_fns.to_2d_array(entries),
                ts,
                stop,
                trailing,
                exit_wait,
                until_next,
                skip_until_exit,
                pick_first,
                entries.ndim == 2
            )
            return ArrayWrapper.from_obj(entries).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))

    def generate_ohlc_stop_exits(self,
                                 open: tp.ArrayLike,
                                 high: tp.Optional[tp.ArrayLike] = None,
                                 low: tp.Optional[tp.ArrayLike] = None,
                                 close: tp.Optional[tp.ArrayLike] = None,
                                 is_open_safe: bool = True,
                                 out_dict: tp.Optional[tp.Dict[str, tp.ArrayLike]] = None,
                                 sl_stop: tp.ArrayLike = np.nan,
                                 sl_trail: tp.ArrayLike = False,
                                 tp_stop: tp.ArrayLike = np.nan,
                                 reverse: tp.ArrayLike = False,
                                 entry_wait: int = 1,
                                 exit_wait: int = 1,
                                 until_next: bool = True,
                                 skip_until_exit: bool = False,
                                 pick_first: bool = True,
                                 chain: bool = False,
                                 broadcast_kwargs: tp.KwargsLike = None,
                                 wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeTuple[tp.SeriesFrame]:
        &#34;&#34;&#34;Generate exits based on when the price hits (trailing) stop loss or take profit.

        !!! hint
            This function is meant for signal analysis. For backtesting, consider using
            the stop logic integrated into `vectorbt.portfolio.base.Portfolio.from_signals`.

        If any of `high`, `low` or `close` is None, it will be set to `open`.

        Use `out_dict` as a dict to pass `stop_price` and `stop_type` arrays. You can also
        set `out_dict` to {} to produce these arrays automatically and still have access to them.

        For arguments, see `vectorbt.signals.nb.ohlc_stop_choice_nb`.
        If `chain` is True, see `vectorbt.signals.nb.generate_ohlc_stop_enex_nb`.
        Otherwise, see `vectorbt.signals.nb.generate_ohlc_stop_ex_nb`.

        All array-like arguments including stops and `out_dict` will broadcast using
        `vectorbt.base.reshape_fns.broadcast` and `broadcast_kwargs`.

        For arguments, see `vectorbt.signals.nb.ohlc_stop_choice_nb`.

        !!! note
            `open` isn&#39;t necessarily open price, but can be any entry price (even previous close).
            Stop price is calculated based solely on the entry price.

        !!! hint
            Default arguments will generate an exit signal strictly between two entry signals.
            If both entry signals are too close to each other, no exit will be generated.

            To ignore all entries that come between an entry and its exit,
            set `until_next` to False and `skip_until_exit` to True.

            To remove all entries that come between an entry and its exit,
            set `chain` to True. This will return two arrays: new entries and exits.

        ## Example

        The same example as under `vectorbt.signals.nb.generate_ohlc_stop_ex_nb`:

        ```python-repl
        &gt;&gt;&gt; from vectorbt.signals.enums import StopType

        &gt;&gt;&gt; price = pd.DataFrame({
        ...     &#39;open&#39;: [10, 11, 12, 11, 10],
        ...     &#39;high&#39;: [11, 12, 13, 12, 11],
        ...     &#39;low&#39;: [9, 10, 11, 10, 9],
        ...     &#39;close&#39;: [10, 11, 12, 11, 10]
        ... })
        &gt;&gt;&gt; out_dict = {}
        &gt;&gt;&gt; exits = mask.vbt.signals.generate_ohlc_stop_exits(
        ...     price[&#39;open&#39;], price[&#39;high&#39;], price[&#39;low&#39;], price[&#39;close&#39;],
        ...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict)
        &gt;&gt;&gt; exits
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True   True  False
        2020-01-03  False  False  False
        2020-01-04  False   True   True
        2020-01-05  False  False  False

        &gt;&gt;&gt; out_dict[&#39;stop_price&#39;]
                       a     b     c
        2020-01-01   NaN   NaN   NaN
        2020-01-02  11.0  11.0   NaN
        2020-01-03   NaN   NaN   NaN
        2020-01-04   NaN  10.8  10.8
        2020-01-05   NaN   NaN   NaN

        &gt;&gt;&gt; out_dict[&#39;stop_type&#39;].vbt(mapping=StopType).apply_mapping()
                             a           b          c
        2020-01-01        None        None       None
        2020-01-02  TakeProfit  TakeProfit       None
        2020-01-03        None        None       None
        2020-01-04        None   TrailStop  TrailStop
        2020-01-05        None        None       None
        ```

        Notice how the first two entry signals in the third column have no exit signal - there is
        no room between them for an exit signal. To find an exit for the first entry and ignore all
        entries that are in-between them, we can pass `until_next=False` and `skip_until_exit=True`:

        ```python-repl
        &gt;&gt;&gt; out_dict = {}
        &gt;&gt;&gt; exits = mask.vbt.signals.generate_ohlc_stop_exits(
        ...     price[&#39;open&#39;], price[&#39;high&#39;], price[&#39;low&#39;], price[&#39;close&#39;],
        ...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict,
        ...     until_next=False, skip_until_exit=True)
        &gt;&gt;&gt; exits
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True   True   True
        2020-01-03  False  False  False
        2020-01-04  False   True   True
        2020-01-05  False  False  False

        &gt;&gt;&gt; out_dict[&#39;stop_price&#39;]
        2020-01-01   NaN   NaN   NaN
        2020-01-02  11.0  11.0  11.0
        2020-01-03   NaN   NaN   NaN
        2020-01-04   NaN  10.8  10.8
        2020-01-05   NaN   NaN   NaN

        &gt;&gt;&gt; out_dict[&#39;stop_type&#39;].vbt(mapping=StopType).apply_mapping()
                             a           b           c
        2020-01-01        None        None        None
        2020-01-02  TakeProfit  TakeProfit  TakeProfit
        2020-01-03        None        None        None
        2020-01-04        None   TrailStop   TrailStop
        2020-01-05        None        None        None
        ```

        Now, the first signal in the third column gets executed regardless of the entries that come next,
        which is very similar to the logic that is implemented in `vectorbt.portfolio.base.Portfolio.from_signals`.

        To automatically remove all ignored entry signals, pass `chain=True`.
        This will return a new entries array:

        ```python-repl
        &gt;&gt;&gt; out_dict = {}
        &gt;&gt;&gt; new_entries, exits = mask.vbt.signals.generate_ohlc_stop_exits(
        ...     price[&#39;open&#39;], price[&#39;high&#39;], price[&#39;low&#39;], price[&#39;close&#39;],
        ...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict,
        ...     chain=True)
        &gt;&gt;&gt; new_entries
                        a      b      c
        2020-01-01   True   True   True
        2020-01-02  False  False  False  &lt;&lt; removed entry in the third column
        2020-01-03  False   True   True
        2020-01-04  False  False  False
        2020-01-05  False   True  False
        &gt;&gt;&gt; exits
                        a      b      c
        2020-01-01  False  False  False
        2020-01-02   True   True   True
        2020-01-03  False  False  False
        2020-01-04  False   True   True
        2020-01-05  False  False  False
        ```

        !!! warning
            The last two examples above make entries dependent upon exits - this makes only sense
            if you have no other exit arrays to combine this stop exit array with.
        &#34;&#34;&#34;
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        entries = self.obj
        if high is None:
            high = open
        if low is None:
            low = open
        if close is None:
            close = open
        if out_dict is None:
            out_dict_passed = False
            out_dict = {}
        else:
            out_dict_passed = True
        stop_price_out = out_dict.get(&#39;stop_price&#39;, np.nan if out_dict_passed else None)
        stop_type_out = out_dict.get(&#39;stop_type&#39;, -1 if out_dict_passed else None)
        out_args = ()
        if stop_price_out is not None:
            out_args += (stop_price_out,)
        if stop_type_out is not None:
            out_args += (stop_type_out,)

        keep_raw = (False, True, True, True, True, True, True, True, True) + (False,) * len(out_args)
        broadcast_kwargs = merge_dicts(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
        entries, open, high, low, close, sl_stop, sl_trail, tp_stop, reverse, *out_args = reshape_fns.broadcast(
            entries, open, high, low, close, sl_stop, sl_trail, tp_stop, reverse, *out_args,
            **broadcast_kwargs, keep_raw=keep_raw)
        if stop_price_out is None:
            stop_price_out = np.empty_like(entries, dtype=np.float_)
        else:
            stop_price_out = out_args[0]
            out_args = out_args[1:]
        if stop_type_out is None:
            stop_type_out = np.empty_like(entries, dtype=np.int_)
        else:
            stop_type_out = out_args[0]
        stop_price_out = reshape_fns.to_2d_array(stop_price_out)
        stop_type_out = reshape_fns.to_2d_array(stop_type_out)

        # Perform generation
        if chain:
            new_entries, exits = nb.generate_ohlc_stop_enex_nb(
                reshape_fns.to_2d_array(entries),
                open,
                high,
                low,
                close,
                stop_price_out,
                stop_type_out,
                sl_stop,
                sl_trail,
                tp_stop,
                reverse,
                is_open_safe,
                entry_wait,
                exit_wait,
                pick_first,
                entries.ndim == 2
            )
            out_dict[&#39;stop_price&#39;] = ArrayWrapper.from_obj(entries).wrap(
                stop_price_out, group_by=False, **merge_dicts({}, wrap_kwargs))
            out_dict[&#39;stop_type&#39;] = ArrayWrapper.from_obj(entries).wrap(
                stop_type_out, group_by=False, **merge_dicts({}, wrap_kwargs))
            return ArrayWrapper.from_obj(entries).wrap(new_entries, group_by=False, **merge_dicts({}, wrap_kwargs)), \
                   ArrayWrapper.from_obj(entries).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))
        else:
            if skip_until_exit and until_next:
                warnings.warn(&#34;skip_until_exit=True has only effect when until_next=False&#34;, stacklevel=2)
            exits = nb.generate_ohlc_stop_ex_nb(
                reshape_fns.to_2d_array(entries),
                open,
                high,
                low,
                close,
                stop_price_out,
                stop_type_out,
                sl_stop,
                sl_trail,
                tp_stop,
                reverse,
                is_open_safe,
                exit_wait,
                until_next,
                skip_until_exit,
                pick_first,
                entries.ndim == 2
            )
            out_dict[&#39;stop_price&#39;] = ArrayWrapper.from_obj(entries).wrap(
                stop_price_out, group_by=False, **merge_dicts({}, wrap_kwargs))
            out_dict[&#39;stop_type&#39;] = ArrayWrapper.from_obj(entries).wrap(
                stop_type_out, group_by=False, **merge_dicts({}, wrap_kwargs))
            return ArrayWrapper.from_obj(entries).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))

    # ############# Ranges ############# #

    def between_ranges(self,
                       other: tp.Optional[tp.ArrayLike] = None,
                       from_other: bool = False,
                       broadcast_kwargs: tp.KwargsLike = None,
                       group_by: tp.GroupByLike = None,
                       attach_ts: bool = True,
                       attach_other: bool = False,
                       **kwargs) -&gt; Ranges:
        &#34;&#34;&#34;Wrap the result of `vectorbt.signals.nb.between_ranges_nb`
        with `vectorbt.generic.ranges.Ranges`.

        If `other` specified, see `vectorbt.signals.nb.between_two_ranges_nb`.
        Both will broadcast using `vectorbt.base.reshape_fns.broadcast` and `broadcast_kwargs`.

        ## Example

        One array:

        ```python-repl
        &gt;&gt;&gt; mask_sr = pd.Series([True, False, False, True, False, True, True])
        &gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges()
        &gt;&gt;&gt; ranges
        &lt;vectorbt.generic.ranges.Ranges at 0x7ff29ea7c7b8&gt;

        &gt;&gt;&gt; ranges.records_readable
           Range Id  Column  Start Timestamp  End Timestamp  Status
        0         0       0                0              3  Closed
        1         1       0                3              5  Closed
        2         2       0                5              6  Closed

        &gt;&gt;&gt; ranges.duration.values
        array([3, 2, 1])
        ```

        Two arrays, traversing the signals of the first array:

        ```python-repl
        &gt;&gt;&gt; mask_sr = pd.Series([True, True, True, False, False])
        &gt;&gt;&gt; mask_sr2 = pd.Series([False, False, True, False, True])
        &gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges(other=mask_sr2)
        &gt;&gt;&gt; ranges
        &lt;vectorbt.generic.ranges.Ranges at 0x7ff29e3b80f0&gt;

        &gt;&gt;&gt; ranges.records_readable
           Range Id  Column  Start Timestamp  End Timestamp  Status
        0         0       0                0              2  Closed
        1         1       0                1              2  Closed
        2         2       0                2              2  Closed

        &gt;&gt;&gt; ranges.duration.values
        array([2, 1, 0])
        ```

        Two arrays, traversing the signals of the second array:

        ```python-repl
        &gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges(other=mask_sr2, from_other=True)
        &gt;&gt;&gt; ranges
        &lt;vectorbt.generic.ranges.Ranges at 0x7ff29eccbd68&gt;

        &gt;&gt;&gt; ranges.records_readable
           Range Id  Column  Start Timestamp  End Timestamp  Status
        0         0       0                2              2  Closed
        1         1       0                2              4  Closed

        &gt;&gt;&gt; ranges.duration.values
        array([0, 2])
        ```
        &#34;&#34;&#34;
        if broadcast_kwargs is None:
            broadcast_kwargs = {}

        if other is None:
            # One input array
            range_records = nb.between_ranges_nb(self.to_2d_array())
            wrapper = self.wrapper
            to_attach = self.obj
        else:
            # Two input arrays
            obj, other = reshape_fns.broadcast(self.obj, other, **broadcast_kwargs)
            range_records = nb.between_two_ranges_nb(
                reshape_fns.to_2d_array(obj),
                reshape_fns.to_2d_array(other),
                from_other=from_other
            )
            wrapper = ArrayWrapper.from_obj(obj)
            to_attach = other if attach_other else obj
        return Ranges(
            wrapper,
            range_records,
            ts=to_attach if attach_ts else None,
            **kwargs
        ).regroup(group_by)

    def partition_ranges(self, group_by: tp.GroupByLike = None, attach_ts: bool = True, **kwargs) -&gt; Ranges:
        &#34;&#34;&#34;Wrap the result of `vectorbt.signals.nb.partition_ranges_nb`
        with `vectorbt.generic.ranges.Ranges`.

        If `use_end_idxs` is True, uses the index of the last signal in each partition as `idx_arr`.
        Otherwise, uses the index of the first signal.

        ## Example

        ```python-repl
        &gt;&gt;&gt; mask_sr = pd.Series([True, True, True, False, True, True])
        &gt;&gt;&gt; mask_sr.vbt.signals.partition_ranges().records_readable
           Range Id  Column  Start Timestamp  End Timestamp  Status
        0         0       0                0              3  Closed
        1         1       0                4              5    Open
        ```&#34;&#34;&#34;
        range_records = nb.partition_ranges_nb(self.to_2d_array())
        return Ranges(
            self.wrapper,
            range_records,
            ts=self.obj if attach_ts else None,
            **kwargs
        ).regroup(group_by)

    def between_partition_ranges(self, group_by: tp.GroupByLike = None, attach_ts: bool = True, **kwargs) -&gt; Ranges:
        &#34;&#34;&#34;Wrap the result of `vectorbt.signals.nb.between_partition_ranges_nb`
        with `vectorbt.generic.ranges.Ranges`.

        ## Example

        ```python-repl
        &gt;&gt;&gt; mask_sr = pd.Series([True, False, False, True, False, True, True])
        &gt;&gt;&gt; mask_sr.vbt.signals.between_partition_ranges().records_readable
           Range Id  Column  Start Timestamp  End Timestamp  Status
        0         0       0                0              3  Closed
        1         1       0                3              5  Closed
         ```&#34;&#34;&#34;
        range_records = nb.between_partition_ranges_nb(self.to_2d_array())
        return Ranges(
            self.wrapper,
            range_records,
            ts=self.obj if attach_ts else None,
            **kwargs
        ).regroup(group_by)

    # ############# Ranking ############# #

    def rank(self,
             rank_func_nb: tp.RankFunc, *args,
             prepare_func: tp.Optional[tp.Callable] = None,
             reset_by: tp.Optional[tp.ArrayLike] = None,
             after_false: bool = False,
             broadcast_kwargs: tp.KwargsLike = None,
             wrap_kwargs: tp.KwargsLike = None,
             as_mapped: bool = False,
             **kwargs) -&gt; tp.Union[tp.SeriesFrame, MappedArray]:
        &#34;&#34;&#34;See `vectorbt.signals.nb.rank_nb`.

        Will broadcast with `reset_by` using `vectorbt.base.reshape_fns.broadcast` and `broadcast_kwargs`.

        Use `prepare_func` to prepare further arguments to be passed before `*args`, such as temporary arrays.
        It should take both broadcasted arrays (`reset_by` can be None) and return a tuple.

        Set `as_mapped` to True to return an instance of `vectorbt.records.mapped_array.MappedArray`.&#34;&#34;&#34;
        checks.assert_not_none(rank_func_nb)
        checks.assert_numba_func(rank_func_nb)
        if broadcast_kwargs is None:
            broadcast_kwargs = {}

        if reset_by is not None:
            obj, reset_by = reshape_fns.broadcast(self.obj, reset_by, **broadcast_kwargs)
            reset_by = reshape_fns.to_2d_array(reset_by)
        else:
            obj = self.obj
        obj_arr = reshape_fns.to_2d_array(obj)
        if prepare_func is not None:
            temp_arrs = prepare_func(obj_arr, reset_by)
        else:
            temp_arrs = ()
        rank = nb.rank_nb(
            obj_arr,
            reset_by,
            after_false,
            rank_func_nb,
            *temp_arrs,
            *args
        )
        rank_wrapped = ArrayWrapper.from_obj(obj).wrap(rank, group_by=False, **merge_dicts({}, wrap_kwargs))
        if as_mapped:
            rank_wrapped = rank_wrapped.replace(-1, np.nan)
            return rank_wrapped.vbt.to_mapped(
                dropna=True,
                dtype=np.int_,
                **kwargs
            )
        return rank_wrapped

    def pos_rank(self, allow_gaps: bool = False, **kwargs) -&gt; tp.Union[tp.SeriesFrame, MappedArray]:
        &#34;&#34;&#34;Get signal position ranks.

        Uses `SignalsAccessor.rank` with `vectorbt.signals.nb.sig_pos_rank_nb`.

        ## Example

        Rank each True value in each partition in `mask`:

        ```python-repl
        &gt;&gt;&gt; mask.vbt.signals.pos_rank()
                    a  b  c
        2020-01-01  0  0  0
        2020-01-02 -1 -1  1
        2020-01-03 -1  0  2
        2020-01-04 -1 -1 -1
        2020-01-05 -1  0 -1

        &gt;&gt;&gt; mask.vbt.signals.pos_rank(after_false=True)
                    a  b  c
        2020-01-01 -1 -1 -1
        2020-01-02 -1 -1 -1
        2020-01-03 -1  0 -1
        2020-01-04 -1 -1 -1
        2020-01-05 -1  0 -1

        &gt;&gt;&gt; mask.vbt.signals.pos_rank(allow_gaps=True)
                    a  b  c
        2020-01-01  0  0  0
        2020-01-02 -1 -1  1
        2020-01-03 -1  1  2
        2020-01-04 -1 -1 -1
        2020-01-05 -1  2 -1

        &gt;&gt;&gt; mask.vbt.signals.pos_rank(reset_by=~mask, allow_gaps=True)
                    a  b  c
        2020-01-01  0  0  0
        2020-01-02 -1 -1  1
        2020-01-03 -1  0  2
        2020-01-04 -1 -1 -1
        2020-01-05 -1  0 -1
        ```
        &#34;&#34;&#34;
        prepare_func = lambda obj, reset_by: (np.full(obj.shape[1], -1, dtype=np.int_),)
        return self.rank(
            nb.sig_pos_rank_nb,
            allow_gaps,
            prepare_func=prepare_func,
            **kwargs
        )

    def partition_pos_rank(self, **kwargs) -&gt; tp.Union[tp.SeriesFrame, MappedArray]:
        &#34;&#34;&#34;Get partition position ranks.

        Uses `SignalsAccessor.rank` with `vectorbt.signals.nb.part_pos_rank_nb`.

        ## Example

        Rank each partition of True values in `mask`:

        ```python-repl
        &gt;&gt;&gt; mask.vbt.signals.partition_pos_rank()
                    a  b  c
        2020-01-01  0  0  0
        2020-01-02 -1 -1  0
        2020-01-03 -1  1  0
        2020-01-04 -1 -1 -1
        2020-01-05 -1  2 -1

        &gt;&gt;&gt; mask.vbt.signals.partition_pos_rank(after_false=True)
                    a  b  c
        2020-01-01 -1 -1 -1
        2020-01-02 -1 -1 -1
        2020-01-03 -1  0 -1
        2020-01-04 -1 -1 -1
        2020-01-05 -1  1 -1

        &gt;&gt;&gt; mask.vbt.signals.partition_pos_rank(reset_by=mask)
                    a  b  c
        2020-01-01  0  0  0
        2020-01-02 -1 -1  0
        2020-01-03 -1  0  0
        2020-01-04 -1 -1 -1
        2020-01-05 -1  0 -1
        ```
        &#34;&#34;&#34;
        prepare_func = lambda obj, reset_by: (np.full(obj.shape[1], -1, dtype=np.int_),)
        return self.rank(
            nb.part_pos_rank_nb,
            prepare_func=prepare_func,
            **kwargs
        )

    def first(self, wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Select signals that satisfy the condition `pos_rank == 0`.&#34;&#34;&#34;
        pos_rank = self.pos_rank(**kwargs).values
        return self.wrapper.wrap(pos_rank == 0, group_by=False, **merge_dicts({}, wrap_kwargs))

    def nth(self, n: int, wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Select signals that satisfy the condition `pos_rank == n`.&#34;&#34;&#34;
        pos_rank = self.pos_rank(**kwargs).values
        return self.wrapper.wrap(pos_rank == n, group_by=False, **merge_dicts({}, wrap_kwargs))

    def from_nth(self, n: int, wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Select signals that satisfy the condition `pos_rank &gt;= n`.&#34;&#34;&#34;
        pos_rank = self.pos_rank(**kwargs).values
        return self.wrapper.wrap(pos_rank &gt;= n, group_by=False, **merge_dicts({}, wrap_kwargs))

    def pos_rank_mapped(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Get a mapped array of signal position ranks.

        See `SignalsAccessor.pos_rank`.&#34;&#34;&#34;
        return self.pos_rank(as_mapped=True, group_by=group_by, **kwargs)

    def partition_pos_rank_mapped(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Get a mapped array of partition position ranks.

        See `SignalsAccessor.partition_pos_rank`.&#34;&#34;&#34;
        return self.partition_pos_rank(as_mapped=True, group_by=group_by, **kwargs)

    # ############# Index ############# #

    def nth_index(self, n: int, return_labels: bool = True, group_by: tp.GroupByLike = None,
                  wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;See `vectorbt.signals.nb.nth_index_nb`.

        ## Example

        ```python-repl
        &gt;&gt;&gt; mask.vbt.signals.nth_index(0)
        a   2020-01-01
        b   2020-01-01
        c   2020-01-01
        Name: nth_index, dtype: datetime64[ns]

        &gt;&gt;&gt; mask.vbt.signals.nth_index(2)
        a          NaT
        b   2020-01-05
        c   2020-01-03
        Name: nth_index, dtype: datetime64[ns]

        &gt;&gt;&gt; mask.vbt.signals.nth_index(-1)
        a   2020-01-01
        b   2020-01-05
        c   2020-01-03
        Name: nth_index, dtype: datetime64[ns]

        &gt;&gt;&gt; mask.vbt.signals.nth_index(-1, group_by=True)
        Timestamp(&#39;2020-01-05 00:00:00&#39;)
        ```&#34;&#34;&#34;
        if self.is_frame() and self.wrapper.grouper.is_grouped(group_by=group_by):
            squeezed = self.squeeze_grouped(generic_nb.any_squeeze_nb, group_by=group_by)
            arr = reshape_fns.to_2d_array(squeezed)
        else:
            arr = self.to_2d_array()
        nth_index = nb.nth_index_nb(arr, n)
        if return_labels:
            minus_one_mask = nth_index == -1
            nth_index = nth_index.astype(object)
            nth_index[minus_one_mask] = np.nan
            nth_index[~minus_one_mask] = self.wrapper.index[nth_index[~minus_one_mask].astype(np.int_)]
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;nth_index&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(nth_index, group_by=group_by, **wrap_kwargs)

    def norm_avg_index(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;See `vectorbt.signals.nb.norm_avg_index_nb`.

        Normalized average index measures the average signal location relative to the middle of the column.
        This way, we can quickly see where the majority of signals are located.

        Common values are:

        * -1.0: only the first signal is set
        * 1.0: only the last signal is set
        * 0.0: symmetric distribution around the middle
        * [-1.0, 0.0): average signal is on the left
        * (0.0, 1.0]: average signal is on the right

        ## Example

        ```python-repl
        &gt;&gt;&gt; pd.Series([True, False, False, False]).vbt.signals.norm_avg_index()
        -1.0

        &gt;&gt;&gt; pd.Series([False, False, False, True]).vbt.signals.norm_avg_index()
        1.0

        &gt;&gt;&gt; pd.Series([True, False, False, True]).vbt.signals.norm_avg_index()
        0.0
        ```&#34;&#34;&#34;
        norm_avg_index = nb.norm_avg_index_nb(self.to_2d_array())
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;norm_avg_index&#39;), wrap_kwargs)
        norm_avg_index = self.wrapper.wrap_reduced(norm_avg_index, group_by=False, **wrap_kwargs)
        if self.is_frame() and self.wrapper.grouper.is_grouped(group_by=group_by):
            # Group index is a weighted average of column indexes in the group
            if group_by is None:
                group_by = self.wrapper.grouper.group_by
            col_total = self.total(group_by=False)
            norm_avg_index *= col_total
            norm_avg_index = norm_avg_index.vbt.squeeze_grouped(
                generic_nb.sum_squeeze_nb, group_by=group_by)
            group_total = col_total.vbt.squeeze_grouped(
                generic_nb.sum_squeeze_nb, group_by=group_by)
            norm_avg_index /= group_total
        return norm_avg_index

    def index_mapped(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Get a mapped array of indices.

        See `vectorbt.generic.accessors.GenericAccessor.to_mapped`.

        Only True values will be considered.&#34;&#34;&#34;
        indices = np.arange(len(self.wrapper.index), dtype=np.float_)[:, None]
        indices = np.tile(indices, (1, len(self.wrapper.columns)))
        indices = reshape_fns.soft_to_ndim(indices, self.wrapper.ndim)
        indices[~self.obj.values] = np.nan
        return self.wrapper.wrap(indices).vbt.to_mapped(
            dropna=True,
            dtype=np.int_,
            group_by=group_by,
            **kwargs
        )

    def total(self, wrap_kwargs: tp.KwargsLike = None,
              group_by: tp.GroupByLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Total number of True values in each column/group.&#34;&#34;&#34;
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total&#39;), wrap_kwargs)
        return self.sum(group_by=group_by, wrap_kwargs=wrap_kwargs)

    def rate(self, wrap_kwargs: tp.KwargsLike = None,
             group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;`SignalsAccessor.total` divided by the total index length in each column/group.&#34;&#34;&#34;
        total = reshape_fns.to_1d_array(self.total(group_by=group_by, **kwargs))
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;rate&#39;), wrap_kwargs)
        total_steps = self.wrapper.grouper.get_group_lens(group_by=group_by) * self.wrapper.shape[0]
        return self.wrapper.wrap_reduced(total / total_steps, group_by=group_by, **wrap_kwargs)

    def total_partitions(self, wrap_kwargs: tp.KwargsLike = None,
                         group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Total number of partitions of True values in each column/group.&#34;&#34;&#34;
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total_partitions&#39;), wrap_kwargs)
        return self.partition_ranges(**kwargs).count(group_by=group_by, wrap_kwargs=wrap_kwargs)

    def partition_rate(self, wrap_kwargs: tp.KwargsLike = None,
                       group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;`SignalsAccessor.total_partitions` divided by `SignalsAccessor.total` in each column/group.&#34;&#34;&#34;
        total_partitions = reshape_fns.to_1d_array(self.total_partitions(group_by=group_by, *kwargs))
        total = reshape_fns.to_1d_array(self.total(group_by=group_by, *kwargs))
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;partition_rate&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(total_partitions / total, group_by=group_by, **wrap_kwargs)

    # ############# Logical operations ############# #

    def AND(self, other: tp.ArrayLike, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Combine with `other` using logical AND.

        See `vectorbt.base.accessors.BaseAccessor.combine`.

        &#34;&#34;&#34;
        return self.combine(other, combine_func=np.logical_and, **kwargs)

    def OR(self, other: tp.ArrayLike, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Combine with `other` using logical OR.

        See `vectorbt.base.accessors.BaseAccessor.combine`.

        ## Example

        Perform two OR operations and concatenate them:

        ```python-repl
        &gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1])
        &gt;&gt;&gt; mask.vbt.signals.OR([ts &gt; 1, ts &gt; 2], concat=True, keys=[&#39;&gt;1&#39;, &#39;&gt;2&#39;])
                                    &gt;1                   &gt;2
                        a     b      c      a      b      c
        2020-01-01   True  True   True   True   True   True
        2020-01-02   True  True   True  False  False   True
        2020-01-03   True  True   True   True   True   True
        2020-01-04   True  True   True  False  False  False
        2020-01-05  False  True  False  False   True  False
        ```
        &#34;&#34;&#34;
        return self.combine(other, combine_func=np.logical_or, **kwargs)

    def XOR(self, other: tp.ArrayLike, **kwargs) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Combine with `other` using logical XOR.

        See `vectorbt.base.accessors.BaseAccessor.combine`.&#34;&#34;&#34;
        return self.combine(other, combine_func=np.logical_xor, **kwargs)

    # ############# Stats ############# #

    @property
    def stats_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `SignalsAccessor.stats`.

        Merges `vectorbt.generic.accessors.GenericAccessor.stats_defaults` and
        `signals.stats` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        signals_stats_cfg = settings[&#39;signals&#39;][&#39;stats&#39;]

        return merge_dicts(
            GenericAccessor.stats_defaults.__get__(self),
            signals_stats_cfg
        )

    _metrics: tp.ClassVar[Config] = Config(
        dict(
            start=dict(
                title=&#39;Start&#39;,
                calc_func=lambda self: self.wrapper.index[0],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            end=dict(
                title=&#39;End&#39;,
                calc_func=lambda self: self.wrapper.index[-1],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            period=dict(
                title=&#39;Period&#39;,
                calc_func=lambda self: len(self.wrapper.index),
                apply_to_timedelta=True,
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            total=dict(
                title=&#39;Total&#39;,
                calc_func=&#39;total&#39;,
                tags=&#39;signals&#39;
            ),
            rate=dict(
                title=&#39;Rate [%]&#39;,
                calc_func=&#39;rate&#39;,
                post_calc_func=lambda self, out, settings: out * 100,
                tags=&#39;signals&#39;
            ),
            total_overlapping=dict(
                title=&#39;Total Overlapping&#39;,
                calc_func=lambda self, other, group_by:
                (self &amp; other).vbt.signals.total(group_by=group_by),
                check_silent_has_other=True,
                tags=[&#39;signals&#39;, &#39;other&#39;]
            ),
            overlapping_rate=dict(
                title=&#39;Overlapping Rate [%]&#39;,
                calc_func=lambda self, other, group_by:
                (self &amp; other).vbt.signals.total(group_by=group_by) /
                (self | other).vbt.signals.total(group_by=group_by),
                post_calc_func=lambda self, out, settings: out * 100,
                check_silent_has_other=True,
                tags=[&#39;signals&#39;, &#39;other&#39;]
            ),
            first_index=dict(
                title=&#39;First Index&#39;,
                calc_func=&#39;nth_index&#39;,
                n=0,
                return_labels=True,
                tags=[&#39;signals&#39;, &#39;index&#39;]
            ),
            last_index=dict(
                title=&#39;Last Index&#39;,
                calc_func=&#39;nth_index&#39;,
                n=-1,
                return_labels=True,
                tags=[&#39;signals&#39;, &#39;index&#39;]
            ),
            norm_avg_index=dict(
                title=&#39;Norm Avg Index [-1, 1]&#39;,
                calc_func=&#39;norm_avg_index&#39;,
                tags=[&#39;signals&#39;, &#39;index&#39;]
            ),
            distance=dict(
                title=RepEval(&#34;f&#39;Distance {\&#34;&lt;-\&#34; if from_other else \&#34;-&gt;\&#34;} {other_name}&#39; &#34;
                              &#34;if other is not None else &#39;Distance&#39;&#34;),
                calc_func=&#39;between_ranges.duration&#39;,
                post_calc_func=lambda self, out, settings: {
                    &#39;Min&#39;: out.min(),
                    &#39;Max&#39;: out.max(),
                    &#39;Mean&#39;: out.mean(),
                    &#39;Std&#39;: out.std(ddof=settings.get(&#39;ddof&#39;, 1))
                },
                apply_to_timedelta=True,
                tags=RepEval(&#34;[&#39;signals&#39;, &#39;distance&#39;, &#39;other&#39;] if other is not None else [&#39;signals&#39;, &#39;distance&#39;]&#34;)
            ),
            total_partitions=dict(
                title=&#39;Total Partitions&#39;,
                calc_func=&#39;total_partitions&#39;,
                tags=[&#39;signals&#39;, &#39;partitions&#39;]
            ),
            partition_rate=dict(
                title=&#39;Partition Rate [%]&#39;,
                calc_func=&#39;partition_rate&#39;,
                post_calc_func=lambda self, out, settings: out * 100,
                tags=[&#39;signals&#39;, &#39;partitions&#39;]
            ),
            partition_len=dict(
                title=&#39;Partition Length&#39;,
                calc_func=&#39;partition_ranges.duration&#39;,
                post_calc_func=lambda self, out, settings: {
                    &#39;Min&#39;: out.min(),
                    &#39;Max&#39;: out.max(),
                    &#39;Mean&#39;: out.mean(),
                    &#39;Std&#39;: out.std(ddof=settings.get(&#39;ddof&#39;, 1))
                },
                apply_to_timedelta=True,
                tags=[&#39;signals&#39;, &#39;partitions&#39;, &#39;distance&#39;]
            ),
            partition_distance=dict(
                title=&#39;Partition Distance&#39;,
                calc_func=&#39;between_partition_ranges.duration&#39;,
                post_calc_func=lambda self, out, settings: {
                    &#39;Min&#39;: out.min(),
                    &#39;Max&#39;: out.max(),
                    &#39;Mean&#39;: out.mean(),
                    &#39;Std&#39;: out.std(ddof=settings.get(&#39;ddof&#39;, 1))
                },
                apply_to_timedelta=True,
                tags=[&#39;signals&#39;, &#39;partitions&#39;, &#39;distance&#39;]
            ),
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def metrics(self) -&gt; Config:
        return self._metrics

    # ############# Plotting ############# #

    def plot(self, yref: str = &#39;y&#39;, **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
        &#34;&#34;&#34;Plot signals.

        Args:
            yref (str): Y coordinate axis.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.lineplot`.

        ## Example

        ```python-repl
        &gt;&gt;&gt; mask[[&#39;a&#39;, &#39;c&#39;]].vbt.signals.plot()
        ```

        ![](/docs/img/signals_df_plot.svg)
        &#34;&#34;&#34;
        default_layout = dict()
        default_layout[&#39;yaxis&#39; + yref[1:]] = dict(
            tickmode=&#39;array&#39;,
            tickvals=[0, 1],
            ticktext=[&#39;false&#39;, &#39;true&#39;]
        )
        return self.obj.vbt.lineplot(**merge_dicts(default_layout, kwargs))

    @property
    def plots_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `SignalsAccessor.plots`.

        Merges `vectorbt.generic.accessors.GenericAccessor.plots_defaults` and
        `signals.plots` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        signals_plots_cfg = settings[&#39;signals&#39;][&#39;plots&#39;]

        return merge_dicts(
            GenericAccessor.plots_defaults.__get__(self),
            signals_plots_cfg
        )

    @property
    def subplots(self) -&gt; Config:
        return self._subplots</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.generic.accessors.GenericAccessor" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor">GenericAccessor</a></li>
<li><a title="vectorbt.base.accessors.BaseAccessor" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor">BaseAccessor</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr.AttrResolver" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.signals.accessors.SignalsDFAccessor" href="#vectorbt.signals.accessors.SignalsDFAccessor">SignalsDFAccessor</a></li>
<li><a title="vectorbt.signals.accessors.SignalsSRAccessor" href="#vectorbt.signals.accessors.SignalsSRAccessor">SignalsSRAccessor</a></li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.signals.accessors.SignalsAccessor.metrics"><code class="name">var <span class="ident child-name">metrics</span></code></dt>
<dd>
<div class="desc"><p>Metrics supported by <code><a title="vectorbt.signals.accessors.SignalsAccessor" href="#vectorbt.signals.accessors.SignalsAccessor">SignalsAccessor</a></code>.</p>
<pre><code class="language-json">Config({
    &quot;start&quot;: {
        &quot;title&quot;: &quot;Start&quot;,
        &quot;calc_func&quot;: &quot;&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7fcd3f7540d0&gt;&quot;,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    },
    &quot;end&quot;: {
        &quot;title&quot;: &quot;End&quot;,
        &quot;calc_func&quot;: &quot;&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7fcd3f754158&gt;&quot;,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    },
    &quot;period&quot;: {
        &quot;title&quot;: &quot;Period&quot;,
        &quot;calc_func&quot;: &quot;&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7fcd3f7541e0&gt;&quot;,
        &quot;apply_to_timedelta&quot;: true,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    },
    &quot;total&quot;: {
        &quot;title&quot;: &quot;Total&quot;,
        &quot;calc_func&quot;: &quot;total&quot;,
        &quot;tags&quot;: &quot;signals&quot;
    },
    &quot;rate&quot;: {
        &quot;title&quot;: &quot;Rate [%]&quot;,
        &quot;calc_func&quot;: &quot;rate&quot;,
        &quot;post_calc_func&quot;: &quot;&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7fcd3f754268&gt;&quot;,
        &quot;tags&quot;: &quot;signals&quot;
    },
    &quot;total_overlapping&quot;: {
        &quot;title&quot;: &quot;Total Overlapping&quot;,
        &quot;calc_func&quot;: &quot;&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7fcd3f7542f0&gt;&quot;,
        &quot;check_silent_has_other&quot;: true,
        &quot;tags&quot;: [
            &quot;signals&quot;,
            &quot;other&quot;
        ]
    },
    &quot;overlapping_rate&quot;: {
        &quot;title&quot;: &quot;Overlapping Rate [%]&quot;,
        &quot;calc_func&quot;: &quot;&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7fcd3f754378&gt;&quot;,
        &quot;post_calc_func&quot;: &quot;&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7fcd3f754400&gt;&quot;,
        &quot;check_silent_has_other&quot;: true,
        &quot;tags&quot;: [
            &quot;signals&quot;,
            &quot;other&quot;
        ]
    },
    &quot;first_index&quot;: {
        &quot;title&quot;: &quot;First Index&quot;,
        &quot;calc_func&quot;: &quot;nth_index&quot;,
        &quot;n&quot;: 0,
        &quot;return_labels&quot;: true,
        &quot;tags&quot;: [
            &quot;signals&quot;,
            &quot;index&quot;
        ]
    },
    &quot;last_index&quot;: {
        &quot;title&quot;: &quot;Last Index&quot;,
        &quot;calc_func&quot;: &quot;nth_index&quot;,
        &quot;n&quot;: -1,
        &quot;return_labels&quot;: true,
        &quot;tags&quot;: [
            &quot;signals&quot;,
            &quot;index&quot;
        ]
    },
    &quot;norm_avg_index&quot;: {
        &quot;title&quot;: &quot;Norm Avg Index [-1, 1]&quot;,
        &quot;calc_func&quot;: &quot;norm_avg_index&quot;,
        &quot;tags&quot;: [
            &quot;signals&quot;,
            &quot;index&quot;
        ]
    },
    &quot;distance&quot;: {
        &quot;title&quot;: &quot;RepEval(expression=\&quot;f'Distance {\&quot;&lt;-\&quot; if from_other else \&quot;-&gt;\&quot;} {other_name}' if other is not None else 'Distance'\&quot;, mapping={})&quot;,
        &quot;calc_func&quot;: &quot;between_ranges.duration&quot;,
        &quot;post_calc_func&quot;: &quot;&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7fcd3f754488&gt;&quot;,
        &quot;apply_to_timedelta&quot;: true,
        &quot;tags&quot;: &quot;RepEval(expression=\&quot;['signals', 'distance', 'other'] if other is not None else ['signals', 'distance']\&quot;, mapping={})&quot;
    },
    &quot;total_partitions&quot;: {
        &quot;title&quot;: &quot;Total Partitions&quot;,
        &quot;calc_func&quot;: &quot;total_partitions&quot;,
        &quot;tags&quot;: [
            &quot;signals&quot;,
            &quot;partitions&quot;
        ]
    },
    &quot;partition_rate&quot;: {
        &quot;title&quot;: &quot;Partition Rate [%]&quot;,
        &quot;calc_func&quot;: &quot;partition_rate&quot;,
        &quot;post_calc_func&quot;: &quot;&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7fcd3f754510&gt;&quot;,
        &quot;tags&quot;: [
            &quot;signals&quot;,
            &quot;partitions&quot;
        ]
    },
    &quot;partition_len&quot;: {
        &quot;title&quot;: &quot;Partition Length&quot;,
        &quot;calc_func&quot;: &quot;partition_ranges.duration&quot;,
        &quot;post_calc_func&quot;: &quot;&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7fcd3f754598&gt;&quot;,
        &quot;apply_to_timedelta&quot;: true,
        &quot;tags&quot;: [
            &quot;signals&quot;,
            &quot;partitions&quot;,
            &quot;distance&quot;
        ]
    },
    &quot;partition_distance&quot;: {
        &quot;title&quot;: &quot;Partition Distance&quot;,
        &quot;calc_func&quot;: &quot;between_partition_ranges.duration&quot;,
        &quot;post_calc_func&quot;: &quot;&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7fcd3f754620&gt;&quot;,
        &quot;apply_to_timedelta&quot;: true,
        &quot;tags&quot;: [
            &quot;signals&quot;,
            &quot;partitions&quot;,
            &quot;distance&quot;
        ]
    }
})
</code></pre>
<p>Returns <code>SignalsAccessor._metrics</code>, which gets (deep) copied upon creation of each instance.
Thus, changing this config won't affect the class.</p>
<p>To change metrics, you can either change the config in-place, override this property,
or overwrite the instance variable <code>SignalsAccessor._metrics</code>.</p></div>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.subplots"><code class="name">var <span class="ident child-name">subplots</span></code></dt>
<dd>
<div class="desc"><p>Subplots supported by <code><a title="vectorbt.signals.accessors.SignalsAccessor" href="#vectorbt.signals.accessors.SignalsAccessor">SignalsAccessor</a></code>.</p>
<pre><code class="language-json">Config({
    &quot;plot&quot;: {
        &quot;check_is_not_grouped&quot;: true,
        &quot;plot_func&quot;: &quot;plot&quot;,
        &quot;pass_trace_names&quot;: false,
        &quot;tags&quot;: &quot;generic&quot;
    }
})
</code></pre>
<p>Returns <code>SignalsAccessor._subplots</code>, which gets (deep) copied upon creation of each instance.
Thus, changing this config won't affect the class.</p>
<p>To change subplots, you can either change the config in-place, override this property,
or overwrite the instance variable <code>SignalsAccessor._subplots</code>.</p></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.accessors.SignalsAccessor.clean"><code class="name flex">
<span>def <span class="ident child-name">clean</span></span>(<span class="params">*args, entry_first=True, broadcast_kwargs=None, wrap_kwargs=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Clean signals.</p>
<p>If one array passed, see <code><a title="vectorbt.signals.accessors.SignalsAccessor.first" href="#vectorbt.signals.accessors.SignalsAccessor.first">SignalsAccessor.first()</a></code>.
If two arrays passed, entries and exits, see <code><a title="vectorbt.signals.nb.clean_enex_nb" href="nb.html#vectorbt.signals.nb.clean_enex_nb">clean_enex_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@class_or_instancemethod
def clean(cls_or_self,
          *args,
          entry_first: bool = True,
          broadcast_kwargs: tp.KwargsLike = None,
          wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeTuple[tp.SeriesFrame]:
    &#34;&#34;&#34;Clean signals.

    If one array passed, see `SignalsAccessor.first`.
    If two arrays passed, entries and exits, see `vectorbt.signals.nb.clean_enex_nb`.&#34;&#34;&#34;
    if not isinstance(cls_or_self, type):
        args = (cls_or_self.obj, *args)
    if len(args) == 1:
        obj = args[0]
        if not isinstance(obj, (pd.Series, pd.DataFrame)):
            wrapper = ArrayWrapper.from_shape(np.asarray(obj).shape)
            obj = wrapper.wrap(obj)
        return obj.vbt.signals.first(wrap_kwargs=wrap_kwargs)
    elif len(args) == 2:
        if broadcast_kwargs is None:
            broadcast_kwargs = {}
        entries, exits = reshape_fns.broadcast(*args, **broadcast_kwargs)
        entries_out, exits_out = nb.clean_enex_nb(
            reshape_fns.to_2d_array(entries),
            reshape_fns.to_2d_array(exits),
            entry_first
        )
        return (
            ArrayWrapper.from_obj(entries).wrap(entries_out, group_by=False, **merge_dicts({}, wrap_kwargs)),
            ArrayWrapper.from_obj(exits).wrap(exits_out, group_by=False, **merge_dicts({}, wrap_kwargs))
        )
    else:
        raise ValueError(&#34;Either one or two arrays must be passed&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.empty"><code class="name flex">
<span>def <span class="ident child-name">empty</span></span>(<span class="params">*args, fill_value=False, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.base.accessors.BaseAccessor.empty" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.empty">BaseAccessor.empty()</a></code> with <code>fill_value=False</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def empty(cls, *args, fill_value: bool = False, **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;`vectorbt.base.accessors.BaseAccessor.empty` with `fill_value=False`.&#34;&#34;&#34;
    return GenericAccessor.empty(*args, fill_value=fill_value, dtype=np.bool_, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.empty_like"><code class="name flex">
<span>def <span class="ident child-name">empty_like</span></span>(<span class="params">*args, fill_value=False, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.base.accessors.BaseAccessor.empty_like" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.empty_like">BaseAccessor.empty_like()</a></code> with <code>fill_value=False</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def empty_like(cls, *args, fill_value: bool = False, **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;`vectorbt.base.accessors.BaseAccessor.empty_like` with `fill_value=False`.&#34;&#34;&#34;
    return GenericAccessor.empty_like(*args, fill_value=fill_value, dtype=np.bool_, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.generate"><code class="name flex">
<span>def <span class="ident child-name">generate</span></span>(<span class="params">shape, choice_func_nb, *args, pick_first=False, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.signals.nb.generate_nb" href="nb.html#vectorbt.signals.nb.generate_nb">generate_nb()</a></code>.</p>
<p><code>**kwargs</code> will be passed to pandas constructor.</p>
<h2 id="example">Example</h2>
<p>Generate random signals manually:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @njit
... def choice_func_nb(from_i, to_i, col):
...     return col + from_i

&gt;&gt;&gt; pd.DataFrame.vbt.signals.generate((5, 3),
...     choice_func_nb, index=mask.index, columns=mask.columns)
                a      b      c
2020-01-01   True  False  False
2020-01-02  False   True  False
2020-01-03  False  False   True
2020-01-04  False  False  False
2020-01-05  False  False  False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def generate(cls,
             shape: tp.RelaxedShape,
             choice_func_nb: tp.ChoiceFunc, *args,
             pick_first: bool = False,
             **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;See `vectorbt.signals.nb.generate_nb`.

    `**kwargs` will be passed to pandas constructor.

    ## Example

    Generate random signals manually:

    ```python-repl
    &gt;&gt;&gt; @njit
    ... def choice_func_nb(from_i, to_i, col):
    ...     return col + from_i

    &gt;&gt;&gt; pd.DataFrame.vbt.signals.generate((5, 3),
    ...     choice_func_nb, index=mask.index, columns=mask.columns)
                    a      b      c
    2020-01-01   True  False  False
    2020-01-02  False   True  False
    2020-01-03  False  False   True
    2020-01-04  False  False  False
    2020-01-05  False  False  False
    ```
    &#34;&#34;&#34;
    checks.assert_numba_func(choice_func_nb)

    if not isinstance(shape, tuple):
        shape = (shape, 1)
    elif isinstance(shape, tuple) and len(shape) == 1:
        shape = (shape[0], 1)

    result = nb.generate_nb(shape, pick_first, choice_func_nb, *args)

    if cls.is_series():
        if shape[1] &gt; 1:
            raise ValueError(&#34;Use DataFrame accessor&#34;)
        return pd.Series(result[:, 0], **kwargs)
    return pd.DataFrame(result, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.generate_both"><code class="name flex">
<span>def <span class="ident child-name">generate_both</span></span>(<span class="params">shape, entry_choice_func_nb=None, entry_args=None, exit_choice_func_nb=None, exit_args=None, entry_wait=1, exit_wait=1, entry_pick_first=True, exit_pick_first=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.signals.nb.generate_enex_nb" href="nb.html#vectorbt.signals.nb.generate_enex_nb">generate_enex_nb()</a></code>.</p>
<p><code>**kwargs</code> will be passed to pandas constructor.</p>
<h2 id="example">Example</h2>
<p>Generate entry and exit signals one after another. Each column increment
the number of ticks to wait before placing the exit signal.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @njit
... def entry_choice_func_nb(from_i, to_i, col, temp_idx_arr):
...     temp_idx_arr[0] = from_i
...     return temp_idx_arr[:1]  # array with one signal

&gt;&gt;&gt; @njit
... def exit_choice_func_nb(from_i, to_i, col, temp_idx_arr):
...     wait = col
...     temp_idx_arr[0] = from_i + wait
...     if temp_idx_arr[0] &lt; to_i:
...         return temp_idx_arr[:1]  # array with one signal
...     return temp_idx_arr[:0]  # empty array

&gt;&gt;&gt; temp_idx_arr = np.empty((1,), dtype=np.int_)  # reuse memory
&gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_both(
...     (5, 3),
...     entry_choice_func_nb, (temp_idx_arr,),
...     exit_choice_func_nb, (temp_idx_arr,),
...     index=mask.index, columns=mask.columns)
&gt;&gt;&gt; en
                a      b      c
2020-01-01   True   True   True
2020-01-02  False  False  False
2020-01-03   True  False  False
2020-01-04  False   True  False
2020-01-05   True  False   True
&gt;&gt;&gt; ex
                a      b      c
2020-01-01  False  False  False
2020-01-02   True  False  False
2020-01-03  False   True  False
2020-01-04   True  False   True
2020-01-05  False  False  False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def generate_both(cls,
                  shape: tp.RelaxedShape,
                  entry_choice_func_nb: tp.Optional[tp.ChoiceFunc] = None,
                  entry_args: tp.ArgsLike = None,
                  exit_choice_func_nb: tp.Optional[tp.ChoiceFunc] = None,
                  exit_args: tp.ArgsLike = None,
                  entry_wait: int = 1,
                  exit_wait: int = 1,
                  entry_pick_first: bool = True,
                  exit_pick_first: bool = True,
                  **kwargs) -&gt; tp.Tuple[tp.SeriesFrame, tp.SeriesFrame]:
    &#34;&#34;&#34;See `vectorbt.signals.nb.generate_enex_nb`.

    `**kwargs` will be passed to pandas constructor.

    ## Example

    Generate entry and exit signals one after another. Each column increment
    the number of ticks to wait before placing the exit signal.

    ```python-repl
    &gt;&gt;&gt; @njit
    ... def entry_choice_func_nb(from_i, to_i, col, temp_idx_arr):
    ...     temp_idx_arr[0] = from_i
    ...     return temp_idx_arr[:1]  # array with one signal

    &gt;&gt;&gt; @njit
    ... def exit_choice_func_nb(from_i, to_i, col, temp_idx_arr):
    ...     wait = col
    ...     temp_idx_arr[0] = from_i + wait
    ...     if temp_idx_arr[0] &lt; to_i:
    ...         return temp_idx_arr[:1]  # array with one signal
    ...     return temp_idx_arr[:0]  # empty array

    &gt;&gt;&gt; temp_idx_arr = np.empty((1,), dtype=np.int_)  # reuse memory
    &gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_both(
    ...     (5, 3),
    ...     entry_choice_func_nb, (temp_idx_arr,),
    ...     exit_choice_func_nb, (temp_idx_arr,),
    ...     index=mask.index, columns=mask.columns)
    &gt;&gt;&gt; en
                    a      b      c
    2020-01-01   True   True   True
    2020-01-02  False  False  False
    2020-01-03   True  False  False
    2020-01-04  False   True  False
    2020-01-05   True  False   True
    &gt;&gt;&gt; ex
                    a      b      c
    2020-01-01  False  False  False
    2020-01-02   True  False  False
    2020-01-03  False   True  False
    2020-01-04   True  False   True
    2020-01-05  False  False  False
    ```
    &#34;&#34;&#34;
    checks.assert_not_none(entry_choice_func_nb)
    checks.assert_not_none(exit_choice_func_nb)
    checks.assert_numba_func(entry_choice_func_nb)
    checks.assert_numba_func(exit_choice_func_nb)
    if entry_args is None:
        entry_args = ()
    if exit_args is None:
        exit_args = ()

    if not isinstance(shape, tuple):
        shape = (shape, 1)
    elif isinstance(shape, tuple) and len(shape) == 1:
        shape = (shape[0], 1)

    result1, result2 = nb.generate_enex_nb(
        shape,
        entry_wait,
        exit_wait,
        entry_pick_first,
        exit_pick_first,
        entry_choice_func_nb, entry_args,
        exit_choice_func_nb, exit_args
    )
    if cls.is_series():
        if shape[1] &gt; 1:
            raise ValueError(&#34;Use DataFrame accessor&#34;)
        return pd.Series(result1[:, 0], **kwargs), pd.Series(result2[:, 0], **kwargs)
    return pd.DataFrame(result1, **kwargs), pd.DataFrame(result2, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.generate_random"><code class="name flex">
<span>def <span class="ident child-name">generate_random</span></span>(<span class="params">shape, n=None, prob=None, pick_first=False, seed=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Generate signals randomly.</p>
<p>If <code>n</code> is set, see <code><a title="vectorbt.signals.nb.generate_rand_nb" href="nb.html#vectorbt.signals.nb.generate_rand_nb">generate_rand_nb()</a></code>.
If <code>prob</code> is set, see <code><a title="vectorbt.signals.nb.generate_rand_by_prob_nb" href="nb.html#vectorbt.signals.nb.generate_rand_by_prob_nb">generate_rand_by_prob_nb()</a></code>.</p>
<p><code>n</code> should be either a scalar or an array that will broadcast to the number of columns.
<code>prob</code> should be either a single number or an array that will broadcast to match <code>shape</code>.
<code>**kwargs</code> will be passed to pandas constructor.</p>
<h2 id="example">Example</h2>
<p>For each column, generate a variable number of signals:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pd.DataFrame.vbt.signals.generate_random((5, 3), n=[0, 1, 2],
...     seed=42, index=mask.index, columns=mask.columns)
                a      b      c
2020-01-01  False  False   True
2020-01-02  False  False   True
2020-01-03  False  False  False
2020-01-04  False   True  False
2020-01-05  False  False  False
</code></pre>
<p>For each column and time step, pick a signal with 50% probability:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pd.DataFrame.vbt.signals.generate_random((5, 3), prob=0.5,
...     seed=42, index=mask.index, columns=mask.columns)
                a      b      c
2020-01-01   True   True   True
2020-01-02  False   True  False
2020-01-03  False  False  False
2020-01-04  False  False   True
2020-01-05   True  False   True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def generate_random(cls,
                    shape: tp.RelaxedShape,
                    n: tp.Optional[tp.ArrayLike] = None,
                    prob: tp.Optional[tp.ArrayLike] = None,
                    pick_first: bool = False,
                    seed: tp.Optional[int] = None,
                    **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Generate signals randomly.

    If `n` is set, see `vectorbt.signals.nb.generate_rand_nb`.
    If `prob` is set, see `vectorbt.signals.nb.generate_rand_by_prob_nb`.

    `n` should be either a scalar or an array that will broadcast to the number of columns.
    `prob` should be either a single number or an array that will broadcast to match `shape`.
    `**kwargs` will be passed to pandas constructor.

    ## Example

    For each column, generate a variable number of signals:

    ```python-repl
    &gt;&gt;&gt; pd.DataFrame.vbt.signals.generate_random((5, 3), n=[0, 1, 2],
    ...     seed=42, index=mask.index, columns=mask.columns)
                    a      b      c
    2020-01-01  False  False   True
    2020-01-02  False  False   True
    2020-01-03  False  False  False
    2020-01-04  False   True  False
    2020-01-05  False  False  False
    ```

    For each column and time step, pick a signal with 50% probability:

    ```python-repl
    &gt;&gt;&gt; pd.DataFrame.vbt.signals.generate_random((5, 3), prob=0.5,
    ...     seed=42, index=mask.index, columns=mask.columns)
                    a      b      c
    2020-01-01   True   True   True
    2020-01-02  False   True  False
    2020-01-03  False  False  False
    2020-01-04  False  False   True
    2020-01-05   True  False   True
    ```
    &#34;&#34;&#34;
    flex_2d = True
    if not isinstance(shape, tuple):
        flex_2d = False
        shape = (shape, 1)
    elif isinstance(shape, tuple) and len(shape) == 1:
        flex_2d = False
        shape = (shape[0], 1)

    if n is not None and prob is not None:
        raise ValueError(&#34;Either n or prob should be set, not both&#34;)
    if n is not None:
        n = np.broadcast_to(n, shape[1])
        result = nb.generate_rand_nb(shape, n, seed=seed)
    elif prob is not None:
        prob = np.broadcast_to(prob, shape)
        result = nb.generate_rand_by_prob_nb(shape, prob, pick_first, flex_2d, seed=seed)
    else:
        raise ValueError(&#34;At least n or prob should be set&#34;)

    if cls.is_series():
        if shape[1] &gt; 1:
            raise ValueError(&#34;Use DataFrame accessor&#34;)
        return pd.Series(result[:, 0], **kwargs)
    return pd.DataFrame(result, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.generate_random_both"><code class="name flex">
<span>def <span class="ident child-name">generate_random_both</span></span>(<span class="params">shape, n=None, entry_prob=None, exit_prob=None, seed=None, entry_wait=1, exit_wait=1, entry_pick_first=True, exit_pick_first=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Generate chain of entry and exit signals randomly.</p>
<p>If <code>n</code> is set, see <code><a title="vectorbt.signals.nb.generate_rand_enex_nb" href="nb.html#vectorbt.signals.nb.generate_rand_enex_nb">generate_rand_enex_nb()</a></code>.
If <code>entry_prob</code> and <code>exit_prob</code> are set, see <code><a title="vectorbt.signals.nb.generate_rand_enex_by_prob_nb" href="nb.html#vectorbt.signals.nb.generate_rand_enex_by_prob_nb">generate_rand_enex_by_prob_nb()</a></code>.</p>
<p>For arguments, see <code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_random" href="#vectorbt.signals.accessors.SignalsAccessor.generate_random">SignalsAccessor.generate_random()</a></code>.</p>
<h2 id="example">Example</h2>
<p>For each column, generate two entries and exits randomly:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_random_both(
...     (5, 3), n=2, seed=42, index=mask.index, columns=mask.columns)
&gt;&gt;&gt; en
                a      b      c
2020-01-01   True   True   True
2020-01-02  False  False  False
2020-01-03   True   True  False
2020-01-04  False  False   True
2020-01-05  False  False  False
&gt;&gt;&gt; ex
                a      b      c
2020-01-01  False  False  False
2020-01-02   True   True   True
2020-01-03  False  False  False
2020-01-04  False   True  False
2020-01-05   True  False   True
</code></pre>
<p>For each column and time step, pick entry with 50% probability and exit right after:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_random_both(
...     (5, 3), entry_prob=0.5, exit_prob=1.,
...     seed=42, index=mask.index, columns=mask.columns)
&gt;&gt;&gt; en
                a      b      c
2020-01-01   True   True   True
2020-01-02  False  False  False
2020-01-03  False  False  False
2020-01-04  False  False   True
2020-01-05   True  False  False
&gt;&gt;&gt; ex
                a      b      c
2020-01-01  False  False  False
2020-01-02   True   True  False
2020-01-03  False  False   True
2020-01-04  False   True  False
2020-01-05   True  False   True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def generate_random_both(cls,
                         shape: tp.RelaxedShape,
                         n: tp.Optional[tp.ArrayLike] = None,
                         entry_prob: tp.Optional[tp.ArrayLike] = None,
                         exit_prob: tp.Optional[tp.ArrayLike] = None,
                         seed: tp.Optional[int] = None,
                         entry_wait: int = 1,
                         exit_wait: int = 1,
                         entry_pick_first: bool = True,
                         exit_pick_first: bool = True,
                         **kwargs) -&gt; tp.Tuple[tp.SeriesFrame, tp.SeriesFrame]:
    &#34;&#34;&#34;Generate chain of entry and exit signals randomly.

    If `n` is set, see `vectorbt.signals.nb.generate_rand_enex_nb`.
    If `entry_prob` and `exit_prob` are set, see `vectorbt.signals.nb.generate_rand_enex_by_prob_nb`.

    For arguments, see `SignalsAccessor.generate_random`.

    ## Example

    For each column, generate two entries and exits randomly:

    ```python-repl
    &gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_random_both(
    ...     (5, 3), n=2, seed=42, index=mask.index, columns=mask.columns)
    &gt;&gt;&gt; en
                    a      b      c
    2020-01-01   True   True   True
    2020-01-02  False  False  False
    2020-01-03   True   True  False
    2020-01-04  False  False   True
    2020-01-05  False  False  False
    &gt;&gt;&gt; ex
                    a      b      c
    2020-01-01  False  False  False
    2020-01-02   True   True   True
    2020-01-03  False  False  False
    2020-01-04  False   True  False
    2020-01-05   True  False   True
    ```

    For each column and time step, pick entry with 50% probability and exit right after:

    ```python-repl
    &gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_random_both(
    ...     (5, 3), entry_prob=0.5, exit_prob=1.,
    ...     seed=42, index=mask.index, columns=mask.columns)
    &gt;&gt;&gt; en
                    a      b      c
    2020-01-01   True   True   True
    2020-01-02  False  False  False
    2020-01-03  False  False  False
    2020-01-04  False  False   True
    2020-01-05   True  False  False
    &gt;&gt;&gt; ex
                    a      b      c
    2020-01-01  False  False  False
    2020-01-02   True   True  False
    2020-01-03  False  False   True
    2020-01-04  False   True  False
    2020-01-05   True  False   True
    ```
    &#34;&#34;&#34;
    flex_2d = True
    if not isinstance(shape, tuple):
        flex_2d = False
        shape = (shape, 1)
    elif isinstance(shape, tuple) and len(shape) == 1:
        flex_2d = False
        shape = (shape[0], 1)

    if n is not None and (entry_prob is not None or exit_prob is not None):
        raise ValueError(&#34;Either n or any of the entry_prob and exit_prob should be set, not both&#34;)
    if n is not None:
        n = np.broadcast_to(n, shape[1])
        entries, exits = nb.generate_rand_enex_nb(shape, n, entry_wait, exit_wait, seed=seed)
    elif entry_prob is not None and exit_prob is not None:
        entry_prob = np.broadcast_to(entry_prob, shape)
        exit_prob = np.broadcast_to(exit_prob, shape)
        entries, exits = nb.generate_rand_enex_by_prob_nb(
            shape,
            entry_prob,
            exit_prob,
            entry_wait,
            exit_wait,
            entry_pick_first,
            exit_pick_first,
            flex_2d,
            seed=seed
        )
    else:
        raise ValueError(&#34;At least n, or entry_prob and exit_prob should be set&#34;)

    if cls.is_series():
        if shape[1] &gt; 1:
            raise ValueError(&#34;Use DataFrame accessor&#34;)
        return pd.Series(entries[:, 0], **kwargs), pd.Series(exits[:, 0], **kwargs)
    return pd.DataFrame(entries, **kwargs), pd.DataFrame(exits, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.accessors.SignalsAccessor.plots_defaults"><code class="name">var <span class="ident child-name">plots_defaults</span></code></dt>
<dd>
<div class="desc"><p>Defaults for <code><a title="vectorbt.signals.accessors.SignalsAccessor.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">PlotsBuilderMixin.plots()</a></code>.</p>
<p>Merges <code><a title="vectorbt.generic.accessors.GenericAccessor.plots_defaults" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.plots_defaults">GenericAccessor.plots_defaults</a></code> and
<code>signals.plots</code> from <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plots_defaults(self) -&gt; tp.Kwargs:
    &#34;&#34;&#34;Defaults for `SignalsAccessor.plots`.

    Merges `vectorbt.generic.accessors.GenericAccessor.plots_defaults` and
    `signals.plots` from `vectorbt._settings.settings`.&#34;&#34;&#34;
    from vectorbt._settings import settings
    signals_plots_cfg = settings[&#39;signals&#39;][&#39;plots&#39;]

    return merge_dicts(
        GenericAccessor.plots_defaults.__get__(self),
        signals_plots_cfg
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.stats_defaults"><code class="name">var <span class="ident child-name">stats_defaults</span></code></dt>
<dd>
<div class="desc"><p>Defaults for <code><a title="vectorbt.signals.accessors.SignalsAccessor.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code>.</p>
<p>Merges <code><a title="vectorbt.generic.accessors.GenericAccessor.stats_defaults" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.stats_defaults">GenericAccessor.stats_defaults</a></code> and
<code>signals.stats</code> from <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stats_defaults(self) -&gt; tp.Kwargs:
    &#34;&#34;&#34;Defaults for `SignalsAccessor.stats`.

    Merges `vectorbt.generic.accessors.GenericAccessor.stats_defaults` and
    `signals.stats` from `vectorbt._settings.settings`.&#34;&#34;&#34;
    from vectorbt._settings import settings
    signals_stats_cfg = settings[&#39;signals&#39;][&#39;stats&#39;]

    return merge_dicts(
        GenericAccessor.stats_defaults.__get__(self),
        signals_stats_cfg
    )</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.accessors.SignalsAccessor.AND"><code class="name flex">
<span>def <span class="ident child-name">AND</span></span>(<span class="params">self, other, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Combine with <code>other</code> using logical AND.</p>
<p>See <code><a title="vectorbt.base.accessors.BaseAccessor.combine" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.combine">BaseAccessor.combine()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AND(self, other: tp.ArrayLike, **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Combine with `other` using logical AND.

    See `vectorbt.base.accessors.BaseAccessor.combine`.

    &#34;&#34;&#34;
    return self.combine(other, combine_func=np.logical_and, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.OR"><code class="name flex">
<span>def <span class="ident child-name">OR</span></span>(<span class="params">self, other, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Combine with <code>other</code> using logical OR.</p>
<p>See <code><a title="vectorbt.base.accessors.BaseAccessor.combine" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.combine">BaseAccessor.combine()</a></code>.</p>
<h2 id="example">Example</h2>
<p>Perform two OR operations and concatenate them:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1])
&gt;&gt;&gt; mask.vbt.signals.OR([ts &gt; 1, ts &gt; 2], concat=True, keys=['&gt;1', '&gt;2'])
                            &gt;1                   &gt;2
                a     b      c      a      b      c
2020-01-01   True  True   True   True   True   True
2020-01-02   True  True   True  False  False   True
2020-01-03   True  True   True   True   True   True
2020-01-04   True  True   True  False  False  False
2020-01-05  False  True  False  False   True  False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OR(self, other: tp.ArrayLike, **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Combine with `other` using logical OR.

    See `vectorbt.base.accessors.BaseAccessor.combine`.

    ## Example

    Perform two OR operations and concatenate them:

    ```python-repl
    &gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1])
    &gt;&gt;&gt; mask.vbt.signals.OR([ts &gt; 1, ts &gt; 2], concat=True, keys=[&#39;&gt;1&#39;, &#39;&gt;2&#39;])
                                &gt;1                   &gt;2
                    a     b      c      a      b      c
    2020-01-01   True  True   True   True   True   True
    2020-01-02   True  True   True  False  False   True
    2020-01-03   True  True   True   True   True   True
    2020-01-04   True  True   True  False  False  False
    2020-01-05  False  True  False  False   True  False
    ```
    &#34;&#34;&#34;
    return self.combine(other, combine_func=np.logical_or, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.XOR"><code class="name flex">
<span>def <span class="ident child-name">XOR</span></span>(<span class="params">self, other, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Combine with <code>other</code> using logical XOR.</p>
<p>See <code><a title="vectorbt.base.accessors.BaseAccessor.combine" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.combine">BaseAccessor.combine()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def XOR(self, other: tp.ArrayLike, **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Combine with `other` using logical XOR.

    See `vectorbt.base.accessors.BaseAccessor.combine`.&#34;&#34;&#34;
    return self.combine(other, combine_func=np.logical_xor, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.between_partition_ranges"><code class="name flex">
<span>def <span class="ident child-name">between_partition_ranges</span></span>(<span class="params">self, group_by=None, attach_ts=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Wrap the result of <code><a title="vectorbt.signals.nb.between_partition_ranges_nb" href="nb.html#vectorbt.signals.nb.between_partition_ranges_nb">between_partition_ranges_nb()</a></code>
with <code><a title="vectorbt.generic.ranges.Ranges" href="../generic/ranges.html#vectorbt.generic.ranges.Ranges">Ranges</a></code>.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">```python-repl
&gt;&gt;&gt; mask_sr = pd.Series([True, False, False, True, False, True, True])
&gt;&gt;&gt; mask_sr.vbt.signals.between_partition_ranges().records_readable
   Range Id  Column  Start Timestamp  End Timestamp  Status
0         0       0                0              3  Closed
1         1       0                3              5  Closed
 ```
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def between_partition_ranges(self, group_by: tp.GroupByLike = None, attach_ts: bool = True, **kwargs) -&gt; Ranges:
    &#34;&#34;&#34;Wrap the result of `vectorbt.signals.nb.between_partition_ranges_nb`
    with `vectorbt.generic.ranges.Ranges`.

    ## Example

    ```python-repl
    &gt;&gt;&gt; mask_sr = pd.Series([True, False, False, True, False, True, True])
    &gt;&gt;&gt; mask_sr.vbt.signals.between_partition_ranges().records_readable
       Range Id  Column  Start Timestamp  End Timestamp  Status
    0         0       0                0              3  Closed
    1         1       0                3              5  Closed
     ```&#34;&#34;&#34;
    range_records = nb.between_partition_ranges_nb(self.to_2d_array())
    return Ranges(
        self.wrapper,
        range_records,
        ts=self.obj if attach_ts else None,
        **kwargs
    ).regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.between_ranges"><code class="name flex">
<span>def <span class="ident child-name">between_ranges</span></span>(<span class="params">self, other=None, from_other=False, broadcast_kwargs=None, group_by=None, attach_ts=True, attach_other=False, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Wrap the result of <code><a title="vectorbt.signals.nb.between_ranges_nb" href="nb.html#vectorbt.signals.nb.between_ranges_nb">between_ranges_nb()</a></code>
with <code><a title="vectorbt.generic.ranges.Ranges" href="../generic/ranges.html#vectorbt.generic.ranges.Ranges">Ranges</a></code>.</p>
<p>If <code>other</code> specified, see <code><a title="vectorbt.signals.nb.between_two_ranges_nb" href="nb.html#vectorbt.signals.nb.between_two_ranges_nb">between_two_ranges_nb()</a></code>.
Both will broadcast using <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code> and <code>broadcast_kwargs</code>.</p>
<h2 id="example">Example</h2>
<p>One array:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask_sr = pd.Series([True, False, False, True, False, True, True])
&gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges()
&gt;&gt;&gt; ranges
&lt;vectorbt.generic.ranges.Ranges at 0x7ff29ea7c7b8&gt;

&gt;&gt;&gt; ranges.records_readable
   Range Id  Column  Start Timestamp  End Timestamp  Status
0         0       0                0              3  Closed
1         1       0                3              5  Closed
2         2       0                5              6  Closed

&gt;&gt;&gt; ranges.duration.values
array([3, 2, 1])
</code></pre>
<p>Two arrays, traversing the signals of the first array:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask_sr = pd.Series([True, True, True, False, False])
&gt;&gt;&gt; mask_sr2 = pd.Series([False, False, True, False, True])
&gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges(other=mask_sr2)
&gt;&gt;&gt; ranges
&lt;vectorbt.generic.ranges.Ranges at 0x7ff29e3b80f0&gt;

&gt;&gt;&gt; ranges.records_readable
   Range Id  Column  Start Timestamp  End Timestamp  Status
0         0       0                0              2  Closed
1         1       0                1              2  Closed
2         2       0                2              2  Closed

&gt;&gt;&gt; ranges.duration.values
array([2, 1, 0])
</code></pre>
<p>Two arrays, traversing the signals of the second array:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges(other=mask_sr2, from_other=True)
&gt;&gt;&gt; ranges
&lt;vectorbt.generic.ranges.Ranges at 0x7ff29eccbd68&gt;

&gt;&gt;&gt; ranges.records_readable
   Range Id  Column  Start Timestamp  End Timestamp  Status
0         0       0                2              2  Closed
1         1       0                2              4  Closed

&gt;&gt;&gt; ranges.duration.values
array([0, 2])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def between_ranges(self,
                   other: tp.Optional[tp.ArrayLike] = None,
                   from_other: bool = False,
                   broadcast_kwargs: tp.KwargsLike = None,
                   group_by: tp.GroupByLike = None,
                   attach_ts: bool = True,
                   attach_other: bool = False,
                   **kwargs) -&gt; Ranges:
    &#34;&#34;&#34;Wrap the result of `vectorbt.signals.nb.between_ranges_nb`
    with `vectorbt.generic.ranges.Ranges`.

    If `other` specified, see `vectorbt.signals.nb.between_two_ranges_nb`.
    Both will broadcast using `vectorbt.base.reshape_fns.broadcast` and `broadcast_kwargs`.

    ## Example

    One array:

    ```python-repl
    &gt;&gt;&gt; mask_sr = pd.Series([True, False, False, True, False, True, True])
    &gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges()
    &gt;&gt;&gt; ranges
    &lt;vectorbt.generic.ranges.Ranges at 0x7ff29ea7c7b8&gt;

    &gt;&gt;&gt; ranges.records_readable
       Range Id  Column  Start Timestamp  End Timestamp  Status
    0         0       0                0              3  Closed
    1         1       0                3              5  Closed
    2         2       0                5              6  Closed

    &gt;&gt;&gt; ranges.duration.values
    array([3, 2, 1])
    ```

    Two arrays, traversing the signals of the first array:

    ```python-repl
    &gt;&gt;&gt; mask_sr = pd.Series([True, True, True, False, False])
    &gt;&gt;&gt; mask_sr2 = pd.Series([False, False, True, False, True])
    &gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges(other=mask_sr2)
    &gt;&gt;&gt; ranges
    &lt;vectorbt.generic.ranges.Ranges at 0x7ff29e3b80f0&gt;

    &gt;&gt;&gt; ranges.records_readable
       Range Id  Column  Start Timestamp  End Timestamp  Status
    0         0       0                0              2  Closed
    1         1       0                1              2  Closed
    2         2       0                2              2  Closed

    &gt;&gt;&gt; ranges.duration.values
    array([2, 1, 0])
    ```

    Two arrays, traversing the signals of the second array:

    ```python-repl
    &gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges(other=mask_sr2, from_other=True)
    &gt;&gt;&gt; ranges
    &lt;vectorbt.generic.ranges.Ranges at 0x7ff29eccbd68&gt;

    &gt;&gt;&gt; ranges.records_readable
       Range Id  Column  Start Timestamp  End Timestamp  Status
    0         0       0                2              2  Closed
    1         1       0                2              4  Closed

    &gt;&gt;&gt; ranges.duration.values
    array([0, 2])
    ```
    &#34;&#34;&#34;
    if broadcast_kwargs is None:
        broadcast_kwargs = {}

    if other is None:
        # One input array
        range_records = nb.between_ranges_nb(self.to_2d_array())
        wrapper = self.wrapper
        to_attach = self.obj
    else:
        # Two input arrays
        obj, other = reshape_fns.broadcast(self.obj, other, **broadcast_kwargs)
        range_records = nb.between_two_ranges_nb(
            reshape_fns.to_2d_array(obj),
            reshape_fns.to_2d_array(other),
            from_other=from_other
        )
        wrapper = ArrayWrapper.from_obj(obj)
        to_attach = other if attach_other else obj
    return Ranges(
        wrapper,
        range_records,
        ts=to_attach if attach_ts else None,
        **kwargs
    ).regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.bshift"><code class="name flex">
<span>def <span class="ident child-name">bshift</span></span>(<span class="params">self, *args, fill_value=False, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.generic.accessors.GenericAccessor.bshift" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.bshift">GenericAccessor.bshift()</a></code> with <code>fill_value=False</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bshift(self, *args, fill_value: bool = False, **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;`vectorbt.generic.accessors.GenericAccessor.bshift` with `fill_value=False`.&#34;&#34;&#34;
    return GenericAccessor.bshift(self, *args, fill_value=fill_value, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.first"><code class="name flex">
<span>def <span class="ident child-name">first</span></span>(<span class="params">self, wrap_kwargs=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Select signals that satisfy the condition <code>pos_rank == 0</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first(self, wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Select signals that satisfy the condition `pos_rank == 0`.&#34;&#34;&#34;
    pos_rank = self.pos_rank(**kwargs).values
    return self.wrapper.wrap(pos_rank == 0, group_by=False, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.from_nth"><code class="name flex">
<span>def <span class="ident child-name">from_nth</span></span>(<span class="params">self, n, wrap_kwargs=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Select signals that satisfy the condition <code>pos_rank &gt;= n</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_nth(self, n: int, wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Select signals that satisfy the condition `pos_rank &gt;= n`.&#34;&#34;&#34;
    pos_rank = self.pos_rank(**kwargs).values
    return self.wrapper.wrap(pos_rank &gt;= n, group_by=False, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.fshift"><code class="name flex">
<span>def <span class="ident child-name">fshift</span></span>(<span class="params">self, *args, fill_value=False, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.generic.accessors.GenericAccessor.fshift" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.fshift">GenericAccessor.fshift()</a></code> with <code>fill_value=False</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fshift(self, *args, fill_value: bool = False, **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;`vectorbt.generic.accessors.GenericAccessor.fshift` with `fill_value=False`.&#34;&#34;&#34;
    return GenericAccessor.fshift(self, *args, fill_value=fill_value, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.generate_exits"><code class="name flex">
<span>def <span class="ident child-name">generate_exits</span></span>(<span class="params">self, exit_choice_func_nb, *args, wait=1, until_next=True, skip_until_exit=False, pick_first=False, wrap_kwargs=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.signals.nb.generate_ex_nb" href="nb.html#vectorbt.signals.nb.generate_ex_nb">generate_ex_nb()</a></code>.</p>
<h2 id="example">Example</h2>
<p>Fill all space after signals in <code>mask</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @njit
... def exit_choice_func_nb(from_i, to_i, col, temp_range):
...     return temp_range[from_i:to_i]

&gt;&gt;&gt; temp_range = np.arange(mask.shape[0])  # reuse memory
&gt;&gt;&gt; mask.vbt.signals.generate_exits(exit_choice_func_nb, temp_range)
                a      b      c
2020-01-01  False  False  False
2020-01-02   True   True  False
2020-01-03   True  False  False
2020-01-04   True   True   True
2020-01-05   True  False   True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_exits(self,
                   exit_choice_func_nb: tp.ChoiceFunc, *args,
                   wait: int = 1,
                   until_next: bool = True,
                   skip_until_exit: bool = False,
                   pick_first: bool = False,
                   wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;See `vectorbt.signals.nb.generate_ex_nb`.

    ## Example

    Fill all space after signals in `mask`:

    ```python-repl
    &gt;&gt;&gt; @njit
    ... def exit_choice_func_nb(from_i, to_i, col, temp_range):
    ...     return temp_range[from_i:to_i]

    &gt;&gt;&gt; temp_range = np.arange(mask.shape[0])  # reuse memory
    &gt;&gt;&gt; mask.vbt.signals.generate_exits(exit_choice_func_nb, temp_range)
                    a      b      c
    2020-01-01  False  False  False
    2020-01-02   True   True  False
    2020-01-03   True  False  False
    2020-01-04   True   True   True
    2020-01-05   True  False   True
    ```
    &#34;&#34;&#34;
    checks.assert_numba_func(exit_choice_func_nb)

    exits = nb.generate_ex_nb(
        self.to_2d_array(),
        wait,
        until_next,
        skip_until_exit,
        pick_first,
        exit_choice_func_nb,
        *args
    )
    return self.wrapper.wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.generate_ohlc_stop_exits"><code class="name flex">
<span>def <span class="ident child-name">generate_ohlc_stop_exits</span></span>(<span class="params">self, open, high=None, low=None, close=None, is_open_safe=True, out_dict=None, sl_stop=nan, sl_trail=False, tp_stop=nan, reverse=False, entry_wait=1, exit_wait=1, until_next=True, skip_until_exit=False, pick_first=True, chain=False, broadcast_kwargs=None, wrap_kwargs=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Generate exits based on when the price hits (trailing) stop loss or take profit.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>This function is meant for signal analysis. For backtesting, consider using
the stop logic integrated into <code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="../portfolio/base.html#vectorbt.portfolio.base.Portfolio.from_signals">Portfolio.from_signals()</a></code>.</p>
</div>
<p>If any of <code>high</code>, <code>low</code> or <code>close</code> is None, it will be set to <code>open</code>.</p>
<p>Use <code>out_dict</code> as a dict to pass <code>stop_price</code> and <code>stop_type</code> arrays. You can also
set <code>out_dict</code> to {} to produce these arrays automatically and still have access to them.</p>
<p>For arguments, see <code><a title="vectorbt.signals.nb.ohlc_stop_choice_nb" href="nb.html#vectorbt.signals.nb.ohlc_stop_choice_nb">ohlc_stop_choice_nb()</a></code>.
If <code>chain</code> is True, see <code><a title="vectorbt.signals.nb.generate_ohlc_stop_enex_nb" href="nb.html#vectorbt.signals.nb.generate_ohlc_stop_enex_nb">generate_ohlc_stop_enex_nb()</a></code>.
Otherwise, see <code><a title="vectorbt.signals.nb.generate_ohlc_stop_ex_nb" href="nb.html#vectorbt.signals.nb.generate_ohlc_stop_ex_nb">generate_ohlc_stop_ex_nb()</a></code>.</p>
<p>All array-like arguments including stops and <code>out_dict</code> will broadcast using
<code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code> and <code>broadcast_kwargs</code>.</p>
<p>For arguments, see <code><a title="vectorbt.signals.nb.ohlc_stop_choice_nb" href="nb.html#vectorbt.signals.nb.ohlc_stop_choice_nb">ohlc_stop_choice_nb()</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>open</code> isn't necessarily open price, but can be any entry price (even previous close).
Stop price is calculated based solely on the entry price.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Default arguments will generate an exit signal strictly between two entry signals.
If both entry signals are too close to each other, no exit will be generated.</p>
<p>To ignore all entries that come between an entry and its exit,
set <code>until_next</code> to False and <code>skip_until_exit</code> to True.</p>
<p>To remove all entries that come between an entry and its exit,
set <code>chain</code> to True. This will return two arrays: new entries and exits.</p>
</div>
<h2 id="example">Example</h2>
<p>The same example as under <code><a title="vectorbt.signals.nb.generate_ohlc_stop_ex_nb" href="nb.html#vectorbt.signals.nb.generate_ohlc_stop_ex_nb">generate_ohlc_stop_ex_nb()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from vectorbt.signals.enums import StopType

&gt;&gt;&gt; price = pd.DataFrame({
...     'open': [10, 11, 12, 11, 10],
...     'high': [11, 12, 13, 12, 11],
...     'low': [9, 10, 11, 10, 9],
...     'close': [10, 11, 12, 11, 10]
... })
&gt;&gt;&gt; out_dict = {}
&gt;&gt;&gt; exits = mask.vbt.signals.generate_ohlc_stop_exits(
...     price['open'], price['high'], price['low'], price['close'],
...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict)
&gt;&gt;&gt; exits
                a      b      c
2020-01-01  False  False  False
2020-01-02   True   True  False
2020-01-03  False  False  False
2020-01-04  False   True   True
2020-01-05  False  False  False

&gt;&gt;&gt; out_dict['stop_price']
               a     b     c
2020-01-01   NaN   NaN   NaN
2020-01-02  11.0  11.0   NaN
2020-01-03   NaN   NaN   NaN
2020-01-04   NaN  10.8  10.8
2020-01-05   NaN   NaN   NaN

&gt;&gt;&gt; out_dict['stop_type'].vbt(mapping=StopType).apply_mapping()
                     a           b          c
2020-01-01        None        None       None
2020-01-02  TakeProfit  TakeProfit       None
2020-01-03        None        None       None
2020-01-04        None   TrailStop  TrailStop
2020-01-05        None        None       None
</code></pre>
<p>Notice how the first two entry signals in the third column have no exit signal - there is
no room between them for an exit signal. To find an exit for the first entry and ignore all
entries that are in-between them, we can pass <code>until_next=False</code> and <code>skip_until_exit=True</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; out_dict = {}
&gt;&gt;&gt; exits = mask.vbt.signals.generate_ohlc_stop_exits(
...     price['open'], price['high'], price['low'], price['close'],
...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict,
...     until_next=False, skip_until_exit=True)
&gt;&gt;&gt; exits
                a      b      c
2020-01-01  False  False  False
2020-01-02   True   True   True
2020-01-03  False  False  False
2020-01-04  False   True   True
2020-01-05  False  False  False

&gt;&gt;&gt; out_dict['stop_price']
2020-01-01   NaN   NaN   NaN
2020-01-02  11.0  11.0  11.0
2020-01-03   NaN   NaN   NaN
2020-01-04   NaN  10.8  10.8
2020-01-05   NaN   NaN   NaN

&gt;&gt;&gt; out_dict['stop_type'].vbt(mapping=StopType).apply_mapping()
                     a           b           c
2020-01-01        None        None        None
2020-01-02  TakeProfit  TakeProfit  TakeProfit
2020-01-03        None        None        None
2020-01-04        None   TrailStop   TrailStop
2020-01-05        None        None        None
</code></pre>
<p>Now, the first signal in the third column gets executed regardless of the entries that come next,
which is very similar to the logic that is implemented in <code><a title="vectorbt.portfolio.base.Portfolio.from_signals" href="../portfolio/base.html#vectorbt.portfolio.base.Portfolio.from_signals">Portfolio.from_signals()</a></code>.</p>
<p>To automatically remove all ignored entry signals, pass <code>chain=True</code>.
This will return a new entries array:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; out_dict = {}
&gt;&gt;&gt; new_entries, exits = mask.vbt.signals.generate_ohlc_stop_exits(
...     price['open'], price['high'], price['low'], price['close'],
...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict,
...     chain=True)
&gt;&gt;&gt; new_entries
                a      b      c
2020-01-01   True   True   True
2020-01-02  False  False  False  &lt;&lt; removed entry in the third column
2020-01-03  False   True   True
2020-01-04  False  False  False
2020-01-05  False   True  False
&gt;&gt;&gt; exits
                a      b      c
2020-01-01  False  False  False
2020-01-02   True   True   True
2020-01-03  False  False  False
2020-01-04  False   True   True
2020-01-05  False  False  False
</code></pre>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The last two examples above make entries dependent upon exits - this makes only sense
if you have no other exit arrays to combine this stop exit array with.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_ohlc_stop_exits(self,
                             open: tp.ArrayLike,
                             high: tp.Optional[tp.ArrayLike] = None,
                             low: tp.Optional[tp.ArrayLike] = None,
                             close: tp.Optional[tp.ArrayLike] = None,
                             is_open_safe: bool = True,
                             out_dict: tp.Optional[tp.Dict[str, tp.ArrayLike]] = None,
                             sl_stop: tp.ArrayLike = np.nan,
                             sl_trail: tp.ArrayLike = False,
                             tp_stop: tp.ArrayLike = np.nan,
                             reverse: tp.ArrayLike = False,
                             entry_wait: int = 1,
                             exit_wait: int = 1,
                             until_next: bool = True,
                             skip_until_exit: bool = False,
                             pick_first: bool = True,
                             chain: bool = False,
                             broadcast_kwargs: tp.KwargsLike = None,
                             wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeTuple[tp.SeriesFrame]:
    &#34;&#34;&#34;Generate exits based on when the price hits (trailing) stop loss or take profit.

    !!! hint
        This function is meant for signal analysis. For backtesting, consider using
        the stop logic integrated into `vectorbt.portfolio.base.Portfolio.from_signals`.

    If any of `high`, `low` or `close` is None, it will be set to `open`.

    Use `out_dict` as a dict to pass `stop_price` and `stop_type` arrays. You can also
    set `out_dict` to {} to produce these arrays automatically and still have access to them.

    For arguments, see `vectorbt.signals.nb.ohlc_stop_choice_nb`.
    If `chain` is True, see `vectorbt.signals.nb.generate_ohlc_stop_enex_nb`.
    Otherwise, see `vectorbt.signals.nb.generate_ohlc_stop_ex_nb`.

    All array-like arguments including stops and `out_dict` will broadcast using
    `vectorbt.base.reshape_fns.broadcast` and `broadcast_kwargs`.

    For arguments, see `vectorbt.signals.nb.ohlc_stop_choice_nb`.

    !!! note
        `open` isn&#39;t necessarily open price, but can be any entry price (even previous close).
        Stop price is calculated based solely on the entry price.

    !!! hint
        Default arguments will generate an exit signal strictly between two entry signals.
        If both entry signals are too close to each other, no exit will be generated.

        To ignore all entries that come between an entry and its exit,
        set `until_next` to False and `skip_until_exit` to True.

        To remove all entries that come between an entry and its exit,
        set `chain` to True. This will return two arrays: new entries and exits.

    ## Example

    The same example as under `vectorbt.signals.nb.generate_ohlc_stop_ex_nb`:

    ```python-repl
    &gt;&gt;&gt; from vectorbt.signals.enums import StopType

    &gt;&gt;&gt; price = pd.DataFrame({
    ...     &#39;open&#39;: [10, 11, 12, 11, 10],
    ...     &#39;high&#39;: [11, 12, 13, 12, 11],
    ...     &#39;low&#39;: [9, 10, 11, 10, 9],
    ...     &#39;close&#39;: [10, 11, 12, 11, 10]
    ... })
    &gt;&gt;&gt; out_dict = {}
    &gt;&gt;&gt; exits = mask.vbt.signals.generate_ohlc_stop_exits(
    ...     price[&#39;open&#39;], price[&#39;high&#39;], price[&#39;low&#39;], price[&#39;close&#39;],
    ...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict)
    &gt;&gt;&gt; exits
                    a      b      c
    2020-01-01  False  False  False
    2020-01-02   True   True  False
    2020-01-03  False  False  False
    2020-01-04  False   True   True
    2020-01-05  False  False  False

    &gt;&gt;&gt; out_dict[&#39;stop_price&#39;]
                   a     b     c
    2020-01-01   NaN   NaN   NaN
    2020-01-02  11.0  11.0   NaN
    2020-01-03   NaN   NaN   NaN
    2020-01-04   NaN  10.8  10.8
    2020-01-05   NaN   NaN   NaN

    &gt;&gt;&gt; out_dict[&#39;stop_type&#39;].vbt(mapping=StopType).apply_mapping()
                         a           b          c
    2020-01-01        None        None       None
    2020-01-02  TakeProfit  TakeProfit       None
    2020-01-03        None        None       None
    2020-01-04        None   TrailStop  TrailStop
    2020-01-05        None        None       None
    ```

    Notice how the first two entry signals in the third column have no exit signal - there is
    no room between them for an exit signal. To find an exit for the first entry and ignore all
    entries that are in-between them, we can pass `until_next=False` and `skip_until_exit=True`:

    ```python-repl
    &gt;&gt;&gt; out_dict = {}
    &gt;&gt;&gt; exits = mask.vbt.signals.generate_ohlc_stop_exits(
    ...     price[&#39;open&#39;], price[&#39;high&#39;], price[&#39;low&#39;], price[&#39;close&#39;],
    ...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict,
    ...     until_next=False, skip_until_exit=True)
    &gt;&gt;&gt; exits
                    a      b      c
    2020-01-01  False  False  False
    2020-01-02   True   True   True
    2020-01-03  False  False  False
    2020-01-04  False   True   True
    2020-01-05  False  False  False

    &gt;&gt;&gt; out_dict[&#39;stop_price&#39;]
    2020-01-01   NaN   NaN   NaN
    2020-01-02  11.0  11.0  11.0
    2020-01-03   NaN   NaN   NaN
    2020-01-04   NaN  10.8  10.8
    2020-01-05   NaN   NaN   NaN

    &gt;&gt;&gt; out_dict[&#39;stop_type&#39;].vbt(mapping=StopType).apply_mapping()
                         a           b           c
    2020-01-01        None        None        None
    2020-01-02  TakeProfit  TakeProfit  TakeProfit
    2020-01-03        None        None        None
    2020-01-04        None   TrailStop   TrailStop
    2020-01-05        None        None        None
    ```

    Now, the first signal in the third column gets executed regardless of the entries that come next,
    which is very similar to the logic that is implemented in `vectorbt.portfolio.base.Portfolio.from_signals`.

    To automatically remove all ignored entry signals, pass `chain=True`.
    This will return a new entries array:

    ```python-repl
    &gt;&gt;&gt; out_dict = {}
    &gt;&gt;&gt; new_entries, exits = mask.vbt.signals.generate_ohlc_stop_exits(
    ...     price[&#39;open&#39;], price[&#39;high&#39;], price[&#39;low&#39;], price[&#39;close&#39;],
    ...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict,
    ...     chain=True)
    &gt;&gt;&gt; new_entries
                    a      b      c
    2020-01-01   True   True   True
    2020-01-02  False  False  False  &lt;&lt; removed entry in the third column
    2020-01-03  False   True   True
    2020-01-04  False  False  False
    2020-01-05  False   True  False
    &gt;&gt;&gt; exits
                    a      b      c
    2020-01-01  False  False  False
    2020-01-02   True   True   True
    2020-01-03  False  False  False
    2020-01-04  False   True   True
    2020-01-05  False  False  False
    ```

    !!! warning
        The last two examples above make entries dependent upon exits - this makes only sense
        if you have no other exit arrays to combine this stop exit array with.
    &#34;&#34;&#34;
    if broadcast_kwargs is None:
        broadcast_kwargs = {}
    entries = self.obj
    if high is None:
        high = open
    if low is None:
        low = open
    if close is None:
        close = open
    if out_dict is None:
        out_dict_passed = False
        out_dict = {}
    else:
        out_dict_passed = True
    stop_price_out = out_dict.get(&#39;stop_price&#39;, np.nan if out_dict_passed else None)
    stop_type_out = out_dict.get(&#39;stop_type&#39;, -1 if out_dict_passed else None)
    out_args = ()
    if stop_price_out is not None:
        out_args += (stop_price_out,)
    if stop_type_out is not None:
        out_args += (stop_type_out,)

    keep_raw = (False, True, True, True, True, True, True, True, True) + (False,) * len(out_args)
    broadcast_kwargs = merge_dicts(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
    entries, open, high, low, close, sl_stop, sl_trail, tp_stop, reverse, *out_args = reshape_fns.broadcast(
        entries, open, high, low, close, sl_stop, sl_trail, tp_stop, reverse, *out_args,
        **broadcast_kwargs, keep_raw=keep_raw)
    if stop_price_out is None:
        stop_price_out = np.empty_like(entries, dtype=np.float_)
    else:
        stop_price_out = out_args[0]
        out_args = out_args[1:]
    if stop_type_out is None:
        stop_type_out = np.empty_like(entries, dtype=np.int_)
    else:
        stop_type_out = out_args[0]
    stop_price_out = reshape_fns.to_2d_array(stop_price_out)
    stop_type_out = reshape_fns.to_2d_array(stop_type_out)

    # Perform generation
    if chain:
        new_entries, exits = nb.generate_ohlc_stop_enex_nb(
            reshape_fns.to_2d_array(entries),
            open,
            high,
            low,
            close,
            stop_price_out,
            stop_type_out,
            sl_stop,
            sl_trail,
            tp_stop,
            reverse,
            is_open_safe,
            entry_wait,
            exit_wait,
            pick_first,
            entries.ndim == 2
        )
        out_dict[&#39;stop_price&#39;] = ArrayWrapper.from_obj(entries).wrap(
            stop_price_out, group_by=False, **merge_dicts({}, wrap_kwargs))
        out_dict[&#39;stop_type&#39;] = ArrayWrapper.from_obj(entries).wrap(
            stop_type_out, group_by=False, **merge_dicts({}, wrap_kwargs))
        return ArrayWrapper.from_obj(entries).wrap(new_entries, group_by=False, **merge_dicts({}, wrap_kwargs)), \
               ArrayWrapper.from_obj(entries).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))
    else:
        if skip_until_exit and until_next:
            warnings.warn(&#34;skip_until_exit=True has only effect when until_next=False&#34;, stacklevel=2)
        exits = nb.generate_ohlc_stop_ex_nb(
            reshape_fns.to_2d_array(entries),
            open,
            high,
            low,
            close,
            stop_price_out,
            stop_type_out,
            sl_stop,
            sl_trail,
            tp_stop,
            reverse,
            is_open_safe,
            exit_wait,
            until_next,
            skip_until_exit,
            pick_first,
            entries.ndim == 2
        )
        out_dict[&#39;stop_price&#39;] = ArrayWrapper.from_obj(entries).wrap(
            stop_price_out, group_by=False, **merge_dicts({}, wrap_kwargs))
        out_dict[&#39;stop_type&#39;] = ArrayWrapper.from_obj(entries).wrap(
            stop_type_out, group_by=False, **merge_dicts({}, wrap_kwargs))
        return ArrayWrapper.from_obj(entries).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.generate_random_exits"><code class="name flex">
<span>def <span class="ident child-name">generate_random_exits</span></span>(<span class="params">self, prob=None, seed=None, wait=1, until_next=True, skip_until_exit=False, wrap_kwargs=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Generate exit signals randomly.</p>
<p>If <code>prob</code> is None, see <code><a title="vectorbt.signals.nb.generate_rand_ex_nb" href="nb.html#vectorbt.signals.nb.generate_rand_ex_nb">generate_rand_ex_nb()</a></code>.
Otherwise, see <code><a title="vectorbt.signals.nb.generate_rand_ex_by_prob_nb" href="nb.html#vectorbt.signals.nb.generate_rand_ex_by_prob_nb">generate_rand_ex_by_prob_nb()</a></code>.</p>
<h2 id="example">Example</h2>
<p>After each entry in <code>mask</code>, generate exactly one exit:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask.vbt.signals.generate_random_exits(seed=42)
                a      b      c
2020-01-01  False  False  False
2020-01-02  False   True  False
2020-01-03   True  False  False
2020-01-04  False   True  False
2020-01-05  False  False   True
</code></pre>
<p>After each entry in <code>mask</code> and at each time step, generate exit with 50% probability:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask.vbt.signals.generate_random_exits(prob=0.5, seed=42)
                a      b      c
2020-01-01  False  False  False
2020-01-02   True  False  False
2020-01-03  False  False  False
2020-01-04  False  False  False
2020-01-05  False  False   True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_random_exits(self,
                          prob: tp.Optional[tp.ArrayLike] = None,
                          seed: tp.Optional[int] = None,
                          wait: int = 1,
                          until_next: bool = True,
                          skip_until_exit: bool = False,
                          wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Generate exit signals randomly.

    If `prob` is None, see `vectorbt.signals.nb.generate_rand_ex_nb`.
    Otherwise, see `vectorbt.signals.nb.generate_rand_ex_by_prob_nb`.

    ## Example

    After each entry in `mask`, generate exactly one exit:

    ```python-repl
    &gt;&gt;&gt; mask.vbt.signals.generate_random_exits(seed=42)
                    a      b      c
    2020-01-01  False  False  False
    2020-01-02  False   True  False
    2020-01-03   True  False  False
    2020-01-04  False   True  False
    2020-01-05  False  False   True
    ```

    After each entry in `mask` and at each time step, generate exit with 50% probability:

    ```python-repl
    &gt;&gt;&gt; mask.vbt.signals.generate_random_exits(prob=0.5, seed=42)
                    a      b      c
    2020-01-01  False  False  False
    2020-01-02   True  False  False
    2020-01-03  False  False  False
    2020-01-04  False  False  False
    2020-01-05  False  False   True
    ```
    &#34;&#34;&#34;
    if prob is not None:
        obj, prob = reshape_fns.broadcast(self.obj, prob, keep_raw=[False, True])
        exits = nb.generate_rand_ex_by_prob_nb(
            reshape_fns.to_2d_array(obj),
            prob,
            wait,
            until_next,
            skip_until_exit,
            obj.ndim == 2,
            seed=seed
        )
        return ArrayWrapper.from_obj(obj).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))
    exits = nb.generate_rand_ex_nb(
        self.to_2d_array(),
        wait,
        until_next,
        skip_until_exit,
        seed=seed
    )
    return self.wrapper.wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.generate_stop_exits"><code class="name flex">
<span>def <span class="ident child-name">generate_stop_exits</span></span>(<span class="params">self, ts, stop, trailing=False, entry_wait=1, exit_wait=1, until_next=True, skip_until_exit=False, pick_first=True, chain=False, broadcast_kwargs=None, wrap_kwargs=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Generate exits based on when <code>ts</code> hits the stop.</p>
<p>For arguments, see <code><a title="vectorbt.signals.nb.stop_choice_nb" href="nb.html#vectorbt.signals.nb.stop_choice_nb">stop_choice_nb()</a></code>.
If <code>chain</code> is True, see <code><a title="vectorbt.signals.nb.generate_stop_enex_nb" href="nb.html#vectorbt.signals.nb.generate_stop_enex_nb">generate_stop_enex_nb()</a></code>.
Otherwise, see <code><a title="vectorbt.signals.nb.generate_stop_ex_nb" href="nb.html#vectorbt.signals.nb.generate_stop_ex_nb">generate_stop_ex_nb()</a></code>.</p>
<p>Arguments <code>entries</code>, <code>ts</code> and <code>stop</code> will broadcast using <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code>
and <code>broadcast_kwargs</code>.</p>
<p>For arguments, see <code><a title="vectorbt.signals.nb.stop_choice_nb" href="nb.html#vectorbt.signals.nb.stop_choice_nb">stop_choice_nb()</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Default arguments will generate an exit signal strictly between two entry signals.
If both entry signals are too close to each other, no exit will be generated.</p>
<p>To ignore all entries that come between an entry and its exit,
set <code>until_next</code> to False and <code>skip_until_exit</code> to True.</p>
<p>To remove all entries that come between an entry and its exit,
set <code>chain</code> to True. This will return two arrays: new entries and exits.</p>
</div>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1])

&gt;&gt;&gt; # stop loss
&gt;&gt;&gt; mask.vbt.signals.generate_stop_exits(ts, -0.1)
                a      b      c
2020-01-01  False  False  False
2020-01-02  False  False  False
2020-01-03  False  False  False
2020-01-04  False   True   True
2020-01-05  False  False  False

&gt;&gt;&gt; # trailing stop loss
&gt;&gt;&gt; mask.vbt.signals.generate_stop_exits(ts, -0.1, trailing=True)
                a      b      c
2020-01-01  False  False  False
2020-01-02  False  False  False
2020-01-03  False  False  False
2020-01-04   True   True   True
2020-01-05  False  False  False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_stop_exits(self,
                        ts: tp.ArrayLike,
                        stop: tp.ArrayLike,
                        trailing: tp.ArrayLike = False,
                        entry_wait: int = 1,
                        exit_wait: int = 1,
                        until_next: bool = True,
                        skip_until_exit: bool = False,
                        pick_first: bool = True,
                        chain: bool = False,
                        broadcast_kwargs: tp.KwargsLike = None,
                        wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeTuple[tp.SeriesFrame]:
    &#34;&#34;&#34;Generate exits based on when `ts` hits the stop.

    For arguments, see `vectorbt.signals.nb.stop_choice_nb`.
    If `chain` is True, see `vectorbt.signals.nb.generate_stop_enex_nb`.
    Otherwise, see `vectorbt.signals.nb.generate_stop_ex_nb`.

    Arguments `entries`, `ts` and `stop` will broadcast using `vectorbt.base.reshape_fns.broadcast`
    and `broadcast_kwargs`.

    For arguments, see `vectorbt.signals.nb.stop_choice_nb`.

    !!! hint
        Default arguments will generate an exit signal strictly between two entry signals.
        If both entry signals are too close to each other, no exit will be generated.

        To ignore all entries that come between an entry and its exit,
        set `until_next` to False and `skip_until_exit` to True.

        To remove all entries that come between an entry and its exit,
        set `chain` to True. This will return two arrays: new entries and exits.

    ## Example

    ```python-repl
    &gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1])

    &gt;&gt;&gt; # stop loss
    &gt;&gt;&gt; mask.vbt.signals.generate_stop_exits(ts, -0.1)
                    a      b      c
    2020-01-01  False  False  False
    2020-01-02  False  False  False
    2020-01-03  False  False  False
    2020-01-04  False   True   True
    2020-01-05  False  False  False

    &gt;&gt;&gt; # trailing stop loss
    &gt;&gt;&gt; mask.vbt.signals.generate_stop_exits(ts, -0.1, trailing=True)
                    a      b      c
    2020-01-01  False  False  False
    2020-01-02  False  False  False
    2020-01-03  False  False  False
    2020-01-04   True   True   True
    2020-01-05  False  False  False
    ```
    &#34;&#34;&#34;
    if broadcast_kwargs is None:
        broadcast_kwargs = {}
    entries = self.obj

    keep_raw = (False, True, True, True)
    broadcast_kwargs = merge_dicts(dict(require_kwargs=dict(requirements=&#39;W&#39;)), broadcast_kwargs)
    entries, ts, stop, trailing = reshape_fns.broadcast(
        entries, ts, stop, trailing, **broadcast_kwargs, keep_raw=keep_raw)

    # Perform generation
    if chain:
        new_entries, exits = nb.generate_stop_enex_nb(
            reshape_fns.to_2d_array(entries),
            ts,
            stop,
            trailing,
            entry_wait,
            exit_wait,
            pick_first,
            entries.ndim == 2
        )
        return ArrayWrapper.from_obj(entries).wrap(new_entries, group_by=False, **merge_dicts({}, wrap_kwargs)), \
               ArrayWrapper.from_obj(entries).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))
    else:
        if skip_until_exit and until_next:
            warnings.warn(&#34;skip_until_exit=True has only effect when until_next=False&#34;, stacklevel=2)
        exits = nb.generate_stop_ex_nb(
            reshape_fns.to_2d_array(entries),
            ts,
            stop,
            trailing,
            exit_wait,
            until_next,
            skip_until_exit,
            pick_first,
            entries.ndim == 2
        )
        return ArrayWrapper.from_obj(entries).wrap(exits, group_by=False, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.index_mapped"><code class="name flex">
<span>def <span class="ident child-name">index_mapped</span></span>(<span class="params">self, group_by=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get a mapped array of indices.</p>
<p>See <code><a title="vectorbt.generic.accessors.GenericAccessor.to_mapped" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.to_mapped">GenericAccessor.to_mapped()</a></code>.</p>
<p>Only True values will be considered.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_mapped(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; MappedArray:
    &#34;&#34;&#34;Get a mapped array of indices.

    See `vectorbt.generic.accessors.GenericAccessor.to_mapped`.

    Only True values will be considered.&#34;&#34;&#34;
    indices = np.arange(len(self.wrapper.index), dtype=np.float_)[:, None]
    indices = np.tile(indices, (1, len(self.wrapper.columns)))
    indices = reshape_fns.soft_to_ndim(indices, self.wrapper.ndim)
    indices[~self.obj.values] = np.nan
    return self.wrapper.wrap(indices).vbt.to_mapped(
        dropna=True,
        dtype=np.int_,
        group_by=group_by,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.norm_avg_index"><code class="name flex">
<span>def <span class="ident child-name">norm_avg_index</span></span>(<span class="params">self, group_by=None, wrap_kwargs=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.signals.nb.norm_avg_index_nb" href="nb.html#vectorbt.signals.nb.norm_avg_index_nb">norm_avg_index_nb()</a></code>.</p>
<p>Normalized average index measures the average signal location relative to the middle of the column.
This way, we can quickly see where the majority of signals are located.</p>
<p>Common values are:</p>
<ul>
<li>-1.0: only the first signal is set</li>
<li>1.0: only the last signal is set</li>
<li>0.0: symmetric distribution around the middle</li>
<li>[-1.0, 0.0): average signal is on the left</li>
<li>(0.0, 1.0]: average signal is on the right</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; pd.Series([True, False, False, False]).vbt.signals.norm_avg_index()
-1.0

&gt;&gt;&gt; pd.Series([False, False, False, True]).vbt.signals.norm_avg_index()
1.0

&gt;&gt;&gt; pd.Series([True, False, False, True]).vbt.signals.norm_avg_index()
0.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def norm_avg_index(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;See `vectorbt.signals.nb.norm_avg_index_nb`.

    Normalized average index measures the average signal location relative to the middle of the column.
    This way, we can quickly see where the majority of signals are located.

    Common values are:

    * -1.0: only the first signal is set
    * 1.0: only the last signal is set
    * 0.0: symmetric distribution around the middle
    * [-1.0, 0.0): average signal is on the left
    * (0.0, 1.0]: average signal is on the right

    ## Example

    ```python-repl
    &gt;&gt;&gt; pd.Series([True, False, False, False]).vbt.signals.norm_avg_index()
    -1.0

    &gt;&gt;&gt; pd.Series([False, False, False, True]).vbt.signals.norm_avg_index()
    1.0

    &gt;&gt;&gt; pd.Series([True, False, False, True]).vbt.signals.norm_avg_index()
    0.0
    ```&#34;&#34;&#34;
    norm_avg_index = nb.norm_avg_index_nb(self.to_2d_array())
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;norm_avg_index&#39;), wrap_kwargs)
    norm_avg_index = self.wrapper.wrap_reduced(norm_avg_index, group_by=False, **wrap_kwargs)
    if self.is_frame() and self.wrapper.grouper.is_grouped(group_by=group_by):
        # Group index is a weighted average of column indexes in the group
        if group_by is None:
            group_by = self.wrapper.grouper.group_by
        col_total = self.total(group_by=False)
        norm_avg_index *= col_total
        norm_avg_index = norm_avg_index.vbt.squeeze_grouped(
            generic_nb.sum_squeeze_nb, group_by=group_by)
        group_total = col_total.vbt.squeeze_grouped(
            generic_nb.sum_squeeze_nb, group_by=group_by)
        norm_avg_index /= group_total
    return norm_avg_index</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.nth"><code class="name flex">
<span>def <span class="ident child-name">nth</span></span>(<span class="params">self, n, wrap_kwargs=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Select signals that satisfy the condition <code>pos_rank == n</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nth(self, n: int, wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Select signals that satisfy the condition `pos_rank == n`.&#34;&#34;&#34;
    pos_rank = self.pos_rank(**kwargs).values
    return self.wrapper.wrap(pos_rank == n, group_by=False, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.nth_index"><code class="name flex">
<span>def <span class="ident child-name">nth_index</span></span>(<span class="params">self, n, return_labels=True, group_by=None, wrap_kwargs=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.signals.nb.nth_index_nb" href="nb.html#vectorbt.signals.nb.nth_index_nb">nth_index_nb()</a></code>.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask.vbt.signals.nth_index(0)
a   2020-01-01
b   2020-01-01
c   2020-01-01
Name: nth_index, dtype: datetime64[ns]

&gt;&gt;&gt; mask.vbt.signals.nth_index(2)
a          NaT
b   2020-01-05
c   2020-01-03
Name: nth_index, dtype: datetime64[ns]

&gt;&gt;&gt; mask.vbt.signals.nth_index(-1)
a   2020-01-01
b   2020-01-05
c   2020-01-03
Name: nth_index, dtype: datetime64[ns]

&gt;&gt;&gt; mask.vbt.signals.nth_index(-1, group_by=True)
Timestamp('2020-01-05 00:00:00')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nth_index(self, n: int, return_labels: bool = True, group_by: tp.GroupByLike = None,
              wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;See `vectorbt.signals.nb.nth_index_nb`.

    ## Example

    ```python-repl
    &gt;&gt;&gt; mask.vbt.signals.nth_index(0)
    a   2020-01-01
    b   2020-01-01
    c   2020-01-01
    Name: nth_index, dtype: datetime64[ns]

    &gt;&gt;&gt; mask.vbt.signals.nth_index(2)
    a          NaT
    b   2020-01-05
    c   2020-01-03
    Name: nth_index, dtype: datetime64[ns]

    &gt;&gt;&gt; mask.vbt.signals.nth_index(-1)
    a   2020-01-01
    b   2020-01-05
    c   2020-01-03
    Name: nth_index, dtype: datetime64[ns]

    &gt;&gt;&gt; mask.vbt.signals.nth_index(-1, group_by=True)
    Timestamp(&#39;2020-01-05 00:00:00&#39;)
    ```&#34;&#34;&#34;
    if self.is_frame() and self.wrapper.grouper.is_grouped(group_by=group_by):
        squeezed = self.squeeze_grouped(generic_nb.any_squeeze_nb, group_by=group_by)
        arr = reshape_fns.to_2d_array(squeezed)
    else:
        arr = self.to_2d_array()
    nth_index = nb.nth_index_nb(arr, n)
    if return_labels:
        minus_one_mask = nth_index == -1
        nth_index = nth_index.astype(object)
        nth_index[minus_one_mask] = np.nan
        nth_index[~minus_one_mask] = self.wrapper.index[nth_index[~minus_one_mask].astype(np.int_)]
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;nth_index&#39;), wrap_kwargs)
    return self.wrapper.wrap_reduced(nth_index, group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank"><code class="name flex">
<span>def <span class="ident child-name">partition_pos_rank</span></span>(<span class="params">self, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get partition position ranks.</p>
<p>Uses <code><a title="vectorbt.signals.accessors.SignalsAccessor.rank" href="#vectorbt.signals.accessors.SignalsAccessor.rank">SignalsAccessor.rank()</a></code> with <code><a title="vectorbt.signals.nb.part_pos_rank_nb" href="nb.html#vectorbt.signals.nb.part_pos_rank_nb">part_pos_rank_nb()</a></code>.</p>
<h2 id="example">Example</h2>
<p>Rank each partition of True values in <code>mask</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask.vbt.signals.partition_pos_rank()
            a  b  c
2020-01-01  0  0  0
2020-01-02 -1 -1  0
2020-01-03 -1  1  0
2020-01-04 -1 -1 -1
2020-01-05 -1  2 -1

&gt;&gt;&gt; mask.vbt.signals.partition_pos_rank(after_false=True)
            a  b  c
2020-01-01 -1 -1 -1
2020-01-02 -1 -1 -1
2020-01-03 -1  0 -1
2020-01-04 -1 -1 -1
2020-01-05 -1  1 -1

&gt;&gt;&gt; mask.vbt.signals.partition_pos_rank(reset_by=mask)
            a  b  c
2020-01-01  0  0  0
2020-01-02 -1 -1  0
2020-01-03 -1  0  0
2020-01-04 -1 -1 -1
2020-01-05 -1  0 -1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition_pos_rank(self, **kwargs) -&gt; tp.Union[tp.SeriesFrame, MappedArray]:
    &#34;&#34;&#34;Get partition position ranks.

    Uses `SignalsAccessor.rank` with `vectorbt.signals.nb.part_pos_rank_nb`.

    ## Example

    Rank each partition of True values in `mask`:

    ```python-repl
    &gt;&gt;&gt; mask.vbt.signals.partition_pos_rank()
                a  b  c
    2020-01-01  0  0  0
    2020-01-02 -1 -1  0
    2020-01-03 -1  1  0
    2020-01-04 -1 -1 -1
    2020-01-05 -1  2 -1

    &gt;&gt;&gt; mask.vbt.signals.partition_pos_rank(after_false=True)
                a  b  c
    2020-01-01 -1 -1 -1
    2020-01-02 -1 -1 -1
    2020-01-03 -1  0 -1
    2020-01-04 -1 -1 -1
    2020-01-05 -1  1 -1

    &gt;&gt;&gt; mask.vbt.signals.partition_pos_rank(reset_by=mask)
                a  b  c
    2020-01-01  0  0  0
    2020-01-02 -1 -1  0
    2020-01-03 -1  0  0
    2020-01-04 -1 -1 -1
    2020-01-05 -1  0 -1
    ```
    &#34;&#34;&#34;
    prepare_func = lambda obj, reset_by: (np.full(obj.shape[1], -1, dtype=np.int_),)
    return self.rank(
        nb.part_pos_rank_nb,
        prepare_func=prepare_func,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank_mapped"><code class="name flex">
<span>def <span class="ident child-name">partition_pos_rank_mapped</span></span>(<span class="params">self, group_by=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get a mapped array of partition position ranks.</p>
<p>See <code><a title="vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank" href="#vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank">SignalsAccessor.partition_pos_rank()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition_pos_rank_mapped(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; MappedArray:
    &#34;&#34;&#34;Get a mapped array of partition position ranks.

    See `SignalsAccessor.partition_pos_rank`.&#34;&#34;&#34;
    return self.partition_pos_rank(as_mapped=True, group_by=group_by, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.partition_ranges"><code class="name flex">
<span>def <span class="ident child-name">partition_ranges</span></span>(<span class="params">self, group_by=None, attach_ts=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Wrap the result of <code><a title="vectorbt.signals.nb.partition_ranges_nb" href="nb.html#vectorbt.signals.nb.partition_ranges_nb">partition_ranges_nb()</a></code>
with <code><a title="vectorbt.generic.ranges.Ranges" href="../generic/ranges.html#vectorbt.generic.ranges.Ranges">Ranges</a></code>.</p>
<p>If <code>use_end_idxs</code> is True, uses the index of the last signal in each partition as <code>idx_arr</code>.
Otherwise, uses the index of the first signal.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask_sr = pd.Series([True, True, True, False, True, True])
&gt;&gt;&gt; mask_sr.vbt.signals.partition_ranges().records_readable
   Range Id  Column  Start Timestamp  End Timestamp  Status
0         0       0                0              3  Closed
1         1       0                4              5    Open
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition_ranges(self, group_by: tp.GroupByLike = None, attach_ts: bool = True, **kwargs) -&gt; Ranges:
    &#34;&#34;&#34;Wrap the result of `vectorbt.signals.nb.partition_ranges_nb`
    with `vectorbt.generic.ranges.Ranges`.

    If `use_end_idxs` is True, uses the index of the last signal in each partition as `idx_arr`.
    Otherwise, uses the index of the first signal.

    ## Example

    ```python-repl
    &gt;&gt;&gt; mask_sr = pd.Series([True, True, True, False, True, True])
    &gt;&gt;&gt; mask_sr.vbt.signals.partition_ranges().records_readable
       Range Id  Column  Start Timestamp  End Timestamp  Status
    0         0       0                0              3  Closed
    1         1       0                4              5    Open
    ```&#34;&#34;&#34;
    range_records = nb.partition_ranges_nb(self.to_2d_array())
    return Ranges(
        self.wrapper,
        range_records,
        ts=self.obj if attach_ts else None,
        **kwargs
    ).regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.partition_rate"><code class="name flex">
<span>def <span class="ident child-name">partition_rate</span></span>(<span class="params">self, wrap_kwargs=None, group_by=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.signals.accessors.SignalsAccessor.total_partitions" href="#vectorbt.signals.accessors.SignalsAccessor.total_partitions">SignalsAccessor.total_partitions()</a></code> divided by <code><a title="vectorbt.signals.accessors.SignalsAccessor.total" href="#vectorbt.signals.accessors.SignalsAccessor.total">SignalsAccessor.total()</a></code> in each column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition_rate(self, wrap_kwargs: tp.KwargsLike = None,
                   group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;`SignalsAccessor.total_partitions` divided by `SignalsAccessor.total` in each column/group.&#34;&#34;&#34;
    total_partitions = reshape_fns.to_1d_array(self.total_partitions(group_by=group_by, *kwargs))
    total = reshape_fns.to_1d_array(self.total(group_by=group_by, *kwargs))
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;partition_rate&#39;), wrap_kwargs)
    return self.wrapper.wrap_reduced(total_partitions / total, group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.plot"><code class="name flex">
<span>def <span class="ident child-name">plot</span></span>(<span class="params">self, yref='y', **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Plot signals.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.generic.accessors.GenericAccessor.lineplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.lineplot">GenericAccessor.lineplot()</a></code>.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask[['a', 'c']].vbt.signals.plot()
</code></pre>
<p><img alt="" src="/docs/img/signals_df_plot.svg"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, yref: str = &#39;y&#39;, **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
    &#34;&#34;&#34;Plot signals.

    Args:
        yref (str): Y coordinate axis.
        **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.lineplot`.

    ## Example

    ```python-repl
    &gt;&gt;&gt; mask[[&#39;a&#39;, &#39;c&#39;]].vbt.signals.plot()
    ```

    ![](/docs/img/signals_df_plot.svg)
    &#34;&#34;&#34;
    default_layout = dict()
    default_layout[&#39;yaxis&#39; + yref[1:]] = dict(
        tickmode=&#39;array&#39;,
        tickvals=[0, 1],
        ticktext=[&#39;false&#39;, &#39;true&#39;]
    )
    return self.obj.vbt.lineplot(**merge_dicts(default_layout, kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.pos_rank"><code class="name flex">
<span>def <span class="ident child-name">pos_rank</span></span>(<span class="params">self, allow_gaps=False, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get signal position ranks.</p>
<p>Uses <code><a title="vectorbt.signals.accessors.SignalsAccessor.rank" href="#vectorbt.signals.accessors.SignalsAccessor.rank">SignalsAccessor.rank()</a></code> with <code><a title="vectorbt.signals.nb.sig_pos_rank_nb" href="nb.html#vectorbt.signals.nb.sig_pos_rank_nb">sig_pos_rank_nb()</a></code>.</p>
<h2 id="example">Example</h2>
<p>Rank each True value in each partition in <code>mask</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask.vbt.signals.pos_rank()
            a  b  c
2020-01-01  0  0  0
2020-01-02 -1 -1  1
2020-01-03 -1  0  2
2020-01-04 -1 -1 -1
2020-01-05 -1  0 -1

&gt;&gt;&gt; mask.vbt.signals.pos_rank(after_false=True)
            a  b  c
2020-01-01 -1 -1 -1
2020-01-02 -1 -1 -1
2020-01-03 -1  0 -1
2020-01-04 -1 -1 -1
2020-01-05 -1  0 -1

&gt;&gt;&gt; mask.vbt.signals.pos_rank(allow_gaps=True)
            a  b  c
2020-01-01  0  0  0
2020-01-02 -1 -1  1
2020-01-03 -1  1  2
2020-01-04 -1 -1 -1
2020-01-05 -1  2 -1

&gt;&gt;&gt; mask.vbt.signals.pos_rank(reset_by=~mask, allow_gaps=True)
            a  b  c
2020-01-01  0  0  0
2020-01-02 -1 -1  1
2020-01-03 -1  0  2
2020-01-04 -1 -1 -1
2020-01-05 -1  0 -1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pos_rank(self, allow_gaps: bool = False, **kwargs) -&gt; tp.Union[tp.SeriesFrame, MappedArray]:
    &#34;&#34;&#34;Get signal position ranks.

    Uses `SignalsAccessor.rank` with `vectorbt.signals.nb.sig_pos_rank_nb`.

    ## Example

    Rank each True value in each partition in `mask`:

    ```python-repl
    &gt;&gt;&gt; mask.vbt.signals.pos_rank()
                a  b  c
    2020-01-01  0  0  0
    2020-01-02 -1 -1  1
    2020-01-03 -1  0  2
    2020-01-04 -1 -1 -1
    2020-01-05 -1  0 -1

    &gt;&gt;&gt; mask.vbt.signals.pos_rank(after_false=True)
                a  b  c
    2020-01-01 -1 -1 -1
    2020-01-02 -1 -1 -1
    2020-01-03 -1  0 -1
    2020-01-04 -1 -1 -1
    2020-01-05 -1  0 -1

    &gt;&gt;&gt; mask.vbt.signals.pos_rank(allow_gaps=True)
                a  b  c
    2020-01-01  0  0  0
    2020-01-02 -1 -1  1
    2020-01-03 -1  1  2
    2020-01-04 -1 -1 -1
    2020-01-05 -1  2 -1

    &gt;&gt;&gt; mask.vbt.signals.pos_rank(reset_by=~mask, allow_gaps=True)
                a  b  c
    2020-01-01  0  0  0
    2020-01-02 -1 -1  1
    2020-01-03 -1  0  2
    2020-01-04 -1 -1 -1
    2020-01-05 -1  0 -1
    ```
    &#34;&#34;&#34;
    prepare_func = lambda obj, reset_by: (np.full(obj.shape[1], -1, dtype=np.int_),)
    return self.rank(
        nb.sig_pos_rank_nb,
        allow_gaps,
        prepare_func=prepare_func,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.pos_rank_mapped"><code class="name flex">
<span>def <span class="ident child-name">pos_rank_mapped</span></span>(<span class="params">self, group_by=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get a mapped array of signal position ranks.</p>
<p>See <code><a title="vectorbt.signals.accessors.SignalsAccessor.pos_rank" href="#vectorbt.signals.accessors.SignalsAccessor.pos_rank">SignalsAccessor.pos_rank()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pos_rank_mapped(self, group_by: tp.GroupByLike = None, **kwargs) -&gt; MappedArray:
    &#34;&#34;&#34;Get a mapped array of signal position ranks.

    See `SignalsAccessor.pos_rank`.&#34;&#34;&#34;
    return self.pos_rank(as_mapped=True, group_by=group_by, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.rank"><code class="name flex">
<span>def <span class="ident child-name">rank</span></span>(<span class="params">self, rank_func_nb, *args, prepare_func=None, reset_by=None, after_false=False, broadcast_kwargs=None, wrap_kwargs=None, as_mapped=False, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.signals.nb.rank_nb" href="nb.html#vectorbt.signals.nb.rank_nb">rank_nb()</a></code>.</p>
<p>Will broadcast with <code>reset_by</code> using <code><a title="vectorbt.base.reshape_fns.broadcast" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.broadcast">broadcast()</a></code> and <code>broadcast_kwargs</code>.</p>
<p>Use <code>prepare_func</code> to prepare further arguments to be passed before <code>*args</code>, such as temporary arrays.
It should take both broadcasted arrays (<code>reset_by</code> can be None) and return a tuple.</p>
<p>Set <code>as_mapped</code> to True to return an instance of <code><a title="vectorbt.records.mapped_array.MappedArray" href="../records/mapped_array.html#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rank(self,
         rank_func_nb: tp.RankFunc, *args,
         prepare_func: tp.Optional[tp.Callable] = None,
         reset_by: tp.Optional[tp.ArrayLike] = None,
         after_false: bool = False,
         broadcast_kwargs: tp.KwargsLike = None,
         wrap_kwargs: tp.KwargsLike = None,
         as_mapped: bool = False,
         **kwargs) -&gt; tp.Union[tp.SeriesFrame, MappedArray]:
    &#34;&#34;&#34;See `vectorbt.signals.nb.rank_nb`.

    Will broadcast with `reset_by` using `vectorbt.base.reshape_fns.broadcast` and `broadcast_kwargs`.

    Use `prepare_func` to prepare further arguments to be passed before `*args`, such as temporary arrays.
    It should take both broadcasted arrays (`reset_by` can be None) and return a tuple.

    Set `as_mapped` to True to return an instance of `vectorbt.records.mapped_array.MappedArray`.&#34;&#34;&#34;
    checks.assert_not_none(rank_func_nb)
    checks.assert_numba_func(rank_func_nb)
    if broadcast_kwargs is None:
        broadcast_kwargs = {}

    if reset_by is not None:
        obj, reset_by = reshape_fns.broadcast(self.obj, reset_by, **broadcast_kwargs)
        reset_by = reshape_fns.to_2d_array(reset_by)
    else:
        obj = self.obj
    obj_arr = reshape_fns.to_2d_array(obj)
    if prepare_func is not None:
        temp_arrs = prepare_func(obj_arr, reset_by)
    else:
        temp_arrs = ()
    rank = nb.rank_nb(
        obj_arr,
        reset_by,
        after_false,
        rank_func_nb,
        *temp_arrs,
        *args
    )
    rank_wrapped = ArrayWrapper.from_obj(obj).wrap(rank, group_by=False, **merge_dicts({}, wrap_kwargs))
    if as_mapped:
        rank_wrapped = rank_wrapped.replace(-1, np.nan)
        return rank_wrapped.vbt.to_mapped(
            dropna=True,
            dtype=np.int_,
            **kwargs
        )
    return rank_wrapped</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.rate"><code class="name flex">
<span>def <span class="ident child-name">rate</span></span>(<span class="params">self, wrap_kwargs=None, group_by=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="vectorbt.signals.accessors.SignalsAccessor.total" href="#vectorbt.signals.accessors.SignalsAccessor.total">SignalsAccessor.total()</a></code> divided by the total index length in each column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rate(self, wrap_kwargs: tp.KwargsLike = None,
         group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;`SignalsAccessor.total` divided by the total index length in each column/group.&#34;&#34;&#34;
    total = reshape_fns.to_1d_array(self.total(group_by=group_by, **kwargs))
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;rate&#39;), wrap_kwargs)
    total_steps = self.wrapper.grouper.get_group_lens(group_by=group_by) * self.wrapper.shape[0]
    return self.wrapper.wrap_reduced(total / total_steps, group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.total"><code class="name flex">
<span>def <span class="ident child-name">total</span></span>(<span class="params">self, wrap_kwargs=None, group_by=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Total number of True values in each column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def total(self, wrap_kwargs: tp.KwargsLike = None,
          group_by: tp.GroupByLike = None) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;Total number of True values in each column/group.&#34;&#34;&#34;
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total&#39;), wrap_kwargs)
    return self.sum(group_by=group_by, wrap_kwargs=wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsAccessor.total_partitions"><code class="name flex">
<span>def <span class="ident child-name">total_partitions</span></span>(<span class="params">self, wrap_kwargs=None, group_by=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Total number of partitions of True values in each column/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def total_partitions(self, wrap_kwargs: tp.KwargsLike = None,
                     group_by: tp.GroupByLike = None, **kwargs) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;Total number of partitions of True values in each column/group.&#34;&#34;&#34;
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;total_partitions&#39;), wrap_kwargs)
    return self.partition_ranges(**kwargs).count(group_by=group_by, wrap_kwargs=wrap_kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.generic.accessors.GenericAccessor" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor">GenericAccessor</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.align_to" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.align_to">align_to</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.apply" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.apply">apply</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.apply_along_axis" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.apply_along_axis">apply_along_axis</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.apply_and_concat" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.apply_and_concat">apply_and_concat</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.apply_and_reduce" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.apply_and_reduce">apply_and_reduce</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.apply_mapping" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.apply_mapping">apply_mapping</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.apply_on_index" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.apply_on_index">apply_on_index</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.applymap" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.applymap">applymap</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.barplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.barplot">barplot</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.bfill" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.bfill">bfill</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.binarize" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.binarize">binarize</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.boxplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.boxplot">boxplot</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.broadcast" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.broadcast">broadcast</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.broadcast_to" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.broadcast_to">broadcast_to</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.build_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.build_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.combine" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.combine">combine</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.concat" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.concat">concat</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.count" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.count">count</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.cumprod" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.cumprod">cumprod</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.cumsum" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.cumsum">cumsum</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.deep_getattr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.describe" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.describe">describe</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.df_accessor_cls" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.df_accessor_cls">df_accessor_cls</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.diff" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.diff">diff</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.drawdown" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.drawdown">drawdown</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.drawdowns" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.drawdowns">drawdowns</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.drop_duplicate_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.drop_duplicate_levels">drop_duplicate_levels</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.drop_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.drop_levels">drop_levels</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.drop_redundant_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.drop_redundant_levels">drop_redundant_levels</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.ewm_mean" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.ewm_mean">ewm_mean</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.ewm_std" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.ewm_std">ewm_std</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.expanding_apply" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_apply">expanding_apply</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.expanding_max" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_max">expanding_max</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.expanding_mean" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_mean">expanding_mean</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.expanding_min" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_min">expanding_min</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.expanding_split" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_split">expanding_split</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.expanding_std" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_std">expanding_std</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.ffill" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.ffill">ffill</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.fillna" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.fillna">fillna</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.filter" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.filter">filter</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.get_drawdowns" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.get_drawdowns">get_drawdowns</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.get_ranges" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.get_ranges">get_ranges</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.groupby_apply" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.groupby_apply">groupby_apply</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.histplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.histplot">histplot</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.idxmax" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.idxmax">idxmax</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.idxmin" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.idxmin">idxmin</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.indexing_func" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.lineplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.lineplot">lineplot</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.make_symmetric" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.make_symmetric">make_symmetric</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.mapping" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.mapping">mapping</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.max" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.max">max</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.maxabs_scale" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.maxabs_scale">maxabs_scale</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.mean" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.mean">mean</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.median" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.median">median</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.min" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.min">min</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.minmax_scale" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.minmax_scale">minmax_scale</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.normalize" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.normalize">normalize</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.obj" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.obj">obj</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.override_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.override_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.pct_change" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.pct_change">pct_change</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.post_resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.power_transform" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.power_transform">power_transform</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.pre_resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.product" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.product">product</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.quantile_transform" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.quantile_transform">quantile_transform</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.range_split" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.range_split">range_split</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.ranges" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.ranges">ranges</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.rebase" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rebase">rebase</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.reduce" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.reduce">reduce</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.rename_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.rename_levels">rename_levels</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.repeat" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.repeat">repeat</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.replace" href="../utils/config.html#vectorbt.utils.config.Configured.replace">replace</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.resample_apply" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.resample_apply">resample_apply</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.resolve_self" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.robust_scale" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.robust_scale">robust_scale</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.rolling_apply" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_apply">rolling_apply</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.rolling_max" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_max">rolling_max</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.rolling_mean" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_mean">rolling_mean</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.rolling_min" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_min">rolling_min</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.rolling_split" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_split">rolling_split</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.rolling_std" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_std">rolling_std</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.scale" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.scale">scale</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.scatterplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.scatterplot">scatterplot</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.select_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.select_levels">select_levels</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.self_aliases" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.shuffle" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.shuffle">shuffle</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.split" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.split">split</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.sr_accessor_cls" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.sr_accessor_cls">sr_accessor_cls</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.stack_index" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.stack_index">stack_index</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.std" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.std">std</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.sum" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.sum">sum</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.tile" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.tile">tile</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.to_1d_array" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.to_1d_array">to_1d_array</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.to_2d_array" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.to_2d_array">to_2d_array</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.to_dict" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.to_dict">to_dict</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.to_mapped" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.to_mapped">to_mapped</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.to_returns" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.to_returns">to_returns</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.transform" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.transform">transform</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.unstack_to_array" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.unstack_to_array">unstack_to_array</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.unstack_to_df" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.unstack_to_df">unstack_to_df</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.value_counts" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.value_counts">value_counts</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericAccessor.zscore" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.zscore">zscore</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.accessors.SignalsDFAccessor"><code class="flex name class">
<span>class <span class="ident parent-name">SignalsDFAccessor</span></span>
(<span class="params">obj, **kwargs</span>)
</code></dt>
<dd>
<div class="desc"><p>Accessor on top of signal series. For DataFrames only.</p>
<p>Accessible through <code>pd.DataFrame.vbt.signals</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignalsDFAccessor(SignalsAccessor, GenericDFAccessor):
    &#34;&#34;&#34;Accessor on top of signal series. For DataFrames only.

    Accessible through `pd.DataFrame.vbt.signals`.&#34;&#34;&#34;

    def __init__(self, obj: tp.Frame, **kwargs) -&gt; None:
        GenericDFAccessor.__init__(self, obj, **kwargs)
        SignalsAccessor.__init__(self, obj, **kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.signals.accessors.SignalsAccessor" href="#vectorbt.signals.accessors.SignalsAccessor">SignalsAccessor</a></li>
<li><a title="vectorbt.generic.accessors.GenericDFAccessor" href="../generic/accessors.html#vectorbt.generic.accessors.GenericDFAccessor">GenericDFAccessor</a></li>
<li><a title="vectorbt.generic.accessors.GenericAccessor" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor">GenericAccessor</a></li>
<li><a title="vectorbt.base.accessors.BaseDFAccessor" href="../base/accessors.html#vectorbt.base.accessors.BaseDFAccessor">BaseDFAccessor</a></li>
<li><a title="vectorbt.base.accessors.BaseAccessor" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor">BaseAccessor</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr.AttrResolver" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
</ul>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.signals.accessors.SignalsAccessor" href="#vectorbt.signals.accessors.SignalsAccessor">SignalsAccessor</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.AND" href="#vectorbt.signals.accessors.SignalsAccessor.AND">AND</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.OR" href="#vectorbt.signals.accessors.SignalsAccessor.OR">OR</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.XOR" href="#vectorbt.signals.accessors.SignalsAccessor.XOR">XOR</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.align_to" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.align_to">align_to</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.apply" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.apply">apply</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.apply_along_axis" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.apply_along_axis">apply_along_axis</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.apply_and_concat" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.apply_and_concat">apply_and_concat</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.apply_and_reduce" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.apply_and_reduce">apply_and_reduce</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.apply_mapping" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.apply_mapping">apply_mapping</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.apply_on_index" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.apply_on_index">apply_on_index</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.applymap" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.applymap">applymap</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.barplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.barplot">barplot</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.between_partition_ranges" href="#vectorbt.signals.accessors.SignalsAccessor.between_partition_ranges">between_partition_ranges</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.between_ranges" href="#vectorbt.signals.accessors.SignalsAccessor.between_ranges">between_ranges</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.bfill" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.bfill">bfill</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.binarize" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.binarize">binarize</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.boxplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.boxplot">boxplot</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.broadcast" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.broadcast">broadcast</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.broadcast_to" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.broadcast_to">broadcast_to</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.bshift" href="#vectorbt.signals.accessors.SignalsAccessor.bshift">bshift</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.build_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.build_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.clean" href="#vectorbt.signals.accessors.SignalsAccessor.clean">clean</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.combine" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.combine">combine</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.concat" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.concat">concat</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.count" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.count">count</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.cumprod" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.cumprod">cumprod</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.cumsum" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.cumsum">cumsum</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.deep_getattr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.describe" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.describe">describe</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.df_accessor_cls" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.df_accessor_cls">df_accessor_cls</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.diff" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.diff">diff</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.drawdown" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.drawdown">drawdown</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.drawdowns" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.drawdowns">drawdowns</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.drop_duplicate_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.drop_duplicate_levels">drop_duplicate_levels</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.drop_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.drop_levels">drop_levels</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.drop_redundant_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.drop_redundant_levels">drop_redundant_levels</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.empty" href="#vectorbt.signals.accessors.SignalsAccessor.empty">empty</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.empty_like" href="#vectorbt.signals.accessors.SignalsAccessor.empty_like">empty_like</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.ewm_mean" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.ewm_mean">ewm_mean</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.ewm_std" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.ewm_std">ewm_std</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.expanding_apply" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_apply">expanding_apply</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.expanding_max" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_max">expanding_max</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.expanding_mean" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_mean">expanding_mean</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.expanding_min" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_min">expanding_min</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.expanding_split" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_split">expanding_split</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.expanding_std" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_std">expanding_std</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.ffill" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.ffill">ffill</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.fillna" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.fillna">fillna</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.filter" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.filter">filter</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.first" href="#vectorbt.signals.accessors.SignalsAccessor.first">first</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.from_nth" href="#vectorbt.signals.accessors.SignalsAccessor.from_nth">from_nth</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.fshift" href="#vectorbt.signals.accessors.SignalsAccessor.fshift">fshift</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate" href="#vectorbt.signals.accessors.SignalsAccessor.generate">generate</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_both" href="#vectorbt.signals.accessors.SignalsAccessor.generate_both">generate_both</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_exits" href="#vectorbt.signals.accessors.SignalsAccessor.generate_exits">generate_exits</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_ohlc_stop_exits" href="#vectorbt.signals.accessors.SignalsAccessor.generate_ohlc_stop_exits">generate_ohlc_stop_exits</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_random" href="#vectorbt.signals.accessors.SignalsAccessor.generate_random">generate_random</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_random_both" href="#vectorbt.signals.accessors.SignalsAccessor.generate_random_both">generate_random_both</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_random_exits" href="#vectorbt.signals.accessors.SignalsAccessor.generate_random_exits">generate_random_exits</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_stop_exits" href="#vectorbt.signals.accessors.SignalsAccessor.generate_stop_exits">generate_stop_exits</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.get_drawdowns" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.get_drawdowns">get_drawdowns</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.get_ranges" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.get_ranges">get_ranges</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.groupby_apply" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.groupby_apply">groupby_apply</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.histplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.histplot">histplot</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.idxmax" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.idxmax">idxmax</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.idxmin" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.idxmin">idxmin</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.index_mapped" href="#vectorbt.signals.accessors.SignalsAccessor.index_mapped">index_mapped</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.indexing_func" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.lineplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.lineplot">lineplot</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.make_symmetric" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.make_symmetric">make_symmetric</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.mapping" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.mapping">mapping</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.max" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.max">max</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.maxabs_scale" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.maxabs_scale">maxabs_scale</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.mean" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.mean">mean</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.median" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.median">median</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.min" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.min">min</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.minmax_scale" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.minmax_scale">minmax_scale</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.norm_avg_index" href="#vectorbt.signals.accessors.SignalsAccessor.norm_avg_index">norm_avg_index</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.normalize" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.normalize">normalize</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.nth" href="#vectorbt.signals.accessors.SignalsAccessor.nth">nth</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.nth_index" href="#vectorbt.signals.accessors.SignalsAccessor.nth_index">nth_index</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.obj" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.obj">obj</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.override_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.override_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank" href="#vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank">partition_pos_rank</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank_mapped" href="#vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank_mapped">partition_pos_rank_mapped</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.partition_ranges" href="#vectorbt.signals.accessors.SignalsAccessor.partition_ranges">partition_ranges</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.partition_rate" href="#vectorbt.signals.accessors.SignalsAccessor.partition_rate">partition_rate</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.pct_change" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.pct_change">pct_change</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.plot" href="#vectorbt.signals.accessors.SignalsAccessor.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.plots_defaults" href="#vectorbt.signals.accessors.SignalsAccessor.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.pos_rank" href="#vectorbt.signals.accessors.SignalsAccessor.pos_rank">pos_rank</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.pos_rank_mapped" href="#vectorbt.signals.accessors.SignalsAccessor.pos_rank_mapped">pos_rank_mapped</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.post_resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.power_transform" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.power_transform">power_transform</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.pre_resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.product" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.product">product</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.quantile_transform" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.quantile_transform">quantile_transform</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.range_split" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.range_split">range_split</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.ranges" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.ranges">ranges</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rank" href="#vectorbt.signals.accessors.SignalsAccessor.rank">rank</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rate" href="#vectorbt.signals.accessors.SignalsAccessor.rate">rate</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rebase" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rebase">rebase</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.reduce" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.reduce">reduce</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rename_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.rename_levels">rename_levels</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.repeat" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.repeat">repeat</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.replace" href="../utils/config.html#vectorbt.utils.config.Configured.replace">replace</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.resample_apply" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.resample_apply">resample_apply</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.resolve_self" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.robust_scale" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.robust_scale">robust_scale</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rolling_apply" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_apply">rolling_apply</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rolling_max" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_max">rolling_max</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rolling_mean" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_mean">rolling_mean</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rolling_min" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_min">rolling_min</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rolling_split" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_split">rolling_split</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rolling_std" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_std">rolling_std</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.scale" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.scale">scale</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.scatterplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.scatterplot">scatterplot</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.select_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.select_levels">select_levels</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.self_aliases" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.shuffle" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.shuffle">shuffle</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.split" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.split">split</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.sr_accessor_cls" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.sr_accessor_cls">sr_accessor_cls</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.stack_index" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.stack_index">stack_index</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.stats_defaults" href="#vectorbt.signals.accessors.SignalsAccessor.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.std" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.std">std</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.sum" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.sum">sum</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.tile" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.tile">tile</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.to_1d_array" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.to_1d_array">to_1d_array</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.to_2d_array" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.to_2d_array">to_2d_array</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.to_dict" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.to_dict">to_dict</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.to_mapped" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.to_mapped">to_mapped</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.to_returns" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.to_returns">to_returns</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.total" href="#vectorbt.signals.accessors.SignalsAccessor.total">total</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.total_partitions" href="#vectorbt.signals.accessors.SignalsAccessor.total_partitions">total_partitions</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.transform" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.transform">transform</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.unstack_to_array" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.unstack_to_array">unstack_to_array</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.unstack_to_df" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.unstack_to_df">unstack_to_df</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.value_counts" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.value_counts">value_counts</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.zscore" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.zscore">zscore</a></code></li>
</ul>
</li>
<li><code><b><a title="vectorbt.generic.accessors.GenericDFAccessor" href="../generic/accessors.html#vectorbt.generic.accessors.GenericDFAccessor">GenericDFAccessor</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.generic.accessors.GenericDFAccessor.flatten_grouped" href="../generic/accessors.html#vectorbt.generic.accessors.GenericDFAccessor.flatten_grouped">flatten_grouped</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericDFAccessor.heatmap" href="../generic/accessors.html#vectorbt.generic.accessors.GenericDFAccessor.heatmap">heatmap</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericDFAccessor.squeeze_grouped" href="../generic/accessors.html#vectorbt.generic.accessors.GenericDFAccessor.squeeze_grouped">squeeze_grouped</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericDFAccessor.ts_heatmap" href="../generic/accessors.html#vectorbt.generic.accessors.GenericDFAccessor.ts_heatmap">ts_heatmap</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.accessors.SignalsSRAccessor"><code class="flex name class">
<span>class <span class="ident parent-name">SignalsSRAccessor</span></span>
(<span class="params">obj, **kwargs</span>)
</code></dt>
<dd>
<div class="desc"><p>Accessor on top of signal series. For Series only.</p>
<p>Accessible through <code>pd.Series.vbt.signals</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignalsSRAccessor(SignalsAccessor, GenericSRAccessor):
    &#34;&#34;&#34;Accessor on top of signal series. For Series only.

    Accessible through `pd.Series.vbt.signals`.&#34;&#34;&#34;

    def __init__(self, obj: tp.Series, **kwargs) -&gt; None:
        GenericSRAccessor.__init__(self, obj, **kwargs)
        SignalsAccessor.__init__(self, obj, **kwargs)

    def plot_as_markers(self, y: tp.Optional[tp.ArrayLike] = None,
                        **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
        &#34;&#34;&#34;Plot Series as markers.

        Args:
            y (array_like): Y-axis values to plot markers on.
            **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.scatterplot`.

        ## Example

        ```python-repl
        &gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1], index=mask.index)
        &gt;&gt;&gt; fig = ts.vbt.lineplot()
        &gt;&gt;&gt; mask[&#39;b&#39;].vbt.signals.plot_as_entry_markers(y=ts, fig=fig)
        &gt;&gt;&gt; (~mask[&#39;b&#39;]).vbt.signals.plot_as_exit_markers(y=ts, fig=fig)
        ```

        ![](/docs/img/signals_plot_as_markers.svg)
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        if y is None:
            y = pd.Series.vbt.empty_like(self.obj, 1)
        else:
            y = reshape_fns.to_pd_array(y)

        return y[self.obj].vbt.scatterplot(**merge_dicts(dict(
            trace_kwargs=dict(
                marker=dict(
                    symbol=&#39;circle&#39;,
                    color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;blue&#39;],
                    size=7,
                    line=dict(
                        width=1,
                        color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;blue&#39;])
                    )
                )
            )
        ), kwargs))

    def plot_as_entry_markers(self, y: tp.Optional[tp.ArrayLike] = None,
                              **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
        &#34;&#34;&#34;Plot signals as entry markers.

        See `SignalsSRAccessor.plot_as_markers`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        return self.plot_as_markers(y=y, **merge_dicts(dict(
            trace_kwargs=dict(
                marker=dict(
                    symbol=&#39;triangle-up&#39;,
                    color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;green&#39;],
                    size=8,
                    line=dict(
                        width=1,
                        color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;green&#39;])
                    )
                ),
                name=&#39;Entry&#39;
            )
        ), kwargs))

    def plot_as_exit_markers(self, y: tp.Optional[tp.ArrayLike] = None,
                             **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
        &#34;&#34;&#34;Plot signals as exit markers.

        See `SignalsSRAccessor.plot_as_markers`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        return self.plot_as_markers(y=y, **merge_dicts(dict(
            trace_kwargs=dict(
                marker=dict(
                    symbol=&#39;triangle-down&#39;,
                    color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;red&#39;],
                    size=8,
                    line=dict(
                        width=1,
                        color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;red&#39;])
                    )
                ),
                name=&#39;Exit&#39;
            )
        ), kwargs))</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.signals.accessors.SignalsAccessor" href="#vectorbt.signals.accessors.SignalsAccessor">SignalsAccessor</a></li>
<li><a title="vectorbt.generic.accessors.GenericSRAccessor" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor">GenericSRAccessor</a></li>
<li><a title="vectorbt.generic.accessors.GenericAccessor" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor">GenericAccessor</a></li>
<li><a title="vectorbt.base.accessors.BaseSRAccessor" href="../base/accessors.html#vectorbt.base.accessors.BaseSRAccessor">BaseSRAccessor</a></li>
<li><a title="vectorbt.base.accessors.BaseAccessor" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor">BaseAccessor</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr.AttrResolver" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
</ul>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers"><code class="name flex">
<span>def <span class="ident child-name">plot_as_entry_markers</span></span>(<span class="params">self, y=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Plot signals as entry markers.</p>
<p>See <code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers" href="#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers">SignalsSRAccessor.plot_as_markers()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_as_entry_markers(self, y: tp.Optional[tp.ArrayLike] = None,
                          **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
    &#34;&#34;&#34;Plot signals as entry markers.

    See `SignalsSRAccessor.plot_as_markers`.&#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    return self.plot_as_markers(y=y, **merge_dicts(dict(
        trace_kwargs=dict(
            marker=dict(
                symbol=&#39;triangle-up&#39;,
                color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;green&#39;],
                size=8,
                line=dict(
                    width=1,
                    color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;green&#39;])
                )
            ),
            name=&#39;Entry&#39;
        )
    ), kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers"><code class="name flex">
<span>def <span class="ident child-name">plot_as_exit_markers</span></span>(<span class="params">self, y=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Plot signals as exit markers.</p>
<p>See <code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers" href="#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers">SignalsSRAccessor.plot_as_markers()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_as_exit_markers(self, y: tp.Optional[tp.ArrayLike] = None,
                         **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
    &#34;&#34;&#34;Plot signals as exit markers.

    See `SignalsSRAccessor.plot_as_markers`.&#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    return self.plot_as_markers(y=y, **merge_dicts(dict(
        trace_kwargs=dict(
            marker=dict(
                symbol=&#39;triangle-down&#39;,
                color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;red&#39;],
                size=8,
                line=dict(
                    width=1,
                    color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;red&#39;])
                )
            ),
            name=&#39;Exit&#39;
        )
    ), kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers"><code class="name flex">
<span>def <span class="ident child-name">plot_as_markers</span></span>(<span class="params">self, y=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Plot Series as markers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot markers on.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.generic.accessors.GenericAccessor.scatterplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.scatterplot">GenericAccessor.scatterplot()</a></code>.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1], index=mask.index)
&gt;&gt;&gt; fig = ts.vbt.lineplot()
&gt;&gt;&gt; mask['b'].vbt.signals.plot_as_entry_markers(y=ts, fig=fig)
&gt;&gt;&gt; (~mask['b']).vbt.signals.plot_as_exit_markers(y=ts, fig=fig)
</code></pre>
<p><img alt="" src="/docs/img/signals_plot_as_markers.svg"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_as_markers(self, y: tp.Optional[tp.ArrayLike] = None,
                    **kwargs) -&gt; tp.Union[tp.BaseFigure, plotting.Scatter]:  # pragma: no cover
    &#34;&#34;&#34;Plot Series as markers.

    Args:
        y (array_like): Y-axis values to plot markers on.
        **kwargs: Keyword arguments passed to `vectorbt.generic.accessors.GenericAccessor.scatterplot`.

    ## Example

    ```python-repl
    &gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1], index=mask.index)
    &gt;&gt;&gt; fig = ts.vbt.lineplot()
    &gt;&gt;&gt; mask[&#39;b&#39;].vbt.signals.plot_as_entry_markers(y=ts, fig=fig)
    &gt;&gt;&gt; (~mask[&#39;b&#39;]).vbt.signals.plot_as_exit_markers(y=ts, fig=fig)
    ```

    ![](/docs/img/signals_plot_as_markers.svg)
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    if y is None:
        y = pd.Series.vbt.empty_like(self.obj, 1)
    else:
        y = reshape_fns.to_pd_array(y)

    return y[self.obj].vbt.scatterplot(**merge_dicts(dict(
        trace_kwargs=dict(
            marker=dict(
                symbol=&#39;circle&#39;,
                color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;blue&#39;],
                size=7,
                line=dict(
                    width=1,
                    color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;blue&#39;])
                )
            )
        )
    ), kwargs))</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.signals.accessors.SignalsAccessor" href="#vectorbt.signals.accessors.SignalsAccessor">SignalsAccessor</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.AND" href="#vectorbt.signals.accessors.SignalsAccessor.AND">AND</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.OR" href="#vectorbt.signals.accessors.SignalsAccessor.OR">OR</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.XOR" href="#vectorbt.signals.accessors.SignalsAccessor.XOR">XOR</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.align_to" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.align_to">align_to</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.apply" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.apply">apply</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.apply_along_axis" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.apply_along_axis">apply_along_axis</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.apply_and_concat" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.apply_and_concat">apply_and_concat</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.apply_and_reduce" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.apply_and_reduce">apply_and_reduce</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.apply_mapping" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.apply_mapping">apply_mapping</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.apply_on_index" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.apply_on_index">apply_on_index</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.applymap" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.applymap">applymap</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.barplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.barplot">barplot</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.between_partition_ranges" href="#vectorbt.signals.accessors.SignalsAccessor.between_partition_ranges">between_partition_ranges</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.between_ranges" href="#vectorbt.signals.accessors.SignalsAccessor.between_ranges">between_ranges</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.bfill" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.bfill">bfill</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.binarize" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.binarize">binarize</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.boxplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.boxplot">boxplot</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.broadcast" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.broadcast">broadcast</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.broadcast_to" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.broadcast_to">broadcast_to</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.bshift" href="#vectorbt.signals.accessors.SignalsAccessor.bshift">bshift</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.build_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.build_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.clean" href="#vectorbt.signals.accessors.SignalsAccessor.clean">clean</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.combine" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.combine">combine</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.concat" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.concat">concat</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.count" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.count">count</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.cumprod" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.cumprod">cumprod</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.cumsum" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.cumsum">cumsum</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.deep_getattr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.describe" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.describe">describe</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.df_accessor_cls" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.df_accessor_cls">df_accessor_cls</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.diff" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.diff">diff</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.drawdown" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.drawdown">drawdown</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.drawdowns" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.drawdowns">drawdowns</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.drop_duplicate_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.drop_duplicate_levels">drop_duplicate_levels</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.drop_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.drop_levels">drop_levels</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.drop_redundant_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.drop_redundant_levels">drop_redundant_levels</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.empty" href="#vectorbt.signals.accessors.SignalsAccessor.empty">empty</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.empty_like" href="#vectorbt.signals.accessors.SignalsAccessor.empty_like">empty_like</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.ewm_mean" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.ewm_mean">ewm_mean</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.ewm_std" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.ewm_std">ewm_std</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.expanding_apply" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_apply">expanding_apply</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.expanding_max" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_max">expanding_max</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.expanding_mean" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_mean">expanding_mean</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.expanding_min" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_min">expanding_min</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.expanding_split" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_split">expanding_split</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.expanding_std" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.expanding_std">expanding_std</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.ffill" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.ffill">ffill</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.fillna" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.fillna">fillna</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.filter" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.filter">filter</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.first" href="#vectorbt.signals.accessors.SignalsAccessor.first">first</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.from_nth" href="#vectorbt.signals.accessors.SignalsAccessor.from_nth">from_nth</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.fshift" href="#vectorbt.signals.accessors.SignalsAccessor.fshift">fshift</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate" href="#vectorbt.signals.accessors.SignalsAccessor.generate">generate</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_both" href="#vectorbt.signals.accessors.SignalsAccessor.generate_both">generate_both</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_exits" href="#vectorbt.signals.accessors.SignalsAccessor.generate_exits">generate_exits</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_ohlc_stop_exits" href="#vectorbt.signals.accessors.SignalsAccessor.generate_ohlc_stop_exits">generate_ohlc_stop_exits</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_random" href="#vectorbt.signals.accessors.SignalsAccessor.generate_random">generate_random</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_random_both" href="#vectorbt.signals.accessors.SignalsAccessor.generate_random_both">generate_random_both</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_random_exits" href="#vectorbt.signals.accessors.SignalsAccessor.generate_random_exits">generate_random_exits</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_stop_exits" href="#vectorbt.signals.accessors.SignalsAccessor.generate_stop_exits">generate_stop_exits</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.get_drawdowns" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.get_drawdowns">get_drawdowns</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.get_ranges" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.get_ranges">get_ranges</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.groupby_apply" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.groupby_apply">groupby_apply</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.histplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.histplot">histplot</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.idxmax" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.idxmax">idxmax</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.idxmin" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.idxmin">idxmin</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.index_mapped" href="#vectorbt.signals.accessors.SignalsAccessor.index_mapped">index_mapped</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.indexing_func" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.lineplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.lineplot">lineplot</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.make_symmetric" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.make_symmetric">make_symmetric</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.mapping" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.mapping">mapping</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.max" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.max">max</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.maxabs_scale" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.maxabs_scale">maxabs_scale</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.mean" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.mean">mean</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.median" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.median">median</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.min" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.min">min</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.minmax_scale" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.minmax_scale">minmax_scale</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.norm_avg_index" href="#vectorbt.signals.accessors.SignalsAccessor.norm_avg_index">norm_avg_index</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.normalize" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.normalize">normalize</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.nth" href="#vectorbt.signals.accessors.SignalsAccessor.nth">nth</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.nth_index" href="#vectorbt.signals.accessors.SignalsAccessor.nth_index">nth_index</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.obj" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.obj">obj</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.override_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.override_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank" href="#vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank">partition_pos_rank</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank_mapped" href="#vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank_mapped">partition_pos_rank_mapped</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.partition_ranges" href="#vectorbt.signals.accessors.SignalsAccessor.partition_ranges">partition_ranges</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.partition_rate" href="#vectorbt.signals.accessors.SignalsAccessor.partition_rate">partition_rate</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.pct_change" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.pct_change">pct_change</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.plot" href="#vectorbt.signals.accessors.SignalsAccessor.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.plots_defaults" href="#vectorbt.signals.accessors.SignalsAccessor.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.pos_rank" href="#vectorbt.signals.accessors.SignalsAccessor.pos_rank">pos_rank</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.pos_rank_mapped" href="#vectorbt.signals.accessors.SignalsAccessor.pos_rank_mapped">pos_rank_mapped</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.post_resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.power_transform" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.power_transform">power_transform</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.pre_resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.product" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.product">product</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.quantile_transform" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.quantile_transform">quantile_transform</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.range_split" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.range_split">range_split</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.ranges" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.ranges">ranges</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rank" href="#vectorbt.signals.accessors.SignalsAccessor.rank">rank</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rate" href="#vectorbt.signals.accessors.SignalsAccessor.rate">rate</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rebase" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rebase">rebase</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.reduce" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.reduce">reduce</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rename_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.rename_levels">rename_levels</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.repeat" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.repeat">repeat</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.replace" href="../utils/config.html#vectorbt.utils.config.Configured.replace">replace</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.resample_apply" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.resample_apply">resample_apply</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.resolve_self" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.robust_scale" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.robust_scale">robust_scale</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rolling_apply" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_apply">rolling_apply</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rolling_max" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_max">rolling_max</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rolling_mean" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_mean">rolling_mean</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rolling_min" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_min">rolling_min</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rolling_split" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_split">rolling_split</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rolling_std" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.rolling_std">rolling_std</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.scale" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.scale">scale</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.scatterplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.scatterplot">scatterplot</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.select_levels" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.select_levels">select_levels</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.self_aliases" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.shuffle" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.shuffle">shuffle</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.split" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.split">split</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.sr_accessor_cls" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.sr_accessor_cls">sr_accessor_cls</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.stack_index" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.stack_index">stack_index</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.stats_defaults" href="#vectorbt.signals.accessors.SignalsAccessor.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.std" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.std">std</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.sum" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.sum">sum</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.tile" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.tile">tile</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.to_1d_array" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.to_1d_array">to_1d_array</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.to_2d_array" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.to_2d_array">to_2d_array</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.to_dict" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.to_dict">to_dict</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.to_mapped" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.to_mapped">to_mapped</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.to_returns" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.to_returns">to_returns</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.total" href="#vectorbt.signals.accessors.SignalsAccessor.total">total</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.total_partitions" href="#vectorbt.signals.accessors.SignalsAccessor.total_partitions">total_partitions</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.transform" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.transform">transform</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.unstack_to_array" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.unstack_to_array">unstack_to_array</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.unstack_to_df" href="../base/accessors.html#vectorbt.base.accessors.BaseAccessor.unstack_to_df">unstack_to_df</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.value_counts" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.value_counts">value_counts</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.zscore" href="../generic/accessors.html#vectorbt.generic.accessors.GenericAccessor.zscore">zscore</a></code></li>
</ul>
</li>
<li><code><b><a title="vectorbt.generic.accessors.GenericSRAccessor" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor">GenericSRAccessor</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.generic.accessors.GenericSRAccessor.flatten_grouped" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.flatten_grouped">flatten_grouped</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericSRAccessor.heatmap" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.heatmap">heatmap</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap">overlay_with_heatmap</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericSRAccessor.plot_against" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.plot_against">plot_against</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericSRAccessor.qqplot" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.qqplot">qqplot</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericSRAccessor.squeeze_grouped" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.squeeze_grouped">squeeze_grouped</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericSRAccessor.ts_heatmap" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.ts_heatmap">ts_heatmap</a></code></li>
<li><code><a title="vectorbt.generic.accessors.GenericSRAccessor.volume" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.volume">volume</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRUYwMDAwO30KCS5zdDF7ZmlsbDojRkY5MDAwO30KCS5zdDJ7ZmlsbDojRkZERjAwO30KCS5zdDN7ZmlsbDojMjgyQzM0O30KPC9zdHlsZT4KPGc+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNTUuMywzMDAuMSAyODMuMSwwIDIwOCwwIDExMC44LDAgMzUuOCwwIDEuMiw0NTAuMiA3Ni4zLDQ1MC4yIAkJCSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjIzMC40LDMwMC4xIDM1OC4xLDAgMjgzLjEsMCAxODUuOCwwIDExMC44LDAgNzYuMyw0NTAuMiAxNTEuMyw0NTAuMiAJCQkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIzMDUuNCwzMDAuMSA0MzMuMSwwIDM1OC4xLDAgMzMxLjYsNjIuMyAyNjAuOCwwIDE4NS44LDAgMTUxLjMsNDUwLjIgMjI2LjQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iNTEwLjgsMCA0MzMuMSwwIDMwNS40LDMwMC4xIDMzOC40LDAgMjYwLjgsMCAyMjYuNCw0NTAuMiAzMDQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="/>
vectorbt <span class="version">0.21.0</span></a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul>
<li><a href="#stats">Stats</a></li>
<li><a href="#plots">Plots</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.signals" href="index.html">vectorbt.signals</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.signals.accessors.SignalsAccessor" href="#vectorbt.signals.accessors.SignalsAccessor">SignalsAccessor</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.AND" href="#vectorbt.signals.accessors.SignalsAccessor.AND">AND</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.OR" href="#vectorbt.signals.accessors.SignalsAccessor.OR">OR</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.XOR" href="#vectorbt.signals.accessors.SignalsAccessor.XOR">XOR</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.between_partition_ranges" href="#vectorbt.signals.accessors.SignalsAccessor.between_partition_ranges">between_partition_ranges</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.between_ranges" href="#vectorbt.signals.accessors.SignalsAccessor.between_ranges">between_ranges</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.bshift" href="#vectorbt.signals.accessors.SignalsAccessor.bshift">bshift</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.clean" href="#vectorbt.signals.accessors.SignalsAccessor.clean">clean</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.empty" href="#vectorbt.signals.accessors.SignalsAccessor.empty">empty</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.empty_like" href="#vectorbt.signals.accessors.SignalsAccessor.empty_like">empty_like</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.first" href="#vectorbt.signals.accessors.SignalsAccessor.first">first</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.from_nth" href="#vectorbt.signals.accessors.SignalsAccessor.from_nth">from_nth</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.fshift" href="#vectorbt.signals.accessors.SignalsAccessor.fshift">fshift</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate" href="#vectorbt.signals.accessors.SignalsAccessor.generate">generate</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_both" href="#vectorbt.signals.accessors.SignalsAccessor.generate_both">generate_both</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_exits" href="#vectorbt.signals.accessors.SignalsAccessor.generate_exits">generate_exits</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_ohlc_stop_exits" href="#vectorbt.signals.accessors.SignalsAccessor.generate_ohlc_stop_exits">generate_ohlc_stop_exits</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_random" href="#vectorbt.signals.accessors.SignalsAccessor.generate_random">generate_random</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_random_both" href="#vectorbt.signals.accessors.SignalsAccessor.generate_random_both">generate_random_both</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_random_exits" href="#vectorbt.signals.accessors.SignalsAccessor.generate_random_exits">generate_random_exits</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.generate_stop_exits" href="#vectorbt.signals.accessors.SignalsAccessor.generate_stop_exits">generate_stop_exits</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.index_mapped" href="#vectorbt.signals.accessors.SignalsAccessor.index_mapped">index_mapped</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.metrics" href="#vectorbt.signals.accessors.SignalsAccessor.metrics">metrics</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.norm_avg_index" href="#vectorbt.signals.accessors.SignalsAccessor.norm_avg_index">norm_avg_index</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.nth" href="#vectorbt.signals.accessors.SignalsAccessor.nth">nth</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.nth_index" href="#vectorbt.signals.accessors.SignalsAccessor.nth_index">nth_index</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank" href="#vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank">partition_pos_rank</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank_mapped" href="#vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank_mapped">partition_pos_rank_mapped</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.partition_ranges" href="#vectorbt.signals.accessors.SignalsAccessor.partition_ranges">partition_ranges</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.partition_rate" href="#vectorbt.signals.accessors.SignalsAccessor.partition_rate">partition_rate</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.plot" href="#vectorbt.signals.accessors.SignalsAccessor.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.plots_defaults" href="#vectorbt.signals.accessors.SignalsAccessor.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.pos_rank" href="#vectorbt.signals.accessors.SignalsAccessor.pos_rank">pos_rank</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.pos_rank_mapped" href="#vectorbt.signals.accessors.SignalsAccessor.pos_rank_mapped">pos_rank_mapped</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rank" href="#vectorbt.signals.accessors.SignalsAccessor.rank">rank</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.rate" href="#vectorbt.signals.accessors.SignalsAccessor.rate">rate</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.stats_defaults" href="#vectorbt.signals.accessors.SignalsAccessor.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.subplots" href="#vectorbt.signals.accessors.SignalsAccessor.subplots">subplots</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.total" href="#vectorbt.signals.accessors.SignalsAccessor.total">total</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsAccessor.total_partitions" href="#vectorbt.signals.accessors.SignalsAccessor.total_partitions">total_partitions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.accessors.SignalsDFAccessor" href="#vectorbt.signals.accessors.SignalsDFAccessor">SignalsDFAccessor</a></code></h4>
</li>
<li>
<h4><code><a title="vectorbt.signals.accessors.SignalsSRAccessor" href="#vectorbt.signals.accessors.SignalsSRAccessor">SignalsSRAccessor</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers" href="#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers">plot_as_entry_markers</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers" href="#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers">plot_as_exit_markers</a></code></li>
<li><code><a title="vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers" href="#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers">plot_as_markers</a></code></li>
</ul>
</li>
</ul>
</li>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous"></script>
<script>
$(document).ready(function() {
$("article dt[id], #section-intro [id]").each(function() {
const thisId = $(this).attr('id');
$(this).wrap('<a class="headerlink" href="#' + thisId + '">');
});
});
</script>
</body>
</html>