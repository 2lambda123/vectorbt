<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.signals.basic API documentation</title>
<meta name="description" content="Signal generators built with `vectorbt.signals.factory.SignalFactory`." />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3B4556}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="mask-icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.signals.basic</code></h1>
</header>
<section id="section-intro">
<p>Signal generators built with <code><a title="vectorbt.signals.factory.SignalFactory" href="factory.html#vectorbt.signals.factory.SignalFactory">SignalFactory</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Signal generators built with `vectorbt.signals.factory.SignalFactory`.&#34;&#34;&#34;

import numpy as np
import plotly.graph_objects as go

from vectorbt.utils.config import Config
from vectorbt.utils.docs import fix_class_for_docs
from vectorbt.utils.widgets import CustomFigureWidget
from vectorbt.signals.enums import StopType
from vectorbt.signals.factory import SignalFactory
from vectorbt.signals.nb import (
    rand_enex_apply_nb,
    rand_by_prob_choice_nb,
    stop_choice_nb,
    adv_stop_choice_nb
)

flex_elem_param_config = Config(
    array_like=True,  # passing a NumPy array means passing one value, for multiple use list
    bc_to_input=True,  # broadcast to input
    broadcast_kwargs=dict(
        keep_raw=True  # keep original shape for flexible indexing to save memory
    )
)
&#34;&#34;&#34;Config for flexible element-wise parameters.&#34;&#34;&#34;

flex_col_param_config = Config(
    array_like=True,
    bc_to_input=1,  # broadcast to axis 1 (columns)
    broadcast_kwargs=dict(
        keep_raw=True
    )
)
&#34;&#34;&#34;Config for flexible column-wise parameters.&#34;&#34;&#34;

# ############# Random signals ############# #


RAND = SignalFactory(
    class_name=&#39;RAND&#39;,
    module_name=__name__,
    short_name=&#39;rand&#39;,
    param_names=[&#39;n&#39;]
).from_apply_func(  # apply_func since function is (almost) vectorized
    rand_enex_apply_nb,
    param_settings=dict(
        n=flex_col_param_config
    ),
    pass_kwargs=[
        (&#39;entry_wait&#39;, 1),
        (&#39;exit_wait&#39;, 1)
    ],
    seed=None
)


class RAND(RAND):
    &#34;&#34;&#34;Random entry and exit signal generator based on the number of signals.

    Generates `entries` and `exits` based on `vectorbt.signals.nb.rand_enex_apply_nb`.

    !!! hint
        Parameter `n` can be either a single value (per frame) or a NumPy array (per column).
        To generate multiple combinations, pass it as a list.

    ## Example

    Test three different `n` values:
    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; rand = vbt.RAND.run(
    ...     n=[1, 2, 3], input_shape=(6,), seed=42
    ... )

    &gt;&gt;&gt; rand.entries
    rand_n      1      2      3
    0        True   True   True
    1       False  False  False
    2       False   True   True
    3       False  False  False
    4       False  False   True
    5       False  False  False

    &gt;&gt;&gt; rand.exits
    rand_n      1      2      3
    0       False  False  False
    1        True   True   True
    2       False  False  False
    3       False   True   True
    4       False  False  False
    5       False  False   True
    ```

    `n` can also be set per column:
    ```python-repl
    &gt;&gt;&gt; import numpy as np

    &gt;&gt;&gt; rand = vbt.RAND.run(
    ...     n=[np.array([1, 2]), np.array([3, 4])],
    ...     input_shape=(8, 2), seed=42
    ... )

    &gt;&gt;&gt; rand.entries
    rand_n         mix_0         mix_1
                0      1      0      1
    0       False   True   True   True
    1        True  False  False  False
    2       False  False  False   True
    3       False  False   True  False
    4       False   True  False   True
    5       False  False   True  False
    6       False  False  False   True
    7       False  False  False  False

    &gt;&gt;&gt; rand.exits
    rand_n         mix_0         mix_1
                0      1      0      1
    0       False  False  False  False
    1       False  False   True   True
    2       False  False  False  False
    3       False   True  False   True
    4       False  False   True  False
    5        True  False  False   True
    6       False  False   True  False
    7       False   True  False   True
    ```
    &#34;&#34;&#34;
    pass


fix_class_for_docs(RAND)

RPROB = SignalFactory(
    class_name=&#39;RPROB&#39;,
    module_name=__name__,
    short_name=&#39;rprob&#39;,
    param_names=[&#39;entry_prob&#39;, &#39;exit_prob&#39;]
).from_choice_func(
    entry_choice_func=rand_by_prob_choice_nb,
    entry_settings=dict(
        pass_params=[&#39;entry_prob&#39;],
        pass_kwargs=[&#39;first&#39;, &#39;temp_idx_arr&#39;, &#39;flex_2d&#39;]
    ),
    exit_choice_func=rand_by_prob_choice_nb,
    exit_settings=dict(
        pass_params=[&#39;exit_prob&#39;],
        pass_kwargs=[&#39;first&#39;, &#39;temp_idx_arr&#39;, &#39;flex_2d&#39;]
    ),
    forward_flex_2d=True,
    param_settings=dict(
        entry_prob=flex_elem_param_config,
        exit_prob=flex_elem_param_config
    ),
    seed=None
)


class RPROB(RPROB):
    &#34;&#34;&#34;Random entry and exit signal generator based on probabilities.

    Generates `entries` and `exits` based on `vectorbt.signals.nb.rand_by_prob_choice_nb`.

    !!! hint
        All parameters can be either a single value (per frame) or a NumPy array (per row, column,
        or element). To generate multiple combinations, pass them as lists.

    ## Example

    Test all probability combinations:
    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; rprob = vbt.RPROB.run(
    ...     entry_prob=[0.5, 1.], exit_prob=[0.5, 1.],
    ...     input_shape=(5,), param_product=True, seed=42
    ... )

    &gt;&gt;&gt; rprob.entries
    rprob_entry_prob           0.5           1.0
    rprob_exit_prob     0.5    1.0    0.5    1.0
    0                  True   True   True   True
    1                 False  False  False  False
    2                 False  False  False   True
    3                 False  False  False  False
    4                 False  False   True   True

    &gt;&gt;&gt; rprob.exits
    rprob_entry_prob           0.5           1.0
    rprob_exit_prob     0.5    1.0    0.5    1.0
    0                 False  False  False  False
    1                 False   True  False   True
    2                 False  False  False  False
    3                 False  False   True   True
    4                  True  False  False  False
    ```

    `entry_prob` and `exit_prob` can also be set per row, column, or element:
    ```python-repl
    &gt;&gt;&gt; import numpy as np

    &gt;&gt;&gt; entry_prob1 = np.asarray([1., 0., 1., 0., 1.])
    &gt;&gt;&gt; entry_prob2 = np.asarray([0., 1., 0., 1., 0.])
    &gt;&gt;&gt; rprob = vbt.RPROB.run(
    ...     entry_prob=[entry_prob1, entry_prob2], exit_prob=1.,
    ...     input_shape=(5,), seed=42
    ... )

    &gt;&gt;&gt; rprob.entries
    rprob_entry_prob  mix_0  mix_1
    rprob_exit_prob     1.0    1.0
    0                  True  False
    1                 False   True
    2                  True  False
    3                 False   True
    4                  True  False

    &gt;&gt;&gt; rprob.exits
    rprob_entry_prob  mix_0  mix_1
    rprob_exit_prob     1.0    1.0
    0                 False  False
    1                  True  False
    2                 False   True
    3                  True  False
    4                 False   True
    ```
    &#34;&#34;&#34;
    pass


fix_class_for_docs(RPROB)

rprobex_config = Config(
    class_name=&#39;RPROBEX&#39;,
    module_name=__name__,
    short_name=&#39;rprobex&#39;,
    param_names=[&#39;prob&#39;],
    exit_only=True,
    iteratively=False
)
&#34;&#34;&#34;Factory config for `RPROBEX`.&#34;&#34;&#34;

rprobex_func_config = Config(
    exit_choice_func=rand_by_prob_choice_nb,
    exit_settings=dict(
        pass_params=[&#39;prob&#39;],
        pass_kwargs=[&#39;first&#39;, &#39;temp_idx_arr&#39;, &#39;flex_2d&#39;]
    ),
    forward_flex_2d=True,
    param_settings=dict(
        prob=flex_elem_param_config
    ),
    seed=None
)
&#34;&#34;&#34;Exit function config for `RPROBEX`.&#34;&#34;&#34;

RPROBEX = SignalFactory(
    **rprobex_config
).from_choice_func(
    **rprobex_func_config
)


class RPROBEX(RPROBEX):
    &#34;&#34;&#34;Random exit signal generator based on probabilities.

    Generates `exits` based on `entries` and `vectorbt.signals.nb.rand_by_prob_choice_nb`.

    See `RPROB` for notes on parameters.&#34;&#34;&#34;
    pass


fix_class_for_docs(RPROBEX)

IRPROBEX = SignalFactory(
    **rprobex_config.merge_with(
        dict(
            class_name=&#39;IRPROBEX&#39;,
            short_name=&#39;irprobex&#39;,
            iteratively=True
        )
    )
).from_choice_func(
    **rprobex_func_config
)


class IRPROBEX(IRPROBEX):
    &#34;&#34;&#34;Random exit signal generator based on probabilities.

    Iteratively generates `new_entries` and `exits` based on `entries` and
    `vectorbt.signals.nb.rand_by_prob_choice_nb`.

    See `RPROB` for notes on parameters.&#34;&#34;&#34;
    pass


fix_class_for_docs(IRPROBEX)

# ############# Stop signals ############# #

stex_config = Config(
    class_name=&#39;STEX&#39;,
    module_name=__name__,
    short_name=&#39;stex&#39;,
    input_names=[&#39;ts&#39;],
    param_names=[&#39;stop&#39;, &#39;trailing&#39;],
    exit_only=True,
    iteratively=False
)
&#34;&#34;&#34;Factory config for `STEX`.&#34;&#34;&#34;

stex_func_config = Config(
    exit_choice_func=stop_choice_nb,
    exit_settings=dict(
        pass_inputs=[&#39;ts&#39;],
        pass_params=[&#39;stop&#39;, &#39;trailing&#39;],
        pass_kwargs=[&#39;wait&#39;, &#39;first&#39;, &#39;temp_idx_arr&#39;, &#39;flex_2d&#39;]
    ),
    forward_flex_2d=True,
    param_settings=dict(
        stop=flex_elem_param_config,
        trailing=flex_elem_param_config
    ),
    trailing=False
)
&#34;&#34;&#34;Exit function config for `STEX`.&#34;&#34;&#34;

STEX = SignalFactory(
    **stex_config
).from_choice_func(
    **stex_func_config
)


class STEX(STEX):
    &#34;&#34;&#34;Exit signal generator based on stop values.

    Generates `exits` based on `entries` and `vectorbt.signals.nb.stop_choice_nb`.

    !!! hint
        All parameters can be either a single value (per frame) or a NumPy array (per row, column,
        or element). To generate multiple combinations, pass them as lists.&#34;&#34;&#34;
    pass


fix_class_for_docs(STEX)

ISTEX = SignalFactory(
    **stex_config.merge_with(
        dict(
            class_name=&#39;ISTEX&#39;,
            short_name=&#39;istex&#39;,
            iteratively=True
        )
    )
).from_choice_func(
    **stex_func_config
)


class ISTEX(ISTEX):
    &#34;&#34;&#34;Exit signal generator based on stop values.

    Iteratively generates `new_entries` and `exits` based on `entries` and
    `vectorbt.signals.nb.stop_choice_nb`.

    See `STEX` for notes on parameters.&#34;&#34;&#34;
    pass


fix_class_for_docs(ISTEX)


# ############# Advanced stop signals ############# #

advstex_config = Config(
    class_name=&#39;ADVSTEX&#39;,
    module_name=__name__,
    short_name=&#39;advstex&#39;,
    input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
    in_output_names=[&#39;hit_price&#39;, &#39;stop_type&#39;],
    param_names=[&#39;sl_stop&#39;, &#39;ts_stop&#39;, &#39;tp_stop&#39;],
    attr_settings=dict(
        stop_type=dict(dtype=StopType)  # creates rand_type_readable
    ),
    exit_only=True,
    iteratively=False
)
&#34;&#34;&#34;Factory config for `ADVSTEX`.&#34;&#34;&#34;

advstex_func_config = Config(
    exit_choice_func=adv_stop_choice_nb,
    exit_settings=dict(
        pass_inputs=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;],  # do not pass entries
        pass_in_outputs=[&#39;hit_price&#39;, &#39;stop_type&#39;],
        pass_params=[&#39;sl_stop&#39;, &#39;ts_stop&#39;, &#39;tp_stop&#39;],
        pass_kwargs=[(&#39;is_open_safe&#39;, True), &#39;wait&#39;, &#39;first&#39;, &#39;temp_idx_arr&#39;, &#39;flex_2d&#39;],
    ),
    forward_flex_2d=True,
    in_output_settings=dict(
        hit_price=dict(
            dtype=np.float_
        ),
        stop_type=dict(
            dtype=np.int_
        )
    ),
    param_settings=dict(stop=flex_elem_param_config),  # param per frame/row/col/element
    sl_stop=0.,
    ts_stop=0.,
    tp_stop=0.,
    hit_price=np.nan,
    stop_type=-1
)
&#34;&#34;&#34;Exit function config for `ADVSTEX`.&#34;&#34;&#34;

ADVSTEX = SignalFactory(
    **advstex_config
).from_choice_func(
    **advstex_func_config
)


def _generate_advstex_plot(base_cls, entries_attr):  # pragma: no cover
    def plot(self,
             plot_type=go.Ohlc,
             ohlc_kwargs=None,
             entry_trace_kwargs=None,
             exit_trace_kwargs=None,
             row=None, col=None,
             fig=None,
             **layout_kwargs):  # pragma: no cover
        if self.wrapper.ndim &gt; 1:
            raise TypeError(&#34;Select a column first. Use indexing.&#34;)

        if fig is None:
            fig = CustomFigureWidget()
            fig.update_layout(
                showlegend=True,
                xaxis_rangeslider_visible=False,
                xaxis_showgrid=True,
                yaxis_showgrid=True
            )
        fig.update_layout(**layout_kwargs)
        if ohlc_kwargs is None:
            ohlc_kwargs = {}

        # Plot OHLC
        ohlc = plot_type(
            x=self.wrapper.index,
            open=self.open,
            high=self.high,
            low=self.low,
            close=self.close,
            name=&#39;OHLC&#39;,
            increasing_line_color=&#39;#1b9e76&#39;,
            decreasing_line_color=&#39;#d95f02&#39;,
            opacity=0.7
        )
        ohlc.update(**ohlc_kwargs)
        fig.add_trace(ohlc, row=row, col=col)

        # Plot entry and exit markers
        base_cls.plot(
            self,
            entry_y=self.open,
            exit_y=self.hit_price,
            exit_types=self.stop_type_readable,
            entry_trace_kwargs=entry_trace_kwargs,
            exit_trace_kwargs=exit_trace_kwargs,
            row=row, col=col,
            fig=fig
        )
        return fig

    plot.__doc__ = &#34;&#34;&#34;Plot OHLC, `{0}.{1}` and `{0}.exits`.
    
    Args:
        plot_type: Either `plotly.graph_objects.Ohlc` or `plotly.graph_objects.Candlestick`.
        ohlc_kwargs (dict): Keyword arguments passed to `plot_type`.
        entry_trace_kwargs (dict): Keyword arguments passed to \
        `vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers` for `{0}.{1}`.
        exit_trace_kwargs (dict): Keyword arguments passed to \
        `vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers` for `{0}.exits`.
        fig (plotly.graph_objects.Figure): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.&#34;&#34;&#34;.format(base_cls.__name__, entries_attr)

    if entries_attr == &#39;entries&#39;:
        plot.__doc__ += &#34;&#34;&#34;
    ## Example
        
    ```python-repl
    &gt;&gt;&gt; advstex.iloc[:, 0].plot()
    ```
    
    ![](/vectorbt/docs/img/advstex.png)
    &#34;&#34;&#34;
    return plot


class ADVSTEX(ADVSTEX):
    &#34;&#34;&#34;Advanced exit signal generator based on stop values.

    Generates `exits` based on `entries` and `vectorbt.signals.nb.adv_stop_choice_nb`.

    !!! hint
        All parameters can be either a single value (per frame) or a NumPy array (per row, column,
        or element). To generate multiple combinations, pass them as lists.

    ## Example

    Test each stop type individually:
    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt
    &gt;&gt;&gt; import pandas as pd

    &gt;&gt;&gt; entries = pd.Series([True, False, False, False, False])
    &gt;&gt;&gt; price = pd.DataFrame({
    ...     &#39;open&#39;: [10, 11, 12, 11, 10],
    ...     &#39;high&#39;: [11, 12, 13, 12, 11],
    ...     &#39;low&#39;: [9, 10, 11, 10, 9],
    ...     &#39;close&#39;: [10, 11, 12, 11, 10]
    ... })
    &gt;&gt;&gt; advstex = vbt.ADVSTEX.run(
    ...     entries, price[&#39;open&#39;], price[&#39;high&#39;], price[&#39;low&#39;], price[&#39;close&#39;],
    ...     sl_stop=[0.1, 0., 0.], ts_stop=[0., 0.1, 0.], tp_stop=[0., 0., 0.1]
    ... )

    &gt;&gt;&gt; advstex.entries
    advstex_sl_stop    0.1    0.0    0.0
    advstex_ts_stop    0.0    0.1    0.0
    advstex_tp_stop    0.0    0.0    0.1
    0                 True   True   True
    1                False  False  False
    2                False  False  False
    3                False  False  False
    4                False  False  False

    &gt;&gt;&gt; advstex.exits
    advstex_sl_stop    0.1    0.0    0.0
    advstex_ts_stop    0.0    0.1    0.0
    advstex_tp_stop    0.0    0.0    0.1
    0                False  False  False
    1                False  False   True
    2                False  False  False
    3                False   True  False
    4                 True  False  False

    &gt;&gt;&gt; advstex.hit_price
    advstex_sl_stop  0.1   0.0   0.0
    advstex_ts_stop  0.0   0.1   0.0
    advstex_tp_stop  0.0   0.0   0.1
    0                NaN   NaN   NaN
    1                NaN   NaN  11.0
    2                NaN   NaN   NaN
    3                NaN  11.7   NaN
    4                9.0   NaN   NaN

    &gt;&gt;&gt; advstex.stop_type_readable
    advstex_sl_stop       0.1        0.0         0.0
    advstex_ts_stop       0.0        0.1         0.0
    advstex_tp_stop       0.0        0.0         0.1
    0
    1                                     TakeProfit
    2
    3                          TrailStop
    4                StopLoss
    ```
    &#34;&#34;&#34;

    plot = _generate_advstex_plot(ADVSTEX, &#39;entries&#39;)


fix_class_for_docs(ADVSTEX)

IADVSTEX = SignalFactory(
    **advstex_config.merge_with(
        dict(
            class_name=&#39;IADVSTEX&#39;,
            short_name=&#39;iadvstex&#39;,
            iteratively=True
        )
    )
).from_choice_func(
    **advstex_func_config
)


class IADVSTEX(IADVSTEX):
    &#34;&#34;&#34;Advanced exit signal generator based on stop values.

    Iteratively generates `new_entries` and `exits` based on `entries` and
    `vectorbt.signals.nb.adv_stop_choice_nb`.

    See `ADVSTEX` for notes on parameters.&#34;&#34;&#34;

    plot = _generate_advstex_plot(IADVSTEX, &#39;new_entries&#39;)


fix_class_for_docs(IADVSTEX)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="vectorbt.signals.basic.advstex_config"><code class="name">var <span class="ident fname">advstex_config</span></code></dt>
<dd>
<div class="desc"><p>Factory config for <code><a title="vectorbt.signals.basic.ADVSTEX" href="#vectorbt.signals.basic.ADVSTEX">ADVSTEX</a></code>.</p></div>
</dd>
<dt id="vectorbt.signals.basic.advstex_func_config"><code class="name">var <span class="ident fname">advstex_func_config</span></code></dt>
<dd>
<div class="desc"><p>Exit function config for <code><a title="vectorbt.signals.basic.ADVSTEX" href="#vectorbt.signals.basic.ADVSTEX">ADVSTEX</a></code>.</p></div>
</dd>
<dt id="vectorbt.signals.basic.flex_col_param_config"><code class="name">var <span class="ident fname">flex_col_param_config</span></code></dt>
<dd>
<div class="desc"><p>Config for flexible column-wise parameters.</p></div>
</dd>
<dt id="vectorbt.signals.basic.flex_elem_param_config"><code class="name">var <span class="ident fname">flex_elem_param_config</span></code></dt>
<dd>
<div class="desc"><p>Config for flexible element-wise parameters.</p></div>
</dd>
<dt id="vectorbt.signals.basic.rprobex_config"><code class="name">var <span class="ident fname">rprobex_config</span></code></dt>
<dd>
<div class="desc"><p>Factory config for <code><a title="vectorbt.signals.basic.RPROBEX" href="#vectorbt.signals.basic.RPROBEX">RPROBEX</a></code>.</p></div>
</dd>
<dt id="vectorbt.signals.basic.rprobex_func_config"><code class="name">var <span class="ident fname">rprobex_func_config</span></code></dt>
<dd>
<div class="desc"><p>Exit function config for <code><a title="vectorbt.signals.basic.RPROBEX" href="#vectorbt.signals.basic.RPROBEX">RPROBEX</a></code>.</p></div>
</dd>
<dt id="vectorbt.signals.basic.stex_config"><code class="name">var <span class="ident fname">stex_config</span></code></dt>
<dd>
<div class="desc"><p>Factory config for <code><a title="vectorbt.signals.basic.STEX" href="#vectorbt.signals.basic.STEX">STEX</a></code>.</p></div>
</dd>
<dt id="vectorbt.signals.basic.stex_func_config"><code class="name">var <span class="ident fname">stex_func_config</span></code></dt>
<dd>
<div class="desc"><p>Exit function config for <code><a title="vectorbt.signals.basic.STEX" href="#vectorbt.signals.basic.STEX">STEX</a></code>.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.signals.basic.ADVSTEX"><code class="flex name class">
<span>class <span class="ident parent-fname">ADVSTEX</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Advanced exit signal generator based on stop values.</p>
<p>Generates <code>exits</code> based on <code>entries</code> and <code><a title="vectorbt.signals.nb.adv_stop_choice_nb" href="nb.html#vectorbt.signals.nb.adv_stop_choice_nb">adv_stop_choice_nb()</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>All parameters can be either a single value (per frame) or a NumPy array (per row, column,
or element). To generate multiple combinations, pass them as lists.</p>
</div>
<h2 id="example">Example</h2>
<p>Test each stop type individually:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import pandas as pd

&gt;&gt;&gt; entries = pd.Series([True, False, False, False, False])
&gt;&gt;&gt; price = pd.DataFrame({
...     'open': [10, 11, 12, 11, 10],
...     'high': [11, 12, 13, 12, 11],
...     'low': [9, 10, 11, 10, 9],
...     'close': [10, 11, 12, 11, 10]
... })
&gt;&gt;&gt; advstex = vbt.ADVSTEX.run(
...     entries, price['open'], price['high'], price['low'], price['close'],
...     sl_stop=[0.1, 0., 0.], ts_stop=[0., 0.1, 0.], tp_stop=[0., 0., 0.1]
... )

&gt;&gt;&gt; advstex.entries
advstex_sl_stop    0.1    0.0    0.0
advstex_ts_stop    0.0    0.1    0.0
advstex_tp_stop    0.0    0.0    0.1
0                 True   True   True
1                False  False  False
2                False  False  False
3                False  False  False
4                False  False  False

&gt;&gt;&gt; advstex.exits
advstex_sl_stop    0.1    0.0    0.0
advstex_ts_stop    0.0    0.1    0.0
advstex_tp_stop    0.0    0.0    0.1
0                False  False  False
1                False  False   True
2                False  False  False
3                False   True  False
4                 True  False  False

&gt;&gt;&gt; advstex.hit_price
advstex_sl_stop  0.1   0.0   0.0
advstex_ts_stop  0.0   0.1   0.0
advstex_tp_stop  0.0   0.0   0.1
0                NaN   NaN   NaN
1                NaN   NaN  11.0
2                NaN   NaN   NaN
3                NaN  11.7   NaN
4                9.0   NaN   NaN

&gt;&gt;&gt; advstex.stop_type_readable
advstex_sl_stop       0.1        0.0         0.0
advstex_ts_stop       0.0        0.1         0.0
advstex_tp_stop       0.0        0.0         0.1
0
1                                     TakeProfit
2
3                          TrailStop
4                StopLoss
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ADVSTEX(ADVSTEX):
    &#34;&#34;&#34;Advanced exit signal generator based on stop values.

    Generates `exits` based on `entries` and `vectorbt.signals.nb.adv_stop_choice_nb`.

    !!! hint
        All parameters can be either a single value (per frame) or a NumPy array (per row, column,
        or element). To generate multiple combinations, pass them as lists.

    ## Example

    Test each stop type individually:
    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt
    &gt;&gt;&gt; import pandas as pd

    &gt;&gt;&gt; entries = pd.Series([True, False, False, False, False])
    &gt;&gt;&gt; price = pd.DataFrame({
    ...     &#39;open&#39;: [10, 11, 12, 11, 10],
    ...     &#39;high&#39;: [11, 12, 13, 12, 11],
    ...     &#39;low&#39;: [9, 10, 11, 10, 9],
    ...     &#39;close&#39;: [10, 11, 12, 11, 10]
    ... })
    &gt;&gt;&gt; advstex = vbt.ADVSTEX.run(
    ...     entries, price[&#39;open&#39;], price[&#39;high&#39;], price[&#39;low&#39;], price[&#39;close&#39;],
    ...     sl_stop=[0.1, 0., 0.], ts_stop=[0., 0.1, 0.], tp_stop=[0., 0., 0.1]
    ... )

    &gt;&gt;&gt; advstex.entries
    advstex_sl_stop    0.1    0.0    0.0
    advstex_ts_stop    0.0    0.1    0.0
    advstex_tp_stop    0.0    0.0    0.1
    0                 True   True   True
    1                False  False  False
    2                False  False  False
    3                False  False  False
    4                False  False  False

    &gt;&gt;&gt; advstex.exits
    advstex_sl_stop    0.1    0.0    0.0
    advstex_ts_stop    0.0    0.1    0.0
    advstex_tp_stop    0.0    0.0    0.1
    0                False  False  False
    1                False  False   True
    2                False  False  False
    3                False   True  False
    4                 True  False  False

    &gt;&gt;&gt; advstex.hit_price
    advstex_sl_stop  0.1   0.0   0.0
    advstex_ts_stop  0.0   0.1   0.0
    advstex_tp_stop  0.0   0.0   0.1
    0                NaN   NaN   NaN
    1                NaN   NaN  11.0
    2                NaN   NaN   NaN
    3                NaN  11.7   NaN
    4                9.0   NaN   NaN

    &gt;&gt;&gt; advstex.stop_type_readable
    advstex_sl_stop       0.1        0.0         0.0
    advstex_ts_stop       0.0        0.1         0.0
    advstex_tp_stop       0.0        0.0         0.1
    0
    1                                     TakeProfit
    2
    3                          TrailStop
    4                StopLoss
    ```
    &#34;&#34;&#34;

    plot = _generate_advstex_plot(ADVSTEX, &#39;entries&#39;)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.basic.ADVSTEX.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>entries, open, high, low, close, sl_stop=0.0, ts_stop=0.0, tp_stop=0.0, hit_price=nan, stop_type=-1, short_name='advstex', hide_params=None, hide_default=True, forward_flex_2d=True, pass_lists=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the ADVSTEX indicator using input time series <code>entries</code>, <code>open</code>, <code>high</code>, <code>low</code> and <code>close</code>, and parameters <code>sl_stop</code>, <code>ts_stop</code> and <code>tp_stop</code>, to
produce output time series <code>exits</code>, <code>hit_price</code> and <code>stop_type</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show column levels of parameters with the default value passed.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>entries, open, high, low, close, sl_stop=0.0, ts_stop=0.0, tp_stop=0.0, hit_price=nan, stop_type=-1, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, hide_params=None, hide_default=True, forward_flex_2d=True, pass_lists=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple ADVSTEX indicators using function <code>comb_func</code>.
Run each indicator using input time series input time series <code>entries</code>, <code>open</code>, <code>high</code>, <code>low</code> and <code>close</code>, and parameters <code>sl_stop</code>, <code>ts_stop</code> and <code>tp_stop</code>, to produce output time series <code>exits</code>, <code>hit_price</code> and <code>stop_type</code>.</p>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>. Also accepts all
combinatoric iterators from itertools such as <code>itertools.combinations</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to True to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.basic.ADVSTEX.run" href="#vectorbt.signals.basic.ADVSTEX.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.basic.ADVSTEX.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.entries"><code class="name">var <span class="ident fname">entries</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.exits"><code class="name">var <span class="ident fname">exits</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.high"><code class="name">var <span class="ident fname">high</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.hit_price"><code class="name">var <span class="ident fname">hit_price</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.low"><code class="name">var <span class="ident fname">low</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.open"><code class="name">var <span class="ident fname">open</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.sl_stop_array"><code class="name">var <span class="ident fname">sl_stop_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>sl_stop</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.sl_stop_loc"><code class="name">var <span class="ident fname">sl_stop_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>sl_stop</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.stop_type"><code class="name">var <span class="ident fname">stop_type</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.stop_type_readable"><code class="name">var <span class="ident fname">stop_type_readable</span></code></dt>
<dd>
<div class="desc"><p>stop_type in readable format based on enum StopType(StopLoss=0, TrailStop=1, TakeProfit=2).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_readable(_self, attr_name=attr_name, enum=dtype):
    if _self.wrapper.ndim == 1:
        return getattr(_self, attr_name).map(lambda x: &#39;&#39; if x == -1 else enum._fields[x])
    return getattr(_self, attr_name).applymap(lambda x: &#39;&#39; if x == -1 else enum._fields[x])</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.tp_stop_array"><code class="name">var <span class="ident fname">tp_stop_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>tp_stop</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.tp_stop_loc"><code class="name">var <span class="ident fname">tp_stop_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>tp_stop</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.ts_stop_array"><code class="name">var <span class="ident fname">ts_stop_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>ts_stop</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.ts_stop_loc"><code class="name">var <span class="ident fname">ts_stop_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>ts_stop</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.tuple_loc"><code class="name">var <span class="ident fname">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>tuple</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.basic.ADVSTEX.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.entries_and"><code class="name flex">
<span>def <span class="ident fname">entries_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.entries_or"><code class="name flex">
<span>def <span class="ident fname">entries_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.entries_xor"><code class="name flex">
<span>def <span class="ident fname">entries_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.exits_and"><code class="name flex">
<span>def <span class="ident fname">exits_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.exits_or"><code class="name flex">
<span>def <span class="ident fname">exits_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.exits_xor"><code class="name flex">
<span>def <span class="ident fname">exits_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.high_above"><code class="name flex">
<span>def <span class="ident fname">high_above</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.high_below"><code class="name flex">
<span>def <span class="ident fname">high_below</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.high_equal"><code class="name flex">
<span>def <span class="ident fname">high_equal</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.hit_price_above"><code class="name flex">
<span>def <span class="ident fname">hit_price_above</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hit_price</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hit_price</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.hit_price_below"><code class="name flex">
<span>def <span class="ident fname">hit_price_below</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hit_price</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hit_price</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.hit_price_equal"><code class="name flex">
<span>def <span class="ident fname">hit_price_equal</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hit_price</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hit_price</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.low_above"><code class="name flex">
<span>def <span class="ident fname">low_above</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.low_below"><code class="name flex">
<span>def <span class="ident fname">low_below</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.low_equal"><code class="name flex">
<span>def <span class="ident fname">low_equal</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.open_above"><code class="name flex">
<span>def <span class="ident fname">open_above</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>open</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>open</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.open_below"><code class="name flex">
<span>def <span class="ident fname">open_below</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>open</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>open</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.open_equal"><code class="name flex">
<span>def <span class="ident fname">open_equal</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>open</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>open</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ADVSTEX.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, plot_type=plotly.graph_objs._ohlc.Ohlc, ohlc_kwargs=None, entry_trace_kwargs=None, exit_trace_kwargs=None, row=None, col=None, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot OHLC, <code><a title="vectorbt.signals.basic.ADVSTEX.entries" href="#vectorbt.signals.basic.ADVSTEX.entries">ADVSTEX.entries</a></code> and <code><a title="vectorbt.signals.basic.ADVSTEX.exits" href="#vectorbt.signals.basic.ADVSTEX.exits">ADVSTEX.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plot_type</code></strong></dt>
<dd>Either <code>plotly.graph_objects.Ohlc</code> or <code>plotly.graph_objects.Candlestick</code>.</dd>
<dt><strong><code>ohlc_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plot_type</code>.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers">Signals_SRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.basic.ADVSTEX.entries" href="#vectorbt.signals.basic.ADVSTEX.entries">ADVSTEX.entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers">Signals_SRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.basic.ADVSTEX.exits" href="#vectorbt.signals.basic.ADVSTEX.exits">ADVSTEX.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; advstex.iloc[:, 0].plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/advstex.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         plot_type=go.Ohlc,
         ohlc_kwargs=None,
         entry_trace_kwargs=None,
         exit_trace_kwargs=None,
         row=None, col=None,
         fig=None,
         **layout_kwargs):  # pragma: no cover
    if self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if fig is None:
        fig = CustomFigureWidget()
        fig.update_layout(
            showlegend=True,
            xaxis_rangeslider_visible=False,
            xaxis_showgrid=True,
            yaxis_showgrid=True
        )
    fig.update_layout(**layout_kwargs)
    if ohlc_kwargs is None:
        ohlc_kwargs = {}

    # Plot OHLC
    ohlc = plot_type(
        x=self.wrapper.index,
        open=self.open,
        high=self.high,
        low=self.low,
        close=self.close,
        name=&#39;OHLC&#39;,
        increasing_line_color=&#39;#1b9e76&#39;,
        decreasing_line_color=&#39;#d95f02&#39;,
        opacity=0.7
    )
    ohlc.update(**ohlc_kwargs)
    fig.add_trace(ohlc, row=row, col=col)

    # Plot entry and exit markers
    base_cls.plot(
        self,
        entry_y=self.open,
        exit_y=self.hit_price,
        exit_types=self.stop_type_readable,
        entry_trace_kwargs=entry_trace_kwargs,
        exit_trace_kwargs=exit_trace_kwargs,
        row=row, col=col,
        fig=fig
    )
    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX"><code class="flex name class">
<span>class <span class="ident parent-fname">IADVSTEX</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Advanced exit signal generator based on stop values.</p>
<p>Iteratively generates <code>new_entries</code> and <code>exits</code> based on <code>entries</code> and
<code><a title="vectorbt.signals.nb.adv_stop_choice_nb" href="nb.html#vectorbt.signals.nb.adv_stop_choice_nb">adv_stop_choice_nb()</a></code>.</p>
<p>See <code><a title="vectorbt.signals.basic.ADVSTEX" href="#vectorbt.signals.basic.ADVSTEX">ADVSTEX</a></code> for notes on parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IADVSTEX(IADVSTEX):
    &#34;&#34;&#34;Advanced exit signal generator based on stop values.

    Iteratively generates `new_entries` and `exits` based on `entries` and
    `vectorbt.signals.nb.adv_stop_choice_nb`.

    See `ADVSTEX` for notes on parameters.&#34;&#34;&#34;

    plot = _generate_advstex_plot(IADVSTEX, &#39;new_entries&#39;)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.basic.IADVSTEX.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>entries, open, high, low, close, sl_stop=0.0, ts_stop=0.0, tp_stop=0.0, hit_price=nan, stop_type=-1, short_name='iadvstex', hide_params=None, hide_default=True, forward_flex_2d=True, pass_lists=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the IADVSTEX indicator using input time series <code>entries</code>, <code>open</code>, <code>high</code>, <code>low</code> and <code>close</code>, and parameters <code>sl_stop</code>, <code>ts_stop</code> and <code>tp_stop</code>, to
produce output time series <code>new_entries</code>, <code>exits</code>, <code>hit_price</code> and <code>stop_type</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show column levels of parameters with the default value passed.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>entries, open, high, low, close, sl_stop=0.0, ts_stop=0.0, tp_stop=0.0, hit_price=nan, stop_type=-1, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, hide_params=None, hide_default=True, forward_flex_2d=True, pass_lists=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple IADVSTEX indicators using function <code>comb_func</code>.
Run each indicator using input time series input time series <code>entries</code>, <code>open</code>, <code>high</code>, <code>low</code> and <code>close</code>, and parameters <code>sl_stop</code>, <code>ts_stop</code> and <code>tp_stop</code>, to produce output time series <code>new_entries</code>, <code>exits</code>, <code>hit_price</code> and <code>stop_type</code>.</p>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>. Also accepts all
combinatoric iterators from itertools such as <code>itertools.combinations</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to True to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.basic.IADVSTEX.run" href="#vectorbt.signals.basic.IADVSTEX.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.basic.IADVSTEX.close"><code class="name">var <span class="ident fname">close</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.entries"><code class="name">var <span class="ident fname">entries</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.exits"><code class="name">var <span class="ident fname">exits</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.high"><code class="name">var <span class="ident fname">high</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.hit_price"><code class="name">var <span class="ident fname">hit_price</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.low"><code class="name">var <span class="ident fname">low</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.new_entries"><code class="name">var <span class="ident fname">new_entries</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.open"><code class="name">var <span class="ident fname">open</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.sl_stop_array"><code class="name">var <span class="ident fname">sl_stop_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>sl_stop</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.sl_stop_loc"><code class="name">var <span class="ident fname">sl_stop_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>sl_stop</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.stop_type"><code class="name">var <span class="ident fname">stop_type</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.stop_type_readable"><code class="name">var <span class="ident fname">stop_type_readable</span></code></dt>
<dd>
<div class="desc"><p>stop_type in readable format based on enum StopType(StopLoss=0, TrailStop=1, TakeProfit=2).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_readable(_self, attr_name=attr_name, enum=dtype):
    if _self.wrapper.ndim == 1:
        return getattr(_self, attr_name).map(lambda x: &#39;&#39; if x == -1 else enum._fields[x])
    return getattr(_self, attr_name).applymap(lambda x: &#39;&#39; if x == -1 else enum._fields[x])</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.tp_stop_array"><code class="name">var <span class="ident fname">tp_stop_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>tp_stop</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.tp_stop_loc"><code class="name">var <span class="ident fname">tp_stop_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>tp_stop</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.ts_stop_array"><code class="name">var <span class="ident fname">ts_stop_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>ts_stop</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.ts_stop_loc"><code class="name">var <span class="ident fname">ts_stop_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>ts_stop</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.tuple_loc"><code class="name">var <span class="ident fname">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>tuple</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.basic.IADVSTEX.close_above"><code class="name flex">
<span>def <span class="ident fname">close_above</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.close_below"><code class="name flex">
<span>def <span class="ident fname">close_below</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.close_equal"><code class="name flex">
<span>def <span class="ident fname">close_equal</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.entries_and"><code class="name flex">
<span>def <span class="ident fname">entries_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.entries_or"><code class="name flex">
<span>def <span class="ident fname">entries_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.entries_xor"><code class="name flex">
<span>def <span class="ident fname">entries_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.exits_and"><code class="name flex">
<span>def <span class="ident fname">exits_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.exits_or"><code class="name flex">
<span>def <span class="ident fname">exits_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.exits_xor"><code class="name flex">
<span>def <span class="ident fname">exits_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.high_above"><code class="name flex">
<span>def <span class="ident fname">high_above</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.high_below"><code class="name flex">
<span>def <span class="ident fname">high_below</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.high_equal"><code class="name flex">
<span>def <span class="ident fname">high_equal</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>high</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.hit_price_above"><code class="name flex">
<span>def <span class="ident fname">hit_price_above</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hit_price</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hit_price</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.hit_price_below"><code class="name flex">
<span>def <span class="ident fname">hit_price_below</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hit_price</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hit_price</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.hit_price_equal"><code class="name flex">
<span>def <span class="ident fname">hit_price_equal</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>hit_price</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>hit_price</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.low_above"><code class="name flex">
<span>def <span class="ident fname">low_above</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.low_below"><code class="name flex">
<span>def <span class="ident fname">low_below</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.low_equal"><code class="name flex">
<span>def <span class="ident fname">low_equal</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>low</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.new_entries_and"><code class="name flex">
<span>def <span class="ident fname">new_entries_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.new_entries_or"><code class="name flex">
<span>def <span class="ident fname">new_entries_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.new_entries_xor"><code class="name flex">
<span>def <span class="ident fname">new_entries_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.open_above"><code class="name flex">
<span>def <span class="ident fname">open_above</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>open</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>open</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.open_below"><code class="name flex">
<span>def <span class="ident fname">open_below</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>open</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>open</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.open_equal"><code class="name flex">
<span>def <span class="ident fname">open_equal</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>open</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>open</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IADVSTEX.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>self, plot_type=plotly.graph_objs._ohlc.Ohlc, ohlc_kwargs=None, entry_trace_kwargs=None, exit_trace_kwargs=None, row=None, col=None, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot OHLC, <code><a title="vectorbt.signals.basic.IADVSTEX.new_entries" href="#vectorbt.signals.basic.IADVSTEX.new_entries">IADVSTEX.new_entries</a></code> and <code><a title="vectorbt.signals.basic.IADVSTEX.exits" href="#vectorbt.signals.basic.IADVSTEX.exits">IADVSTEX.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plot_type</code></strong></dt>
<dd>Either <code>plotly.graph_objects.Ohlc</code> or <code>plotly.graph_objects.Candlestick</code>.</dd>
<dt><strong><code>ohlc_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plot_type</code>.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers">Signals_SRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.basic.IADVSTEX.new_entries" href="#vectorbt.signals.basic.IADVSTEX.new_entries">IADVSTEX.new_entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers">Signals_SRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.basic.IADVSTEX.exits" href="#vectorbt.signals.basic.IADVSTEX.exits">IADVSTEX.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         plot_type=go.Ohlc,
         ohlc_kwargs=None,
         entry_trace_kwargs=None,
         exit_trace_kwargs=None,
         row=None, col=None,
         fig=None,
         **layout_kwargs):  # pragma: no cover
    if self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if fig is None:
        fig = CustomFigureWidget()
        fig.update_layout(
            showlegend=True,
            xaxis_rangeslider_visible=False,
            xaxis_showgrid=True,
            yaxis_showgrid=True
        )
    fig.update_layout(**layout_kwargs)
    if ohlc_kwargs is None:
        ohlc_kwargs = {}

    # Plot OHLC
    ohlc = plot_type(
        x=self.wrapper.index,
        open=self.open,
        high=self.high,
        low=self.low,
        close=self.close,
        name=&#39;OHLC&#39;,
        increasing_line_color=&#39;#1b9e76&#39;,
        decreasing_line_color=&#39;#d95f02&#39;,
        opacity=0.7
    )
    ohlc.update(**ohlc_kwargs)
    fig.add_trace(ohlc, row=row, col=col)

    # Plot entry and exit markers
    base_cls.plot(
        self,
        entry_y=self.open,
        exit_y=self.hit_price,
        exit_types=self.stop_type_readable,
        entry_trace_kwargs=entry_trace_kwargs,
        exit_trace_kwargs=exit_trace_kwargs,
        row=row, col=col,
        fig=fig
    )
    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX"><code class="flex name class">
<span>class <span class="ident parent-fname">IRPROBEX</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Random exit signal generator based on probabilities.</p>
<p>Iteratively generates <code>new_entries</code> and <code>exits</code> based on <code>entries</code> and
<code><a title="vectorbt.signals.nb.rand_by_prob_choice_nb" href="nb.html#vectorbt.signals.nb.rand_by_prob_choice_nb">rand_by_prob_choice_nb()</a></code>.</p>
<p>See <code><a title="vectorbt.signals.basic.RPROB" href="#vectorbt.signals.basic.RPROB">RPROB</a></code> for notes on parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IRPROBEX(IRPROBEX):
    &#34;&#34;&#34;Random exit signal generator based on probabilities.

    Iteratively generates `new_entries` and `exits` based on `entries` and
    `vectorbt.signals.nb.rand_by_prob_choice_nb`.

    See `RPROB` for notes on parameters.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.basic.IRPROBEX.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>entries, prob, short_name='irprobex', hide_params=None, hide_default=True, pass_lists=True, seed=None, forward_flex_2d=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the IRPROBEX indicator using input time series <code>entries</code>, and parameters <code>prob</code>, to
produce output time series <code>new_entries</code> and <code>exits</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show column levels of parameters with the default value passed.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>entries, prob, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, hide_params=None, hide_default=True, pass_lists=True, seed=None, forward_flex_2d=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple IRPROBEX indicators using function <code>comb_func</code>.
Run each indicator using input time series input time series <code>entries</code>, and parameters <code>prob</code>, to produce output time series <code>new_entries</code> and <code>exits</code>.</p>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>. Also accepts all
combinatoric iterators from itertools such as <code>itertools.combinations</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to True to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.basic.IRPROBEX.run" href="#vectorbt.signals.basic.IRPROBEX.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.basic.IRPROBEX.entries"><code class="name">var <span class="ident fname">entries</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.exits"><code class="name">var <span class="ident fname">exits</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.new_entries"><code class="name">var <span class="ident fname">new_entries</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.prob_array"><code class="name">var <span class="ident fname">prob_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>prob</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.prob_loc"><code class="name">var <span class="ident fname">prob_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>prob</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.basic.IRPROBEX.entries_and"><code class="name flex">
<span>def <span class="ident fname">entries_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.entries_or"><code class="name flex">
<span>def <span class="ident fname">entries_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.entries_xor"><code class="name flex">
<span>def <span class="ident fname">entries_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.exits_and"><code class="name flex">
<span>def <span class="ident fname">exits_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.exits_or"><code class="name flex">
<span>def <span class="ident fname">exits_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.exits_xor"><code class="name flex">
<span>def <span class="ident fname">exits_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.new_entries_and"><code class="name flex">
<span>def <span class="ident fname">new_entries_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.new_entries_or"><code class="name flex">
<span>def <span class="ident fname">new_entries_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.new_entries_xor"><code class="name flex">
<span>def <span class="ident fname">new_entries_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.IRPROBEX.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>_self, entry_y=None, exit_y=None, entry_types=None, exit_types=None, entry_trace_kwargs=None, exit_trace_kwargs=None, fig=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.signals.basic.IRPROBEX.new_entries" href="#vectorbt.signals.basic.IRPROBEX.new_entries">IRPROBEX.new_entries</a></code> and <code><a title="vectorbt.signals.basic.IRPROBEX.exits" href="#vectorbt.signals.basic.IRPROBEX.exits">IRPROBEX.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entry_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot entry markers on.</dd>
<dt><strong><code>exit_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot exit markers on.</dd>
<dt><strong><code>entry_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Entry types in string format.</dd>
<dt><strong><code>exit_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Exit types in string format.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers">Signals_SRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.basic.IRPROBEX.new_entries" href="#vectorbt.signals.basic.IRPROBEX.new_entries">IRPROBEX.new_entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers">Signals_SRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.basic.IRPROBEX.exits" href="#vectorbt.signals.basic.IRPROBEX.exits">IRPROBEX.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_markers">Signals_SRAccessor.plot_as_markers()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(_self,
         entry_y=None,
         exit_y=None,
         entry_types=None,
         exit_types=None,
         entry_trace_kwargs=None,
         exit_trace_kwargs=None,
         fig=None,
         **kwargs):  # pragma: no cover
    if _self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if entry_trace_kwargs is None:
        entry_trace_kwargs = {}
    if exit_trace_kwargs is None:
        exit_trace_kwargs = {}
    if entry_types is not None:
        entry_trace_kwargs = merge_dicts(dict(
            customdata=entry_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), entry_trace_kwargs)
    if exit_types is not None:
        exit_trace_kwargs = merge_dicts(dict(
            customdata=exit_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), exit_trace_kwargs)
    if exit_only and iteratively:
        entries = _self.new_entries
    else:
        entries = _self.entries
    exits = _self.exits
    fig = entries.vbt.signals.plot_as_entry_markers(
        y=entry_y, trace_kwargs=entry_trace_kwargs, fig=fig, **kwargs)
    fig = exits.vbt.signals.plot_as_exit_markers(
        y=exit_y, trace_kwargs=exit_trace_kwargs, fig=fig, **kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.basic.ISTEX"><code class="flex name class">
<span>class <span class="ident parent-fname">ISTEX</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Exit signal generator based on stop values.</p>
<p>Iteratively generates <code>new_entries</code> and <code>exits</code> based on <code>entries</code> and
<code><a title="vectorbt.signals.nb.stop_choice_nb" href="nb.html#vectorbt.signals.nb.stop_choice_nb">stop_choice_nb()</a></code>.</p>
<p>See <code><a title="vectorbt.signals.basic.STEX" href="#vectorbt.signals.basic.STEX">STEX</a></code> for notes on parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ISTEX(ISTEX):
    &#34;&#34;&#34;Exit signal generator based on stop values.

    Iteratively generates `new_entries` and `exits` based on `entries` and
    `vectorbt.signals.nb.stop_choice_nb`.

    See `STEX` for notes on parameters.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.basic.ISTEX.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>entries, ts, stop, trailing=False, short_name='istex', hide_params=None, hide_default=True, pass_lists=True, forward_flex_2d=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the ISTEX indicator using input time series <code>entries</code> and <code>ts</code>, and parameters <code>stop</code> and <code>trailing</code>, to
produce output time series <code>new_entries</code> and <code>exits</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show column levels of parameters with the default value passed.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>entries, ts, stop, trailing=False, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, hide_params=None, hide_default=True, pass_lists=True, forward_flex_2d=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple ISTEX indicators using function <code>comb_func</code>.
Run each indicator using input time series input time series <code>entries</code> and <code>ts</code>, and parameters <code>stop</code> and <code>trailing</code>, to produce output time series <code>new_entries</code> and <code>exits</code>.</p>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>. Also accepts all
combinatoric iterators from itertools such as <code>itertools.combinations</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to True to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.basic.ISTEX.run" href="#vectorbt.signals.basic.ISTEX.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.basic.ISTEX.entries"><code class="name">var <span class="ident fname">entries</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.exits"><code class="name">var <span class="ident fname">exits</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.new_entries"><code class="name">var <span class="ident fname">new_entries</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.stop_array"><code class="name">var <span class="ident fname">stop_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>stop</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.stop_loc"><code class="name">var <span class="ident fname">stop_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>stop</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.trailing_array"><code class="name">var <span class="ident fname">trailing_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>trailing</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.trailing_loc"><code class="name">var <span class="ident fname">trailing_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>trailing</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.ts"><code class="name">var <span class="ident fname">ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.tuple_loc"><code class="name">var <span class="ident fname">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>tuple</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.basic.ISTEX.entries_and"><code class="name flex">
<span>def <span class="ident fname">entries_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.entries_or"><code class="name flex">
<span>def <span class="ident fname">entries_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.entries_xor"><code class="name flex">
<span>def <span class="ident fname">entries_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.exits_and"><code class="name flex">
<span>def <span class="ident fname">exits_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.exits_or"><code class="name flex">
<span>def <span class="ident fname">exits_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.exits_xor"><code class="name flex">
<span>def <span class="ident fname">exits_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.new_entries_and"><code class="name flex">
<span>def <span class="ident fname">new_entries_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.new_entries_or"><code class="name flex">
<span>def <span class="ident fname">new_entries_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.new_entries_xor"><code class="name flex">
<span>def <span class="ident fname">new_entries_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>new_entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>_self, entry_y=None, exit_y=None, entry_types=None, exit_types=None, entry_trace_kwargs=None, exit_trace_kwargs=None, fig=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.signals.basic.ISTEX.new_entries" href="#vectorbt.signals.basic.ISTEX.new_entries">ISTEX.new_entries</a></code> and <code><a title="vectorbt.signals.basic.ISTEX.exits" href="#vectorbt.signals.basic.ISTEX.exits">ISTEX.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entry_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot entry markers on.</dd>
<dt><strong><code>exit_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot exit markers on.</dd>
<dt><strong><code>entry_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Entry types in string format.</dd>
<dt><strong><code>exit_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Exit types in string format.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers">Signals_SRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.basic.ISTEX.new_entries" href="#vectorbt.signals.basic.ISTEX.new_entries">ISTEX.new_entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers">Signals_SRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.basic.ISTEX.exits" href="#vectorbt.signals.basic.ISTEX.exits">ISTEX.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_markers">Signals_SRAccessor.plot_as_markers()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(_self,
         entry_y=None,
         exit_y=None,
         entry_types=None,
         exit_types=None,
         entry_trace_kwargs=None,
         exit_trace_kwargs=None,
         fig=None,
         **kwargs):  # pragma: no cover
    if _self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if entry_trace_kwargs is None:
        entry_trace_kwargs = {}
    if exit_trace_kwargs is None:
        exit_trace_kwargs = {}
    if entry_types is not None:
        entry_trace_kwargs = merge_dicts(dict(
            customdata=entry_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), entry_trace_kwargs)
    if exit_types is not None:
        exit_trace_kwargs = merge_dicts(dict(
            customdata=exit_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), exit_trace_kwargs)
    if exit_only and iteratively:
        entries = _self.new_entries
    else:
        entries = _self.entries
    exits = _self.exits
    fig = entries.vbt.signals.plot_as_entry_markers(
        y=entry_y, trace_kwargs=entry_trace_kwargs, fig=fig, **kwargs)
    fig = exits.vbt.signals.plot_as_exit_markers(
        y=exit_y, trace_kwargs=exit_trace_kwargs, fig=fig, **kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.ts_above"><code class="name flex">
<span>def <span class="ident fname">ts_above</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.ts_below"><code class="name flex">
<span>def <span class="ident fname">ts_below</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.ISTEX.ts_equal"><code class="name flex">
<span>def <span class="ident fname">ts_equal</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.basic.RAND"><code class="flex name class">
<span>class <span class="ident parent-fname">RAND</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Random entry and exit signal generator based on the number of signals.</p>
<p>Generates <code>entries</code> and <code>exits</code> based on <code><a title="vectorbt.signals.nb.rand_enex_apply_nb" href="nb.html#vectorbt.signals.nb.rand_enex_apply_nb">rand_enex_apply_nb()</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Parameter <code>n</code> can be either a single value (per frame) or a NumPy array (per column).
To generate multiple combinations, pass it as a list.</p>
</div>
<h2 id="example">Example</h2>
<p>Test three different <code>n</code> values:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; rand = vbt.RAND.run(
...     n=[1, 2, 3], input_shape=(6,), seed=42
... )

&gt;&gt;&gt; rand.entries
rand_n      1      2      3
0        True   True   True
1       False  False  False
2       False   True   True
3       False  False  False
4       False  False   True
5       False  False  False

&gt;&gt;&gt; rand.exits
rand_n      1      2      3
0       False  False  False
1        True   True   True
2       False  False  False
3       False   True   True
4       False  False  False
5       False  False   True
</code></pre>
<p><code>n</code> can also be set per column:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np

&gt;&gt;&gt; rand = vbt.RAND.run(
...     n=[np.array([1, 2]), np.array([3, 4])],
...     input_shape=(8, 2), seed=42
... )

&gt;&gt;&gt; rand.entries
rand_n         mix_0         mix_1
            0      1      0      1
0       False   True   True   True
1        True  False  False  False
2       False  False  False   True
3       False  False   True  False
4       False   True  False   True
5       False  False   True  False
6       False  False  False   True
7       False  False  False  False

&gt;&gt;&gt; rand.exits
rand_n         mix_0         mix_1
            0      1      0      1
0       False  False  False  False
1       False  False   True   True
2       False  False  False  False
3       False   True  False   True
4       False  False   True  False
5        True  False  False   True
6       False  False   True  False
7       False   True  False   True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RAND(RAND):
    &#34;&#34;&#34;Random entry and exit signal generator based on the number of signals.

    Generates `entries` and `exits` based on `vectorbt.signals.nb.rand_enex_apply_nb`.

    !!! hint
        Parameter `n` can be either a single value (per frame) or a NumPy array (per column).
        To generate multiple combinations, pass it as a list.

    ## Example

    Test three different `n` values:
    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; rand = vbt.RAND.run(
    ...     n=[1, 2, 3], input_shape=(6,), seed=42
    ... )

    &gt;&gt;&gt; rand.entries
    rand_n      1      2      3
    0        True   True   True
    1       False  False  False
    2       False   True   True
    3       False  False  False
    4       False  False   True
    5       False  False  False

    &gt;&gt;&gt; rand.exits
    rand_n      1      2      3
    0       False  False  False
    1        True   True   True
    2       False  False  False
    3       False   True   True
    4       False  False  False
    5       False  False   True
    ```

    `n` can also be set per column:
    ```python-repl
    &gt;&gt;&gt; import numpy as np

    &gt;&gt;&gt; rand = vbt.RAND.run(
    ...     n=[np.array([1, 2]), np.array([3, 4])],
    ...     input_shape=(8, 2), seed=42
    ... )

    &gt;&gt;&gt; rand.entries
    rand_n         mix_0         mix_1
                0      1      0      1
    0       False   True   True   True
    1        True  False  False  False
    2       False  False  False   True
    3       False  False   True  False
    4       False   True  False   True
    5       False  False   True  False
    6       False  False  False   True
    7       False  False  False  False

    &gt;&gt;&gt; rand.exits
    rand_n         mix_0         mix_1
                0      1      0      1
    0       False  False  False  False
    1       False  False   True   True
    2       False  False  False  False
    3       False   True  False   True
    4       False  False   True  False
    5        True  False  False   True
    6       False  False   True  False
    7       False   True  False   True
    ```
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.basic.RAND.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>n, short_name='rand', hide_params=None, hide_default=True, pass_lists=True, seed=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the RAND indicator using no input time series, and parameters <code>n</code>, to
produce output time series <code>entries</code> and <code>exits</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show column levels of parameters with the default value passed.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RAND.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>n, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, hide_params=None, hide_default=True, pass_lists=True, seed=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple RAND indicators using function <code>comb_func</code>.
Run each indicator using input time series no input time series, and parameters <code>n</code>, to produce output time series <code>entries</code> and <code>exits</code>.</p>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>. Also accepts all
combinatoric iterators from itertools such as <code>itertools.combinations</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to True to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.basic.RAND.run" href="#vectorbt.signals.basic.RAND.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.basic.RAND.entries"><code class="name">var <span class="ident fname">entries</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RAND.exits"><code class="name">var <span class="ident fname">exits</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RAND.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RAND.n_array"><code class="name">var <span class="ident fname">n_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>n</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RAND.n_loc"><code class="name">var <span class="ident fname">n_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>n</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RAND.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.basic.RAND.entries_and"><code class="name flex">
<span>def <span class="ident fname">entries_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RAND.entries_or"><code class="name flex">
<span>def <span class="ident fname">entries_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RAND.entries_xor"><code class="name flex">
<span>def <span class="ident fname">entries_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RAND.exits_and"><code class="name flex">
<span>def <span class="ident fname">exits_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RAND.exits_or"><code class="name flex">
<span>def <span class="ident fname">exits_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RAND.exits_xor"><code class="name flex">
<span>def <span class="ident fname">exits_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RAND.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>_self, entry_y=None, exit_y=None, entry_types=None, exit_types=None, entry_trace_kwargs=None, exit_trace_kwargs=None, fig=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.signals.basic.RAND.entries" href="#vectorbt.signals.basic.RAND.entries">RAND.entries</a></code> and <code><a title="vectorbt.signals.basic.RAND.exits" href="#vectorbt.signals.basic.RAND.exits">RAND.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entry_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot entry markers on.</dd>
<dt><strong><code>exit_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot exit markers on.</dd>
<dt><strong><code>entry_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Entry types in string format.</dd>
<dt><strong><code>exit_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Exit types in string format.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers">Signals_SRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.basic.RAND.entries" href="#vectorbt.signals.basic.RAND.entries">RAND.entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers">Signals_SRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.basic.RAND.exits" href="#vectorbt.signals.basic.RAND.exits">RAND.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_markers">Signals_SRAccessor.plot_as_markers()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(_self,
         entry_y=None,
         exit_y=None,
         entry_types=None,
         exit_types=None,
         entry_trace_kwargs=None,
         exit_trace_kwargs=None,
         fig=None,
         **kwargs):  # pragma: no cover
    if _self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if entry_trace_kwargs is None:
        entry_trace_kwargs = {}
    if exit_trace_kwargs is None:
        exit_trace_kwargs = {}
    if entry_types is not None:
        entry_trace_kwargs = merge_dicts(dict(
            customdata=entry_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), entry_trace_kwargs)
    if exit_types is not None:
        exit_trace_kwargs = merge_dicts(dict(
            customdata=exit_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), exit_trace_kwargs)
    if exit_only and iteratively:
        entries = _self.new_entries
    else:
        entries = _self.entries
    exits = _self.exits
    fig = entries.vbt.signals.plot_as_entry_markers(
        y=entry_y, trace_kwargs=entry_trace_kwargs, fig=fig, **kwargs)
    fig = exits.vbt.signals.plot_as_exit_markers(
        y=exit_y, trace_kwargs=exit_trace_kwargs, fig=fig, **kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.basic.RPROB"><code class="flex name class">
<span>class <span class="ident parent-fname">RPROB</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Random entry and exit signal generator based on probabilities.</p>
<p>Generates <code>entries</code> and <code>exits</code> based on <code><a title="vectorbt.signals.nb.rand_by_prob_choice_nb" href="nb.html#vectorbt.signals.nb.rand_by_prob_choice_nb">rand_by_prob_choice_nb()</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>All parameters can be either a single value (per frame) or a NumPy array (per row, column,
or element). To generate multiple combinations, pass them as lists.</p>
</div>
<h2 id="example">Example</h2>
<p>Test all probability combinations:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; rprob = vbt.RPROB.run(
...     entry_prob=[0.5, 1.], exit_prob=[0.5, 1.],
...     input_shape=(5,), param_product=True, seed=42
... )

&gt;&gt;&gt; rprob.entries
rprob_entry_prob           0.5           1.0
rprob_exit_prob     0.5    1.0    0.5    1.0
0                  True   True   True   True
1                 False  False  False  False
2                 False  False  False   True
3                 False  False  False  False
4                 False  False   True   True

&gt;&gt;&gt; rprob.exits
rprob_entry_prob           0.5           1.0
rprob_exit_prob     0.5    1.0    0.5    1.0
0                 False  False  False  False
1                 False   True  False   True
2                 False  False  False  False
3                 False  False   True   True
4                  True  False  False  False
</code></pre>
<p><code>entry_prob</code> and <code>exit_prob</code> can also be set per row, column, or element:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np

&gt;&gt;&gt; entry_prob1 = np.asarray([1., 0., 1., 0., 1.])
&gt;&gt;&gt; entry_prob2 = np.asarray([0., 1., 0., 1., 0.])
&gt;&gt;&gt; rprob = vbt.RPROB.run(
...     entry_prob=[entry_prob1, entry_prob2], exit_prob=1.,
...     input_shape=(5,), seed=42
... )

&gt;&gt;&gt; rprob.entries
rprob_entry_prob  mix_0  mix_1
rprob_exit_prob     1.0    1.0
0                  True  False
1                 False   True
2                  True  False
3                 False   True
4                  True  False

&gt;&gt;&gt; rprob.exits
rprob_entry_prob  mix_0  mix_1
rprob_exit_prob     1.0    1.0
0                 False  False
1                  True  False
2                 False   True
3                  True  False
4                 False   True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RPROB(RPROB):
    &#34;&#34;&#34;Random entry and exit signal generator based on probabilities.

    Generates `entries` and `exits` based on `vectorbt.signals.nb.rand_by_prob_choice_nb`.

    !!! hint
        All parameters can be either a single value (per frame) or a NumPy array (per row, column,
        or element). To generate multiple combinations, pass them as lists.

    ## Example

    Test all probability combinations:
    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt

    &gt;&gt;&gt; rprob = vbt.RPROB.run(
    ...     entry_prob=[0.5, 1.], exit_prob=[0.5, 1.],
    ...     input_shape=(5,), param_product=True, seed=42
    ... )

    &gt;&gt;&gt; rprob.entries
    rprob_entry_prob           0.5           1.0
    rprob_exit_prob     0.5    1.0    0.5    1.0
    0                  True   True   True   True
    1                 False  False  False  False
    2                 False  False  False   True
    3                 False  False  False  False
    4                 False  False   True   True

    &gt;&gt;&gt; rprob.exits
    rprob_entry_prob           0.5           1.0
    rprob_exit_prob     0.5    1.0    0.5    1.0
    0                 False  False  False  False
    1                 False   True  False   True
    2                 False  False  False  False
    3                 False  False   True   True
    4                  True  False  False  False
    ```

    `entry_prob` and `exit_prob` can also be set per row, column, or element:
    ```python-repl
    &gt;&gt;&gt; import numpy as np

    &gt;&gt;&gt; entry_prob1 = np.asarray([1., 0., 1., 0., 1.])
    &gt;&gt;&gt; entry_prob2 = np.asarray([0., 1., 0., 1., 0.])
    &gt;&gt;&gt; rprob = vbt.RPROB.run(
    ...     entry_prob=[entry_prob1, entry_prob2], exit_prob=1.,
    ...     input_shape=(5,), seed=42
    ... )

    &gt;&gt;&gt; rprob.entries
    rprob_entry_prob  mix_0  mix_1
    rprob_exit_prob     1.0    1.0
    0                  True  False
    1                 False   True
    2                  True  False
    3                 False   True
    4                  True  False

    &gt;&gt;&gt; rprob.exits
    rprob_entry_prob  mix_0  mix_1
    rprob_exit_prob     1.0    1.0
    0                 False  False
    1                  True  False
    2                 False   True
    3                  True  False
    4                 False   True
    ```
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.basic.RPROB.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>entry_prob, exit_prob, short_name='rprob', hide_params=None, hide_default=True, pass_lists=True, seed=None, forward_flex_2d=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the RPROB indicator using no input time series, and parameters <code>entry_prob</code> and <code>exit_prob</code>, to
produce output time series <code>entries</code> and <code>exits</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show column levels of parameters with the default value passed.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>entry_prob, exit_prob, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, hide_params=None, hide_default=True, pass_lists=True, seed=None, forward_flex_2d=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple RPROB indicators using function <code>comb_func</code>.
Run each indicator using input time series no input time series, and parameters <code>entry_prob</code> and <code>exit_prob</code>, to produce output time series <code>entries</code> and <code>exits</code>.</p>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>. Also accepts all
combinatoric iterators from itertools such as <code>itertools.combinations</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to True to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.basic.RPROB.run" href="#vectorbt.signals.basic.RPROB.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.basic.RPROB.entries"><code class="name">var <span class="ident fname">entries</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.entry_prob_array"><code class="name">var <span class="ident fname">entry_prob_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>entry_prob</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.entry_prob_loc"><code class="name">var <span class="ident fname">entry_prob_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>entry_prob</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.exit_prob_array"><code class="name">var <span class="ident fname">exit_prob_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>exit_prob</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.exit_prob_loc"><code class="name">var <span class="ident fname">exit_prob_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>exit_prob</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.exits"><code class="name">var <span class="ident fname">exits</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.tuple_loc"><code class="name">var <span class="ident fname">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>tuple</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.basic.RPROB.entries_and"><code class="name flex">
<span>def <span class="ident fname">entries_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.entries_or"><code class="name flex">
<span>def <span class="ident fname">entries_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.entries_xor"><code class="name flex">
<span>def <span class="ident fname">entries_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.exits_and"><code class="name flex">
<span>def <span class="ident fname">exits_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.exits_or"><code class="name flex">
<span>def <span class="ident fname">exits_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.exits_xor"><code class="name flex">
<span>def <span class="ident fname">exits_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROB.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>_self, entry_y=None, exit_y=None, entry_types=None, exit_types=None, entry_trace_kwargs=None, exit_trace_kwargs=None, fig=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.signals.basic.RPROB.entries" href="#vectorbt.signals.basic.RPROB.entries">RPROB.entries</a></code> and <code><a title="vectorbt.signals.basic.RPROB.exits" href="#vectorbt.signals.basic.RPROB.exits">RPROB.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entry_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot entry markers on.</dd>
<dt><strong><code>exit_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot exit markers on.</dd>
<dt><strong><code>entry_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Entry types in string format.</dd>
<dt><strong><code>exit_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Exit types in string format.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers">Signals_SRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.basic.RPROB.entries" href="#vectorbt.signals.basic.RPROB.entries">RPROB.entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers">Signals_SRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.basic.RPROB.exits" href="#vectorbt.signals.basic.RPROB.exits">RPROB.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_markers">Signals_SRAccessor.plot_as_markers()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(_self,
         entry_y=None,
         exit_y=None,
         entry_types=None,
         exit_types=None,
         entry_trace_kwargs=None,
         exit_trace_kwargs=None,
         fig=None,
         **kwargs):  # pragma: no cover
    if _self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if entry_trace_kwargs is None:
        entry_trace_kwargs = {}
    if exit_trace_kwargs is None:
        exit_trace_kwargs = {}
    if entry_types is not None:
        entry_trace_kwargs = merge_dicts(dict(
            customdata=entry_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), entry_trace_kwargs)
    if exit_types is not None:
        exit_trace_kwargs = merge_dicts(dict(
            customdata=exit_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), exit_trace_kwargs)
    if exit_only and iteratively:
        entries = _self.new_entries
    else:
        entries = _self.entries
    exits = _self.exits
    fig = entries.vbt.signals.plot_as_entry_markers(
        y=entry_y, trace_kwargs=entry_trace_kwargs, fig=fig, **kwargs)
    fig = exits.vbt.signals.plot_as_exit_markers(
        y=exit_y, trace_kwargs=exit_trace_kwargs, fig=fig, **kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.basic.RPROBEX"><code class="flex name class">
<span>class <span class="ident parent-fname">RPROBEX</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Random exit signal generator based on probabilities.</p>
<p>Generates <code>exits</code> based on <code>entries</code> and <code><a title="vectorbt.signals.nb.rand_by_prob_choice_nb" href="nb.html#vectorbt.signals.nb.rand_by_prob_choice_nb">rand_by_prob_choice_nb()</a></code>.</p>
<p>See <code><a title="vectorbt.signals.basic.RPROB" href="#vectorbt.signals.basic.RPROB">RPROB</a></code> for notes on parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RPROBEX(RPROBEX):
    &#34;&#34;&#34;Random exit signal generator based on probabilities.

    Generates `exits` based on `entries` and `vectorbt.signals.nb.rand_by_prob_choice_nb`.

    See `RPROB` for notes on parameters.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.basic.RPROBEX.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>entries, prob, short_name='rprobex', hide_params=None, hide_default=True, pass_lists=True, seed=None, forward_flex_2d=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the RPROBEX indicator using input time series <code>entries</code>, and parameters <code>prob</code>, to
produce output time series <code>exits</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show column levels of parameters with the default value passed.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROBEX.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>entries, prob, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, hide_params=None, hide_default=True, pass_lists=True, seed=None, forward_flex_2d=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple RPROBEX indicators using function <code>comb_func</code>.
Run each indicator using input time series input time series <code>entries</code>, and parameters <code>prob</code>, to produce output time series <code>exits</code>.</p>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>. Also accepts all
combinatoric iterators from itertools such as <code>itertools.combinations</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to True to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.basic.RPROBEX.run" href="#vectorbt.signals.basic.RPROBEX.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.basic.RPROBEX.entries"><code class="name">var <span class="ident fname">entries</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROBEX.exits"><code class="name">var <span class="ident fname">exits</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROBEX.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROBEX.prob_array"><code class="name">var <span class="ident fname">prob_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>prob</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROBEX.prob_loc"><code class="name">var <span class="ident fname">prob_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>prob</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROBEX.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.basic.RPROBEX.entries_and"><code class="name flex">
<span>def <span class="ident fname">entries_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROBEX.entries_or"><code class="name flex">
<span>def <span class="ident fname">entries_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROBEX.entries_xor"><code class="name flex">
<span>def <span class="ident fname">entries_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROBEX.exits_and"><code class="name flex">
<span>def <span class="ident fname">exits_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROBEX.exits_or"><code class="name flex">
<span>def <span class="ident fname">exits_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROBEX.exits_xor"><code class="name flex">
<span>def <span class="ident fname">exits_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.RPROBEX.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>_self, entry_y=None, exit_y=None, entry_types=None, exit_types=None, entry_trace_kwargs=None, exit_trace_kwargs=None, fig=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.signals.basic.RPROBEX.entries" href="#vectorbt.signals.basic.RPROBEX.entries">RPROBEX.entries</a></code> and <code><a title="vectorbt.signals.basic.RPROBEX.exits" href="#vectorbt.signals.basic.RPROBEX.exits">RPROBEX.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entry_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot entry markers on.</dd>
<dt><strong><code>exit_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot exit markers on.</dd>
<dt><strong><code>entry_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Entry types in string format.</dd>
<dt><strong><code>exit_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Exit types in string format.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers">Signals_SRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.basic.RPROBEX.entries" href="#vectorbt.signals.basic.RPROBEX.entries">RPROBEX.entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers">Signals_SRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.basic.RPROBEX.exits" href="#vectorbt.signals.basic.RPROBEX.exits">RPROBEX.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_markers">Signals_SRAccessor.plot_as_markers()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(_self,
         entry_y=None,
         exit_y=None,
         entry_types=None,
         exit_types=None,
         entry_trace_kwargs=None,
         exit_trace_kwargs=None,
         fig=None,
         **kwargs):  # pragma: no cover
    if _self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if entry_trace_kwargs is None:
        entry_trace_kwargs = {}
    if exit_trace_kwargs is None:
        exit_trace_kwargs = {}
    if entry_types is not None:
        entry_trace_kwargs = merge_dicts(dict(
            customdata=entry_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), entry_trace_kwargs)
    if exit_types is not None:
        exit_trace_kwargs = merge_dicts(dict(
            customdata=exit_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), exit_trace_kwargs)
    if exit_only and iteratively:
        entries = _self.new_entries
    else:
        entries = _self.entries
    exits = _self.exits
    fig = entries.vbt.signals.plot_as_entry_markers(
        y=entry_y, trace_kwargs=entry_trace_kwargs, fig=fig, **kwargs)
    fig = exits.vbt.signals.plot_as_exit_markers(
        y=exit_y, trace_kwargs=exit_trace_kwargs, fig=fig, **kwargs)

    return fig</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.signals.basic.STEX"><code class="flex name class">
<span>class <span class="ident parent-fname">STEX</span></span>
<span>(</span><span>wrapper, input_list, input_mapper, output_list, param_list, mapper_list, short_name, level_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Exit signal generator based on stop values.</p>
<p>Generates <code>exits</code> based on <code>entries</code> and <code><a title="vectorbt.signals.nb.stop_choice_nb" href="nb.html#vectorbt.signals.nb.stop_choice_nb">stop_choice_nb()</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>All parameters can be either a single value (per frame) or a NumPy array (per row, column,
or element). To generate multiple combinations, pass them as lists.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class STEX(STEX):
    &#34;&#34;&#34;Exit signal generator based on stop values.

    Generates `exits` based on `entries` and `vectorbt.signals.nb.stop_choice_nb`.

    !!! hint
        All parameters can be either a single value (per frame) or a NumPy array (per row, column,
        or element). To generate multiple combinations, pass them as lists.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.base.indexing.ParamIndexer</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.signals.basic.STEX.run"><code class="name flex">
<span>def <span class="ident fname">run</span></span>(<span>entries, ts, stop, trailing=False, short_name='stex', hide_params=None, hide_default=True, pass_lists=True, forward_flex_2d=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the STEX indicator using input time series <code>entries</code> and <code>ts</code>, and parameters <code>stop</code> and <code>trailing</code>, to
produce output time series <code>exits</code>.</p>
<p>Pass a list of parameter names <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show column levels of parameters with the default value passed.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.run_combs"><code class="name flex">
<span>def <span class="ident fname">run_combs</span></span>(<span>entries, ts, stop, trailing=False, r=2, param_product=False, comb_func=itertools.combinations, speed_up=True, short_names=None, hide_params=None, hide_default=True, pass_lists=True, forward_flex_2d=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple STEX indicators using function <code>comb_func</code>.
Run each indicator using input time series input time series <code>entries</code> and <code>ts</code>, and parameters <code>stop</code> and <code>trailing</code>, to produce output time series <code>exits</code>.</p>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>. Also accepts all
combinatoric iterators from itertools such as <code>itertools.combinations</code>.</p>
<p>Pass <code>r</code> to specify how many indicators to run. Pass <code>short_names</code> to specify the
short name for each indicator. Set <code>speed_up</code> to True to first compute raw outputs
for all parameters, and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.signals.basic.STEX.run" href="#vectorbt.signals.basic.STEX.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new indicators with ease.

Each indicator is basically a pipeline that:

* Accepts a list of time series objects (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, size of rolling window)
* Accepts other relevant arguments and keyword arguments
* Performs calculations to produce new time series objects (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies usage of `run_pipeline` by generating and pre-configuring
a new Python class with various methods for running the indicator. It has the following features:

* Accepts time series of any shape thanks to broadcasting
* Accepts arbitrary parameter combinations
* Supports pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
* Supports parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
* Exposes common signal generation methods for all inputs, outputs and properties, e.g., crossover

Consider the following price DataFrame:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

## IndicatorFactory

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     short_name=&#39;myma&#39;
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_above(myma.ma, crossed=True)
&gt;&gt;&gt; below_signals = myma.price_below(myma.ma, crossed=True)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, you provide
all the necessary information to build the facade of the indicator, such as input, parameter and
output names, and the actual calculation function. The factory then generates a self-contained
indicator class capable of running arbitrary configurations of inputs and parameters. To run any
configuration, you can either use the `run` method (as we did above) or the `run_combs` method.

### run method

The main method to run an indicator is `run` that accepts 1) input time series, 2) parameters,
and 3) other arguments that are accepted by the calculation function.

Input time series can have any shape as long as they are Series or DataFrames. Passing multiple time
series with different shapes will broadcast them to a single shape.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price1&#39;, &#39;price2&#39;],
...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
... ).from_apply_func(
...     lambda price1, price2, p1, p2: price1 * p1 + price2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
2020-01-01    11.0
2020-01-02    10.0
2020-01-03     9.0
2020-01-04     8.0
2020-01-05     7.0
Name: (1, 2, a, b), dtype: float64

&gt;&gt;&gt; myInd = MyInd.run(price, price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.output
custom_p1            1
custom_p2            2
               a     b
2020-01-01  11.0  15.0
2020-01-02  10.0  12.0
2020-01-03   9.0   9.0
2020-01-04   8.0   6.0
2020-01-05   7.0   3.0
```

Parameters are also flexible: they can be either single values, or arrays to run multiple
configurations at once. Multiple parameters will broadcast together to have the same length.
You can even set `param_product` to True to run all possible combinations of passed parameter values.

```python-repl
&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, 2)
&gt;&gt;&gt; myInd.p1_array
array([1])
&gt;&gt;&gt; myInd.p2_array
array([2])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], 1, [2, 3])
&gt;&gt;&gt; myInd.p1_array
array([1, 1])
&gt;&gt;&gt; myInd.p2_array
array([2, 3])

&gt;&gt;&gt; myInd = MyInd.run(price[&#39;a&#39;], price[&#39;b&#39;], [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; myInd.p1_array
array([1, 1, 2, 2])
&gt;&gt;&gt; myInd.p2_array
array([3, 4, 3, 4])
```

The output of the `run` method will be the instance of the indicator.
All outputs can be then accessed as variables of the instance.

### run_combs method

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters and returns multiple instances that can be compared with each other.
For example, this is useful to generate crossover signals of multiple moving averages.

```python-repl
&gt;&gt;&gt; myma1, myma2 = MyMA.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myma1.ma
myma_1_window                   2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myma2.ma
myma_2_window         3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myma1.ma_above(myma2.ma, crossed=True)
myma_1_window                           2             3
myma_2_window             3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

The main advantage is that it doesn&#39;t re-compute each combination thanks to caching.

### Comparison methods

For all our inputs in `input_names` and outputs in `output_names`, it created a bunch of comparison methods
for generating signals, such as `above`, `below` and `equal` (use `dir()`):

```python-repl
&#39;ma_above&#39;,
&#39;ma_below&#39;,
&#39;ma_equal&#39;,
&#39;price_above&#39;,
&#39;price_below&#39;,
&#39;price_equal&#39;,
```

Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time series objects with an
arbitrary array-like object, given their shapes can be broadcast together. You can also compare them
to multiple objects at once, for example:

```python-repl
&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above                         1.5                         2.5
myma_window               2             3             2             3
                a         b      a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False  False  False
2020-01-02     False   True  False  False  False   True  False  False
2020-01-03      True   True   True   True  False   True  False   True
2020-01-04      True   True   True   True   True  False   True   True
2020-01-05      True  False   True   True   True  False   True  False
```

### Indexing

`IndicatorFactory` also attaches pandas indexing to the indicator class:

```python-repl
&#39;iloc&#39;
&#39;loc&#39;
&#39;window_loc&#39;
&#39;xs&#39;
```

This makes accessing rows and columns by labels, integer positions, and parameters much easier.

```python-repl
&gt;&gt;&gt; myma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.factory.CustomIndicator at 0x7fa4b3e0c4e0&gt;

&gt;&gt;&gt; myma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64
```
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List
import itertools
import inspect
from collections import OrderedDict

from vectorbt.utils import checks
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.config import merge_dicts, Configured
from vectorbt.utils.random import set_seed
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.indexing import ParamIndexerFactory
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping


def flatten_param_tuples(param_tuples):
    &#34;&#34;&#34;Flattens a nested list of tuples using unzipping.&#34;&#34;&#34;
    param_list = []
    unzipped_tuples = zip(*param_tuples)
    for i, unzipped in enumerate(unzipped_tuples):
        unzipped = tuple(unzipped)
        if isinstance(unzipped[0], tuple):
            param_list.extend(flatten_param_tuples(unzipped))
        else:
            param_list.append(unzipped)
    return param_list</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.signals.basic.STEX.entries"><code class="name">var <span class="ident fname">entries</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.exits"><code class="name">var <span class="ident fname">exits</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(_self, output_name=output_name):
    &#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
    return _self.wrapper.wrap(getattr(_self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.level_names"><code class="name">var <span class="ident fname">level_names</span></code></dt>
<dd>
<div class="desc"><p>Column level names corresponding to each parameter (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._level_names)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.short_name"><code class="name">var <span class="ident fname">short_name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self: _self._short_name)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.stop_array"><code class="name">var <span class="ident fname">stop_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>stop</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.stop_loc"><code class="name">var <span class="ident fname">stop_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>stop</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.trailing_array"><code class="name">var <span class="ident fname">trailing_array</span></code></dt>
<dd>
<div class="desc"><p>Array of <code>trailing</code> combinations (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda _self, param_name=param_name: getattr(_self, f&#39;_{param_name}_array&#39;))</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.trailing_loc"><code class="name">var <span class="ident fname">trailing_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>trailing</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.ts"><code class="name">var <span class="ident fname">ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p>
<p>Will broadcast to match the shape of outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not is_caching_enabled(self.name, instance, **self.kwargs):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.tuple_loc"><code class="name">var <span class="ident fname">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter <code>tuple</code> using <code>pd.Series.loc</code>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self, param_name=param_name):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.basic.STEX.entries_and"><code class="name flex">
<span>def <span class="ident fname">entries_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.entries_or"><code class="name flex">
<span>def <span class="ident fname">entries_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.entries_xor"><code class="name flex">
<span>def <span class="ident fname">entries_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>entries XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.exits_and"><code class="name flex">
<span>def <span class="ident fname">exits_and</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits AND other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.exits_or"><code class="name flex">
<span>def <span class="ident fname">exits_or</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits OR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.exits_xor"><code class="name flex">
<span>def <span class="ident fname">exits_xor</span></span>(<span>_self, other, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>exits XOR other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bool_method(_self, other, level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    return combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.plot"><code class="name flex">
<span>def <span class="ident fname">plot</span></span>(<span>_self, entry_y=None, exit_y=None, entry_types=None, exit_types=None, entry_trace_kwargs=None, exit_trace_kwargs=None, fig=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code><a title="vectorbt.signals.basic.STEX.entries" href="#vectorbt.signals.basic.STEX.entries">STEX.entries</a></code> and <code><a title="vectorbt.signals.basic.STEX.exits" href="#vectorbt.signals.basic.STEX.exits">STEX.exits</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entry_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot entry markers on.</dd>
<dt><strong><code>exit_y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Y-axis values to plot exit markers on.</dd>
<dt><strong><code>entry_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Entry types in string format.</dd>
<dt><strong><code>exit_types</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Exit types in string format.</dd>
<dt><strong><code>entry_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_entry_markers">Signals_SRAccessor.plot_as_entry_markers()</a></code> for <code><a title="vectorbt.signals.basic.STEX.entries" href="#vectorbt.signals.basic.STEX.entries">STEX.entries</a></code>.</dd>
<dt><strong><code>exit_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to
<code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_exit_markers">Signals_SRAccessor.plot_as_exit_markers()</a></code> for <code><a title="vectorbt.signals.basic.STEX.exits" href="#vectorbt.signals.basic.STEX.exits">STEX.exits</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.signals.accessors.Signals_SRAccessor.plot_as_markers" href="accessors.html#vectorbt.signals.accessors.Signals_SRAccessor.plot_as_markers">Signals_SRAccessor.plot_as_markers()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(_self,
         entry_y=None,
         exit_y=None,
         entry_types=None,
         exit_types=None,
         entry_trace_kwargs=None,
         exit_trace_kwargs=None,
         fig=None,
         **kwargs):  # pragma: no cover
    if _self.wrapper.ndim &gt; 1:
        raise TypeError(&#34;Select a column first. Use indexing.&#34;)

    if entry_trace_kwargs is None:
        entry_trace_kwargs = {}
    if exit_trace_kwargs is None:
        exit_trace_kwargs = {}
    if entry_types is not None:
        entry_trace_kwargs = merge_dicts(dict(
            customdata=entry_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), entry_trace_kwargs)
    if exit_types is not None:
        exit_trace_kwargs = merge_dicts(dict(
            customdata=exit_types,
            hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
        ), exit_trace_kwargs)
    if exit_only and iteratively:
        entries = _self.new_entries
    else:
        entries = _self.entries
    exits = _self.exits
    fig = entries.vbt.signals.plot_as_entry_markers(
        y=entry_y, trace_kwargs=entry_trace_kwargs, fig=fig, **kwargs)
    fig = exits.vbt.signals.plot_as_exit_markers(
        y=exit_y, trace_kwargs=exit_trace_kwargs, fig=fig, **kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.ts_above"><code class="name flex">
<span>def <span class="ident fname">ts_above</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.ts_below"><code class="name flex">
<span>def <span class="ident fname">ts_below</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.signals.basic.STEX.ts_equal"><code class="name flex">
<span>def <span class="ident fname">ts_equal</span></span>(<span>_self, other, crossed=False, wait=0, after_false=True, level_name=None, prepend_name=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossed</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric_method(_self, other, crossed=False, wait=0, after_false=True,
                   level_name=None, prepend_name=prepend_name, **kwargs):
    if isinstance(other, _self.__class__):
        other = getattr(other, attr_name)
    if level_name is None:
        if prepend_name:
            if attr_name == _self.short_name:
                level_name = f&#39;{_self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{_self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(_self, attr_name),
        other,
        combine_func,
        level_name=level_name,
        **kwargs
    )
    if crossed:
        return out.vbt.signals.nst(wait + 1, after_false=after_false)
    return out</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABmtJREFUeNrsnD1vFEkQhtve+fIuax9gDDIHQubDSMiQOEByjERGxg+4iL9DRI6A4IhAAkLIIeV0BwEICQJbwpbshRXegDbmkAW2p96erp7qpiqxg9mveWuq3nqme8aWrlw3Gu3FuJ4CFUAF0FABVAANFUAF0FABVAANFUAF0FABVAANFUAF0FABko/M7WULqysLq8v046uryLsfM2aKeuyHlerhs2PQl79x8e33/yaMOQm80H6Q/Tj68Z2s6GQ5iwCXl99fe/eK+j2Om/5Z5N2XjJmmHvvi5R/3n/ShL//X2Zff/ztvzDz1VeuD7ObtI8YM6B/U7RdcJWhufY1+8NiE1Ov/BJb+WHEf79Smfwo9YP0TdhEvHv0/dWzx6QIvvPPoT+iDiomelCY8fgh8wTRw7H9vDwRI/6fPp6Hqb9M/LypGAaAODAvAGfMHN7b+TGEyo+mfl1S1fjsbOlmMvjUx4CU2922rB3re2FhedgUJgDXhKezNnyOnxsbsgaHJMfd56+9TWPWvulYDRgEgC7RtQ5GrlzcbZntDcxpp8oPMNgBstiqQbuHwG3qjzXhLUN+WINB9Wg2A/Ckq24FjRhHgFYC6oPlLGxLcZyMBjn4eYJfkGcYeAKUnt/vM8hJKf0cBZoYDE2csnltjdZ+2/cJDUtSeEkpPtL6h7pOC3jw14U2gCWMWyMZh5BwtYwLMn9rgc5/04SuoDRVF4iZ7Iyb3SWcPSZUglMTNHhnS2y/U3lHzE04AGAQhLgj1oHQBoPqzxR6c0t9RAF4SxzkJ92klyPZeqL07mJ9EShAaxCYMuU8IvbUgANaEwR+Ckjii+4Tarx2+6OjNgwC8JK7LmAqLF9a8p3+T9usoQNQkjuI+oXu/KHoT3wM4SRylAcDus2p6zcICoCQOK0GcJI4yhUHus5MV450stAAoiZMzCdcOAaj7LJtV/+htKEriagWA2q/NfQf05qMJIyQOnsI4Sdz+UxjqPptX/xA2VNaClH2bMGR+nNFbUiUIJXEe609eeetsvALAHZiNxNWmP91QfUNv7Qkwt77K5UENI4nbvwFA6Q8t+9FJuN4CWfcJXUxN0JvsHsBJ4o7P7CnAA5A9eEx/WADeBSmcJK7fHe3lPiH/U/gYvtwFmBl+itQy7dWEA6M32SWIeU2cB/dZ+ucqmAC9zS/Q8XJI3K43AyD36bbsx7MAcxvY3Ri5u8Nc3CfLj4l1EoZI3K4NwFYwehGzpT/Ly8gEkEPidp3CsPT3bX4cBVj4uMIoQMApDLr16BG9pVOCIBL36xR29zFkfirGOsH31nJI3K9T2IOn1PRvuOzHtwuKk8T91IShRz74RW+N54Ak1qRA8CcrKtYvI6YHcJK4nVOYrV30bRcc7MFdgHhJnED36SJApCRuZwOA3OfWsh/m9JdUgthI3M4pDHKfJX/6YwJESuJ2TmF098mE3hoJECmJ+zGFQZt+WYev6CdhCET/mMLo7ZeVPQQSgJXEOSxIgTb9FkGqPyxApCRuO+jLnpvsuPtdShAUdgqDNv36WvTZsgCsJO7FP9jWMPqtR2701swFRUjithsAvf023HHHPAdESOLsFAa5z5DtV1IPAC/6f9+Qx+DuiJ7+AdCbuwCiSBz9dpi9AgD3Gbb9YgJESuIw9NbJ5ArAG2AHRjcnUaIMXv0xAUSROPhBWbVnwdOOO0YBElsTJ6H6xzoJw49JrD0FAdFbIAHkkDhSA6ravFqpAkRN4mrYQxGDAKkG97KfdgSAOzDSAlESV1N/ym67GUB2QawkrqWT4H3HHecckOJzmoqWhi9hPQAcgOgkbv9weNB2awLIely6p0dEtDh8wQLEuzt1zy4VatlPgjbUC4krKimohCQAL4mbBgVoTOL4dtxxCZAYiZNgfmItQc1JXLvoLYQAMAiaBI5tTuKCLfr0KQAviQtoRsIv+0nQBTVjDxOtswd2ASSTuLwSZw9oLigJEtfKsh9Pc0ASJE6U+xTTA0KRuDA77lgESIPElSLTnyRAAiRODnqL3oa6kThpwxcmAErisEGMn8RJYw+wACiJk7YmpZBa/eMrQQ4kzs69cshzCAHgMZiZxLW+7KfeNNYesVz17p2+QK8/xWvk84fAJGwbAOompaG3XVJ26cp1o6E9QAXQUAFUAA0VQAXQUAFUAA0VQAXQUAFUAA0VQAXQUAFUAA2++CrAAE3lth2zPPJAAAAAAElFTkSuQmCC"/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.signals" href="index.html">vectorbt.signals</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="vectorbt.signals.basic.advstex_config" href="#vectorbt.signals.basic.advstex_config">advstex_config</a></code></li>
<li><code><a title="vectorbt.signals.basic.advstex_func_config" href="#vectorbt.signals.basic.advstex_func_config">advstex_func_config</a></code></li>
<li><code><a title="vectorbt.signals.basic.flex_col_param_config" href="#vectorbt.signals.basic.flex_col_param_config">flex_col_param_config</a></code></li>
<li><code><a title="vectorbt.signals.basic.flex_elem_param_config" href="#vectorbt.signals.basic.flex_elem_param_config">flex_elem_param_config</a></code></li>
<li><code><a title="vectorbt.signals.basic.rprobex_config" href="#vectorbt.signals.basic.rprobex_config">rprobex_config</a></code></li>
<li><code><a title="vectorbt.signals.basic.rprobex_func_config" href="#vectorbt.signals.basic.rprobex_func_config">rprobex_func_config</a></code></li>
<li><code><a title="vectorbt.signals.basic.stex_config" href="#vectorbt.signals.basic.stex_config">stex_config</a></code></li>
<li><code><a title="vectorbt.signals.basic.stex_func_config" href="#vectorbt.signals.basic.stex_func_config">stex_func_config</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.signals.basic.ADVSTEX" href="#vectorbt.signals.basic.ADVSTEX">ADVSTEX</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.basic.ADVSTEX.close" href="#vectorbt.signals.basic.ADVSTEX.close">close</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.close_above" href="#vectorbt.signals.basic.ADVSTEX.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.close_below" href="#vectorbt.signals.basic.ADVSTEX.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.close_equal" href="#vectorbt.signals.basic.ADVSTEX.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.entries" href="#vectorbt.signals.basic.ADVSTEX.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.entries_and" href="#vectorbt.signals.basic.ADVSTEX.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.entries_or" href="#vectorbt.signals.basic.ADVSTEX.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.entries_xor" href="#vectorbt.signals.basic.ADVSTEX.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.exits" href="#vectorbt.signals.basic.ADVSTEX.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.exits_and" href="#vectorbt.signals.basic.ADVSTEX.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.exits_or" href="#vectorbt.signals.basic.ADVSTEX.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.exits_xor" href="#vectorbt.signals.basic.ADVSTEX.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.high" href="#vectorbt.signals.basic.ADVSTEX.high">high</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.high_above" href="#vectorbt.signals.basic.ADVSTEX.high_above">high_above</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.high_below" href="#vectorbt.signals.basic.ADVSTEX.high_below">high_below</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.high_equal" href="#vectorbt.signals.basic.ADVSTEX.high_equal">high_equal</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.hit_price" href="#vectorbt.signals.basic.ADVSTEX.hit_price">hit_price</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.hit_price_above" href="#vectorbt.signals.basic.ADVSTEX.hit_price_above">hit_price_above</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.hit_price_below" href="#vectorbt.signals.basic.ADVSTEX.hit_price_below">hit_price_below</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.hit_price_equal" href="#vectorbt.signals.basic.ADVSTEX.hit_price_equal">hit_price_equal</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.level_names" href="#vectorbt.signals.basic.ADVSTEX.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.low" href="#vectorbt.signals.basic.ADVSTEX.low">low</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.low_above" href="#vectorbt.signals.basic.ADVSTEX.low_above">low_above</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.low_below" href="#vectorbt.signals.basic.ADVSTEX.low_below">low_below</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.low_equal" href="#vectorbt.signals.basic.ADVSTEX.low_equal">low_equal</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.open" href="#vectorbt.signals.basic.ADVSTEX.open">open</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.open_above" href="#vectorbt.signals.basic.ADVSTEX.open_above">open_above</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.open_below" href="#vectorbt.signals.basic.ADVSTEX.open_below">open_below</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.open_equal" href="#vectorbt.signals.basic.ADVSTEX.open_equal">open_equal</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.plot" href="#vectorbt.signals.basic.ADVSTEX.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.run" href="#vectorbt.signals.basic.ADVSTEX.run">run</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.run_combs" href="#vectorbt.signals.basic.ADVSTEX.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.short_name" href="#vectorbt.signals.basic.ADVSTEX.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.sl_stop_array" href="#vectorbt.signals.basic.ADVSTEX.sl_stop_array">sl_stop_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.sl_stop_loc" href="#vectorbt.signals.basic.ADVSTEX.sl_stop_loc">sl_stop_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.stop_type" href="#vectorbt.signals.basic.ADVSTEX.stop_type">stop_type</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.stop_type_readable" href="#vectorbt.signals.basic.ADVSTEX.stop_type_readable">stop_type_readable</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.tp_stop_array" href="#vectorbt.signals.basic.ADVSTEX.tp_stop_array">tp_stop_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.tp_stop_loc" href="#vectorbt.signals.basic.ADVSTEX.tp_stop_loc">tp_stop_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.ts_stop_array" href="#vectorbt.signals.basic.ADVSTEX.ts_stop_array">ts_stop_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.ts_stop_loc" href="#vectorbt.signals.basic.ADVSTEX.ts_stop_loc">ts_stop_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.ADVSTEX.tuple_loc" href="#vectorbt.signals.basic.ADVSTEX.tuple_loc">tuple_loc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.basic.IADVSTEX" href="#vectorbt.signals.basic.IADVSTEX">IADVSTEX</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.basic.IADVSTEX.close" href="#vectorbt.signals.basic.IADVSTEX.close">close</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.close_above" href="#vectorbt.signals.basic.IADVSTEX.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.close_below" href="#vectorbt.signals.basic.IADVSTEX.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.close_equal" href="#vectorbt.signals.basic.IADVSTEX.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.entries" href="#vectorbt.signals.basic.IADVSTEX.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.entries_and" href="#vectorbt.signals.basic.IADVSTEX.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.entries_or" href="#vectorbt.signals.basic.IADVSTEX.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.entries_xor" href="#vectorbt.signals.basic.IADVSTEX.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.exits" href="#vectorbt.signals.basic.IADVSTEX.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.exits_and" href="#vectorbt.signals.basic.IADVSTEX.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.exits_or" href="#vectorbt.signals.basic.IADVSTEX.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.exits_xor" href="#vectorbt.signals.basic.IADVSTEX.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.high" href="#vectorbt.signals.basic.IADVSTEX.high">high</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.high_above" href="#vectorbt.signals.basic.IADVSTEX.high_above">high_above</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.high_below" href="#vectorbt.signals.basic.IADVSTEX.high_below">high_below</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.high_equal" href="#vectorbt.signals.basic.IADVSTEX.high_equal">high_equal</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.hit_price" href="#vectorbt.signals.basic.IADVSTEX.hit_price">hit_price</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.hit_price_above" href="#vectorbt.signals.basic.IADVSTEX.hit_price_above">hit_price_above</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.hit_price_below" href="#vectorbt.signals.basic.IADVSTEX.hit_price_below">hit_price_below</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.hit_price_equal" href="#vectorbt.signals.basic.IADVSTEX.hit_price_equal">hit_price_equal</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.level_names" href="#vectorbt.signals.basic.IADVSTEX.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.low" href="#vectorbt.signals.basic.IADVSTEX.low">low</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.low_above" href="#vectorbt.signals.basic.IADVSTEX.low_above">low_above</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.low_below" href="#vectorbt.signals.basic.IADVSTEX.low_below">low_below</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.low_equal" href="#vectorbt.signals.basic.IADVSTEX.low_equal">low_equal</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.new_entries" href="#vectorbt.signals.basic.IADVSTEX.new_entries">new_entries</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.new_entries_and" href="#vectorbt.signals.basic.IADVSTEX.new_entries_and">new_entries_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.new_entries_or" href="#vectorbt.signals.basic.IADVSTEX.new_entries_or">new_entries_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.new_entries_xor" href="#vectorbt.signals.basic.IADVSTEX.new_entries_xor">new_entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.open" href="#vectorbt.signals.basic.IADVSTEX.open">open</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.open_above" href="#vectorbt.signals.basic.IADVSTEX.open_above">open_above</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.open_below" href="#vectorbt.signals.basic.IADVSTEX.open_below">open_below</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.open_equal" href="#vectorbt.signals.basic.IADVSTEX.open_equal">open_equal</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.plot" href="#vectorbt.signals.basic.IADVSTEX.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.run" href="#vectorbt.signals.basic.IADVSTEX.run">run</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.run_combs" href="#vectorbt.signals.basic.IADVSTEX.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.short_name" href="#vectorbt.signals.basic.IADVSTEX.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.sl_stop_array" href="#vectorbt.signals.basic.IADVSTEX.sl_stop_array">sl_stop_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.sl_stop_loc" href="#vectorbt.signals.basic.IADVSTEX.sl_stop_loc">sl_stop_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.stop_type" href="#vectorbt.signals.basic.IADVSTEX.stop_type">stop_type</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.stop_type_readable" href="#vectorbt.signals.basic.IADVSTEX.stop_type_readable">stop_type_readable</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.tp_stop_array" href="#vectorbt.signals.basic.IADVSTEX.tp_stop_array">tp_stop_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.tp_stop_loc" href="#vectorbt.signals.basic.IADVSTEX.tp_stop_loc">tp_stop_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.ts_stop_array" href="#vectorbt.signals.basic.IADVSTEX.ts_stop_array">ts_stop_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.ts_stop_loc" href="#vectorbt.signals.basic.IADVSTEX.ts_stop_loc">ts_stop_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.IADVSTEX.tuple_loc" href="#vectorbt.signals.basic.IADVSTEX.tuple_loc">tuple_loc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.basic.IRPROBEX" href="#vectorbt.signals.basic.IRPROBEX">IRPROBEX</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.basic.IRPROBEX.entries" href="#vectorbt.signals.basic.IRPROBEX.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.entries_and" href="#vectorbt.signals.basic.IRPROBEX.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.entries_or" href="#vectorbt.signals.basic.IRPROBEX.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.entries_xor" href="#vectorbt.signals.basic.IRPROBEX.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.exits" href="#vectorbt.signals.basic.IRPROBEX.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.exits_and" href="#vectorbt.signals.basic.IRPROBEX.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.exits_or" href="#vectorbt.signals.basic.IRPROBEX.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.exits_xor" href="#vectorbt.signals.basic.IRPROBEX.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.level_names" href="#vectorbt.signals.basic.IRPROBEX.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.new_entries" href="#vectorbt.signals.basic.IRPROBEX.new_entries">new_entries</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.new_entries_and" href="#vectorbt.signals.basic.IRPROBEX.new_entries_and">new_entries_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.new_entries_or" href="#vectorbt.signals.basic.IRPROBEX.new_entries_or">new_entries_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.new_entries_xor" href="#vectorbt.signals.basic.IRPROBEX.new_entries_xor">new_entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.plot" href="#vectorbt.signals.basic.IRPROBEX.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.prob_array" href="#vectorbt.signals.basic.IRPROBEX.prob_array">prob_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.prob_loc" href="#vectorbt.signals.basic.IRPROBEX.prob_loc">prob_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.run" href="#vectorbt.signals.basic.IRPROBEX.run">run</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.run_combs" href="#vectorbt.signals.basic.IRPROBEX.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.signals.basic.IRPROBEX.short_name" href="#vectorbt.signals.basic.IRPROBEX.short_name">short_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.basic.ISTEX" href="#vectorbt.signals.basic.ISTEX">ISTEX</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.basic.ISTEX.entries" href="#vectorbt.signals.basic.ISTEX.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.entries_and" href="#vectorbt.signals.basic.ISTEX.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.entries_or" href="#vectorbt.signals.basic.ISTEX.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.entries_xor" href="#vectorbt.signals.basic.ISTEX.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.exits" href="#vectorbt.signals.basic.ISTEX.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.exits_and" href="#vectorbt.signals.basic.ISTEX.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.exits_or" href="#vectorbt.signals.basic.ISTEX.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.exits_xor" href="#vectorbt.signals.basic.ISTEX.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.level_names" href="#vectorbt.signals.basic.ISTEX.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.new_entries" href="#vectorbt.signals.basic.ISTEX.new_entries">new_entries</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.new_entries_and" href="#vectorbt.signals.basic.ISTEX.new_entries_and">new_entries_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.new_entries_or" href="#vectorbt.signals.basic.ISTEX.new_entries_or">new_entries_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.new_entries_xor" href="#vectorbt.signals.basic.ISTEX.new_entries_xor">new_entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.plot" href="#vectorbt.signals.basic.ISTEX.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.run" href="#vectorbt.signals.basic.ISTEX.run">run</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.run_combs" href="#vectorbt.signals.basic.ISTEX.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.short_name" href="#vectorbt.signals.basic.ISTEX.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.stop_array" href="#vectorbt.signals.basic.ISTEX.stop_array">stop_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.stop_loc" href="#vectorbt.signals.basic.ISTEX.stop_loc">stop_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.trailing_array" href="#vectorbt.signals.basic.ISTEX.trailing_array">trailing_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.trailing_loc" href="#vectorbt.signals.basic.ISTEX.trailing_loc">trailing_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.ts" href="#vectorbt.signals.basic.ISTEX.ts">ts</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.ts_above" href="#vectorbt.signals.basic.ISTEX.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.ts_below" href="#vectorbt.signals.basic.ISTEX.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.ts_equal" href="#vectorbt.signals.basic.ISTEX.ts_equal">ts_equal</a></code></li>
<li><code><a title="vectorbt.signals.basic.ISTEX.tuple_loc" href="#vectorbt.signals.basic.ISTEX.tuple_loc">tuple_loc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.basic.RAND" href="#vectorbt.signals.basic.RAND">RAND</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.basic.RAND.entries" href="#vectorbt.signals.basic.RAND.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.basic.RAND.entries_and" href="#vectorbt.signals.basic.RAND.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.RAND.entries_or" href="#vectorbt.signals.basic.RAND.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.RAND.entries_xor" href="#vectorbt.signals.basic.RAND.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.RAND.exits" href="#vectorbt.signals.basic.RAND.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.basic.RAND.exits_and" href="#vectorbt.signals.basic.RAND.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.RAND.exits_or" href="#vectorbt.signals.basic.RAND.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.RAND.exits_xor" href="#vectorbt.signals.basic.RAND.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.RAND.level_names" href="#vectorbt.signals.basic.RAND.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.signals.basic.RAND.n_array" href="#vectorbt.signals.basic.RAND.n_array">n_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.RAND.n_loc" href="#vectorbt.signals.basic.RAND.n_loc">n_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.RAND.plot" href="#vectorbt.signals.basic.RAND.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.basic.RAND.run" href="#vectorbt.signals.basic.RAND.run">run</a></code></li>
<li><code><a title="vectorbt.signals.basic.RAND.run_combs" href="#vectorbt.signals.basic.RAND.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.signals.basic.RAND.short_name" href="#vectorbt.signals.basic.RAND.short_name">short_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.basic.RPROB" href="#vectorbt.signals.basic.RPROB">RPROB</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.basic.RPROB.entries" href="#vectorbt.signals.basic.RPROB.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.entries_and" href="#vectorbt.signals.basic.RPROB.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.entries_or" href="#vectorbt.signals.basic.RPROB.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.entries_xor" href="#vectorbt.signals.basic.RPROB.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.entry_prob_array" href="#vectorbt.signals.basic.RPROB.entry_prob_array">entry_prob_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.entry_prob_loc" href="#vectorbt.signals.basic.RPROB.entry_prob_loc">entry_prob_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.exit_prob_array" href="#vectorbt.signals.basic.RPROB.exit_prob_array">exit_prob_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.exit_prob_loc" href="#vectorbt.signals.basic.RPROB.exit_prob_loc">exit_prob_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.exits" href="#vectorbt.signals.basic.RPROB.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.exits_and" href="#vectorbt.signals.basic.RPROB.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.exits_or" href="#vectorbt.signals.basic.RPROB.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.exits_xor" href="#vectorbt.signals.basic.RPROB.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.level_names" href="#vectorbt.signals.basic.RPROB.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.plot" href="#vectorbt.signals.basic.RPROB.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.run" href="#vectorbt.signals.basic.RPROB.run">run</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.run_combs" href="#vectorbt.signals.basic.RPROB.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.short_name" href="#vectorbt.signals.basic.RPROB.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROB.tuple_loc" href="#vectorbt.signals.basic.RPROB.tuple_loc">tuple_loc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.basic.RPROBEX" href="#vectorbt.signals.basic.RPROBEX">RPROBEX</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.basic.RPROBEX.entries" href="#vectorbt.signals.basic.RPROBEX.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROBEX.entries_and" href="#vectorbt.signals.basic.RPROBEX.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROBEX.entries_or" href="#vectorbt.signals.basic.RPROBEX.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROBEX.entries_xor" href="#vectorbt.signals.basic.RPROBEX.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROBEX.exits" href="#vectorbt.signals.basic.RPROBEX.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROBEX.exits_and" href="#vectorbt.signals.basic.RPROBEX.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROBEX.exits_or" href="#vectorbt.signals.basic.RPROBEX.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROBEX.exits_xor" href="#vectorbt.signals.basic.RPROBEX.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROBEX.level_names" href="#vectorbt.signals.basic.RPROBEX.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROBEX.plot" href="#vectorbt.signals.basic.RPROBEX.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROBEX.prob_array" href="#vectorbt.signals.basic.RPROBEX.prob_array">prob_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROBEX.prob_loc" href="#vectorbt.signals.basic.RPROBEX.prob_loc">prob_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROBEX.run" href="#vectorbt.signals.basic.RPROBEX.run">run</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROBEX.run_combs" href="#vectorbt.signals.basic.RPROBEX.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.signals.basic.RPROBEX.short_name" href="#vectorbt.signals.basic.RPROBEX.short_name">short_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.signals.basic.STEX" href="#vectorbt.signals.basic.STEX">STEX</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.signals.basic.STEX.entries" href="#vectorbt.signals.basic.STEX.entries">entries</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.entries_and" href="#vectorbt.signals.basic.STEX.entries_and">entries_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.entries_or" href="#vectorbt.signals.basic.STEX.entries_or">entries_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.entries_xor" href="#vectorbt.signals.basic.STEX.entries_xor">entries_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.exits" href="#vectorbt.signals.basic.STEX.exits">exits</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.exits_and" href="#vectorbt.signals.basic.STEX.exits_and">exits_and</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.exits_or" href="#vectorbt.signals.basic.STEX.exits_or">exits_or</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.exits_xor" href="#vectorbt.signals.basic.STEX.exits_xor">exits_xor</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.level_names" href="#vectorbt.signals.basic.STEX.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.plot" href="#vectorbt.signals.basic.STEX.plot">plot</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.run" href="#vectorbt.signals.basic.STEX.run">run</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.run_combs" href="#vectorbt.signals.basic.STEX.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.short_name" href="#vectorbt.signals.basic.STEX.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.stop_array" href="#vectorbt.signals.basic.STEX.stop_array">stop_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.stop_loc" href="#vectorbt.signals.basic.STEX.stop_loc">stop_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.trailing_array" href="#vectorbt.signals.basic.STEX.trailing_array">trailing_array</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.trailing_loc" href="#vectorbt.signals.basic.STEX.trailing_loc">trailing_loc</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.ts" href="#vectorbt.signals.basic.STEX.ts">ts</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.ts_above" href="#vectorbt.signals.basic.STEX.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.ts_below" href="#vectorbt.signals.basic.STEX.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.ts_equal" href="#vectorbt.signals.basic.STEX.ts_equal">ts_equal</a></code></li>
<li><code><a title="vectorbt.signals.basic.STEX.tuple_loc" href="#vectorbt.signals.basic.STEX.tuple_loc">tuple_loc</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>