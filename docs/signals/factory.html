<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.signals.factory API documentation</title>
<meta name="description" content="A factory for building new signal generators with ease." />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3B4556}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="mask-icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.signals.factory</code></h1>
</header>
<section id="section-intro">
<p>A factory for building new signal generators with ease.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A factory for building new signal generators with ease.&#34;&#34;&#34;

import numpy as np
from numba import njit
from numba.typed import List
import inspect

from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts
from vectorbt.base import combine_fns
from vectorbt.indicators.factory import IndicatorFactory, to_typed_list
from vectorbt.signals.nb import generate_ex_nb, generate_enex_nb, first_choice_nb


class SignalFactory(IndicatorFactory):
    &#34;&#34;&#34;A factory for building signal generators.

    Extends `vectorbt.indicators.factory.IndicatorFactory` with choice functions.

    Generates a fixed number of outputs (see arguments). If you need to generate other outputs,
    use in-place outputs (via `in_output_names`).

    Args:
        exit_only (bool): Whether to generate exit signals only.

            If True, uses `entries` as input and `exits` as output.
            Otherwise, uses `entries` and `exits` as outputs.
        iteratively (bool): Whether to use entries to iteratively generate new entries and exits.

            If True, uses `entries` as input and `new_entries` and `exits` as outputs.

    Other arguments are passed to `vectorbt.indicators.factory.IndicatorFactory`.
    ```&#34;&#34;&#34;

    def __init__(self,
                 *args,
                 class_name=&#39;CustomSignals&#39;,
                 input_names=None,
                 attr_settings=None,
                 exit_only=False,
                 iteratively=False,
                 **kwargs):
        if input_names is None:
            input_names = []
        if attr_settings is None:
            attr_settings = {}
        if iteratively:
            exit_only = True
        if exit_only:
            if len(input_names) &gt; 0:
                if input_names[0] != &#39;entries&#39;:
                    input_names = [&#39;entries&#39;] + input_names
            else:
                input_names = [&#39;entries&#39;]
            output_names = [&#39;exits&#39;]
            if iteratively:
                output_names = [&#39;new_entries&#39;] + output_names
                attr_settings[&#39;new_entries&#39;] = dict(dtype=np.bool)
        else:
            output_names = [&#39;entries&#39;, &#39;exits&#39;]
        attr_settings[&#39;entries&#39;] = dict(dtype=np.bool)
        attr_settings[&#39;exits&#39;] = dict(dtype=np.bool)
        IndicatorFactory.__init__(
            self, *args,
            class_name=class_name,
            input_names=input_names,
            output_names=output_names,
            attr_settings=attr_settings,
            **kwargs
        )
        self.exit_only = exit_only
        self.iteratively = iteratively

        def plot(_self,
                 entry_y=None,
                 exit_y=None,
                 entry_types=None,
                 exit_types=None,
                 entry_trace_kwargs=None,
                 exit_trace_kwargs=None,
                 fig=None,
                 **kwargs):  # pragma: no cover
            if _self.wrapper.ndim &gt; 1:
                raise TypeError(&#34;Select a column first. Use indexing.&#34;)

            if entry_trace_kwargs is None:
                entry_trace_kwargs = {}
            if exit_trace_kwargs is None:
                exit_trace_kwargs = {}
            if entry_types is not None:
                entry_trace_kwargs = merge_dicts(dict(
                    customdata=entry_types,
                    hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
                ), entry_trace_kwargs)
            if exit_types is not None:
                exit_trace_kwargs = merge_dicts(dict(
                    customdata=exit_types,
                    hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
                ), exit_trace_kwargs)
            if exit_only and iteratively:
                entries = _self.new_entries
            else:
                entries = _self.entries
            exits = _self.exits
            fig = entries.vbt.signals.plot_as_entry_markers(
                y=entry_y, trace_kwargs=entry_trace_kwargs, fig=fig, **kwargs)
            fig = exits.vbt.signals.plot_as_exit_markers(
                y=exit_y, trace_kwargs=exit_trace_kwargs, fig=fig, **kwargs)

            return fig

        plot.__doc__ = &#34;&#34;&#34;Plot `{0}.{1}` and `{0}.exits`.

        Args:
            entry_y (array_like): Y-axis values to plot entry markers on.
            exit_y (array_like): Y-axis values to plot exit markers on.
            entry_types (array_like): Entry types in string format.
            exit_types (array_like): Exit types in string format.
            entry_trace_kwargs (dict): Keyword arguments passed to \
            `vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers` for `{0}.{1}`.
            exit_trace_kwargs (dict): Keyword arguments passed to \
            `vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers` for `{0}.exits`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **kwargs: Keyword arguments passed to `vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers`.
        &#34;&#34;&#34;.format(
            class_name, &#39;new_entries&#39; if exit_only and iteratively else &#39;entries&#39;
        )

        setattr(self.CustomIndicator, &#39;plot&#39;, plot)

    def from_choice_func(
            self,
            entry_choice_func=None,
            exit_choice_func=None,
            cache_func=None,
            entry_settings=None,
            exit_settings=None,
            cache_settings=None,
            **kwargs):
        &#34;&#34;&#34;Build signal generator class around entry and exit choice functions.

        A choice function is simply a function that returns indices of signals.
        There are two types of it: entry choice function and exit choice function.
        Each choice function takes broadcast time series, broadcast in-place output time series,
        broadcast parameter arrays, and other arguments, and returns an array of indices
        corresponding to chosen signals. See `vectorbt.signals.nb.generate_nb`.

        If `exit_only` is True, calls `vectorbt.signals.nb.generate_ex_nb`.
        If `exit_only` is False or `iteratively` is True, calls `vectorbt.signals.nb.generate_enex_nb`.

        Args:
            entry_choice_func (callable): `choice_func_nb` that returns indices of entries.

                If `exit_only` is True, automatically set to `vectorbt.signals.nb.first_choice_nb`.
            exit_choice_func (callable): `choice_func_nb` that returns indices of exits.
            cache_func (callable): A caching function to preprocess data beforehand.

                All returned objects will be passed as last arguments to choice functions.
            entry_settings (dict): Settings dict for `entry_choice_func`.
            exit_settings (dict): Settings dict for `exit_choice_func`.
            cache_settings (dict): Settings dict for `cache_func`.
            **kwargs: Keyword arguments passed to `IndicatorFactory.from_custom_func`.

        !!! note
            Choice functions should be Numba-compiled.

            Which inputs, parameters and arguments to pass to each function should be
            explicitly indicated in the function&#39;s settings dict. By default, nothing is passed.

        Settings dict of each function can have the following keys:

        Attributes:
            pass_inputs (list of str): Input names to pass to the choice function.

                Defaults to []. Order matters. Each name must be in `input_names`.
            pass_in_outputs (list of str): In-place output names to pass to the choice function.

                Defaults to []. Order matters. Each name must be in `in_output_names`.
            pass_params (list of str): Parameter names to pass to the choice function.

                Defaults to []. Order matters. Each name must be in `param_names`.
            pass_kwargs (list of str or list of tuple): Keyword arguments from `kwargs` dict to
                pass as positional arguments to the choice function.

                Defaults to []. Order matters.

                If any element is a tuple, should contain the name and the default value.
                If any element is a string, the default value is None.

                Built-in keys include:

                * `input_shape`: Input shape if no input time series passed.
                    Default is provided by the pipeline if `forward_input_shape` is True.
                * `wait`: Number of ticks to wait before placing signals.
                    Default is 1.
                * `first`: Whether to stop as soon as the first exit signal is found.
                    Default is True.
                * `temp_idx_arr`: Empty integer array used to temporarily store indices.
                    Default is an automatically generated array of shape `input_shape[0]`.

                    You can also pass `temp_idx_arr1`, `temp_idx_arr2`, etc. to generate multiple.
                * `flex_2d`: See `vectorbt.base.reshape_fns.flex_choose_i_and_col_nb`.
                    Default is provided by the pipeline if `forward_flex_2d` is True.
            pass_cache (bool): Whether to pass cache from `cache_func` to the choice function.

                Defaults to False. Cache is passed unpacked.

        The following arguments can be passed to `run` and `run_combs` methods:

        Args:
            *args: Should be used instead of `exit_args` when `exit_only` is True.
            entry_args (tuple): Arguments passed to the entry choice function.
            exit_args (tuple): Arguments passed to the exit choice function.
            cache_args (tuple): Arguments passed to the cache function.
            entry_kwargs (tuple): Settings for the entry choice function. Also contains arguments
                passed as positional if in `pass_kwargs`.
            exit_kwargs (tuple): Settings for the exit choice function. Also contains arguments
                passed as positional if in `pass_kwargs`.
            cache_kwargs (tuple): Settings for the cache function. Also contains arguments
                passed as positional if in `pass_kwargs`.
            return_cache (bool): Whether to return only cache.
            use_cache (any): Cache to use.
            **kwargs: Should be used instead of `exit_kwargs` when `exit_only` is True.

        For more arguments, see `vectorbt.indicators.factory.run_pipeline`.

        ## Example

        Take the first entry and place an exit after waiting `n` ticks. Find the next entry and repeat.
        Test three different `n` values.

        ```python-repl
        &gt;&gt;&gt; from numba import njit
        &gt;&gt;&gt; from vectorbt.signals.factory import SignalFactory

        &gt;&gt;&gt; @njit
        ... def wait_choice_nb(from_i, to_i, col, n, temp_idx_arr):
        ...     temp_idx_arr[0] = from_i + n  # index of next exit
        ...     if temp_idx_arr[0] &lt; to_i:
        ...         return temp_idx_arr[:1]
        ...     return temp_idx_arr[:0]  # must return array anyway

        &gt;&gt;&gt; # Build signal generator
        &gt;&gt;&gt; MySignals = SignalFactory(
        ...     param_names=[&#39;n&#39;],
        ...     iteratively=True
        ... ).from_choice_func(
        ...     exit_choice_func=wait_choice_nb,
        ...     exit_settings=dict(
        ...         pass_params=[&#39;n&#39;],
        ...         pass_kwargs=[&#39;temp_idx_arr&#39;]  # built-in kwarg
        ...     )
        ... )

        &gt;&gt;&gt; # Run signal generator
        &gt;&gt;&gt; entries = [True, True, True, True, True]
        &gt;&gt;&gt; my_sig = MySignals.run(entries, [0, 1, 2])

        &gt;&gt;&gt; my_sig.entries  # input entries
        custom_n     0     1     2
        0         True  True  True
        1         True  True  True
        2         True  True  True
        3         True  True  True
        4         True  True  True

        &gt;&gt;&gt; my_sig.new_entries  # output entries
        custom_n      0      1      2
        0          True   True   True
        1         False  False  False
        2          True  False  False
        3         False   True  False
        4          True  False   True

        &gt;&gt;&gt; my_sig.exits  # output exits
        custom_n      0      1      2
        0         False  False  False
        1          True  False  False
        2         False   True  False
        3          True  False   True
        4         False  False  False
        ```

        To combine multiple iterative signals, you would need to create a choice function
        that does that. Here is an example of combining two random generators using &#34;OR&#34; rule:

        ```python-repl
        &gt;&gt;&gt; from numba import njit
        &gt;&gt;&gt; from collections import namedtuple
        &gt;&gt;&gt; from vectorbt.signals.factory import SignalFactory
        &gt;&gt;&gt; from vectorbt.signals.nb import rand_by_prob_choice_nb
        &gt;&gt;&gt; from vectorbt.signals.basic import flex_elem_param_config

        &gt;&gt;&gt; # Enum to distinguish random generators
        &gt;&gt;&gt; RandType = namedtuple(&#39;RandType&#39;, [&#39;R1&#39;, &#39;R2&#39;])(0, 1)

        &gt;&gt;&gt; # Define exit choice function
        &gt;&gt;&gt; @njit
        ... def rand_exit_choice_nb(from_i, to_i, col, rand_type_out, prob1,
        ...                         prob2, temp_idx_arr1, temp_idx_arr2, flex_2d):
        ...     idxs1 = rand_by_prob_choice_nb(
        ...         from_i, to_i, col, prob1, True, temp_idx_arr1, flex_2d)
        ...     if len(idxs1) &gt; 0:
        ...         to_i = idxs1[0]  # no need to go beyond first signal
        ...     idxs2 = rand_by_prob_choice_nb(
        ...         from_i, to_i, col, prob2, True, temp_idx_arr2, flex_2d)
        ...     if len(idxs2) &gt; 0:
        ...         rand_type_out[idxs2[0], col] = RandType.R2
        ...         return idxs2
        ...     if len(idxs1) &gt; 0:
        ...         rand_type_out[idxs1[0], col] = RandType.R1
        ...         return idxs1
        ...     return temp_idx_arr1[:0]

        &gt;&gt;&gt; # Build signal generator
        &gt;&gt;&gt; MySignals = SignalFactory(
        ...     in_output_names=[&#39;rand_type&#39;],
        ...     param_names=[&#39;prob1&#39;, &#39;prob2&#39;],
        ...     attr_settings=dict(
        ...         rand_type=dict(dtype=RandType)  # creates rand_type_readable
        ...     ),
        ...     iteratively=True
        ... ).from_choice_func(
        ...     exit_choice_func=rand_exit_choice_nb,
        ...     exit_settings=dict(
        ...         pass_in_outputs=[&#39;rand_type&#39;],
        ...         pass_params=[&#39;prob1&#39;, &#39;prob2&#39;],
        ...         pass_kwargs=[&#39;temp_idx_arr1&#39;, &#39;temp_idx_arr2&#39;, &#39;flex_2d&#39;]
        ...     ),
        ...     param_settings=dict(
        ...         prob1=flex_elem_param_config,  # param per frame/row/col/element
        ...         prob2=flex_elem_param_config
        ...     ),
        ...     forward_flex_2d=True,
        ...     rand_type=-1  # fill with this value
        ... )

        &gt;&gt;&gt; # Run signal generator
        &gt;&gt;&gt; entries = [True, True, True, True, True]
        &gt;&gt;&gt; my_sig = MySignals.run(entries, [0., 1.], [0., 1.], param_product=True)

        &gt;&gt;&gt; my_sig.new_entries
        custom_prob1           0.0           1.0
        custom_prob2    0.0    1.0    0.0    1.0
        0              True   True   True   True
        1             False  False  False  False
        2             False   True   True   True
        3             False  False  False  False
        4             False   True   True   True

        &gt;&gt;&gt; my_sig.exits
        custom_prob1           0.0           1.0
        custom_prob2    0.0    1.0    0.0    1.0
        0             False  False  False  False
        1             False   True   True   True
        2             False  False  False  False
        3             False   True   True   True
        4             False  False  False  False

        &gt;&gt;&gt; my_sig.rand_type_readable
        custom_prob1     0.0     1.0
        custom_prob2 0.0 1.0 0.0 1.0
        0
        1                 R2  R1  R1
        2
        3                 R2  R1  R1
        4
        ```
        &#34;&#34;&#34;

        exit_only = self.exit_only
        iteratively = self.iteratively
        input_names = self.input_names
        param_names = self.param_names
        in_output_names = self.in_output_names

        checks.assert_not_none(exit_choice_func)
        checks.assert_numba_func(exit_choice_func)
        if exit_only:
            if iteratively:
                if entry_choice_func is None:
                    entry_choice_func = first_choice_nb
                if entry_settings is None:
                    entry_settings = {}
                entry_settings = merge_dicts(dict(
                    pass_inputs=[&#39;entries&#39;]
                ), entry_settings)
        else:
            checks.assert_not_none(entry_choice_func)
            checks.assert_numba_func(entry_choice_func)

        if entry_settings is None:
            entry_settings = {}
        if exit_settings is None:
            exit_settings = {}
        if cache_settings is None:
            cache_settings = {}

        def _check_settings(func_settings):
            for k in func_settings:
                if k not in (
                    &#39;pass_inputs&#39;,
                    &#39;pass_in_outputs&#39;,
                    &#39;pass_params&#39;,
                    &#39;pass_kwargs&#39;,
                    &#39;pass_cache&#39;
                ):
                    raise ValueError(f&#34;Can&#39;t find key {k} in function settings&#34;)

        _check_settings(entry_settings)
        _check_settings(exit_settings)
        _check_settings(cache_settings)

        # Get input names for each function
        def _get_func_names(func_settings, setting, all_names):
            func_input_names = func_settings.get(setting, None)
            if func_input_names is None:
                return []
            else:
                for name in func_input_names:
                    checks.assert_in(name, all_names)
            return func_input_names

        entry_input_names = _get_func_names(entry_settings, &#39;pass_inputs&#39;, input_names)
        exit_input_names = _get_func_names(exit_settings, &#39;pass_inputs&#39;, input_names)
        cache_input_names = _get_func_names(cache_settings, &#39;pass_inputs&#39;, input_names)

        entry_in_output_names = _get_func_names(entry_settings, &#39;pass_in_outputs&#39;, in_output_names)
        exit_in_output_names = _get_func_names(exit_settings, &#39;pass_in_outputs&#39;, in_output_names)
        cache_in_output_names = _get_func_names(cache_settings, &#39;pass_in_outputs&#39;, in_output_names)

        entry_param_names = _get_func_names(entry_settings, &#39;pass_params&#39;, param_names)
        exit_param_names = _get_func_names(exit_settings, &#39;pass_params&#39;, param_names)
        cache_param_names = _get_func_names(cache_settings, &#39;pass_params&#39;, param_names)

        # Build a function that selects a parameter tuple
        if exit_only and not iteratively:
            _0 = &#34;i&#34;
            _0 += &#34;, entries&#34;
            _0 += &#34;, exit_wait&#34;
            _0 += &#34;, exit_input_tuple&#34;
            if len(exit_in_output_names) &gt; 0:
                _0 += &#34;, exit_in_output_tuples&#34;
            if len(exit_param_names) &gt; 0:
                _0 += &#34;, exit_param_tuples&#34;
            _0 += &#34;, exit_args&#34;
            _1 = &#34;entries&#34;
            _1 += &#34;, exit_wait&#34;
            _1 += &#34;, exit_choice_func&#34;
            _1 += &#34;, *exit_input_tuple&#34;
            if len(exit_in_output_names) &gt; 0:
                _1 += &#34;, *exit_in_output_tuples[i]&#34;
            if len(exit_param_names) &gt; 0:
                _1 += &#34;, *exit_param_tuples[i]&#34;
            _1 += &#34;, *exit_args&#34;
            func_str = &#34;def apply_func_nb({0}):\n   return generate_ex_nb({1})&#34;.format(_0, _1)
            scope = {
                &#39;generate_ex_nb&#39;: generate_ex_nb,
                &#39;exit_choice_func&#39;: exit_choice_func
            }
            filename = inspect.getfile(lambda: None)
            code = compile(func_str, filename, &#39;single&#39;)
            exec(code, scope)
            apply_func_nb = scope[&#39;apply_func_nb&#39;]
            apply_func_nb = njit(apply_func_nb)

        else:
            _0 = &#34;i&#34;
            _0 += &#34;, shape&#34;
            _0 += &#34;, entry_wait&#34;
            _0 += &#34;, exit_wait&#34;
            _0 += &#34;, entry_input_tuple&#34;
            _0 += &#34;, exit_input_tuple&#34;
            if len(entry_in_output_names) &gt; 0:
                _0 += &#34;, entry_in_output_tuples&#34;
            if len(exit_in_output_names) &gt; 0:
                _0 += &#34;, exit_in_output_tuples&#34;
            if len(entry_param_names) &gt; 0:
                _0 += &#34;, entry_param_tuples&#34;
            if len(exit_param_names) &gt; 0:
                _0 += &#34;, exit_param_tuples&#34;
            _0 += &#34;, entry_args&#34;
            _0 += &#34;, exit_args&#34;
            _1 = &#34;shape&#34;
            _1 += &#34;, entry_wait&#34;
            _1 += &#34;, exit_wait&#34;
            _1 += &#34;, entry_choice_func&#34;
            _1 += &#34;, (*entry_input_tuple&#34;
            if len(entry_in_output_names) &gt; 0:
                _1 += &#34;, *entry_in_output_tuples[i]&#34;
            if len(entry_param_names) &gt; 0:
                _1 += &#34;, *entry_param_tuples[i]&#34;
            _1 += &#34;, *entry_args)&#34;
            _1 += &#34;, exit_choice_func&#34;
            _1 += &#34;, (*exit_input_tuple&#34;
            if len(exit_in_output_names) &gt; 0:
                _1 += &#34;, *exit_in_output_tuples[i]&#34;
            if len(exit_param_names) &gt; 0:
                _1 += &#34;, *exit_param_tuples[i]&#34;
            _1 += &#34;, *exit_args)&#34;
            func_str = &#34;def apply_func_nb({0}):\n   return generate_enex_nb({1})&#34;.format(_0, _1)
            scope = {
                &#39;generate_enex_nb&#39;: generate_enex_nb,
                &#39;entry_choice_func&#39;: entry_choice_func,
                &#39;exit_choice_func&#39;: exit_choice_func
            }
            filename = inspect.getfile(lambda: None)
            code = compile(func_str, filename, &#39;single&#39;)
            exec(code, scope)
            apply_func_nb = scope[&#39;apply_func_nb&#39;]
            apply_func_nb = njit(apply_func_nb)

        def custom_func(input_list, in_output_list, param_list, *args, input_shape=None, flex_2d=None,
                        entry_args=None, exit_args=None, cache_args=None, entry_kwargs=None,
                        exit_kwargs=None, cache_kwargs=None, return_cache=False, use_cache=None, **_kwargs):
            # Get arguments
            if len(input_list) == 0:
                if input_shape is None:
                    raise ValueError(&#34;Pass input_shape if no input time series passed&#34;)
            else:
                input_shape = input_list[0].shape

            if entry_args is None:
                entry_args = ()
            if exit_args is None:
                exit_args = ()
            if cache_args is None:
                cache_args = ()
            if exit_only:
                if len(exit_args) &gt; 0:
                    raise ValueError(&#34;Use *args instead of exit_args when exit_only=True&#34;)
                exit_args = args
            else:
                if len(args) &gt; 0:
                    raise ValueError(&#34;*args can be only used when exit_only=True&#34;)

            if entry_kwargs is None:
                entry_kwargs = {}
            if exit_kwargs is None:
                exit_kwargs = {}
            if cache_kwargs is None:
                cache_kwargs = {}
            if exit_only:
                if len(exit_kwargs) &gt; 0:
                    raise ValueError(&#34;Use **kwargs instead of exit_kwargs when exit_only=True&#34;)
                exit_kwargs = _kwargs
            else:
                if len(_kwargs) &gt; 0:
                    raise ValueError(&#34;**kwargs can be only used when exit_only=True&#34;)

            kwargs_defaults = dict(
                input_shape=input_shape,
                wait=1,
                first=True,
                flex_2d=flex_2d,
            )
            entry_kwargs = merge_dicts(kwargs_defaults, entry_kwargs)
            exit_kwargs = merge_dicts(kwargs_defaults, exit_kwargs)
            cache_kwargs = merge_dicts(kwargs_defaults, cache_kwargs)
            entry_wait = entry_kwargs[&#39;wait&#39;]
            exit_wait = exit_kwargs[&#39;wait&#39;]

            # Distribute arguments across functions
            entry_input_tuple = ()
            exit_input_tuple = ()
            cache_input_tuple = ()
            for input_name in entry_input_names:
                entry_input_tuple += (input_list[input_names.index(input_name)],)
            for input_name in exit_input_names:
                exit_input_tuple += (input_list[input_names.index(input_name)],)
            for input_name in cache_input_names:
                cache_input_tuple += (input_list[input_names.index(input_name)],)

            entry_in_output_list = []
            exit_in_output_list = []
            cache_in_output_list = []
            for in_output_name in entry_in_output_names:
                entry_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
            for in_output_name in exit_in_output_names:
                exit_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
            for in_output_name in cache_in_output_names:
                cache_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])

            entry_param_list = []
            exit_param_list = []
            cache_param_list = []
            for param_name in entry_param_names:
                entry_param_list.append(param_list[param_names.index(param_name)])
            for param_name in exit_param_names:
                exit_param_list.append(param_list[param_names.index(param_name)])
            for param_name in cache_param_names:
                cache_param_list.append(param_list[param_names.index(param_name)])

            n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
            entry_in_output_tuples = list(zip(*entry_in_output_list))
            exit_in_output_tuples = list(zip(*exit_in_output_list))
            entry_param_tuples = list(zip(*entry_param_list))
            exit_param_tuples = list(zip(*exit_param_list))

            def _build_more_args(func_settings, func_kwargs):
                pass_kwargs = func_settings.get(&#39;pass_kwargs&#39;, [])
                more_args = ()
                for key in pass_kwargs:
                    value = None
                    if isinstance(key, tuple):
                        key, value = key
                    else:
                        if key.startswith(&#39;temp_idx_arr&#39;):
                            value = np.empty((input_shape[0],), dtype=np.int_)
                    value = func_kwargs.get(key, value)
                    more_args += (value,)
                return more_args

            entry_more_args = _build_more_args(entry_settings, entry_kwargs)
            exit_more_args = _build_more_args(exit_settings, exit_kwargs)
            cache_more_args = _build_more_args(cache_settings, cache_kwargs)

            # Caching
            cache = use_cache
            if cache is None and cache_func is not None:
                _cache_in_output_list = cache_in_output_list
                _cache_param_list = cache_param_list
                if checks.is_numba_func(cache_func):
                    if len(_cache_in_output_list) &gt; 0:
                        _cache_in_output_list = [to_typed_list(in_outputs) for in_outputs in _cache_in_output_list]
                    if len(_cache_param_list) &gt; 0:
                        _cache_param_list = [to_typed_list(params) for params in _cache_param_list]

                cache = cache_func(
                    *cache_input_tuple,
                    *_cache_in_output_list,
                    *_cache_param_list,
                    *cache_args,
                    *cache_more_args
                )
            if return_cache:
                return cache
            if cache is None:
                cache = ()
            if not isinstance(cache, (tuple, list, List)):
                cache = (cache,)

            entry_cache = ()
            exit_cache = ()
            if entry_settings.get(&#39;pass_cache&#39;, False):
                entry_cache = cache
            if exit_settings.get(&#39;pass_cache&#39;, False):
                exit_cache = cache

            # Apply and concatenate
            if exit_only and not iteratively:
                if len(exit_in_output_names) &gt; 0:
                    _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
                else:
                    _exit_in_output_tuples = ()
                if len(exit_param_names) &gt; 0:
                    _exit_param_tuples = (to_typed_list(exit_param_tuples),)
                else:
                    _exit_param_tuples = ()

                return combine_fns.apply_and_concat_one_nb(
                    n_params,
                    apply_func_nb,
                    input_list[0],
                    exit_wait,
                    exit_input_tuple,
                    *_exit_in_output_tuples,
                    *_exit_param_tuples,
                    exit_args + exit_more_args + exit_cache
                )

            else:
                if len(entry_in_output_names) &gt; 0:
                    _entry_in_output_tuples = (to_typed_list(entry_in_output_tuples),)
                else:
                    _entry_in_output_tuples = ()
                if len(entry_param_names) &gt; 0:
                    _entry_param_tuples = (to_typed_list(entry_param_tuples),)
                else:
                    _entry_param_tuples = ()
                if len(exit_in_output_names) &gt; 0:
                    _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
                else:
                    _exit_in_output_tuples = ()
                if len(exit_param_names) &gt; 0:
                    _exit_param_tuples = (to_typed_list(exit_param_tuples),)
                else:
                    _exit_param_tuples = ()

                return combine_fns.apply_and_concat_multiple_nb(
                    n_params,
                    apply_func_nb,
                    input_shape,
                    entry_wait,
                    exit_wait,
                    entry_input_tuple,
                    exit_input_tuple,
                    *_entry_in_output_tuples,
                    *_exit_in_output_tuples,
                    *_entry_param_tuples,
                    *_exit_param_tuples,
                    entry_args + entry_more_args + entry_cache,
                    exit_args + exit_more_args + exit_cache
                )

        return self.from_custom_func(custom_func, pass_lists=True, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.signals.factory.SignalFactory"><code class="flex name class">
<span>class <span class="ident parent-fname">SignalFactory</span></span>
<span>(</span><span>*args, class_name='CustomSignals', input_names=None, attr_settings=None, exit_only=False, iteratively=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A factory for building signal generators.</p>
<p>Extends <code><a title="vectorbt.indicators.factory.IndicatorFactory" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorFactory">IndicatorFactory</a></code> with choice functions.</p>
<p>Generates a fixed number of outputs (see arguments). If you need to generate other outputs,
use in-place outputs (via <code>in_output_names</code>).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>exit_only</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to generate exit signals only.</p>
<p>If True, uses <code>entries</code> as input and <code>exits</code> as output.
Otherwise, uses <code>entries</code> and <code>exits</code> as outputs.</p>
</dd>
<dt><strong><code>iteratively</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to use entries to iteratively generate new entries and exits.</p>
<p>If True, uses <code>entries</code> as input and <code>new_entries</code> and <code>exits</code> as outputs.</p>
</dd>
</dl>
<p>Other arguments are passed to <code><a title="vectorbt.indicators.factory.IndicatorFactory" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorFactory">IndicatorFactory</a></code>.
```</p>
<p>A factory for creating new indicators.</p>
<p>Initialize <code>IndicatorFactory</code> to create a skeleton and then use a class method
to finish building the indicator class.</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>class_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name for the created Python class.</dd>
<dt><strong><code>class_docstring</code></strong> :&ensp;<code>str</code></dt>
<dd>Docstring for the created Python class.</dd>
<dt><strong><code>module_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Specify the module the class originates from.</dd>
<dt><strong><code>short_name</code></strong> :&ensp;<code>str</code></dt>
<dd>A short name of the indicator.</dd>
<dt><strong><code>prepend_name</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to prepend <code>short_name</code> to each parameter level.</dd>
<dt><strong><code>input_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of names of input time series objects.</dd>
<dt><strong><code>param_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of names of parameters.</dd>
<dt><strong><code>in_output_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>
<p>A list of names of in-place output time series objects.</p>
<p>An in-place output is an output that is not returned but modified in-place.
Some advantages of such outputs include:</p>
<p>1) they don't need to be returned,
2) they can be passed between functions as easily as inputs,
3) they can be provided with already allocated data to safe memory,
4) if data or default value are not provided, they are created empty to safe memory.</p>
</dd>
<dt><strong><code>output_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>
<p>A list of names of output time series objects.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Must have at least one (non-in-place) output.</p>
</div>
</dd>
<dt><strong><code>output_flags</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of output flags.</dd>
<dt><strong><code>custom_output_funcs</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary with user-defined functions that will be
bound to the indicator class and wrapped with <code>@cached_property</code>.</dd>
<dt><strong><code>attr_settings</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>A dictionary of settings by attribute name.</p>
<p>Attributes can be <code>input_names</code>, <code>in_output_names</code>, <code>output_names</code> and <code>custom_output_funcs</code>.</p>
<p>Following keys are accepted:</p>
<ul>
<li><code>dtype</code>: Data type used to determine which methods to generate around this attribute.
Set to None to disable. Default is <code>np.float_</code>. Can be set to instance of
<code>collections.namedtuple</code> acting as enumerated type; it will then create a property
with suffix <code>readable</code> that contains data in a string format.</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code>__init__</code> method is not used for running the indicator, for this use <code>run</code>.
The reason for this is indexing, which requires a clean <code>__init__</code> method for creating
a new indicator object with newly indexed attributes.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignalFactory(IndicatorFactory):
    &#34;&#34;&#34;A factory for building signal generators.

    Extends `vectorbt.indicators.factory.IndicatorFactory` with choice functions.

    Generates a fixed number of outputs (see arguments). If you need to generate other outputs,
    use in-place outputs (via `in_output_names`).

    Args:
        exit_only (bool): Whether to generate exit signals only.

            If True, uses `entries` as input and `exits` as output.
            Otherwise, uses `entries` and `exits` as outputs.
        iteratively (bool): Whether to use entries to iteratively generate new entries and exits.

            If True, uses `entries` as input and `new_entries` and `exits` as outputs.

    Other arguments are passed to `vectorbt.indicators.factory.IndicatorFactory`.
    ```&#34;&#34;&#34;

    def __init__(self,
                 *args,
                 class_name=&#39;CustomSignals&#39;,
                 input_names=None,
                 attr_settings=None,
                 exit_only=False,
                 iteratively=False,
                 **kwargs):
        if input_names is None:
            input_names = []
        if attr_settings is None:
            attr_settings = {}
        if iteratively:
            exit_only = True
        if exit_only:
            if len(input_names) &gt; 0:
                if input_names[0] != &#39;entries&#39;:
                    input_names = [&#39;entries&#39;] + input_names
            else:
                input_names = [&#39;entries&#39;]
            output_names = [&#39;exits&#39;]
            if iteratively:
                output_names = [&#39;new_entries&#39;] + output_names
                attr_settings[&#39;new_entries&#39;] = dict(dtype=np.bool)
        else:
            output_names = [&#39;entries&#39;, &#39;exits&#39;]
        attr_settings[&#39;entries&#39;] = dict(dtype=np.bool)
        attr_settings[&#39;exits&#39;] = dict(dtype=np.bool)
        IndicatorFactory.__init__(
            self, *args,
            class_name=class_name,
            input_names=input_names,
            output_names=output_names,
            attr_settings=attr_settings,
            **kwargs
        )
        self.exit_only = exit_only
        self.iteratively = iteratively

        def plot(_self,
                 entry_y=None,
                 exit_y=None,
                 entry_types=None,
                 exit_types=None,
                 entry_trace_kwargs=None,
                 exit_trace_kwargs=None,
                 fig=None,
                 **kwargs):  # pragma: no cover
            if _self.wrapper.ndim &gt; 1:
                raise TypeError(&#34;Select a column first. Use indexing.&#34;)

            if entry_trace_kwargs is None:
                entry_trace_kwargs = {}
            if exit_trace_kwargs is None:
                exit_trace_kwargs = {}
            if entry_types is not None:
                entry_trace_kwargs = merge_dicts(dict(
                    customdata=entry_types,
                    hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
                ), entry_trace_kwargs)
            if exit_types is not None:
                exit_trace_kwargs = merge_dicts(dict(
                    customdata=exit_types,
                    hovertemplate=&#34;(%{x}, %{y})&lt;br&gt;Type: %{customdata}&#34;
                ), exit_trace_kwargs)
            if exit_only and iteratively:
                entries = _self.new_entries
            else:
                entries = _self.entries
            exits = _self.exits
            fig = entries.vbt.signals.plot_as_entry_markers(
                y=entry_y, trace_kwargs=entry_trace_kwargs, fig=fig, **kwargs)
            fig = exits.vbt.signals.plot_as_exit_markers(
                y=exit_y, trace_kwargs=exit_trace_kwargs, fig=fig, **kwargs)

            return fig

        plot.__doc__ = &#34;&#34;&#34;Plot `{0}.{1}` and `{0}.exits`.

        Args:
            entry_y (array_like): Y-axis values to plot entry markers on.
            exit_y (array_like): Y-axis values to plot exit markers on.
            entry_types (array_like): Entry types in string format.
            exit_types (array_like): Exit types in string format.
            entry_trace_kwargs (dict): Keyword arguments passed to \
            `vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers` for `{0}.{1}`.
            exit_trace_kwargs (dict): Keyword arguments passed to \
            `vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers` for `{0}.exits`.
            fig (plotly.graph_objects.Figure): Figure to add traces to.
            **kwargs: Keyword arguments passed to `vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers`.
        &#34;&#34;&#34;.format(
            class_name, &#39;new_entries&#39; if exit_only and iteratively else &#39;entries&#39;
        )

        setattr(self.CustomIndicator, &#39;plot&#39;, plot)

    def from_choice_func(
            self,
            entry_choice_func=None,
            exit_choice_func=None,
            cache_func=None,
            entry_settings=None,
            exit_settings=None,
            cache_settings=None,
            **kwargs):
        &#34;&#34;&#34;Build signal generator class around entry and exit choice functions.

        A choice function is simply a function that returns indices of signals.
        There are two types of it: entry choice function and exit choice function.
        Each choice function takes broadcast time series, broadcast in-place output time series,
        broadcast parameter arrays, and other arguments, and returns an array of indices
        corresponding to chosen signals. See `vectorbt.signals.nb.generate_nb`.

        If `exit_only` is True, calls `vectorbt.signals.nb.generate_ex_nb`.
        If `exit_only` is False or `iteratively` is True, calls `vectorbt.signals.nb.generate_enex_nb`.

        Args:
            entry_choice_func (callable): `choice_func_nb` that returns indices of entries.

                If `exit_only` is True, automatically set to `vectorbt.signals.nb.first_choice_nb`.
            exit_choice_func (callable): `choice_func_nb` that returns indices of exits.
            cache_func (callable): A caching function to preprocess data beforehand.

                All returned objects will be passed as last arguments to choice functions.
            entry_settings (dict): Settings dict for `entry_choice_func`.
            exit_settings (dict): Settings dict for `exit_choice_func`.
            cache_settings (dict): Settings dict for `cache_func`.
            **kwargs: Keyword arguments passed to `IndicatorFactory.from_custom_func`.

        !!! note
            Choice functions should be Numba-compiled.

            Which inputs, parameters and arguments to pass to each function should be
            explicitly indicated in the function&#39;s settings dict. By default, nothing is passed.

        Settings dict of each function can have the following keys:

        Attributes:
            pass_inputs (list of str): Input names to pass to the choice function.

                Defaults to []. Order matters. Each name must be in `input_names`.
            pass_in_outputs (list of str): In-place output names to pass to the choice function.

                Defaults to []. Order matters. Each name must be in `in_output_names`.
            pass_params (list of str): Parameter names to pass to the choice function.

                Defaults to []. Order matters. Each name must be in `param_names`.
            pass_kwargs (list of str or list of tuple): Keyword arguments from `kwargs` dict to
                pass as positional arguments to the choice function.

                Defaults to []. Order matters.

                If any element is a tuple, should contain the name and the default value.
                If any element is a string, the default value is None.

                Built-in keys include:

                * `input_shape`: Input shape if no input time series passed.
                    Default is provided by the pipeline if `forward_input_shape` is True.
                * `wait`: Number of ticks to wait before placing signals.
                    Default is 1.
                * `first`: Whether to stop as soon as the first exit signal is found.
                    Default is True.
                * `temp_idx_arr`: Empty integer array used to temporarily store indices.
                    Default is an automatically generated array of shape `input_shape[0]`.

                    You can also pass `temp_idx_arr1`, `temp_idx_arr2`, etc. to generate multiple.
                * `flex_2d`: See `vectorbt.base.reshape_fns.flex_choose_i_and_col_nb`.
                    Default is provided by the pipeline if `forward_flex_2d` is True.
            pass_cache (bool): Whether to pass cache from `cache_func` to the choice function.

                Defaults to False. Cache is passed unpacked.

        The following arguments can be passed to `run` and `run_combs` methods:

        Args:
            *args: Should be used instead of `exit_args` when `exit_only` is True.
            entry_args (tuple): Arguments passed to the entry choice function.
            exit_args (tuple): Arguments passed to the exit choice function.
            cache_args (tuple): Arguments passed to the cache function.
            entry_kwargs (tuple): Settings for the entry choice function. Also contains arguments
                passed as positional if in `pass_kwargs`.
            exit_kwargs (tuple): Settings for the exit choice function. Also contains arguments
                passed as positional if in `pass_kwargs`.
            cache_kwargs (tuple): Settings for the cache function. Also contains arguments
                passed as positional if in `pass_kwargs`.
            return_cache (bool): Whether to return only cache.
            use_cache (any): Cache to use.
            **kwargs: Should be used instead of `exit_kwargs` when `exit_only` is True.

        For more arguments, see `vectorbt.indicators.factory.run_pipeline`.

        ## Example

        Take the first entry and place an exit after waiting `n` ticks. Find the next entry and repeat.
        Test three different `n` values.

        ```python-repl
        &gt;&gt;&gt; from numba import njit
        &gt;&gt;&gt; from vectorbt.signals.factory import SignalFactory

        &gt;&gt;&gt; @njit
        ... def wait_choice_nb(from_i, to_i, col, n, temp_idx_arr):
        ...     temp_idx_arr[0] = from_i + n  # index of next exit
        ...     if temp_idx_arr[0] &lt; to_i:
        ...         return temp_idx_arr[:1]
        ...     return temp_idx_arr[:0]  # must return array anyway

        &gt;&gt;&gt; # Build signal generator
        &gt;&gt;&gt; MySignals = SignalFactory(
        ...     param_names=[&#39;n&#39;],
        ...     iteratively=True
        ... ).from_choice_func(
        ...     exit_choice_func=wait_choice_nb,
        ...     exit_settings=dict(
        ...         pass_params=[&#39;n&#39;],
        ...         pass_kwargs=[&#39;temp_idx_arr&#39;]  # built-in kwarg
        ...     )
        ... )

        &gt;&gt;&gt; # Run signal generator
        &gt;&gt;&gt; entries = [True, True, True, True, True]
        &gt;&gt;&gt; my_sig = MySignals.run(entries, [0, 1, 2])

        &gt;&gt;&gt; my_sig.entries  # input entries
        custom_n     0     1     2
        0         True  True  True
        1         True  True  True
        2         True  True  True
        3         True  True  True
        4         True  True  True

        &gt;&gt;&gt; my_sig.new_entries  # output entries
        custom_n      0      1      2
        0          True   True   True
        1         False  False  False
        2          True  False  False
        3         False   True  False
        4          True  False   True

        &gt;&gt;&gt; my_sig.exits  # output exits
        custom_n      0      1      2
        0         False  False  False
        1          True  False  False
        2         False   True  False
        3          True  False   True
        4         False  False  False
        ```

        To combine multiple iterative signals, you would need to create a choice function
        that does that. Here is an example of combining two random generators using &#34;OR&#34; rule:

        ```python-repl
        &gt;&gt;&gt; from numba import njit
        &gt;&gt;&gt; from collections import namedtuple
        &gt;&gt;&gt; from vectorbt.signals.factory import SignalFactory
        &gt;&gt;&gt; from vectorbt.signals.nb import rand_by_prob_choice_nb
        &gt;&gt;&gt; from vectorbt.signals.basic import flex_elem_param_config

        &gt;&gt;&gt; # Enum to distinguish random generators
        &gt;&gt;&gt; RandType = namedtuple(&#39;RandType&#39;, [&#39;R1&#39;, &#39;R2&#39;])(0, 1)

        &gt;&gt;&gt; # Define exit choice function
        &gt;&gt;&gt; @njit
        ... def rand_exit_choice_nb(from_i, to_i, col, rand_type_out, prob1,
        ...                         prob2, temp_idx_arr1, temp_idx_arr2, flex_2d):
        ...     idxs1 = rand_by_prob_choice_nb(
        ...         from_i, to_i, col, prob1, True, temp_idx_arr1, flex_2d)
        ...     if len(idxs1) &gt; 0:
        ...         to_i = idxs1[0]  # no need to go beyond first signal
        ...     idxs2 = rand_by_prob_choice_nb(
        ...         from_i, to_i, col, prob2, True, temp_idx_arr2, flex_2d)
        ...     if len(idxs2) &gt; 0:
        ...         rand_type_out[idxs2[0], col] = RandType.R2
        ...         return idxs2
        ...     if len(idxs1) &gt; 0:
        ...         rand_type_out[idxs1[0], col] = RandType.R1
        ...         return idxs1
        ...     return temp_idx_arr1[:0]

        &gt;&gt;&gt; # Build signal generator
        &gt;&gt;&gt; MySignals = SignalFactory(
        ...     in_output_names=[&#39;rand_type&#39;],
        ...     param_names=[&#39;prob1&#39;, &#39;prob2&#39;],
        ...     attr_settings=dict(
        ...         rand_type=dict(dtype=RandType)  # creates rand_type_readable
        ...     ),
        ...     iteratively=True
        ... ).from_choice_func(
        ...     exit_choice_func=rand_exit_choice_nb,
        ...     exit_settings=dict(
        ...         pass_in_outputs=[&#39;rand_type&#39;],
        ...         pass_params=[&#39;prob1&#39;, &#39;prob2&#39;],
        ...         pass_kwargs=[&#39;temp_idx_arr1&#39;, &#39;temp_idx_arr2&#39;, &#39;flex_2d&#39;]
        ...     ),
        ...     param_settings=dict(
        ...         prob1=flex_elem_param_config,  # param per frame/row/col/element
        ...         prob2=flex_elem_param_config
        ...     ),
        ...     forward_flex_2d=True,
        ...     rand_type=-1  # fill with this value
        ... )

        &gt;&gt;&gt; # Run signal generator
        &gt;&gt;&gt; entries = [True, True, True, True, True]
        &gt;&gt;&gt; my_sig = MySignals.run(entries, [0., 1.], [0., 1.], param_product=True)

        &gt;&gt;&gt; my_sig.new_entries
        custom_prob1           0.0           1.0
        custom_prob2    0.0    1.0    0.0    1.0
        0              True   True   True   True
        1             False  False  False  False
        2             False   True   True   True
        3             False  False  False  False
        4             False   True   True   True

        &gt;&gt;&gt; my_sig.exits
        custom_prob1           0.0           1.0
        custom_prob2    0.0    1.0    0.0    1.0
        0             False  False  False  False
        1             False   True   True   True
        2             False  False  False  False
        3             False   True   True   True
        4             False  False  False  False

        &gt;&gt;&gt; my_sig.rand_type_readable
        custom_prob1     0.0     1.0
        custom_prob2 0.0 1.0 0.0 1.0
        0
        1                 R2  R1  R1
        2
        3                 R2  R1  R1
        4
        ```
        &#34;&#34;&#34;

        exit_only = self.exit_only
        iteratively = self.iteratively
        input_names = self.input_names
        param_names = self.param_names
        in_output_names = self.in_output_names

        checks.assert_not_none(exit_choice_func)
        checks.assert_numba_func(exit_choice_func)
        if exit_only:
            if iteratively:
                if entry_choice_func is None:
                    entry_choice_func = first_choice_nb
                if entry_settings is None:
                    entry_settings = {}
                entry_settings = merge_dicts(dict(
                    pass_inputs=[&#39;entries&#39;]
                ), entry_settings)
        else:
            checks.assert_not_none(entry_choice_func)
            checks.assert_numba_func(entry_choice_func)

        if entry_settings is None:
            entry_settings = {}
        if exit_settings is None:
            exit_settings = {}
        if cache_settings is None:
            cache_settings = {}

        def _check_settings(func_settings):
            for k in func_settings:
                if k not in (
                    &#39;pass_inputs&#39;,
                    &#39;pass_in_outputs&#39;,
                    &#39;pass_params&#39;,
                    &#39;pass_kwargs&#39;,
                    &#39;pass_cache&#39;
                ):
                    raise ValueError(f&#34;Can&#39;t find key {k} in function settings&#34;)

        _check_settings(entry_settings)
        _check_settings(exit_settings)
        _check_settings(cache_settings)

        # Get input names for each function
        def _get_func_names(func_settings, setting, all_names):
            func_input_names = func_settings.get(setting, None)
            if func_input_names is None:
                return []
            else:
                for name in func_input_names:
                    checks.assert_in(name, all_names)
            return func_input_names

        entry_input_names = _get_func_names(entry_settings, &#39;pass_inputs&#39;, input_names)
        exit_input_names = _get_func_names(exit_settings, &#39;pass_inputs&#39;, input_names)
        cache_input_names = _get_func_names(cache_settings, &#39;pass_inputs&#39;, input_names)

        entry_in_output_names = _get_func_names(entry_settings, &#39;pass_in_outputs&#39;, in_output_names)
        exit_in_output_names = _get_func_names(exit_settings, &#39;pass_in_outputs&#39;, in_output_names)
        cache_in_output_names = _get_func_names(cache_settings, &#39;pass_in_outputs&#39;, in_output_names)

        entry_param_names = _get_func_names(entry_settings, &#39;pass_params&#39;, param_names)
        exit_param_names = _get_func_names(exit_settings, &#39;pass_params&#39;, param_names)
        cache_param_names = _get_func_names(cache_settings, &#39;pass_params&#39;, param_names)

        # Build a function that selects a parameter tuple
        if exit_only and not iteratively:
            _0 = &#34;i&#34;
            _0 += &#34;, entries&#34;
            _0 += &#34;, exit_wait&#34;
            _0 += &#34;, exit_input_tuple&#34;
            if len(exit_in_output_names) &gt; 0:
                _0 += &#34;, exit_in_output_tuples&#34;
            if len(exit_param_names) &gt; 0:
                _0 += &#34;, exit_param_tuples&#34;
            _0 += &#34;, exit_args&#34;
            _1 = &#34;entries&#34;
            _1 += &#34;, exit_wait&#34;
            _1 += &#34;, exit_choice_func&#34;
            _1 += &#34;, *exit_input_tuple&#34;
            if len(exit_in_output_names) &gt; 0:
                _1 += &#34;, *exit_in_output_tuples[i]&#34;
            if len(exit_param_names) &gt; 0:
                _1 += &#34;, *exit_param_tuples[i]&#34;
            _1 += &#34;, *exit_args&#34;
            func_str = &#34;def apply_func_nb({0}):\n   return generate_ex_nb({1})&#34;.format(_0, _1)
            scope = {
                &#39;generate_ex_nb&#39;: generate_ex_nb,
                &#39;exit_choice_func&#39;: exit_choice_func
            }
            filename = inspect.getfile(lambda: None)
            code = compile(func_str, filename, &#39;single&#39;)
            exec(code, scope)
            apply_func_nb = scope[&#39;apply_func_nb&#39;]
            apply_func_nb = njit(apply_func_nb)

        else:
            _0 = &#34;i&#34;
            _0 += &#34;, shape&#34;
            _0 += &#34;, entry_wait&#34;
            _0 += &#34;, exit_wait&#34;
            _0 += &#34;, entry_input_tuple&#34;
            _0 += &#34;, exit_input_tuple&#34;
            if len(entry_in_output_names) &gt; 0:
                _0 += &#34;, entry_in_output_tuples&#34;
            if len(exit_in_output_names) &gt; 0:
                _0 += &#34;, exit_in_output_tuples&#34;
            if len(entry_param_names) &gt; 0:
                _0 += &#34;, entry_param_tuples&#34;
            if len(exit_param_names) &gt; 0:
                _0 += &#34;, exit_param_tuples&#34;
            _0 += &#34;, entry_args&#34;
            _0 += &#34;, exit_args&#34;
            _1 = &#34;shape&#34;
            _1 += &#34;, entry_wait&#34;
            _1 += &#34;, exit_wait&#34;
            _1 += &#34;, entry_choice_func&#34;
            _1 += &#34;, (*entry_input_tuple&#34;
            if len(entry_in_output_names) &gt; 0:
                _1 += &#34;, *entry_in_output_tuples[i]&#34;
            if len(entry_param_names) &gt; 0:
                _1 += &#34;, *entry_param_tuples[i]&#34;
            _1 += &#34;, *entry_args)&#34;
            _1 += &#34;, exit_choice_func&#34;
            _1 += &#34;, (*exit_input_tuple&#34;
            if len(exit_in_output_names) &gt; 0:
                _1 += &#34;, *exit_in_output_tuples[i]&#34;
            if len(exit_param_names) &gt; 0:
                _1 += &#34;, *exit_param_tuples[i]&#34;
            _1 += &#34;, *exit_args)&#34;
            func_str = &#34;def apply_func_nb({0}):\n   return generate_enex_nb({1})&#34;.format(_0, _1)
            scope = {
                &#39;generate_enex_nb&#39;: generate_enex_nb,
                &#39;entry_choice_func&#39;: entry_choice_func,
                &#39;exit_choice_func&#39;: exit_choice_func
            }
            filename = inspect.getfile(lambda: None)
            code = compile(func_str, filename, &#39;single&#39;)
            exec(code, scope)
            apply_func_nb = scope[&#39;apply_func_nb&#39;]
            apply_func_nb = njit(apply_func_nb)

        def custom_func(input_list, in_output_list, param_list, *args, input_shape=None, flex_2d=None,
                        entry_args=None, exit_args=None, cache_args=None, entry_kwargs=None,
                        exit_kwargs=None, cache_kwargs=None, return_cache=False, use_cache=None, **_kwargs):
            # Get arguments
            if len(input_list) == 0:
                if input_shape is None:
                    raise ValueError(&#34;Pass input_shape if no input time series passed&#34;)
            else:
                input_shape = input_list[0].shape

            if entry_args is None:
                entry_args = ()
            if exit_args is None:
                exit_args = ()
            if cache_args is None:
                cache_args = ()
            if exit_only:
                if len(exit_args) &gt; 0:
                    raise ValueError(&#34;Use *args instead of exit_args when exit_only=True&#34;)
                exit_args = args
            else:
                if len(args) &gt; 0:
                    raise ValueError(&#34;*args can be only used when exit_only=True&#34;)

            if entry_kwargs is None:
                entry_kwargs = {}
            if exit_kwargs is None:
                exit_kwargs = {}
            if cache_kwargs is None:
                cache_kwargs = {}
            if exit_only:
                if len(exit_kwargs) &gt; 0:
                    raise ValueError(&#34;Use **kwargs instead of exit_kwargs when exit_only=True&#34;)
                exit_kwargs = _kwargs
            else:
                if len(_kwargs) &gt; 0:
                    raise ValueError(&#34;**kwargs can be only used when exit_only=True&#34;)

            kwargs_defaults = dict(
                input_shape=input_shape,
                wait=1,
                first=True,
                flex_2d=flex_2d,
            )
            entry_kwargs = merge_dicts(kwargs_defaults, entry_kwargs)
            exit_kwargs = merge_dicts(kwargs_defaults, exit_kwargs)
            cache_kwargs = merge_dicts(kwargs_defaults, cache_kwargs)
            entry_wait = entry_kwargs[&#39;wait&#39;]
            exit_wait = exit_kwargs[&#39;wait&#39;]

            # Distribute arguments across functions
            entry_input_tuple = ()
            exit_input_tuple = ()
            cache_input_tuple = ()
            for input_name in entry_input_names:
                entry_input_tuple += (input_list[input_names.index(input_name)],)
            for input_name in exit_input_names:
                exit_input_tuple += (input_list[input_names.index(input_name)],)
            for input_name in cache_input_names:
                cache_input_tuple += (input_list[input_names.index(input_name)],)

            entry_in_output_list = []
            exit_in_output_list = []
            cache_in_output_list = []
            for in_output_name in entry_in_output_names:
                entry_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
            for in_output_name in exit_in_output_names:
                exit_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
            for in_output_name in cache_in_output_names:
                cache_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])

            entry_param_list = []
            exit_param_list = []
            cache_param_list = []
            for param_name in entry_param_names:
                entry_param_list.append(param_list[param_names.index(param_name)])
            for param_name in exit_param_names:
                exit_param_list.append(param_list[param_names.index(param_name)])
            for param_name in cache_param_names:
                cache_param_list.append(param_list[param_names.index(param_name)])

            n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
            entry_in_output_tuples = list(zip(*entry_in_output_list))
            exit_in_output_tuples = list(zip(*exit_in_output_list))
            entry_param_tuples = list(zip(*entry_param_list))
            exit_param_tuples = list(zip(*exit_param_list))

            def _build_more_args(func_settings, func_kwargs):
                pass_kwargs = func_settings.get(&#39;pass_kwargs&#39;, [])
                more_args = ()
                for key in pass_kwargs:
                    value = None
                    if isinstance(key, tuple):
                        key, value = key
                    else:
                        if key.startswith(&#39;temp_idx_arr&#39;):
                            value = np.empty((input_shape[0],), dtype=np.int_)
                    value = func_kwargs.get(key, value)
                    more_args += (value,)
                return more_args

            entry_more_args = _build_more_args(entry_settings, entry_kwargs)
            exit_more_args = _build_more_args(exit_settings, exit_kwargs)
            cache_more_args = _build_more_args(cache_settings, cache_kwargs)

            # Caching
            cache = use_cache
            if cache is None and cache_func is not None:
                _cache_in_output_list = cache_in_output_list
                _cache_param_list = cache_param_list
                if checks.is_numba_func(cache_func):
                    if len(_cache_in_output_list) &gt; 0:
                        _cache_in_output_list = [to_typed_list(in_outputs) for in_outputs in _cache_in_output_list]
                    if len(_cache_param_list) &gt; 0:
                        _cache_param_list = [to_typed_list(params) for params in _cache_param_list]

                cache = cache_func(
                    *cache_input_tuple,
                    *_cache_in_output_list,
                    *_cache_param_list,
                    *cache_args,
                    *cache_more_args
                )
            if return_cache:
                return cache
            if cache is None:
                cache = ()
            if not isinstance(cache, (tuple, list, List)):
                cache = (cache,)

            entry_cache = ()
            exit_cache = ()
            if entry_settings.get(&#39;pass_cache&#39;, False):
                entry_cache = cache
            if exit_settings.get(&#39;pass_cache&#39;, False):
                exit_cache = cache

            # Apply and concatenate
            if exit_only and not iteratively:
                if len(exit_in_output_names) &gt; 0:
                    _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
                else:
                    _exit_in_output_tuples = ()
                if len(exit_param_names) &gt; 0:
                    _exit_param_tuples = (to_typed_list(exit_param_tuples),)
                else:
                    _exit_param_tuples = ()

                return combine_fns.apply_and_concat_one_nb(
                    n_params,
                    apply_func_nb,
                    input_list[0],
                    exit_wait,
                    exit_input_tuple,
                    *_exit_in_output_tuples,
                    *_exit_param_tuples,
                    exit_args + exit_more_args + exit_cache
                )

            else:
                if len(entry_in_output_names) &gt; 0:
                    _entry_in_output_tuples = (to_typed_list(entry_in_output_tuples),)
                else:
                    _entry_in_output_tuples = ()
                if len(entry_param_names) &gt; 0:
                    _entry_param_tuples = (to_typed_list(entry_param_tuples),)
                else:
                    _entry_param_tuples = ()
                if len(exit_in_output_names) &gt; 0:
                    _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
                else:
                    _exit_in_output_tuples = ()
                if len(exit_param_names) &gt; 0:
                    _exit_param_tuples = (to_typed_list(exit_param_tuples),)
                else:
                    _exit_param_tuples = ()

                return combine_fns.apply_and_concat_multiple_nb(
                    n_params,
                    apply_func_nb,
                    input_shape,
                    entry_wait,
                    exit_wait,
                    entry_input_tuple,
                    exit_input_tuple,
                    *_entry_in_output_tuples,
                    *_exit_in_output_tuples,
                    *_entry_param_tuples,
                    *_exit_param_tuples,
                    entry_args + entry_more_args + entry_cache,
                    exit_args + exit_more_args + exit_cache
                )

        return self.from_custom_func(custom_func, pass_lists=True, **kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorFactory" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorFactory">IndicatorFactory</a></li>
</ul>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.signals.factory.SignalFactory.from_choice_func"><code class="name flex">
<span>def <span class="ident fname">from_choice_func</span></span>(<span>self, entry_choice_func=None, exit_choice_func=None, cache_func=None, entry_settings=None, exit_settings=None, cache_settings=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Build signal generator class around entry and exit choice functions.</p>
<p>A choice function is simply a function that returns indices of signals.
There are two types of it: entry choice function and exit choice function.
Each choice function takes broadcast time series, broadcast in-place output time series,
broadcast parameter arrays, and other arguments, and returns an array of indices
corresponding to chosen signals. See <code><a title="vectorbt.signals.nb.generate_nb" href="nb.html#vectorbt.signals.nb.generate_nb">generate_nb()</a></code>.</p>
<p>If <code>exit_only</code> is True, calls <code><a title="vectorbt.signals.nb.generate_ex_nb" href="nb.html#vectorbt.signals.nb.generate_ex_nb">generate_ex_nb()</a></code>.
If <code>exit_only</code> is False or <code>iteratively</code> is True, calls <code><a title="vectorbt.signals.nb.generate_enex_nb" href="nb.html#vectorbt.signals.nb.generate_enex_nb">generate_enex_nb()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entry_choice_func</code></strong> :&ensp;<code>callable</code></dt>
<dd>
<p><code>choice_func_nb</code> that returns indices of entries.</p>
<p>If <code>exit_only</code> is True, automatically set to <code><a title="vectorbt.signals.nb.first_choice_nb" href="nb.html#vectorbt.signals.nb.first_choice_nb">first_choice_nb()</a></code>.</p>
</dd>
<dt><strong><code>exit_choice_func</code></strong> :&ensp;<code>callable</code></dt>
<dd><code>choice_func_nb</code> that returns indices of exits.</dd>
<dt><strong><code>cache_func</code></strong> :&ensp;<code>callable</code></dt>
<dd>
<p>A caching function to preprocess data beforehand.</p>
<p>All returned objects will be passed as last arguments to choice functions.</p>
</dd>
<dt><strong><code>entry_settings</code></strong> :&ensp;<code>dict</code></dt>
<dd>Settings dict for <code>entry_choice_func</code>.</dd>
<dt><strong><code>exit_settings</code></strong> :&ensp;<code>dict</code></dt>
<dd>Settings dict for <code>exit_choice_func</code>.</dd>
<dt><strong><code>cache_settings</code></strong> :&ensp;<code>dict</code></dt>
<dd>Settings dict for <code>cache_func</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code>IndicatorFactory.from_custom_func</code>.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Choice functions should be Numba-compiled.</p>
<p>Which inputs, parameters and arguments to pass to each function should be
explicitly indicated in the function's settings dict. By default, nothing is passed.</p>
</div>
<p>Settings dict of each function can have the following keys:</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>pass_inputs</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>
<p>Input names to pass to the choice function.</p>
<p>Defaults to []. Order matters. Each name must be in <code>input_names</code>.</p>
</dd>
<dt><strong><code>pass_in_outputs</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>
<p>In-place output names to pass to the choice function.</p>
<p>Defaults to []. Order matters. Each name must be in <code>in_output_names</code>.</p>
</dd>
<dt><strong><code>pass_params</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>
<p>Parameter names to pass to the choice function.</p>
<p>Defaults to []. Order matters. Each name must be in <code>param_names</code>.</p>
</dd>
<dt><strong><code>pass_kwargs</code></strong> :&ensp;<code>list</code> of <code>str</code> or <code>list</code> of <code>tuple</code></dt>
<dd>
<p>Keyword arguments from <code>kwargs</code> dict to
pass as positional arguments to the choice function.</p>
<p>Defaults to []. Order matters.</p>
<p>If any element is a tuple, should contain the name and the default value.
If any element is a string, the default value is None.</p>
<p>Built-in keys include:</p>
<ul>
<li><code>input_shape</code>: Input shape if no input time series passed.
Default is provided by the pipeline if <code>forward_input_shape</code> is True.</li>
<li><code>wait</code>: Number of ticks to wait before placing signals.
Default is 1.</li>
<li><code>first</code>: Whether to stop as soon as the first exit signal is found.
Default is True.</li>
<li>
<p><code>temp_idx_arr</code>: Empty integer array used to temporarily store indices.
Default is an automatically generated array of shape <code>input_shape[0]</code>.</p>
<p>You can also pass <code>temp_idx_arr1</code>, <code>temp_idx_arr2</code>, etc. to generate multiple.
* <code>flex_2d</code>: See <code><a title="vectorbt.base.reshape_fns.flex_choose_i_and_col_nb" href="../base/reshape_fns.html#vectorbt.base.reshape_fns.flex_choose_i_and_col_nb">flex_choose_i_and_col_nb()</a></code>.
Default is provided by the pipeline if <code>forward_flex_2d</code> is True.</p>
</li>
</ul>
</dd>
<dt><strong><code>pass_cache</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to pass cache from <code>cache_func</code> to the choice function.</p>
<p>Defaults to False. Cache is passed unpacked.</p>
</dd>
</dl>
<p>The following arguments can be passed to <code>run</code> and <code>run_combs</code> methods:</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Should be used instead of <code>exit_args</code> when <code>exit_only</code> is True.</dd>
<dt><strong><code>entry_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Arguments passed to the entry choice function.</dd>
<dt><strong><code>exit_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Arguments passed to the exit choice function.</dd>
<dt><strong><code>cache_args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Arguments passed to the cache function.</dd>
<dt><strong><code>entry_kwargs</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Settings for the entry choice function. Also contains arguments
passed as positional if in <code>pass_kwargs</code>.</dd>
<dt><strong><code>exit_kwargs</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Settings for the exit choice function. Also contains arguments
passed as positional if in <code>pass_kwargs</code>.</dd>
<dt><strong><code>cache_kwargs</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Settings for the cache function. Also contains arguments
passed as positional if in <code>pass_kwargs</code>.</dd>
<dt><strong><code>return_cache</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return only cache.</dd>
<dt><strong><code>use_cache</code></strong> :&ensp;<code>any</code></dt>
<dd>Cache to use.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Should be used instead of <code>exit_kwargs</code> when <code>exit_only</code> is True.</dd>
</dl>
<p>For more arguments, see <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p>
<h2 id="example">Example</h2>
<p>Take the first entry and place an exit after waiting <code>n</code> ticks. Find the next entry and repeat.
Test three different <code>n</code> values.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from vectorbt.signals.factory import SignalFactory

&gt;&gt;&gt; @njit
... def wait_choice_nb(from_i, to_i, col, n, temp_idx_arr):
...     temp_idx_arr[0] = from_i + n  # index of next exit
...     if temp_idx_arr[0] &lt; to_i:
...         return temp_idx_arr[:1]
...     return temp_idx_arr[:0]  # must return array anyway

&gt;&gt;&gt; # Build signal generator
&gt;&gt;&gt; MySignals = SignalFactory(
...     param_names=['n'],
...     iteratively=True
... ).from_choice_func(
...     exit_choice_func=wait_choice_nb,
...     exit_settings=dict(
...         pass_params=['n'],
...         pass_kwargs=['temp_idx_arr']  # built-in kwarg
...     )
... )

&gt;&gt;&gt; # Run signal generator
&gt;&gt;&gt; entries = [True, True, True, True, True]
&gt;&gt;&gt; my_sig = MySignals.run(entries, [0, 1, 2])

&gt;&gt;&gt; my_sig.entries  # input entries
custom_n     0     1     2
0         True  True  True
1         True  True  True
2         True  True  True
3         True  True  True
4         True  True  True

&gt;&gt;&gt; my_sig.new_entries  # output entries
custom_n      0      1      2
0          True   True   True
1         False  False  False
2          True  False  False
3         False   True  False
4          True  False   True

&gt;&gt;&gt; my_sig.exits  # output exits
custom_n      0      1      2
0         False  False  False
1          True  False  False
2         False   True  False
3          True  False   True
4         False  False  False
</code></pre>
<p>To combine multiple iterative signals, you would need to create a choice function
that does that. Here is an example of combining two random generators using "OR" rule:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; from vectorbt.signals.factory import SignalFactory
&gt;&gt;&gt; from vectorbt.signals.nb import rand_by_prob_choice_nb
&gt;&gt;&gt; from vectorbt.signals.basic import flex_elem_param_config

&gt;&gt;&gt; # Enum to distinguish random generators
&gt;&gt;&gt; RandType = namedtuple('RandType', ['R1', 'R2'])(0, 1)

&gt;&gt;&gt; # Define exit choice function
&gt;&gt;&gt; @njit
... def rand_exit_choice_nb(from_i, to_i, col, rand_type_out, prob1,
...                         prob2, temp_idx_arr1, temp_idx_arr2, flex_2d):
...     idxs1 = rand_by_prob_choice_nb(
...         from_i, to_i, col, prob1, True, temp_idx_arr1, flex_2d)
...     if len(idxs1) &gt; 0:
...         to_i = idxs1[0]  # no need to go beyond first signal
...     idxs2 = rand_by_prob_choice_nb(
...         from_i, to_i, col, prob2, True, temp_idx_arr2, flex_2d)
...     if len(idxs2) &gt; 0:
...         rand_type_out[idxs2[0], col] = RandType.R2
...         return idxs2
...     if len(idxs1) &gt; 0:
...         rand_type_out[idxs1[0], col] = RandType.R1
...         return idxs1
...     return temp_idx_arr1[:0]

&gt;&gt;&gt; # Build signal generator
&gt;&gt;&gt; MySignals = SignalFactory(
...     in_output_names=['rand_type'],
...     param_names=['prob1', 'prob2'],
...     attr_settings=dict(
...         rand_type=dict(dtype=RandType)  # creates rand_type_readable
...     ),
...     iteratively=True
... ).from_choice_func(
...     exit_choice_func=rand_exit_choice_nb,
...     exit_settings=dict(
...         pass_in_outputs=['rand_type'],
...         pass_params=['prob1', 'prob2'],
...         pass_kwargs=['temp_idx_arr1', 'temp_idx_arr2', 'flex_2d']
...     ),
...     param_settings=dict(
...         prob1=flex_elem_param_config,  # param per frame/row/col/element
...         prob2=flex_elem_param_config
...     ),
...     forward_flex_2d=True,
...     rand_type=-1  # fill with this value
... )

&gt;&gt;&gt; # Run signal generator
&gt;&gt;&gt; entries = [True, True, True, True, True]
&gt;&gt;&gt; my_sig = MySignals.run(entries, [0., 1.], [0., 1.], param_product=True)

&gt;&gt;&gt; my_sig.new_entries
custom_prob1           0.0           1.0
custom_prob2    0.0    1.0    0.0    1.0
0              True   True   True   True
1             False  False  False  False
2             False   True   True   True
3             False  False  False  False
4             False   True   True   True

&gt;&gt;&gt; my_sig.exits
custom_prob1           0.0           1.0
custom_prob2    0.0    1.0    0.0    1.0
0             False  False  False  False
1             False   True   True   True
2             False  False  False  False
3             False   True   True   True
4             False  False  False  False

&gt;&gt;&gt; my_sig.rand_type_readable
custom_prob1     0.0     1.0
custom_prob2 0.0 1.0 0.0 1.0
0
1                 R2  R1  R1
2
3                 R2  R1  R1
4
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_choice_func(
        self,
        entry_choice_func=None,
        exit_choice_func=None,
        cache_func=None,
        entry_settings=None,
        exit_settings=None,
        cache_settings=None,
        **kwargs):
    &#34;&#34;&#34;Build signal generator class around entry and exit choice functions.

    A choice function is simply a function that returns indices of signals.
    There are two types of it: entry choice function and exit choice function.
    Each choice function takes broadcast time series, broadcast in-place output time series,
    broadcast parameter arrays, and other arguments, and returns an array of indices
    corresponding to chosen signals. See `vectorbt.signals.nb.generate_nb`.

    If `exit_only` is True, calls `vectorbt.signals.nb.generate_ex_nb`.
    If `exit_only` is False or `iteratively` is True, calls `vectorbt.signals.nb.generate_enex_nb`.

    Args:
        entry_choice_func (callable): `choice_func_nb` that returns indices of entries.

            If `exit_only` is True, automatically set to `vectorbt.signals.nb.first_choice_nb`.
        exit_choice_func (callable): `choice_func_nb` that returns indices of exits.
        cache_func (callable): A caching function to preprocess data beforehand.

            All returned objects will be passed as last arguments to choice functions.
        entry_settings (dict): Settings dict for `entry_choice_func`.
        exit_settings (dict): Settings dict for `exit_choice_func`.
        cache_settings (dict): Settings dict for `cache_func`.
        **kwargs: Keyword arguments passed to `IndicatorFactory.from_custom_func`.

    !!! note
        Choice functions should be Numba-compiled.

        Which inputs, parameters and arguments to pass to each function should be
        explicitly indicated in the function&#39;s settings dict. By default, nothing is passed.

    Settings dict of each function can have the following keys:

    Attributes:
        pass_inputs (list of str): Input names to pass to the choice function.

            Defaults to []. Order matters. Each name must be in `input_names`.
        pass_in_outputs (list of str): In-place output names to pass to the choice function.

            Defaults to []. Order matters. Each name must be in `in_output_names`.
        pass_params (list of str): Parameter names to pass to the choice function.

            Defaults to []. Order matters. Each name must be in `param_names`.
        pass_kwargs (list of str or list of tuple): Keyword arguments from `kwargs` dict to
            pass as positional arguments to the choice function.

            Defaults to []. Order matters.

            If any element is a tuple, should contain the name and the default value.
            If any element is a string, the default value is None.

            Built-in keys include:

            * `input_shape`: Input shape if no input time series passed.
                Default is provided by the pipeline if `forward_input_shape` is True.
            * `wait`: Number of ticks to wait before placing signals.
                Default is 1.
            * `first`: Whether to stop as soon as the first exit signal is found.
                Default is True.
            * `temp_idx_arr`: Empty integer array used to temporarily store indices.
                Default is an automatically generated array of shape `input_shape[0]`.

                You can also pass `temp_idx_arr1`, `temp_idx_arr2`, etc. to generate multiple.
            * `flex_2d`: See `vectorbt.base.reshape_fns.flex_choose_i_and_col_nb`.
                Default is provided by the pipeline if `forward_flex_2d` is True.
        pass_cache (bool): Whether to pass cache from `cache_func` to the choice function.

            Defaults to False. Cache is passed unpacked.

    The following arguments can be passed to `run` and `run_combs` methods:

    Args:
        *args: Should be used instead of `exit_args` when `exit_only` is True.
        entry_args (tuple): Arguments passed to the entry choice function.
        exit_args (tuple): Arguments passed to the exit choice function.
        cache_args (tuple): Arguments passed to the cache function.
        entry_kwargs (tuple): Settings for the entry choice function. Also contains arguments
            passed as positional if in `pass_kwargs`.
        exit_kwargs (tuple): Settings for the exit choice function. Also contains arguments
            passed as positional if in `pass_kwargs`.
        cache_kwargs (tuple): Settings for the cache function. Also contains arguments
            passed as positional if in `pass_kwargs`.
        return_cache (bool): Whether to return only cache.
        use_cache (any): Cache to use.
        **kwargs: Should be used instead of `exit_kwargs` when `exit_only` is True.

    For more arguments, see `vectorbt.indicators.factory.run_pipeline`.

    ## Example

    Take the first entry and place an exit after waiting `n` ticks. Find the next entry and repeat.
    Test three different `n` values.

    ```python-repl
    &gt;&gt;&gt; from numba import njit
    &gt;&gt;&gt; from vectorbt.signals.factory import SignalFactory

    &gt;&gt;&gt; @njit
    ... def wait_choice_nb(from_i, to_i, col, n, temp_idx_arr):
    ...     temp_idx_arr[0] = from_i + n  # index of next exit
    ...     if temp_idx_arr[0] &lt; to_i:
    ...         return temp_idx_arr[:1]
    ...     return temp_idx_arr[:0]  # must return array anyway

    &gt;&gt;&gt; # Build signal generator
    &gt;&gt;&gt; MySignals = SignalFactory(
    ...     param_names=[&#39;n&#39;],
    ...     iteratively=True
    ... ).from_choice_func(
    ...     exit_choice_func=wait_choice_nb,
    ...     exit_settings=dict(
    ...         pass_params=[&#39;n&#39;],
    ...         pass_kwargs=[&#39;temp_idx_arr&#39;]  # built-in kwarg
    ...     )
    ... )

    &gt;&gt;&gt; # Run signal generator
    &gt;&gt;&gt; entries = [True, True, True, True, True]
    &gt;&gt;&gt; my_sig = MySignals.run(entries, [0, 1, 2])

    &gt;&gt;&gt; my_sig.entries  # input entries
    custom_n     0     1     2
    0         True  True  True
    1         True  True  True
    2         True  True  True
    3         True  True  True
    4         True  True  True

    &gt;&gt;&gt; my_sig.new_entries  # output entries
    custom_n      0      1      2
    0          True   True   True
    1         False  False  False
    2          True  False  False
    3         False   True  False
    4          True  False   True

    &gt;&gt;&gt; my_sig.exits  # output exits
    custom_n      0      1      2
    0         False  False  False
    1          True  False  False
    2         False   True  False
    3          True  False   True
    4         False  False  False
    ```

    To combine multiple iterative signals, you would need to create a choice function
    that does that. Here is an example of combining two random generators using &#34;OR&#34; rule:

    ```python-repl
    &gt;&gt;&gt; from numba import njit
    &gt;&gt;&gt; from collections import namedtuple
    &gt;&gt;&gt; from vectorbt.signals.factory import SignalFactory
    &gt;&gt;&gt; from vectorbt.signals.nb import rand_by_prob_choice_nb
    &gt;&gt;&gt; from vectorbt.signals.basic import flex_elem_param_config

    &gt;&gt;&gt; # Enum to distinguish random generators
    &gt;&gt;&gt; RandType = namedtuple(&#39;RandType&#39;, [&#39;R1&#39;, &#39;R2&#39;])(0, 1)

    &gt;&gt;&gt; # Define exit choice function
    &gt;&gt;&gt; @njit
    ... def rand_exit_choice_nb(from_i, to_i, col, rand_type_out, prob1,
    ...                         prob2, temp_idx_arr1, temp_idx_arr2, flex_2d):
    ...     idxs1 = rand_by_prob_choice_nb(
    ...         from_i, to_i, col, prob1, True, temp_idx_arr1, flex_2d)
    ...     if len(idxs1) &gt; 0:
    ...         to_i = idxs1[0]  # no need to go beyond first signal
    ...     idxs2 = rand_by_prob_choice_nb(
    ...         from_i, to_i, col, prob2, True, temp_idx_arr2, flex_2d)
    ...     if len(idxs2) &gt; 0:
    ...         rand_type_out[idxs2[0], col] = RandType.R2
    ...         return idxs2
    ...     if len(idxs1) &gt; 0:
    ...         rand_type_out[idxs1[0], col] = RandType.R1
    ...         return idxs1
    ...     return temp_idx_arr1[:0]

    &gt;&gt;&gt; # Build signal generator
    &gt;&gt;&gt; MySignals = SignalFactory(
    ...     in_output_names=[&#39;rand_type&#39;],
    ...     param_names=[&#39;prob1&#39;, &#39;prob2&#39;],
    ...     attr_settings=dict(
    ...         rand_type=dict(dtype=RandType)  # creates rand_type_readable
    ...     ),
    ...     iteratively=True
    ... ).from_choice_func(
    ...     exit_choice_func=rand_exit_choice_nb,
    ...     exit_settings=dict(
    ...         pass_in_outputs=[&#39;rand_type&#39;],
    ...         pass_params=[&#39;prob1&#39;, &#39;prob2&#39;],
    ...         pass_kwargs=[&#39;temp_idx_arr1&#39;, &#39;temp_idx_arr2&#39;, &#39;flex_2d&#39;]
    ...     ),
    ...     param_settings=dict(
    ...         prob1=flex_elem_param_config,  # param per frame/row/col/element
    ...         prob2=flex_elem_param_config
    ...     ),
    ...     forward_flex_2d=True,
    ...     rand_type=-1  # fill with this value
    ... )

    &gt;&gt;&gt; # Run signal generator
    &gt;&gt;&gt; entries = [True, True, True, True, True]
    &gt;&gt;&gt; my_sig = MySignals.run(entries, [0., 1.], [0., 1.], param_product=True)

    &gt;&gt;&gt; my_sig.new_entries
    custom_prob1           0.0           1.0
    custom_prob2    0.0    1.0    0.0    1.0
    0              True   True   True   True
    1             False  False  False  False
    2             False   True   True   True
    3             False  False  False  False
    4             False   True   True   True

    &gt;&gt;&gt; my_sig.exits
    custom_prob1           0.0           1.0
    custom_prob2    0.0    1.0    0.0    1.0
    0             False  False  False  False
    1             False   True   True   True
    2             False  False  False  False
    3             False   True   True   True
    4             False  False  False  False

    &gt;&gt;&gt; my_sig.rand_type_readable
    custom_prob1     0.0     1.0
    custom_prob2 0.0 1.0 0.0 1.0
    0
    1                 R2  R1  R1
    2
    3                 R2  R1  R1
    4
    ```
    &#34;&#34;&#34;

    exit_only = self.exit_only
    iteratively = self.iteratively
    input_names = self.input_names
    param_names = self.param_names
    in_output_names = self.in_output_names

    checks.assert_not_none(exit_choice_func)
    checks.assert_numba_func(exit_choice_func)
    if exit_only:
        if iteratively:
            if entry_choice_func is None:
                entry_choice_func = first_choice_nb
            if entry_settings is None:
                entry_settings = {}
            entry_settings = merge_dicts(dict(
                pass_inputs=[&#39;entries&#39;]
            ), entry_settings)
    else:
        checks.assert_not_none(entry_choice_func)
        checks.assert_numba_func(entry_choice_func)

    if entry_settings is None:
        entry_settings = {}
    if exit_settings is None:
        exit_settings = {}
    if cache_settings is None:
        cache_settings = {}

    def _check_settings(func_settings):
        for k in func_settings:
            if k not in (
                &#39;pass_inputs&#39;,
                &#39;pass_in_outputs&#39;,
                &#39;pass_params&#39;,
                &#39;pass_kwargs&#39;,
                &#39;pass_cache&#39;
            ):
                raise ValueError(f&#34;Can&#39;t find key {k} in function settings&#34;)

    _check_settings(entry_settings)
    _check_settings(exit_settings)
    _check_settings(cache_settings)

    # Get input names for each function
    def _get_func_names(func_settings, setting, all_names):
        func_input_names = func_settings.get(setting, None)
        if func_input_names is None:
            return []
        else:
            for name in func_input_names:
                checks.assert_in(name, all_names)
        return func_input_names

    entry_input_names = _get_func_names(entry_settings, &#39;pass_inputs&#39;, input_names)
    exit_input_names = _get_func_names(exit_settings, &#39;pass_inputs&#39;, input_names)
    cache_input_names = _get_func_names(cache_settings, &#39;pass_inputs&#39;, input_names)

    entry_in_output_names = _get_func_names(entry_settings, &#39;pass_in_outputs&#39;, in_output_names)
    exit_in_output_names = _get_func_names(exit_settings, &#39;pass_in_outputs&#39;, in_output_names)
    cache_in_output_names = _get_func_names(cache_settings, &#39;pass_in_outputs&#39;, in_output_names)

    entry_param_names = _get_func_names(entry_settings, &#39;pass_params&#39;, param_names)
    exit_param_names = _get_func_names(exit_settings, &#39;pass_params&#39;, param_names)
    cache_param_names = _get_func_names(cache_settings, &#39;pass_params&#39;, param_names)

    # Build a function that selects a parameter tuple
    if exit_only and not iteratively:
        _0 = &#34;i&#34;
        _0 += &#34;, entries&#34;
        _0 += &#34;, exit_wait&#34;
        _0 += &#34;, exit_input_tuple&#34;
        if len(exit_in_output_names) &gt; 0:
            _0 += &#34;, exit_in_output_tuples&#34;
        if len(exit_param_names) &gt; 0:
            _0 += &#34;, exit_param_tuples&#34;
        _0 += &#34;, exit_args&#34;
        _1 = &#34;entries&#34;
        _1 += &#34;, exit_wait&#34;
        _1 += &#34;, exit_choice_func&#34;
        _1 += &#34;, *exit_input_tuple&#34;
        if len(exit_in_output_names) &gt; 0:
            _1 += &#34;, *exit_in_output_tuples[i]&#34;
        if len(exit_param_names) &gt; 0:
            _1 += &#34;, *exit_param_tuples[i]&#34;
        _1 += &#34;, *exit_args&#34;
        func_str = &#34;def apply_func_nb({0}):\n   return generate_ex_nb({1})&#34;.format(_0, _1)
        scope = {
            &#39;generate_ex_nb&#39;: generate_ex_nb,
            &#39;exit_choice_func&#39;: exit_choice_func
        }
        filename = inspect.getfile(lambda: None)
        code = compile(func_str, filename, &#39;single&#39;)
        exec(code, scope)
        apply_func_nb = scope[&#39;apply_func_nb&#39;]
        apply_func_nb = njit(apply_func_nb)

    else:
        _0 = &#34;i&#34;
        _0 += &#34;, shape&#34;
        _0 += &#34;, entry_wait&#34;
        _0 += &#34;, exit_wait&#34;
        _0 += &#34;, entry_input_tuple&#34;
        _0 += &#34;, exit_input_tuple&#34;
        if len(entry_in_output_names) &gt; 0:
            _0 += &#34;, entry_in_output_tuples&#34;
        if len(exit_in_output_names) &gt; 0:
            _0 += &#34;, exit_in_output_tuples&#34;
        if len(entry_param_names) &gt; 0:
            _0 += &#34;, entry_param_tuples&#34;
        if len(exit_param_names) &gt; 0:
            _0 += &#34;, exit_param_tuples&#34;
        _0 += &#34;, entry_args&#34;
        _0 += &#34;, exit_args&#34;
        _1 = &#34;shape&#34;
        _1 += &#34;, entry_wait&#34;
        _1 += &#34;, exit_wait&#34;
        _1 += &#34;, entry_choice_func&#34;
        _1 += &#34;, (*entry_input_tuple&#34;
        if len(entry_in_output_names) &gt; 0:
            _1 += &#34;, *entry_in_output_tuples[i]&#34;
        if len(entry_param_names) &gt; 0:
            _1 += &#34;, *entry_param_tuples[i]&#34;
        _1 += &#34;, *entry_args)&#34;
        _1 += &#34;, exit_choice_func&#34;
        _1 += &#34;, (*exit_input_tuple&#34;
        if len(exit_in_output_names) &gt; 0:
            _1 += &#34;, *exit_in_output_tuples[i]&#34;
        if len(exit_param_names) &gt; 0:
            _1 += &#34;, *exit_param_tuples[i]&#34;
        _1 += &#34;, *exit_args)&#34;
        func_str = &#34;def apply_func_nb({0}):\n   return generate_enex_nb({1})&#34;.format(_0, _1)
        scope = {
            &#39;generate_enex_nb&#39;: generate_enex_nb,
            &#39;entry_choice_func&#39;: entry_choice_func,
            &#39;exit_choice_func&#39;: exit_choice_func
        }
        filename = inspect.getfile(lambda: None)
        code = compile(func_str, filename, &#39;single&#39;)
        exec(code, scope)
        apply_func_nb = scope[&#39;apply_func_nb&#39;]
        apply_func_nb = njit(apply_func_nb)

    def custom_func(input_list, in_output_list, param_list, *args, input_shape=None, flex_2d=None,
                    entry_args=None, exit_args=None, cache_args=None, entry_kwargs=None,
                    exit_kwargs=None, cache_kwargs=None, return_cache=False, use_cache=None, **_kwargs):
        # Get arguments
        if len(input_list) == 0:
            if input_shape is None:
                raise ValueError(&#34;Pass input_shape if no input time series passed&#34;)
        else:
            input_shape = input_list[0].shape

        if entry_args is None:
            entry_args = ()
        if exit_args is None:
            exit_args = ()
        if cache_args is None:
            cache_args = ()
        if exit_only:
            if len(exit_args) &gt; 0:
                raise ValueError(&#34;Use *args instead of exit_args when exit_only=True&#34;)
            exit_args = args
        else:
            if len(args) &gt; 0:
                raise ValueError(&#34;*args can be only used when exit_only=True&#34;)

        if entry_kwargs is None:
            entry_kwargs = {}
        if exit_kwargs is None:
            exit_kwargs = {}
        if cache_kwargs is None:
            cache_kwargs = {}
        if exit_only:
            if len(exit_kwargs) &gt; 0:
                raise ValueError(&#34;Use **kwargs instead of exit_kwargs when exit_only=True&#34;)
            exit_kwargs = _kwargs
        else:
            if len(_kwargs) &gt; 0:
                raise ValueError(&#34;**kwargs can be only used when exit_only=True&#34;)

        kwargs_defaults = dict(
            input_shape=input_shape,
            wait=1,
            first=True,
            flex_2d=flex_2d,
        )
        entry_kwargs = merge_dicts(kwargs_defaults, entry_kwargs)
        exit_kwargs = merge_dicts(kwargs_defaults, exit_kwargs)
        cache_kwargs = merge_dicts(kwargs_defaults, cache_kwargs)
        entry_wait = entry_kwargs[&#39;wait&#39;]
        exit_wait = exit_kwargs[&#39;wait&#39;]

        # Distribute arguments across functions
        entry_input_tuple = ()
        exit_input_tuple = ()
        cache_input_tuple = ()
        for input_name in entry_input_names:
            entry_input_tuple += (input_list[input_names.index(input_name)],)
        for input_name in exit_input_names:
            exit_input_tuple += (input_list[input_names.index(input_name)],)
        for input_name in cache_input_names:
            cache_input_tuple += (input_list[input_names.index(input_name)],)

        entry_in_output_list = []
        exit_in_output_list = []
        cache_in_output_list = []
        for in_output_name in entry_in_output_names:
            entry_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
        for in_output_name in exit_in_output_names:
            exit_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])
        for in_output_name in cache_in_output_names:
            cache_in_output_list.append(in_output_list[in_output_names.index(in_output_name)])

        entry_param_list = []
        exit_param_list = []
        cache_param_list = []
        for param_name in entry_param_names:
            entry_param_list.append(param_list[param_names.index(param_name)])
        for param_name in exit_param_names:
            exit_param_list.append(param_list[param_names.index(param_name)])
        for param_name in cache_param_names:
            cache_param_list.append(param_list[param_names.index(param_name)])

        n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
        entry_in_output_tuples = list(zip(*entry_in_output_list))
        exit_in_output_tuples = list(zip(*exit_in_output_list))
        entry_param_tuples = list(zip(*entry_param_list))
        exit_param_tuples = list(zip(*exit_param_list))

        def _build_more_args(func_settings, func_kwargs):
            pass_kwargs = func_settings.get(&#39;pass_kwargs&#39;, [])
            more_args = ()
            for key in pass_kwargs:
                value = None
                if isinstance(key, tuple):
                    key, value = key
                else:
                    if key.startswith(&#39;temp_idx_arr&#39;):
                        value = np.empty((input_shape[0],), dtype=np.int_)
                value = func_kwargs.get(key, value)
                more_args += (value,)
            return more_args

        entry_more_args = _build_more_args(entry_settings, entry_kwargs)
        exit_more_args = _build_more_args(exit_settings, exit_kwargs)
        cache_more_args = _build_more_args(cache_settings, cache_kwargs)

        # Caching
        cache = use_cache
        if cache is None and cache_func is not None:
            _cache_in_output_list = cache_in_output_list
            _cache_param_list = cache_param_list
            if checks.is_numba_func(cache_func):
                if len(_cache_in_output_list) &gt; 0:
                    _cache_in_output_list = [to_typed_list(in_outputs) for in_outputs in _cache_in_output_list]
                if len(_cache_param_list) &gt; 0:
                    _cache_param_list = [to_typed_list(params) for params in _cache_param_list]

            cache = cache_func(
                *cache_input_tuple,
                *_cache_in_output_list,
                *_cache_param_list,
                *cache_args,
                *cache_more_args
            )
        if return_cache:
            return cache
        if cache is None:
            cache = ()
        if not isinstance(cache, (tuple, list, List)):
            cache = (cache,)

        entry_cache = ()
        exit_cache = ()
        if entry_settings.get(&#39;pass_cache&#39;, False):
            entry_cache = cache
        if exit_settings.get(&#39;pass_cache&#39;, False):
            exit_cache = cache

        # Apply and concatenate
        if exit_only and not iteratively:
            if len(exit_in_output_names) &gt; 0:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = ()
            if len(exit_param_names) &gt; 0:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = ()

            return combine_fns.apply_and_concat_one_nb(
                n_params,
                apply_func_nb,
                input_list[0],
                exit_wait,
                exit_input_tuple,
                *_exit_in_output_tuples,
                *_exit_param_tuples,
                exit_args + exit_more_args + exit_cache
            )

        else:
            if len(entry_in_output_names) &gt; 0:
                _entry_in_output_tuples = (to_typed_list(entry_in_output_tuples),)
            else:
                _entry_in_output_tuples = ()
            if len(entry_param_names) &gt; 0:
                _entry_param_tuples = (to_typed_list(entry_param_tuples),)
            else:
                _entry_param_tuples = ()
            if len(exit_in_output_names) &gt; 0:
                _exit_in_output_tuples = (to_typed_list(exit_in_output_tuples),)
            else:
                _exit_in_output_tuples = ()
            if len(exit_param_names) &gt; 0:
                _exit_param_tuples = (to_typed_list(exit_param_tuples),)
            else:
                _exit_param_tuples = ()

            return combine_fns.apply_and_concat_multiple_nb(
                n_params,
                apply_func_nb,
                input_shape,
                entry_wait,
                exit_wait,
                entry_input_tuple,
                exit_input_tuple,
                *_entry_in_output_tuples,
                *_exit_in_output_tuples,
                *_entry_param_tuples,
                *_exit_param_tuples,
                entry_args + entry_more_args + entry_cache,
                exit_args + exit_more_args + exit_cache
            )

    return self.from_custom_func(custom_func, pass_lists=True, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorFactory" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorFactory">IndicatorFactory</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorFactory.from_apply_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorFactory.from_apply_func">from_apply_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorFactory.from_custom_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorFactory.from_custom_func">from_custom_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorFactory.from_talib" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorFactory.from_talib">from_talib</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABmtJREFUeNrsnD1vFEkQhtve+fIuax9gDDIHQubDSMiQOEByjERGxg+4iL9DRI6A4IhAAkLIIeV0BwEICQJbwpbshRXegDbmkAW2p96erp7qpiqxg9mveWuq3nqme8aWrlw3Gu3FuJ4CFUAF0FABVAANFUAF0FABVAANFUAF0FABVAANFUAF0FABko/M7WULqysLq8v046uryLsfM2aKeuyHlerhs2PQl79x8e33/yaMOQm80H6Q/Tj68Z2s6GQ5iwCXl99fe/eK+j2Om/5Z5N2XjJmmHvvi5R/3n/ShL//X2Zff/ztvzDz1VeuD7ObtI8YM6B/U7RdcJWhufY1+8NiE1Ov/BJb+WHEf79Smfwo9YP0TdhEvHv0/dWzx6QIvvPPoT+iDiomelCY8fgh8wTRw7H9vDwRI/6fPp6Hqb9M/LypGAaAODAvAGfMHN7b+TGEyo+mfl1S1fjsbOlmMvjUx4CU2922rB3re2FhedgUJgDXhKezNnyOnxsbsgaHJMfd56+9TWPWvulYDRgEgC7RtQ5GrlzcbZntDcxpp8oPMNgBstiqQbuHwG3qjzXhLUN+WINB9Wg2A/Ckq24FjRhHgFYC6oPlLGxLcZyMBjn4eYJfkGcYeAKUnt/vM8hJKf0cBZoYDE2csnltjdZ+2/cJDUtSeEkpPtL6h7pOC3jw14U2gCWMWyMZh5BwtYwLMn9rgc5/04SuoDRVF4iZ7Iyb3SWcPSZUglMTNHhnS2y/U3lHzE04AGAQhLgj1oHQBoPqzxR6c0t9RAF4SxzkJ92klyPZeqL07mJ9EShAaxCYMuU8IvbUgANaEwR+Ckjii+4Tarx2+6OjNgwC8JK7LmAqLF9a8p3+T9usoQNQkjuI+oXu/KHoT3wM4SRylAcDus2p6zcICoCQOK0GcJI4yhUHus5MV450stAAoiZMzCdcOAaj7LJtV/+htKEriagWA2q/NfQf05qMJIyQOnsI4Sdz+UxjqPptX/xA2VNaClH2bMGR+nNFbUiUIJXEe609eeetsvALAHZiNxNWmP91QfUNv7Qkwt77K5UENI4nbvwFA6Q8t+9FJuN4CWfcJXUxN0JvsHsBJ4o7P7CnAA5A9eEx/WADeBSmcJK7fHe3lPiH/U/gYvtwFmBl+itQy7dWEA6M32SWIeU2cB/dZ+ucqmAC9zS/Q8XJI3K43AyD36bbsx7MAcxvY3Ri5u8Nc3CfLj4l1EoZI3K4NwFYwehGzpT/Ly8gEkEPidp3CsPT3bX4cBVj4uMIoQMApDLr16BG9pVOCIBL36xR29zFkfirGOsH31nJI3K9T2IOn1PRvuOzHtwuKk8T91IShRz74RW+N54Ak1qRA8CcrKtYvI6YHcJK4nVOYrV30bRcc7MFdgHhJnED36SJApCRuZwOA3OfWsh/m9JdUgthI3M4pDHKfJX/6YwJESuJ2TmF098mE3hoJECmJ+zGFQZt+WYev6CdhCET/mMLo7ZeVPQQSgJXEOSxIgTb9FkGqPyxApCRuO+jLnpvsuPtdShAUdgqDNv36WvTZsgCsJO7FP9jWMPqtR2701swFRUjithsAvf023HHHPAdESOLsFAa5z5DtV1IPAC/6f9+Qx+DuiJ7+AdCbuwCiSBz9dpi9AgD3Gbb9YgJESuIw9NbJ5ArAG2AHRjcnUaIMXv0xAUSROPhBWbVnwdOOO0YBElsTJ6H6xzoJw49JrD0FAdFbIAHkkDhSA6ravFqpAkRN4mrYQxGDAKkG97KfdgSAOzDSAlESV1N/ym67GUB2QawkrqWT4H3HHecckOJzmoqWhi9hPQAcgOgkbv9weNB2awLIely6p0dEtDh8wQLEuzt1zy4VatlPgjbUC4krKimohCQAL4mbBgVoTOL4dtxxCZAYiZNgfmItQc1JXLvoLYQAMAiaBI5tTuKCLfr0KQAviQtoRsIv+0nQBTVjDxOtswd2ASSTuLwSZw9oLigJEtfKsh9Pc0ASJE6U+xTTA0KRuDA77lgESIPElSLTnyRAAiRODnqL3oa6kThpwxcmAErisEGMn8RJYw+wACiJk7YmpZBa/eMrQQ4kzs69cshzCAHgMZiZxLW+7KfeNNYesVz17p2+QK8/xWvk84fAJGwbAOompaG3XVJ26cp1o6E9QAXQUAFUAA0VQAXQUAFUAA0VQAXQUAFUAA0VQAXQUAFUAA2++CrAAE3lth2zPPJAAAAAAElFTkSuQmCC"/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.signals" href="index.html">vectorbt.signals</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.signals.factory.SignalFactory" href="#vectorbt.signals.factory.SignalFactory">SignalFactory</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.signals.factory.SignalFactory.from_choice_func" href="#vectorbt.signals.factory.SignalFactory.from_choice_func">from_choice_func</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>