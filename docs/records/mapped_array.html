<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.records.mapped_array API documentation</title>
<meta name="description" content="Base class for working with mapped arrays â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3B4556}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="mask-icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.records.mapped_array</code></h1>
</header>
<section id="section-intro">
<p>Base class for working with mapped arrays.</p>
<p>This class takes the mapped array and the corresponding column and (optionally) index arrays,
and offers features to directly process the mapped array without converting it to the matrix form;
for example, to compute various statistics by column, such as standard deviation.</p>
<h2 id="reducing">Reducing</h2>
<p>Using <code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code>, you can then reduce by column as follows:</p>
<ul>
<li>Use already provided reducers such as <code><a title="vectorbt.records.mapped_array.MappedArray.mean" href="#vectorbt.records.mapped_array.MappedArray.mean">MappedArray.mean()</a></code>:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; a = np.array([10., 11., 12., 13., 14., 15., 16., 17., 18.])
&gt;&gt;&gt; col_arr = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2])
&gt;&gt;&gt; idx_arr = np.array([0, 1, 2, 0, 1, 2, 0, 1, 2])
&gt;&gt;&gt; wrapper = vbt.ArrayWrapper(index=['x', 'y', 'z'],
...     columns=['a', 'b', 'c'], ndim=2, freq='1 day')
&gt;&gt;&gt; ma = vbt.MappedArray(wrapper, a, col_arr, idx_arr=idx_arr)

&gt;&gt;&gt; ma.mean()
a    11.0
b    14.0
c    17.0
dtype: float64
</code></pre>
<ul>
<li>Use <code><a title="vectorbt.records.mapped_array.MappedArray.to_matrix" href="#vectorbt.records.mapped_array.MappedArray.to_matrix">MappedArray.to_matrix()</a></code> to map to a matrix and then reduce manually (expensive):</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; ma.to_matrix().mean()
a    11.0
b    14.0
c    17.0
dtype: float64
</code></pre>
<ul>
<li>Use <code><a title="vectorbt.records.mapped_array.MappedArray.reduce" href="#vectorbt.records.mapped_array.MappedArray.reduce">MappedArray.reduce()</a></code> to reduce using a custom function:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; @njit
... def pow_mean_reduce_nb(col, a, pow):
...     return np.mean(a ** pow)

&gt;&gt;&gt; ma.reduce(pow_mean_reduce_nb, 2)
a    121.666667
b    196.666667
c    289.666667
dtype: float64

&gt;&gt;&gt; @njit
... def min_max_reduce_nb(col, a):
...     return np.array([np.min(a), np.max(a)])

&gt;&gt;&gt; ma.reduce(min_max_reduce_nb, to_array=True, index=['min', 'max'])
        a     b     c
min  10.0  13.0  16.0
max  12.0  15.0  18.0

&gt;&gt;&gt; @njit
... def idxmin_idxmax_reduce_nb(col, a):
...     return np.array([np.argmin(a), np.argmax(a)])

&gt;&gt;&gt; ma.reduce(idxmin_idxmax_reduce_nb, to_array=True,
...     to_idx=True, index=['idxmin', 'idxmax'])
        a  b  c
idxmin  x  x  x
idxmax  z  z  z
</code></pre>
<h2 id="conversion">Conversion</h2>
<p>You can convert any <code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code> instance to the matrix form:</p>
<ul>
<li>Given <code>idx_arr</code> was provided:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; ma.to_matrix()
      a     b     c
x  10.0  13.0  16.0
y  11.0  14.0  17.0
z  12.0  15.0  18.0
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Will raise an error if there are multiple records pointing to the same matrix element.</p>
</div>
<ul>
<li>Given <code>group_by</code> was provided, index can be ignored, or there are position conflicts:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; ma.stack(group_by=np.array(['first', 'first', 'second']))
   first  second
0   10.0    16.0
1   11.0    17.0
2   12.0    18.0
3   13.0     NaN
4   14.0     NaN
5   15.0     NaN
</code></pre>
<h2 id="filtering">Filtering</h2>
<p>Use <code><a title="vectorbt.records.mapped_array.MappedArray.filter_by_mask" href="#vectorbt.records.mapped_array.MappedArray.filter_by_mask">MappedArray.filter_by_mask()</a></code> to filter elements per column/group:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask = [True, False, True, False, True, False, True, False, True]
&gt;&gt;&gt; filtered_ma = ma.filter_by_mask(mask)
&gt;&gt;&gt; filtered_ma.count()
a    2
b    1
c    2
dtype: int64

&gt;&gt;&gt; filtered_ma.id_arr
array([0, 2, 4, 6, 8])
</code></pre>
<h2 id="plotting">Plotting</h2>
<p>You can build histograms and boxplots of <code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code> directly:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ma.boxplot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/mapped_boxplot.png"></p>
<p>To use scatterplots or any other plots that require index, convert to matrix first:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ma.to_matrix().vbt.plot()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/mapped_plot.png"></p>
<h2 id="grouping">Grouping</h2>
<p>One of the key features of <code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code> is that you can perform reducing operations on a group
of columns as if they were a single column. Groups can be specified by <code>group_by</code>, which
can be anything from positions or names of column levels, to a NumPy array with actual groups.</p>
<p>There are multiple ways of define grouping:</p>
<ul>
<li>When creating <code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code>, pass <code>group_by</code> to <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; group_by = np.array(['first', 'first', 'second'])
&gt;&gt;&gt; grouped_wrapper = wrapper.copy(group_by=group_by)
&gt;&gt;&gt; grouped_ma = vbt.MappedArray(grouped_wrapper, a, col_arr, idx_arr=idx_arr)

&gt;&gt;&gt; grouped_ma.mean()
first     12.5
second    17.0
dtype: float64
</code></pre>
<ul>
<li>Regroup an existing <code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code>:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; ma.regroup(group_by).mean()
first     12.5
second    17.0
dtype: float64
</code></pre>
<ul>
<li>Pass <code>group_by</code> directly to the reducing method:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; ma.mean(group_by=group_by)
first     12.5
second    17.0
dtype: float64
</code></pre>
<p>By the same way you can disable or modify any existing grouping:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; grouped_ma.mean(group_by=False)
a    11.0
b    14.0
c    17.0
dtype: float64
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Grouping applies only to reducing operations, there is no change to the arrays.</p>
</div>
<h2 id="operators">Operators</h2>
<p><code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code> implements arithmetic, comparison and logical operators. You can perform basic
operations (such as addition) on mapped arrays as if they were NumPy arrays.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ma ** 2
&lt;vectorbt.records.mapped_array.MappedArray at 0x7f97bfc49358&gt;

&gt;&gt;&gt; ma * np.array([1, 2, 3, 4, 5, 6])
&lt;vectorbt.records.mapped_array.MappedArray at 0x7f97bfc65e80&gt;

&gt;&gt;&gt; ma + ma
&lt;vectorbt.records.mapped_array.MappedArray at 0x7fd638004d30&gt;
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You should ensure that your <code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code> operand is on the left if the other operand is an array.</p>
<p>If two <code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code> operands have different metadata, will copy metadata from the first one,
but at least their <code>id_arr</code> and <code>col_arr</code> must match.</p>
</div>
<h2 id="indexing">Indexing</h2>
<p>Like any other class subclassing <code><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></code>, we can do pandas indexing
on a <code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code> instance, which forwards indexing operation to each object with columns:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ma['a'].values
array([10., 11., 12.])

&gt;&gt;&gt; grouped_ma['first'].values
array([10., 11., 12., 13., 14., 15.])
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Changing index (time axis) is not supported. The object should be treated as a Series
rather than a DataFrame; for example, use <code>some_field.iloc[0]</code> instead of <code>some_field.iloc[:, 0]</code>.</p>
<p>Indexing behavior depends solely upon <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.
For example, if <code>group_select</code> is enabled indexing will be performed on groups,
otherwise on single columns.</p>
</div>
<h2 id="caching">Caching</h2>
<p><code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code> supports caching. If a method or a property requires heavy computation, it's wrapped
with <code><a title="vectorbt.utils.decorators.cached_method" href="../utils/decorators.html#vectorbt.utils.decorators.cached_method">cached_method()</a></code> and <code><a title="vectorbt.utils.decorators.cached_property" href="../utils/decorators.html#vectorbt.utils.decorators.cached_property">cached_property</a></code>
respectively. Caching can be disabled globally via <code><a title="vectorbt.settings" href="../settings.html">vectorbt.settings</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because of caching, class is meant to be immutable and all properties are read-only.
To change any attribute, use the <code>copy</code> method and pass the attribute as keyword argument.</p>
</div>
<h2 id="saving-and-loading">Saving and loading</h2>
<p>Like any other class subclassing <code><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></code>, we can save a <code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code>
instance to the disk with <code><a title="vectorbt.records.mapped_array.MappedArray.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">Pickleable.save()</a></code> and load it with <code><a title="vectorbt.records.mapped_array.MappedArray.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">Pickleable.load()</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Base class for working with mapped arrays.

This class takes the mapped array and the corresponding column and (optionally) index arrays,
and offers features to directly process the mapped array without converting it to the matrix form;
for example, to compute various statistics by column, such as standard deviation.

## Reducing

Using `MappedArray`, you can then reduce by column as follows:

* Use already provided reducers such as `MappedArray.mean`:

```python-repl
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; a = np.array([10., 11., 12., 13., 14., 15., 16., 17., 18.])
&gt;&gt;&gt; col_arr = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2])
&gt;&gt;&gt; idx_arr = np.array([0, 1, 2, 0, 1, 2, 0, 1, 2])
&gt;&gt;&gt; wrapper = vbt.ArrayWrapper(index=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;],
...     columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], ndim=2, freq=&#39;1 day&#39;)
&gt;&gt;&gt; ma = vbt.MappedArray(wrapper, a, col_arr, idx_arr=idx_arr)

&gt;&gt;&gt; ma.mean()
a    11.0
b    14.0
c    17.0
dtype: float64
```

* Use `MappedArray.to_matrix` to map to a matrix and then reduce manually (expensive):

```python-repl
&gt;&gt;&gt; ma.to_matrix().mean()
a    11.0
b    14.0
c    17.0
dtype: float64
```

* Use `MappedArray.reduce` to reduce using a custom function:

```python-repl
&gt;&gt;&gt; @njit
... def pow_mean_reduce_nb(col, a, pow):
...     return np.mean(a ** pow)

&gt;&gt;&gt; ma.reduce(pow_mean_reduce_nb, 2)
a    121.666667
b    196.666667
c    289.666667
dtype: float64

&gt;&gt;&gt; @njit
... def min_max_reduce_nb(col, a):
...     return np.array([np.min(a), np.max(a)])

&gt;&gt;&gt; ma.reduce(min_max_reduce_nb, to_array=True, index=[&#39;min&#39;, &#39;max&#39;])
        a     b     c
min  10.0  13.0  16.0
max  12.0  15.0  18.0

&gt;&gt;&gt; @njit
... def idxmin_idxmax_reduce_nb(col, a):
...     return np.array([np.argmin(a), np.argmax(a)])

&gt;&gt;&gt; ma.reduce(idxmin_idxmax_reduce_nb, to_array=True,
...     to_idx=True, index=[&#39;idxmin&#39;, &#39;idxmax&#39;])
        a  b  c
idxmin  x  x  x
idxmax  z  z  z
```

## Conversion

You can convert any `MappedArray` instance to the matrix form:

* Given `idx_arr` was provided:

```python-repl
&gt;&gt;&gt; ma.to_matrix()
      a     b     c
x  10.0  13.0  16.0
y  11.0  14.0  17.0
z  12.0  15.0  18.0
```

!!! note
    Will raise an error if there are multiple records pointing to the same matrix element.

* Given `group_by` was provided, index can be ignored, or there are position conflicts:

```python-repl
&gt;&gt;&gt; ma.stack(group_by=np.array([&#39;first&#39;, &#39;first&#39;, &#39;second&#39;]))
   first  second
0   10.0    16.0
1   11.0    17.0
2   12.0    18.0
3   13.0     NaN
4   14.0     NaN
5   15.0     NaN
```

## Filtering

Use `MappedArray.filter_by_mask` to filter elements per column/group:

```python-repl
&gt;&gt;&gt; mask = [True, False, True, False, True, False, True, False, True]
&gt;&gt;&gt; filtered_ma = ma.filter_by_mask(mask)
&gt;&gt;&gt; filtered_ma.count()
a    2
b    1
c    2
dtype: int64

&gt;&gt;&gt; filtered_ma.id_arr
array([0, 2, 4, 6, 8])
```

## Plotting

You can build histograms and boxplots of `MappedArray` directly:

```python-repl
&gt;&gt;&gt; ma.boxplot()
```

![](/vectorbt/docs/img/mapped_boxplot.png)

To use scatterplots or any other plots that require index, convert to matrix first:

```python-repl
&gt;&gt;&gt; ma.to_matrix().vbt.plot()
```

![](/vectorbt/docs/img/mapped_plot.png)

## Grouping

One of the key features of `MappedArray` is that you can perform reducing operations on a group
of columns as if they were a single column. Groups can be specified by `group_by`, which
can be anything from positions or names of column levels, to a NumPy array with actual groups.

There are multiple ways of define grouping:

* When creating `MappedArray`, pass `group_by` to `vectorbt.base.array_wrapper.ArrayWrapper`:

```python-repl
&gt;&gt;&gt; group_by = np.array([&#39;first&#39;, &#39;first&#39;, &#39;second&#39;])
&gt;&gt;&gt; grouped_wrapper = wrapper.copy(group_by=group_by)
&gt;&gt;&gt; grouped_ma = vbt.MappedArray(grouped_wrapper, a, col_arr, idx_arr=idx_arr)

&gt;&gt;&gt; grouped_ma.mean()
first     12.5
second    17.0
dtype: float64
```

* Regroup an existing `MappedArray`:

```python-repl
&gt;&gt;&gt; ma.regroup(group_by).mean()
first     12.5
second    17.0
dtype: float64
```

* Pass `group_by` directly to the reducing method:

```python-repl
&gt;&gt;&gt; ma.mean(group_by=group_by)
first     12.5
second    17.0
dtype: float64
```

By the same way you can disable or modify any existing grouping:

```python-repl
&gt;&gt;&gt; grouped_ma.mean(group_by=False)
a    11.0
b    14.0
c    17.0
dtype: float64
```

!!! note
    Grouping applies only to reducing operations, there is no change to the arrays.

## Operators

`MappedArray` implements arithmetic, comparison and logical operators. You can perform basic
operations (such as addition) on mapped arrays as if they were NumPy arrays.

```python-repl
&gt;&gt;&gt; ma ** 2
&lt;vectorbt.records.mapped_array.MappedArray at 0x7f97bfc49358&gt;

&gt;&gt;&gt; ma * np.array([1, 2, 3, 4, 5, 6])
&lt;vectorbt.records.mapped_array.MappedArray at 0x7f97bfc65e80&gt;

&gt;&gt;&gt; ma + ma
&lt;vectorbt.records.mapped_array.MappedArray at 0x7fd638004d30&gt;
```

!!! note
    You should ensure that your `MappedArray` operand is on the left if the other operand is an array.

    If two `MappedArray` operands have different metadata, will copy metadata from the first one,
    but at least their `id_arr` and `col_arr` must match.

## Indexing

Like any other class subclassing `vectorbt.base.array_wrapper.Wrapping`, we can do pandas indexing
on a `MappedArray` instance, which forwards indexing operation to each object with columns:

```python-repl
&gt;&gt;&gt; ma[&#39;a&#39;].values
array([10., 11., 12.])

&gt;&gt;&gt; grouped_ma[&#39;first&#39;].values
array([10., 11., 12., 13., 14., 15.])
```

!!! note
    Changing index (time axis) is not supported. The object should be treated as a Series
    rather than a DataFrame; for example, use `some_field.iloc[0]` instead of `some_field.iloc[:, 0]`.

    Indexing behavior depends solely upon `vectorbt.base.array_wrapper.ArrayWrapper`.
    For example, if `group_select` is enabled indexing will be performed on groups,
    otherwise on single columns.

## Caching

`MappedArray` supports caching. If a method or a property requires heavy computation, it&#39;s wrapped
with `vectorbt.utils.decorators.cached_method` and `vectorbt.utils.decorators.cached_property`
respectively. Caching can be disabled globally via `vectorbt.settings`.

!!! note
    Because of caching, class is meant to be immutable and all properties are read-only.
    To change any attribute, use the `copy` method and pass the attribute as keyword argument.

## Saving and loading

Like any other class subclassing `vectorbt.utils.config.Pickleable`, we can save a `MappedArray`
instance to the disk with `MappedArray.save` and load it with `MappedArray.load`.
&#34;&#34;&#34;

import numpy as np
import pandas as pd

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_method
from vectorbt.utils.enum import to_value_map
from vectorbt.utils.config import merge_dicts
from vectorbt.base.reshape_fns import to_1d
from vectorbt.base.class_helpers import (
    add_binary_magic_methods,
    add_unary_magic_methods,
    binary_magic_methods,
    unary_magic_methods
)
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic import nb as generic_nb
from vectorbt.records import nb
from vectorbt.records.col_mapper import ColumnMapper


def combine_mapped_with_other(self, other, np_func):
    &#34;&#34;&#34;Combine `MappedArray` with other compatible object.

    If other object is also `MappedArray`, their `id_arr` and `col_arr` must match.&#34;&#34;&#34;
    if isinstance(other, MappedArray):
        checks.assert_array_equal(self.id_arr, other.id_arr)
        checks.assert_array_equal(self.col_arr, other.col_arr)
        other = other.values
    return self.copy(mapped_arr=np_func(self.values, other))


@add_binary_magic_methods(
    binary_magic_methods,
    combine_mapped_with_other
)
@add_unary_magic_methods(
    unary_magic_methods,
    lambda self, np_func: self.copy(mapped_arr=np_func(self.values))
)
class MappedArray(Wrapping):
    &#34;&#34;&#34;Exposes methods for reducing, converting, and plotting arrays mapped by
    `vectorbt.records.base.Records` class.

    Args:
        wrapper (ArrayWrapper): Array wrapper.

            See `vectorbt.base.array_wrapper.ArrayWrapper`.
        mapped_arr (array_like): A one-dimensional array of mapped record values.
        col_arr (array_like): A one-dimensional column array.

            Must be of the same size as `mapped_arr`.
        id_arr (array_like): A one-dimensional id array. Defaults to simple range.

            Must be of the same size as `mapped_arr`.
        idx_arr (array_like): A one-dimensional index array. Optional.

            Must be of the same size as `mapped_arr`.
        value_map (namedtuple, dict or callable): Value map.
        **kwargs: Custom keyword arguments passed to the config.

            Useful if any subclass wants to extend the config.
    &#34;&#34;&#34;

    def __init__(self, wrapper, mapped_arr, col_arr, id_arr=None, idx_arr=None, value_map=None, **kwargs):
        Wrapping.__init__(
            self,
            wrapper,
            mapped_arr=mapped_arr,
            col_arr=col_arr,
            id_arr=id_arr,
            idx_arr=idx_arr,
            value_map=value_map,
            **kwargs
        )
        mapped_arr = np.asarray(mapped_arr)
        col_arr = np.asarray(col_arr)
        checks.assert_shape_equal(mapped_arr, col_arr, axis=0)
        if id_arr is None:
            id_arr = np.arange(len(mapped_arr))
        if idx_arr is not None:
            idx_arr = np.asarray(idx_arr)
            checks.assert_shape_equal(mapped_arr, idx_arr, axis=0)
        if value_map is not None:
            if checks.is_namedtuple(value_map):
                value_map = to_value_map(value_map)

        self._mapped_arr = mapped_arr
        self._id_arr = id_arr
        self._col_arr = col_arr
        self._idx_arr = idx_arr
        self._value_map = value_map
        self._col_mapper = ColumnMapper(wrapper, col_arr)

    def _indexing_func_meta(self, pd_indexing_func, **kwargs):
        &#34;&#34;&#34;Perform indexing on `MappedArray` and return metadata.&#34;&#34;&#34;
        new_wrapper, _, group_idxs, col_idxs = \
            self.wrapper._indexing_func_meta(pd_indexing_func, column_only_select=True, **kwargs)
        new_indices, new_col_arr = self.col_mapper._col_idxs_meta(col_idxs)
        new_mapped_arr = self.values[new_indices]
        new_id_arr = self.id_arr[new_indices]
        if self.idx_arr is not None:
            new_idx_arr = self.idx_arr[new_indices]
        else:
            new_idx_arr = None
        return new_wrapper, new_mapped_arr, new_col_arr, new_id_arr, new_idx_arr, group_idxs, col_idxs

    def _indexing_func(self, pd_indexing_func, **kwargs):
        &#34;&#34;&#34;Perform indexing on `MappedArray`.&#34;&#34;&#34;
        new_wrapper, new_mapped_arr, new_col_arr, new_id_arr, new_idx_arr, _, _ = \
            self._indexing_func_meta(pd_indexing_func, **kwargs)
        return self.copy(
            wrapper=new_wrapper,
            mapped_arr=new_mapped_arr,
            col_arr=new_col_arr,
            id_arr=new_id_arr,
            idx_arr=new_idx_arr
        )

    @property
    def mapped_arr(self):
        &#34;&#34;&#34;Mapped array.&#34;&#34;&#34;
        return self._mapped_arr

    values = mapped_arr

    def __len__(self):
        return len(self.values)

    @property
    def col_arr(self):
        &#34;&#34;&#34;Column array.&#34;&#34;&#34;
        return self._col_arr

    @property
    def col_mapper(self):
        &#34;&#34;&#34;Column mapper.

        See `vectorbt.records.col_mapper.ColumnMapper`.&#34;&#34;&#34;
        return self._col_mapper

    @property
    def id_arr(self):
        &#34;&#34;&#34;Id array.&#34;&#34;&#34;
        return self._id_arr

    @property
    def idx_arr(self):
        &#34;&#34;&#34;Index array.&#34;&#34;&#34;
        return self._idx_arr

    @property
    def value_map(self):
        &#34;&#34;&#34;Value map.&#34;&#34;&#34;
        return self._value_map

    @cached_method
    def is_sorted(self, incl_id=False):
        &#34;&#34;&#34;Check whether mapped array is sorted.&#34;&#34;&#34;
        if incl_id:
            return nb.is_col_idx_sorted_nb(self.col_arr, self.id_arr)
        return nb.is_col_sorted_nb(self.col_arr)

    def sort(self, incl_id=False, idx_arr=None, group_by=None, **kwargs):
        &#34;&#34;&#34;Sort mapped array by column array (primary) and id array (secondary, optional).&#34;&#34;&#34;
        if idx_arr is None:
            idx_arr = self.idx_arr
        if self.is_sorted(incl_id=incl_id):
            return self.copy(idx_arr=idx_arr, **kwargs).regroup(group_by)
        if incl_id:
            ind = np.lexsort((self.id_arr, self.col_arr))  # expensive!
        else:
            ind = np.argsort(self.col_arr)
        return self.copy(
            mapped_arr=self.values[ind],
            col_arr=self.col_arr[ind],
            id_arr=self.id_arr[ind],
            idx_arr=idx_arr[ind] if idx_arr is not None else None,
            **kwargs
        ).regroup(group_by)

    def filter_by_mask(self, mask, idx_arr=None, group_by=None, **kwargs):
        &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
        if idx_arr is None:
            idx_arr = self.idx_arr
        return self.copy(
            mapped_arr=self.values[mask],
            col_arr=self.col_arr[mask],
            id_arr=self.id_arr[mask],
            idx_arr=idx_arr[mask] if idx_arr is not None else None,
            **kwargs
        ).regroup(group_by)

    def map_to_mask(self, inout_map_func_nb, *args, group_by=None):
        &#34;&#34;&#34;Map mapped array to a mask.

        See `vectorbt.records.nb.mapped_to_mask_nb`.&#34;&#34;&#34;
        col_map = self.col_mapper.get_col_map(group_by=group_by)
        return nb.mapped_to_mask_nb(self.values, col_map, inout_map_func_nb, *args)

    @cached_method
    def top_n_mask(self, n, **kwargs):
        &#34;&#34;&#34;Return mask of top N elements in each column.&#34;&#34;&#34;
        return self.map_to_mask(nb.top_n_inout_map_nb, n, **kwargs)

    @cached_method
    def bottom_n_mask(self, n, **kwargs):
        &#34;&#34;&#34;Return mask of bottom N elements in each column.&#34;&#34;&#34;
        return self.map_to_mask(nb.bottom_n_inout_map_nb, n, **kwargs)

    @cached_method
    def top_n(self, n, **kwargs):
        &#34;&#34;&#34;Filter top N elements from each column.&#34;&#34;&#34;
        return self.filter_by_mask(self.top_n_mask(n), **kwargs)

    @cached_method
    def bottom_n(self, n, **kwargs):
        &#34;&#34;&#34;Filter bottom N elements from each column.&#34;&#34;&#34;
        return self.filter_by_mask(self.bottom_n_mask(n), **kwargs)

    @cached_method
    def is_matrix_compatible(self, idx_arr=None, group_by=None):
        &#34;&#34;&#34;See `vectorbt.records.nb.mapped_matrix_compatible_nb`.&#34;&#34;&#34;
        if idx_arr is None:
            if self.idx_arr is None:
                raise ValueError(&#34;Must pass idx_arr&#34;)
            idx_arr = self.idx_arr
        col_arr = self.col_mapper.get_col_arr(group_by=group_by)
        target_shape = self.wrapper.get_shape_2d(group_by=group_by)
        return nb.mapped_matrix_compatible_nb(col_arr, idx_arr, target_shape)

    def to_matrix(self, idx_arr=None, default_val=np.nan, group_by=None, wrap_kwargs=None):
        &#34;&#34;&#34;Convert mapped array to the matrix form.

        See `vectorbt.records.nb.mapped_to_matrix_nb`.

        !!! note
            Will raise an error if there are multiple values pointing to the same matrix element.

        !!! warning
            Mapped arrays represent information in the most memory-friendly format.
            Mapping back to the matrix form may occupy lots of memory if records are sparse.&#34;&#34;&#34;
        if idx_arr is None:
            if self.idx_arr is None:
                raise ValueError(&#34;Must pass idx_arr&#34;)
            idx_arr = self.idx_arr
        if not self.is_matrix_compatible(idx_arr=idx_arr, group_by=group_by):
            raise ValueError(&#34;Multiple values are pointing to the same matrix element&#34;)
        col_arr = self.col_mapper.get_col_arr(group_by=group_by)
        target_shape = self.wrapper.get_shape_2d(group_by=group_by)
        out = nb.mapped_to_matrix_nb(self.values, col_arr, idx_arr, target_shape, default_val)
        return self.wrapper.wrap(out, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    def reduce(self, reduce_func_nb, *args, idx_arr=None, to_array=False, to_idx=False,
               idx_labeled=True, default_val=np.nan, group_by=None, wrap_kwargs=None):
        &#34;&#34;&#34;Reduce mapped array by column.

        If `to_array` is False and `to_idx` is False, see `vectorbt.records.nb.reduce_mapped_nb`.
        If `to_array` is False and `to_idx` is True, see `vectorbt.records.nb.reduce_mapped_to_idx_nb`.
        If `to_array` is True and `to_idx` is False, see `vectorbt.records.nb.reduce_mapped_to_array_nb`.
        If `to_array` is True and `to_idx` is True, see `vectorbt.records.nb.reduce_mapped_to_idx_array_nb`.

        If `to_idx` is True, must pass `idx_arr`. Set `idx_labeled` to False to return raw positions instead
        of labels. Use `default_val` to set the default value. Set `group_by` to False to disable grouping.
        &#34;&#34;&#34;
        # Perform checks
        checks.assert_numba_func(reduce_func_nb)
        if idx_arr is None:
            if self.idx_arr is None:
                if to_idx:
                    raise ValueError(&#34;Must pass idx_arr&#34;)
            idx_arr = self.idx_arr

        # Perform main computation
        col_map = self.col_mapper.get_col_map(group_by=group_by)
        if not to_array:
            if not to_idx:
                out = nb.reduce_mapped_nb(
                    self.values,
                    col_map,
                    default_val,
                    reduce_func_nb,
                    *args
                )
            else:
                out = nb.reduce_mapped_to_idx_nb(
                    self.values,
                    col_map,
                    idx_arr,
                    default_val,
                    reduce_func_nb,
                    *args
                )
        else:
            if not to_idx:
                out = nb.reduce_mapped_to_array_nb(
                    self.values,
                    col_map,
                    default_val,
                    reduce_func_nb,
                    *args
                )
            else:
                out = nb.reduce_mapped_to_idx_array_nb(
                    self.values,
                    col_map,
                    idx_arr,
                    default_val,
                    reduce_func_nb,
                    *args
                )

        # Perform post-processing
        if to_idx:
            nan_mask = np.isnan(out)
            if idx_labeled:
                out = out.astype(np.object)
                out[~nan_mask] = self.wrapper.index[out[~nan_mask].astype(np.int_)]
            else:
                out[nan_mask] = -1
                out = out.astype(np.int_)
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;reduce&#39; if not to_array else None), wrap_kwargs)
        return self.wrapper.wrap_reduced(out, group_by=group_by, **wrap_kwargs)

    @cached_method
    def nst(self, n, **kwargs):
        &#34;&#34;&#34;Return nst element of each column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;nst&#39;)), kwargs)
        return self.reduce(generic_nb.nst_reduce_nb, n, to_array=False, to_idx=False, **kwargs)

    @cached_method
    def min(self, **kwargs):
        &#34;&#34;&#34;Return min by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;min&#39;)), kwargs)
        return self.reduce(generic_nb.min_reduce_nb, to_array=False, to_idx=False, **kwargs)

    @cached_method
    def max(self, **kwargs):
        &#34;&#34;&#34;Return max by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;max&#39;)), kwargs)
        return self.reduce(generic_nb.max_reduce_nb, to_array=False, to_idx=False, **kwargs)

    @cached_method
    def mean(self, **kwargs):
        &#34;&#34;&#34;Return mean by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;mean&#39;)), kwargs)
        return self.reduce(generic_nb.mean_reduce_nb, to_array=False, to_idx=False, **kwargs)

    @cached_method
    def median(self, **kwargs):
        &#34;&#34;&#34;Return median by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;median&#39;)), kwargs)
        return self.reduce(generic_nb.median_reduce_nb, to_array=False, to_idx=False, **kwargs)

    @cached_method
    def std(self, ddof=1, **kwargs):
        &#34;&#34;&#34;Return std by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;std&#39;)), kwargs)
        return self.reduce(generic_nb.std_reduce_nb, ddof, to_array=False, to_idx=False, **kwargs)

    @cached_method
    def sum(self, default_val=0., **kwargs):
        &#34;&#34;&#34;Return sum by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;sum&#39;)), kwargs)
        return self.reduce(
            generic_nb.sum_reduce_nb,
            to_array=False,
            to_idx=False,
            default_val=default_val,
            **kwargs
        )

    @cached_method
    def idxmin(self, **kwargs):
        &#34;&#34;&#34;Return index of min by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;idxmin&#39;)), kwargs)
        return self.reduce(generic_nb.argmin_reduce_nb, to_array=False, to_idx=True, **kwargs)

    @cached_method
    def idxmax(self, **kwargs):
        &#34;&#34;&#34;Return index of max by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;idxmax&#39;)), kwargs)
        return self.reduce(generic_nb.argmax_reduce_nb, to_array=False, to_idx=True, **kwargs)

    @cached_method
    def describe(self, percentiles=None, ddof=1, **kwargs):
        &#34;&#34;&#34;Return statistics by column.&#34;&#34;&#34;
        if percentiles is not None:
            percentiles = to_1d(percentiles, raw=True)
        else:
            percentiles = np.array([0.25, 0.5, 0.75])
        percentiles = percentiles.tolist()
        if 0.5 not in percentiles:
            percentiles.append(0.5)
        percentiles = np.unique(percentiles)
        perc_formatted = pd.io.formats.format.format_percentiles(percentiles)
        index = pd.Index([&#39;count&#39;, &#39;mean&#39;, &#39;std&#39;, &#39;min&#39;, *perc_formatted, &#39;max&#39;])
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=index)), kwargs)
        out = self.reduce(
            generic_nb.describe_reduce_nb,
            percentiles,
            ddof,
            to_array=True,
            to_idx=False,
            **kwargs
        )
        if isinstance(out, pd.DataFrame):
            out.loc[&#39;count&#39;].fillna(0., inplace=True)
        else:
            if np.isnan(out.loc[&#39;count&#39;]):
                out.loc[&#39;count&#39;] = 0.
        return out

    @cached_method
    def count(self, group_by=None, wrap_kwargs=None):
        &#34;&#34;&#34;Return count by column.&#34;&#34;&#34;
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;count&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(
            self.col_mapper.get_col_map(group_by=group_by)[1],
            group_by=group_by, **wrap_kwargs)

    @cached_method
    def value_counts(self, group_by=None, value_map=None, wrap_kwargs=None):
        &#34;&#34;&#34;Return a pandas object containing counts of unique values.&#34;&#34;&#34;
        mapped_codes, mapped_uniques = pd.factorize(self.values)
        col_map = self.col_mapper.get_col_map(group_by=group_by)
        value_counts = nb.mapped_value_counts_nb(mapped_codes, col_map)
        value_counts_df = self.wrapper.wrap(
            value_counts,
            index=mapped_uniques,
            group_by=group_by,
            **merge_dicts({}, wrap_kwargs)
        )
        if value_map is None:
            value_map = self.value_map
        if value_map is not None:
            if checks.is_namedtuple(value_map):
                value_map = to_value_map(value_map)
            value_counts_df.index = value_counts_df.index.map(value_map)
        return value_counts_df

    def stack(self, group_by=None, default_val=np.nan, wrap_kwargs=None):
        &#34;&#34;&#34;Stack into a matrix.

        Will lose index information and fill missing values with `default_val`.&#34;&#34;&#34;
        if self.wrapper.ndim == 1:
            return self.wrapper.wrap(
                self.values,
                index=np.arange(len(self.values)),
                group_by=group_by,
                **merge_dicts({}, wrap_kwargs)
            )
        col_map = self.col_mapper.get_col_map(group_by=group_by)
        out = nb.stack_mapped_nb(self.values, col_map, default_val)
        return self.wrapper.wrap(
            out, index=np.arange(out.shape[0]),
            group_by=group_by, **merge_dicts({}, wrap_kwargs))

    def histplot(self, group_by=None, **kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot histogram by column.&#34;&#34;&#34;
        return self.stack(group_by=group_by).vbt.histplot(**kwargs)

    def boxplot(self, group_by=None, **kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot box plot by column.&#34;&#34;&#34;
        return self.stack(group_by=group_by).vbt.boxplot(**kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.records.mapped_array.combine_mapped_with_other"><code class="name flex">
<span>def <span class="ident fname">combine_mapped_with_other</span></span>(<span>self, other, np_func)</span>
</code></dt>
<dd>
<div class="desc"><p>Combine <code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code> with other compatible object.</p>
<p>If other object is also <code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code>, their <code>id_arr</code> and <code>col_arr</code> must match.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_mapped_with_other(self, other, np_func):
    &#34;&#34;&#34;Combine `MappedArray` with other compatible object.

    If other object is also `MappedArray`, their `id_arr` and `col_arr` must match.&#34;&#34;&#34;
    if isinstance(other, MappedArray):
        checks.assert_array_equal(self.id_arr, other.id_arr)
        checks.assert_array_equal(self.col_arr, other.col_arr)
        other = other.values
    return self.copy(mapped_arr=np_func(self.values, other))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.records.mapped_array.MappedArray"><code class="flex name class">
<span>class <span class="ident parent-fname">MappedArray</span></span>
<span>(</span><span>wrapper, mapped_arr, col_arr, id_arr=None, idx_arr=None, value_map=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Exposes methods for reducing, converting, and plotting arrays mapped by
<code><a title="vectorbt.records.base.Records" href="base.html#vectorbt.records.base.Records">Records</a></code> class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrapper</code></strong> :&ensp;<code>ArrayWrapper</code></dt>
<dd>
<p>Array wrapper.</p>
<p>See <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</p>
</dd>
<dt><strong><code>mapped_arr</code></strong> :&ensp;<code>array_like</code></dt>
<dd>A one-dimensional array of mapped record values.</dd>
<dt><strong><code>col_arr</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>A one-dimensional column array.</p>
<p>Must be of the same size as <code>mapped_arr</code>.</p>
</dd>
<dt><strong><code>id_arr</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>A one-dimensional id array. Defaults to simple range.</p>
<p>Must be of the same size as <code>mapped_arr</code>.</p>
</dd>
<dt><strong><code>idx_arr</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>A one-dimensional index array. Optional.</p>
<p>Must be of the same size as <code>mapped_arr</code>.</p>
</dd>
<dt><strong><code>value_map</code></strong> :&ensp;<code>namedtuple, dict</code> or <code>callable</code></dt>
<dd>Value map.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>
<p>Custom keyword arguments passed to the config.</p>
<p>Useful if any subclass wants to extend the config.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MappedArray(Wrapping):
    &#34;&#34;&#34;Exposes methods for reducing, converting, and plotting arrays mapped by
    `vectorbt.records.base.Records` class.

    Args:
        wrapper (ArrayWrapper): Array wrapper.

            See `vectorbt.base.array_wrapper.ArrayWrapper`.
        mapped_arr (array_like): A one-dimensional array of mapped record values.
        col_arr (array_like): A one-dimensional column array.

            Must be of the same size as `mapped_arr`.
        id_arr (array_like): A one-dimensional id array. Defaults to simple range.

            Must be of the same size as `mapped_arr`.
        idx_arr (array_like): A one-dimensional index array. Optional.

            Must be of the same size as `mapped_arr`.
        value_map (namedtuple, dict or callable): Value map.
        **kwargs: Custom keyword arguments passed to the config.

            Useful if any subclass wants to extend the config.
    &#34;&#34;&#34;

    def __init__(self, wrapper, mapped_arr, col_arr, id_arr=None, idx_arr=None, value_map=None, **kwargs):
        Wrapping.__init__(
            self,
            wrapper,
            mapped_arr=mapped_arr,
            col_arr=col_arr,
            id_arr=id_arr,
            idx_arr=idx_arr,
            value_map=value_map,
            **kwargs
        )
        mapped_arr = np.asarray(mapped_arr)
        col_arr = np.asarray(col_arr)
        checks.assert_shape_equal(mapped_arr, col_arr, axis=0)
        if id_arr is None:
            id_arr = np.arange(len(mapped_arr))
        if idx_arr is not None:
            idx_arr = np.asarray(idx_arr)
            checks.assert_shape_equal(mapped_arr, idx_arr, axis=0)
        if value_map is not None:
            if checks.is_namedtuple(value_map):
                value_map = to_value_map(value_map)

        self._mapped_arr = mapped_arr
        self._id_arr = id_arr
        self._col_arr = col_arr
        self._idx_arr = idx_arr
        self._value_map = value_map
        self._col_mapper = ColumnMapper(wrapper, col_arr)

    def _indexing_func_meta(self, pd_indexing_func, **kwargs):
        &#34;&#34;&#34;Perform indexing on `MappedArray` and return metadata.&#34;&#34;&#34;
        new_wrapper, _, group_idxs, col_idxs = \
            self.wrapper._indexing_func_meta(pd_indexing_func, column_only_select=True, **kwargs)
        new_indices, new_col_arr = self.col_mapper._col_idxs_meta(col_idxs)
        new_mapped_arr = self.values[new_indices]
        new_id_arr = self.id_arr[new_indices]
        if self.idx_arr is not None:
            new_idx_arr = self.idx_arr[new_indices]
        else:
            new_idx_arr = None
        return new_wrapper, new_mapped_arr, new_col_arr, new_id_arr, new_idx_arr, group_idxs, col_idxs

    def _indexing_func(self, pd_indexing_func, **kwargs):
        &#34;&#34;&#34;Perform indexing on `MappedArray`.&#34;&#34;&#34;
        new_wrapper, new_mapped_arr, new_col_arr, new_id_arr, new_idx_arr, _, _ = \
            self._indexing_func_meta(pd_indexing_func, **kwargs)
        return self.copy(
            wrapper=new_wrapper,
            mapped_arr=new_mapped_arr,
            col_arr=new_col_arr,
            id_arr=new_id_arr,
            idx_arr=new_idx_arr
        )

    @property
    def mapped_arr(self):
        &#34;&#34;&#34;Mapped array.&#34;&#34;&#34;
        return self._mapped_arr

    values = mapped_arr

    def __len__(self):
        return len(self.values)

    @property
    def col_arr(self):
        &#34;&#34;&#34;Column array.&#34;&#34;&#34;
        return self._col_arr

    @property
    def col_mapper(self):
        &#34;&#34;&#34;Column mapper.

        See `vectorbt.records.col_mapper.ColumnMapper`.&#34;&#34;&#34;
        return self._col_mapper

    @property
    def id_arr(self):
        &#34;&#34;&#34;Id array.&#34;&#34;&#34;
        return self._id_arr

    @property
    def idx_arr(self):
        &#34;&#34;&#34;Index array.&#34;&#34;&#34;
        return self._idx_arr

    @property
    def value_map(self):
        &#34;&#34;&#34;Value map.&#34;&#34;&#34;
        return self._value_map

    @cached_method
    def is_sorted(self, incl_id=False):
        &#34;&#34;&#34;Check whether mapped array is sorted.&#34;&#34;&#34;
        if incl_id:
            return nb.is_col_idx_sorted_nb(self.col_arr, self.id_arr)
        return nb.is_col_sorted_nb(self.col_arr)

    def sort(self, incl_id=False, idx_arr=None, group_by=None, **kwargs):
        &#34;&#34;&#34;Sort mapped array by column array (primary) and id array (secondary, optional).&#34;&#34;&#34;
        if idx_arr is None:
            idx_arr = self.idx_arr
        if self.is_sorted(incl_id=incl_id):
            return self.copy(idx_arr=idx_arr, **kwargs).regroup(group_by)
        if incl_id:
            ind = np.lexsort((self.id_arr, self.col_arr))  # expensive!
        else:
            ind = np.argsort(self.col_arr)
        return self.copy(
            mapped_arr=self.values[ind],
            col_arr=self.col_arr[ind],
            id_arr=self.id_arr[ind],
            idx_arr=idx_arr[ind] if idx_arr is not None else None,
            **kwargs
        ).regroup(group_by)

    def filter_by_mask(self, mask, idx_arr=None, group_by=None, **kwargs):
        &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
        if idx_arr is None:
            idx_arr = self.idx_arr
        return self.copy(
            mapped_arr=self.values[mask],
            col_arr=self.col_arr[mask],
            id_arr=self.id_arr[mask],
            idx_arr=idx_arr[mask] if idx_arr is not None else None,
            **kwargs
        ).regroup(group_by)

    def map_to_mask(self, inout_map_func_nb, *args, group_by=None):
        &#34;&#34;&#34;Map mapped array to a mask.

        See `vectorbt.records.nb.mapped_to_mask_nb`.&#34;&#34;&#34;
        col_map = self.col_mapper.get_col_map(group_by=group_by)
        return nb.mapped_to_mask_nb(self.values, col_map, inout_map_func_nb, *args)

    @cached_method
    def top_n_mask(self, n, **kwargs):
        &#34;&#34;&#34;Return mask of top N elements in each column.&#34;&#34;&#34;
        return self.map_to_mask(nb.top_n_inout_map_nb, n, **kwargs)

    @cached_method
    def bottom_n_mask(self, n, **kwargs):
        &#34;&#34;&#34;Return mask of bottom N elements in each column.&#34;&#34;&#34;
        return self.map_to_mask(nb.bottom_n_inout_map_nb, n, **kwargs)

    @cached_method
    def top_n(self, n, **kwargs):
        &#34;&#34;&#34;Filter top N elements from each column.&#34;&#34;&#34;
        return self.filter_by_mask(self.top_n_mask(n), **kwargs)

    @cached_method
    def bottom_n(self, n, **kwargs):
        &#34;&#34;&#34;Filter bottom N elements from each column.&#34;&#34;&#34;
        return self.filter_by_mask(self.bottom_n_mask(n), **kwargs)

    @cached_method
    def is_matrix_compatible(self, idx_arr=None, group_by=None):
        &#34;&#34;&#34;See `vectorbt.records.nb.mapped_matrix_compatible_nb`.&#34;&#34;&#34;
        if idx_arr is None:
            if self.idx_arr is None:
                raise ValueError(&#34;Must pass idx_arr&#34;)
            idx_arr = self.idx_arr
        col_arr = self.col_mapper.get_col_arr(group_by=group_by)
        target_shape = self.wrapper.get_shape_2d(group_by=group_by)
        return nb.mapped_matrix_compatible_nb(col_arr, idx_arr, target_shape)

    def to_matrix(self, idx_arr=None, default_val=np.nan, group_by=None, wrap_kwargs=None):
        &#34;&#34;&#34;Convert mapped array to the matrix form.

        See `vectorbt.records.nb.mapped_to_matrix_nb`.

        !!! note
            Will raise an error if there are multiple values pointing to the same matrix element.

        !!! warning
            Mapped arrays represent information in the most memory-friendly format.
            Mapping back to the matrix form may occupy lots of memory if records are sparse.&#34;&#34;&#34;
        if idx_arr is None:
            if self.idx_arr is None:
                raise ValueError(&#34;Must pass idx_arr&#34;)
            idx_arr = self.idx_arr
        if not self.is_matrix_compatible(idx_arr=idx_arr, group_by=group_by):
            raise ValueError(&#34;Multiple values are pointing to the same matrix element&#34;)
        col_arr = self.col_mapper.get_col_arr(group_by=group_by)
        target_shape = self.wrapper.get_shape_2d(group_by=group_by)
        out = nb.mapped_to_matrix_nb(self.values, col_arr, idx_arr, target_shape, default_val)
        return self.wrapper.wrap(out, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    def reduce(self, reduce_func_nb, *args, idx_arr=None, to_array=False, to_idx=False,
               idx_labeled=True, default_val=np.nan, group_by=None, wrap_kwargs=None):
        &#34;&#34;&#34;Reduce mapped array by column.

        If `to_array` is False and `to_idx` is False, see `vectorbt.records.nb.reduce_mapped_nb`.
        If `to_array` is False and `to_idx` is True, see `vectorbt.records.nb.reduce_mapped_to_idx_nb`.
        If `to_array` is True and `to_idx` is False, see `vectorbt.records.nb.reduce_mapped_to_array_nb`.
        If `to_array` is True and `to_idx` is True, see `vectorbt.records.nb.reduce_mapped_to_idx_array_nb`.

        If `to_idx` is True, must pass `idx_arr`. Set `idx_labeled` to False to return raw positions instead
        of labels. Use `default_val` to set the default value. Set `group_by` to False to disable grouping.
        &#34;&#34;&#34;
        # Perform checks
        checks.assert_numba_func(reduce_func_nb)
        if idx_arr is None:
            if self.idx_arr is None:
                if to_idx:
                    raise ValueError(&#34;Must pass idx_arr&#34;)
            idx_arr = self.idx_arr

        # Perform main computation
        col_map = self.col_mapper.get_col_map(group_by=group_by)
        if not to_array:
            if not to_idx:
                out = nb.reduce_mapped_nb(
                    self.values,
                    col_map,
                    default_val,
                    reduce_func_nb,
                    *args
                )
            else:
                out = nb.reduce_mapped_to_idx_nb(
                    self.values,
                    col_map,
                    idx_arr,
                    default_val,
                    reduce_func_nb,
                    *args
                )
        else:
            if not to_idx:
                out = nb.reduce_mapped_to_array_nb(
                    self.values,
                    col_map,
                    default_val,
                    reduce_func_nb,
                    *args
                )
            else:
                out = nb.reduce_mapped_to_idx_array_nb(
                    self.values,
                    col_map,
                    idx_arr,
                    default_val,
                    reduce_func_nb,
                    *args
                )

        # Perform post-processing
        if to_idx:
            nan_mask = np.isnan(out)
            if idx_labeled:
                out = out.astype(np.object)
                out[~nan_mask] = self.wrapper.index[out[~nan_mask].astype(np.int_)]
            else:
                out[nan_mask] = -1
                out = out.astype(np.int_)
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;reduce&#39; if not to_array else None), wrap_kwargs)
        return self.wrapper.wrap_reduced(out, group_by=group_by, **wrap_kwargs)

    @cached_method
    def nst(self, n, **kwargs):
        &#34;&#34;&#34;Return nst element of each column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;nst&#39;)), kwargs)
        return self.reduce(generic_nb.nst_reduce_nb, n, to_array=False, to_idx=False, **kwargs)

    @cached_method
    def min(self, **kwargs):
        &#34;&#34;&#34;Return min by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;min&#39;)), kwargs)
        return self.reduce(generic_nb.min_reduce_nb, to_array=False, to_idx=False, **kwargs)

    @cached_method
    def max(self, **kwargs):
        &#34;&#34;&#34;Return max by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;max&#39;)), kwargs)
        return self.reduce(generic_nb.max_reduce_nb, to_array=False, to_idx=False, **kwargs)

    @cached_method
    def mean(self, **kwargs):
        &#34;&#34;&#34;Return mean by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;mean&#39;)), kwargs)
        return self.reduce(generic_nb.mean_reduce_nb, to_array=False, to_idx=False, **kwargs)

    @cached_method
    def median(self, **kwargs):
        &#34;&#34;&#34;Return median by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;median&#39;)), kwargs)
        return self.reduce(generic_nb.median_reduce_nb, to_array=False, to_idx=False, **kwargs)

    @cached_method
    def std(self, ddof=1, **kwargs):
        &#34;&#34;&#34;Return std by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;std&#39;)), kwargs)
        return self.reduce(generic_nb.std_reduce_nb, ddof, to_array=False, to_idx=False, **kwargs)

    @cached_method
    def sum(self, default_val=0., **kwargs):
        &#34;&#34;&#34;Return sum by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;sum&#39;)), kwargs)
        return self.reduce(
            generic_nb.sum_reduce_nb,
            to_array=False,
            to_idx=False,
            default_val=default_val,
            **kwargs
        )

    @cached_method
    def idxmin(self, **kwargs):
        &#34;&#34;&#34;Return index of min by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;idxmin&#39;)), kwargs)
        return self.reduce(generic_nb.argmin_reduce_nb, to_array=False, to_idx=True, **kwargs)

    @cached_method
    def idxmax(self, **kwargs):
        &#34;&#34;&#34;Return index of max by column.&#34;&#34;&#34;
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;idxmax&#39;)), kwargs)
        return self.reduce(generic_nb.argmax_reduce_nb, to_array=False, to_idx=True, **kwargs)

    @cached_method
    def describe(self, percentiles=None, ddof=1, **kwargs):
        &#34;&#34;&#34;Return statistics by column.&#34;&#34;&#34;
        if percentiles is not None:
            percentiles = to_1d(percentiles, raw=True)
        else:
            percentiles = np.array([0.25, 0.5, 0.75])
        percentiles = percentiles.tolist()
        if 0.5 not in percentiles:
            percentiles.append(0.5)
        percentiles = np.unique(percentiles)
        perc_formatted = pd.io.formats.format.format_percentiles(percentiles)
        index = pd.Index([&#39;count&#39;, &#39;mean&#39;, &#39;std&#39;, &#39;min&#39;, *perc_formatted, &#39;max&#39;])
        kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=index)), kwargs)
        out = self.reduce(
            generic_nb.describe_reduce_nb,
            percentiles,
            ddof,
            to_array=True,
            to_idx=False,
            **kwargs
        )
        if isinstance(out, pd.DataFrame):
            out.loc[&#39;count&#39;].fillna(0., inplace=True)
        else:
            if np.isnan(out.loc[&#39;count&#39;]):
                out.loc[&#39;count&#39;] = 0.
        return out

    @cached_method
    def count(self, group_by=None, wrap_kwargs=None):
        &#34;&#34;&#34;Return count by column.&#34;&#34;&#34;
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;count&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(
            self.col_mapper.get_col_map(group_by=group_by)[1],
            group_by=group_by, **wrap_kwargs)

    @cached_method
    def value_counts(self, group_by=None, value_map=None, wrap_kwargs=None):
        &#34;&#34;&#34;Return a pandas object containing counts of unique values.&#34;&#34;&#34;
        mapped_codes, mapped_uniques = pd.factorize(self.values)
        col_map = self.col_mapper.get_col_map(group_by=group_by)
        value_counts = nb.mapped_value_counts_nb(mapped_codes, col_map)
        value_counts_df = self.wrapper.wrap(
            value_counts,
            index=mapped_uniques,
            group_by=group_by,
            **merge_dicts({}, wrap_kwargs)
        )
        if value_map is None:
            value_map = self.value_map
        if value_map is not None:
            if checks.is_namedtuple(value_map):
                value_map = to_value_map(value_map)
            value_counts_df.index = value_counts_df.index.map(value_map)
        return value_counts_df

    def stack(self, group_by=None, default_val=np.nan, wrap_kwargs=None):
        &#34;&#34;&#34;Stack into a matrix.

        Will lose index information and fill missing values with `default_val`.&#34;&#34;&#34;
        if self.wrapper.ndim == 1:
            return self.wrapper.wrap(
                self.values,
                index=np.arange(len(self.values)),
                group_by=group_by,
                **merge_dicts({}, wrap_kwargs)
            )
        col_map = self.col_mapper.get_col_map(group_by=group_by)
        out = nb.stack_mapped_nb(self.values, col_map, default_val)
        return self.wrapper.wrap(
            out, index=np.arange(out.shape[0]),
            group_by=group_by, **merge_dicts({}, wrap_kwargs))

    def histplot(self, group_by=None, **kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot histogram by column.&#34;&#34;&#34;
        return self.stack(group_by=group_by).vbt.histplot(**kwargs)

    def boxplot(self, group_by=None, **kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot box plot by column.&#34;&#34;&#34;
        return self.stack(group_by=group_by).vbt.boxplot(**kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.records.mapped_array.MappedArray.col_arr"><code class="name">var <span class="ident fname">col_arr</span></code></dt>
<dd>
<div class="desc"><p>Column array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def col_arr(self):
    &#34;&#34;&#34;Column array.&#34;&#34;&#34;
    return self._col_arr</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.col_mapper"><code class="name">var <span class="ident fname">col_mapper</span></code></dt>
<dd>
<div class="desc"><p>Column mapper.</p>
<p>See <code><a title="vectorbt.records.col_mapper.ColumnMapper" href="col_mapper.html#vectorbt.records.col_mapper.ColumnMapper">ColumnMapper</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def col_mapper(self):
    &#34;&#34;&#34;Column mapper.

    See `vectorbt.records.col_mapper.ColumnMapper`.&#34;&#34;&#34;
    return self._col_mapper</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.id_arr"><code class="name">var <span class="ident fname">id_arr</span></code></dt>
<dd>
<div class="desc"><p>Id array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id_arr(self):
    &#34;&#34;&#34;Id array.&#34;&#34;&#34;
    return self._id_arr</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.idx_arr"><code class="name">var <span class="ident fname">idx_arr</span></code></dt>
<dd>
<div class="desc"><p>Index array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def idx_arr(self):
    &#34;&#34;&#34;Index array.&#34;&#34;&#34;
    return self._idx_arr</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.mapped_arr"><code class="name">var <span class="ident fname">mapped_arr</span></code></dt>
<dd>
<div class="desc"><p>Mapped array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mapped_arr(self):
    &#34;&#34;&#34;Mapped array.&#34;&#34;&#34;
    return self._mapped_arr</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.value_map"><code class="name">var <span class="ident fname">value_map</span></code></dt>
<dd>
<div class="desc"><p>Value map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value_map(self):
    &#34;&#34;&#34;Value map.&#34;&#34;&#34;
    return self._value_map</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.values"><code class="name">var <span class="ident fname">values</span></code></dt>
<dd>
<div class="desc"><p>Mapped array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mapped_arr(self):
    &#34;&#34;&#34;Mapped array.&#34;&#34;&#34;
    return self._mapped_arr</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.records.mapped_array.MappedArray.bottom_n"><code class="name flex">
<span>def <span class="ident fname">bottom_n</span></span>(<span>self, n, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter bottom N elements from each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def bottom_n(self, n, **kwargs):
    &#34;&#34;&#34;Filter bottom N elements from each column.&#34;&#34;&#34;
    return self.filter_by_mask(self.bottom_n_mask(n), **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.bottom_n_mask"><code class="name flex">
<span>def <span class="ident fname">bottom_n_mask</span></span>(<span>self, n, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return mask of bottom N elements in each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def bottom_n_mask(self, n, **kwargs):
    &#34;&#34;&#34;Return mask of bottom N elements in each column.&#34;&#34;&#34;
    return self.map_to_mask(nb.bottom_n_inout_map_nb, n, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.boxplot"><code class="name flex">
<span>def <span class="ident fname">boxplot</span></span>(<span>self, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot box plot by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boxplot(self, group_by=None, **kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot box plot by column.&#34;&#34;&#34;
    return self.stack(group_by=group_by).vbt.boxplot(**kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.count"><code class="name flex">
<span>def <span class="ident fname">count</span></span>(<span>self, group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return count by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def count(self, group_by=None, wrap_kwargs=None):
    &#34;&#34;&#34;Return count by column.&#34;&#34;&#34;
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;count&#39;), wrap_kwargs)
    return self.wrapper.wrap_reduced(
        self.col_mapper.get_col_map(group_by=group_by)[1],
        group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.describe"><code class="name flex">
<span>def <span class="ident fname">describe</span></span>(<span>self, percentiles=None, ddof=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return statistics by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def describe(self, percentiles=None, ddof=1, **kwargs):
    &#34;&#34;&#34;Return statistics by column.&#34;&#34;&#34;
    if percentiles is not None:
        percentiles = to_1d(percentiles, raw=True)
    else:
        percentiles = np.array([0.25, 0.5, 0.75])
    percentiles = percentiles.tolist()
    if 0.5 not in percentiles:
        percentiles.append(0.5)
    percentiles = np.unique(percentiles)
    perc_formatted = pd.io.formats.format.format_percentiles(percentiles)
    index = pd.Index([&#39;count&#39;, &#39;mean&#39;, &#39;std&#39;, &#39;min&#39;, *perc_formatted, &#39;max&#39;])
    kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=index)), kwargs)
    out = self.reduce(
        generic_nb.describe_reduce_nb,
        percentiles,
        ddof,
        to_array=True,
        to_idx=False,
        **kwargs
    )
    if isinstance(out, pd.DataFrame):
        out.loc[&#39;count&#39;].fillna(0., inplace=True)
    else:
        if np.isnan(out.loc[&#39;count&#39;]):
            out.loc[&#39;count&#39;] = 0.
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.filter_by_mask"><code class="name flex">
<span>def <span class="ident fname">filter_by_mask</span></span>(<span>self, mask, idx_arr=None, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new class instance, filtered by mask.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_mask(self, mask, idx_arr=None, group_by=None, **kwargs):
    &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
    if idx_arr is None:
        idx_arr = self.idx_arr
    return self.copy(
        mapped_arr=self.values[mask],
        col_arr=self.col_arr[mask],
        id_arr=self.id_arr[mask],
        idx_arr=idx_arr[mask] if idx_arr is not None else None,
        **kwargs
    ).regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.histplot"><code class="name flex">
<span>def <span class="ident fname">histplot</span></span>(<span>self, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot histogram by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def histplot(self, group_by=None, **kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot histogram by column.&#34;&#34;&#34;
    return self.stack(group_by=group_by).vbt.histplot(**kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.idxmax"><code class="name flex">
<span>def <span class="ident fname">idxmax</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return index of max by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def idxmax(self, **kwargs):
    &#34;&#34;&#34;Return index of max by column.&#34;&#34;&#34;
    kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;idxmax&#39;)), kwargs)
    return self.reduce(generic_nb.argmax_reduce_nb, to_array=False, to_idx=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.idxmin"><code class="name flex">
<span>def <span class="ident fname">idxmin</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return index of min by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def idxmin(self, **kwargs):
    &#34;&#34;&#34;Return index of min by column.&#34;&#34;&#34;
    kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;idxmin&#39;)), kwargs)
    return self.reduce(generic_nb.argmin_reduce_nb, to_array=False, to_idx=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.is_matrix_compatible"><code class="name flex">
<span>def <span class="ident fname">is_matrix_compatible</span></span>(<span>self, idx_arr=None, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.records.nb.mapped_matrix_compatible_nb" href="nb.html#vectorbt.records.nb.mapped_matrix_compatible_nb">mapped_matrix_compatible_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def is_matrix_compatible(self, idx_arr=None, group_by=None):
    &#34;&#34;&#34;See `vectorbt.records.nb.mapped_matrix_compatible_nb`.&#34;&#34;&#34;
    if idx_arr is None:
        if self.idx_arr is None:
            raise ValueError(&#34;Must pass idx_arr&#34;)
        idx_arr = self.idx_arr
    col_arr = self.col_mapper.get_col_arr(group_by=group_by)
    target_shape = self.wrapper.get_shape_2d(group_by=group_by)
    return nb.mapped_matrix_compatible_nb(col_arr, idx_arr, target_shape)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.is_sorted"><code class="name flex">
<span>def <span class="ident fname">is_sorted</span></span>(<span>self, incl_id=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether mapped array is sorted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def is_sorted(self, incl_id=False):
    &#34;&#34;&#34;Check whether mapped array is sorted.&#34;&#34;&#34;
    if incl_id:
        return nb.is_col_idx_sorted_nb(self.col_arr, self.id_arr)
    return nb.is_col_sorted_nb(self.col_arr)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.map_to_mask"><code class="name flex">
<span>def <span class="ident fname">map_to_mask</span></span>(<span>self, inout_map_func_nb, *args, group_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Map mapped array to a mask.</p>
<p>See <code><a title="vectorbt.records.nb.mapped_to_mask_nb" href="nb.html#vectorbt.records.nb.mapped_to_mask_nb">mapped_to_mask_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_to_mask(self, inout_map_func_nb, *args, group_by=None):
    &#34;&#34;&#34;Map mapped array to a mask.

    See `vectorbt.records.nb.mapped_to_mask_nb`.&#34;&#34;&#34;
    col_map = self.col_mapper.get_col_map(group_by=group_by)
    return nb.mapped_to_mask_nb(self.values, col_map, inout_map_func_nb, *args)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.max"><code class="name flex">
<span>def <span class="ident fname">max</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return max by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def max(self, **kwargs):
    &#34;&#34;&#34;Return max by column.&#34;&#34;&#34;
    kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;max&#39;)), kwargs)
    return self.reduce(generic_nb.max_reduce_nb, to_array=False, to_idx=False, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.mean"><code class="name flex">
<span>def <span class="ident fname">mean</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return mean by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def mean(self, **kwargs):
    &#34;&#34;&#34;Return mean by column.&#34;&#34;&#34;
    kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;mean&#39;)), kwargs)
    return self.reduce(generic_nb.mean_reduce_nb, to_array=False, to_idx=False, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.median"><code class="name flex">
<span>def <span class="ident fname">median</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return median by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def median(self, **kwargs):
    &#34;&#34;&#34;Return median by column.&#34;&#34;&#34;
    kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;median&#39;)), kwargs)
    return self.reduce(generic_nb.median_reduce_nb, to_array=False, to_idx=False, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.min"><code class="name flex">
<span>def <span class="ident fname">min</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return min by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def min(self, **kwargs):
    &#34;&#34;&#34;Return min by column.&#34;&#34;&#34;
    kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;min&#39;)), kwargs)
    return self.reduce(generic_nb.min_reduce_nb, to_array=False, to_idx=False, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.nst"><code class="name flex">
<span>def <span class="ident fname">nst</span></span>(<span>self, n, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return nst element of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def nst(self, n, **kwargs):
    &#34;&#34;&#34;Return nst element of each column.&#34;&#34;&#34;
    kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;nst&#39;)), kwargs)
    return self.reduce(generic_nb.nst_reduce_nb, n, to_array=False, to_idx=False, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.reduce"><code class="name flex">
<span>def <span class="ident fname">reduce</span></span>(<span>self, reduce_func_nb, *args, idx_arr=None, to_array=False, to_idx=False, idx_labeled=True, default_val=nan, group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduce mapped array by column.</p>
<p>If <code>to_array</code> is False and <code>to_idx</code> is False, see <code><a title="vectorbt.records.nb.reduce_mapped_nb" href="nb.html#vectorbt.records.nb.reduce_mapped_nb">reduce_mapped_nb()</a></code>.
If <code>to_array</code> is False and <code>to_idx</code> is True, see <code><a title="vectorbt.records.nb.reduce_mapped_to_idx_nb" href="nb.html#vectorbt.records.nb.reduce_mapped_to_idx_nb">reduce_mapped_to_idx_nb()</a></code>.
If <code>to_array</code> is True and <code>to_idx</code> is False, see <code><a title="vectorbt.records.nb.reduce_mapped_to_array_nb" href="nb.html#vectorbt.records.nb.reduce_mapped_to_array_nb">reduce_mapped_to_array_nb()</a></code>.
If <code>to_array</code> is True and <code>to_idx</code> is True, see <code><a title="vectorbt.records.nb.reduce_mapped_to_idx_array_nb" href="nb.html#vectorbt.records.nb.reduce_mapped_to_idx_array_nb">reduce_mapped_to_idx_array_nb()</a></code>.</p>
<p>If <code>to_idx</code> is True, must pass <code>idx_arr</code>. Set <code>idx_labeled</code> to False to return raw positions instead
of labels. Use <code>default_val</code> to set the default value. Set <code>group_by</code> to False to disable grouping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce(self, reduce_func_nb, *args, idx_arr=None, to_array=False, to_idx=False,
           idx_labeled=True, default_val=np.nan, group_by=None, wrap_kwargs=None):
    &#34;&#34;&#34;Reduce mapped array by column.

    If `to_array` is False and `to_idx` is False, see `vectorbt.records.nb.reduce_mapped_nb`.
    If `to_array` is False and `to_idx` is True, see `vectorbt.records.nb.reduce_mapped_to_idx_nb`.
    If `to_array` is True and `to_idx` is False, see `vectorbt.records.nb.reduce_mapped_to_array_nb`.
    If `to_array` is True and `to_idx` is True, see `vectorbt.records.nb.reduce_mapped_to_idx_array_nb`.

    If `to_idx` is True, must pass `idx_arr`. Set `idx_labeled` to False to return raw positions instead
    of labels. Use `default_val` to set the default value. Set `group_by` to False to disable grouping.
    &#34;&#34;&#34;
    # Perform checks
    checks.assert_numba_func(reduce_func_nb)
    if idx_arr is None:
        if self.idx_arr is None:
            if to_idx:
                raise ValueError(&#34;Must pass idx_arr&#34;)
        idx_arr = self.idx_arr

    # Perform main computation
    col_map = self.col_mapper.get_col_map(group_by=group_by)
    if not to_array:
        if not to_idx:
            out = nb.reduce_mapped_nb(
                self.values,
                col_map,
                default_val,
                reduce_func_nb,
                *args
            )
        else:
            out = nb.reduce_mapped_to_idx_nb(
                self.values,
                col_map,
                idx_arr,
                default_val,
                reduce_func_nb,
                *args
            )
    else:
        if not to_idx:
            out = nb.reduce_mapped_to_array_nb(
                self.values,
                col_map,
                default_val,
                reduce_func_nb,
                *args
            )
        else:
            out = nb.reduce_mapped_to_idx_array_nb(
                self.values,
                col_map,
                idx_arr,
                default_val,
                reduce_func_nb,
                *args
            )

    # Perform post-processing
    if to_idx:
        nan_mask = np.isnan(out)
        if idx_labeled:
            out = out.astype(np.object)
            out[~nan_mask] = self.wrapper.index[out[~nan_mask].astype(np.int_)]
        else:
            out[nan_mask] = -1
            out = out.astype(np.int_)
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;reduce&#39; if not to_array else None), wrap_kwargs)
    return self.wrapper.wrap_reduced(out, group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.sort"><code class="name flex">
<span>def <span class="ident fname">sort</span></span>(<span>self, incl_id=False, idx_arr=None, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Sort mapped array by column array (primary) and id array (secondary, optional).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, incl_id=False, idx_arr=None, group_by=None, **kwargs):
    &#34;&#34;&#34;Sort mapped array by column array (primary) and id array (secondary, optional).&#34;&#34;&#34;
    if idx_arr is None:
        idx_arr = self.idx_arr
    if self.is_sorted(incl_id=incl_id):
        return self.copy(idx_arr=idx_arr, **kwargs).regroup(group_by)
    if incl_id:
        ind = np.lexsort((self.id_arr, self.col_arr))  # expensive!
    else:
        ind = np.argsort(self.col_arr)
    return self.copy(
        mapped_arr=self.values[ind],
        col_arr=self.col_arr[ind],
        id_arr=self.id_arr[ind],
        idx_arr=idx_arr[ind] if idx_arr is not None else None,
        **kwargs
    ).regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.stack"><code class="name flex">
<span>def <span class="ident fname">stack</span></span>(<span>self, group_by=None, default_val=nan, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stack into a matrix.</p>
<p>Will lose index information and fill missing values with <code>default_val</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stack(self, group_by=None, default_val=np.nan, wrap_kwargs=None):
    &#34;&#34;&#34;Stack into a matrix.

    Will lose index information and fill missing values with `default_val`.&#34;&#34;&#34;
    if self.wrapper.ndim == 1:
        return self.wrapper.wrap(
            self.values,
            index=np.arange(len(self.values)),
            group_by=group_by,
            **merge_dicts({}, wrap_kwargs)
        )
    col_map = self.col_mapper.get_col_map(group_by=group_by)
    out = nb.stack_mapped_nb(self.values, col_map, default_val)
    return self.wrapper.wrap(
        out, index=np.arange(out.shape[0]),
        group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.std"><code class="name flex">
<span>def <span class="ident fname">std</span></span>(<span>self, ddof=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return std by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def std(self, ddof=1, **kwargs):
    &#34;&#34;&#34;Return std by column.&#34;&#34;&#34;
    kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;std&#39;)), kwargs)
    return self.reduce(generic_nb.std_reduce_nb, ddof, to_array=False, to_idx=False, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.sum"><code class="name flex">
<span>def <span class="ident fname">sum</span></span>(<span>self, default_val=0.0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return sum by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def sum(self, default_val=0., **kwargs):
    &#34;&#34;&#34;Return sum by column.&#34;&#34;&#34;
    kwargs = merge_dicts(dict(wrap_kwargs=dict(name_or_index=&#39;sum&#39;)), kwargs)
    return self.reduce(
        generic_nb.sum_reduce_nb,
        to_array=False,
        to_idx=False,
        default_val=default_val,
        **kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.to_matrix"><code class="name flex">
<span>def <span class="ident fname">to_matrix</span></span>(<span>self, idx_arr=None, default_val=nan, group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert mapped array to the matrix form.</p>
<p>See <code><a title="vectorbt.records.nb.mapped_to_matrix_nb" href="nb.html#vectorbt.records.nb.mapped_to_matrix_nb">mapped_to_matrix_nb()</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Will raise an error if there are multiple values pointing to the same matrix element.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Mapped arrays represent information in the most memory-friendly format.
Mapping back to the matrix form may occupy lots of memory if records are sparse.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_matrix(self, idx_arr=None, default_val=np.nan, group_by=None, wrap_kwargs=None):
    &#34;&#34;&#34;Convert mapped array to the matrix form.

    See `vectorbt.records.nb.mapped_to_matrix_nb`.

    !!! note
        Will raise an error if there are multiple values pointing to the same matrix element.

    !!! warning
        Mapped arrays represent information in the most memory-friendly format.
        Mapping back to the matrix form may occupy lots of memory if records are sparse.&#34;&#34;&#34;
    if idx_arr is None:
        if self.idx_arr is None:
            raise ValueError(&#34;Must pass idx_arr&#34;)
        idx_arr = self.idx_arr
    if not self.is_matrix_compatible(idx_arr=idx_arr, group_by=group_by):
        raise ValueError(&#34;Multiple values are pointing to the same matrix element&#34;)
    col_arr = self.col_mapper.get_col_arr(group_by=group_by)
    target_shape = self.wrapper.get_shape_2d(group_by=group_by)
    out = nb.mapped_to_matrix_nb(self.values, col_arr, idx_arr, target_shape, default_val)
    return self.wrapper.wrap(out, group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.top_n"><code class="name flex">
<span>def <span class="ident fname">top_n</span></span>(<span>self, n, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter top N elements from each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def top_n(self, n, **kwargs):
    &#34;&#34;&#34;Filter top N elements from each column.&#34;&#34;&#34;
    return self.filter_by_mask(self.top_n_mask(n), **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.top_n_mask"><code class="name flex">
<span>def <span class="ident fname">top_n_mask</span></span>(<span>self, n, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return mask of top N elements in each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def top_n_mask(self, n, **kwargs):
    &#34;&#34;&#34;Return mask of top N elements in each column.&#34;&#34;&#34;
    return self.map_to_mask(nb.top_n_inout_map_nb, n, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.mapped_array.MappedArray.value_counts"><code class="name flex">
<span>def <span class="ident fname">value_counts</span></span>(<span>self, group_by=None, value_map=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a pandas object containing counts of unique values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def value_counts(self, group_by=None, value_map=None, wrap_kwargs=None):
    &#34;&#34;&#34;Return a pandas object containing counts of unique values.&#34;&#34;&#34;
    mapped_codes, mapped_uniques = pd.factorize(self.values)
    col_map = self.col_mapper.get_col_map(group_by=group_by)
    value_counts = nb.mapped_value_counts_nb(mapped_codes, col_map)
    value_counts_df = self.wrapper.wrap(
        value_counts,
        index=mapped_uniques,
        group_by=group_by,
        **merge_dicts({}, wrap_kwargs)
    )
    if value_map is None:
        value_map = self.value_map
    if value_map is not None:
        if checks.is_namedtuple(value_map):
            value_map = to_value_map(value_map)
        value_counts_df.index = value_counts_df.index.map(value_map)
    return value_counts_df</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABmtJREFUeNrsnD1vFEkQhtve+fIuax9gDDIHQubDSMiQOEByjERGxg+4iL9DRI6A4IhAAkLIIeV0BwEICQJbwpbshRXegDbmkAW2p96erp7qpiqxg9mveWuq3nqme8aWrlw3Gu3FuJ4CFUAF0FABVAANFUAF0FABVAANFUAF0FABVAANFUAF0FABko/M7WULqysLq8v046uryLsfM2aKeuyHlerhs2PQl79x8e33/yaMOQm80H6Q/Tj68Z2s6GQ5iwCXl99fe/eK+j2Om/5Z5N2XjJmmHvvi5R/3n/ShL//X2Zff/ztvzDz1VeuD7ObtI8YM6B/U7RdcJWhufY1+8NiE1Ov/BJb+WHEf79Smfwo9YP0TdhEvHv0/dWzx6QIvvPPoT+iDiomelCY8fgh8wTRw7H9vDwRI/6fPp6Hqb9M/LypGAaAODAvAGfMHN7b+TGEyo+mfl1S1fjsbOlmMvjUx4CU2922rB3re2FhedgUJgDXhKezNnyOnxsbsgaHJMfd56+9TWPWvulYDRgEgC7RtQ5GrlzcbZntDcxpp8oPMNgBstiqQbuHwG3qjzXhLUN+WINB9Wg2A/Ckq24FjRhHgFYC6oPlLGxLcZyMBjn4eYJfkGcYeAKUnt/vM8hJKf0cBZoYDE2csnltjdZ+2/cJDUtSeEkpPtL6h7pOC3jw14U2gCWMWyMZh5BwtYwLMn9rgc5/04SuoDRVF4iZ7Iyb3SWcPSZUglMTNHhnS2y/U3lHzE04AGAQhLgj1oHQBoPqzxR6c0t9RAF4SxzkJ92klyPZeqL07mJ9EShAaxCYMuU8IvbUgANaEwR+Ckjii+4Tarx2+6OjNgwC8JK7LmAqLF9a8p3+T9usoQNQkjuI+oXu/KHoT3wM4SRylAcDus2p6zcICoCQOK0GcJI4yhUHus5MV450stAAoiZMzCdcOAaj7LJtV/+htKEriagWA2q/NfQf05qMJIyQOnsI4Sdz+UxjqPptX/xA2VNaClH2bMGR+nNFbUiUIJXEe609eeetsvALAHZiNxNWmP91QfUNv7Qkwt77K5UENI4nbvwFA6Q8t+9FJuN4CWfcJXUxN0JvsHsBJ4o7P7CnAA5A9eEx/WADeBSmcJK7fHe3lPiH/U/gYvtwFmBl+itQy7dWEA6M32SWIeU2cB/dZ+ucqmAC9zS/Q8XJI3K43AyD36bbsx7MAcxvY3Ri5u8Nc3CfLj4l1EoZI3K4NwFYwehGzpT/Ly8gEkEPidp3CsPT3bX4cBVj4uMIoQMApDLr16BG9pVOCIBL36xR29zFkfirGOsH31nJI3K9T2IOn1PRvuOzHtwuKk8T91IShRz74RW+N54Ak1qRA8CcrKtYvI6YHcJK4nVOYrV30bRcc7MFdgHhJnED36SJApCRuZwOA3OfWsh/m9JdUgthI3M4pDHKfJX/6YwJESuJ2TmF098mE3hoJECmJ+zGFQZt+WYev6CdhCET/mMLo7ZeVPQQSgJXEOSxIgTb9FkGqPyxApCRuO+jLnpvsuPtdShAUdgqDNv36WvTZsgCsJO7FP9jWMPqtR2701swFRUjithsAvf023HHHPAdESOLsFAa5z5DtV1IPAC/6f9+Qx+DuiJ7+AdCbuwCiSBz9dpi9AgD3Gbb9YgJESuIw9NbJ5ArAG2AHRjcnUaIMXv0xAUSROPhBWbVnwdOOO0YBElsTJ6H6xzoJw49JrD0FAdFbIAHkkDhSA6ravFqpAkRN4mrYQxGDAKkG97KfdgSAOzDSAlESV1N/ym67GUB2QawkrqWT4H3HHecckOJzmoqWhi9hPQAcgOgkbv9weNB2awLIely6p0dEtDh8wQLEuzt1zy4VatlPgjbUC4krKimohCQAL4mbBgVoTOL4dtxxCZAYiZNgfmItQc1JXLvoLYQAMAiaBI5tTuKCLfr0KQAviQtoRsIv+0nQBTVjDxOtswd2ASSTuLwSZw9oLigJEtfKsh9Pc0ASJE6U+xTTA0KRuDA77lgESIPElSLTnyRAAiRODnqL3oa6kThpwxcmAErisEGMn8RJYw+wACiJk7YmpZBa/eMrQQ4kzs69cshzCAHgMZiZxLW+7KfeNNYesVz17p2+QK8/xWvk84fAJGwbAOompaG3XVJ26cp1o6E9QAXQUAFUAA0VQAXQUAFUAA0VQAXQUAFUAA0VQAXQUAFUAA2++CrAAE3lth2zPPJAAAAAAElFTkSuQmCC"/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul>
<li><a href="#reducing">Reducing</a></li>
<li><a href="#conversion">Conversion</a></li>
<li><a href="#filtering">Filtering</a></li>
<li><a href="#plotting">Plotting</a></li>
<li><a href="#grouping">Grouping</a></li>
<li><a href="#operators">Operators</a></li>
<li><a href="#indexing">Indexing</a></li>
<li><a href="#caching">Caching</a></li>
<li><a href="#saving-and-loading">Saving and loading</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.records" href="index.html">vectorbt.records</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.records.mapped_array.combine_mapped_with_other" href="#vectorbt.records.mapped_array.combine_mapped_with_other">combine_mapped_with_other</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.records.mapped_array.MappedArray" href="#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.records.mapped_array.MappedArray.bottom_n" href="#vectorbt.records.mapped_array.MappedArray.bottom_n">bottom_n</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.bottom_n_mask" href="#vectorbt.records.mapped_array.MappedArray.bottom_n_mask">bottom_n_mask</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.boxplot" href="#vectorbt.records.mapped_array.MappedArray.boxplot">boxplot</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.col_arr" href="#vectorbt.records.mapped_array.MappedArray.col_arr">col_arr</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.col_mapper" href="#vectorbt.records.mapped_array.MappedArray.col_mapper">col_mapper</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.count" href="#vectorbt.records.mapped_array.MappedArray.count">count</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.describe" href="#vectorbt.records.mapped_array.MappedArray.describe">describe</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.filter_by_mask" href="#vectorbt.records.mapped_array.MappedArray.filter_by_mask">filter_by_mask</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.histplot" href="#vectorbt.records.mapped_array.MappedArray.histplot">histplot</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.id_arr" href="#vectorbt.records.mapped_array.MappedArray.id_arr">id_arr</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.idx_arr" href="#vectorbt.records.mapped_array.MappedArray.idx_arr">idx_arr</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.idxmax" href="#vectorbt.records.mapped_array.MappedArray.idxmax">idxmax</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.idxmin" href="#vectorbt.records.mapped_array.MappedArray.idxmin">idxmin</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.is_matrix_compatible" href="#vectorbt.records.mapped_array.MappedArray.is_matrix_compatible">is_matrix_compatible</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.is_sorted" href="#vectorbt.records.mapped_array.MappedArray.is_sorted">is_sorted</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.map_to_mask" href="#vectorbt.records.mapped_array.MappedArray.map_to_mask">map_to_mask</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.mapped_arr" href="#vectorbt.records.mapped_array.MappedArray.mapped_arr">mapped_arr</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.max" href="#vectorbt.records.mapped_array.MappedArray.max">max</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.mean" href="#vectorbt.records.mapped_array.MappedArray.mean">mean</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.median" href="#vectorbt.records.mapped_array.MappedArray.median">median</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.min" href="#vectorbt.records.mapped_array.MappedArray.min">min</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.nst" href="#vectorbt.records.mapped_array.MappedArray.nst">nst</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.reduce" href="#vectorbt.records.mapped_array.MappedArray.reduce">reduce</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.sort" href="#vectorbt.records.mapped_array.MappedArray.sort">sort</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.stack" href="#vectorbt.records.mapped_array.MappedArray.stack">stack</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.std" href="#vectorbt.records.mapped_array.MappedArray.std">std</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.sum" href="#vectorbt.records.mapped_array.MappedArray.sum">sum</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.to_matrix" href="#vectorbt.records.mapped_array.MappedArray.to_matrix">to_matrix</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.top_n" href="#vectorbt.records.mapped_array.MappedArray.top_n">top_n</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.top_n_mask" href="#vectorbt.records.mapped_array.MappedArray.top_n_mask">top_n_mask</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.value_counts" href="#vectorbt.records.mapped_array.MappedArray.value_counts">value_counts</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.value_map" href="#vectorbt.records.mapped_array.MappedArray.value_map">value_map</a></code></li>
<li><code><a title="vectorbt.records.mapped_array.MappedArray.values" href="#vectorbt.records.mapped_array.MappedArray.values">values</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>