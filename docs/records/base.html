<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.records.base API documentation</title>
<meta name="description" content="Base class for working with records â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#31353f}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #31353f}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #31353f;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#31353f}#sidebar{background:#3B4556}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#31353f}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#31353f">
<meta name="theme-color" content="#31353f">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.records.base</code></h1>
</header>
<section id="section-intro">
<p>Base class for working with records.</p>
<p>vectorbt works with two different representations of data: matrices and records.</p>
<p>A matrix, in this context, is just an array of one-dimensional arrays, each corresponding
to a separate feature. The matrix itself holds only one kind of information (one attribute).
For example, one can create a matrix for entry signals, with columns being different strategy
configurations. But what if the matrix is huge and sparse? What if there is more
information we would like to represent by each element? Creating multiple matrices would be
a waste of memory.</p>
<p>Records make possible representing complex, sparse information in a dense format. They are just
an array of one-dimensional arrays of fixed schema. You can imagine records being a DataFrame,
where each row represents a record and each column represents a specific attribute.</p>
<pre><code class="language-plaintext">               a     b
         0   1.0   5.0
attr1 =  1   2.0   NaN
         2   NaN   7.0
         3   4.0   8.0
               a     b
         0   9.0  13.0
attr2 =  1  10.0   NaN
         2   NaN  15.0
         3  12.0  16.0
            |
            v
      id  idx  col  attr1  attr2
0      0    0    0      1      9
1      1    1    0      2     10
2      2    3    0      4     12
3      3    0    1      5     13
4      4    1    1      7     15
5      5    3    1      8     16
</code></pre>
<p>Another advantage of records is that they are not constrained by size. Multiple records can map
to a single element in a matrix. For example, one can define multiple orders at the same time step,
which is impossible to represent in a matrix form without using complex data types.</p>
<h2 id="mapping">Mapping</h2>
<p><code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> are just <a href="https://numpy.org/doc/stable/user/basics.rec.html">structured arrays</a> with a bunch
of methods and properties for processing them. Their main feature is to map the records array and
to reduce it by column (similar to the MapReduce paradigm). The main advantage is that it all happens
without conversion to the matrix form and wasting memory resources.</p>
<p>Consider the following example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; example_dt = np.dtype([
...     ('id', np.int64),
...     ('idx', np.int64),
...     ('col', np.int64),
...     ('some_field', np.float64)
... ])
&gt;&gt;&gt; records_arr = np.array([
...     (0, 0, 0, 10.),
...     (1, 1, 0, 11.),
...     (2, 2, 0, 12.),
...     (3, 0, 1, 13.),
...     (4, 1, 1, 14.),
...     (5, 2, 1, 15.),
...     (6, 0, 2, 16.),
...     (7, 1, 2, 17.),
...     (8, 2, 2, 18.)
... ], dtype=example_dt)
&gt;&gt;&gt; wrapper = vbt.ArrayWrapper(index=['x', 'y', 'z'],
...     columns=['a', 'b', 'c'], ndim=2, freq='1 day')
&gt;&gt;&gt; records = vbt.Records(wrapper, records_arr)

&gt;&gt;&gt; records.records
   id  idx  col  some_field
0   0    0    0        10.0
1   1    1    0        11.0
2   2    2    0        12.0
3   3    0    1        13.0
4   4    1    1        14.0
5   5    2    1        15.0
6   6    0    2        16.0
7   7    1    2        17.0
8   8    2    2        18.0
</code></pre>
<p><code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> can be mapped to <code><a title="vectorbt.records.mapped_array.MappedArray" href="mapped_array.html#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code> in several ways:</p>
<ul>
<li>Use <code><a title="vectorbt.records.base.Records.map_field" href="#vectorbt.records.base.Records.map_field">Records.map_field()</a></code> to map a record field:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; records.map_field('some_field')
&lt;vectorbt.records.mapped_array.MappedArray at 0x7ff49bd31a58&gt;

&gt;&gt;&gt; records.map_field('some_field').values
array([10., 11., 12., 13., 14., 15., 16., 17., 18.])
</code></pre>
<ul>
<li>Use <code><a title="vectorbt.records.base.Records.map" href="#vectorbt.records.base.Records.map">Records.map()</a></code> to map records using a custom function.</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; @njit
... def power_map_nb(record, pow):
...     return record.some_field ** pow

&gt;&gt;&gt; records.map(power_map_nb, 2)
&lt;vectorbt.records.mapped_array.MappedArray at 0x7ff49c990cf8&gt;

&gt;&gt;&gt; records.map(power_map_nb, 2).values
array([100., 121., 144., 169., 196., 225., 256., 289., 324.])
</code></pre>
<ul>
<li>Use <code><a title="vectorbt.records.base.Records.map_array" href="#vectorbt.records.base.Records.map_array">Records.map_array()</a></code> to convert an array to <code><a title="vectorbt.records.mapped_array.MappedArray" href="mapped_array.html#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code>.</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; records.map_array(records_arr['some_field'] ** 2)
&lt;vectorbt.records.mapped_array.MappedArray object at 0x7fe9bccf2978&gt;

&gt;&gt;&gt; records.map_array(records_arr['some_field'] ** 2).values
array([100., 121., 144., 169., 196., 225., 256., 289., 324.])
</code></pre>
<h2 id="filtering">Filtering</h2>
<p>Use <code><a title="vectorbt.records.base.Records.filter_by_mask" href="#vectorbt.records.base.Records.filter_by_mask">Records.filter_by_mask()</a></code> to filter elements per column/group:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask = [True, False, True, False, True, False, True, False, True]
&gt;&gt;&gt; filtered_records = records.filter_by_mask(mask)
&gt;&gt;&gt; filtered_records.count()
a    2
b    1
c    2
dtype: int64

&gt;&gt;&gt; filtered_records.values['id']
array([0, 2, 4, 6, 8])
</code></pre>
<h2 id="grouping">Grouping</h2>
<p>One of the key features of <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> is that you can perform reducing operations on a group
of columns as if they were a single column. Groups can be specified by <code>group_by</code>, which
can be anything from positions or names of column levels, to a NumPy array with actual groups.</p>
<p>There are multiple ways of define grouping:</p>
<ul>
<li>When creating <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code>, pass <code>group_by</code> to <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; group_by = np.array(['first', 'first', 'second'])
&gt;&gt;&gt; grouped_wrapper = wrapper.copy(group_by=group_by)
&gt;&gt;&gt; grouped_records = vbt.Records(grouped_wrapper, records_arr)

&gt;&gt;&gt; grouped_records.map_field('some_field').mean()
first     12.5
second    17.0
dtype: float64
</code></pre>
<ul>
<li>Regroup an existing <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code>:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; records.regroup(group_by).map_field('some_field').mean()
first     12.5
second    17.0
dtype: float64
</code></pre>
<ul>
<li>Pass <code>group_by</code> directly to the mapping method:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; records.map_field('some_field', group_by=group_by).mean()
first     12.5
second    17.0
dtype: float64
</code></pre>
<ul>
<li>Pass <code>group_by</code> directly to the reducing method:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; records.map_field('some_field').mean(group_by=group_by)
a    11.0
b    14.0
c    17.0
dtype: float64
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Grouping applies only to reducing operations, there is no change to the arrays.</p>
</div>
<h2 id="indexing">Indexing</h2>
<p>Like any other class subclassing <code><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></code>, we can do pandas indexing
on a <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> instance, which forwards indexing operation to each object with columns:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; records['a'].records
   id  idx  col  some_field
0   0    0    0        10.0
1   1    1    0        11.0
2   2    2    0        12.0

&gt;&gt;&gt; grouped_records['first'].records
   id  idx  col  some_field
0   0    0    0        10.0
1   1    1    0        11.0
2   2    2    0        12.0
3   3    0    1        13.0
4   4    1    1        14.0
5   5    2    1        15.0
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Changing index (time axis) is not supported. The object should be treated as a Series
rather than a DataFrame; for example, use <code>some_field.iloc[0]</code> instead of <code>some_field.iloc[:, 0]</code>.</p>
<p>Indexing behavior depends solely upon <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.
For example, if <code>group_select</code> is enabled indexing will be performed on groups,
otherwise on single columns.</p>
</div>
<h2 id="caching">Caching</h2>
<p><code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> supports caching. If a method or a property requires heavy computation, it's wrapped
with <code><a title="vectorbt.utils.decorators.cached_method" href="../utils/decorators.html#vectorbt.utils.decorators.cached_method">cached_method()</a></code> and <code><a title="vectorbt.utils.decorators.cached_property" href="../utils/decorators.html#vectorbt.utils.decorators.cached_property">cached_property</a></code>
respectively. Caching can be disabled globally via <code><a title="vectorbt.settings" href="../settings.html">vectorbt.settings</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because of caching, class is meant to be immutable and all properties are read-only.
To change any attribute, use the <code>copy</code> method and pass the attribute as keyword argument.</p>
</div>
<h2 id="saving-and-loading">Saving and loading</h2>
<p>Like any other class subclassing <code><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></code>, we can save a <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code>
instance to the disk with <code><a title="vectorbt.records.base.Records.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">Pickleable.save()</a></code> and load it with <code><a title="vectorbt.records.base.Records.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">Pickleable.load()</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Base class for working with records.

vectorbt works with two different representations of data: matrices and records.

A matrix, in this context, is just an array of one-dimensional arrays, each corresponding
to a separate feature. The matrix itself holds only one kind of information (one attribute).
For example, one can create a matrix for entry signals, with columns being different strategy
configurations. But what if the matrix is huge and sparse? What if there is more
information we would like to represent by each element? Creating multiple matrices would be
a waste of memory.

Records make possible representing complex, sparse information in a dense format. They are just
an array of one-dimensional arrays of fixed schema. You can imagine records being a DataFrame,
where each row represents a record and each column represents a specific attribute.

```plaintext
               a     b
         0   1.0   5.0
attr1 =  1   2.0   NaN
         2   NaN   7.0
         3   4.0   8.0
               a     b
         0   9.0  13.0
attr2 =  1  10.0   NaN
         2   NaN  15.0
         3  12.0  16.0
            |
            v
      id  idx  col  attr1  attr2
0      0    0    0      1      9
1      1    1    0      2     10
2      2    3    0      4     12
3      3    0    1      5     13
4      4    1    1      7     15
5      5    3    1      8     16
```

Another advantage of records is that they are not constrained by size. Multiple records can map
to a single element in a matrix. For example, one can define multiple orders at the same time step,
which is impossible to represent in a matrix form without using complex data types.

## Mapping

`Records` are just [structured arrays](https://numpy.org/doc/stable/user/basics.rec.html) with a bunch
of methods and properties for processing them. Their main feature is to map the records array and
to reduce it by column (similar to the MapReduce paradigm). The main advantage is that it all happens
without conversion to the matrix form and wasting memory resources.

Consider the following example:

```python-repl
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; example_dt = np.dtype([
...     (&#39;id&#39;, np.int64),
...     (&#39;idx&#39;, np.int64),
...     (&#39;col&#39;, np.int64),
...     (&#39;some_field&#39;, np.float64)
... ])
&gt;&gt;&gt; records_arr = np.array([
...     (0, 0, 0, 10.),
...     (1, 1, 0, 11.),
...     (2, 2, 0, 12.),
...     (3, 0, 1, 13.),
...     (4, 1, 1, 14.),
...     (5, 2, 1, 15.),
...     (6, 0, 2, 16.),
...     (7, 1, 2, 17.),
...     (8, 2, 2, 18.)
... ], dtype=example_dt)
&gt;&gt;&gt; wrapper = vbt.ArrayWrapper(index=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;],
...     columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], ndim=2, freq=&#39;1 day&#39;)
&gt;&gt;&gt; records = vbt.Records(wrapper, records_arr)

&gt;&gt;&gt; records.records
   id  idx  col  some_field
0   0    0    0        10.0
1   1    1    0        11.0
2   2    2    0        12.0
3   3    0    1        13.0
4   4    1    1        14.0
5   5    2    1        15.0
6   6    0    2        16.0
7   7    1    2        17.0
8   8    2    2        18.0
```

`Records` can be mapped to `vectorbt.records.mapped_array.MappedArray` in several ways:

* Use `Records.map_field` to map a record field:

```python-repl
&gt;&gt;&gt; records.map_field(&#39;some_field&#39;)
&lt;vectorbt.records.mapped_array.MappedArray at 0x7ff49bd31a58&gt;

&gt;&gt;&gt; records.map_field(&#39;some_field&#39;).values
array([10., 11., 12., 13., 14., 15., 16., 17., 18.])
```

* Use `Records.map` to map records using a custom function.

```python-repl
&gt;&gt;&gt; @njit
... def power_map_nb(record, pow):
...     return record.some_field ** pow

&gt;&gt;&gt; records.map(power_map_nb, 2)
&lt;vectorbt.records.mapped_array.MappedArray at 0x7ff49c990cf8&gt;

&gt;&gt;&gt; records.map(power_map_nb, 2).values
array([100., 121., 144., 169., 196., 225., 256., 289., 324.])
```

* Use `Records.map_array` to convert an array to `vectorbt.records.mapped_array.MappedArray`.

```python-repl
&gt;&gt;&gt; records.map_array(records_arr[&#39;some_field&#39;] ** 2)
&lt;vectorbt.records.mapped_array.MappedArray object at 0x7fe9bccf2978&gt;

&gt;&gt;&gt; records.map_array(records_arr[&#39;some_field&#39;] ** 2).values
array([100., 121., 144., 169., 196., 225., 256., 289., 324.])
```

## Filtering

Use `Records.filter_by_mask` to filter elements per column/group:

```python-repl
&gt;&gt;&gt; mask = [True, False, True, False, True, False, True, False, True]
&gt;&gt;&gt; filtered_records = records.filter_by_mask(mask)
&gt;&gt;&gt; filtered_records.count()
a    2
b    1
c    2
dtype: int64

&gt;&gt;&gt; filtered_records.values[&#39;id&#39;]
array([0, 2, 4, 6, 8])
```

## Grouping

One of the key features of `Records` is that you can perform reducing operations on a group
of columns as if they were a single column. Groups can be specified by `group_by`, which
can be anything from positions or names of column levels, to a NumPy array with actual groups.

There are multiple ways of define grouping:

* When creating `Records`, pass `group_by` to `vectorbt.base.array_wrapper.ArrayWrapper`:

```python-repl
&gt;&gt;&gt; group_by = np.array([&#39;first&#39;, &#39;first&#39;, &#39;second&#39;])
&gt;&gt;&gt; grouped_wrapper = wrapper.copy(group_by=group_by)
&gt;&gt;&gt; grouped_records = vbt.Records(grouped_wrapper, records_arr)

&gt;&gt;&gt; grouped_records.map_field(&#39;some_field&#39;).mean()
first     12.5
second    17.0
dtype: float64
```

* Regroup an existing `Records`:

```python-repl
&gt;&gt;&gt; records.regroup(group_by).map_field(&#39;some_field&#39;).mean()
first     12.5
second    17.0
dtype: float64
```

* Pass `group_by` directly to the mapping method:

```python-repl
&gt;&gt;&gt; records.map_field(&#39;some_field&#39;, group_by=group_by).mean()
first     12.5
second    17.0
dtype: float64
```

* Pass `group_by` directly to the reducing method:

```python-repl
&gt;&gt;&gt; records.map_field(&#39;some_field&#39;).mean(group_by=group_by)
a    11.0
b    14.0
c    17.0
dtype: float64
```

!!! note
    Grouping applies only to reducing operations, there is no change to the arrays.

## Indexing

Like any other class subclassing `vectorbt.base.array_wrapper.Wrapping`, we can do pandas indexing
on a `Records` instance, which forwards indexing operation to each object with columns:

```python-repl
&gt;&gt;&gt; records[&#39;a&#39;].records
   id  idx  col  some_field
0   0    0    0        10.0
1   1    1    0        11.0
2   2    2    0        12.0

&gt;&gt;&gt; grouped_records[&#39;first&#39;].records
   id  idx  col  some_field
0   0    0    0        10.0
1   1    1    0        11.0
2   2    2    0        12.0
3   3    0    1        13.0
4   4    1    1        14.0
5   5    2    1        15.0
```

!!! note
    Changing index (time axis) is not supported. The object should be treated as a Series
    rather than a DataFrame; for example, use `some_field.iloc[0]` instead of `some_field.iloc[:, 0]`.

    Indexing behavior depends solely upon `vectorbt.base.array_wrapper.ArrayWrapper`.
    For example, if `group_select` is enabled indexing will be performed on groups,
    otherwise on single columns.

## Caching

`Records` supports caching. If a method or a property requires heavy computation, it&#39;s wrapped
with `vectorbt.utils.decorators.cached_method` and `vectorbt.utils.decorators.cached_property`
respectively. Caching can be disabled globally via `vectorbt.settings`.

!!! note
    Because of caching, class is meant to be immutable and all properties are read-only.
    To change any attribute, use the `copy` method and pass the attribute as keyword argument.

## Saving and loading

Like any other class subclassing `vectorbt.utils.config.Pickleable`, we can save a `Records`
instance to the disk with `Records.save` and load it with `Records.load`.
&#34;&#34;&#34;

import numpy as np
import pandas as pd

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_method
from vectorbt.utils.config import merge_dicts
from vectorbt.base.reshape_fns import to_1d
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.records import nb
from vectorbt.records.mapped_array import MappedArray
from vectorbt.records.col_mapper import ColumnMapper


class Records(Wrapping):
    &#34;&#34;&#34;Wraps the actual records array (such as trades) and exposes methods for mapping
    it to some array of values (such as P&amp;L of each trade).

    Args:
        wrapper (ArrayWrapper): Array wrapper.

            See `vectorbt.base.array_wrapper.ArrayWrapper`.
        records_arr (array_like): A structured NumPy array of records.

            Must have the fields `id` (record index) and `col` (column index).
        idx_field (str): The name of the field corresponding to the index. Optional.

            Searches for a field with name &#39;idx&#39; if `idx_field` is &#39;auto&#39;.
            Throws an error if the name was provided explicitly and the field cannot be found.
        **kwargs: Custom keyword arguments passed to the config.

            Useful if any subclass wants to extend the config.
    &#34;&#34;&#34;

    def __init__(self, wrapper, records_arr, idx_field=&#39;auto&#39;, **kwargs):
        Wrapping.__init__(
            self,
            wrapper,
            records_arr=records_arr,
            idx_field=idx_field,
            **kwargs
        )
        records_arr = np.asarray(records_arr)
        checks.assert_not_none(records_arr.dtype.fields)
        checks.assert_in(&#39;id&#39;, records_arr.dtype.names)
        checks.assert_in(&#39;col&#39;, records_arr.dtype.names)
        if idx_field == &#39;auto&#39;:
            if &#39;idx&#39; in records_arr.dtype.names:
                idx_field = &#39;idx&#39;
        elif idx_field is not None:
            checks.assert_in(idx_field, records_arr.dtype.names)

        self._records_arr = records_arr
        self._idx_field = idx_field
        self._col_mapper = ColumnMapper(wrapper, records_arr[&#39;col&#39;])

    def _col_idxs_records(self, col_idxs):
        &#34;&#34;&#34;Get records corresponding to column indices.

        Returns new records array.&#34;&#34;&#34;
        if self.col_mapper.is_sorted():
            new_records_arr = nb.record_col_range_select_nb(
                self.values, self.col_mapper.col_range, to_1d(col_idxs))  # faster
        else:
            new_records_arr = nb.record_col_map_select_nb(
                self.values, self.col_mapper.col_map, to_1d(col_idxs))
        return new_records_arr

    def _indexing_func_meta(self, pd_indexing_func, **kwargs):
        &#34;&#34;&#34;Perform indexing on `Records` and return metadata.&#34;&#34;&#34;
        new_wrapper, _, group_idxs, col_idxs = \
            self.wrapper._indexing_func_meta(pd_indexing_func, column_only_select=True, **kwargs)
        new_records_arr = self._col_idxs_records(col_idxs)
        return new_wrapper, new_records_arr, group_idxs, col_idxs

    def _indexing_func(self, pd_indexing_func, **kwargs):
        &#34;&#34;&#34;Perform indexing on `Records`.&#34;&#34;&#34;
        new_wrapper, new_records_arr, _, _ = self._indexing_func_meta(pd_indexing_func, **kwargs)
        return self.copy(
            wrapper=new_wrapper,
            records_arr=new_records_arr
        )

    @property
    def records_arr(self):
        &#34;&#34;&#34;Records array.&#34;&#34;&#34;
        return self._records_arr

    values = records_arr

    def __len__(self):
        return len(self.values)

    @property
    def idx_field(self):
        &#34;&#34;&#34;Index field.&#34;&#34;&#34;
        return self._idx_field

    @property
    def records(self):
        &#34;&#34;&#34;Records.&#34;&#34;&#34;
        return pd.DataFrame.from_records(self.values)

    @property
    def recarray(self):
        return self.values.view(np.recarray)

    @property
    def col_mapper(self):
        &#34;&#34;&#34;Column mapper.

        See `vectorbt.records.col_mapper.ColumnMapper`.&#34;&#34;&#34;
        return self._col_mapper

    @cached_method
    def is_sorted(self, incl_id=False):
        &#34;&#34;&#34;Check whether records are sorted.&#34;&#34;&#34;
        if incl_id:
            return nb.is_col_idx_sorted_nb(self.values[&#39;col&#39;], self.values[&#39;id&#39;])
        return nb.is_col_sorted_nb(self.values[&#39;col&#39;])

    def sort(self, incl_id=False, group_by=None, **kwargs):
        &#34;&#34;&#34;Sort records by columns (primary) and ids (secondary, optional).

        !!! note
            Sorting is expensive. A better approach is to append records already in the correct order.&#34;&#34;&#34;
        if self.is_sorted(incl_id=incl_id):
            return self.copy(**kwargs).regroup(group_by)
        if incl_id:
            ind = np.lexsort((self.values[&#39;id&#39;], self.values[&#39;col&#39;]))  # expensive!
        else:
            ind = np.argsort(self.values[&#39;col&#39;])
        return self.copy(records_arr=self.values[ind], **kwargs).regroup(group_by)

    def filter_by_mask(self, mask, group_by=None, **kwargs):
        &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
        return self.copy(records_arr=self.values[mask], **kwargs).regroup(group_by)

    def map(self, map_func_nb, *args, idx_field=None, value_map=None, group_by=None, **kwargs):
        &#34;&#34;&#34;Map each record to a scalar value. Returns mapped array.

        See `vectorbt.records.nb.map_records_nb`.&#34;&#34;&#34;
        checks.assert_numba_func(map_func_nb)
        mapped_arr = nb.map_records_nb(self.values, map_func_nb, *args)
        if idx_field is None:
            idx_field = self.idx_field
        if idx_field is not None:
            idx_arr = self.values[idx_field]
        else:
            idx_arr = None
        return MappedArray(
            self.wrapper,
            mapped_arr,
            self.values[&#39;col&#39;],
            id_arr=self.values[&#39;id&#39;],
            idx_arr=idx_arr,
            value_map=value_map,
            **kwargs
        ).regroup(group_by)

    def map_field(self, field, idx_field=None, value_map=None, group_by=None, **kwargs):
        &#34;&#34;&#34;Convert field to mapped array.&#34;&#34;&#34;
        if idx_field is None:
            idx_field = self.idx_field
        if idx_field is not None:
            idx_arr = self.values[idx_field]
        else:
            idx_arr = None
        return MappedArray(
            self.wrapper,
            self.values[field],
            self.values[&#39;col&#39;],
            id_arr=self.values[&#39;id&#39;],
            idx_arr=idx_arr,
            value_map=value_map,
            **kwargs
        ).regroup(group_by)

    def map_array(self, a, idx_field=None, value_map=None, group_by=None, **kwargs):
        &#34;&#34;&#34;Convert array to mapped array.

         The length of the array should match that of the records.&#34;&#34;&#34;
        if not isinstance(a, np.ndarray):
            a = np.asarray(a)
        checks.assert_shape_equal(a, self.values)
        if idx_field is None:
            idx_field = self.idx_field
        if idx_field is not None:
            idx_arr = self.values[idx_field]
        else:
            idx_arr = None
        return MappedArray(
            self.wrapper,
            a,
            self.values[&#39;col&#39;],
            id_arr=self.values[&#39;id&#39;],
            idx_arr=idx_arr,
            value_map=value_map,
            **kwargs
        ).regroup(group_by)

    @cached_method
    def count(self, group_by=None, wrap_kwargs=None):
        &#34;&#34;&#34;Return count by column.&#34;&#34;&#34;
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;count&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(
            self.col_mapper.get_col_map(group_by=group_by)[1],
            group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.records.base.Records"><code class="flex name class">
<span>class <span class="ident parent-fname">Records</span></span>
<span>(</span><span>wrapper, records_arr, idx_field='auto', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps the actual records array (such as trades) and exposes methods for mapping
it to some array of values (such as P&amp;L of each trade).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrapper</code></strong> :&ensp;<code>ArrayWrapper</code></dt>
<dd>
<p>Array wrapper.</p>
<p>See <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</p>
</dd>
<dt><strong><code>records_arr</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>A structured NumPy array of records.</p>
<p>Must have the fields <code>id</code> (record index) and <code>col</code> (column index).</p>
</dd>
<dt><strong><code>idx_field</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>The name of the field corresponding to the index. Optional.</p>
<p>Searches for a field with name 'idx' if <code>idx_field</code> is 'auto'.
Throws an error if the name was provided explicitly and the field cannot be found.</p>
</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>
<p>Custom keyword arguments passed to the config.</p>
<p>Useful if any subclass wants to extend the config.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Records(Wrapping):
    &#34;&#34;&#34;Wraps the actual records array (such as trades) and exposes methods for mapping
    it to some array of values (such as P&amp;L of each trade).

    Args:
        wrapper (ArrayWrapper): Array wrapper.

            See `vectorbt.base.array_wrapper.ArrayWrapper`.
        records_arr (array_like): A structured NumPy array of records.

            Must have the fields `id` (record index) and `col` (column index).
        idx_field (str): The name of the field corresponding to the index. Optional.

            Searches for a field with name &#39;idx&#39; if `idx_field` is &#39;auto&#39;.
            Throws an error if the name was provided explicitly and the field cannot be found.
        **kwargs: Custom keyword arguments passed to the config.

            Useful if any subclass wants to extend the config.
    &#34;&#34;&#34;

    def __init__(self, wrapper, records_arr, idx_field=&#39;auto&#39;, **kwargs):
        Wrapping.__init__(
            self,
            wrapper,
            records_arr=records_arr,
            idx_field=idx_field,
            **kwargs
        )
        records_arr = np.asarray(records_arr)
        checks.assert_not_none(records_arr.dtype.fields)
        checks.assert_in(&#39;id&#39;, records_arr.dtype.names)
        checks.assert_in(&#39;col&#39;, records_arr.dtype.names)
        if idx_field == &#39;auto&#39;:
            if &#39;idx&#39; in records_arr.dtype.names:
                idx_field = &#39;idx&#39;
        elif idx_field is not None:
            checks.assert_in(idx_field, records_arr.dtype.names)

        self._records_arr = records_arr
        self._idx_field = idx_field
        self._col_mapper = ColumnMapper(wrapper, records_arr[&#39;col&#39;])

    def _col_idxs_records(self, col_idxs):
        &#34;&#34;&#34;Get records corresponding to column indices.

        Returns new records array.&#34;&#34;&#34;
        if self.col_mapper.is_sorted():
            new_records_arr = nb.record_col_range_select_nb(
                self.values, self.col_mapper.col_range, to_1d(col_idxs))  # faster
        else:
            new_records_arr = nb.record_col_map_select_nb(
                self.values, self.col_mapper.col_map, to_1d(col_idxs))
        return new_records_arr

    def _indexing_func_meta(self, pd_indexing_func, **kwargs):
        &#34;&#34;&#34;Perform indexing on `Records` and return metadata.&#34;&#34;&#34;
        new_wrapper, _, group_idxs, col_idxs = \
            self.wrapper._indexing_func_meta(pd_indexing_func, column_only_select=True, **kwargs)
        new_records_arr = self._col_idxs_records(col_idxs)
        return new_wrapper, new_records_arr, group_idxs, col_idxs

    def _indexing_func(self, pd_indexing_func, **kwargs):
        &#34;&#34;&#34;Perform indexing on `Records`.&#34;&#34;&#34;
        new_wrapper, new_records_arr, _, _ = self._indexing_func_meta(pd_indexing_func, **kwargs)
        return self.copy(
            wrapper=new_wrapper,
            records_arr=new_records_arr
        )

    @property
    def records_arr(self):
        &#34;&#34;&#34;Records array.&#34;&#34;&#34;
        return self._records_arr

    values = records_arr

    def __len__(self):
        return len(self.values)

    @property
    def idx_field(self):
        &#34;&#34;&#34;Index field.&#34;&#34;&#34;
        return self._idx_field

    @property
    def records(self):
        &#34;&#34;&#34;Records.&#34;&#34;&#34;
        return pd.DataFrame.from_records(self.values)

    @property
    def recarray(self):
        return self.values.view(np.recarray)

    @property
    def col_mapper(self):
        &#34;&#34;&#34;Column mapper.

        See `vectorbt.records.col_mapper.ColumnMapper`.&#34;&#34;&#34;
        return self._col_mapper

    @cached_method
    def is_sorted(self, incl_id=False):
        &#34;&#34;&#34;Check whether records are sorted.&#34;&#34;&#34;
        if incl_id:
            return nb.is_col_idx_sorted_nb(self.values[&#39;col&#39;], self.values[&#39;id&#39;])
        return nb.is_col_sorted_nb(self.values[&#39;col&#39;])

    def sort(self, incl_id=False, group_by=None, **kwargs):
        &#34;&#34;&#34;Sort records by columns (primary) and ids (secondary, optional).

        !!! note
            Sorting is expensive. A better approach is to append records already in the correct order.&#34;&#34;&#34;
        if self.is_sorted(incl_id=incl_id):
            return self.copy(**kwargs).regroup(group_by)
        if incl_id:
            ind = np.lexsort((self.values[&#39;id&#39;], self.values[&#39;col&#39;]))  # expensive!
        else:
            ind = np.argsort(self.values[&#39;col&#39;])
        return self.copy(records_arr=self.values[ind], **kwargs).regroup(group_by)

    def filter_by_mask(self, mask, group_by=None, **kwargs):
        &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
        return self.copy(records_arr=self.values[mask], **kwargs).regroup(group_by)

    def map(self, map_func_nb, *args, idx_field=None, value_map=None, group_by=None, **kwargs):
        &#34;&#34;&#34;Map each record to a scalar value. Returns mapped array.

        See `vectorbt.records.nb.map_records_nb`.&#34;&#34;&#34;
        checks.assert_numba_func(map_func_nb)
        mapped_arr = nb.map_records_nb(self.values, map_func_nb, *args)
        if idx_field is None:
            idx_field = self.idx_field
        if idx_field is not None:
            idx_arr = self.values[idx_field]
        else:
            idx_arr = None
        return MappedArray(
            self.wrapper,
            mapped_arr,
            self.values[&#39;col&#39;],
            id_arr=self.values[&#39;id&#39;],
            idx_arr=idx_arr,
            value_map=value_map,
            **kwargs
        ).regroup(group_by)

    def map_field(self, field, idx_field=None, value_map=None, group_by=None, **kwargs):
        &#34;&#34;&#34;Convert field to mapped array.&#34;&#34;&#34;
        if idx_field is None:
            idx_field = self.idx_field
        if idx_field is not None:
            idx_arr = self.values[idx_field]
        else:
            idx_arr = None
        return MappedArray(
            self.wrapper,
            self.values[field],
            self.values[&#39;col&#39;],
            id_arr=self.values[&#39;id&#39;],
            idx_arr=idx_arr,
            value_map=value_map,
            **kwargs
        ).regroup(group_by)

    def map_array(self, a, idx_field=None, value_map=None, group_by=None, **kwargs):
        &#34;&#34;&#34;Convert array to mapped array.

         The length of the array should match that of the records.&#34;&#34;&#34;
        if not isinstance(a, np.ndarray):
            a = np.asarray(a)
        checks.assert_shape_equal(a, self.values)
        if idx_field is None:
            idx_field = self.idx_field
        if idx_field is not None:
            idx_arr = self.values[idx_field]
        else:
            idx_arr = None
        return MappedArray(
            self.wrapper,
            a,
            self.values[&#39;col&#39;],
            id_arr=self.values[&#39;id&#39;],
            idx_arr=idx_arr,
            value_map=value_map,
            **kwargs
        ).regroup(group_by)

    @cached_method
    def count(self, group_by=None, wrap_kwargs=None):
        &#34;&#34;&#34;Return count by column.&#34;&#34;&#34;
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;count&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(
            self.col_mapper.get_col_map(group_by=group_by)[1],
            group_by=group_by, **wrap_kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.generic.drawdowns.Drawdowns" href="../generic/drawdowns.html#vectorbt.generic.drawdowns.Drawdowns">Drawdowns</a></li>
<li><a title="vectorbt.portfolio.logs.Logs" href="../portfolio/logs.html#vectorbt.portfolio.logs.Logs">Logs</a></li>
<li><a title="vectorbt.portfolio.orders.Orders" href="../portfolio/orders.html#vectorbt.portfolio.orders.Orders">Orders</a></li>
<li><a title="vectorbt.portfolio.trades.Trades" href="../portfolio/trades.html#vectorbt.portfolio.trades.Trades">Trades</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.records.base.Records.col_mapper"><code class="name">var <span class="ident fname">col_mapper</span></code></dt>
<dd>
<div class="desc"><p>Column mapper.</p>
<p>See <code><a title="vectorbt.records.col_mapper.ColumnMapper" href="col_mapper.html#vectorbt.records.col_mapper.ColumnMapper">ColumnMapper</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def col_mapper(self):
    &#34;&#34;&#34;Column mapper.

    See `vectorbt.records.col_mapper.ColumnMapper`.&#34;&#34;&#34;
    return self._col_mapper</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.idx_field"><code class="name">var <span class="ident fname">idx_field</span></code></dt>
<dd>
<div class="desc"><p>Index field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def idx_field(self):
    &#34;&#34;&#34;Index field.&#34;&#34;&#34;
    return self._idx_field</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.recarray"><code class="name">var <span class="ident fname">recarray</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def recarray(self):
    return self.values.view(np.recarray)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.records"><code class="name">var <span class="ident fname">records</span></code></dt>
<dd>
<div class="desc"><p>Records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def records(self):
    &#34;&#34;&#34;Records.&#34;&#34;&#34;
    return pd.DataFrame.from_records(self.values)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.records_arr"><code class="name">var <span class="ident fname">records_arr</span></code></dt>
<dd>
<div class="desc"><p>Records array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def records_arr(self):
    &#34;&#34;&#34;Records array.&#34;&#34;&#34;
    return self._records_arr</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.values"><code class="name">var <span class="ident fname">values</span></code></dt>
<dd>
<div class="desc"><p>Records array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def records_arr(self):
    &#34;&#34;&#34;Records array.&#34;&#34;&#34;
    return self._records_arr</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.records.base.Records.count"><code class="name flex">
<span>def <span class="ident fname">count</span></span>(<span>self, group_by=None, wrap_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return count by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def count(self, group_by=None, wrap_kwargs=None):
    &#34;&#34;&#34;Return count by column.&#34;&#34;&#34;
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;count&#39;), wrap_kwargs)
    return self.wrapper.wrap_reduced(
        self.col_mapper.get_col_map(group_by=group_by)[1],
        group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.filter_by_mask"><code class="name flex">
<span>def <span class="ident fname">filter_by_mask</span></span>(<span>self, mask, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new class instance, filtered by mask.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_mask(self, mask, group_by=None, **kwargs):
    &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
    return self.copy(records_arr=self.values[mask], **kwargs).regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.is_sorted"><code class="name flex">
<span>def <span class="ident fname">is_sorted</span></span>(<span>self, incl_id=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether records are sorted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def is_sorted(self, incl_id=False):
    &#34;&#34;&#34;Check whether records are sorted.&#34;&#34;&#34;
    if incl_id:
        return nb.is_col_idx_sorted_nb(self.values[&#39;col&#39;], self.values[&#39;id&#39;])
    return nb.is_col_sorted_nb(self.values[&#39;col&#39;])</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.map"><code class="name flex">
<span>def <span class="ident fname">map</span></span>(<span>self, map_func_nb, *args, idx_field=None, value_map=None, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Map each record to a scalar value. Returns mapped array.</p>
<p>See <code><a title="vectorbt.records.nb.map_records_nb" href="nb.html#vectorbt.records.nb.map_records_nb">map_records_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, map_func_nb, *args, idx_field=None, value_map=None, group_by=None, **kwargs):
    &#34;&#34;&#34;Map each record to a scalar value. Returns mapped array.

    See `vectorbt.records.nb.map_records_nb`.&#34;&#34;&#34;
    checks.assert_numba_func(map_func_nb)
    mapped_arr = nb.map_records_nb(self.values, map_func_nb, *args)
    if idx_field is None:
        idx_field = self.idx_field
    if idx_field is not None:
        idx_arr = self.values[idx_field]
    else:
        idx_arr = None
    return MappedArray(
        self.wrapper,
        mapped_arr,
        self.values[&#39;col&#39;],
        id_arr=self.values[&#39;id&#39;],
        idx_arr=idx_arr,
        value_map=value_map,
        **kwargs
    ).regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.map_array"><code class="name flex">
<span>def <span class="ident fname">map_array</span></span>(<span>self, a, idx_field=None, value_map=None, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert array to mapped array.</p>
<p>The length of the array should match that of the records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_array(self, a, idx_field=None, value_map=None, group_by=None, **kwargs):
    &#34;&#34;&#34;Convert array to mapped array.

     The length of the array should match that of the records.&#34;&#34;&#34;
    if not isinstance(a, np.ndarray):
        a = np.asarray(a)
    checks.assert_shape_equal(a, self.values)
    if idx_field is None:
        idx_field = self.idx_field
    if idx_field is not None:
        idx_arr = self.values[idx_field]
    else:
        idx_arr = None
    return MappedArray(
        self.wrapper,
        a,
        self.values[&#39;col&#39;],
        id_arr=self.values[&#39;id&#39;],
        idx_arr=idx_arr,
        value_map=value_map,
        **kwargs
    ).regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.map_field"><code class="name flex">
<span>def <span class="ident fname">map_field</span></span>(<span>self, field, idx_field=None, value_map=None, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert field to mapped array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_field(self, field, idx_field=None, value_map=None, group_by=None, **kwargs):
    &#34;&#34;&#34;Convert field to mapped array.&#34;&#34;&#34;
    if idx_field is None:
        idx_field = self.idx_field
    if idx_field is not None:
        idx_arr = self.values[idx_field]
    else:
        idx_arr = None
    return MappedArray(
        self.wrapper,
        self.values[field],
        self.values[&#39;col&#39;],
        id_arr=self.values[&#39;id&#39;],
        idx_arr=idx_arr,
        value_map=value_map,
        **kwargs
    ).regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.sort"><code class="name flex">
<span>def <span class="ident fname">sort</span></span>(<span>self, incl_id=False, group_by=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Sort records by columns (primary) and ids (secondary, optional).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Sorting is expensive. A better approach is to append records already in the correct order.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, incl_id=False, group_by=None, **kwargs):
    &#34;&#34;&#34;Sort records by columns (primary) and ids (secondary, optional).

    !!! note
        Sorting is expensive. A better approach is to append records already in the correct order.&#34;&#34;&#34;
    if self.is_sorted(incl_id=incl_id):
        return self.copy(**kwargs).regroup(group_by)
    if incl_id:
        ind = np.lexsort((self.values[&#39;id&#39;], self.values[&#39;col&#39;]))  # expensive!
    else:
        ind = np.argsort(self.values[&#39;col&#39;])
    return self.copy(records_arr=self.values[ind], **kwargs).regroup(group_by)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.getattr" href="../utils/config.html#vectorbt.utils.config.Configured.getattr">getattr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_series" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_series">select_series</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,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"/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul>
<li><a href="#mapping">Mapping</a></li>
<li><a href="#filtering">Filtering</a></li>
<li><a href="#grouping">Grouping</a></li>
<li><a href="#indexing">Indexing</a></li>
<li><a href="#caching">Caching</a></li>
<li><a href="#saving-and-loading">Saving and loading</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.records" href="index.html">vectorbt.records</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.records.base.Records.col_mapper" href="#vectorbt.records.base.Records.col_mapper">col_mapper</a></code></li>
<li><code><a title="vectorbt.records.base.Records.count" href="#vectorbt.records.base.Records.count">count</a></code></li>
<li><code><a title="vectorbt.records.base.Records.filter_by_mask" href="#vectorbt.records.base.Records.filter_by_mask">filter_by_mask</a></code></li>
<li><code><a title="vectorbt.records.base.Records.idx_field" href="#vectorbt.records.base.Records.idx_field">idx_field</a></code></li>
<li><code><a title="vectorbt.records.base.Records.is_sorted" href="#vectorbt.records.base.Records.is_sorted">is_sorted</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map" href="#vectorbt.records.base.Records.map">map</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map_array" href="#vectorbt.records.base.Records.map_array">map_array</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map_field" href="#vectorbt.records.base.Records.map_field">map_field</a></code></li>
<li><code><a title="vectorbt.records.base.Records.recarray" href="#vectorbt.records.base.Records.recarray">recarray</a></code></li>
<li><code><a title="vectorbt.records.base.Records.records" href="#vectorbt.records.base.Records.records">records</a></code></li>
<li><code><a title="vectorbt.records.base.Records.records_arr" href="#vectorbt.records.base.Records.records_arr">records_arr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.sort" href="#vectorbt.records.base.Records.sort">sort</a></code></li>
<li><code><a title="vectorbt.records.base.Records.values" href="#vectorbt.records.base.Records.values">values</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>