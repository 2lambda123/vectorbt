<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.records.base API documentation</title>
<meta name="description" content="Main class for working with records â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:rgba(0,0,0,.2);border:none;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3A4D6B}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.records.base</code></h1>
</header>
<section id="section-intro">
<p>Main class for working with records.</p>
<p>vectorbt works with two different representations of data: matrices and records.</p>
<p>A matrix, in this context, is just an array of one-dimensional arrays, each corresponding
to a separate feature. The matrix itself holds only one kind of information (one attribute).
For example, one can create a matrix for entry signals, with columns being different strategy
configurations. But what if the matrix is huge and sparse? What if there is more
information we would like to represent by each element? Creating multiple matrices would be
a waste of memory.</p>
<p>Records make possible representing complex, sparse information in a dense format. They are just
an array of one-dimensional arrays of fixed schema. You can imagine records being a DataFrame,
where each row represents a record and each column represents a specific attribute.</p>
<pre><code class="plaintext">               a     b
         0   1.0   5.0
attr1 =  1   2.0   NaN
         2   NaN   7.0
         3   4.0   8.0
               a     b
         0   9.0  13.0
attr2 =  1  10.0   NaN
         2   NaN  15.0
         3  12.0  16.0
            |
            v
      col  idx  attr1  attr2
0       0    0      1      9
1       0    1      2     10
2       0    3      4     12
3       1    0      5     13
4       1    1      7     15
5       1    3      8     16
</code></pre>
<p>Another advantage of records is that they are not constrained by size. Multiple records can map
to a single element in a matrix. For example, one can define multiple orders at the same time step,
which is impossible to represent in a matrix form without using complex data types.</p>
<h2 id="records-class">Records class</h2>
<p><code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> are just <a href="https://numpy.org/doc/stable/user/basics.rec.html">structured arrays</a> with a bunch
of methods and properties for processing them. Its main feature is to map the records array and
to reduce it by column (similar to the MapReduce paradigm). The main advantage is that it all happens
without conversion to the matrix form and wasting memory resources.</p>
<h2 id="mappedarray-class">MappedArray class</h2>
<p>When mapping records using <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code>, for example, to compute P&amp;L of each trade record, the mapping
result is wrapped with <code><a title="vectorbt.records.base.MappedArray" href="#vectorbt.records.base.MappedArray">MappedArray</a></code> class. This class takes the mapped array and the corresponding column
and (optionally) index arrays, and offers features to directly process the mapped array without converting
it to the matrix form; for example, to compute various statistics by column, such as standard deviation.</p>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; from vectorbt.tseries.common import TSArrayWrapper
&gt;&gt;&gt; from vectorbt.records import Records

&gt;&gt;&gt; example_dt = np.dtype([
...     ('col', np.int64),
...     ('idx', np.int64),
...     ('some_field', np.float64)
... ])
&gt;&gt;&gt; records_arr = np.array([
...     (0, 0, 10.),
...     (0, 1, 11.),
...     (0, 2, 12.),
...     (1, 0, 13.),
...     (1, 1, 14.),
...     (1, 2, 15.)
... ], dtype=example_dt)
&gt;&gt;&gt; wrapper = TSArrayWrapper(index=['x', 'y', 'z'],
...     columns=['a', 'b'], ndim=2, freq='1 day')
&gt;&gt;&gt; records = Records(records_arr, wrapper)

&gt;&gt;&gt; print(records.records)
   col  idx  some_field
0    0    0        10.0
1    0    1        11.0
2    0    2        12.0
3    1    0        13.0
4    1    1        14.0
5    1    2        15.0
</code></pre>
<h3 id="mapping">Mapping</h3>
<p>There are several options for mapping:</p>
<ul>
<li>Use <code><a title="vectorbt.records.base.Records.map_field" href="#vectorbt.records.base.Records.map_field">Records.map_field()</a></code> to map a record field:</li>
</ul>
<pre><code class="python-repl">&gt;&gt;&gt; records.map_field('some_field')
&lt;vectorbt.records.base.MappedArray at 0x7ff49bd31a58&gt;

&gt;&gt;&gt; print(records.map_field('some_field').mapped_arr)
[10. 11. 12. 13. 14. 15.]
</code></pre>
<ul>
<li>Use <code><a title="vectorbt.records.base.Records.map" href="#vectorbt.records.base.Records.map">Records.map()</a></code> to map records using a custom function.</li>
</ul>
<pre><code class="python-repl">&gt;&gt;&gt; @njit
... def power_map_nb(record, pow):
...     return record.some_field ** pow

&gt;&gt;&gt; records.map(power_map_nb, 2)
&lt;vectorbt.records.base.MappedArray at 0x7ff49c990cf8&gt;

&gt;&gt;&gt; print(records.map(power_map_nb, 2).mapped_arr)
[100. 121. 144. 169. 196. 225.]
</code></pre>
<ul>
<li>Use <code><a title="vectorbt.records.base.Records.map_array" href="#vectorbt.records.base.Records.map_array">Records.map_array()</a></code> to convert an array to <code><a title="vectorbt.records.base.MappedArray" href="#vectorbt.records.base.MappedArray">MappedArray</a></code>.</li>
</ul>
<pre><code class="python-repl">&gt;&gt;&gt; records.map_array(records_arr['some_field'] ** 2)
&lt;vectorbt.records.base.MappedArray object at 0x7fe9bccf2978&gt;

&gt;&gt;&gt; print(records.map_array(records_arr['some_field'] ** 2).mapped_arr)
[100. 121. 144. 169. 196. 225.]
</code></pre>
<h3 id="reducing">Reducing</h3>
<p>Using <code><a title="vectorbt.records.base.MappedArray" href="#vectorbt.records.base.MappedArray">MappedArray</a></code>, you can then reduce by column as follows:</p>
<ul>
<li>Use already provided reducers such as <code><a title="vectorbt.records.base.MappedArray.mean" href="#vectorbt.records.base.MappedArray.mean">MappedArray.mean()</a></code>:</li>
</ul>
<pre><code class="python-repl">&gt;&gt;&gt; print(mapped.mean())
a    11.0
b    14.0
dtype: float64
</code></pre>
<ul>
<li>Use <code><a title="vectorbt.records.base.MappedArray.to_matrix" href="#vectorbt.records.base.MappedArray.to_matrix">MappedArray.to_matrix()</a></code> to map to a matrix and then reduce manually (expensive):</li>
</ul>
<pre><code class="python-repl">&gt;&gt;&gt; print(mapped.to_matrix().mean())
a    11.0
b    14.0
dtype: float64
</code></pre>
<ul>
<li>Use <code><a title="vectorbt.records.base.MappedArray.reduce" href="#vectorbt.records.base.MappedArray.reduce">MappedArray.reduce()</a></code> to reduce to a scalar using a custom function:</li>
</ul>
<pre><code class="python-repl">&gt;&gt;&gt; mapped = records.map_field('some_field')

&gt;&gt;&gt; @njit
... def pow_mean_reduce_nb(col, a, pow):
...     return np.mean(a ** pow)

&gt;&gt;&gt; print(mapped.reduce(pow_mean_reduce_nb, 2))
a    121.666667
b    196.666667
dtype: float64
</code></pre>
<ul>
<li>Use <code><a title="vectorbt.records.base.MappedArray.reduce_to_array" href="#vectorbt.records.base.MappedArray.reduce_to_array">MappedArray.reduce_to_array()</a></code> to reduce to an array:</li>
</ul>
<pre><code class="python-repl">&gt;&gt;&gt; @njit
... def min_max_reduce_nb(col, a):
...     return np.array([np.min(a), np.max(a)])

&gt;&gt;&gt; print(mapped.reduce_to_array(min_max_reduce_nb, index=['min', 'max']))
        a     b
min  10.0  13.0
max  12.0  15.0
</code></pre>
<h3 id="conversion">Conversion</h3>
<p>You can convert any <code><a title="vectorbt.records.base.MappedArray" href="#vectorbt.records.base.MappedArray">MappedArray</a></code> instance to the matrix form, given <code>idx_arr</code> was provided:</p>
<pre><code class="python-repl">&gt;&gt;&gt; mapped.to_matrix()
      a     b
x  10.0  13.0
y  11.0  14.0
z  12.0  15.0
</code></pre>
<p>Note, though, that it will raise an error if there are multiple records pointing to the same matrix element.</p>
<h3 id="plotting">Plotting</h3>
<p>You can build histograms and boxplots of <code><a title="vectorbt.records.base.MappedArray" href="#vectorbt.records.base.MappedArray">MappedArray</a></code> directly:</p>
<pre><code class="python-repl">&gt;&gt;&gt; mapped.box()
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/mapped_box.png"></p>
<p>To use scatterplots or any other plots that require index, convert to matrix first:</p>
<pre><code class="python-repl">&gt;&gt;&gt; mapped.to_matrix().vbt.scatter(trace_kwargs=dict(connectgaps=True))
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/mapped_scatter.png"></p>
<h2 id="indexing">Indexing</h2>
<p>You can use pandas indexing on both the <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> and <code><a title="vectorbt.records.base.MappedArray" href="#vectorbt.records.base.MappedArray">MappedArray</a></code> class, which will forward
the indexing operation to each <code>__init__</code> argument with index:</p>
<pre><code class="python-repl">&gt;&gt;&gt; print(records['a'].records)
   col  idx  some_field
0    0    0        10.0
1    0    1        11.0
2    0    2        12.0

&gt;&gt;&gt; print(mapped['a'].mapped_arr)
[10. 11. 12.]
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Changing index (time axis) is not supported.</p>
</div>
<h2 id="operators">Operators</h2>
<p>Additionally, <code><a title="vectorbt.records.base.MappedArray" href="#vectorbt.records.base.MappedArray">MappedArray</a></code> implements arithmetic, comparison and logical operators.
You can perform basic operations (such as addition) on mapped arrays as if they were NumPy arrays.</p>
<pre><code class="python-repl">&gt;&gt;&gt; mapped ** 2
&lt;vectorbt.records.base.MappedArray at 0x7f97bfc49358&gt;

&gt;&gt;&gt; mapped * np.array([1, 2, 3, 4, 5, 6])
&lt;vectorbt.records.base.MappedArray at 0x7f97bfc65e80&gt;

&gt;&gt;&gt; mapped + mapped
&lt;vectorbt.records.base.MappedArray at 0x7f97bfc492e8&gt;
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You should ensure that your <code>*.vbt</code> operand is on the left if the other operand is an array.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Main class for working with records.

vectorbt works with two different representations of data: matrices and records.

A matrix, in this context, is just an array of one-dimensional arrays, each corresponding
to a separate feature. The matrix itself holds only one kind of information (one attribute).
For example, one can create a matrix for entry signals, with columns being different strategy
configurations. But what if the matrix is huge and sparse? What if there is more
information we would like to represent by each element? Creating multiple matrices would be
a waste of memory.

Records make possible representing complex, sparse information in a dense format. They are just
an array of one-dimensional arrays of fixed schema. You can imagine records being a DataFrame,
where each row represents a record and each column represents a specific attribute.

```plaintext
               a     b
         0   1.0   5.0
attr1 =  1   2.0   NaN
         2   NaN   7.0
         3   4.0   8.0
               a     b
         0   9.0  13.0
attr2 =  1  10.0   NaN
         2   NaN  15.0
         3  12.0  16.0
            |
            v
      col  idx  attr1  attr2
0       0    0      1      9
1       0    1      2     10
2       0    3      4     12
3       1    0      5     13
4       1    1      7     15
5       1    3      8     16
```

Another advantage of records is that they are not constrained by size. Multiple records can map
to a single element in a matrix. For example, one can define multiple orders at the same time step,
which is impossible to represent in a matrix form without using complex data types.

## Records class

`Records` are just [structured arrays](https://numpy.org/doc/stable/user/basics.rec.html) with a bunch
of methods and properties for processing them. Its main feature is to map the records array and
to reduce it by column (similar to the MapReduce paradigm). The main advantage is that it all happens
without conversion to the matrix form and wasting memory resources.

## MappedArray class

When mapping records using `Records`, for example, to compute P&amp;L of each trade record, the mapping
result is wrapped with `MappedArray` class. This class takes the mapped array and the corresponding column
and (optionally) index arrays, and offers features to directly process the mapped array without converting
it to the matrix form; for example, to compute various statistics by column, such as standard deviation.

## Example

```python-repl
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; from vectorbt.tseries.common import TSArrayWrapper
&gt;&gt;&gt; from vectorbt.records import Records

&gt;&gt;&gt; example_dt = np.dtype([
...     (&#39;col&#39;, np.int64),
...     (&#39;idx&#39;, np.int64),
...     (&#39;some_field&#39;, np.float64)
... ])
&gt;&gt;&gt; records_arr = np.array([
...     (0, 0, 10.),
...     (0, 1, 11.),
...     (0, 2, 12.),
...     (1, 0, 13.),
...     (1, 1, 14.),
...     (1, 2, 15.)
... ], dtype=example_dt)
&gt;&gt;&gt; wrapper = TSArrayWrapper(index=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;],
...     columns=[&#39;a&#39;, &#39;b&#39;], ndim=2, freq=&#39;1 day&#39;)
&gt;&gt;&gt; records = Records(records_arr, wrapper)

&gt;&gt;&gt; print(records.records)
   col  idx  some_field
0    0    0        10.0
1    0    1        11.0
2    0    2        12.0
3    1    0        13.0
4    1    1        14.0
5    1    2        15.0
```

### Mapping

There are several options for mapping:

* Use `Records.map_field` to map a record field:

```python-repl
&gt;&gt;&gt; records.map_field(&#39;some_field&#39;)
&lt;vectorbt.records.base.MappedArray at 0x7ff49bd31a58&gt;

&gt;&gt;&gt; print(records.map_field(&#39;some_field&#39;).mapped_arr)
[10. 11. 12. 13. 14. 15.]
```

* Use `Records.map` to map records using a custom function.

```python-repl
&gt;&gt;&gt; @njit
... def power_map_nb(record, pow):
...     return record.some_field ** pow

&gt;&gt;&gt; records.map(power_map_nb, 2)
&lt;vectorbt.records.base.MappedArray at 0x7ff49c990cf8&gt;

&gt;&gt;&gt; print(records.map(power_map_nb, 2).mapped_arr)
[100. 121. 144. 169. 196. 225.]
```

* Use `Records.map_array` to convert an array to `MappedArray`.

```python-repl
&gt;&gt;&gt; records.map_array(records_arr[&#39;some_field&#39;] ** 2)
&lt;vectorbt.records.base.MappedArray object at 0x7fe9bccf2978&gt;

&gt;&gt;&gt; print(records.map_array(records_arr[&#39;some_field&#39;] ** 2).mapped_arr)
[100. 121. 144. 169. 196. 225.]
```

### Reducing

Using `MappedArray`, you can then reduce by column as follows:

* Use already provided reducers such as `MappedArray.mean`:

```python-repl
&gt;&gt;&gt; print(mapped.mean())
a    11.0
b    14.0
dtype: float64
```

* Use `MappedArray.to_matrix` to map to a matrix and then reduce manually (expensive):

```python-repl
&gt;&gt;&gt; print(mapped.to_matrix().mean())
a    11.0
b    14.0
dtype: float64
```

* Use `MappedArray.reduce` to reduce to a scalar using a custom function:

```python-repl
&gt;&gt;&gt; mapped = records.map_field(&#39;some_field&#39;)

&gt;&gt;&gt; @njit
... def pow_mean_reduce_nb(col, a, pow):
...     return np.mean(a ** pow)

&gt;&gt;&gt; print(mapped.reduce(pow_mean_reduce_nb, 2))
a    121.666667
b    196.666667
dtype: float64
```

* Use `MappedArray.reduce_to_array` to reduce to an array:

```python-repl
&gt;&gt;&gt; @njit
... def min_max_reduce_nb(col, a):
...     return np.array([np.min(a), np.max(a)])

&gt;&gt;&gt; print(mapped.reduce_to_array(min_max_reduce_nb, index=[&#39;min&#39;, &#39;max&#39;]))
        a     b
min  10.0  13.0
max  12.0  15.0
```

### Conversion

You can convert any `MappedArray` instance to the matrix form, given `idx_arr` was provided:

```python-repl
&gt;&gt;&gt; mapped.to_matrix()
      a     b
x  10.0  13.0
y  11.0  14.0
z  12.0  15.0
```

Note, though, that it will raise an error if there are multiple records pointing to the same matrix element.

### Plotting

You can build histograms and boxplots of `MappedArray` directly:

```python-repl
&gt;&gt;&gt; mapped.box()
```

![](/vectorbt/docs/img/mapped_box.png)

To use scatterplots or any other plots that require index, convert to matrix first:

```python-repl
&gt;&gt;&gt; mapped.to_matrix().vbt.scatter(trace_kwargs=dict(connectgaps=True))
```

![](/vectorbt/docs/img/mapped_scatter.png)

## Indexing

You can use pandas indexing on both the `Records` and `MappedArray` class, which will forward
the indexing operation to each `__init__` argument with index:

```python-repl
&gt;&gt;&gt; print(records[&#39;a&#39;].records)
   col  idx  some_field
0    0    0        10.0
1    0    1        11.0
2    0    2        12.0

&gt;&gt;&gt; print(mapped[&#39;a&#39;].mapped_arr)
[10. 11. 12.]
```

!!! note
    Changing index (time axis) is not supported.

## Operators

Additionally, `MappedArray` implements arithmetic, comparison and logical operators.
You can perform basic operations (such as addition) on mapped arrays as if they were NumPy arrays.

```python-repl
&gt;&gt;&gt; mapped ** 2
&lt;vectorbt.records.base.MappedArray at 0x7f97bfc49358&gt;

&gt;&gt;&gt; mapped * np.array([1, 2, 3, 4, 5, 6])
&lt;vectorbt.records.base.MappedArray at 0x7f97bfc65e80&gt;

&gt;&gt;&gt; mapped + mapped
&lt;vectorbt.records.base.MappedArray at 0x7f97bfc492e8&gt;
```

!!! note
    You should ensure that your `*.vbt` operand is on the left if the other operand is an array.
&#34;&#34;&#34;

import numpy as np
import pandas as pd

from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_property
from vectorbt.base.indexing import PandasIndexer
from vectorbt.base import reshape_fns
from vectorbt.base.common import (
    add_binary_magic_methods,
    add_unary_magic_methods,
    binary_magic_methods,
    unary_magic_methods
)
from vectorbt.tseries.common import TSArrayWrapper
from vectorbt.tseries import nb as tseries_nb
from vectorbt.records import nb


def _mapped_indexing_func(obj, pd_indexing_func):
    &#34;&#34;&#34;Perform indexing on `MappedArray`.&#34;&#34;&#34;
    if obj.wrapper.ndim == 1:
        raise TypeError(&#34;Indexing on Series is not supported&#34;)

    n_rows = len(obj.wrapper.index)
    n_cols = len(obj.wrapper.columns)
    col_mapper = obj.wrapper.wrap(np.broadcast_to(np.arange(n_cols), (n_rows, n_cols)))
    col_mapper = pd_indexing_func(col_mapper)
    if not pd.Index.equals(col_mapper.index, obj.wrapper.index):
        raise NotImplementedError(&#34;Changing index (time axis) is not supported&#34;)

    new_cols = reshape_fns.to_1d(col_mapper.values[0])  # array required
    new_indices, new_col_arr = nb.select_mapped_cols_nb(
        obj.col_arr,
        obj.col_index,
        new_cols
    )
    new_mapped_arr = obj.mapped_arr[new_indices]
    if obj.idx_arr is not None:
        new_idx_arr = obj.idx_arr[new_indices]
    else:
        new_idx_arr = None
    new_wrapper = TSArrayWrapper.from_obj(col_mapper, freq=obj.wrapper.freq)
    return obj.__class__(new_mapped_arr, new_col_arr, new_wrapper, idx_arr=new_idx_arr)


def _mapped_binary_translate_func(self, other, np_func):
    &#34;&#34;&#34;Perform operation between two instances of `MappedArray`.&#34;&#34;&#34;
    if isinstance(other, self.__class__):
        passed = True
        if not np.array_equal(self.col_arr, other.col_arr):
            passed = False
        if self.idx_arr is None or other.idx_arr is None:
            if self.idx_arr != other.idx_arr:
                passed = False
        else:
            if not np.array_equal(self.idx_arr, other.idx_arr):
                passed = False
        if self.wrapper != other.wrapper:
            passed = False
        if not passed:
            raise ValueError(&#34;Both MappedArray instances must have same metadata&#34;)
        other = other.mapped_arr
    return self.__class__(
        np_func(self.mapped_arr, other),
        self.col_arr,
        self.wrapper,
        idx_arr=self.idx_arr
    )


@add_binary_magic_methods(
    binary_magic_methods,
    _mapped_binary_translate_func
)
@add_unary_magic_methods(
    unary_magic_methods,
    lambda self, np_func: self.__class__(
        np_func(self.mapped_arr),
        self.col_arr,
        self.wrapper,
        idx_arr=self.idx_arr
    )
)
class MappedArray(PandasIndexer):
    &#34;&#34;&#34;Exposes methods and properties for working with records.

    Args:
        mapped_arr (array_like): A one-dimensional array of mapped record values.
        col_arr (array_like): A one-dimensional column array.

            Must be of the same size as `mapped_arr`.
        wrapper (TSArrayWrapper): Array wrapper of type `vectorbt.tseries.common.TSArrayWrapper`.
        idx_arr (array_like): A one-dimensional index array. Optional.

            Must be of the same size as `mapped_arr`.&#34;&#34;&#34;

    def __init__(self, mapped_arr, col_arr, wrapper, idx_arr=None):
        if not isinstance(mapped_arr, np.ndarray):
            mapped_arr = np.asarray(mapped_arr)
        if not isinstance(col_arr, np.ndarray):
            col_arr = np.asarray(col_arr)
        checks.assert_same_shape(mapped_arr, col_arr, axis=0)
        checks.assert_type(wrapper, TSArrayWrapper)
        if idx_arr is not None:
            if not isinstance(idx_arr, np.ndarray):
                idx_arr = np.asarray(idx_arr)
            checks.assert_same_shape(mapped_arr, idx_arr, axis=0)

        self.mapped_arr = mapped_arr
        self.col_arr = col_arr
        self.wrapper = wrapper
        self.idx_arr = idx_arr

        PandasIndexer.__init__(self, _mapped_indexing_func)

    @cached_property
    def col_index(self):
        &#34;&#34;&#34;Column index for `MappedArray.mapped_arr`.&#34;&#34;&#34;
        return nb.mapped_col_index_nb(self.mapped_arr, self.col_arr, len(self.wrapper.columns))

    def filter_by_mask(self, mask):
        &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
        if self.idx_arr is not None:
            idx_arr = self.idx_arr[mask]
        else:
            idx_arr = None
        return self.__class__(self.mapped_arr[mask], self.col_arr[mask], self.wrapper, idx_arr=idx_arr)

    def to_matrix(self, idx_arr=None, default_val=np.nan):
        &#34;&#34;&#34;Convert mapped array to the matrix form.

        See `vectorbt.records.nb.mapped_to_matrix_nb`.

        !!! warning
            Mapped arrays represent information in the most memory-friendly format.
            Mapping back to the matrix form may occupy lots of memory if records are sparse.

        !!! note
            Will raise an error if there are multiple values pointing at the same matrix element.&#34;&#34;&#34;
        if idx_arr is None:
            if self.idx_arr is None:
                raise ValueError(&#34;Must pass idx_arr&#34;)
            idx_arr = self.idx_arr
        # Check many-to-one relationship
        n_unique = np.unique(np.hstack((self.col_arr[:, None], idx_arr[:, None])), axis=0).shape[0]
        if n_unique &lt; self.col_arr.shape[0]:
            raise ValueError(&#34;Multiple values are pointing at the same matrix element&#34;)
        target_shape = (len(self.wrapper.index), len(self.wrapper.columns))
        result = nb.mapped_to_matrix_nb(self.mapped_arr, self.col_arr, idx_arr, target_shape, default_val)
        return self.wrapper.wrap(result)

    def reduce(self, reduce_func_nb, *args, default_val=np.nan, cast=None, **kwargs):
        &#34;&#34;&#34;Reduce mapped array by column to a scalar value.

        See `vectorbt.records.nb.reduce_mapped_nb`.

        `**kwargs` will be passed to `vectorbt.tseries.common.TSArrayWrapper.wrap_reduced`.&#34;&#34;&#34;
        checks.assert_numba_func(reduce_func_nb)

        result = nb.reduce_mapped_nb(
            self.mapped_arr,
            self.col_arr,
            len(self.wrapper.columns),
            default_val,
            reduce_func_nb,
            *args
        )
        if cast is not None:
            result = result.astype(cast)
        return self.wrapper.wrap_reduced(result, **kwargs)

    def reduce_to_array(self, reduce_func_nb, *args, default_val=np.nan, cast=None, **kwargs):
        &#34;&#34;&#34;Reduce mapped array by column to an array.

        See `vectorbt.records.nb.reduce_mapped_to_array_nb`.

        `**kwargs` will be passed to `vectorbt.tseries.common.TSArrayWrapper.wrap_reduced`.&#34;&#34;&#34;
        checks.assert_numba_func(reduce_func_nb)

        result = nb.reduce_mapped_to_array_nb(
            self.mapped_arr,
            self.col_arr,
            len(self.wrapper.columns),
            default_val,
            reduce_func_nb,
            *args
        )
        if cast is not None:
            result = result.astype(cast)
        return self.wrapper.wrap_reduced(result, **kwargs)

    def nst(self, n, **kwargs):
        &#34;&#34;&#34;Return nst element of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.nst_reduce_nb, n, **kwargs)

    def min(self, **kwargs):
        &#34;&#34;&#34;Return min of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.min_reduce_nb, **kwargs)

    def max(self, **kwargs):
        &#34;&#34;&#34;Return max of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.max_reduce_nb, **kwargs)

    def mean(self, **kwargs):
        &#34;&#34;&#34;Return mean of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.mean_reduce_nb, **kwargs)

    def median(self, **kwargs):
        &#34;&#34;&#34;Return median of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.median_reduce_nb, **kwargs)

    def std(self, ddof=1, **kwargs):
        &#34;&#34;&#34;Return std of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.std_reduce_nb, ddof, **kwargs)

    def sum(self, default_val=0., **kwargs):
        &#34;&#34;&#34;Return sum of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.sum_reduce_nb, default_val=default_val, **kwargs)

    def count(self, default_val=0., cast=np.int64, **kwargs):
        &#34;&#34;&#34;Return count of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.count_reduce_nb, default_val=default_val, cast=cast, **kwargs)

    def describe(self, percentiles=None, ddof=1, **kwargs):
        &#34;&#34;&#34;Return stats of each column.&#34;&#34;&#34;
        if percentiles is not None:
            percentiles = reshape_fns.to_1d(percentiles, raw=True)
        else:
            percentiles = np.array([0.25, 0.5, 0.75])
        percentiles = percentiles.tolist()
        if 0.5 not in percentiles:
            percentiles.append(0.5)
        percentiles = np.unique(percentiles)
        perc_formatted = pd.io.formats.format.format_percentiles(percentiles)
        index = pd.Index([&#39;count&#39;, &#39;mean&#39;, &#39;std&#39;, &#39;min&#39;, *perc_formatted, &#39;max&#39;])
        result = self.reduce_to_array(tseries_nb.describe_reduce_nb, percentiles, ddof, index=index, **kwargs)
        if isinstance(result, pd.DataFrame):
            result.loc[&#39;count&#39;].fillna(0., inplace=True)
        else:
            if np.isnan(result.loc[&#39;count&#39;]):
                result.loc[&#39;count&#39;] = 0.
        return result

    def idxmin(self, idx_arr=None, **kwargs):
        &#34;&#34;&#34;Return index of min of each column.&#34;&#34;&#34;
        if idx_arr is None:
            if self.idx_arr is None:
                raise ValueError(&#34;Must pass idx_arr&#34;)
            idx_arr = self.idx_arr
        result = reshape_fns.to_1d(self.reduce(tseries_nb.argmin_reduce_nb), raw=True)
        mask = np.isnan(result)
        if mask.any():
            # Contains NaNs
            result[mask] = 0
            result = result.astype(int)
            result = self.wrapper.index[idx_arr[result]].to_numpy()
            result = result.astype(np.object)
            result[mask] = np.nan
        else:
            result = self.wrapper.index[idx_arr[result.astype(int)]].to_numpy()
        return self.wrapper.wrap_reduced(result, **kwargs)

    def idxmax(self, idx_arr=None, **kwargs):
        &#34;&#34;&#34;Return index of max of each column.&#34;&#34;&#34;
        if idx_arr is None:
            if self.idx_arr is None:
                raise ValueError(&#34;Must pass idx_arr&#34;)
            idx_arr = self.idx_arr
        result = reshape_fns.to_1d(self.reduce(tseries_nb.argmax_reduce_nb), raw=True)
        mask = np.isnan(result)
        if mask.any():
            # Contains NaNs
            result[mask] = 0
            result = result.astype(int)
            result = self.wrapper.index[idx_arr[result]].to_numpy()
            result = result.astype(np.object)
            result[mask] = np.nan
        else:
            result = self.wrapper.index[idx_arr[result.astype(int)]].to_numpy()
        return self.wrapper.wrap_reduced(result, **kwargs)

    def _transform_and_plot(self, plot_func):  # pragma: no cover
        &#34;&#34;&#34;Transform data to the format suitable for plotting, and plot.

        Should only be used by plotting methods that disregard X axis labels.&#34;&#34;&#34;
        if self.wrapper.ndim == 1:
            name = None if self.wrapper.columns[0] == 0 else self.wrapper.columns[0]
            return plot_func(pd.Series(self.mapped_arr, name=name))
        # We can&#39;t simply do to_matrix since there can be multiple records for one position in matrix
        a = np.full((self.mapped_arr.shape[0], self.wrapper.shape[1]), np.nan)
        for col in range(self.wrapper.shape[1]):
            masked_arr = self.mapped_arr[self.col_arr == col]
            a[:masked_arr.shape[0], col] = masked_arr
        return plot_func(pd.DataFrame(a, columns=self.wrapper.columns))

    def hist(self, **kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot histogram by column.&#34;&#34;&#34;
        return self._transform_and_plot(lambda x: x.vbt.hist(**kwargs))

    def box(self, **kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot box plot by column.&#34;&#34;&#34;
        return self._transform_and_plot(lambda x: x.vbt.box(**kwargs))


def indexing_on_records(obj, pd_indexing_func):
    &#34;&#34;&#34;Perform indexing on `Records`.&#34;&#34;&#34;
    if obj.wrapper.ndim == 1:
        raise TypeError(&#34;Indexing on Series is not supported&#34;)

    n_rows = len(obj.wrapper.index)
    n_cols = len(obj.wrapper.columns)
    col_mapper = obj.wrapper.wrap(np.broadcast_to(np.arange(n_cols), (n_rows, n_cols)))
    col_mapper = pd_indexing_func(col_mapper)
    if not pd.Index.equals(col_mapper.index, obj.wrapper.index):
        raise NotImplementedError(&#34;Changing index (time axis) is not supported&#34;)

    new_cols = reshape_fns.to_1d(col_mapper.values[0])  # array required
    records = nb.select_record_cols_nb(
        obj.records_arr,
        obj.col_index,
        new_cols
    )
    wrapper = TSArrayWrapper.from_obj(col_mapper, freq=obj.wrapper.freq)
    return records, wrapper


def _records_indexing_func(obj, pd_indexing_func):
    &#34;&#34;&#34;See `indexing_on_records`.&#34;&#34;&#34;
    return obj.__class__(*indexing_on_records(obj, pd_indexing_func), idx_field=obj.idx_field)


class Records(PandasIndexer):
    &#34;&#34;&#34;Exposes methods and properties for working with records.

    Args:
        records_arr (array_like): A structured NumPy array of records.

            Must have the field `col` (column position in a matrix).
        wrapper (TSArrayWrapper): Array wrapper of type `vectorbt.tseries.common.TSArrayWrapper`.
        idx_field (str): The name of the field corresponding to the index. Optional.

            Will be derived automatically if records contain field `&#39;idx&#39;`.&#34;&#34;&#34;

    def __init__(self, records_arr, wrapper, idx_field=None):
        if not isinstance(records_arr, np.ndarray):
            records_arr = np.asarray(records_arr)
        checks.assert_not_none(records_arr.dtype.fields)
        checks.assert_value_in(&#39;col&#39;, records_arr.dtype.names)
        checks.assert_type(wrapper, TSArrayWrapper)
        if idx_field is not None:
            checks.assert_value_in(idx_field, records_arr.dtype.names)
        else:
            if &#39;idx&#39; in records_arr.dtype.names:
                idx_field = &#39;idx&#39;

        self.records_arr = records_arr
        self.wrapper = wrapper
        self.idx_field = idx_field

        PandasIndexer.__init__(self, _records_indexing_func)

    @cached_property
    def records(self):
        &#34;&#34;&#34;Records.&#34;&#34;&#34;
        return pd.DataFrame.from_records(self.records_arr)

    @cached_property
    def recarray(self):
        return self.records_arr.view(np.recarray)

    @cached_property
    def col_index(self):
        &#34;&#34;&#34;Column index for `Records.records`.&#34;&#34;&#34;
        return nb.record_col_index_nb(self.records_arr, len(self.wrapper.columns))

    def filter_by_mask(self, mask):
        &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
        return self.__class__(self.records_arr[mask], self.wrapper, idx_field=self.idx_field)

    def map(self, map_func_nb, *args, idx_arr=None):
        &#34;&#34;&#34;Map each record to a scalar value. Returns `MappedArray`.

        See `vectorbt.records.nb.map_records_nb`.&#34;&#34;&#34;
        checks.assert_numba_func(map_func_nb)

        mapped_arr = nb.map_records_nb(self.records_arr, map_func_nb, *args)
        if idx_arr is None:
            if self.idx_field is not None:
                idx_arr = self.records_arr[self.idx_field]
            else:
                idx_arr = None
        return MappedArray(mapped_arr, self.records_arr[&#39;col&#39;], self.wrapper, idx_arr=idx_arr)

    def map_field(self, field, idx_arr=None):
        &#34;&#34;&#34;Convert field to `MappedArray`.&#34;&#34;&#34;
        if idx_arr is None:
            if self.idx_field is not None:
                idx_arr = self.records_arr[self.idx_field]
            else:
                idx_arr = None
        return MappedArray(self.records_arr[field], self.records_arr[&#39;col&#39;], self.wrapper, idx_arr=idx_arr)

    def map_array(self, a, idx_arr=None):
        &#34;&#34;&#34;Convert array to `MappedArray`.

         The length of the array should match that of the records.&#34;&#34;&#34;
        if not isinstance(a, np.ndarray):
            a = np.asarray(a)
        checks.assert_same_shape(a, self.records_arr)

        if idx_arr is None:
            if self.idx_field is not None:
                idx_arr = self.records_arr[self.idx_field]
            else:
                idx_arr = None
        return MappedArray(a, self.records_arr[&#39;col&#39;], self.wrapper, idx_arr=idx_arr)

    @cached_property
    def count(self):
        &#34;&#34;&#34;Number of records.&#34;&#34;&#34;
        mapped_arr = np.full(len(self.records_arr), 1)
        return MappedArray(mapped_arr, self.records_arr[&#39;col&#39;], self.wrapper).count(default_val=0.)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.records.base.indexing_on_records"><code class="name flex">
<span>def <span class="ident fname">indexing_on_records</span></span>(<span>obj, pd_indexing_func)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform indexing on <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indexing_on_records(obj, pd_indexing_func):
    &#34;&#34;&#34;Perform indexing on `Records`.&#34;&#34;&#34;
    if obj.wrapper.ndim == 1:
        raise TypeError(&#34;Indexing on Series is not supported&#34;)

    n_rows = len(obj.wrapper.index)
    n_cols = len(obj.wrapper.columns)
    col_mapper = obj.wrapper.wrap(np.broadcast_to(np.arange(n_cols), (n_rows, n_cols)))
    col_mapper = pd_indexing_func(col_mapper)
    if not pd.Index.equals(col_mapper.index, obj.wrapper.index):
        raise NotImplementedError(&#34;Changing index (time axis) is not supported&#34;)

    new_cols = reshape_fns.to_1d(col_mapper.values[0])  # array required
    records = nb.select_record_cols_nb(
        obj.records_arr,
        obj.col_index,
        new_cols
    )
    wrapper = TSArrayWrapper.from_obj(col_mapper, freq=obj.wrapper.freq)
    return records, wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.records.base.MappedArray"><code class="flex name class">
<span>class <span class="ident parent-fname">MappedArray</span></span>
<span>(</span><span>mapped_arr, col_arr, wrapper, idx_arr=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Exposes methods and properties for working with records.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapped_arr</code></strong> :&ensp;<code>array_like</code></dt>
<dd>A one-dimensional array of mapped record values.</dd>
<dt><strong><code>col_arr</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>A one-dimensional column array.</p>
<p>Must be of the same size as <code>mapped_arr</code>.</p>
</dd>
<dt><strong><code>wrapper</code></strong> :&ensp;<code>TSArrayWrapper</code></dt>
<dd>Array wrapper of type <code><a title="vectorbt.tseries.common.TSArrayWrapper" href="../tseries/common.html#vectorbt.tseries.common.TSArrayWrapper">TSArrayWrapper</a></code>.</dd>
<dt><strong><code>idx_arr</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>A one-dimensional index array. Optional.</p>
<p>Must be of the same size as <code>mapped_arr</code>.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MappedArray(PandasIndexer):
    &#34;&#34;&#34;Exposes methods and properties for working with records.

    Args:
        mapped_arr (array_like): A one-dimensional array of mapped record values.
        col_arr (array_like): A one-dimensional column array.

            Must be of the same size as `mapped_arr`.
        wrapper (TSArrayWrapper): Array wrapper of type `vectorbt.tseries.common.TSArrayWrapper`.
        idx_arr (array_like): A one-dimensional index array. Optional.

            Must be of the same size as `mapped_arr`.&#34;&#34;&#34;

    def __init__(self, mapped_arr, col_arr, wrapper, idx_arr=None):
        if not isinstance(mapped_arr, np.ndarray):
            mapped_arr = np.asarray(mapped_arr)
        if not isinstance(col_arr, np.ndarray):
            col_arr = np.asarray(col_arr)
        checks.assert_same_shape(mapped_arr, col_arr, axis=0)
        checks.assert_type(wrapper, TSArrayWrapper)
        if idx_arr is not None:
            if not isinstance(idx_arr, np.ndarray):
                idx_arr = np.asarray(idx_arr)
            checks.assert_same_shape(mapped_arr, idx_arr, axis=0)

        self.mapped_arr = mapped_arr
        self.col_arr = col_arr
        self.wrapper = wrapper
        self.idx_arr = idx_arr

        PandasIndexer.__init__(self, _mapped_indexing_func)

    @cached_property
    def col_index(self):
        &#34;&#34;&#34;Column index for `MappedArray.mapped_arr`.&#34;&#34;&#34;
        return nb.mapped_col_index_nb(self.mapped_arr, self.col_arr, len(self.wrapper.columns))

    def filter_by_mask(self, mask):
        &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
        if self.idx_arr is not None:
            idx_arr = self.idx_arr[mask]
        else:
            idx_arr = None
        return self.__class__(self.mapped_arr[mask], self.col_arr[mask], self.wrapper, idx_arr=idx_arr)

    def to_matrix(self, idx_arr=None, default_val=np.nan):
        &#34;&#34;&#34;Convert mapped array to the matrix form.

        See `vectorbt.records.nb.mapped_to_matrix_nb`.

        !!! warning
            Mapped arrays represent information in the most memory-friendly format.
            Mapping back to the matrix form may occupy lots of memory if records are sparse.

        !!! note
            Will raise an error if there are multiple values pointing at the same matrix element.&#34;&#34;&#34;
        if idx_arr is None:
            if self.idx_arr is None:
                raise ValueError(&#34;Must pass idx_arr&#34;)
            idx_arr = self.idx_arr
        # Check many-to-one relationship
        n_unique = np.unique(np.hstack((self.col_arr[:, None], idx_arr[:, None])), axis=0).shape[0]
        if n_unique &lt; self.col_arr.shape[0]:
            raise ValueError(&#34;Multiple values are pointing at the same matrix element&#34;)
        target_shape = (len(self.wrapper.index), len(self.wrapper.columns))
        result = nb.mapped_to_matrix_nb(self.mapped_arr, self.col_arr, idx_arr, target_shape, default_val)
        return self.wrapper.wrap(result)

    def reduce(self, reduce_func_nb, *args, default_val=np.nan, cast=None, **kwargs):
        &#34;&#34;&#34;Reduce mapped array by column to a scalar value.

        See `vectorbt.records.nb.reduce_mapped_nb`.

        `**kwargs` will be passed to `vectorbt.tseries.common.TSArrayWrapper.wrap_reduced`.&#34;&#34;&#34;
        checks.assert_numba_func(reduce_func_nb)

        result = nb.reduce_mapped_nb(
            self.mapped_arr,
            self.col_arr,
            len(self.wrapper.columns),
            default_val,
            reduce_func_nb,
            *args
        )
        if cast is not None:
            result = result.astype(cast)
        return self.wrapper.wrap_reduced(result, **kwargs)

    def reduce_to_array(self, reduce_func_nb, *args, default_val=np.nan, cast=None, **kwargs):
        &#34;&#34;&#34;Reduce mapped array by column to an array.

        See `vectorbt.records.nb.reduce_mapped_to_array_nb`.

        `**kwargs` will be passed to `vectorbt.tseries.common.TSArrayWrapper.wrap_reduced`.&#34;&#34;&#34;
        checks.assert_numba_func(reduce_func_nb)

        result = nb.reduce_mapped_to_array_nb(
            self.mapped_arr,
            self.col_arr,
            len(self.wrapper.columns),
            default_val,
            reduce_func_nb,
            *args
        )
        if cast is not None:
            result = result.astype(cast)
        return self.wrapper.wrap_reduced(result, **kwargs)

    def nst(self, n, **kwargs):
        &#34;&#34;&#34;Return nst element of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.nst_reduce_nb, n, **kwargs)

    def min(self, **kwargs):
        &#34;&#34;&#34;Return min of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.min_reduce_nb, **kwargs)

    def max(self, **kwargs):
        &#34;&#34;&#34;Return max of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.max_reduce_nb, **kwargs)

    def mean(self, **kwargs):
        &#34;&#34;&#34;Return mean of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.mean_reduce_nb, **kwargs)

    def median(self, **kwargs):
        &#34;&#34;&#34;Return median of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.median_reduce_nb, **kwargs)

    def std(self, ddof=1, **kwargs):
        &#34;&#34;&#34;Return std of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.std_reduce_nb, ddof, **kwargs)

    def sum(self, default_val=0., **kwargs):
        &#34;&#34;&#34;Return sum of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.sum_reduce_nb, default_val=default_val, **kwargs)

    def count(self, default_val=0., cast=np.int64, **kwargs):
        &#34;&#34;&#34;Return count of each column.&#34;&#34;&#34;
        return self.reduce(tseries_nb.count_reduce_nb, default_val=default_val, cast=cast, **kwargs)

    def describe(self, percentiles=None, ddof=1, **kwargs):
        &#34;&#34;&#34;Return stats of each column.&#34;&#34;&#34;
        if percentiles is not None:
            percentiles = reshape_fns.to_1d(percentiles, raw=True)
        else:
            percentiles = np.array([0.25, 0.5, 0.75])
        percentiles = percentiles.tolist()
        if 0.5 not in percentiles:
            percentiles.append(0.5)
        percentiles = np.unique(percentiles)
        perc_formatted = pd.io.formats.format.format_percentiles(percentiles)
        index = pd.Index([&#39;count&#39;, &#39;mean&#39;, &#39;std&#39;, &#39;min&#39;, *perc_formatted, &#39;max&#39;])
        result = self.reduce_to_array(tseries_nb.describe_reduce_nb, percentiles, ddof, index=index, **kwargs)
        if isinstance(result, pd.DataFrame):
            result.loc[&#39;count&#39;].fillna(0., inplace=True)
        else:
            if np.isnan(result.loc[&#39;count&#39;]):
                result.loc[&#39;count&#39;] = 0.
        return result

    def idxmin(self, idx_arr=None, **kwargs):
        &#34;&#34;&#34;Return index of min of each column.&#34;&#34;&#34;
        if idx_arr is None:
            if self.idx_arr is None:
                raise ValueError(&#34;Must pass idx_arr&#34;)
            idx_arr = self.idx_arr
        result = reshape_fns.to_1d(self.reduce(tseries_nb.argmin_reduce_nb), raw=True)
        mask = np.isnan(result)
        if mask.any():
            # Contains NaNs
            result[mask] = 0
            result = result.astype(int)
            result = self.wrapper.index[idx_arr[result]].to_numpy()
            result = result.astype(np.object)
            result[mask] = np.nan
        else:
            result = self.wrapper.index[idx_arr[result.astype(int)]].to_numpy()
        return self.wrapper.wrap_reduced(result, **kwargs)

    def idxmax(self, idx_arr=None, **kwargs):
        &#34;&#34;&#34;Return index of max of each column.&#34;&#34;&#34;
        if idx_arr is None:
            if self.idx_arr is None:
                raise ValueError(&#34;Must pass idx_arr&#34;)
            idx_arr = self.idx_arr
        result = reshape_fns.to_1d(self.reduce(tseries_nb.argmax_reduce_nb), raw=True)
        mask = np.isnan(result)
        if mask.any():
            # Contains NaNs
            result[mask] = 0
            result = result.astype(int)
            result = self.wrapper.index[idx_arr[result]].to_numpy()
            result = result.astype(np.object)
            result[mask] = np.nan
        else:
            result = self.wrapper.index[idx_arr[result.astype(int)]].to_numpy()
        return self.wrapper.wrap_reduced(result, **kwargs)

    def _transform_and_plot(self, plot_func):  # pragma: no cover
        &#34;&#34;&#34;Transform data to the format suitable for plotting, and plot.

        Should only be used by plotting methods that disregard X axis labels.&#34;&#34;&#34;
        if self.wrapper.ndim == 1:
            name = None if self.wrapper.columns[0] == 0 else self.wrapper.columns[0]
            return plot_func(pd.Series(self.mapped_arr, name=name))
        # We can&#39;t simply do to_matrix since there can be multiple records for one position in matrix
        a = np.full((self.mapped_arr.shape[0], self.wrapper.shape[1]), np.nan)
        for col in range(self.wrapper.shape[1]):
            masked_arr = self.mapped_arr[self.col_arr == col]
            a[:masked_arr.shape[0], col] = masked_arr
        return plot_func(pd.DataFrame(a, columns=self.wrapper.columns))

    def hist(self, **kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot histogram by column.&#34;&#34;&#34;
        return self._transform_and_plot(lambda x: x.vbt.hist(**kwargs))

    def box(self, **kwargs):  # pragma: no cover
        &#34;&#34;&#34;Plot box plot by column.&#34;&#34;&#34;
        return self._transform_and_plot(lambda x: x.vbt.box(**kwargs))</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.records.base.MappedArray.col_index"><code class="name">var <span class="ident fname">col_index</span></code></dt>
<dd>
<div class="desc"><p>Column index for <code>MappedArray.mapped_arr</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.records.base.MappedArray.box"><code class="name flex">
<span>def <span class="ident fname">box</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot box plot by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def box(self, **kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot box plot by column.&#34;&#34;&#34;
    return self._transform_and_plot(lambda x: x.vbt.box(**kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.count"><code class="name flex">
<span>def <span class="ident fname">count</span></span>(<span>self, default_val=0.0, cast=numpy.int64, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return count of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(self, default_val=0., cast=np.int64, **kwargs):
    &#34;&#34;&#34;Return count of each column.&#34;&#34;&#34;
    return self.reduce(tseries_nb.count_reduce_nb, default_val=default_val, cast=cast, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.describe"><code class="name flex">
<span>def <span class="ident fname">describe</span></span>(<span>self, percentiles=None, ddof=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return stats of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(self, percentiles=None, ddof=1, **kwargs):
    &#34;&#34;&#34;Return stats of each column.&#34;&#34;&#34;
    if percentiles is not None:
        percentiles = reshape_fns.to_1d(percentiles, raw=True)
    else:
        percentiles = np.array([0.25, 0.5, 0.75])
    percentiles = percentiles.tolist()
    if 0.5 not in percentiles:
        percentiles.append(0.5)
    percentiles = np.unique(percentiles)
    perc_formatted = pd.io.formats.format.format_percentiles(percentiles)
    index = pd.Index([&#39;count&#39;, &#39;mean&#39;, &#39;std&#39;, &#39;min&#39;, *perc_formatted, &#39;max&#39;])
    result = self.reduce_to_array(tseries_nb.describe_reduce_nb, percentiles, ddof, index=index, **kwargs)
    if isinstance(result, pd.DataFrame):
        result.loc[&#39;count&#39;].fillna(0., inplace=True)
    else:
        if np.isnan(result.loc[&#39;count&#39;]):
            result.loc[&#39;count&#39;] = 0.
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.filter_by_mask"><code class="name flex">
<span>def <span class="ident fname">filter_by_mask</span></span>(<span>self, mask)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new class instance, filtered by mask.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_mask(self, mask):
    &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
    if self.idx_arr is not None:
        idx_arr = self.idx_arr[mask]
    else:
        idx_arr = None
    return self.__class__(self.mapped_arr[mask], self.col_arr[mask], self.wrapper, idx_arr=idx_arr)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.hist"><code class="name flex">
<span>def <span class="ident fname">hist</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot histogram by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hist(self, **kwargs):  # pragma: no cover
    &#34;&#34;&#34;Plot histogram by column.&#34;&#34;&#34;
    return self._transform_and_plot(lambda x: x.vbt.hist(**kwargs))</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.idxmax"><code class="name flex">
<span>def <span class="ident fname">idxmax</span></span>(<span>self, idx_arr=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return index of max of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def idxmax(self, idx_arr=None, **kwargs):
    &#34;&#34;&#34;Return index of max of each column.&#34;&#34;&#34;
    if idx_arr is None:
        if self.idx_arr is None:
            raise ValueError(&#34;Must pass idx_arr&#34;)
        idx_arr = self.idx_arr
    result = reshape_fns.to_1d(self.reduce(tseries_nb.argmax_reduce_nb), raw=True)
    mask = np.isnan(result)
    if mask.any():
        # Contains NaNs
        result[mask] = 0
        result = result.astype(int)
        result = self.wrapper.index[idx_arr[result]].to_numpy()
        result = result.astype(np.object)
        result[mask] = np.nan
    else:
        result = self.wrapper.index[idx_arr[result.astype(int)]].to_numpy()
    return self.wrapper.wrap_reduced(result, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.idxmin"><code class="name flex">
<span>def <span class="ident fname">idxmin</span></span>(<span>self, idx_arr=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return index of min of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def idxmin(self, idx_arr=None, **kwargs):
    &#34;&#34;&#34;Return index of min of each column.&#34;&#34;&#34;
    if idx_arr is None:
        if self.idx_arr is None:
            raise ValueError(&#34;Must pass idx_arr&#34;)
        idx_arr = self.idx_arr
    result = reshape_fns.to_1d(self.reduce(tseries_nb.argmin_reduce_nb), raw=True)
    mask = np.isnan(result)
    if mask.any():
        # Contains NaNs
        result[mask] = 0
        result = result.astype(int)
        result = self.wrapper.index[idx_arr[result]].to_numpy()
        result = result.astype(np.object)
        result[mask] = np.nan
    else:
        result = self.wrapper.index[idx_arr[result.astype(int)]].to_numpy()
    return self.wrapper.wrap_reduced(result, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.max"><code class="name flex">
<span>def <span class="ident fname">max</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return max of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max(self, **kwargs):
    &#34;&#34;&#34;Return max of each column.&#34;&#34;&#34;
    return self.reduce(tseries_nb.max_reduce_nb, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.mean"><code class="name flex">
<span>def <span class="ident fname">mean</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return mean of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(self, **kwargs):
    &#34;&#34;&#34;Return mean of each column.&#34;&#34;&#34;
    return self.reduce(tseries_nb.mean_reduce_nb, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.median"><code class="name flex">
<span>def <span class="ident fname">median</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return median of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def median(self, **kwargs):
    &#34;&#34;&#34;Return median of each column.&#34;&#34;&#34;
    return self.reduce(tseries_nb.median_reduce_nb, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.min"><code class="name flex">
<span>def <span class="ident fname">min</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return min of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min(self, **kwargs):
    &#34;&#34;&#34;Return min of each column.&#34;&#34;&#34;
    return self.reduce(tseries_nb.min_reduce_nb, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.nst"><code class="name flex">
<span>def <span class="ident fname">nst</span></span>(<span>self, n, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return nst element of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nst(self, n, **kwargs):
    &#34;&#34;&#34;Return nst element of each column.&#34;&#34;&#34;
    return self.reduce(tseries_nb.nst_reduce_nb, n, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.reduce"><code class="name flex">
<span>def <span class="ident fname">reduce</span></span>(<span>self, reduce_func_nb, *args, default_val=nan, cast=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduce mapped array by column to a scalar value.</p>
<p>See <code><a title="vectorbt.records.nb.reduce_mapped_nb" href="nb.html#vectorbt.records.nb.reduce_mapped_nb">reduce_mapped_nb()</a></code>.</p>
<p><code>**kwargs</code> will be passed to <code><a title="vectorbt.tseries.common.TSArrayWrapper.wrap_reduced" href="../tseries/common.html#vectorbt.tseries.common.TSArrayWrapper.wrap_reduced">TSArrayWrapper.wrap_reduced()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce(self, reduce_func_nb, *args, default_val=np.nan, cast=None, **kwargs):
    &#34;&#34;&#34;Reduce mapped array by column to a scalar value.

    See `vectorbt.records.nb.reduce_mapped_nb`.

    `**kwargs` will be passed to `vectorbt.tseries.common.TSArrayWrapper.wrap_reduced`.&#34;&#34;&#34;
    checks.assert_numba_func(reduce_func_nb)

    result = nb.reduce_mapped_nb(
        self.mapped_arr,
        self.col_arr,
        len(self.wrapper.columns),
        default_val,
        reduce_func_nb,
        *args
    )
    if cast is not None:
        result = result.astype(cast)
    return self.wrapper.wrap_reduced(result, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.reduce_to_array"><code class="name flex">
<span>def <span class="ident fname">reduce_to_array</span></span>(<span>self, reduce_func_nb, *args, default_val=nan, cast=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduce mapped array by column to an array.</p>
<p>See <code><a title="vectorbt.records.nb.reduce_mapped_to_array_nb" href="nb.html#vectorbt.records.nb.reduce_mapped_to_array_nb">reduce_mapped_to_array_nb()</a></code>.</p>
<p><code>**kwargs</code> will be passed to <code><a title="vectorbt.tseries.common.TSArrayWrapper.wrap_reduced" href="../tseries/common.html#vectorbt.tseries.common.TSArrayWrapper.wrap_reduced">TSArrayWrapper.wrap_reduced()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_to_array(self, reduce_func_nb, *args, default_val=np.nan, cast=None, **kwargs):
    &#34;&#34;&#34;Reduce mapped array by column to an array.

    See `vectorbt.records.nb.reduce_mapped_to_array_nb`.

    `**kwargs` will be passed to `vectorbt.tseries.common.TSArrayWrapper.wrap_reduced`.&#34;&#34;&#34;
    checks.assert_numba_func(reduce_func_nb)

    result = nb.reduce_mapped_to_array_nb(
        self.mapped_arr,
        self.col_arr,
        len(self.wrapper.columns),
        default_val,
        reduce_func_nb,
        *args
    )
    if cast is not None:
        result = result.astype(cast)
    return self.wrapper.wrap_reduced(result, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.std"><code class="name flex">
<span>def <span class="ident fname">std</span></span>(<span>self, ddof=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return std of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def std(self, ddof=1, **kwargs):
    &#34;&#34;&#34;Return std of each column.&#34;&#34;&#34;
    return self.reduce(tseries_nb.std_reduce_nb, ddof, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.sum"><code class="name flex">
<span>def <span class="ident fname">sum</span></span>(<span>self, default_val=0.0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return sum of each column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum(self, default_val=0., **kwargs):
    &#34;&#34;&#34;Return sum of each column.&#34;&#34;&#34;
    return self.reduce(tseries_nb.sum_reduce_nb, default_val=default_val, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.MappedArray.to_matrix"><code class="name flex">
<span>def <span class="ident fname">to_matrix</span></span>(<span>self, idx_arr=None, default_val=nan)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert mapped array to the matrix form.</p>
<p>See <code><a title="vectorbt.records.nb.mapped_to_matrix_nb" href="nb.html#vectorbt.records.nb.mapped_to_matrix_nb">mapped_to_matrix_nb()</a></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Mapped arrays represent information in the most memory-friendly format.
Mapping back to the matrix form may occupy lots of memory if records are sparse.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Will raise an error if there are multiple values pointing at the same matrix element.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_matrix(self, idx_arr=None, default_val=np.nan):
    &#34;&#34;&#34;Convert mapped array to the matrix form.

    See `vectorbt.records.nb.mapped_to_matrix_nb`.

    !!! warning
        Mapped arrays represent information in the most memory-friendly format.
        Mapping back to the matrix form may occupy lots of memory if records are sparse.

    !!! note
        Will raise an error if there are multiple values pointing at the same matrix element.&#34;&#34;&#34;
    if idx_arr is None:
        if self.idx_arr is None:
            raise ValueError(&#34;Must pass idx_arr&#34;)
        idx_arr = self.idx_arr
    # Check many-to-one relationship
    n_unique = np.unique(np.hstack((self.col_arr[:, None], idx_arr[:, None])), axis=0).shape[0]
    if n_unique &lt; self.col_arr.shape[0]:
        raise ValueError(&#34;Multiple values are pointing at the same matrix element&#34;)
    target_shape = (len(self.wrapper.index), len(self.wrapper.columns))
    result = nb.mapped_to_matrix_nb(self.mapped_arr, self.col_arr, idx_arr, target_shape, default_val)
    return self.wrapper.wrap(result)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.indexing.PandasIndexer.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.records.base.Records"><code class="flex name class">
<span>class <span class="ident parent-fname">Records</span></span>
<span>(</span><span>records_arr, wrapper, idx_field=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Exposes methods and properties for working with records.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>records_arr</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>A structured NumPy array of records.</p>
<p>Must have the field <code>col</code> (column position in a matrix).</p>
</dd>
<dt><strong><code>wrapper</code></strong> :&ensp;<code>TSArrayWrapper</code></dt>
<dd>Array wrapper of type <code><a title="vectorbt.tseries.common.TSArrayWrapper" href="../tseries/common.html#vectorbt.tseries.common.TSArrayWrapper">TSArrayWrapper</a></code>.</dd>
<dt><strong><code>idx_field</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>The name of the field corresponding to the index. Optional.</p>
<p>Will be derived automatically if records contain field <code>'idx'</code>.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Records(PandasIndexer):
    &#34;&#34;&#34;Exposes methods and properties for working with records.

    Args:
        records_arr (array_like): A structured NumPy array of records.

            Must have the field `col` (column position in a matrix).
        wrapper (TSArrayWrapper): Array wrapper of type `vectorbt.tseries.common.TSArrayWrapper`.
        idx_field (str): The name of the field corresponding to the index. Optional.

            Will be derived automatically if records contain field `&#39;idx&#39;`.&#34;&#34;&#34;

    def __init__(self, records_arr, wrapper, idx_field=None):
        if not isinstance(records_arr, np.ndarray):
            records_arr = np.asarray(records_arr)
        checks.assert_not_none(records_arr.dtype.fields)
        checks.assert_value_in(&#39;col&#39;, records_arr.dtype.names)
        checks.assert_type(wrapper, TSArrayWrapper)
        if idx_field is not None:
            checks.assert_value_in(idx_field, records_arr.dtype.names)
        else:
            if &#39;idx&#39; in records_arr.dtype.names:
                idx_field = &#39;idx&#39;

        self.records_arr = records_arr
        self.wrapper = wrapper
        self.idx_field = idx_field

        PandasIndexer.__init__(self, _records_indexing_func)

    @cached_property
    def records(self):
        &#34;&#34;&#34;Records.&#34;&#34;&#34;
        return pd.DataFrame.from_records(self.records_arr)

    @cached_property
    def recarray(self):
        return self.records_arr.view(np.recarray)

    @cached_property
    def col_index(self):
        &#34;&#34;&#34;Column index for `Records.records`.&#34;&#34;&#34;
        return nb.record_col_index_nb(self.records_arr, len(self.wrapper.columns))

    def filter_by_mask(self, mask):
        &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
        return self.__class__(self.records_arr[mask], self.wrapper, idx_field=self.idx_field)

    def map(self, map_func_nb, *args, idx_arr=None):
        &#34;&#34;&#34;Map each record to a scalar value. Returns `MappedArray`.

        See `vectorbt.records.nb.map_records_nb`.&#34;&#34;&#34;
        checks.assert_numba_func(map_func_nb)

        mapped_arr = nb.map_records_nb(self.records_arr, map_func_nb, *args)
        if idx_arr is None:
            if self.idx_field is not None:
                idx_arr = self.records_arr[self.idx_field]
            else:
                idx_arr = None
        return MappedArray(mapped_arr, self.records_arr[&#39;col&#39;], self.wrapper, idx_arr=idx_arr)

    def map_field(self, field, idx_arr=None):
        &#34;&#34;&#34;Convert field to `MappedArray`.&#34;&#34;&#34;
        if idx_arr is None:
            if self.idx_field is not None:
                idx_arr = self.records_arr[self.idx_field]
            else:
                idx_arr = None
        return MappedArray(self.records_arr[field], self.records_arr[&#39;col&#39;], self.wrapper, idx_arr=idx_arr)

    def map_array(self, a, idx_arr=None):
        &#34;&#34;&#34;Convert array to `MappedArray`.

         The length of the array should match that of the records.&#34;&#34;&#34;
        if not isinstance(a, np.ndarray):
            a = np.asarray(a)
        checks.assert_same_shape(a, self.records_arr)

        if idx_arr is None:
            if self.idx_field is not None:
                idx_arr = self.records_arr[self.idx_field]
            else:
                idx_arr = None
        return MappedArray(a, self.records_arr[&#39;col&#39;], self.wrapper, idx_arr=idx_arr)

    @cached_property
    def count(self):
        &#34;&#34;&#34;Number of records.&#34;&#34;&#34;
        mapped_arr = np.full(len(self.records_arr), 1)
        return MappedArray(mapped_arr, self.records_arr[&#39;col&#39;], self.wrapper).count(default_val=0.)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.records.drawdowns.BaseDrawdowns" href="drawdowns.html#vectorbt.records.drawdowns.BaseDrawdowns">BaseDrawdowns</a></li>
<li><a title="vectorbt.records.events.BaseEvents" href="events.html#vectorbt.records.events.BaseEvents">BaseEvents</a></li>
<li><a title="vectorbt.records.orders.BaseOrders" href="orders.html#vectorbt.records.orders.BaseOrders">BaseOrders</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.records.base.Records.col_index"><code class="name">var <span class="ident fname">col_index</span></code></dt>
<dd>
<div class="desc"><p>Column index for <code><a title="vectorbt.records.base.Records.records" href="#vectorbt.records.base.Records.records">Records.records</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.count"><code class="name">var <span class="ident fname">count</span></code></dt>
<dd>
<div class="desc"><p>Number of records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.recarray"><code class="name">var <span class="ident fname">recarray</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.records"><code class="name">var <span class="ident fname">records</span></code></dt>
<dd>
<div class="desc"><p>Records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if not defaults.caching or self.disabled:  # you can manually disable cache here
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.records.base.Records.filter_by_mask"><code class="name flex">
<span>def <span class="ident fname">filter_by_mask</span></span>(<span>self, mask)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new class instance, filtered by mask.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_mask(self, mask):
    &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
    return self.__class__(self.records_arr[mask], self.wrapper, idx_field=self.idx_field)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.map"><code class="name flex">
<span>def <span class="ident fname">map</span></span>(<span>self, map_func_nb, *args, idx_arr=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Map each record to a scalar value. Returns <code><a title="vectorbt.records.base.MappedArray" href="#vectorbt.records.base.MappedArray">MappedArray</a></code>.</p>
<p>See <code><a title="vectorbt.records.nb.map_records_nb" href="nb.html#vectorbt.records.nb.map_records_nb">map_records_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, map_func_nb, *args, idx_arr=None):
    &#34;&#34;&#34;Map each record to a scalar value. Returns `MappedArray`.

    See `vectorbt.records.nb.map_records_nb`.&#34;&#34;&#34;
    checks.assert_numba_func(map_func_nb)

    mapped_arr = nb.map_records_nb(self.records_arr, map_func_nb, *args)
    if idx_arr is None:
        if self.idx_field is not None:
            idx_arr = self.records_arr[self.idx_field]
        else:
            idx_arr = None
    return MappedArray(mapped_arr, self.records_arr[&#39;col&#39;], self.wrapper, idx_arr=idx_arr)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.map_array"><code class="name flex">
<span>def <span class="ident fname">map_array</span></span>(<span>self, a, idx_arr=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert array to <code><a title="vectorbt.records.base.MappedArray" href="#vectorbt.records.base.MappedArray">MappedArray</a></code>.</p>
<p>The length of the array should match that of the records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_array(self, a, idx_arr=None):
    &#34;&#34;&#34;Convert array to `MappedArray`.

     The length of the array should match that of the records.&#34;&#34;&#34;
    if not isinstance(a, np.ndarray):
        a = np.asarray(a)
    checks.assert_same_shape(a, self.records_arr)

    if idx_arr is None:
        if self.idx_field is not None:
            idx_arr = self.records_arr[self.idx_field]
        else:
            idx_arr = None
    return MappedArray(a, self.records_arr[&#39;col&#39;], self.wrapper, idx_arr=idx_arr)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.map_field"><code class="name flex">
<span>def <span class="ident fname">map_field</span></span>(<span>self, field, idx_arr=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert field to <code><a title="vectorbt.records.base.MappedArray" href="#vectorbt.records.base.MappedArray">MappedArray</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_field(self, field, idx_arr=None):
    &#34;&#34;&#34;Convert field to `MappedArray`.&#34;&#34;&#34;
    if idx_arr is None:
        if self.idx_field is not None:
            idx_arr = self.records_arr[self.idx_field]
        else:
            idx_arr = None
    return MappedArray(self.records_arr[field], self.records_arr[&#39;col&#39;], self.wrapper, idx_arr=idx_arr)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.indexing.PandasIndexer.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.indexing.PandasIndexer.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAACXBIWXMAACcQAAAnEAGUaVEZAAAGuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDggNzkuMTY0MDM2LCAyMDE5LzA4LzEzLTAxOjA2OjU3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjEuMCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjAtMDYtMjVUMjM6MzU6MTMrMDI6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjAtMDYtMjZUMTQ6MTA6MzgrMDI6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIwLTA2LTI2VDE0OjEwOjM4KzAyOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNzE0MGFiYi05Mjk1LTQ3MDYtYTNhZi1lMDg2OTFkOTk3NjQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NzZmN2Y4NjAtMThmMi00ZDgxLTg5NjUtNDU5ZjY1NDY2ZGZlIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NzZmN2Y4NjAtMThmMi00ZDgxLTg5NjUtNDU5ZjY1NDY2ZGZlIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjc2ZjdmODYwLTE4ZjItNGQ4MS04OTY1LTQ1OWY2NTQ2NmRmZSIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNVQyMzozNToxMyswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2NjI2MGIzLTY0ZmUtNGJiYy1iMTNiLWZkMDU3NDI3NjIyNCIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNlQxMzoyMTo1NSswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjA3MTQwYWJiLTkyOTUtNDcwNi1hM2FmLWUwODY5MWQ5OTc2NCIgc3RFdnQ6d2hlbj0iMjAyMC0wNi0yNlQxNDoxMDozOCswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Qc/+aQAAAa5JREFUeJzt3cFJA0EYgFEjgj3FGmIjsQexByuxB4vy5kHwELJhCRPekP3eMYdl4Ms/y84Gstsfjg9xHvUCtq4AWAGwAmAFwAqAFQArAFYArABYAbACYAXACoAVACsAVgCsAFgBsAJgBcAKgBUAexp1oe+vz7Ofv7y+dZ0LmgCsAFgBsAJgBcAKgBUAKwBWAKwAWAGwAmAFwAqAFQAb9j5glFHn7KPcej1NAFYAzG9BP+/n3/ld9vwx1051tSYA8xPwZ/03+rqJmVYTgBUAm2UL+re0w6i7br8LunMFwAqAFQArAFYArADYdM8Bd3PKtlITgBUAm2ULurMzzvWaAMxPwNbuuieaAKwAmN+CTtz6/H02TQBWAKwAWAGwAmAFwAqAFQArAFYArABYAbACYAXACoANex8w23n9bOtZ0gRgBcAKgBUAKwBWAKwA2HT/HzDKbOtZ0gRgBcAKgBUAKwBWAKwAWAGwAmAFwAqAFQArAFYArADYbn846jVsWhOAFQArAFYArABYAbACYAXACoAVACsAVgCsAFgBsAJgBcAKgBUAKwBWAKwAWAGwAmC/7uUrwcQVST8AAAAASUVORK5CYII="/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul>
<li><a href="#records-class">Records class</a></li>
<li><a href="#mappedarray-class">MappedArray class</a></li>
<li><a href="#example">Example</a><ul>
<li><a href="#mapping">Mapping</a></li>
<li><a href="#reducing">Reducing</a></li>
<li><a href="#conversion">Conversion</a></li>
<li><a href="#plotting">Plotting</a></li>
</ul>
</li>
<li><a href="#indexing">Indexing</a></li>
<li><a href="#operators">Operators</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.records" href="index.html">vectorbt.records</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.records.base.indexing_on_records" href="#vectorbt.records.base.indexing_on_records">indexing_on_records</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.records.base.MappedArray" href="#vectorbt.records.base.MappedArray">MappedArray</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.records.base.MappedArray.box" href="#vectorbt.records.base.MappedArray.box">box</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.col_index" href="#vectorbt.records.base.MappedArray.col_index">col_index</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.count" href="#vectorbt.records.base.MappedArray.count">count</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.describe" href="#vectorbt.records.base.MappedArray.describe">describe</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.filter_by_mask" href="#vectorbt.records.base.MappedArray.filter_by_mask">filter_by_mask</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.hist" href="#vectorbt.records.base.MappedArray.hist">hist</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.idxmax" href="#vectorbt.records.base.MappedArray.idxmax">idxmax</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.idxmin" href="#vectorbt.records.base.MappedArray.idxmin">idxmin</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.max" href="#vectorbt.records.base.MappedArray.max">max</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.mean" href="#vectorbt.records.base.MappedArray.mean">mean</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.median" href="#vectorbt.records.base.MappedArray.median">median</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.min" href="#vectorbt.records.base.MappedArray.min">min</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.nst" href="#vectorbt.records.base.MappedArray.nst">nst</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.reduce" href="#vectorbt.records.base.MappedArray.reduce">reduce</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.reduce_to_array" href="#vectorbt.records.base.MappedArray.reduce_to_array">reduce_to_array</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.std" href="#vectorbt.records.base.MappedArray.std">std</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.sum" href="#vectorbt.records.base.MappedArray.sum">sum</a></code></li>
<li><code><a title="vectorbt.records.base.MappedArray.to_matrix" href="#vectorbt.records.base.MappedArray.to_matrix">to_matrix</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.records.base.Records.col_index" href="#vectorbt.records.base.Records.col_index">col_index</a></code></li>
<li><code><a title="vectorbt.records.base.Records.count" href="#vectorbt.records.base.Records.count">count</a></code></li>
<li><code><a title="vectorbt.records.base.Records.filter_by_mask" href="#vectorbt.records.base.Records.filter_by_mask">filter_by_mask</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map" href="#vectorbt.records.base.Records.map">map</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map_array" href="#vectorbt.records.base.Records.map_array">map_array</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map_field" href="#vectorbt.records.base.Records.map_field">map_field</a></code></li>
<li><code><a title="vectorbt.records.base.Records.recarray" href="#vectorbt.records.base.Records.recarray">recarray</a></code></li>
<li><code><a title="vectorbt.records.base.Records.records" href="#vectorbt.records.base.Records.records">records</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>