<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>vectorbt.records.base API documentation</title>
<meta name="description" content="Base class for working with records â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#e82}body{line-height:1.5em}.version{font-weight:normal;font-style:italic;font-size:.75em;color:#8b949e}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}h2[id^="header-"]{margin-top:2em}.ident{color:#900}.headerlink{color:inherit}.headerlink:hover{color:inherit}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important;word-break:normal}.hljs-keyword{color:#ff7b72 !important}.hljs-comment{color:#8b949e !important}.hljs-meta{color:#8b949e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 1.5em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:1em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-weight:400;font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{min-width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}.hljs{margin-left:-15px;margin-right:-15px}.source pre code{margin-left:0px;margin-right:0px}dd{margin:0 0 1em 3em}dd dd{margin-left:2em}.flex{display:flex !important}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4QLCS0J048"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4QLCS0J048');
</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:100px;max-height:100px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.records.base</code></h1>
</header>
<section id="section-intro">
<p>Base class for working with records.</p>
<p>vectorbt works with two different representations of data: matrices and records.</p>
<p>A matrix, in this context, is just an array of one-dimensional arrays, each corresponding
to a separate feature. The matrix itself holds only one kind of information (one attribute).
For example, one can create a matrix for entry signals, with columns being different strategy
configurations. But what if the matrix is huge and sparse? What if there is more
information we would like to represent by each element? Creating multiple matrices would be
a waste of memory.</p>
<p>Records make possible representing complex, sparse information in a dense format. They are just
an array of one-dimensional arrays of fixed schema. You can imagine records being a DataFrame,
where each row represents a record and each column represents a specific attribute.</p>
<pre><code class="language-plaintext">               a     b
         0   1.0   5.0
attr1 =  1   2.0   NaN
         2   NaN   7.0
         3   4.0   8.0
               a     b
         0   9.0  13.0
attr2 =  1  10.0   NaN
         2   NaN  15.0
         3  12.0  16.0
            |
            v
      id  col  idx  attr1  attr2
0      0    0    0      1      9
1      1    0    1      2     10
2      2    0    3      4     12
3      3    1    0      5     13
4      4    1    1      7     15
5      5    1    3      8     16
</code></pre>
<p>Another advantage of records is that they are not constrained by size. Multiple records can map
to a single element in a matrix. For example, one can define multiple orders at the same time step,
which is impossible to represent in a matrix form without using complex data types.</p>
<p>Consider the following example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; example_dt = np.dtype([
...     ('id', np.int_),
...     ('col', np.int_),
...     ('idx', np.int_),
...     ('some_field', np.float_)
... ])
&gt;&gt;&gt; records_arr = np.array([
...     (0, 0, 0, 10.),
...     (1, 0, 1, 11.),
...     (2, 0, 2, 12.),
...     (3, 1, 0, 13.),
...     (4, 1, 1, 14.),
...     (5, 1, 2, 15.),
...     (6, 2, 0, 16.),
...     (7, 2, 1, 17.),
...     (8, 2, 2, 18.)
... ], dtype=example_dt)
&gt;&gt;&gt; wrapper = vbt.ArrayWrapper(index=['x', 'y', 'z'],
...     columns=['a', 'b', 'c'], ndim=2, freq='1 day')
&gt;&gt;&gt; records = vbt.Records(wrapper, records_arr)
</code></pre>
<h2 id="printing">Printing</h2>
<p>There are two ways to print records:</p>
<ul>
<li>Raw dataframe that preserves field names and data types:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; records.records
   id  col  idx  some_field
0   0    0    0        10.0
1   1    0    1        11.0
2   2    0    2        12.0
3   3    1    0        13.0
4   4    1    1        14.0
5   5    1    2        15.0
6   6    2    0        16.0
7   7    2    1        17.0
8   8    2    2        18.0
</code></pre>
<ul>
<li>Readable dataframe that takes into consideration <code><a title="vectorbt.records.base.Records.field_config" href="#vectorbt.records.base.Records.field_config">Records.field_config</a></code>:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; records.records_readable
   Id Column Timestamp  some_field
0   0      a         x        10.0
1   1      a         y        11.0
2   2      a         z        12.0
3   3      b         x        13.0
4   4      b         y        14.0
5   5      b         z        15.0
6   6      c         x        16.0
7   7      c         y        17.0
8   8      c         z        18.0
</code></pre>
<h2 id="mapping">Mapping</h2>
<p><code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> are just <a href="https://numpy.org/doc/stable/user/basics.rec.html">structured arrays</a> with a bunch
of methods and properties for processing them. Their main feature is to map the records array and
to reduce it by column (similar to the MapReduce paradigm). The main advantage is that it all happens
without conversion to the matrix form and wasting memory resources.</p>
<p><code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> can be mapped to <code><a title="vectorbt.records.mapped_array.MappedArray" href="mapped_array.html#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code> in several ways:</p>
<ul>
<li>Use <code><a title="vectorbt.records.base.Records.map_field" href="#vectorbt.records.base.Records.map_field">Records.map_field()</a></code> to map a record field:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; records.map_field('some_field')
&lt;vectorbt.records.mapped_array.MappedArray at 0x7ff49bd31a58&gt;

&gt;&gt;&gt; records.map_field('some_field').values
array([10., 11., 12., 13., 14., 15., 16., 17., 18.])
</code></pre>
<ul>
<li>Use <code><a title="vectorbt.records.base.Records.map" href="#vectorbt.records.base.Records.map">Records.map()</a></code> to map records using a custom function.</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; @njit
... def power_map_nb(record, pow):
...     return record.some_field ** pow

&gt;&gt;&gt; records.map(power_map_nb, 2)
&lt;vectorbt.records.mapped_array.MappedArray at 0x7ff49c990cf8&gt;

&gt;&gt;&gt; records.map(power_map_nb, 2).values
array([100., 121., 144., 169., 196., 225., 256., 289., 324.])
</code></pre>
<ul>
<li>Use <code><a title="vectorbt.records.base.Records.map_array" href="#vectorbt.records.base.Records.map_array">Records.map_array()</a></code> to convert an array to <code><a title="vectorbt.records.mapped_array.MappedArray" href="mapped_array.html#vectorbt.records.mapped_array.MappedArray">MappedArray</a></code>.</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; records.map_array(records_arr['some_field'] ** 2)
&lt;vectorbt.records.mapped_array.MappedArray object at 0x7fe9bccf2978&gt;

&gt;&gt;&gt; records.map_array(records_arr['some_field'] ** 2).values
array([100., 121., 144., 169., 196., 225., 256., 289., 324.])
</code></pre>
<ul>
<li>Use <code><a title="vectorbt.records.base.Records.apply" href="#vectorbt.records.base.Records.apply">Records.apply()</a></code> to apply a function on each column/group:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; @njit
... def cumsum_apply_nb(records):
...     return np.cumsum(records.some_field)

&gt;&gt;&gt; records.apply(cumsum_apply_nb)
&lt;vectorbt.records.mapped_array.MappedArray at 0x7ff49c990cf8&gt;

&gt;&gt;&gt; records.apply(cumsum_apply_nb).values
array([10., 21., 33., 13., 27., 42., 16., 33., 51.])

&gt;&gt;&gt; group_by = np.array(['first', 'first', 'second'])
&gt;&gt;&gt; records.apply(cumsum_apply_nb, group_by=group_by, apply_per_group=True).values
array([10., 21., 33., 46., 60., 75., 16., 33., 51.])
</code></pre>
<p>Notice how cumsum resets at each column in the first example and at each group in the second example.</p>
<h2 id="filtering">Filtering</h2>
<p>Use <code><a title="vectorbt.records.base.Records.apply_mask" href="#vectorbt.records.base.Records.apply_mask">Records.apply_mask()</a></code> to filter elements per column/group:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mask = [True, False, True, False, True, False, True, False, True]
&gt;&gt;&gt; filtered_records = records.apply_mask(mask)
&gt;&gt;&gt; filtered_records.count()
a    2
b    1
c    2
dtype: int64

&gt;&gt;&gt; filtered_records.values['id']
array([0, 2, 4, 6, 8])
</code></pre>
<h2 id="grouping">Grouping</h2>
<p>One of the key features of <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> is that you can perform reducing operations on a group
of columns as if they were a single column. Groups can be specified by <code>group_by</code>, which
can be anything from positions or names of column levels, to a NumPy array with actual groups.</p>
<p>There are multiple ways of define grouping:</p>
<ul>
<li>When creating <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code>, pass <code>group_by</code> to <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; group_by = np.array(['first', 'first', 'second'])
&gt;&gt;&gt; grouped_wrapper = wrapper.replace(group_by=group_by)
&gt;&gt;&gt; grouped_records = vbt.Records(grouped_wrapper, records_arr)

&gt;&gt;&gt; grouped_records.map_field('some_field').mean()
first     12.5
second    17.0
dtype: float64
</code></pre>
<ul>
<li>Regroup an existing <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code>:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; records.regroup(group_by).map_field('some_field').mean()
first     12.5
second    17.0
dtype: float64
</code></pre>
<ul>
<li>Pass <code>group_by</code> directly to the mapping method:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; records.map_field('some_field', group_by=group_by).mean()
first     12.5
second    17.0
dtype: float64
</code></pre>
<ul>
<li>Pass <code>group_by</code> directly to the reducing method:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; records.map_field('some_field').mean(group_by=group_by)
a    11.0
b    14.0
c    17.0
dtype: float64
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Grouping applies only to reducing operations, there is no change to the arrays.</p>
</div>
<h2 id="indexing">Indexing</h2>
<p>Like any other class subclassing <code><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></code>, we can do pandas indexing
on a <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> instance, which forwards indexing operation to each object with columns:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; records['a'].records
   id  col  idx  some_field
0   0    0    0        10.0
1   1    0    1        11.0
2   2    0    2        12.0

&gt;&gt;&gt; grouped_records['first'].records
   id  col  idx  some_field
0   0    0    0        10.0
1   1    0    1        11.0
2   2    0    2        12.0
3   3    1    0        13.0
4   4    1    1        14.0
5   5    1    2        15.0
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Changing index (time axis) is not supported. The object should be treated as a Series
rather than a DataFrame; for example, use <code>some_field.iloc[0]</code> instead of <code>some_field.iloc[:, 0]</code>.</p>
<p>Indexing behavior depends solely upon <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.
For example, if <code>group_select</code> is enabled indexing will be performed on groups,
otherwise on single columns.</p>
</div>
<h2 id="caching">Caching</h2>
<p><code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> supports caching. If a method or a property requires heavy computation, it's wrapped
with <code><a title="vectorbt.utils.decorators.cached_method" href="../utils/decorators.html#vectorbt.utils.decorators.cached_method">cached_method()</a></code> and <code><a title="vectorbt.utils.decorators.cached_property" href="../utils/decorators.html#vectorbt.utils.decorators.cached_property">cached_property</a></code>
respectively. Caching can be disabled globally via <code>caching</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because of caching, class is meant to be immutable and all properties are read-only.
To change any attribute, use the <code>copy</code> method and pass the attribute as keyword argument.</p>
</div>
<h2 id="saving-and-loading">Saving and loading</h2>
<p>Like any other class subclassing <code><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></code>, we can save a <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code>
instance to the disk with <code><a title="vectorbt.records.base.Records.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">Pickleable.save()</a></code> and load it with <code><a title="vectorbt.records.base.Records.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">Pickleable.load()</a></code>.</p>
<h2 id="stats">Stats</h2>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>See <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code> and <code><a title="vectorbt.records.base.Records.metrics" href="#vectorbt.records.base.Records.metrics">Records.metrics</a></code>.</p>
</div>
<pre><code class="language-python-repl">&gt;&gt;&gt; records.stats(column='a')
Start                          x
End                            z
Period           3 days 00:00:00
Total Records                  3
Name: a, dtype: object
</code></pre>
<p><code><a title="vectorbt.records.base.Records.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code> also supports (re-)grouping:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; grouped_records.stats(column='first')
Start                          x
End                            z
Period           3 days 00:00:00
Total Records                  6
Name: first, dtype: object
</code></pre>
<h2 id="plots">Plots</h2>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>See <code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">PlotsBuilderMixin.plots()</a></code> and <code><a title="vectorbt.records.base.Records.subplots" href="#vectorbt.records.base.Records.subplots">Records.subplots</a></code>.</p>
</div>
<p>This class is too generic to have any subplots, but feel free to add custom subplots to your subclass.</p>
<h2 id="extending">Extending</h2>
<p><code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> class can be extended by subclassing.</p>
<p>In case some of our fields have the same meaning but different naming (such as the base field <code>idx</code>)
or other properties, we can override <code>field_config</code> using <code><a title="vectorbt.records.decorators.override_field_config" href="decorators.html#vectorbt.records.decorators.override_field_config">override_field_config()</a></code>.
It will look for configs of all base classes and merge our config on top of them. This preserves
any base class property that is not explicitly listed in our config.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from vectorbt.records.decorators import override_field_config

&gt;&gt;&gt; my_dt = np.dtype([
...     ('my_id', np.int_),
...     ('my_col', np.int_),
...     ('my_idx', np.int_)
... ])

&gt;&gt;&gt; my_fields_config = dict(
...     dtype=my_dt,
...     settings=dict(
...         id=dict(name='my_id'),
...         col=dict(name='my_col'),
...         idx=dict(name='my_idx')
...     )
... )
&gt;&gt;&gt; @override_field_config(my_fields_config)
... class MyRecords(vbt.Records):
...     pass

&gt;&gt;&gt; records_arr = np.array([
...     (0, 0, 0),
...     (1, 0, 1),
...     (2, 1, 0),
...     (3, 1, 1)
... ], dtype=my_dt)
&gt;&gt;&gt; wrapper = vbt.ArrayWrapper(index=['x', 'y'],
...     columns=['a', 'b'], ndim=2, freq='1 day')
&gt;&gt;&gt; my_records = MyRecords(wrapper, records_arr)

&gt;&gt;&gt; my_records.id_arr
array([0, 1, 2, 3])

&gt;&gt;&gt; my_records.col_arr
array([0, 0, 1, 1])

&gt;&gt;&gt; my_records.idx_arr
array([0, 1, 0, 1])
</code></pre>
<p>Alternatively, we can override the <code>_field_config</code> class attribute.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @override_field_config
... class MyRecords(vbt.Records):
...     _field_config = dict(
...         dtype=my_dt,
...         settings=dict(
...             id=dict(name='my_id'),
...             idx=dict(name='my_idx'),
...             col=dict(name='my_col')
...         )
...     )
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Don't forget to decorate the class with <code>@override_field_config</code> to inherit configs from base classes.</p>
<p>You can stop inheritance by not decorating or passing <code>merge_configs=False</code> to the decorator.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;Base class for working with records.

vectorbt works with two different representations of data: matrices and records.

A matrix, in this context, is just an array of one-dimensional arrays, each corresponding
to a separate feature. The matrix itself holds only one kind of information (one attribute).
For example, one can create a matrix for entry signals, with columns being different strategy
configurations. But what if the matrix is huge and sparse? What if there is more
information we would like to represent by each element? Creating multiple matrices would be
a waste of memory.

Records make possible representing complex, sparse information in a dense format. They are just
an array of one-dimensional arrays of fixed schema. You can imagine records being a DataFrame,
where each row represents a record and each column represents a specific attribute.

```plaintext
               a     b
         0   1.0   5.0
attr1 =  1   2.0   NaN
         2   NaN   7.0
         3   4.0   8.0
               a     b
         0   9.0  13.0
attr2 =  1  10.0   NaN
         2   NaN  15.0
         3  12.0  16.0
            |
            v
      id  col  idx  attr1  attr2
0      0    0    0      1      9
1      1    0    1      2     10
2      2    0    3      4     12
3      3    1    0      5     13
4      4    1    1      7     15
5      5    1    3      8     16
```

Another advantage of records is that they are not constrained by size. Multiple records can map
to a single element in a matrix. For example, one can define multiple orders at the same time step,
which is impossible to represent in a matrix form without using complex data types.

Consider the following example:

```python-repl
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; example_dt = np.dtype([
...     (&#39;id&#39;, np.int_),
...     (&#39;col&#39;, np.int_),
...     (&#39;idx&#39;, np.int_),
...     (&#39;some_field&#39;, np.float_)
... ])
&gt;&gt;&gt; records_arr = np.array([
...     (0, 0, 0, 10.),
...     (1, 0, 1, 11.),
...     (2, 0, 2, 12.),
...     (3, 1, 0, 13.),
...     (4, 1, 1, 14.),
...     (5, 1, 2, 15.),
...     (6, 2, 0, 16.),
...     (7, 2, 1, 17.),
...     (8, 2, 2, 18.)
... ], dtype=example_dt)
&gt;&gt;&gt; wrapper = vbt.ArrayWrapper(index=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;],
...     columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], ndim=2, freq=&#39;1 day&#39;)
&gt;&gt;&gt; records = vbt.Records(wrapper, records_arr)
```

## Printing

There are two ways to print records:

* Raw dataframe that preserves field names and data types:

```python-repl
&gt;&gt;&gt; records.records
   id  col  idx  some_field
0   0    0    0        10.0
1   1    0    1        11.0
2   2    0    2        12.0
3   3    1    0        13.0
4   4    1    1        14.0
5   5    1    2        15.0
6   6    2    0        16.0
7   7    2    1        17.0
8   8    2    2        18.0
```

* Readable dataframe that takes into consideration `Records.field_config`:

```python-repl
&gt;&gt;&gt; records.records_readable
   Id Column Timestamp  some_field
0   0      a         x        10.0
1   1      a         y        11.0
2   2      a         z        12.0
3   3      b         x        13.0
4   4      b         y        14.0
5   5      b         z        15.0
6   6      c         x        16.0
7   7      c         y        17.0
8   8      c         z        18.0
```

## Mapping

`Records` are just [structured arrays](https://numpy.org/doc/stable/user/basics.rec.html) with a bunch
of methods and properties for processing them. Their main feature is to map the records array and
to reduce it by column (similar to the MapReduce paradigm). The main advantage is that it all happens
without conversion to the matrix form and wasting memory resources.

`Records` can be mapped to `vectorbt.records.mapped_array.MappedArray` in several ways:

* Use `Records.map_field` to map a record field:

```python-repl
&gt;&gt;&gt; records.map_field(&#39;some_field&#39;)
&lt;vectorbt.records.mapped_array.MappedArray at 0x7ff49bd31a58&gt;

&gt;&gt;&gt; records.map_field(&#39;some_field&#39;).values
array([10., 11., 12., 13., 14., 15., 16., 17., 18.])
```

* Use `Records.map` to map records using a custom function.

```python-repl
&gt;&gt;&gt; @njit
... def power_map_nb(record, pow):
...     return record.some_field ** pow

&gt;&gt;&gt; records.map(power_map_nb, 2)
&lt;vectorbt.records.mapped_array.MappedArray at 0x7ff49c990cf8&gt;

&gt;&gt;&gt; records.map(power_map_nb, 2).values
array([100., 121., 144., 169., 196., 225., 256., 289., 324.])
```

* Use `Records.map_array` to convert an array to `vectorbt.records.mapped_array.MappedArray`.

```python-repl
&gt;&gt;&gt; records.map_array(records_arr[&#39;some_field&#39;] ** 2)
&lt;vectorbt.records.mapped_array.MappedArray object at 0x7fe9bccf2978&gt;

&gt;&gt;&gt; records.map_array(records_arr[&#39;some_field&#39;] ** 2).values
array([100., 121., 144., 169., 196., 225., 256., 289., 324.])
```

* Use `Records.apply` to apply a function on each column/group:

```python-repl
&gt;&gt;&gt; @njit
... def cumsum_apply_nb(records):
...     return np.cumsum(records.some_field)

&gt;&gt;&gt; records.apply(cumsum_apply_nb)
&lt;vectorbt.records.mapped_array.MappedArray at 0x7ff49c990cf8&gt;

&gt;&gt;&gt; records.apply(cumsum_apply_nb).values
array([10., 21., 33., 13., 27., 42., 16., 33., 51.])

&gt;&gt;&gt; group_by = np.array([&#39;first&#39;, &#39;first&#39;, &#39;second&#39;])
&gt;&gt;&gt; records.apply(cumsum_apply_nb, group_by=group_by, apply_per_group=True).values
array([10., 21., 33., 46., 60., 75., 16., 33., 51.])
```

Notice how cumsum resets at each column in the first example and at each group in the second example.

## Filtering

Use `Records.apply_mask` to filter elements per column/group:

```python-repl
&gt;&gt;&gt; mask = [True, False, True, False, True, False, True, False, True]
&gt;&gt;&gt; filtered_records = records.apply_mask(mask)
&gt;&gt;&gt; filtered_records.count()
a    2
b    1
c    2
dtype: int64

&gt;&gt;&gt; filtered_records.values[&#39;id&#39;]
array([0, 2, 4, 6, 8])
```

## Grouping

One of the key features of `Records` is that you can perform reducing operations on a group
of columns as if they were a single column. Groups can be specified by `group_by`, which
can be anything from positions or names of column levels, to a NumPy array with actual groups.

There are multiple ways of define grouping:

* When creating `Records`, pass `group_by` to `vectorbt.base.array_wrapper.ArrayWrapper`:

```python-repl
&gt;&gt;&gt; group_by = np.array([&#39;first&#39;, &#39;first&#39;, &#39;second&#39;])
&gt;&gt;&gt; grouped_wrapper = wrapper.replace(group_by=group_by)
&gt;&gt;&gt; grouped_records = vbt.Records(grouped_wrapper, records_arr)

&gt;&gt;&gt; grouped_records.map_field(&#39;some_field&#39;).mean()
first     12.5
second    17.0
dtype: float64
```

* Regroup an existing `Records`:

```python-repl
&gt;&gt;&gt; records.regroup(group_by).map_field(&#39;some_field&#39;).mean()
first     12.5
second    17.0
dtype: float64
```

* Pass `group_by` directly to the mapping method:

```python-repl
&gt;&gt;&gt; records.map_field(&#39;some_field&#39;, group_by=group_by).mean()
first     12.5
second    17.0
dtype: float64
```

* Pass `group_by` directly to the reducing method:

```python-repl
&gt;&gt;&gt; records.map_field(&#39;some_field&#39;).mean(group_by=group_by)
a    11.0
b    14.0
c    17.0
dtype: float64
```

!!! note
    Grouping applies only to reducing operations, there is no change to the arrays.

## Indexing

Like any other class subclassing `vectorbt.base.array_wrapper.Wrapping`, we can do pandas indexing
on a `Records` instance, which forwards indexing operation to each object with columns:

```python-repl
&gt;&gt;&gt; records[&#39;a&#39;].records
   id  col  idx  some_field
0   0    0    0        10.0
1   1    0    1        11.0
2   2    0    2        12.0

&gt;&gt;&gt; grouped_records[&#39;first&#39;].records
   id  col  idx  some_field
0   0    0    0        10.0
1   1    0    1        11.0
2   2    0    2        12.0
3   3    1    0        13.0
4   4    1    1        14.0
5   5    1    2        15.0
```

!!! note
    Changing index (time axis) is not supported. The object should be treated as a Series
    rather than a DataFrame; for example, use `some_field.iloc[0]` instead of `some_field.iloc[:, 0]`.

    Indexing behavior depends solely upon `vectorbt.base.array_wrapper.ArrayWrapper`.
    For example, if `group_select` is enabled indexing will be performed on groups,
    otherwise on single columns.

## Caching

`Records` supports caching. If a method or a property requires heavy computation, it&#39;s wrapped
with `vectorbt.utils.decorators.cached_method` and `vectorbt.utils.decorators.cached_property`
respectively. Caching can be disabled globally via `caching` in `vectorbt._settings.settings`.

!!! note
    Because of caching, class is meant to be immutable and all properties are read-only.
    To change any attribute, use the `copy` method and pass the attribute as keyword argument.

## Saving and loading

Like any other class subclassing `vectorbt.utils.config.Pickleable`, we can save a `Records`
instance to the disk with `Records.save` and load it with `Records.load`.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats` and `Records.metrics`.

```python-repl
&gt;&gt;&gt; records.stats(column=&#39;a&#39;)
Start                          x
End                            z
Period           3 days 00:00:00
Total Records                  3
Name: a, dtype: object
```

`Records.stats` also supports (re-)grouping:

```python-repl
&gt;&gt;&gt; grouped_records.stats(column=&#39;first&#39;)
Start                          x
End                            z
Period           3 days 00:00:00
Total Records                  6
Name: first, dtype: object
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots` and `Records.subplots`.

This class is too generic to have any subplots, but feel free to add custom subplots to your subclass.

## Extending

`Records` class can be extended by subclassing.

In case some of our fields have the same meaning but different naming (such as the base field `idx`)
or other properties, we can override `field_config` using `vectorbt.records.decorators.override_field_config`.
It will look for configs of all base classes and merge our config on top of them. This preserves
any base class property that is not explicitly listed in our config.

```python-repl
&gt;&gt;&gt; from vectorbt.records.decorators import override_field_config

&gt;&gt;&gt; my_dt = np.dtype([
...     (&#39;my_id&#39;, np.int_),
...     (&#39;my_col&#39;, np.int_),
...     (&#39;my_idx&#39;, np.int_)
... ])

&gt;&gt;&gt; my_fields_config = dict(
...     dtype=my_dt,
...     settings=dict(
...         id=dict(name=&#39;my_id&#39;),
...         col=dict(name=&#39;my_col&#39;),
...         idx=dict(name=&#39;my_idx&#39;)
...     )
... )
&gt;&gt;&gt; @override_field_config(my_fields_config)
... class MyRecords(vbt.Records):
...     pass

&gt;&gt;&gt; records_arr = np.array([
...     (0, 0, 0),
...     (1, 0, 1),
...     (2, 1, 0),
...     (3, 1, 1)
... ], dtype=my_dt)
&gt;&gt;&gt; wrapper = vbt.ArrayWrapper(index=[&#39;x&#39;, &#39;y&#39;],
...     columns=[&#39;a&#39;, &#39;b&#39;], ndim=2, freq=&#39;1 day&#39;)
&gt;&gt;&gt; my_records = MyRecords(wrapper, records_arr)

&gt;&gt;&gt; my_records.id_arr
array([0, 1, 2, 3])

&gt;&gt;&gt; my_records.col_arr
array([0, 0, 1, 1])

&gt;&gt;&gt; my_records.idx_arr
array([0, 1, 0, 1])
```

Alternatively, we can override the `_field_config` class attribute.

```python-repl
&gt;&gt;&gt; @override_field_config
... class MyRecords(vbt.Records):
...     _field_config = dict(
...         dtype=my_dt,
...         settings=dict(
...             id=dict(name=&#39;my_id&#39;),
...             idx=dict(name=&#39;my_idx&#39;),
...             col=dict(name=&#39;my_col&#39;)
...         )
...     )
```

!!! note
    Don&#39;t forget to decorate the class with `@override_field_config` to inherit configs from base classes.

    You can stop inheritance by not decorating or passing `merge_configs=False` to the decorator.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
import inspect
import string

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.decorators import cached_method
from vectorbt.utils.config import merge_dicts, Config, Configured
from vectorbt.utils.attr import get_dict_attr
from vectorbt.base.reshape_fns import to_1d_array
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.records import nb
from vectorbt.records.mapped_array import MappedArray
from vectorbt.records.col_mapper import ColumnMapper

__pdoc__ = {}

RecordsT = tp.TypeVar(&#34;RecordsT&#34;, bound=&#34;Records&#34;)
IndexingMetaT = tp.Tuple[ArrayWrapper, tp.RecordArray, tp.MaybeArray, tp.Array1d]


class MetaFields(type):
    &#34;&#34;&#34;Meta class that exposes a read-only class property `MetaFields.field_config`.&#34;&#34;&#34;

    @property
    def field_config(cls) -&gt; Config:
        &#34;&#34;&#34;Field config.&#34;&#34;&#34;
        return cls._field_config


class RecordsWithFields(metaclass=MetaFields):
    &#34;&#34;&#34;Class exposes a read-only class property `RecordsWithFields.field_config`.&#34;&#34;&#34;

    @property
    def field_config(self) -&gt; Config:
        &#34;&#34;&#34;Field config of `${cls_name}`.

        ```json
        ${field_config}
        ```
        &#34;&#34;&#34;
        return self._field_config


class MetaRecords(type(StatsBuilderMixin), type(PlotsBuilderMixin), type(RecordsWithFields)):
    pass


class Records(Wrapping, StatsBuilderMixin, PlotsBuilderMixin, RecordsWithFields, metaclass=MetaRecords):
    &#34;&#34;&#34;Wraps the actual records array (such as trades) and exposes methods for mapping
    it to some array of values (such as PnL of each trade).

    Args:
        wrapper (ArrayWrapper): Array wrapper.

            See `vectorbt.base.array_wrapper.ArrayWrapper`.
        records_arr (array_like): A structured NumPy array of records.

            Must have the fields `id` (record index) and `col` (column index).
        col_mapper (ColumnMapper): Column mapper if already known.

            !!! note
                It depends on `records_arr`, so make sure to invalidate `col_mapper` upon creating
                a `Records` instance with a modified `records_arr`.

                `Records.replace` does it automatically.
        **kwargs: Custom keyword arguments passed to the config.

            Useful if any subclass wants to extend the config.
    &#34;&#34;&#34;

    _field_config: tp.ClassVar[Config] = Config(
        dict(
            dtype=None,
            settings=dict(
                id=dict(
                    name=&#39;id&#39;,
                    title=&#39;Id&#39;
                ),
                col=dict(
                    name=&#39;col&#39;,
                    title=&#39;Column&#39;,
                    mapping=&#39;columns&#39;
                ),
                idx=dict(
                    name=&#39;idx&#39;,
                    title=&#39;Timestamp&#39;,
                    mapping=&#39;index&#39;
                )
            )
        ),
        readonly=True,
        as_attrs=False
    )

    @property
    def field_config(self) -&gt; Config:
        &#34;&#34;&#34;Field config of `${cls_name}`.

        ```json
        ${field_config}
        ```
        &#34;&#34;&#34;
        return self._field_config

    def __init__(self,
                 wrapper: ArrayWrapper,
                 records_arr: tp.RecordArray,
                 col_mapper: tp.Optional[ColumnMapper] = None,
                 **kwargs) -&gt; None:
        Wrapping.__init__(
            self,
            wrapper,
            records_arr=records_arr,
            col_mapper=col_mapper,
            **kwargs
        )
        StatsBuilderMixin.__init__(self)

        # Check fields
        records_arr = np.asarray(records_arr)
        checks.assert_not_none(records_arr.dtype.fields)
        field_names = {
            dct.get(&#39;name&#39;, field_name)
            for field_name, dct in self.field_config.get(&#39;settings&#39;, {}).items()
        }
        dtype = self.field_config.get(&#39;dtype&#39;, None)
        if dtype is not None:
            for field in dtype.names:
                if field not in records_arr.dtype.names:
                    if field not in field_names:
                        raise TypeError(f&#34;Field &#39;{field}&#39; from {dtype} cannot be found in records or config&#34;)

        self._records_arr = records_arr
        if col_mapper is None:
            col_mapper = ColumnMapper(wrapper, self.col_arr)
        self._col_mapper = col_mapper

    def replace(self: RecordsT, **kwargs) -&gt; RecordsT:
        &#34;&#34;&#34;See `vectorbt.utils.config.Configured.replace`.

        Also, makes sure that `Records.col_mapper` is not passed to the new instance.&#34;&#34;&#34;
        if self.config.get(&#39;col_mapper&#39;, None) is not None:
            if &#39;wrapper&#39; in kwargs:
                if self.wrapper is not kwargs.get(&#39;wrapper&#39;):
                    kwargs[&#39;col_mapper&#39;] = None
            if &#39;records_arr&#39; in kwargs:
                if self.records_arr is not kwargs.get(&#39;records_arr&#39;):
                    kwargs[&#39;col_mapper&#39;] = None
        return Configured.replace(self, **kwargs)

    def get_by_col_idxs(self, col_idxs: tp.Array1d) -&gt; tp.RecordArray:
        &#34;&#34;&#34;Get records corresponding to column indices.

        Returns new records array.&#34;&#34;&#34;
        if self.col_mapper.is_sorted():
            new_records_arr = nb.record_col_range_select_nb(
                self.values, self.col_mapper.col_range, to_1d_array(col_idxs))  # faster
        else:
            new_records_arr = nb.record_col_map_select_nb(
                self.values, self.col_mapper.col_map, to_1d_array(col_idxs))
        return new_records_arr

    def indexing_func_meta(self, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; IndexingMetaT:
        &#34;&#34;&#34;Perform indexing on `Records` and return metadata.&#34;&#34;&#34;
        new_wrapper, _, group_idxs, col_idxs = \
            self.wrapper.indexing_func_meta(pd_indexing_func, column_only_select=True, **kwargs)
        new_records_arr = self.get_by_col_idxs(col_idxs)
        return new_wrapper, new_records_arr, group_idxs, col_idxs

    def indexing_func(self: RecordsT, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; RecordsT:
        &#34;&#34;&#34;Perform indexing on `Records`.&#34;&#34;&#34;
        new_wrapper, new_records_arr, _, _ = self.indexing_func_meta(pd_indexing_func, **kwargs)
        return self.replace(
            wrapper=new_wrapper,
            records_arr=new_records_arr
        )

    @property
    def records_arr(self) -&gt; tp.RecordArray:
        &#34;&#34;&#34;Records array.&#34;&#34;&#34;
        return self._records_arr

    @property
    def values(self) -&gt; tp.RecordArray:
        &#34;&#34;&#34;Records array.&#34;&#34;&#34;
        return self.records_arr

    def __len__(self) -&gt; int:
        return len(self.values)

    @property
    def records(self) -&gt; tp.Frame:
        &#34;&#34;&#34;Records.&#34;&#34;&#34;
        return pd.DataFrame.from_records(self.values)

    @property
    def recarray(self) -&gt; tp.RecArray:
        return self.values.view(np.recarray)

    @property
    def col_mapper(self) -&gt; ColumnMapper:
        &#34;&#34;&#34;Column mapper.

        See `vectorbt.records.col_mapper.ColumnMapper`.&#34;&#34;&#34;
        return self._col_mapper

    @property
    def records_readable(self) -&gt; tp.Frame:
        &#34;&#34;&#34;Records in readable format.&#34;&#34;&#34;
        df = self.records.copy()
        field_settings = self.field_config.get(&#39;settings&#39;, {})
        for col_name in df.columns:
            if col_name in field_settings:
                dct = field_settings[col_name]
                if dct.get(&#39;ignore&#39;, False):
                    df = df.drop(columns=col_name)
                    continue
                field_name = dct.get(&#39;name&#39;, col_name)
                if &#39;title&#39; in dct:
                    title = dct[&#39;title&#39;]
                    new_columns = dict()
                    new_columns[field_name] = title
                    df.rename(columns=new_columns, inplace=True)
                else:
                    title = field_name
                if &#39;mapping&#39; in dct:
                    if isinstance(dct[&#39;mapping&#39;], str) and dct[&#39;mapping&#39;] == &#39;index&#39;:
                        df[title] = self.get_map_field_to_index(col_name)
                    else:
                        df[title] = self.get_apply_mapping_arr(col_name)
        return df

    def get_field_setting(self, field: str, setting: str, default: tp.Any = None) -&gt; tp.Any:
        &#34;&#34;&#34;Resolve any setting of the field. Uses `Records.field_config`.&#34;&#34;&#34;
        return self.field_config.get(&#39;settings&#39;, {}).get(field, {}).get(setting, default)

    def get_field_name(self, field: str) -&gt; str:
        &#34;&#34;&#34;Resolve the name of the field. Uses `Records.field_config`..&#34;&#34;&#34;
        return self.get_field_setting(field, &#39;name&#39;, field)

    def get_field_title(self, field: str) -&gt; str:
        &#34;&#34;&#34;Resolve the title of the field. Uses `Records.field_config`.&#34;&#34;&#34;
        return self.get_field_setting(field, &#39;title&#39;, field)

    def get_field_mapping(self, field: str) -&gt; tp.Optional[tp.MappingLike]:
        &#34;&#34;&#34;Resolve the mapping of the field. Uses `Records.field_config`.&#34;&#34;&#34;
        return self.get_field_setting(field, &#39;mapping&#39;, None)

    def get_field_arr(self, field: str) -&gt; tp.Array1d:
        &#34;&#34;&#34;Resolve the array of the field. Uses `Records.field_config`.&#34;&#34;&#34;
        return self.values[self.get_field_name(field)]

    def get_map_field(self, field: str, **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Resolve the mapped array of the field. Uses `Records.field_config`.&#34;&#34;&#34;
        return self.map_field(self.get_field_name(field), mapping=self.get_field_mapping(field), **kwargs)

    def get_apply_mapping_arr(self, field: str, **kwargs) -&gt; tp.Array1d:
        &#34;&#34;&#34;Resolve the mapped array on the field, with mapping applied. Uses `Records.field_config`.&#34;&#34;&#34;
        return self.get_map_field(field, **kwargs).apply_mapping().values

    def get_map_field_to_index(self, field: str, **kwargs) -&gt; tp.Index:
        &#34;&#34;&#34;Resolve the mapped array on the field, with index applied. Uses `Records.field_config`.&#34;&#34;&#34;
        return self.get_map_field(field, **kwargs).to_index()

    @property
    def id_arr(self) -&gt; tp.Array1d:
        &#34;&#34;&#34;Get id array.&#34;&#34;&#34;
        return self.values[self.get_field_name(&#39;id&#39;)]

    @property
    def col_arr(self) -&gt; tp.Array1d:
        &#34;&#34;&#34;Get column array.&#34;&#34;&#34;
        return self.values[self.get_field_name(&#39;col&#39;)]

    @property
    def idx_arr(self) -&gt; tp.Optional[tp.Array1d]:
        &#34;&#34;&#34;Get index array.&#34;&#34;&#34;
        idx_field_name = self.get_field_name(&#39;idx&#39;)
        if idx_field_name is None:
            return None
        return self.values[idx_field_name]

    @cached_method
    def is_sorted(self, incl_id: bool = False) -&gt; bool:
        &#34;&#34;&#34;Check whether records are sorted.&#34;&#34;&#34;
        if incl_id:
            return nb.is_col_idx_sorted_nb(self.col_arr, self.id_arr)
        return nb.is_col_sorted_nb(self.col_arr)

    def sort(self: RecordsT, incl_id: bool = False, group_by: tp.GroupByLike = None, **kwargs) -&gt; RecordsT:
        &#34;&#34;&#34;Sort records by columns (primary) and ids (secondary, optional).

        !!! note
            Sorting is expensive. A better approach is to append records already in the correct order.&#34;&#34;&#34;
        if self.is_sorted(incl_id=incl_id):
            return self.replace(**kwargs).regroup(group_by)
        if incl_id:
            ind = np.lexsort((self.id_arr, self.col_arr))  # expensive!
        else:
            ind = np.argsort(self.col_arr)
        return self.replace(records_arr=self.values[ind], **kwargs).regroup(group_by)

    def apply_mask(self: RecordsT, mask: tp.Array1d, group_by: tp.GroupByLike = None, **kwargs) -&gt; RecordsT:
        &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
        mask_indices = np.flatnonzero(mask)
        return self.replace(
            records_arr=np.take(self.values, mask_indices),
            **kwargs
        ).regroup(group_by)

    def map_array(self,
                  a: tp.ArrayLike,
                  idx_arr: tp.Optional[tp.ArrayLike] = None,
                  mapping: tp.Optional[tp.MappingLike] = None,
                  group_by: tp.GroupByLike = None,
                  **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Convert array to mapped array.

         The length of the array should match that of the records.&#34;&#34;&#34;
        if not isinstance(a, np.ndarray):
            a = np.asarray(a)
        checks.assert_shape_equal(a, self.values)
        if idx_arr is None:
            idx_arr = self.idx_arr
        return MappedArray(
            self.wrapper,
            a,
            self.col_arr,
            id_arr=self.id_arr,
            idx_arr=idx_arr,
            mapping=mapping,
            col_mapper=self.col_mapper,
            **kwargs
        ).regroup(group_by)

    def map_field(self, field: str, **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Convert field to mapped array.

        `**kwargs` are passed to `Records.map_array`.&#34;&#34;&#34;
        mapped_arr = self.values[field]
        return self.map_array(mapped_arr, **kwargs)

    def map(self,
            map_func_nb: tp.RecordMapFunc, *args,
            dtype: tp.Optional[tp.DTypeLike] = None,
            **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Map each record to a scalar value. Returns mapped array.

        See `vectorbt.records.nb.map_records_nb`.

        `**kwargs` are passed to `Records.map_array`.&#34;&#34;&#34;
        checks.assert_numba_func(map_func_nb)
        mapped_arr = nb.map_records_nb(self.values, map_func_nb, *args)
        mapped_arr = np.asarray(mapped_arr, dtype=dtype)
        return self.map_array(mapped_arr, **kwargs)

    def apply(self,
              apply_func_nb: tp.RecordApplyFunc, *args,
              group_by: tp.GroupByLike = None,
              apply_per_group: bool = False,
              dtype: tp.Optional[tp.DTypeLike] = None,
              **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Apply function on records per column/group. Returns mapped array.

        Applies per group if `apply_per_group` is True.

        See `vectorbt.records.nb.apply_on_records_nb`.

        `**kwargs` are passed to `Records.map_array`.&#34;&#34;&#34;
        checks.assert_numba_func(apply_func_nb)
        if apply_per_group:
            col_map = self.col_mapper.get_col_map(group_by=group_by)
        else:
            col_map = self.col_mapper.get_col_map(group_by=False)
        mapped_arr = nb.apply_on_records_nb(self.values, col_map, apply_func_nb, *args)
        mapped_arr = np.asarray(mapped_arr, dtype=dtype)
        return self.map_array(mapped_arr, group_by=group_by, **kwargs)

    @cached_method
    def count(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Return count by column.&#34;&#34;&#34;
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;count&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(
            self.col_mapper.get_col_map(group_by=group_by)[1],
            group_by=group_by, **wrap_kwargs)

    # ############# Stats ############# #

    @property
    def stats_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `Records.stats`.

        Merges `vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults` and
        `records.stats` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        records_stats_cfg = settings[&#39;records&#39;][&#39;stats&#39;]

        return merge_dicts(
            StatsBuilderMixin.stats_defaults.__get__(self),
            records_stats_cfg
        )

    _metrics: tp.ClassVar[Config] = Config(
        dict(
            start=dict(
                title=&#39;Start&#39;,
                calc_func=lambda self: self.wrapper.index[0],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            end=dict(
                title=&#39;End&#39;,
                calc_func=lambda self: self.wrapper.index[-1],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            period=dict(
                title=&#39;Period&#39;,
                calc_func=lambda self: len(self.wrapper.index),
                apply_to_timedelta=True,
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            count=dict(
                title=&#39;Count&#39;,
                calc_func=&#39;count&#39;,
                tags=&#39;records&#39;
            )
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def metrics(self) -&gt; Config:
        return self._metrics

    # ############# Plotting ############# #

    @property
    def plots_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `Records.plots`.

        Merges `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults` and
        `records.plots` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        records_plots_cfg = settings[&#39;records&#39;][&#39;plots&#39;]

        return merge_dicts(
            PlotsBuilderMixin.plots_defaults.__get__(self),
            records_plots_cfg
        )

    @property
    def subplots(self) -&gt; Config:
        return self._subplots

    # ############# Docs ############# #

    @classmethod
    def build_field_config_doc(cls, source_cls: tp.Optional[type] = None) -&gt; str:
        &#34;&#34;&#34;Build field config documentation.&#34;&#34;&#34;
        if source_cls is None:
            source_cls = Records
        return string.Template(
            inspect.cleandoc(get_dict_attr(source_cls, &#39;field_config&#39;).__doc__)
        ).substitute(
            {&#39;field_config&#39;: cls.field_config.to_doc(), &#39;cls_name&#39;: cls.__name__}
        )

    @classmethod
    def override_field_config_doc(cls, __pdoc__: dict, source_cls: tp.Optional[type] = None) -&gt; None:
        &#34;&#34;&#34;Call this method on each subclass that overrides `field_config`.&#34;&#34;&#34;
        __pdoc__[cls.__name__ + &#39;.field_config&#39;] = cls.build_field_config_doc(source_cls=source_cls)


Records.override_field_config_doc(__pdoc__)
Records.override_metrics_doc(__pdoc__)
Records.override_subplots_doc(__pdoc__)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.records.base.MetaFields"><code class="flex name class">
<span>class <span class="ident parent-name">MetaFields</span></span>
(<span class="params">*args, **kwargs</span>)
</code></dt>
<dd>
<div class="desc"><p>Meta class that exposes a read-only class property <code><a title="vectorbt.records.base.MetaFields.field_config" href="#vectorbt.records.base.MetaFields.field_config">MetaFields.field_config</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaFields(type):
    &#34;&#34;&#34;Meta class that exposes a read-only class property `MetaFields.field_config`.&#34;&#34;&#34;

    @property
    def field_config(cls) -&gt; Config:
        &#34;&#34;&#34;Field config.&#34;&#34;&#34;
        return cls._field_config</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.records.base.MetaRecords" href="#vectorbt.records.base.MetaRecords">MetaRecords</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.records.base.MetaFields.field_config"><code class="name">var <span class="ident child-name">field_config</span></code></dt>
<dd>
<div class="desc"><p>Field config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def field_config(cls) -&gt; Config:
    &#34;&#34;&#34;Field config.&#34;&#34;&#34;
    return cls._field_config</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.records.base.MetaRecords"><code class="flex name class">
<span>class <span class="ident parent-name">MetaRecords</span></span>
(<span class="params">*args, **kwargs</span>)
</code></dt>
<dd>
<div class="desc"><p>Meta class that exposes a read-only class property <code>StatsBuilderMixin.metrics</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaRecords(type(StatsBuilderMixin), type(PlotsBuilderMixin), type(RecordsWithFields)):
    pass</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.generic.stats_builder.MetaStatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.MetaStatsBuilderMixin">MetaStatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.MetaPlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.MetaPlotsBuilderMixin">MetaPlotsBuilderMixin</a></li>
<li><a title="vectorbt.records.base.MetaFields" href="#vectorbt.records.base.MetaFields">MetaFields</a></li>
<li>builtins.type</li>
</ul>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.generic.stats_builder.MetaStatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.MetaStatsBuilderMixin">MetaStatsBuilderMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.generic.stats_builder.MetaStatsBuilderMixin.metrics" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.MetaStatsBuilderMixin.metrics">metrics</a></code></li>
</ul>
</li>
<li><code><b><a title="vectorbt.generic.plots_builder.MetaPlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.MetaPlotsBuilderMixin">MetaPlotsBuilderMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.generic.plots_builder.MetaPlotsBuilderMixin.subplots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.MetaPlotsBuilderMixin.subplots">subplots</a></code></li>
</ul>
</li>
<li><code><b><a title="vectorbt.records.base.MetaFields" href="#vectorbt.records.base.MetaFields">MetaFields</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.records.base.MetaFields.field_config" href="#vectorbt.records.base.MetaFields.field_config">field_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.records.base.Records"><code class="flex name class">
<span>class <span class="ident parent-name">Records</span></span>
(<span class="params">wrapper, records_arr, col_mapper=None, **kwargs</span>)
</code></dt>
<dd>
<div class="desc"><p>Wraps the actual records array (such as trades) and exposes methods for mapping
it to some array of values (such as PnL of each trade).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrapper</code></strong> :&ensp;<code>ArrayWrapper</code></dt>
<dd>
<p>Array wrapper.</p>
<p>See <code><a title="vectorbt.base.array_wrapper.ArrayWrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper">ArrayWrapper</a></code>.</p>
</dd>
<dt><strong><code>records_arr</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>A structured NumPy array of records.</p>
<p>Must have the fields <code>id</code> (record index) and <code>col</code> (column index).</p>
</dd>
<dt><strong><code>col_mapper</code></strong> :&ensp;<code>ColumnMapper</code></dt>
<dd>
<p>Column mapper if already known.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It depends on <code>records_arr</code>, so make sure to invalidate <code>col_mapper</code> upon creating
a <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> instance with a modified <code>records_arr</code>.</p>
<p><code><a title="vectorbt.records.base.Records.replace" href="#vectorbt.records.base.Records.replace">Records.replace()</a></code> does it automatically.</p>
</div>
</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>
<p>Custom keyword arguments passed to the config.</p>
<p>Useful if any subclass wants to extend the config.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Records(Wrapping, StatsBuilderMixin, PlotsBuilderMixin, RecordsWithFields, metaclass=MetaRecords):
    &#34;&#34;&#34;Wraps the actual records array (such as trades) and exposes methods for mapping
    it to some array of values (such as PnL of each trade).

    Args:
        wrapper (ArrayWrapper): Array wrapper.

            See `vectorbt.base.array_wrapper.ArrayWrapper`.
        records_arr (array_like): A structured NumPy array of records.

            Must have the fields `id` (record index) and `col` (column index).
        col_mapper (ColumnMapper): Column mapper if already known.

            !!! note
                It depends on `records_arr`, so make sure to invalidate `col_mapper` upon creating
                a `Records` instance with a modified `records_arr`.

                `Records.replace` does it automatically.
        **kwargs: Custom keyword arguments passed to the config.

            Useful if any subclass wants to extend the config.
    &#34;&#34;&#34;

    _field_config: tp.ClassVar[Config] = Config(
        dict(
            dtype=None,
            settings=dict(
                id=dict(
                    name=&#39;id&#39;,
                    title=&#39;Id&#39;
                ),
                col=dict(
                    name=&#39;col&#39;,
                    title=&#39;Column&#39;,
                    mapping=&#39;columns&#39;
                ),
                idx=dict(
                    name=&#39;idx&#39;,
                    title=&#39;Timestamp&#39;,
                    mapping=&#39;index&#39;
                )
            )
        ),
        readonly=True,
        as_attrs=False
    )

    @property
    def field_config(self) -&gt; Config:
        &#34;&#34;&#34;Field config of `${cls_name}`.

        ```json
        ${field_config}
        ```
        &#34;&#34;&#34;
        return self._field_config

    def __init__(self,
                 wrapper: ArrayWrapper,
                 records_arr: tp.RecordArray,
                 col_mapper: tp.Optional[ColumnMapper] = None,
                 **kwargs) -&gt; None:
        Wrapping.__init__(
            self,
            wrapper,
            records_arr=records_arr,
            col_mapper=col_mapper,
            **kwargs
        )
        StatsBuilderMixin.__init__(self)

        # Check fields
        records_arr = np.asarray(records_arr)
        checks.assert_not_none(records_arr.dtype.fields)
        field_names = {
            dct.get(&#39;name&#39;, field_name)
            for field_name, dct in self.field_config.get(&#39;settings&#39;, {}).items()
        }
        dtype = self.field_config.get(&#39;dtype&#39;, None)
        if dtype is not None:
            for field in dtype.names:
                if field not in records_arr.dtype.names:
                    if field not in field_names:
                        raise TypeError(f&#34;Field &#39;{field}&#39; from {dtype} cannot be found in records or config&#34;)

        self._records_arr = records_arr
        if col_mapper is None:
            col_mapper = ColumnMapper(wrapper, self.col_arr)
        self._col_mapper = col_mapper

    def replace(self: RecordsT, **kwargs) -&gt; RecordsT:
        &#34;&#34;&#34;See `vectorbt.utils.config.Configured.replace`.

        Also, makes sure that `Records.col_mapper` is not passed to the new instance.&#34;&#34;&#34;
        if self.config.get(&#39;col_mapper&#39;, None) is not None:
            if &#39;wrapper&#39; in kwargs:
                if self.wrapper is not kwargs.get(&#39;wrapper&#39;):
                    kwargs[&#39;col_mapper&#39;] = None
            if &#39;records_arr&#39; in kwargs:
                if self.records_arr is not kwargs.get(&#39;records_arr&#39;):
                    kwargs[&#39;col_mapper&#39;] = None
        return Configured.replace(self, **kwargs)

    def get_by_col_idxs(self, col_idxs: tp.Array1d) -&gt; tp.RecordArray:
        &#34;&#34;&#34;Get records corresponding to column indices.

        Returns new records array.&#34;&#34;&#34;
        if self.col_mapper.is_sorted():
            new_records_arr = nb.record_col_range_select_nb(
                self.values, self.col_mapper.col_range, to_1d_array(col_idxs))  # faster
        else:
            new_records_arr = nb.record_col_map_select_nb(
                self.values, self.col_mapper.col_map, to_1d_array(col_idxs))
        return new_records_arr

    def indexing_func_meta(self, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; IndexingMetaT:
        &#34;&#34;&#34;Perform indexing on `Records` and return metadata.&#34;&#34;&#34;
        new_wrapper, _, group_idxs, col_idxs = \
            self.wrapper.indexing_func_meta(pd_indexing_func, column_only_select=True, **kwargs)
        new_records_arr = self.get_by_col_idxs(col_idxs)
        return new_wrapper, new_records_arr, group_idxs, col_idxs

    def indexing_func(self: RecordsT, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; RecordsT:
        &#34;&#34;&#34;Perform indexing on `Records`.&#34;&#34;&#34;
        new_wrapper, new_records_arr, _, _ = self.indexing_func_meta(pd_indexing_func, **kwargs)
        return self.replace(
            wrapper=new_wrapper,
            records_arr=new_records_arr
        )

    @property
    def records_arr(self) -&gt; tp.RecordArray:
        &#34;&#34;&#34;Records array.&#34;&#34;&#34;
        return self._records_arr

    @property
    def values(self) -&gt; tp.RecordArray:
        &#34;&#34;&#34;Records array.&#34;&#34;&#34;
        return self.records_arr

    def __len__(self) -&gt; int:
        return len(self.values)

    @property
    def records(self) -&gt; tp.Frame:
        &#34;&#34;&#34;Records.&#34;&#34;&#34;
        return pd.DataFrame.from_records(self.values)

    @property
    def recarray(self) -&gt; tp.RecArray:
        return self.values.view(np.recarray)

    @property
    def col_mapper(self) -&gt; ColumnMapper:
        &#34;&#34;&#34;Column mapper.

        See `vectorbt.records.col_mapper.ColumnMapper`.&#34;&#34;&#34;
        return self._col_mapper

    @property
    def records_readable(self) -&gt; tp.Frame:
        &#34;&#34;&#34;Records in readable format.&#34;&#34;&#34;
        df = self.records.copy()
        field_settings = self.field_config.get(&#39;settings&#39;, {})
        for col_name in df.columns:
            if col_name in field_settings:
                dct = field_settings[col_name]
                if dct.get(&#39;ignore&#39;, False):
                    df = df.drop(columns=col_name)
                    continue
                field_name = dct.get(&#39;name&#39;, col_name)
                if &#39;title&#39; in dct:
                    title = dct[&#39;title&#39;]
                    new_columns = dict()
                    new_columns[field_name] = title
                    df.rename(columns=new_columns, inplace=True)
                else:
                    title = field_name
                if &#39;mapping&#39; in dct:
                    if isinstance(dct[&#39;mapping&#39;], str) and dct[&#39;mapping&#39;] == &#39;index&#39;:
                        df[title] = self.get_map_field_to_index(col_name)
                    else:
                        df[title] = self.get_apply_mapping_arr(col_name)
        return df

    def get_field_setting(self, field: str, setting: str, default: tp.Any = None) -&gt; tp.Any:
        &#34;&#34;&#34;Resolve any setting of the field. Uses `Records.field_config`.&#34;&#34;&#34;
        return self.field_config.get(&#39;settings&#39;, {}).get(field, {}).get(setting, default)

    def get_field_name(self, field: str) -&gt; str:
        &#34;&#34;&#34;Resolve the name of the field. Uses `Records.field_config`..&#34;&#34;&#34;
        return self.get_field_setting(field, &#39;name&#39;, field)

    def get_field_title(self, field: str) -&gt; str:
        &#34;&#34;&#34;Resolve the title of the field. Uses `Records.field_config`.&#34;&#34;&#34;
        return self.get_field_setting(field, &#39;title&#39;, field)

    def get_field_mapping(self, field: str) -&gt; tp.Optional[tp.MappingLike]:
        &#34;&#34;&#34;Resolve the mapping of the field. Uses `Records.field_config`.&#34;&#34;&#34;
        return self.get_field_setting(field, &#39;mapping&#39;, None)

    def get_field_arr(self, field: str) -&gt; tp.Array1d:
        &#34;&#34;&#34;Resolve the array of the field. Uses `Records.field_config`.&#34;&#34;&#34;
        return self.values[self.get_field_name(field)]

    def get_map_field(self, field: str, **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Resolve the mapped array of the field. Uses `Records.field_config`.&#34;&#34;&#34;
        return self.map_field(self.get_field_name(field), mapping=self.get_field_mapping(field), **kwargs)

    def get_apply_mapping_arr(self, field: str, **kwargs) -&gt; tp.Array1d:
        &#34;&#34;&#34;Resolve the mapped array on the field, with mapping applied. Uses `Records.field_config`.&#34;&#34;&#34;
        return self.get_map_field(field, **kwargs).apply_mapping().values

    def get_map_field_to_index(self, field: str, **kwargs) -&gt; tp.Index:
        &#34;&#34;&#34;Resolve the mapped array on the field, with index applied. Uses `Records.field_config`.&#34;&#34;&#34;
        return self.get_map_field(field, **kwargs).to_index()

    @property
    def id_arr(self) -&gt; tp.Array1d:
        &#34;&#34;&#34;Get id array.&#34;&#34;&#34;
        return self.values[self.get_field_name(&#39;id&#39;)]

    @property
    def col_arr(self) -&gt; tp.Array1d:
        &#34;&#34;&#34;Get column array.&#34;&#34;&#34;
        return self.values[self.get_field_name(&#39;col&#39;)]

    @property
    def idx_arr(self) -&gt; tp.Optional[tp.Array1d]:
        &#34;&#34;&#34;Get index array.&#34;&#34;&#34;
        idx_field_name = self.get_field_name(&#39;idx&#39;)
        if idx_field_name is None:
            return None
        return self.values[idx_field_name]

    @cached_method
    def is_sorted(self, incl_id: bool = False) -&gt; bool:
        &#34;&#34;&#34;Check whether records are sorted.&#34;&#34;&#34;
        if incl_id:
            return nb.is_col_idx_sorted_nb(self.col_arr, self.id_arr)
        return nb.is_col_sorted_nb(self.col_arr)

    def sort(self: RecordsT, incl_id: bool = False, group_by: tp.GroupByLike = None, **kwargs) -&gt; RecordsT:
        &#34;&#34;&#34;Sort records by columns (primary) and ids (secondary, optional).

        !!! note
            Sorting is expensive. A better approach is to append records already in the correct order.&#34;&#34;&#34;
        if self.is_sorted(incl_id=incl_id):
            return self.replace(**kwargs).regroup(group_by)
        if incl_id:
            ind = np.lexsort((self.id_arr, self.col_arr))  # expensive!
        else:
            ind = np.argsort(self.col_arr)
        return self.replace(records_arr=self.values[ind], **kwargs).regroup(group_by)

    def apply_mask(self: RecordsT, mask: tp.Array1d, group_by: tp.GroupByLike = None, **kwargs) -&gt; RecordsT:
        &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
        mask_indices = np.flatnonzero(mask)
        return self.replace(
            records_arr=np.take(self.values, mask_indices),
            **kwargs
        ).regroup(group_by)

    def map_array(self,
                  a: tp.ArrayLike,
                  idx_arr: tp.Optional[tp.ArrayLike] = None,
                  mapping: tp.Optional[tp.MappingLike] = None,
                  group_by: tp.GroupByLike = None,
                  **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Convert array to mapped array.

         The length of the array should match that of the records.&#34;&#34;&#34;
        if not isinstance(a, np.ndarray):
            a = np.asarray(a)
        checks.assert_shape_equal(a, self.values)
        if idx_arr is None:
            idx_arr = self.idx_arr
        return MappedArray(
            self.wrapper,
            a,
            self.col_arr,
            id_arr=self.id_arr,
            idx_arr=idx_arr,
            mapping=mapping,
            col_mapper=self.col_mapper,
            **kwargs
        ).regroup(group_by)

    def map_field(self, field: str, **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Convert field to mapped array.

        `**kwargs` are passed to `Records.map_array`.&#34;&#34;&#34;
        mapped_arr = self.values[field]
        return self.map_array(mapped_arr, **kwargs)

    def map(self,
            map_func_nb: tp.RecordMapFunc, *args,
            dtype: tp.Optional[tp.DTypeLike] = None,
            **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Map each record to a scalar value. Returns mapped array.

        See `vectorbt.records.nb.map_records_nb`.

        `**kwargs` are passed to `Records.map_array`.&#34;&#34;&#34;
        checks.assert_numba_func(map_func_nb)
        mapped_arr = nb.map_records_nb(self.values, map_func_nb, *args)
        mapped_arr = np.asarray(mapped_arr, dtype=dtype)
        return self.map_array(mapped_arr, **kwargs)

    def apply(self,
              apply_func_nb: tp.RecordApplyFunc, *args,
              group_by: tp.GroupByLike = None,
              apply_per_group: bool = False,
              dtype: tp.Optional[tp.DTypeLike] = None,
              **kwargs) -&gt; MappedArray:
        &#34;&#34;&#34;Apply function on records per column/group. Returns mapped array.

        Applies per group if `apply_per_group` is True.

        See `vectorbt.records.nb.apply_on_records_nb`.

        `**kwargs` are passed to `Records.map_array`.&#34;&#34;&#34;
        checks.assert_numba_func(apply_func_nb)
        if apply_per_group:
            col_map = self.col_mapper.get_col_map(group_by=group_by)
        else:
            col_map = self.col_mapper.get_col_map(group_by=False)
        mapped_arr = nb.apply_on_records_nb(self.values, col_map, apply_func_nb, *args)
        mapped_arr = np.asarray(mapped_arr, dtype=dtype)
        return self.map_array(mapped_arr, group_by=group_by, **kwargs)

    @cached_method
    def count(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Return count by column.&#34;&#34;&#34;
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;count&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(
            self.col_mapper.get_col_map(group_by=group_by)[1],
            group_by=group_by, **wrap_kwargs)

    # ############# Stats ############# #

    @property
    def stats_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `Records.stats`.

        Merges `vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults` and
        `records.stats` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        records_stats_cfg = settings[&#39;records&#39;][&#39;stats&#39;]

        return merge_dicts(
            StatsBuilderMixin.stats_defaults.__get__(self),
            records_stats_cfg
        )

    _metrics: tp.ClassVar[Config] = Config(
        dict(
            start=dict(
                title=&#39;Start&#39;,
                calc_func=lambda self: self.wrapper.index[0],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            end=dict(
                title=&#39;End&#39;,
                calc_func=lambda self: self.wrapper.index[-1],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            period=dict(
                title=&#39;Period&#39;,
                calc_func=lambda self: len(self.wrapper.index),
                apply_to_timedelta=True,
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            count=dict(
                title=&#39;Count&#39;,
                calc_func=&#39;count&#39;,
                tags=&#39;records&#39;
            )
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def metrics(self) -&gt; Config:
        return self._metrics

    # ############# Plotting ############# #

    @property
    def plots_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `Records.plots`.

        Merges `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults` and
        `records.plots` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        records_plots_cfg = settings[&#39;records&#39;][&#39;plots&#39;]

        return merge_dicts(
            PlotsBuilderMixin.plots_defaults.__get__(self),
            records_plots_cfg
        )

    @property
    def subplots(self) -&gt; Config:
        return self._subplots

    # ############# Docs ############# #

    @classmethod
    def build_field_config_doc(cls, source_cls: tp.Optional[type] = None) -&gt; str:
        &#34;&#34;&#34;Build field config documentation.&#34;&#34;&#34;
        if source_cls is None:
            source_cls = Records
        return string.Template(
            inspect.cleandoc(get_dict_attr(source_cls, &#39;field_config&#39;).__doc__)
        ).substitute(
            {&#39;field_config&#39;: cls.field_config.to_doc(), &#39;cls_name&#39;: cls.__name__}
        )

    @classmethod
    def override_field_config_doc(cls, __pdoc__: dict, source_cls: tp.Optional[type] = None) -&gt; None:
        &#34;&#34;&#34;Call this method on each subclass that overrides `field_config`.&#34;&#34;&#34;
        __pdoc__[cls.__name__ + &#39;.field_config&#39;] = cls.build_field_config_doc(source_cls=source_cls)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr.AttrResolver" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
<li><a title="vectorbt.records.base.RecordsWithFields" href="#vectorbt.records.base.RecordsWithFields">RecordsWithFields</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.generic.ranges.Ranges" href="../generic/ranges.html#vectorbt.generic.ranges.Ranges">Ranges</a></li>
<li><a title="vectorbt.portfolio.logs.Logs" href="../portfolio/logs.html#vectorbt.portfolio.logs.Logs">Logs</a></li>
<li><a title="vectorbt.portfolio.orders.Orders" href="../portfolio/orders.html#vectorbt.portfolio.orders.Orders">Orders</a></li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.records.base.Records.field_config"><code class="name">var <span class="ident child-name">field_config</span></code></dt>
<dd>
<div class="desc"><p>Field config of <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code>.</p>
<pre><code class="language-json">Config({
    &quot;dtype&quot;: null,
    &quot;settings&quot;: {
        &quot;id&quot;: {
            &quot;name&quot;: &quot;id&quot;,
            &quot;title&quot;: &quot;Id&quot;
        },
        &quot;col&quot;: {
            &quot;name&quot;: &quot;col&quot;,
            &quot;title&quot;: &quot;Column&quot;,
            &quot;mapping&quot;: &quot;columns&quot;
        },
        &quot;idx&quot;: {
            &quot;name&quot;: &quot;idx&quot;,
            &quot;title&quot;: &quot;Timestamp&quot;,
            &quot;mapping&quot;: &quot;index&quot;
        }
    }
})
</code></pre></div>
</dd>
<dt id="vectorbt.records.base.Records.metrics"><code class="name">var <span class="ident child-name">metrics</span></code></dt>
<dd>
<div class="desc"><p>Metrics supported by <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code>.</p>
<pre><code class="language-json">Config({
    &quot;start&quot;: {
        &quot;title&quot;: &quot;Start&quot;,
        &quot;calc_func&quot;: &quot;&lt;function Records.&lt;lambda&gt; at 0x7f16b5b80048&gt;&quot;,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    },
    &quot;end&quot;: {
        &quot;title&quot;: &quot;End&quot;,
        &quot;calc_func&quot;: &quot;&lt;function Records.&lt;lambda&gt; at 0x7f16b5b800d0&gt;&quot;,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    },
    &quot;period&quot;: {
        &quot;title&quot;: &quot;Period&quot;,
        &quot;calc_func&quot;: &quot;&lt;function Records.&lt;lambda&gt; at 0x7f16b5b80158&gt;&quot;,
        &quot;apply_to_timedelta&quot;: true,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    },
    &quot;count&quot;: {
        &quot;title&quot;: &quot;Count&quot;,
        &quot;calc_func&quot;: &quot;count&quot;,
        &quot;tags&quot;: &quot;records&quot;
    }
})
</code></pre>
<p>Returns <code>Records._metrics</code>, which gets (deep) copied upon creation of each instance.
Thus, changing this config won't affect the class.</p>
<p>To change metrics, you can either change the config in-place, override this property,
or overwrite the instance variable <code>Records._metrics</code>.</p></div>
</dd>
<dt id="vectorbt.records.base.Records.subplots"><code class="name">var <span class="ident child-name">subplots</span></code></dt>
<dd>
<div class="desc"><p>Subplots supported by <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code>.</p>
<pre><code class="language-json">Config({})
</code></pre>
<p>Returns <code>Records._subplots</code>, which gets (deep) copied upon creation of each instance.
Thus, changing this config won't affect the class.</p>
<p>To change subplots, you can either change the config in-place, override this property,
or overwrite the instance variable <code>Records._subplots</code>.</p></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.records.base.Records.build_field_config_doc"><code class="name flex">
<span>def <span class="ident child-name">build_field_config_doc</span></span>(<span class="params">source_cls=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Build field config documentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build_field_config_doc(cls, source_cls: tp.Optional[type] = None) -&gt; str:
    &#34;&#34;&#34;Build field config documentation.&#34;&#34;&#34;
    if source_cls is None:
        source_cls = Records
    return string.Template(
        inspect.cleandoc(get_dict_attr(source_cls, &#39;field_config&#39;).__doc__)
    ).substitute(
        {&#39;field_config&#39;: cls.field_config.to_doc(), &#39;cls_name&#39;: cls.__name__}
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.override_field_config_doc"><code class="name flex">
<span>def <span class="ident child-name">override_field_config_doc</span></span>(<span class="params">__pdoc__, source_cls=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Call this method on each subclass that overrides <code>field_config</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def override_field_config_doc(cls, __pdoc__: dict, source_cls: tp.Optional[type] = None) -&gt; None:
    &#34;&#34;&#34;Call this method on each subclass that overrides `field_config`.&#34;&#34;&#34;
    __pdoc__[cls.__name__ + &#39;.field_config&#39;] = cls.build_field_config_doc(source_cls=source_cls)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.records.base.Records.col_arr"><code class="name">var <span class="ident child-name">col_arr</span></code></dt>
<dd>
<div class="desc"><p>Get column array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def col_arr(self) -&gt; tp.Array1d:
    &#34;&#34;&#34;Get column array.&#34;&#34;&#34;
    return self.values[self.get_field_name(&#39;col&#39;)]</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.col_mapper"><code class="name">var <span class="ident child-name">col_mapper</span></code></dt>
<dd>
<div class="desc"><p>Column mapper.</p>
<p>See <code><a title="vectorbt.records.col_mapper.ColumnMapper" href="col_mapper.html#vectorbt.records.col_mapper.ColumnMapper">ColumnMapper</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def col_mapper(self) -&gt; ColumnMapper:
    &#34;&#34;&#34;Column mapper.

    See `vectorbt.records.col_mapper.ColumnMapper`.&#34;&#34;&#34;
    return self._col_mapper</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.id_arr"><code class="name">var <span class="ident child-name">id_arr</span></code></dt>
<dd>
<div class="desc"><p>Get id array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id_arr(self) -&gt; tp.Array1d:
    &#34;&#34;&#34;Get id array.&#34;&#34;&#34;
    return self.values[self.get_field_name(&#39;id&#39;)]</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.idx_arr"><code class="name">var <span class="ident child-name">idx_arr</span></code></dt>
<dd>
<div class="desc"><p>Get index array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def idx_arr(self) -&gt; tp.Optional[tp.Array1d]:
    &#34;&#34;&#34;Get index array.&#34;&#34;&#34;
    idx_field_name = self.get_field_name(&#39;idx&#39;)
    if idx_field_name is None:
        return None
    return self.values[idx_field_name]</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.plots_defaults"><code class="name">var <span class="ident child-name">plots_defaults</span></code></dt>
<dd>
<div class="desc"><p>Defaults for <code><a title="vectorbt.records.base.Records.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">PlotsBuilderMixin.plots()</a></code>.</p>
<p>Merges <code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults">PlotsBuilderMixin.plots_defaults</a></code> and
<code>records.plots</code> from <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plots_defaults(self) -&gt; tp.Kwargs:
    &#34;&#34;&#34;Defaults for `Records.plots`.

    Merges `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults` and
    `records.plots` from `vectorbt._settings.settings`.&#34;&#34;&#34;
    from vectorbt._settings import settings
    records_plots_cfg = settings[&#39;records&#39;][&#39;plots&#39;]

    return merge_dicts(
        PlotsBuilderMixin.plots_defaults.__get__(self),
        records_plots_cfg
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.recarray"><code class="name">var <span class="ident child-name">recarray</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def recarray(self) -&gt; tp.RecArray:
    return self.values.view(np.recarray)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.records"><code class="name">var <span class="ident child-name">records</span></code></dt>
<dd>
<div class="desc"><p>Records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def records(self) -&gt; tp.Frame:
    &#34;&#34;&#34;Records.&#34;&#34;&#34;
    return pd.DataFrame.from_records(self.values)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.records_arr"><code class="name">var <span class="ident child-name">records_arr</span></code></dt>
<dd>
<div class="desc"><p>Records array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def records_arr(self) -&gt; tp.RecordArray:
    &#34;&#34;&#34;Records array.&#34;&#34;&#34;
    return self._records_arr</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.records_readable"><code class="name">var <span class="ident child-name">records_readable</span></code></dt>
<dd>
<div class="desc"><p>Records in readable format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def records_readable(self) -&gt; tp.Frame:
    &#34;&#34;&#34;Records in readable format.&#34;&#34;&#34;
    df = self.records.copy()
    field_settings = self.field_config.get(&#39;settings&#39;, {})
    for col_name in df.columns:
        if col_name in field_settings:
            dct = field_settings[col_name]
            if dct.get(&#39;ignore&#39;, False):
                df = df.drop(columns=col_name)
                continue
            field_name = dct.get(&#39;name&#39;, col_name)
            if &#39;title&#39; in dct:
                title = dct[&#39;title&#39;]
                new_columns = dict()
                new_columns[field_name] = title
                df.rename(columns=new_columns, inplace=True)
            else:
                title = field_name
            if &#39;mapping&#39; in dct:
                if isinstance(dct[&#39;mapping&#39;], str) and dct[&#39;mapping&#39;] == &#39;index&#39;:
                    df[title] = self.get_map_field_to_index(col_name)
                else:
                    df[title] = self.get_apply_mapping_arr(col_name)
    return df</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.stats_defaults"><code class="name">var <span class="ident child-name">stats_defaults</span></code></dt>
<dd>
<div class="desc"><p>Defaults for <code><a title="vectorbt.records.base.Records.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code>.</p>
<p>Merges <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">StatsBuilderMixin.stats_defaults</a></code> and
<code>records.stats</code> from <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stats_defaults(self) -&gt; tp.Kwargs:
    &#34;&#34;&#34;Defaults for `Records.stats`.

    Merges `vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults` and
    `records.stats` from `vectorbt._settings.settings`.&#34;&#34;&#34;
    from vectorbt._settings import settings
    records_stats_cfg = settings[&#39;records&#39;][&#39;stats&#39;]

    return merge_dicts(
        StatsBuilderMixin.stats_defaults.__get__(self),
        records_stats_cfg
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.values"><code class="name">var <span class="ident child-name">values</span></code></dt>
<dd>
<div class="desc"><p>Records array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self) -&gt; tp.RecordArray:
    &#34;&#34;&#34;Records array.&#34;&#34;&#34;
    return self.records_arr</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.records.base.Records.apply"><code class="name flex">
<span>def <span class="ident child-name">apply</span></span>(<span class="params">self, apply_func_nb, *args, group_by=None, apply_per_group=False, dtype=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Apply function on records per column/group. Returns mapped array.</p>
<p>Applies per group if <code>apply_per_group</code> is True.</p>
<p>See <code><a title="vectorbt.records.nb.apply_on_records_nb" href="nb.html#vectorbt.records.nb.apply_on_records_nb">apply_on_records_nb()</a></code>.</p>
<p><code>**kwargs</code> are passed to <code><a title="vectorbt.records.base.Records.map_array" href="#vectorbt.records.base.Records.map_array">Records.map_array()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self,
          apply_func_nb: tp.RecordApplyFunc, *args,
          group_by: tp.GroupByLike = None,
          apply_per_group: bool = False,
          dtype: tp.Optional[tp.DTypeLike] = None,
          **kwargs) -&gt; MappedArray:
    &#34;&#34;&#34;Apply function on records per column/group. Returns mapped array.

    Applies per group if `apply_per_group` is True.

    See `vectorbt.records.nb.apply_on_records_nb`.

    `**kwargs` are passed to `Records.map_array`.&#34;&#34;&#34;
    checks.assert_numba_func(apply_func_nb)
    if apply_per_group:
        col_map = self.col_mapper.get_col_map(group_by=group_by)
    else:
        col_map = self.col_mapper.get_col_map(group_by=False)
    mapped_arr = nb.apply_on_records_nb(self.values, col_map, apply_func_nb, *args)
    mapped_arr = np.asarray(mapped_arr, dtype=dtype)
    return self.map_array(mapped_arr, group_by=group_by, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.apply_mask"><code class="name flex">
<span>def <span class="ident child-name">apply_mask</span></span>(<span class="params">self, mask, group_by=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return a new class instance, filtered by mask.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_mask(self: RecordsT, mask: tp.Array1d, group_by: tp.GroupByLike = None, **kwargs) -&gt; RecordsT:
    &#34;&#34;&#34;Return a new class instance, filtered by mask.&#34;&#34;&#34;
    mask_indices = np.flatnonzero(mask)
    return self.replace(
        records_arr=np.take(self.values, mask_indices),
        **kwargs
    ).regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.count"><code class="name flex">
<span>def <span class="ident child-name">count</span></span>(<span class="params">self, group_by=None, wrap_kwargs=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return count by column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def count(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;Return count by column.&#34;&#34;&#34;
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;count&#39;), wrap_kwargs)
    return self.wrapper.wrap_reduced(
        self.col_mapper.get_col_map(group_by=group_by)[1],
        group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.get_apply_mapping_arr"><code class="name flex">
<span>def <span class="ident child-name">get_apply_mapping_arr</span></span>(<span class="params">self, field, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve the mapped array on the field, with mapping applied. Uses <code><a title="vectorbt.records.base.Records.field_config" href="#vectorbt.records.base.Records.field_config">Records.field_config</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_apply_mapping_arr(self, field: str, **kwargs) -&gt; tp.Array1d:
    &#34;&#34;&#34;Resolve the mapped array on the field, with mapping applied. Uses `Records.field_config`.&#34;&#34;&#34;
    return self.get_map_field(field, **kwargs).apply_mapping().values</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.get_by_col_idxs"><code class="name flex">
<span>def <span class="ident child-name">get_by_col_idxs</span></span>(<span class="params">self, col_idxs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get records corresponding to column indices.</p>
<p>Returns new records array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_col_idxs(self, col_idxs: tp.Array1d) -&gt; tp.RecordArray:
    &#34;&#34;&#34;Get records corresponding to column indices.

    Returns new records array.&#34;&#34;&#34;
    if self.col_mapper.is_sorted():
        new_records_arr = nb.record_col_range_select_nb(
            self.values, self.col_mapper.col_range, to_1d_array(col_idxs))  # faster
    else:
        new_records_arr = nb.record_col_map_select_nb(
            self.values, self.col_mapper.col_map, to_1d_array(col_idxs))
    return new_records_arr</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.get_field_arr"><code class="name flex">
<span>def <span class="ident child-name">get_field_arr</span></span>(<span class="params">self, field)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve the array of the field. Uses <code><a title="vectorbt.records.base.Records.field_config" href="#vectorbt.records.base.Records.field_config">Records.field_config</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_field_arr(self, field: str) -&gt; tp.Array1d:
    &#34;&#34;&#34;Resolve the array of the field. Uses `Records.field_config`.&#34;&#34;&#34;
    return self.values[self.get_field_name(field)]</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.get_field_mapping"><code class="name flex">
<span>def <span class="ident child-name">get_field_mapping</span></span>(<span class="params">self, field)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve the mapping of the field. Uses <code><a title="vectorbt.records.base.Records.field_config" href="#vectorbt.records.base.Records.field_config">Records.field_config</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_field_mapping(self, field: str) -&gt; tp.Optional[tp.MappingLike]:
    &#34;&#34;&#34;Resolve the mapping of the field. Uses `Records.field_config`.&#34;&#34;&#34;
    return self.get_field_setting(field, &#39;mapping&#39;, None)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.get_field_name"><code class="name flex">
<span>def <span class="ident child-name">get_field_name</span></span>(<span class="params">self, field)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve the name of the field. Uses <code><a title="vectorbt.records.base.Records.field_config" href="#vectorbt.records.base.Records.field_config">Records.field_config</a></code>..</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_field_name(self, field: str) -&gt; str:
    &#34;&#34;&#34;Resolve the name of the field. Uses `Records.field_config`..&#34;&#34;&#34;
    return self.get_field_setting(field, &#39;name&#39;, field)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.get_field_setting"><code class="name flex">
<span>def <span class="ident child-name">get_field_setting</span></span>(<span class="params">self, field, setting, default=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve any setting of the field. Uses <code><a title="vectorbt.records.base.Records.field_config" href="#vectorbt.records.base.Records.field_config">Records.field_config</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_field_setting(self, field: str, setting: str, default: tp.Any = None) -&gt; tp.Any:
    &#34;&#34;&#34;Resolve any setting of the field. Uses `Records.field_config`.&#34;&#34;&#34;
    return self.field_config.get(&#39;settings&#39;, {}).get(field, {}).get(setting, default)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.get_field_title"><code class="name flex">
<span>def <span class="ident child-name">get_field_title</span></span>(<span class="params">self, field)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve the title of the field. Uses <code><a title="vectorbt.records.base.Records.field_config" href="#vectorbt.records.base.Records.field_config">Records.field_config</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_field_title(self, field: str) -&gt; str:
    &#34;&#34;&#34;Resolve the title of the field. Uses `Records.field_config`.&#34;&#34;&#34;
    return self.get_field_setting(field, &#39;title&#39;, field)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.get_map_field"><code class="name flex">
<span>def <span class="ident child-name">get_map_field</span></span>(<span class="params">self, field, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve the mapped array of the field. Uses <code><a title="vectorbt.records.base.Records.field_config" href="#vectorbt.records.base.Records.field_config">Records.field_config</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_map_field(self, field: str, **kwargs) -&gt; MappedArray:
    &#34;&#34;&#34;Resolve the mapped array of the field. Uses `Records.field_config`.&#34;&#34;&#34;
    return self.map_field(self.get_field_name(field), mapping=self.get_field_mapping(field), **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.get_map_field_to_index"><code class="name flex">
<span>def <span class="ident child-name">get_map_field_to_index</span></span>(<span class="params">self, field, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve the mapped array on the field, with index applied. Uses <code><a title="vectorbt.records.base.Records.field_config" href="#vectorbt.records.base.Records.field_config">Records.field_config</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_map_field_to_index(self, field: str, **kwargs) -&gt; tp.Index:
    &#34;&#34;&#34;Resolve the mapped array on the field, with index applied. Uses `Records.field_config`.&#34;&#34;&#34;
    return self.get_map_field(field, **kwargs).to_index()</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.indexing_func"><code class="name flex">
<span>def <span class="ident child-name">indexing_func</span></span>(<span class="params">self, pd_indexing_func, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Perform indexing on <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indexing_func(self: RecordsT, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; RecordsT:
    &#34;&#34;&#34;Perform indexing on `Records`.&#34;&#34;&#34;
    new_wrapper, new_records_arr, _, _ = self.indexing_func_meta(pd_indexing_func, **kwargs)
    return self.replace(
        wrapper=new_wrapper,
        records_arr=new_records_arr
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.indexing_func_meta"><code class="name flex">
<span>def <span class="ident child-name">indexing_func_meta</span></span>(<span class="params">self, pd_indexing_func, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Perform indexing on <code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code> and return metadata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indexing_func_meta(self, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; IndexingMetaT:
    &#34;&#34;&#34;Perform indexing on `Records` and return metadata.&#34;&#34;&#34;
    new_wrapper, _, group_idxs, col_idxs = \
        self.wrapper.indexing_func_meta(pd_indexing_func, column_only_select=True, **kwargs)
    new_records_arr = self.get_by_col_idxs(col_idxs)
    return new_wrapper, new_records_arr, group_idxs, col_idxs</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.is_sorted"><code class="name flex">
<span>def <span class="ident child-name">is_sorted</span></span>(<span class="params">self, incl_id=False)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Check whether records are sorted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def is_sorted(self, incl_id: bool = False) -&gt; bool:
    &#34;&#34;&#34;Check whether records are sorted.&#34;&#34;&#34;
    if incl_id:
        return nb.is_col_idx_sorted_nb(self.col_arr, self.id_arr)
    return nb.is_col_sorted_nb(self.col_arr)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.map"><code class="name flex">
<span>def <span class="ident child-name">map</span></span>(<span class="params">self, map_func_nb, *args, dtype=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Map each record to a scalar value. Returns mapped array.</p>
<p>See <code><a title="vectorbt.records.nb.map_records_nb" href="nb.html#vectorbt.records.nb.map_records_nb">map_records_nb()</a></code>.</p>
<p><code>**kwargs</code> are passed to <code><a title="vectorbt.records.base.Records.map_array" href="#vectorbt.records.base.Records.map_array">Records.map_array()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self,
        map_func_nb: tp.RecordMapFunc, *args,
        dtype: tp.Optional[tp.DTypeLike] = None,
        **kwargs) -&gt; MappedArray:
    &#34;&#34;&#34;Map each record to a scalar value. Returns mapped array.

    See `vectorbt.records.nb.map_records_nb`.

    `**kwargs` are passed to `Records.map_array`.&#34;&#34;&#34;
    checks.assert_numba_func(map_func_nb)
    mapped_arr = nb.map_records_nb(self.values, map_func_nb, *args)
    mapped_arr = np.asarray(mapped_arr, dtype=dtype)
    return self.map_array(mapped_arr, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.map_array"><code class="name flex">
<span>def <span class="ident child-name">map_array</span></span>(<span class="params">self, a, idx_arr=None, mapping=None, group_by=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Convert array to mapped array.</p>
<p>The length of the array should match that of the records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_array(self,
              a: tp.ArrayLike,
              idx_arr: tp.Optional[tp.ArrayLike] = None,
              mapping: tp.Optional[tp.MappingLike] = None,
              group_by: tp.GroupByLike = None,
              **kwargs) -&gt; MappedArray:
    &#34;&#34;&#34;Convert array to mapped array.

     The length of the array should match that of the records.&#34;&#34;&#34;
    if not isinstance(a, np.ndarray):
        a = np.asarray(a)
    checks.assert_shape_equal(a, self.values)
    if idx_arr is None:
        idx_arr = self.idx_arr
    return MappedArray(
        self.wrapper,
        a,
        self.col_arr,
        id_arr=self.id_arr,
        idx_arr=idx_arr,
        mapping=mapping,
        col_mapper=self.col_mapper,
        **kwargs
    ).regroup(group_by)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.map_field"><code class="name flex">
<span>def <span class="ident child-name">map_field</span></span>(<span class="params">self, field, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Convert field to mapped array.</p>
<p><code>**kwargs</code> are passed to <code><a title="vectorbt.records.base.Records.map_array" href="#vectorbt.records.base.Records.map_array">Records.map_array()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_field(self, field: str, **kwargs) -&gt; MappedArray:
    &#34;&#34;&#34;Convert field to mapped array.

    `**kwargs` are passed to `Records.map_array`.&#34;&#34;&#34;
    mapped_arr = self.values[field]
    return self.map_array(mapped_arr, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.replace"><code class="name flex">
<span>def <span class="ident child-name">replace</span></span>(<span class="params">self, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="vectorbt.utils.config.Configured.replace" href="../utils/config.html#vectorbt.utils.config.Configured.replace">Configured.replace()</a></code>.</p>
<p>Also, makes sure that <code><a title="vectorbt.records.base.Records.col_mapper" href="#vectorbt.records.base.Records.col_mapper">Records.col_mapper</a></code> is not passed to the new instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self: RecordsT, **kwargs) -&gt; RecordsT:
    &#34;&#34;&#34;See `vectorbt.utils.config.Configured.replace`.

    Also, makes sure that `Records.col_mapper` is not passed to the new instance.&#34;&#34;&#34;
    if self.config.get(&#39;col_mapper&#39;, None) is not None:
        if &#39;wrapper&#39; in kwargs:
            if self.wrapper is not kwargs.get(&#39;wrapper&#39;):
                kwargs[&#39;col_mapper&#39;] = None
        if &#39;records_arr&#39; in kwargs:
            if self.records_arr is not kwargs.get(&#39;records_arr&#39;):
                kwargs[&#39;col_mapper&#39;] = None
    return Configured.replace(self, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.records.base.Records.sort"><code class="name flex">
<span>def <span class="ident child-name">sort</span></span>(<span class="params">self, incl_id=False, group_by=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Sort records by columns (primary) and ids (secondary, optional).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Sorting is expensive. A better approach is to append records already in the correct order.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self: RecordsT, incl_id: bool = False, group_by: tp.GroupByLike = None, **kwargs) -&gt; RecordsT:
    &#34;&#34;&#34;Sort records by columns (primary) and ids (secondary, optional).

    !!! note
        Sorting is expensive. A better approach is to append records already in the correct order.&#34;&#34;&#34;
    if self.is_sorted(incl_id=incl_id):
        return self.replace(**kwargs).regroup(group_by)
    if incl_id:
        ind = np.lexsort((self.id_arr, self.col_arr))  # expensive!
    else:
        ind = np.argsort(self.col_arr)
    return self.replace(records_arr=self.values[ind], **kwargs).regroup(group_by)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.deep_getattr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.post_resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.pre_resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.resolve_self" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.self_aliases" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.base.array_wrapper.Wrapping.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
<li><code><b><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
</ul>
</li>
<li><code><b><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.records.base.RecordsWithFields"><code class="flex name class">
<span>class <span class="ident parent-name">RecordsWithFields</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class exposes a read-only class property <code><a title="vectorbt.records.base.RecordsWithFields.field_config" href="#vectorbt.records.base.RecordsWithFields.field_config">RecordsWithFields.field_config</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecordsWithFields(metaclass=MetaFields):
    &#34;&#34;&#34;Class exposes a read-only class property `RecordsWithFields.field_config`.&#34;&#34;&#34;

    @property
    def field_config(self) -&gt; Config:
        &#34;&#34;&#34;Field config of `${cls_name}`.

        ```json
        ${field_config}
        ```
        &#34;&#34;&#34;
        return self._field_config</code></pre>
</details>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.records.base.RecordsWithFields.field_config"><code class="name">var <span class="ident child-name">field_config</span></code></dt>
<dd>
<div class="desc"><p>Field config of <code>${cls_name}</code>.</p>
<pre><code class="language-json">${field_config}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def field_config(self) -&gt; Config:
    &#34;&#34;&#34;Field config of `${cls_name}`.

    ```json
    ${field_config}
    ```
    &#34;&#34;&#34;
    return self._field_config</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRUYwMDAwO30KCS5zdDF7ZmlsbDojRkY5MDAwO30KCS5zdDJ7ZmlsbDojRkZERjAwO30KCS5zdDN7ZmlsbDojMjgyQzM0O30KPC9zdHlsZT4KPGc+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNTUuMywzMDAuMSAyODMuMSwwIDIwOCwwIDExMC44LDAgMzUuOCwwIDEuMiw0NTAuMiA3Ni4zLDQ1MC4yIAkJCSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjIzMC40LDMwMC4xIDM1OC4xLDAgMjgzLjEsMCAxODUuOCwwIDExMC44LDAgNzYuMyw0NTAuMiAxNTEuMyw0NTAuMiAJCQkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIzMDUuNCwzMDAuMSA0MzMuMSwwIDM1OC4xLDAgMzMxLjYsNjIuMyAyNjAuOCwwIDE4NS44LDAgMTUxLjMsNDUwLjIgMjI2LjQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iNTEwLjgsMCA0MzMuMSwwIDMwNS40LDMwMC4xIDMzOC40LDAgMjYwLjgsMCAyMjYuNCw0NTAuMiAzMDQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="/>
vectorbt <span class="version">0.21.0</span></a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul>
<li><a href="#printing">Printing</a></li>
<li><a href="#mapping">Mapping</a></li>
<li><a href="#filtering">Filtering</a></li>
<li><a href="#grouping">Grouping</a></li>
<li><a href="#indexing">Indexing</a></li>
<li><a href="#caching">Caching</a></li>
<li><a href="#saving-and-loading">Saving and loading</a></li>
<li><a href="#stats">Stats</a></li>
<li><a href="#plots">Plots</a></li>
<li><a href="#extending">Extending</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.records" href="index.html">vectorbt.records</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.records.base.MetaFields" href="#vectorbt.records.base.MetaFields">MetaFields</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.records.base.MetaFields.field_config" href="#vectorbt.records.base.MetaFields.field_config">field_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.records.base.MetaRecords" href="#vectorbt.records.base.MetaRecords">MetaRecords</a></code></h4>
</li>
<li>
<h4><code><a title="vectorbt.records.base.Records" href="#vectorbt.records.base.Records">Records</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.records.base.Records.apply" href="#vectorbt.records.base.Records.apply">apply</a></code></li>
<li><code><a title="vectorbt.records.base.Records.apply_mask" href="#vectorbt.records.base.Records.apply_mask">apply_mask</a></code></li>
<li><code><a title="vectorbt.records.base.Records.build_field_config_doc" href="#vectorbt.records.base.Records.build_field_config_doc">build_field_config_doc</a></code></li>
<li><code><a title="vectorbt.records.base.Records.col_arr" href="#vectorbt.records.base.Records.col_arr">col_arr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.col_mapper" href="#vectorbt.records.base.Records.col_mapper">col_mapper</a></code></li>
<li><code><a title="vectorbt.records.base.Records.count" href="#vectorbt.records.base.Records.count">count</a></code></li>
<li><code><a title="vectorbt.records.base.Records.field_config" href="#vectorbt.records.base.Records.field_config">field_config</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_apply_mapping_arr" href="#vectorbt.records.base.Records.get_apply_mapping_arr">get_apply_mapping_arr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_by_col_idxs" href="#vectorbt.records.base.Records.get_by_col_idxs">get_by_col_idxs</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_field_arr" href="#vectorbt.records.base.Records.get_field_arr">get_field_arr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_field_mapping" href="#vectorbt.records.base.Records.get_field_mapping">get_field_mapping</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_field_name" href="#vectorbt.records.base.Records.get_field_name">get_field_name</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_field_setting" href="#vectorbt.records.base.Records.get_field_setting">get_field_setting</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_field_title" href="#vectorbt.records.base.Records.get_field_title">get_field_title</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_map_field" href="#vectorbt.records.base.Records.get_map_field">get_map_field</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_map_field_to_index" href="#vectorbt.records.base.Records.get_map_field_to_index">get_map_field_to_index</a></code></li>
<li><code><a title="vectorbt.records.base.Records.id_arr" href="#vectorbt.records.base.Records.id_arr">id_arr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.idx_arr" href="#vectorbt.records.base.Records.idx_arr">idx_arr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.indexing_func" href="#vectorbt.records.base.Records.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.records.base.Records.indexing_func_meta" href="#vectorbt.records.base.Records.indexing_func_meta">indexing_func_meta</a></code></li>
<li><code><a title="vectorbt.records.base.Records.is_sorted" href="#vectorbt.records.base.Records.is_sorted">is_sorted</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map" href="#vectorbt.records.base.Records.map">map</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map_array" href="#vectorbt.records.base.Records.map_array">map_array</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map_field" href="#vectorbt.records.base.Records.map_field">map_field</a></code></li>
<li><code><a title="vectorbt.records.base.Records.metrics" href="#vectorbt.records.base.Records.metrics">metrics</a></code></li>
<li><code><a title="vectorbt.records.base.Records.override_field_config_doc" href="#vectorbt.records.base.Records.override_field_config_doc">override_field_config_doc</a></code></li>
<li><code><a title="vectorbt.records.base.Records.plots_defaults" href="#vectorbt.records.base.Records.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.records.base.Records.recarray" href="#vectorbt.records.base.Records.recarray">recarray</a></code></li>
<li><code><a title="vectorbt.records.base.Records.records" href="#vectorbt.records.base.Records.records">records</a></code></li>
<li><code><a title="vectorbt.records.base.Records.records_arr" href="#vectorbt.records.base.Records.records_arr">records_arr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.records_readable" href="#vectorbt.records.base.Records.records_readable">records_readable</a></code></li>
<li><code><a title="vectorbt.records.base.Records.replace" href="#vectorbt.records.base.Records.replace">replace</a></code></li>
<li><code><a title="vectorbt.records.base.Records.sort" href="#vectorbt.records.base.Records.sort">sort</a></code></li>
<li><code><a title="vectorbt.records.base.Records.stats_defaults" href="#vectorbt.records.base.Records.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.records.base.Records.subplots" href="#vectorbt.records.base.Records.subplots">subplots</a></code></li>
<li><code><a title="vectorbt.records.base.Records.values" href="#vectorbt.records.base.Records.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.records.base.RecordsWithFields" href="#vectorbt.records.base.RecordsWithFields">RecordsWithFields</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.records.base.RecordsWithFields.field_config" href="#vectorbt.records.base.RecordsWithFields.field_config">field_config</a></code></li>
</ul>
</li>
</ul>
</li>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous"></script>
<script>
$(document).ready(function() {
$("article dt[id], #section-intro [id]").each(function() {
const thisId = $(this).attr('id');
$(this).wrap('<a class="headerlink" href="#' + thisId + '">');
});
});
</script>
</body>
</html>