<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>vectorbt.indicators API documentation</title>
<meta name="description" content="Technical indicators are used to see past trends and anticipate future moves. This module provides a collection
of such indicators, but also a …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.indicators</code></h1>
</header>
<section id="section-intro">
<p>Technical indicators are used to see past trends and anticipate future moves. This module provides a collection
of such indicators, but also a comprehensive <code><a title="vectorbt.indicators.IndicatorFactory" href="#vectorbt.indicators.IndicatorFactory">IndicatorFactory</a></code> for building new indicators
with ease.</p>
<p>Before running examples, import the following libraries:</p>
<pre><code class="py">import numpy as np
import pandas as pd
from datetime import datetime, timedelta
import itertools
from numba import njit

import vectorbt as vbt

np.random.seed(0)
price = pd.Series(np.cumsum(np.random.uniform(-0.8, 1, size=(100,))), 
    index=[datetime(2018, 1, 1) + timedelta(days=i) for i in range(100)])

price.vbt.plot()
</code></pre>
<p><img alt="" src="img/Indicators_price.png"></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Technical indicators are used to see past trends and anticipate future moves. This module provides a collection
of such indicators, but also a comprehensive `vectorbt.indicators.IndicatorFactory` for building new indicators
with ease.

Before running examples, import the following libraries:
```py
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
import itertools
from numba import njit

import vectorbt as vbt

np.random.seed(0)
price = pd.Series(np.cumsum(np.random.uniform(-0.8, 1, size=(100,))), 
    index=[datetime(2018, 1, 1) + timedelta(days=i) for i in range(100)])

price.vbt.plot()
```
![](img/Indicators_price.png)
&#34;&#34;&#34;
import pandas as pd
import numpy as np
from numba import njit
from numba.types import UniTuple, f8, i8, b1, DictType, ListType, Array
from numba.typed import List, Dict
from copy import copy
import plotly.graph_objects as go
import itertools
import types

from vectorbt.utils import *
from vectorbt.accessors import *
from vectorbt.timeseries import rolling_mean_nb, rolling_std_nb, ewm_mean_nb, \
    ewm_std_nb, diff_nb, set_by_mask_nb, prepend_nb, rolling_min_nb, rolling_max_nb

# ############# Indicator factory ############# #


def build_column_hierarchy(param_list, level_names, ts_columns):
    check_same_shape(param_list, level_names, along_axis=0)
    param_indices = [index_from_values(param_list[i], name=level_names[i]) for i in range(len(param_list))]
    param_columns = None
    for param_index in param_indices:
        if param_columns is None:
            param_columns = param_index
        else:
            param_columns = stack_indices(param_columns, param_index)
    if param_columns is not None:
        return combine_indices(param_columns, ts_columns)
    return ts_columns


def build_mapper(params, ts, new_columns, level_name):
    params_mapper = np.repeat(params, len(to_2d(ts).columns))
    params_mapper = pd.Series(params_mapper, index=new_columns, name=level_name)
    return params_mapper


def build_tuple_mapper(mappers_list, new_columns, level_names):
    tuple_mapper = list(zip(*list(map(lambda x: x.values, mappers_list))))
    tuple_mapper = pd.Series(tuple_mapper, index=new_columns, name=level_names)
    return tuple_mapper


def wrap_output(output, ts, new_columns):
    return ts.vbt.wrap_array(output, columns=new_columns)


def broadcast_ts(ts, params_len, new_columns):
    if is_series(ts) or len(new_columns) &gt; ts.shape[1]:
        return ts.vbt.wrap_array(tile(ts.values, params_len, along_axis=1), columns=new_columns)
    else:
        return ts.vbt.wrap_array(ts, columns=new_columns)


def from_params_pipeline(ts_list, param_list, level_names, num_outputs, custom_func, *args, pass_lists=False,
                         param_product=False, broadcast_kwargs={}, return_raw=False, **kwargs):
    &#34;&#34;&#34;A pipeline for calculating an indicator, used by `vectorbt.indicators.IndicatorFactory`.

    Does the following:

    * Takes one or multiple time series objects in `ts_list` and broadcasts them

    ```python-repl
    &gt;&gt;&gt; sr = pd.Series([1, 2], index=[&#39;x&#39;, &#39;y&#39;])
    &gt;&gt;&gt; df = pd.DataFrame([[3, 4], [5, 6]], index=[&#39;x&#39;, &#39;y&#39;], columns=[&#39;a&#39;, &#39;b&#39;])
    &gt;&gt;&gt; ts_list = [sr, df]

    &gt;&gt;&gt; ts_list = vbt.utils.broadcast(*ts_list)
    &gt;&gt;&gt; print(ts_list[0])
       a  b
    x  1  1
    y  2  2
    &gt;&gt;&gt; print(ts_list[1])
       a  b
    x  3  4
    y  5  6
    ```

    * Takes one or multiple parameters in `param_list`, converts them to NumPy arrays and 
        broadcasts them

    ```python-repl
    &gt;&gt;&gt; p1, p2, p3 = 1, [2, 3, 4], [False]
    &gt;&gt;&gt; param_list = [p1, p2, p3]

    &gt;&gt;&gt; param_list = vbt.utils.broadcast(*param_list)
    &gt;&gt;&gt; print(param_list[0])
    array([1, 1, 1])
    &gt;&gt;&gt; print(param_list[1])
    array([2, 3, 4])
    &gt;&gt;&gt; print(param_list[2])
    array([False, False, False])
    ```

    * Performs calculation using `custom_func` to build output arrays (`output_list`) and 
        other objects (`other_list`, optional)

    ```python-repl
    &gt;&gt;&gt; def custom_func(ts1, ts2, p1, p2, p3, *args, **kwargs):
    ...     return pd.DataFrame.vbt.concat(
    ...         (ts1.values + ts2.values) + p1[0] * p2[0],
    ...         (ts1.values + ts2.values) + p1[1] * p2[1],
    ...         (ts1.values + ts2.values) + p1[2] * p2[2]
    ...     )

    &gt;&gt;&gt; output = custom_func(*ts_list, *param_list)
    &gt;&gt;&gt; print(output)
    array([[ 6,  7,  7,  8,  8,  9],
           [ 9, 10, 10, 11, 11, 12]])
    ```

    * Creates new column hierarchy based on parameters and level names

    ```python-repl
    &gt;&gt;&gt; p1_columns = pd.Index(param_list[0], name=&#39;p1&#39;)
    &gt;&gt;&gt; p2_columns = pd.Index(param_list[1], name=&#39;p2&#39;)
    &gt;&gt;&gt; p3_columns = pd.Index(param_list[2], name=&#39;p3&#39;)
    &gt;&gt;&gt; p_columns = vbt.utils.stack_indices(p1_columns, p2_columns, p3_columns)
    &gt;&gt;&gt; new_columns = vbt.utils.combine_indices(p_columns, ts_list[0].columns)

    &gt;&gt;&gt; output_df = pd.DataFrame(output, columns=new_columns)
    &gt;&gt;&gt; print(output_df)
    p1      1      1      1      1      1      1                        
    p2      2      2      3      3      4      4    
    p3  False  False  False  False  False  False    
            a      b      a      b      a      b
    0       6      7      7      8      8      9
    1       9     10     10     11     11     12
    ```

    * Broadcasts objects in `ts_list` to match the shape of objects in `output_list` through tiling.
        This is done to be able to compare them and generate signals, since you cannot compare NumPy 
        arrays that have totally different shapes, such as (2, 2) and (2, 6).

    ```python-repl
    &gt;&gt;&gt; new_ts_list = [
    ...     ts_list[0].vbt.tile(len(param_list[0]), as_columns=p_columns),
    ...     ts_list[1].vbt.tile(len(param_list[0]), as_columns=p_columns)
    ... ]
    &gt;&gt;&gt; print(new_ts_list[0])
    p1      1      1      1      1      1      1                        
    p2      2      2      3      3      4      4    
    p3  False  False  False  False  False  False     
            a      b      a      b      a      b
    0       1      1      1      1      1      1
    1       2      2      2      2      2      2
    ```

    * Builds parameter mappers that will link parameters from `param_list` to columns in 
        `ts_list` and `output_list`. This is done to enable column indexing using parameter values.

    Args:
        ts_list (list of array_like): A list of time series objects. At least one must be a pandas object.
        param_list (list of array_like): A list of parameters. Each element is either an array-like object
            or a single value of any type.
        level_names (list of str): A list of column level names corresponding to each parameter.
        num_outputs (int): The number of output arrays.
        custom_func (function): A custom calculation function. See `IndicatorFactory.from_custom_func`.
        *args: Arguments passed to the `custom_func`.
        pass_lists (bool): If True, arguments are passed to the `custom_func` as lists. Defaults to False.
        param_product (bool): If True, builds a Cartesian product out of all parameters. Defaults to False.
        broadcast_kwargs (dict, optional): Keyword arguments passed to the `vectorbt.utils.broadcast` on time series objects.
        return_raw (bool): If True, returns the raw output without post-processing. Defaults to False.
        **kwargs: Keyword arguments passed to the `custom_func`.

            Some common arguments include `return_cache` to return cache and `cache` to pass cache. 
            Those are only applicable to `custom_func` that supports it (`custom_func` created using
            `IndicatorFactory.from_apply_func` are supported by default).
    Returns:
        A list of transformed inputs (`pandas_like`), a list of generated outputs (`pandas_like`), 
        a list of parameter arrays (`numpy.ndarray`), a list of parameter mappers (`pandas.Series`),
        a list of other generated outputs that are outside of  `num_outputs`.
    &#34;&#34;&#34;
    # Check time series objects
    check_type(ts_list[0], (pd.Series, pd.DataFrame))
    for i in range(1, len(ts_list)):
        ts_list[i].vbt.timeseries.validate()
    if len(ts_list) &gt; 1:
        # Broadcast time series
        ts_list = broadcast(*ts_list, **broadcast_kwargs, writeable=True)
    # Check level names
    check_type(level_names, (list, tuple))
    check_same_len(param_list, level_names)
    for ts in ts_list:
        # Every time series object should be free of the specified level names in its columns
        for level_name in level_names:
            check_level_not_exists(ts, level_name)
    # Convert params to 1-dim arrays
    param_list = list(map(to_1d, param_list))
    if len(param_list) &gt; 1:
        if param_product:
            # Make Cartesian product out of all params
            param_list = list(map(to_1d, param_list))
            param_list = list(zip(*list(itertools.product(*param_list))))
            param_list = list(map(np.asarray, param_list))
        else:
            # Broadcast such that each array has the same length
            param_list = broadcast(*param_list, writeable=True)
    # Perform main calculation
    if pass_lists:
        output_list = custom_func(ts_list, param_list, *args, **kwargs)
    else:
        output_list = custom_func(*ts_list, *param_list, *args, **kwargs)
    if return_raw or kwargs.get(&#39;return_cache&#39;, False):
        return output_list  # return raw cache outputs
    if not isinstance(output_list, (tuple, list, List)):
        output_list = [output_list]
    else:
        output_list = list(output_list)
    # Other outputs should be returned without post-processing (for example cache_dict)
    if len(output_list) &gt; num_outputs:
        other_list = output_list[num_outputs:]
    else:
        other_list = []
    # Process only the num_outputs outputs
    output_list = output_list[:num_outputs]
    if len(param_list) &gt; 0:
        # Build new column levels on top of time series levels
        new_columns = build_column_hierarchy(param_list, level_names, to_2d(ts_list[0]).columns)
        # Wrap into new pandas objects both time series and output objects
        new_ts_list = list(map(lambda x: broadcast_ts(x, param_list[0].shape[0], new_columns), ts_list))
        # Build mappers to easily map between parameters and columns
        mapper_list = [build_mapper(x, ts_list[0], new_columns, level_names[i]) for i, x in enumerate(param_list)]
    else:
        # Some indicators don&#39;t have any params
        new_columns = to_2d(ts_list[0]).columns
        new_ts_list = list(ts_list)
        mapper_list = []
    output_list = list(map(lambda x: wrap_output(x, ts_list[0], new_columns), output_list))
    if len(mapper_list) &gt; 1:
        # Tuple object is a mapper that accepts tuples of parameters
        tuple_mapper = build_tuple_mapper(mapper_list, new_columns, tuple(level_names))
        mapper_list.append(tuple_mapper)
    return new_ts_list, output_list, param_list, mapper_list, other_list


def perform_init_checks(ts_list, output_list, param_list, mapper_list, name):
    for ts in ts_list:
        check_type(ts, (pd.Series, pd.DataFrame))
        ts.vbt.timeseries.validate()
    for i in range(1, len(ts_list) + len(output_list)):
        check_same_meta((ts_list + output_list)[i-1], (ts_list + output_list)[i])
    for i in range(1, len(param_list)):
        check_same_shape(param_list[i-1], param_list[i])
    for mapper in mapper_list:
        check_type(mapper, pd.Series)
        check_same_index(to_2d(ts_list[0]).iloc[0, :], mapper)
    check_type(name, str)


def is_equal(obj, other, multiple=False, name=&#39;is_equal&#39;, as_columns=None, **kwargs):
    if multiple:
        if as_columns is None:
            as_columns = index_from_values(other, name=name)
        return obj.vbt.combine_with_multiple(other, combine_func=np.equal, as_columns=as_columns, concat=True, **kwargs)
    return obj.vbt.combine_with(other, combine_func=np.equal, **kwargs)


def is_above(obj, other, multiple=False, name=&#39;is_above&#39;, as_columns=None, **kwargs):
    if multiple:
        if as_columns is None:
            as_columns = index_from_values(other, name=name)
        return obj.vbt.combine_with_multiple(other, combine_func=np.greater, as_columns=as_columns, concat=True, **kwargs)
    return obj.vbt.combine_with(other, combine_func=np.greater, **kwargs)


def is_below(obj, other, multiple=False, name=&#39;is_below&#39;, as_columns=None, **kwargs):
    if multiple:
        if as_columns is None:
            as_columns = index_from_values(other, name=name)
        return obj.vbt.combine_with_multiple(other, combine_func=np.less, as_columns=as_columns, concat=True, **kwargs)
    return obj.vbt.combine_with(other, combine_func=np.less, **kwargs)


class IndicatorFactory():
    def __init__(self,
                 ts_names=[&#39;ts&#39;],
                 param_names=[&#39;param&#39;],
                 output_names=[&#39;output&#39;],
                 name=&#39;custom&#39;,
                 custom_properties={}):
        &#34;&#34;&#34;A factory for creating new indicators.

        Args:
            ts_names (list of str): A list of names of input time-series objects. 
                Defaults to [&#39;ts&#39;].
            param_names (list of str): A list of names of parameters. 
                Defaults to [&#39;param&#39;].
            output_names (list of str): A list of names of outputs time-series objects. 
                Defaults to [&#39;output&#39;].
            name (str): A short name of the indicator. 
                Defaults to &#39;custom&#39;.
            custom_properties (dict, optional): A dictionary with user-defined functions that will be
                bound to the indicator class and wrapped with `@cached_property`.

        Each indicator is basically a pipeline that

        * Accepts a set of time-series objects (for example, OHLCV data)
        * Accepts a set of parameter arrays (for example, rolling windows)
        * Accepts other relevant arguments and keyword arguments
        * Performs calculations to produce new time-series objects (for example, rolling average)

        This pipeline can be well standardized, which is done by this indicatory factory.

        On top of this pipeline, it also does the following:

        * Creates a new indicator class
        * Creates an `__init__` method where it stores all inputs, outputs, and other artifacts

        !!! note
            The `__init__` method is never used for running the indicator, for this use `from_params`.
            The reason for this is indexing, which requires a clean `__init__` method for creating 
            a new indicator object with newly indexed attributes.

        * Creates a `from_params` method that runs the main pipeline using `vectorbt.indicators.from_params_pipeline`
        * Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
        * Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
        * Adds user-defined properties
        * Adds common comparison methods for all inputs, outputs and properties, e.g., crossovers

        Consider the following smaller price dataframe `price_sm`:

        ```python-repl
        &gt;&gt;&gt; index = pd.Index([
        ...     datetime(2018, 1, 1),
        ...     datetime(2018, 1, 2),
        ...     datetime(2018, 1, 3),
        ...     datetime(2018, 1, 4),
        ...     datetime(2018, 1, 5),
        ... ])
        &gt;&gt;&gt; price_sm = pd.DataFrame({
        ...     &#39;a&#39;: [1, 2, 3, 4, 5], 
        ...     &#39;b&#39;: [5, 4, 3, 2, 1]}, index=index).astype(float)
        &gt;&gt;&gt; print(price_sm)
                      a    b
        2018-01-01  1.0  5.0
        2018-01-02  2.0  4.0
        2018-01-03  3.0  3.0
        2018-01-04  4.0  2.0
        2018-01-05  5.0  1.0
        ```

        For each column in the dataframe, let&#39;s calculate a simple moving average and get signals 
        of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

        A naive way of doing this:

        ```python-repl
        &gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
        ...     price_sm.rolling(window=2).mean(), 
        ...     price_sm.rolling(window=3).mean(), 
        ...     as_columns=pd.Index([2, 3], name=&#39;ma_window&#39;))
        &gt;&gt;&gt; print(ma_df)
        ma_window     2    2    3    3
                      a    b    a    b
        2018-01-01  NaN  NaN  NaN  NaN
        2018-01-02  1.5  4.5  NaN  NaN
        2018-01-03  2.5  3.5  2.0  4.0
        2018-01-04  3.5  2.5  3.0  3.0
        2018-01-05  4.5  1.5  4.0  2.0

        &gt;&gt;&gt; above_signals = (price_sm.vbt.tile(2).vbt &gt; ma_df)
        &gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
        &gt;&gt;&gt; print(above_signals)
        ma_window       2      2      3      3
                        a      b      a      b
        2018-01-01  False  False  False  False
        2018-01-02   True  False  False  False
        2018-01-03  False  False   True  False
        2018-01-04  False  False  False  False
        2018-01-05  False  False  False  False

        &gt;&gt;&gt; below_signals = (price_sm.vbt.tile(2).vbt &lt; ma_df)
        &gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
        &gt;&gt;&gt; print(below_signals)
        ma_window       2      2      3      3
                        a      b      a      b
        2018-01-01  False  False  False  False
        2018-01-02  False   True  False  False
        2018-01-03  False  False  False   True
        2018-01-04  False  False  False  False
        2018-01-05  False  False  False  False
        ```

        Now the same using `vectorbt.indicators.IndicatorFactory`:

        ```python-repl
        &gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
        ...     ts_names=[&#39;price_sm&#39;],
        ...     param_names=[&#39;window&#39;],
        ...     output_names=[&#39;ma&#39;],
        ...     name=&#39;myma&#39;
        ... ).from_apply_func(vbt.timeseries.rolling_mean_nb)

        &gt;&gt;&gt; myma = MyMA.from_params(price_sm, [2, 3])
        &gt;&gt;&gt; above_signals = myma.price_sm_above(myma.ma, crossover=True)
        &gt;&gt;&gt; below_signals = myma.price_sm_below(myma.ma, crossover=True)
        ```

        It not only produced the handy `from_params` method, but generated a whole infrastructure to be run with
        an arbitrary number of windows. 

        For all our inputs in `ts_names` and outputs in `output_names`, it created a bunch of comparison methods 
        for generating signals, such as `above`, `below` and `equal` (use `doc()`): 

        ```python-repl
        &#39;ma_above&#39;
        &#39;ma_below&#39;
        &#39;ma_equal&#39;
        &#39;price_sm_above&#39;
        &#39;price_sm_below&#39;
        &#39;price_sm_equal&#39;
        ```

        Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time-series objects with an 
        arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
        to multiple objects at once, for example:

        ```python-repl
        &gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
        myma_ma_above    1.5    1.5    1.5    1.5    2.5    2.5    2.5    2.5
        myma_window        2      2      3      3      2      2      3      3
                           a      b      a      b      a      b      a      b
        2018-01-01     False  False  False  False  False  False  False  False
        2018-01-02     False   True  False  False  False   True  False  False
        2018-01-03      True   True   True   True  False   True  False   True
        2018-01-04      True   True   True   True   True  False   True   True
        2018-01-05      True  False   True   True   True  False   True  False
        ```

        `vectorbt.indicators.IndicatorFactory` also attached pandas indexing to the indicator class: 

        ```python-repl
        &#39;iloc&#39;
        &#39;loc&#39;
        &#39;window_loc&#39;
        &#39;xs&#39;
        ```

        This makes accessing rows and columns by labels, integer positions, and parameters much easier.

        The other advantage of using `vectorbt.indicators.IndicatorFactory` is broadcasting:

        * Passing multiple time-series objects will broadcast them to the same shape and index/columns

        ```python-repl
        &gt;&gt;&gt; price_sm2 = price_sm.copy() + 1
        &gt;&gt;&gt; price_sm2.columns = [&#39;a2&#39;, &#39;b2&#39;]

        &gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
        ...     ts_names=[&#39;price_sm&#39;, &#39;price_sm2&#39;],
        ...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
        ... ).from_apply_func(
        ...     lambda price_sm, price_sm2, p1, p2: price_sm * p1 + price_sm2 * p2
        ... )

        &gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm2, 1, 2)
        &gt;&gt;&gt; print(myInd.price_sm)
                      a    b
                     a2   b2
        2018-01-01  1.0  5.0
        2018-01-02  2.0  4.0
        2018-01-03  3.0  3.0
        2018-01-04  4.0  2.0
        2018-01-05  5.0  1.0
        &gt;&gt;&gt; print(myInd.price_sm2)
                      a    b
                     a2   b2
        2018-01-01  2.0  6.0
        2018-01-02  3.0  5.0
        2018-01-03  4.0  4.0
        2018-01-04  5.0  3.0
        2018-01-05  6.0  2.0
        ```

        * Passing multiple parameters will broadcast them to arrays of the same shape

        ```python-repl
        &gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm2, 1, 2)
        &gt;&gt;&gt; print(myInd._p1_array)
        &gt;&gt;&gt; print(myInd._p2_array)
        [1]
        [2]

        &gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm2, 1, [2, 3])
        &gt;&gt;&gt; print(myInd._p1_array)
        &gt;&gt;&gt; print(myInd._p2_array)
        [1 1]
        [2 3]

        &gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm2, [1, 2], [3, 4], param_product=True)
        &gt;&gt;&gt; print(myInd._p1_array)
        &gt;&gt;&gt; print(myInd._p2_array)
        [1 1 2 2]
        [3 4 3 4]
        ```

        This way, you can define parameter combinations of any order and shape. 
        &#34;&#34;&#34;
        self.ts_names = ts_names
        self.param_names = param_names
        self.output_names = output_names
        self.name = name
        self.custom_properties = custom_properties

    def from_custom_func(self, custom_func, pass_lists=False):
        &#34;&#34;&#34;Build indicator class around a custom calculation function.

        !!! note
            `custom_func` shouldn&#39;t be Numba-compiled, since passed time series are all pandas objects.
            Instead, define your `custom_func` as a regular Python function where you should
            convert all inputs into NumPy arrays, and then pass them to your Numba-compiled function.

            Also, in contrast to `IndicatorFactory.from_apply_func`, it&#39;s up to you to handle caching
            and concatenate columns for each parameter (for example, by using `vectorbt.utils.apply_and_concat_one`).
            Also, you must ensure that each output array has an appropriate number of columns, which
            is the number of columns in input time series multiplied by the number of parameter values.

        Args:
            custom_func (function): A function that takes broadcasted time series corresponding 
                to `ts_names`, broadcasted parameter arrays corresponding to `param_names`, and other 
                arguments and keyword arguments, and returns outputs corresponding to `output_names` 
                and other objects that are then returned with the indicator class instance.
            pass_lists (bool): If True, passes arguments as lists. Otherwise, passes them using 
                starred expression. Defaults to False.
        Returns:
            `CustomIndicator`, and optionally other objects that are returned by `custom_func`
            and exceed `output_names`.
        Examples:
            The following example does the same as the example in `IndicatorFactory.from_apply_func`.

            ```python-repl
            &gt;&gt;&gt; @njit
            &gt;&gt;&gt; def apply_func_nb(i, ts1, ts2, p1, p2, arg1):
            ...     return ts1 * p1[i] + arg1, ts2 * p2[i] + arg1

            &gt;&gt;&gt; def custom_func(ts1, ts2, p1, p2, *args):
            ...     return vbt.utils.apply_and_concat_multiple_nb(len(p1), apply_func_nb, 
            ...         ts1.vbt.to_2d_array(), ts2.vbt.to_2d_array(), p1, p2, *args)

            &gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
            ...     ts_names=[&#39;ts1&#39;, &#39;ts2&#39;],
            ...     param_names=[&#39;p1&#39;, &#39;p2&#39;],
            ...     output_names=[&#39;o1&#39;, &#39;o2&#39;]
            ... ).from_custom_func(custom_func)

            &gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm * 2, [1, 2], [3, 4], 100)
            &gt;&gt;&gt; print(myInd.o1)
            custom_p1       1      1      2      2
            custom_p2       3      3      4      4
                            a      b      a      b
            2018-01-01  101.0  105.0  102.0  110.0
            2018-01-02  102.0  104.0  104.0  108.0
            2018-01-03  103.0  103.0  106.0  106.0
            2018-01-04  104.0  102.0  108.0  104.0
            2018-01-05  105.0  101.0  110.0  102.0
            &gt;&gt;&gt; print(myInd.o2)
            custom_p1       1      1      2      2
            custom_p2       3      3      4      4
                            a      b      a      b
            2018-01-01  106.0  130.0  108.0  140.0
            2018-01-02  112.0  124.0  116.0  132.0
            2018-01-03  118.0  118.0  124.0  124.0
            2018-01-04  124.0  112.0  132.0  116.0
            2018-01-05  130.0  106.0  140.0  108.0
            ```
        &#34;&#34;&#34;

        CustomIndicator = type(&#39;CustomIndicator&#39;, (), {})
        ts_names = self.ts_names
        param_names = self.param_names
        output_names = self.output_names
        name = self.name
        custom_properties = self.custom_properties

        # For name and each input and output, create read-only properties
        prop = property(lambda self: self._name)
        prop.__doc__ = f&#34;&#34;&#34;Name of the indicator (read-only).&#34;&#34;&#34;
        setattr(CustomIndicator, &#39;name&#39;, prop)

        for ts_name in ts_names:
            prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))
            prop.__doc__ = f&#34;&#34;&#34;Input time series (read-only).&#34;&#34;&#34;
            setattr(CustomIndicator, ts_name, prop)

        for output_name in output_names:
            prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))
            prop.__doc__ = f&#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
            setattr(CustomIndicator, output_name, prop)

        for prop in custom_properties.values():
            if prop.__doc__ is None:
                prop.__doc__ = f&#34;&#34;&#34;Custom property.&#34;&#34;&#34;

        # Add __init__ method
        def __init__(self, ts_list, output_list, param_list, mapper_list, name):
            &#34;&#34;&#34;Performs checks on pipeline artifacts and stores them as instance attributes.&#34;&#34;&#34;
            perform_init_checks(ts_list, output_list, param_list, mapper_list, name)

            for i, ts_name in enumerate(ts_names):
                setattr(self, f&#39;_{ts_name}&#39;, ts_list[i])
            for i, output_name in enumerate(output_names):
                setattr(self, f&#39;_{output_name}&#39;, output_list[i])
            for i, param_name in enumerate(param_names):
                setattr(self, f&#39;_{param_name}_array&#39;, param_list[i])
                setattr(self, f&#39;_{param_name}_mapper&#39;, mapper_list[i])
            if len(param_names) &gt; 1:
                setattr(self, &#39;_tuple_mapper&#39;, mapper_list[-1])
            setattr(self, &#39;_name&#39;, name)

        setattr(CustomIndicator, &#39;__init__&#39;, __init__)

        # Add from_params method
        @classmethod
        def from_params(cls, *args, name=name.lower(), return_raw=False, **kwargs):
            &#34;&#34;&#34;Runs the pipeline and initializes the class.&#34;&#34;&#34;
            level_names = tuple([name + &#39;_&#39; + param_name for param_name in param_names])
            args = list(args)
            ts_list = args[:len(ts_names)]
            param_list = args[len(ts_names):len(ts_names)+len(param_names)]
            new_args = args[len(ts_names)+len(param_names):]
            results = from_params_pipeline(
                ts_list, param_list, level_names, len(output_names),
                custom_func, *new_args, pass_lists=pass_lists, return_raw=return_raw, **kwargs)
            if return_raw or kwargs.get(&#39;return_cache&#39;, False):
                return results
            new_ts_list, output_list, new_param_list, mapper_list, other_list = results
            obj = cls(new_ts_list, output_list, new_param_list, mapper_list, name)
            if len(other_list) &gt; 0:
                return (obj,) + other_list
            return obj

        setattr(CustomIndicator, &#39;from_params&#39;, from_params)

        # Add indexing methods
        def indexing_func(obj, loc_pandas_func):
            ts_list = []
            for ts_name in ts_names:
                ts_list.append(loc_pandas_func(getattr(obj, ts_name)))
            output_list = []
            for output_name in output_names:
                output_list.append(loc_pandas_func(getattr(obj, output_name)))
            param_list = []
            for param_name in param_names:
                # TODO: adapt params array according to the indexing operation
                param_list.append(getattr(obj, f&#39;_{param_name}_array&#39;))
            mapper_list = []
            for param_name in param_names:
                mapper_list.append(loc_mapper(
                    getattr(obj, f&#39;_{param_name}_mapper&#39;),
                    getattr(obj, ts_names[0]), loc_pandas_func))
            if len(param_names) &gt; 1:
                mapper_list.append(loc_mapper(obj._tuple_mapper, getattr(obj, ts_names[0]), loc_pandas_func))

            return obj.__class__(ts_list, output_list, param_list, mapper_list, obj.name)

        CustomIndicator = add_indexing(indexing_func)(CustomIndicator)
        for i, param_name in enumerate(param_names):
            CustomIndicator = add_param_indexing(param_name, indexing_func)(CustomIndicator)
        if len(param_names) &gt; 1:
            CustomIndicator = add_param_indexing(&#39;tuple&#39;, indexing_func)(CustomIndicator)

        # Add user-defined properties
        for prop_name, prop_func in custom_properties.items():
            if not isinstance(prop_func, property):
                prop_func = cached_property(prop_func)
            setattr(CustomIndicator, prop_name, prop_func)

        # Add comparison methods for all inputs, outputs, and user-defined properties
        comparison_attrs = set(ts_names + output_names + list(custom_properties.keys()))
        for attr in comparison_attrs:
            def assign_comparison_method(func_name, comparison_func, attr=attr):
                def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
                    if isinstance(other, self.__class__):
                        other = getattr(other, attr)
                    if name is None:
                        if attr == self.name:
                            name = f&#39;{self.name}_{func_name}&#39;
                        else:
                            name = f&#39;{self.name}_{attr}_{func_name}&#39;
                    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
                    if crossover:
                        return result.vbt.signals.nst(wait+1, after_false=True)
                    return result
                comparison_method.__doc__ = f&#34;&#34;&#34;Returns True when `{attr}` is {func_name} `other`. 

                Set `crossover` to True to return the first True after crossover. Specify `wait` to return 
                True only when `{attr}` is {func_name} for a number of time steps in a row after crossover.
                
                Both will be broadcasted together. Set `multiple` to True to combine with multiple arguments. 
                For more keyword arguments, see `vectorbt.utils.Base_Accessor.combine_with`.&#34;&#34;&#34;
                setattr(CustomIndicator, f&#39;{attr}_{func_name}&#39;, comparison_method)

            assign_comparison_method(&#39;above&#39;, is_above)
            assign_comparison_method(&#39;below&#39;, is_below)
            assign_comparison_method(&#39;equal&#39;, is_equal)

        return CustomIndicator

    def from_apply_func(self, apply_func, caching_func=None):
        &#34;&#34;&#34;Build indicator class around a custom apply function.

        In contrast to `IndicatorFactory.from_custom_func`, this method handles a lot of things for you,
        such as caching, parameter selection, and concatenation. All you have to do is to write `apply_func`
        that accepts a selection of parameters (single values as opposed to multiple values in 
        `IndicatorFactory.from_custom_func`) and does the calculation. It then automatically concatenates
        the results into a single array per output.

        While this approach is much more simpler, it is also less flexible, since you can only work with 
        one parameter selection at a time, and can&#39;t view all parameters.

        !!! note
            If `apply_func` is a Numba-compiled function: 

            * All inputs are automatically converted to NumPy arrays
            * Each argument in `*args` must be of a Numba-compatible type
            * You cannot pass keyword arguments
            * Your outputs must be arrays of the same shape, data type and data order

        Args:
            apply_func (function): A function (can be Numba-compiled) that takes broadcasted time 
                series arrays corresponding to `ts_names`, single parameter selection corresponding 
                to `param_names`, and other arguments and keyword arguments, and returns outputs 
                corresponding to `output_names`.
            caching_func (function): A caching function to preprocess data beforehand.
                All returned objects will be passed as additional arguments to `apply_func`.
        Returns:
            `CustomIndicator`
        Examples:
            ```python-repl
            &gt;&gt;&gt; @njit
            ... def apply_func_nb(ts1, ts2, p1, p2, arg1):
            ...     return ts1 * p1 + arg1, ts2 * p2 + arg1

            &gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
            ...     ts_names=[&#39;ts1&#39;, &#39;ts2&#39;],
            ...     param_names=[&#39;p1&#39;, &#39;p2&#39;],
            ...     output_names=[&#39;o1&#39;, &#39;o2&#39;]
            ... ).from_apply_func(apply_func_nb)

            &gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm * 2, [1, 2], [3, 4], 100)
            &gt;&gt;&gt; print(myInd.o1)
            custom_p1       1      1      2      2
            custom_p2       3      3      4      4
                            a      b      a      b
            2018-01-01  101.0  105.0  102.0  110.0
            2018-01-02  102.0  104.0  104.0  108.0
            2018-01-03  103.0  103.0  106.0  106.0
            2018-01-04  104.0  102.0  108.0  104.0
            2018-01-05  105.0  101.0  110.0  102.0
            &gt;&gt;&gt; print(myInd.o2)
            custom_p1       1      1      2      2
            custom_p2       3      3      4      4
                            a      b      a      b
            2018-01-01  106.0  130.0  108.0  140.0
            2018-01-02  112.0  124.0  116.0  132.0
            2018-01-03  118.0  118.0  124.0  124.0
            2018-01-04  124.0  112.0  132.0  116.0
            2018-01-05  130.0  106.0  140.0  108.0
            ```
        &#34;&#34;&#34;
        output_names = self.output_names

        num_outputs = len(output_names)

        if is_numba_func(apply_func):
            apply_and_concat_func = apply_and_concat_multiple_nb if num_outputs &gt; 1 else apply_and_concat_one_nb

            @njit
            def select_params_func_nb(i, apply_func, ts_list, param_tuples, *args):
                # Select the next tuple of parameters
                return apply_func(*ts_list, *param_tuples[i], *args)

            def custom_func(ts_list, param_list, *args, return_cache=False, cache=None):
                # avoid deprecation warnings
                typed_ts_list = tuple(map(lambda x: x.vbt.to_2d_array(), ts_list))
                typed_param_tuples = List()
                for param_tuple in list(zip(*param_list)):
                    typed_param_tuples.append(param_tuple)

                # Caching
                if cache is None and caching_func is not None:
                    cache = caching_func(*typed_ts_list, *param_list, *args)
                if return_cache:
                    return cache
                if cache is None:
                    cache = ()
                if not isinstance(cache, (tuple, list, List)):
                    cache = (cache,)

                return apply_and_concat_func(
                    param_list[0].shape[0],
                    select_params_func_nb,
                    apply_func,
                    typed_ts_list,
                    typed_param_tuples,
                    *args,
                    *cache)
        else:
            apply_and_concat_func = apply_and_concat_multiple if num_outputs &gt; 1 else apply_and_concat_one

            def select_params_func(i, apply_func, ts_list, param_list, *args, **kwargs):
                    # Select the next tuple of parameters
                param_is = list(map(lambda x: x[i], param_list))
                return apply_func(*ts_list, *param_is, *args, **kwargs)

            def custom_func(ts_list, param_list, *args, return_cache=False, **kwargs):
                # Caching
                if cache is None and caching_func is not None:
                    cache = caching_func(*typed_ts_list, *param_list, *args, **kwargs)
                if return_cache:
                    return cache
                if cache is None:
                    cache = ()
                if not isinstance(cache, (tuple, list, List)):
                    cache = (cache,)

                return apply_and_concat_func(
                    param_list[0].shape[0],
                    select_params_func,
                    apply_func,
                    ts_list,
                    param_list,
                    *args,
                    *cache,
                    **kwargs)

        return self.from_custom_func(custom_func, pass_lists=True)

# ############# MA ############# #


@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], b1[:]), cache=True)
def ma_caching_nb(ts, windows, ewms):
    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                ma = ewm_mean_nb(ts, windows[i])
            else:
                ma = rolling_mean_nb(ts, windows[i])
            cache_dict[(windows[i], int(ewms[i]))] = ma
    return cache_dict


@njit(f8[:, :](f8[:, :], i8, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def ma_apply_func_nb(ts, window, ewm, cache_dict):
    return cache_dict[(window, int(ewm))]


MA = IndicatorFactory(
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;ma&#39;],
    name=&#39;ma&#39;
).from_apply_func(ma_apply_func_nb, caching_func=ma_caching_nb)


class MA(MA):
    &#34;&#34;&#34;A moving average (MA) is a widely used indicator in technical analysis that helps smooth out 
    price action by filtering out the “noise” from random short-term price fluctuations. 

    See [Moving Average (MA)](https://www.investopedia.com/terms/m/movingaverage.asp).

    Use `MA.from_params` or `MA.from_combinations` methods to run the indicator.&#34;&#34;&#34;

    @classmethod
    def from_params(cls, ts, window, ewm=False, **kwargs):
        &#34;&#34;&#34;Calculate moving average `MA.ma` from time series `ts` and parameters `window` and `ewm`.

        Args:
            ts (pandas_like): Time series (such as price).
            window (int or array_like of int): Size of the moving window. Can be one or more values.
            ewm (bool or array_like of bool): If True, uses exponential moving average, otherwise 
                simple moving average. Can be one or more values. Defaults to False.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.from_params_pipeline.`
        Examples:
            ```python-repl
            &gt;&gt;&gt; ma = vbt.MA.from_params(price, [10, 20], ewm=[False, True])

            &gt;&gt;&gt; print(ma.ma)
            ma_window         10        20
            ma_ewm         False      True 
            2018-01-01       NaN       NaN
            2018-01-02       NaN       NaN
            2018-01-03       NaN       NaN
            ...              ...       ...
            2018-04-08  5.999866  6.141290
            2018-04-09  6.040747  6.117779
            2018-04-10  5.915199  6.021119

            [100 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        return super().from_params(ts, window, ewm, **kwargs)

    @classmethod
    def from_combinations(cls, ts, windows, r, ewm=False, names=None, **kwargs):
        &#34;&#34;&#34;Calculate multiple moving averages according to `itertools.combinations`.

        Args:
            ts (pandas_like): Time series (such as price).
            windows (array_like of int): Size of the moving window. Must be multiple.
            r (int): The number of `vectorbt.indicators.MA` instances to combine.
            ewm (bool or array_like of bool): If True, uses exponential moving average, otherwise 
                simple moving average. Can be one or more values. Defaults to False.
            names (list of str, optional): A list of names for each `vectorbt.indicators.MA` instance.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.from_params_pipeline.`
        Examples:
            ```python-repl
            &gt;&gt;&gt; fast_ma, slow_ma = vbt.MA.from_combinations(price, 
            ...     [10, 20, 30], 2, ewm=[False, False, True], names=[&#39;fast&#39;, &#39;slow&#39;])

            &gt;&gt;&gt; print(fast_ma.ma)

            fast_window        10        10        20
            fast_ewm        False     False     False
            2018-01-01        NaN       NaN       NaN
            2018-01-02        NaN       NaN       NaN
            2018-01-03        NaN       NaN       NaN
            ...               ...       ...       ...
            2018-04-08   5.999866  5.999866  5.983928
            2018-04-09   6.040747  6.040747  5.931313
            2018-04-10   5.915199  5.915199  5.868436

            [100 rows x 3 columns]

            &gt;&gt;&gt; print(slow_ma.ma)
            slow_window        20        30        30
            slow_ewm        False      True      True 
            2018-01-01        NaN       NaN       NaN
            2018-01-02        NaN       NaN       NaN
            2018-01-03        NaN       NaN       NaN
            ...               ...       ...       ...
            2018-04-08   5.983928  6.356696  6.356696
            2018-04-09   5.931313  6.326833  6.326833
            2018-04-10   5.868436  6.247768  6.247768

            [100 rows x 3 columns]
            ```

            The naive way without caching is the follows:
            ```py
            window_combs = itertools.combinations([10, 20, 30], 2)
            ewm_combs = itertools.combinations([False, False, True], 2)
            fast_windows, slow_windows = np.asarray(list(window_combs)).transpose()
            fast_ewms, slow_ewms = np.asarray(list(ewm_combs)).transpose()

            fast_ma = vbt.MA.from_params(price, fast_windows, fast_ewms, name=&#39;fast&#39;)
            slow_ma = vbt.MA.from_params(price, slow_windows, slow_ewms, name=&#39;slow&#39;)
            ```

            Having this, you can then compare those `vectorbt.indicators.MA` instances together:
            ```python-repl
            &gt;&gt;&gt; entry_signals = fast_ma.ma_above(slow_ma, crossover=True)
            &gt;&gt;&gt; exit_signals = fast_ma.ma_below(slow_ma, crossover=True)

            &gt;&gt;&gt; print(fast_signals)
            fast_window     10     10     20
            fast_ewm     False  False  False
            slow_window     20     30     30
            slow_ewm     False  True   True 
            2018-01-01   False  False  False
            2018-01-02   False  False  False
            2018-01-03   False  False  False
            ...            ...    ...    ...
            2018-04-08   False  False  False
            2018-04-09   False  False  False
            2018-04-10   False  False  False

            [100 rows x 3 columns]
            ```

            Notice the new column hierarchy the `MA.ma_above` method created for you. You can use
            it for indexing as follows:

            ```py
            fig = entry_signals[(10, False, 20, False)].vbt.signals.plot(name=&#39;Entries&#39;)
            exit_signals[(10, False, 20, False)].vbt.signals.plot(name=&#39;Exits&#39;, fig=fig)
            ```
            ![](img/MA_from_combinations.png)
        &#34;&#34;&#34;

        if names is None:
            names = [&#39;ma&#39; + str(i+1) for i in range(r)]
        windows, ewm = broadcast(windows, ewm, writeable=True)
        cache_dict = cls.from_params(ts, windows, ewm=ewm, return_cache=True, **kwargs)
        param_lists = zip(*itertools.combinations(zip(windows, ewm), r))
        mas = []
        for i, param_list in enumerate(param_lists):
            i_windows, i_ewm = zip(*param_list)
            mas.append(cls.from_params(ts, i_windows, ewm=i_ewm, cache=cache_dict, name=names[i], **kwargs))
        return tuple(mas)

    def plot(self,
             ts_name=None,
             ma_name=None,
             ts_trace_kwargs={},
             ma_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot moving average `MA.ma` against time series `MA.ts`.

        Args:
            ts_name (str): Name of trace for `MA.ts`.
            ma_name (str): Name of trace for `MA.ma`.
            ts_trace_kwargs (dict, optional): Keyword arguments passed to `pandas.vbt.timeseries` of `MA.ts`.
            ma_trace_kwargs (dict, optional): Keyword arguments passed to `pandas.vbt.timeseries` of `MA.ma`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Examples:
            ```py
            ma[(10, False)].plot()
            ```

            ![](img/MA.png)&#34;&#34;&#34;
        check_type(self.ts, pd.Series)
        check_type(self.ma, pd.Series)

        if ts_name is None:
            ts_name = f&#39;Price ({self.name})&#39;
        if ma_name is None:
            ma_name = f&#39;MA ({self.name})&#39;

        fig = self.ts.vbt.timeseries.plot(name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.ma.vbt.timeseries.plot(name=ma_name, trace_kwargs=ma_trace_kwargs, fig=fig)

        return fig


fix_class_for_pdoc(MA)

# ############# MSTD ############# #


@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], b1[:]), cache=True)
def mstd_caching_nb(ts, windows, ewms):
    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                mstd = ewm_std_nb(ts, windows[i])
            else:
                mstd = rolling_std_nb(ts, windows[i])
            cache_dict[(windows[i], int(ewms[i]))] = mstd
    return cache_dict


@njit(f8[:, :](f8[:, :], i8, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def mstd_apply_func_nb(ts, window, ewm, cache_dict):
    return cache_dict[(window, int(ewm))]


MSTD = IndicatorFactory(
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;mstd&#39;],
    name=&#39;mstd&#39;
).from_apply_func(mstd_apply_func_nb, caching_func=mstd_caching_nb)


class MSTD(MSTD):
    @classmethod
    def from_params(cls, ts, window, ewm=False, **kwargs):
        return super().from_params(ts, window, ewm, **kwargs)

    def plot(self,
             name=None,
             trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.mstd, pd.Series)

        if name is None:
            name = f&#39;MSTD ({self.name})&#39;

        fig = self.mstd.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_pdoc(MSTD)

# ############# BollingerBands ############# #


@njit(UniTuple(DictType(UniTuple(i8, 2), f8[:, :]), 2)(f8[:, :], i8[:], b1[:], f8[:]), cache=True)
def bb_caching_nb(ts, windows, ewms, alphas):
    ma_cache_dict = ma_caching_nb(ts, windows, ewms)
    mstd_cache_dict = mstd_caching_nb(ts, windows, ewms)
    return ma_cache_dict, mstd_cache_dict


@njit(UniTuple(f8[:, :], 3)(f8[:, :], i8, b1, f8, DictType(UniTuple(i8, 2), f8[:, :]), DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def bb_apply_func_nb(ts, window, ewm, alpha, ma_cache_dict, mstd_cache_dict):
    # Calculate lower, middle and upper bands
    ma = np.copy(ma_cache_dict[(window, int(ewm))])
    mstd = np.copy(mstd_cache_dict[(window, int(ewm))])
    # # (MA + Kσ), MA, (MA - Kσ)
    return ma + alpha * mstd, ma, ma - alpha * mstd


BollingerBands = IndicatorFactory(
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;, &#39;alpha&#39;],
    output_names=[&#39;upper_band&#39;, &#39;middle_band&#39;, &#39;lower_band&#39;],
    name=&#39;bb&#39;,
    custom_properties=dict(
        percent_b=lambda self: (self.ts - self.lower_band) / (self.upper_band - self.lower_band),
        bandwidth=lambda self: (self.upper_band - self.lower_band) / self.middle_band
    )
).from_apply_func(bb_apply_func_nb, caching_func=bb_caching_nb)


class BollingerBands(BollingerBands):
    @classmethod
    def from_params(cls, ts, window=20, ewm=False, alpha=2, **kwargs):
        alpha = np.asarray(alpha).astype(np.float64)
        return super().from_params(ts, window, ewm, alpha, **kwargs)

    def plot(self,
             ts_name=None,
             upper_band_name=None,
             middle_band_name=None,
             lower_band_name=None,
             ts_trace_kwargs={},
             upper_band_trace_kwargs={},
             middle_band_trace_kwargs={},
             lower_band_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.ts, pd.Series)
        check_type(self.upper_band, pd.Series)
        check_type(self.middle_band, pd.Series)
        check_type(self.lower_band, pd.Series)

        if ts_name is None:
            ts_name = f&#39;Price ({self.name})&#39;
        if upper_band_name is None:
            upper_band_name = f&#39;Upper Band ({self.name})&#39;
        if middle_band_name is None:
            middle_band_name = f&#39;Middle Band ({self.name})&#39;
        if lower_band_name is None:
            lower_band_name = f&#39;Lower Band ({self.name})&#39;

        upper_band_trace_kwargs = {**dict(line=dict(color=&#39;grey&#39;)), **upper_band_trace_kwargs}  # default kwargs
        lower_band_trace_kwargs = {**dict(line=dict(color=&#39;grey&#39;)), **lower_band_trace_kwargs}

        fig = self.ts.vbt.timeseries.plot(
            name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.upper_band.vbt.timeseries.plot(
            name=upper_band_name, trace_kwargs=upper_band_trace_kwargs, fig=fig)
        fig = self.middle_band.vbt.timeseries.plot(
            name=middle_band_name, trace_kwargs=middle_band_trace_kwargs, fig=fig)
        fig = self.lower_band.vbt.timeseries.plot(
            name=lower_band_name, trace_kwargs=lower_band_trace_kwargs, fig=fig)

        return fig


fix_class_for_pdoc(BollingerBands)


# ############# RSI ############# #

@njit(DictType(UniTuple(i8, 2), UniTuple(f8[:, :], 2))(f8[:, :], i8[:], b1[:]), cache=True)
def rsi_caching_nb(ts, windows, ewms):
    delta = diff_nb(ts)[1:, :]  # otherwise ewma will be all NaN
    up, down = delta.copy(), delta.copy()
    up = set_by_mask_nb(up, up &lt; 0, 0)
    down = np.abs(set_by_mask_nb(down, down &gt; 0, 0))
    # Cache
    cache_dict = dict()
    for i in range(windows.shape[0]):
        if (windows[i], int(ewms[i])) not in cache_dict:
            if ewms[i]:
                roll_up = ewm_mean_nb(up, windows[i])
                roll_down = ewm_mean_nb(down, windows[i])
            else:
                roll_up = rolling_mean_nb(up, windows[i])
                roll_down = rolling_mean_nb(down, windows[i])
            roll_up = prepend_nb(roll_up, 1, np.nan)  # bring to old shape
            roll_down = prepend_nb(roll_down, 1, np.nan)
            cache_dict[(windows[i], int(ewms[i]))] = roll_up, roll_down
    return cache_dict


@njit(f8[:, :](f8[:, :], i8, b1, DictType(UniTuple(i8, 2), UniTuple(f8[:, :], 2))), cache=True)
def rsi_apply_func_nb(ts, window, ewm, cache_dict):
    roll_up, roll_down = cache_dict[(window, int(ewm))]
    return 100 - 100 / (1 + roll_up / roll_down)


RSI = IndicatorFactory(
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;rsi&#39;],
    name=&#39;rsi&#39;
).from_apply_func(rsi_apply_func_nb, caching_func=rsi_caching_nb)


class RSI(RSI):
    @classmethod
    def from_params(cls, ts, window=14, ewm=False, **kwargs):
        return super().from_params(ts, window, ewm, **kwargs)

    def plot(self,
             name=None,
             trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.rsi, pd.Series)

        if name is None:
            name = f&#39;RSI ({self.name})&#39;

        fig = self.rsi.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_pdoc(RSI)


# ############# Stochastic ############# #


@njit(DictType(i8, UniTuple(f8[:, :], 2))(f8[:, :], f8[:, :], f8[:, :], i8[:], i8[:], b1[:]), cache=True)
def stoch_caching_nb(close_ts, high_ts, low_ts, k_windows, d_windows, ewms):
    cache_dict = dict()
    for i in range(k_windows.shape[0]):
        if k_windows[i] not in cache_dict:
            roll_min = rolling_min_nb(low_ts, k_windows[i])
            roll_max = rolling_max_nb(high_ts, k_windows[i])
            cache_dict[k_windows[i]] = roll_min, roll_max
    return cache_dict


@njit(UniTuple(f8[:, :], 2)(f8[:, :], f8[:, :], f8[:, :], i8, i8, b1, DictType(i8, UniTuple(f8[:, :], 2))), cache=True)
def stoch_apply_func_nb(close_ts, high_ts, low_ts, k_window, d_window, ewm, cache_dict):
    roll_min, roll_max = cache_dict[k_window]
    percent_k = 100 * (close_ts - roll_min) / (roll_max - roll_min)
    if ewm:
        percent_d = ewm_mean_nb(percent_k, d_window)
    else:
        percent_d = rolling_mean_nb(percent_k, d_window)
    percent_d[:k_window+d_window-2, :] = np.nan  # min_periods for ewm
    return percent_k, percent_d


Stochastic = IndicatorFactory(
    ts_names=[&#39;close_ts&#39;, &#39;high_ts&#39;, &#39;low_ts&#39;],
    param_names=[&#39;k_window&#39;, &#39;d_window&#39;, &#39;ewm&#39;],
    output_names=[&#39;percent_k&#39;, &#39;percent_d&#39;],
    name=&#39;stoch&#39;
).from_apply_func(stoch_apply_func_nb, caching_func=stoch_caching_nb)


class Stochastic(Stochastic):
    @classmethod
    def from_params(cls, close_ts, high_ts=None, low_ts=None, k_window=14, d_window=3, ewm=False, **kwargs):
        if high_ts is None:
            high_ts = close_ts
        if low_ts is None:
            low_ts = close_ts
        return super().from_params(close_ts, high_ts, low_ts, k_window, d_window, ewm, **kwargs)

    def crossover(self, **kwargs):
        above_signals = self.percent_k_above(self.percent_d, crossover=True, **kwargs)
        below_signals = self.percent_k_below(self.percent_d, crossover=True, **kwargs)
        return above_signals, below_signals

    def plot(self,
             percent_k_name=None,
             percent_d_name=None,
             percent_k_trace_kwargs={},
             percent_d_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.percent_k, pd.Series)
        check_type(self.percent_d, pd.Series)

        if percent_k_name is None:
            percent_k_name = f&#39;%K ({self.name})&#39;
        if percent_d_name is None:
            percent_d_name = f&#39;%D ({self.name})&#39;

        fig = self.percent_k.vbt.timeseries.plot(
            name=percent_k_name, trace_kwargs=percent_k_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.percent_d.vbt.timeseries.plot(
            name=percent_d_name, trace_kwargs=percent_d_trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_pdoc(Stochastic)


# ############# MACD ############# #

@njit(DictType(UniTuple(i8, 2), f8[:, :])(f8[:, :], i8[:], i8[:], i8[:], b1[:]), cache=True)
def macd_caching_nb(ts, fast_windows, slow_windows, signal_windows, ewms):
    return ma_caching_nb(ts, np.concatenate((fast_windows, slow_windows)), np.concatenate((ewms, ewms)))


@njit(UniTuple(f8[:, :], 4)(f8[:, :], i8, i8, i8, b1, DictType(UniTuple(i8, 2), f8[:, :])), cache=True)
def macd_apply_func_nb(ts, fast_window, slow_window, signal_window, ewm, cache_dict):
    fast_ma = cache_dict[(fast_window, int(ewm))]
    slow_ma = cache_dict[(slow_window, int(ewm))]
    macd_ts = fast_ma - slow_ma
    if ewm:
        signal_ts = ewm_mean_nb(macd_ts, signal_window)
    else:
        signal_ts = rolling_mean_nb(macd_ts, signal_window)
    signal_ts[:max(fast_window, slow_window)+signal_window-2, :] = np.nan  # min_periods for ewm
    return np.copy(fast_ma), np.copy(slow_ma), macd_ts, signal_ts


MACD = IndicatorFactory(
    ts_names=[&#39;ts&#39;],
    param_names=[&#39;fast_window&#39;, &#39;slow_window&#39;, &#39;signal_window&#39;, &#39;ewm&#39;],
    output_names=[&#39;fast_ma&#39;, &#39;slow_ma&#39;, &#39;macd&#39;, &#39;signal&#39;],
    name=&#39;macd&#39;,
    custom_properties=dict(
        histogram=lambda self: self.macd - self.signal,
    )
).from_apply_func(macd_apply_func_nb, caching_func=macd_caching_nb)


class MACD(MACD):
    @classmethod
    def from_params(cls, ts, fast_window=26, slow_window=12, signal_window=9, ewm=True, **kwargs):
        return super().from_params(ts, fast_window, slow_window, signal_window, ewm, **kwargs)

    def crossover(self, **kwargs):
        above_signals = self.macd_above(self.signal, crossover=True, **kwargs)
        below_signals = self.macd_below(self.signal, crossover=True, **kwargs)
        return above_signals, below_signals

    def plot(self,
             macd_name=None,
             signal_name=None,
             macd_trace_kwargs={},
             signal_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.macd, pd.Series)
        check_type(self.signal, pd.Series)

        if macd_name is None:
            macd_name = f&#39;MACD ({self.name})&#39;
        if signal_name is None:
            signal_name = f&#39;Signal ({self.name})&#39;

        fig = self.macd.vbt.timeseries.plot(
            name=macd_name, trace_kwargs=macd_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.signal.vbt.timeseries.plot(
            name=signal_name, trace_kwargs=signal_trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_pdoc(MACD)


# ############# OBV ############# #

@njit(f8[:, :](f8[:, :], f8[:, :]))
def obv_custom_func_nb(close_ts, volume_ts):
    obv = np.full_like(close_ts, np.nan)
    for col in range(close_ts.shape[1]):
        cumsum = 0
        for i in range(1, close_ts.shape[0]):
            if np.isnan(close_ts[i, col]) or np.isnan(close_ts[i-1, col]) or np.isnan(volume_ts[i, col]):
                continue
            if close_ts[i, col] &gt; close_ts[i-1, col]:
                cumsum += volume_ts[i, col]
            elif close_ts[i, col] &lt; close_ts[i-1, col]:
                cumsum += -volume_ts[i, col]
            obv[i, col] = cumsum
    return obv


def obv_custom_func(close_ts, volume_ts):
    return obv_custom_func_nb(close_ts.vbt.to_2d_array(), volume_ts.vbt.to_2d_array())


OBV = IndicatorFactory(
    ts_names=[&#39;close_ts&#39;, &#39;volume_ts&#39;],
    param_names=[],
    output_names=[&#39;obv&#39;],
    name=&#39;obv&#39;
).from_custom_func(obv_custom_func)


class OBV(OBV):
    @classmethod
    def from_params(cls, close_ts, volume_ts):
        return super().from_params(close_ts, volume_ts)

    def plot(self,
             name=None,
             trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.obv, pd.Series)

        if name is None:
            name = f&#39;OBV ({self.name})&#39;

        fig = self.obv.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

        return fig


fix_class_for_pdoc(OBV)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.indicators.from_params_pipeline"><code class="name flex">
<span>def <span class="ident">from_params_pipeline</span></span>(<span>ts_list, param_list, level_names, num_outputs, custom_func, *args, pass_lists=False, param_product=False, broadcast_kwargs={}, return_raw=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A pipeline for calculating an indicator, used by <code><a title="vectorbt.indicators.IndicatorFactory" href="#vectorbt.indicators.IndicatorFactory">IndicatorFactory</a></code>.</p>
<p>Does the following:</p>
<ul>
<li>Takes one or multiple time series objects in <code>ts_list</code> and broadcasts them</li>
</ul>
<pre><code class="python-repl">&gt;&gt;&gt; sr = pd.Series([1, 2], index=['x', 'y'])
&gt;&gt;&gt; df = pd.DataFrame([[3, 4], [5, 6]], index=['x', 'y'], columns=['a', 'b'])
&gt;&gt;&gt; ts_list = [sr, df]

&gt;&gt;&gt; ts_list = vbt.utils.broadcast(*ts_list)
&gt;&gt;&gt; print(ts_list[0])
   a  b
x  1  1
y  2  2
&gt;&gt;&gt; print(ts_list[1])
   a  b
x  3  4
y  5  6
</code></pre>
<ul>
<li>Takes one or multiple parameters in <code>param_list</code>, converts them to NumPy arrays and
broadcasts them</li>
</ul>
<pre><code class="python-repl">&gt;&gt;&gt; p1, p2, p3 = 1, [2, 3, 4], [False]
&gt;&gt;&gt; param_list = [p1, p2, p3]

&gt;&gt;&gt; param_list = vbt.utils.broadcast(*param_list)
&gt;&gt;&gt; print(param_list[0])
array([1, 1, 1])
&gt;&gt;&gt; print(param_list[1])
array([2, 3, 4])
&gt;&gt;&gt; print(param_list[2])
array([False, False, False])
</code></pre>
<ul>
<li>Performs calculation using <code>custom_func</code> to build output arrays (<code>output_list</code>) and
other objects (<code>other_list</code>, optional)</li>
</ul>
<pre><code class="python-repl">&gt;&gt;&gt; def custom_func(ts1, ts2, p1, p2, p3, *args, **kwargs):
...     return pd.DataFrame.vbt.concat(
...         (ts1.values + ts2.values) + p1[0] * p2[0],
...         (ts1.values + ts2.values) + p1[1] * p2[1],
...         (ts1.values + ts2.values) + p1[2] * p2[2]
...     )

&gt;&gt;&gt; output = custom_func(*ts_list, *param_list)
&gt;&gt;&gt; print(output)
array([[ 6,  7,  7,  8,  8,  9],
       [ 9, 10, 10, 11, 11, 12]])
</code></pre>
<ul>
<li>Creates new column hierarchy based on parameters and level names</li>
</ul>
<pre><code class="python-repl">&gt;&gt;&gt; p1_columns = pd.Index(param_list[0], name='p1')
&gt;&gt;&gt; p2_columns = pd.Index(param_list[1], name='p2')
&gt;&gt;&gt; p3_columns = pd.Index(param_list[2], name='p3')
&gt;&gt;&gt; p_columns = vbt.utils.stack_indices(p1_columns, p2_columns, p3_columns)
&gt;&gt;&gt; new_columns = vbt.utils.combine_indices(p_columns, ts_list[0].columns)

&gt;&gt;&gt; output_df = pd.DataFrame(output, columns=new_columns)
&gt;&gt;&gt; print(output_df)
p1      1      1      1      1      1      1                        
p2      2      2      3      3      4      4    
p3  False  False  False  False  False  False    
        a      b      a      b      a      b
0       6      7      7      8      8      9
1       9     10     10     11     11     12
</code></pre>
<ul>
<li>Broadcasts objects in <code>ts_list</code> to match the shape of objects in <code>output_list</code> through tiling.
This is done to be able to compare them and generate signals, since you cannot compare NumPy
arrays that have totally different shapes, such as (2, 2) and (2, 6).</li>
</ul>
<pre><code class="python-repl">&gt;&gt;&gt; new_ts_list = [
...     ts_list[0].vbt.tile(len(param_list[0]), as_columns=p_columns),
...     ts_list[1].vbt.tile(len(param_list[0]), as_columns=p_columns)
... ]
&gt;&gt;&gt; print(new_ts_list[0])
p1      1      1      1      1      1      1                        
p2      2      2      3      3      4      4    
p3  False  False  False  False  False  False     
        a      b      a      b      a      b
0       1      1      1      1      1      1
1       2      2      2      2      2      2
</code></pre>
<ul>
<li>Builds parameter mappers that will link parameters from <code>param_list</code> to columns in
<code>ts_list</code> and <code>output_list</code>. This is done to enable column indexing using parameter values.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts_list</code></strong> :&ensp;<code>list</code> of <code>array_like</code></dt>
<dd>A list of time series objects. At least one must be a pandas object.</dd>
<dt><strong><code>param_list</code></strong> :&ensp;<code>list</code> of <code>array_like</code></dt>
<dd>A list of parameters. Each element is either an array-like object
or a single value of any type.</dd>
<dt><strong><code>level_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of column level names corresponding to each parameter.</dd>
<dt><strong><code>num_outputs</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of output arrays.</dd>
<dt><strong><code>custom_func</code></strong> :&ensp;<code>function</code></dt>
<dd>A custom calculation function. See <code><a title="vectorbt.indicators.IndicatorFactory.from_custom_func" href="#vectorbt.indicators.IndicatorFactory.from_custom_func">IndicatorFactory.from_custom_func()</a></code>.</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>Arguments passed to the <code>custom_func</code>.</dd>
<dt><strong><code>pass_lists</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, arguments are passed to the <code>custom_func</code> as lists. Defaults to False.</dd>
<dt><strong><code>param_product</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, builds a Cartesian product out of all parameters. Defaults to False.</dd>
<dt><strong><code>broadcast_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to the <code><a title="vectorbt.utils.broadcast" href="utils.html#vectorbt.utils.broadcast">broadcast()</a></code> on time series objects.</dd>
<dt><strong><code>return_raw</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, returns the raw output without post-processing. Defaults to False.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>
<p>Keyword arguments passed to the <code>custom_func</code>.</p>
<p>Some common arguments include <code>return_cache</code> to return cache and <code>cache</code> to pass cache.
Those are only applicable to <code>custom_func</code> that supports it (<code>custom_func</code> created using
<code><a title="vectorbt.indicators.IndicatorFactory.from_apply_func" href="#vectorbt.indicators.IndicatorFactory.from_apply_func">IndicatorFactory.from_apply_func()</a></code> are supported by default).</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of transformed inputs (<code>pandas_like</code>), a list of generated outputs (<code>pandas_like</code>),
a list of parameter arrays (<code>numpy.ndarray</code>), a list of parameter mappers (<code>pandas.Series</code>),
a list of other generated outputs that are outside of
<code>num_outputs</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_params_pipeline(ts_list, param_list, level_names, num_outputs, custom_func, *args, pass_lists=False,
                         param_product=False, broadcast_kwargs={}, return_raw=False, **kwargs):
    &#34;&#34;&#34;A pipeline for calculating an indicator, used by `vectorbt.indicators.IndicatorFactory`.

    Does the following:

    * Takes one or multiple time series objects in `ts_list` and broadcasts them

    ```python-repl
    &gt;&gt;&gt; sr = pd.Series([1, 2], index=[&#39;x&#39;, &#39;y&#39;])
    &gt;&gt;&gt; df = pd.DataFrame([[3, 4], [5, 6]], index=[&#39;x&#39;, &#39;y&#39;], columns=[&#39;a&#39;, &#39;b&#39;])
    &gt;&gt;&gt; ts_list = [sr, df]

    &gt;&gt;&gt; ts_list = vbt.utils.broadcast(*ts_list)
    &gt;&gt;&gt; print(ts_list[0])
       a  b
    x  1  1
    y  2  2
    &gt;&gt;&gt; print(ts_list[1])
       a  b
    x  3  4
    y  5  6
    ```

    * Takes one or multiple parameters in `param_list`, converts them to NumPy arrays and 
        broadcasts them

    ```python-repl
    &gt;&gt;&gt; p1, p2, p3 = 1, [2, 3, 4], [False]
    &gt;&gt;&gt; param_list = [p1, p2, p3]

    &gt;&gt;&gt; param_list = vbt.utils.broadcast(*param_list)
    &gt;&gt;&gt; print(param_list[0])
    array([1, 1, 1])
    &gt;&gt;&gt; print(param_list[1])
    array([2, 3, 4])
    &gt;&gt;&gt; print(param_list[2])
    array([False, False, False])
    ```

    * Performs calculation using `custom_func` to build output arrays (`output_list`) and 
        other objects (`other_list`, optional)

    ```python-repl
    &gt;&gt;&gt; def custom_func(ts1, ts2, p1, p2, p3, *args, **kwargs):
    ...     return pd.DataFrame.vbt.concat(
    ...         (ts1.values + ts2.values) + p1[0] * p2[0],
    ...         (ts1.values + ts2.values) + p1[1] * p2[1],
    ...         (ts1.values + ts2.values) + p1[2] * p2[2]
    ...     )

    &gt;&gt;&gt; output = custom_func(*ts_list, *param_list)
    &gt;&gt;&gt; print(output)
    array([[ 6,  7,  7,  8,  8,  9],
           [ 9, 10, 10, 11, 11, 12]])
    ```

    * Creates new column hierarchy based on parameters and level names

    ```python-repl
    &gt;&gt;&gt; p1_columns = pd.Index(param_list[0], name=&#39;p1&#39;)
    &gt;&gt;&gt; p2_columns = pd.Index(param_list[1], name=&#39;p2&#39;)
    &gt;&gt;&gt; p3_columns = pd.Index(param_list[2], name=&#39;p3&#39;)
    &gt;&gt;&gt; p_columns = vbt.utils.stack_indices(p1_columns, p2_columns, p3_columns)
    &gt;&gt;&gt; new_columns = vbt.utils.combine_indices(p_columns, ts_list[0].columns)

    &gt;&gt;&gt; output_df = pd.DataFrame(output, columns=new_columns)
    &gt;&gt;&gt; print(output_df)
    p1      1      1      1      1      1      1                        
    p2      2      2      3      3      4      4    
    p3  False  False  False  False  False  False    
            a      b      a      b      a      b
    0       6      7      7      8      8      9
    1       9     10     10     11     11     12
    ```

    * Broadcasts objects in `ts_list` to match the shape of objects in `output_list` through tiling.
        This is done to be able to compare them and generate signals, since you cannot compare NumPy 
        arrays that have totally different shapes, such as (2, 2) and (2, 6).

    ```python-repl
    &gt;&gt;&gt; new_ts_list = [
    ...     ts_list[0].vbt.tile(len(param_list[0]), as_columns=p_columns),
    ...     ts_list[1].vbt.tile(len(param_list[0]), as_columns=p_columns)
    ... ]
    &gt;&gt;&gt; print(new_ts_list[0])
    p1      1      1      1      1      1      1                        
    p2      2      2      3      3      4      4    
    p3  False  False  False  False  False  False     
            a      b      a      b      a      b
    0       1      1      1      1      1      1
    1       2      2      2      2      2      2
    ```

    * Builds parameter mappers that will link parameters from `param_list` to columns in 
        `ts_list` and `output_list`. This is done to enable column indexing using parameter values.

    Args:
        ts_list (list of array_like): A list of time series objects. At least one must be a pandas object.
        param_list (list of array_like): A list of parameters. Each element is either an array-like object
            or a single value of any type.
        level_names (list of str): A list of column level names corresponding to each parameter.
        num_outputs (int): The number of output arrays.
        custom_func (function): A custom calculation function. See `IndicatorFactory.from_custom_func`.
        *args: Arguments passed to the `custom_func`.
        pass_lists (bool): If True, arguments are passed to the `custom_func` as lists. Defaults to False.
        param_product (bool): If True, builds a Cartesian product out of all parameters. Defaults to False.
        broadcast_kwargs (dict, optional): Keyword arguments passed to the `vectorbt.utils.broadcast` on time series objects.
        return_raw (bool): If True, returns the raw output without post-processing. Defaults to False.
        **kwargs: Keyword arguments passed to the `custom_func`.

            Some common arguments include `return_cache` to return cache and `cache` to pass cache. 
            Those are only applicable to `custom_func` that supports it (`custom_func` created using
            `IndicatorFactory.from_apply_func` are supported by default).
    Returns:
        A list of transformed inputs (`pandas_like`), a list of generated outputs (`pandas_like`), 
        a list of parameter arrays (`numpy.ndarray`), a list of parameter mappers (`pandas.Series`),
        a list of other generated outputs that are outside of  `num_outputs`.
    &#34;&#34;&#34;
    # Check time series objects
    check_type(ts_list[0], (pd.Series, pd.DataFrame))
    for i in range(1, len(ts_list)):
        ts_list[i].vbt.timeseries.validate()
    if len(ts_list) &gt; 1:
        # Broadcast time series
        ts_list = broadcast(*ts_list, **broadcast_kwargs, writeable=True)
    # Check level names
    check_type(level_names, (list, tuple))
    check_same_len(param_list, level_names)
    for ts in ts_list:
        # Every time series object should be free of the specified level names in its columns
        for level_name in level_names:
            check_level_not_exists(ts, level_name)
    # Convert params to 1-dim arrays
    param_list = list(map(to_1d, param_list))
    if len(param_list) &gt; 1:
        if param_product:
            # Make Cartesian product out of all params
            param_list = list(map(to_1d, param_list))
            param_list = list(zip(*list(itertools.product(*param_list))))
            param_list = list(map(np.asarray, param_list))
        else:
            # Broadcast such that each array has the same length
            param_list = broadcast(*param_list, writeable=True)
    # Perform main calculation
    if pass_lists:
        output_list = custom_func(ts_list, param_list, *args, **kwargs)
    else:
        output_list = custom_func(*ts_list, *param_list, *args, **kwargs)
    if return_raw or kwargs.get(&#39;return_cache&#39;, False):
        return output_list  # return raw cache outputs
    if not isinstance(output_list, (tuple, list, List)):
        output_list = [output_list]
    else:
        output_list = list(output_list)
    # Other outputs should be returned without post-processing (for example cache_dict)
    if len(output_list) &gt; num_outputs:
        other_list = output_list[num_outputs:]
    else:
        other_list = []
    # Process only the num_outputs outputs
    output_list = output_list[:num_outputs]
    if len(param_list) &gt; 0:
        # Build new column levels on top of time series levels
        new_columns = build_column_hierarchy(param_list, level_names, to_2d(ts_list[0]).columns)
        # Wrap into new pandas objects both time series and output objects
        new_ts_list = list(map(lambda x: broadcast_ts(x, param_list[0].shape[0], new_columns), ts_list))
        # Build mappers to easily map between parameters and columns
        mapper_list = [build_mapper(x, ts_list[0], new_columns, level_names[i]) for i, x in enumerate(param_list)]
    else:
        # Some indicators don&#39;t have any params
        new_columns = to_2d(ts_list[0]).columns
        new_ts_list = list(ts_list)
        mapper_list = []
    output_list = list(map(lambda x: wrap_output(x, ts_list[0], new_columns), output_list))
    if len(mapper_list) &gt; 1:
        # Tuple object is a mapper that accepts tuples of parameters
        tuple_mapper = build_tuple_mapper(mapper_list, new_columns, tuple(level_names))
        mapper_list.append(tuple_mapper)
    return new_ts_list, output_list, param_list, mapper_list, other_list</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.indicators.BollingerBands"><code class="flex name class">
<span>class <span class="ident">BollingerBands</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BollingerBands(BollingerBands):
    @classmethod
    def from_params(cls, ts, window=20, ewm=False, alpha=2, **kwargs):
        alpha = np.asarray(alpha).astype(np.float64)
        return super().from_params(ts, window, ewm, alpha, **kwargs)

    def plot(self,
             ts_name=None,
             upper_band_name=None,
             middle_band_name=None,
             lower_band_name=None,
             ts_trace_kwargs={},
             upper_band_trace_kwargs={},
             middle_band_trace_kwargs={},
             lower_band_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.ts, pd.Series)
        check_type(self.upper_band, pd.Series)
        check_type(self.middle_band, pd.Series)
        check_type(self.lower_band, pd.Series)

        if ts_name is None:
            ts_name = f&#39;Price ({self.name})&#39;
        if upper_band_name is None:
            upper_band_name = f&#39;Upper Band ({self.name})&#39;
        if middle_band_name is None:
            middle_band_name = f&#39;Middle Band ({self.name})&#39;
        if lower_band_name is None:
            lower_band_name = f&#39;Lower Band ({self.name})&#39;

        upper_band_trace_kwargs = {**dict(line=dict(color=&#39;grey&#39;)), **upper_band_trace_kwargs}  # default kwargs
        lower_band_trace_kwargs = {**dict(line=dict(color=&#39;grey&#39;)), **lower_band_trace_kwargs}

        fig = self.ts.vbt.timeseries.plot(
            name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.upper_band.vbt.timeseries.plot(
            name=upper_band_name, trace_kwargs=upper_band_trace_kwargs, fig=fig)
        fig = self.middle_band.vbt.timeseries.plot(
            name=middle_band_name, trace_kwargs=middle_band_trace_kwargs, fig=fig)
        fig = self.lower_band.vbt.timeseries.plot(
            name=lower_band_name, trace_kwargs=lower_band_trace_kwargs, fig=fig)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.BollingerBands.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, window=20, ewm=False, alpha=2, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the pipeline and initializes the class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, window=20, ewm=False, alpha=2, **kwargs):
    alpha = np.asarray(alpha).astype(np.float64)
    return super().from_params(ts, window, ewm, alpha, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.BollingerBands.alpha_loc"><code class="name">var <span class="ident">alpha_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter alpha using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.bandwidth"><code class="name">var <span class="ident">bandwidth</span></code></dt>
<dd>
<div class="desc"><p>Custom property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">bandwidth=lambda self: (self.upper_band - self.lower_band) / self.middle_band</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.ewm_loc"><code class="name">var <span class="ident">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.lower_band"><code class="name">var <span class="ident">lower_band</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.middle_band"><code class="name">var <span class="ident">middle_band</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.percent_b"><code class="name">var <span class="ident">percent_b</span></code></dt>
<dd>
<div class="desc"><p>Custom property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">percent_b=lambda self: (self.ts - self.lower_band) / (self.upper_band - self.lower_band),</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.ts"><code class="name">var <span class="ident">ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.tuple_loc"><code class="name">var <span class="ident">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter tuple using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.upper_band"><code class="name">var <span class="ident">upper_band</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.window_loc"><code class="name">var <span class="ident">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.BollingerBands.bandwidth_above"><code class="name flex">
<span>def <span class="ident">bandwidth_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>bandwidth</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>bandwidth</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.bandwidth_below"><code class="name flex">
<span>def <span class="ident">bandwidth_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>bandwidth</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>bandwidth</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.bandwidth_equal"><code class="name flex">
<span>def <span class="ident">bandwidth_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>bandwidth</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>bandwidth</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.lower_band_above"><code class="name flex">
<span>def <span class="ident">lower_band_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>lower_band</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>lower_band</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.lower_band_below"><code class="name flex">
<span>def <span class="ident">lower_band_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>lower_band</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>lower_band</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.lower_band_equal"><code class="name flex">
<span>def <span class="ident">lower_band_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>lower_band</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>lower_band</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.middle_band_above"><code class="name flex">
<span>def <span class="ident">middle_band_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>middle_band</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>middle_band</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.middle_band_below"><code class="name flex">
<span>def <span class="ident">middle_band_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>middle_band</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>middle_band</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.middle_band_equal"><code class="name flex">
<span>def <span class="ident">middle_band_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>middle_band</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>middle_band</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.percent_b_above"><code class="name flex">
<span>def <span class="ident">percent_b_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_b</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_b</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.percent_b_below"><code class="name flex">
<span>def <span class="ident">percent_b_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_b</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_b</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.percent_b_equal"><code class="name flex">
<span>def <span class="ident">percent_b_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_b</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_b</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, ts_name=None, upper_band_name=None, middle_band_name=None, lower_band_name=None, ts_trace_kwargs={}, upper_band_trace_kwargs={}, middle_band_trace_kwargs={}, lower_band_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         ts_name=None,
         upper_band_name=None,
         middle_band_name=None,
         lower_band_name=None,
         ts_trace_kwargs={},
         upper_band_trace_kwargs={},
         middle_band_trace_kwargs={},
         lower_band_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    check_type(self.ts, pd.Series)
    check_type(self.upper_band, pd.Series)
    check_type(self.middle_band, pd.Series)
    check_type(self.lower_band, pd.Series)

    if ts_name is None:
        ts_name = f&#39;Price ({self.name})&#39;
    if upper_band_name is None:
        upper_band_name = f&#39;Upper Band ({self.name})&#39;
    if middle_band_name is None:
        middle_band_name = f&#39;Middle Band ({self.name})&#39;
    if lower_band_name is None:
        lower_band_name = f&#39;Lower Band ({self.name})&#39;

    upper_band_trace_kwargs = {**dict(line=dict(color=&#39;grey&#39;)), **upper_band_trace_kwargs}  # default kwargs
    lower_band_trace_kwargs = {**dict(line=dict(color=&#39;grey&#39;)), **lower_band_trace_kwargs}

    fig = self.ts.vbt.timeseries.plot(
        name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.upper_band.vbt.timeseries.plot(
        name=upper_band_name, trace_kwargs=upper_band_trace_kwargs, fig=fig)
    fig = self.middle_band.vbt.timeseries.plot(
        name=middle_band_name, trace_kwargs=middle_band_trace_kwargs, fig=fig)
    fig = self.lower_band.vbt.timeseries.plot(
        name=lower_band_name, trace_kwargs=lower_band_trace_kwargs, fig=fig)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.ts_above"><code class="name flex">
<span>def <span class="ident">ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.ts_below"><code class="name flex">
<span>def <span class="ident">ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.ts_equal"><code class="name flex">
<span>def <span class="ident">ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.upper_band_above"><code class="name flex">
<span>def <span class="ident">upper_band_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>upper_band</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>upper_band</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.upper_band_below"><code class="name flex">
<span>def <span class="ident">upper_band_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>upper_band</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>upper_band</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.upper_band_equal"><code class="name flex">
<span>def <span class="ident">upper_band_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>upper_band</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>upper_band</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.BollingerBands.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.IndicatorFactory"><code class="flex name class">
<span>class <span class="ident">IndicatorFactory</span></span>
<span>(</span><span>ts_names=['ts'], param_names=['param'], output_names=['output'], name='custom', custom_properties={})</span>
</code></dt>
<dd>
<div class="desc"><p>A factory for creating new indicators.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of names of input time-series objects.
Defaults to ['ts'].</dd>
<dt><strong><code>param_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of names of parameters.
Defaults to ['param'].</dd>
<dt><strong><code>output_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of names of outputs time-series objects.
Defaults to ['output'].</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>A short name of the indicator.
Defaults to 'custom'.</dd>
<dt><strong><code>custom_properties</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>A dictionary with user-defined functions that will be
bound to the indicator class and wrapped with <code>@cached_property</code>.</dd>
</dl>
<p>Each indicator is basically a pipeline that</p>
<ul>
<li>Accepts a set of time-series objects (for example, OHLCV data)</li>
<li>Accepts a set of parameter arrays (for example, rolling windows)</li>
<li>Accepts other relevant arguments and keyword arguments</li>
<li>Performs calculations to produce new time-series objects (for example, rolling average)</li>
</ul>
<p>This pipeline can be well standardized, which is done by this indicatory factory.</p>
<p>On top of this pipeline, it also does the following:</p>
<ul>
<li>Creates a new indicator class</li>
<li>Creates an <code>__init__</code> method where it stores all inputs, outputs, and other artifacts</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code>__init__</code> method is never used for running the indicator, for this use <code>from_params</code>.
The reason for this is indexing, which requires a clean <code>__init__</code> method for creating
a new indicator object with newly indexed attributes.</p>
</div>
<ul>
<li>Creates a <code>from_params</code> method that runs the main pipeline using <code><a title="vectorbt.indicators.from_params_pipeline" href="#vectorbt.indicators.from_params_pipeline">from_params_pipeline()</a></code></li>
<li>Adds pandas indexing, i.e., you can use <code>iloc</code>, <code>loc</code>, <code>xs</code>, and <code>__getitem__</code> on the class itself</li>
<li>Adds parameter indexing, i.e., use <code>*your_param*_loc</code> on the class to slice using parameters</li>
<li>Adds user-defined properties</li>
<li>Adds common comparison methods for all inputs, outputs and properties, e.g., crossovers</li>
</ul>
<p>Consider the following smaller price dataframe <code>price_sm</code>:</p>
<pre><code class="python-repl">&gt;&gt;&gt; index = pd.Index([
...     datetime(2018, 1, 1),
...     datetime(2018, 1, 2),
...     datetime(2018, 1, 3),
...     datetime(2018, 1, 4),
...     datetime(2018, 1, 5),
... ])
&gt;&gt;&gt; price_sm = pd.DataFrame({
...     'a': [1, 2, 3, 4, 5], 
...     'b': [5, 4, 3, 2, 1]}, index=index).astype(float)
&gt;&gt;&gt; print(price_sm)
              a    b
2018-01-01  1.0  5.0
2018-01-02  2.0  4.0
2018-01-03  3.0  3.0
2018-01-04  4.0  2.0
2018-01-05  5.0  1.0
</code></pre>
<p>For each column in the dataframe, let's calculate a simple moving average and get signals
of price crossing it. In particular, we want to test two different window sizes: 2 and 3.</p>
<p>A naive way of doing this:</p>
<pre><code class="python-repl">&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price_sm.rolling(window=2).mean(), 
...     price_sm.rolling(window=3).mean(), 
...     as_columns=pd.Index([2, 3], name='ma_window'))
&gt;&gt;&gt; print(ma_df)
ma_window     2    2    3    3
              a    b    a    b
2018-01-01  NaN  NaN  NaN  NaN
2018-01-02  1.5  4.5  NaN  NaN
2018-01-03  2.5  3.5  2.0  4.0
2018-01-04  3.5  2.5  3.0  3.0
2018-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price_sm.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(above_signals)
ma_window       2      2      3      3
                a      b      a      b
2018-01-01  False  False  False  False
2018-01-02   True  False  False  False
2018-01-03  False  False   True  False
2018-01-04  False  False  False  False
2018-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price_sm.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; print(below_signals)
ma_window       2      2      3      3
                a      b      a      b
2018-01-01  False  False  False  False
2018-01-02  False   True  False  False
2018-01-03  False  False  False   True
2018-01-04  False  False  False  False
2018-01-05  False  False  False  False
</code></pre>
<p>Now the same using <code><a title="vectorbt.indicators.IndicatorFactory" href="#vectorbt.indicators.IndicatorFactory">IndicatorFactory</a></code>:</p>
<pre><code class="python-repl">&gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
...     ts_names=['price_sm'],
...     param_names=['window'],
...     output_names=['ma'],
...     name='myma'
... ).from_apply_func(vbt.timeseries.rolling_mean_nb)

&gt;&gt;&gt; myma = MyMA.from_params(price_sm, [2, 3])
&gt;&gt;&gt; above_signals = myma.price_sm_above(myma.ma, crossover=True)
&gt;&gt;&gt; below_signals = myma.price_sm_below(myma.ma, crossover=True)
</code></pre>
<p>It not only produced the handy <code>from_params</code> method, but generated a whole infrastructure to be run with
an arbitrary number of windows. </p>
<p>For all our inputs in <code>ts_names</code> and outputs in <code>output_names</code>, it created a bunch of comparison methods
for generating signals, such as <code>above</code>, <code>below</code> and <code>equal</code> (use <code>doc()</code>): </p>
<pre><code class="python-repl">'ma_above'
'ma_below'
'ma_equal'
'price_sm_above'
'price_sm_below'
'price_sm_equal'
</code></pre>
<p>Each of these methods uses vectorbt's own broadcasting, so you can compare time-series objects with an
arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
to multiple objects at once, for example:</p>
<pre><code class="python-repl">&gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
myma_ma_above    1.5    1.5    1.5    1.5    2.5    2.5    2.5    2.5
myma_window        2      2      3      3      2      2      3      3
                   a      b      a      b      a      b      a      b
2018-01-01     False  False  False  False  False  False  False  False
2018-01-02     False   True  False  False  False   True  False  False
2018-01-03      True   True   True   True  False   True  False   True
2018-01-04      True   True   True   True   True  False   True   True
2018-01-05      True  False   True   True   True  False   True  False
</code></pre>
<p><code><a title="vectorbt.indicators.IndicatorFactory" href="#vectorbt.indicators.IndicatorFactory">IndicatorFactory</a></code> also attached pandas indexing to the indicator class: </p>
<pre><code class="python-repl">'iloc'
'loc'
'window_loc'
'xs'
</code></pre>
<p>This makes accessing rows and columns by labels, integer positions, and parameters much easier.</p>
<p>The other advantage of using <code><a title="vectorbt.indicators.IndicatorFactory" href="#vectorbt.indicators.IndicatorFactory">IndicatorFactory</a></code> is broadcasting:</p>
<ul>
<li>Passing multiple time-series objects will broadcast them to the same shape and index/columns</li>
</ul>
<pre><code class="python-repl">&gt;&gt;&gt; price_sm2 = price_sm.copy() + 1
&gt;&gt;&gt; price_sm2.columns = ['a2', 'b2']

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     ts_names=['price_sm', 'price_sm2'],
...     param_names=['p1', 'p2']
... ).from_apply_func(
...     lambda price_sm, price_sm2, p1, p2: price_sm * p1 + price_sm2 * p2
... )

&gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm2, 1, 2)
&gt;&gt;&gt; print(myInd.price_sm)
              a    b
             a2   b2
2018-01-01  1.0  5.0
2018-01-02  2.0  4.0
2018-01-03  3.0  3.0
2018-01-04  4.0  2.0
2018-01-05  5.0  1.0
&gt;&gt;&gt; print(myInd.price_sm2)
              a    b
             a2   b2
2018-01-01  2.0  6.0
2018-01-02  3.0  5.0
2018-01-03  4.0  4.0
2018-01-04  5.0  3.0
2018-01-05  6.0  2.0
</code></pre>
<ul>
<li>Passing multiple parameters will broadcast them to arrays of the same shape</li>
</ul>
<pre><code class="python-repl">&gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm2, 1, 2)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1]
[2]

&gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm2, 1, [2, 3])
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1]
[2 3]

&gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm2, [1, 2], [3, 4], param_product=True)
&gt;&gt;&gt; print(myInd._p1_array)
&gt;&gt;&gt; print(myInd._p2_array)
[1 1 2 2]
[3 4 3 4]
</code></pre>
<p>This way, you can define parameter combinations of any order and shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndicatorFactory():
    def __init__(self,
                 ts_names=[&#39;ts&#39;],
                 param_names=[&#39;param&#39;],
                 output_names=[&#39;output&#39;],
                 name=&#39;custom&#39;,
                 custom_properties={}):
        &#34;&#34;&#34;A factory for creating new indicators.

        Args:
            ts_names (list of str): A list of names of input time-series objects. 
                Defaults to [&#39;ts&#39;].
            param_names (list of str): A list of names of parameters. 
                Defaults to [&#39;param&#39;].
            output_names (list of str): A list of names of outputs time-series objects. 
                Defaults to [&#39;output&#39;].
            name (str): A short name of the indicator. 
                Defaults to &#39;custom&#39;.
            custom_properties (dict, optional): A dictionary with user-defined functions that will be
                bound to the indicator class and wrapped with `@cached_property`.

        Each indicator is basically a pipeline that

        * Accepts a set of time-series objects (for example, OHLCV data)
        * Accepts a set of parameter arrays (for example, rolling windows)
        * Accepts other relevant arguments and keyword arguments
        * Performs calculations to produce new time-series objects (for example, rolling average)

        This pipeline can be well standardized, which is done by this indicatory factory.

        On top of this pipeline, it also does the following:

        * Creates a new indicator class
        * Creates an `__init__` method where it stores all inputs, outputs, and other artifacts

        !!! note
            The `__init__` method is never used for running the indicator, for this use `from_params`.
            The reason for this is indexing, which requires a clean `__init__` method for creating 
            a new indicator object with newly indexed attributes.

        * Creates a `from_params` method that runs the main pipeline using `vectorbt.indicators.from_params_pipeline`
        * Adds pandas indexing, i.e., you can use `iloc`, `loc`, `xs`, and `__getitem__` on the class itself
        * Adds parameter indexing, i.e., use `*your_param*_loc` on the class to slice using parameters
        * Adds user-defined properties
        * Adds common comparison methods for all inputs, outputs and properties, e.g., crossovers

        Consider the following smaller price dataframe `price_sm`:

        ```python-repl
        &gt;&gt;&gt; index = pd.Index([
        ...     datetime(2018, 1, 1),
        ...     datetime(2018, 1, 2),
        ...     datetime(2018, 1, 3),
        ...     datetime(2018, 1, 4),
        ...     datetime(2018, 1, 5),
        ... ])
        &gt;&gt;&gt; price_sm = pd.DataFrame({
        ...     &#39;a&#39;: [1, 2, 3, 4, 5], 
        ...     &#39;b&#39;: [5, 4, 3, 2, 1]}, index=index).astype(float)
        &gt;&gt;&gt; print(price_sm)
                      a    b
        2018-01-01  1.0  5.0
        2018-01-02  2.0  4.0
        2018-01-03  3.0  3.0
        2018-01-04  4.0  2.0
        2018-01-05  5.0  1.0
        ```

        For each column in the dataframe, let&#39;s calculate a simple moving average and get signals 
        of price crossing it. In particular, we want to test two different window sizes: 2 and 3.

        A naive way of doing this:

        ```python-repl
        &gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
        ...     price_sm.rolling(window=2).mean(), 
        ...     price_sm.rolling(window=3).mean(), 
        ...     as_columns=pd.Index([2, 3], name=&#39;ma_window&#39;))
        &gt;&gt;&gt; print(ma_df)
        ma_window     2    2    3    3
                      a    b    a    b
        2018-01-01  NaN  NaN  NaN  NaN
        2018-01-02  1.5  4.5  NaN  NaN
        2018-01-03  2.5  3.5  2.0  4.0
        2018-01-04  3.5  2.5  3.0  3.0
        2018-01-05  4.5  1.5  4.0  2.0

        &gt;&gt;&gt; above_signals = (price_sm.vbt.tile(2).vbt &gt; ma_df)
        &gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
        &gt;&gt;&gt; print(above_signals)
        ma_window       2      2      3      3
                        a      b      a      b
        2018-01-01  False  False  False  False
        2018-01-02   True  False  False  False
        2018-01-03  False  False   True  False
        2018-01-04  False  False  False  False
        2018-01-05  False  False  False  False

        &gt;&gt;&gt; below_signals = (price_sm.vbt.tile(2).vbt &lt; ma_df)
        &gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
        &gt;&gt;&gt; print(below_signals)
        ma_window       2      2      3      3
                        a      b      a      b
        2018-01-01  False  False  False  False
        2018-01-02  False   True  False  False
        2018-01-03  False  False  False   True
        2018-01-04  False  False  False  False
        2018-01-05  False  False  False  False
        ```

        Now the same using `vectorbt.indicators.IndicatorFactory`:

        ```python-repl
        &gt;&gt;&gt; MyMA = vbt.IndicatorFactory(
        ...     ts_names=[&#39;price_sm&#39;],
        ...     param_names=[&#39;window&#39;],
        ...     output_names=[&#39;ma&#39;],
        ...     name=&#39;myma&#39;
        ... ).from_apply_func(vbt.timeseries.rolling_mean_nb)

        &gt;&gt;&gt; myma = MyMA.from_params(price_sm, [2, 3])
        &gt;&gt;&gt; above_signals = myma.price_sm_above(myma.ma, crossover=True)
        &gt;&gt;&gt; below_signals = myma.price_sm_below(myma.ma, crossover=True)
        ```

        It not only produced the handy `from_params` method, but generated a whole infrastructure to be run with
        an arbitrary number of windows. 

        For all our inputs in `ts_names` and outputs in `output_names`, it created a bunch of comparison methods 
        for generating signals, such as `above`, `below` and `equal` (use `doc()`): 

        ```python-repl
        &#39;ma_above&#39;
        &#39;ma_below&#39;
        &#39;ma_equal&#39;
        &#39;price_sm_above&#39;
        &#39;price_sm_below&#39;
        &#39;price_sm_equal&#39;
        ```

        Each of these methods uses vectorbt&#39;s own broadcasting, so you can compare time-series objects with an 
        arbitrary array-like object, given their shapes can be broadcasted together. You can also compare them
        to multiple objects at once, for example:

        ```python-repl
        &gt;&gt;&gt; myma.ma_above([1.5, 2.5], multiple=True)
        myma_ma_above    1.5    1.5    1.5    1.5    2.5    2.5    2.5    2.5
        myma_window        2      2      3      3      2      2      3      3
                           a      b      a      b      a      b      a      b
        2018-01-01     False  False  False  False  False  False  False  False
        2018-01-02     False   True  False  False  False   True  False  False
        2018-01-03      True   True   True   True  False   True  False   True
        2018-01-04      True   True   True   True   True  False   True   True
        2018-01-05      True  False   True   True   True  False   True  False
        ```

        `vectorbt.indicators.IndicatorFactory` also attached pandas indexing to the indicator class: 

        ```python-repl
        &#39;iloc&#39;
        &#39;loc&#39;
        &#39;window_loc&#39;
        &#39;xs&#39;
        ```

        This makes accessing rows and columns by labels, integer positions, and parameters much easier.

        The other advantage of using `vectorbt.indicators.IndicatorFactory` is broadcasting:

        * Passing multiple time-series objects will broadcast them to the same shape and index/columns

        ```python-repl
        &gt;&gt;&gt; price_sm2 = price_sm.copy() + 1
        &gt;&gt;&gt; price_sm2.columns = [&#39;a2&#39;, &#39;b2&#39;]

        &gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
        ...     ts_names=[&#39;price_sm&#39;, &#39;price_sm2&#39;],
        ...     param_names=[&#39;p1&#39;, &#39;p2&#39;]
        ... ).from_apply_func(
        ...     lambda price_sm, price_sm2, p1, p2: price_sm * p1 + price_sm2 * p2
        ... )

        &gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm2, 1, 2)
        &gt;&gt;&gt; print(myInd.price_sm)
                      a    b
                     a2   b2
        2018-01-01  1.0  5.0
        2018-01-02  2.0  4.0
        2018-01-03  3.0  3.0
        2018-01-04  4.0  2.0
        2018-01-05  5.0  1.0
        &gt;&gt;&gt; print(myInd.price_sm2)
                      a    b
                     a2   b2
        2018-01-01  2.0  6.0
        2018-01-02  3.0  5.0
        2018-01-03  4.0  4.0
        2018-01-04  5.0  3.0
        2018-01-05  6.0  2.0
        ```

        * Passing multiple parameters will broadcast them to arrays of the same shape

        ```python-repl
        &gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm2, 1, 2)
        &gt;&gt;&gt; print(myInd._p1_array)
        &gt;&gt;&gt; print(myInd._p2_array)
        [1]
        [2]

        &gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm2, 1, [2, 3])
        &gt;&gt;&gt; print(myInd._p1_array)
        &gt;&gt;&gt; print(myInd._p2_array)
        [1 1]
        [2 3]

        &gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm2, [1, 2], [3, 4], param_product=True)
        &gt;&gt;&gt; print(myInd._p1_array)
        &gt;&gt;&gt; print(myInd._p2_array)
        [1 1 2 2]
        [3 4 3 4]
        ```

        This way, you can define parameter combinations of any order and shape. 
        &#34;&#34;&#34;
        self.ts_names = ts_names
        self.param_names = param_names
        self.output_names = output_names
        self.name = name
        self.custom_properties = custom_properties

    def from_custom_func(self, custom_func, pass_lists=False):
        &#34;&#34;&#34;Build indicator class around a custom calculation function.

        !!! note
            `custom_func` shouldn&#39;t be Numba-compiled, since passed time series are all pandas objects.
            Instead, define your `custom_func` as a regular Python function where you should
            convert all inputs into NumPy arrays, and then pass them to your Numba-compiled function.

            Also, in contrast to `IndicatorFactory.from_apply_func`, it&#39;s up to you to handle caching
            and concatenate columns for each parameter (for example, by using `vectorbt.utils.apply_and_concat_one`).
            Also, you must ensure that each output array has an appropriate number of columns, which
            is the number of columns in input time series multiplied by the number of parameter values.

        Args:
            custom_func (function): A function that takes broadcasted time series corresponding 
                to `ts_names`, broadcasted parameter arrays corresponding to `param_names`, and other 
                arguments and keyword arguments, and returns outputs corresponding to `output_names` 
                and other objects that are then returned with the indicator class instance.
            pass_lists (bool): If True, passes arguments as lists. Otherwise, passes them using 
                starred expression. Defaults to False.
        Returns:
            `CustomIndicator`, and optionally other objects that are returned by `custom_func`
            and exceed `output_names`.
        Examples:
            The following example does the same as the example in `IndicatorFactory.from_apply_func`.

            ```python-repl
            &gt;&gt;&gt; @njit
            &gt;&gt;&gt; def apply_func_nb(i, ts1, ts2, p1, p2, arg1):
            ...     return ts1 * p1[i] + arg1, ts2 * p2[i] + arg1

            &gt;&gt;&gt; def custom_func(ts1, ts2, p1, p2, *args):
            ...     return vbt.utils.apply_and_concat_multiple_nb(len(p1), apply_func_nb, 
            ...         ts1.vbt.to_2d_array(), ts2.vbt.to_2d_array(), p1, p2, *args)

            &gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
            ...     ts_names=[&#39;ts1&#39;, &#39;ts2&#39;],
            ...     param_names=[&#39;p1&#39;, &#39;p2&#39;],
            ...     output_names=[&#39;o1&#39;, &#39;o2&#39;]
            ... ).from_custom_func(custom_func)

            &gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm * 2, [1, 2], [3, 4], 100)
            &gt;&gt;&gt; print(myInd.o1)
            custom_p1       1      1      2      2
            custom_p2       3      3      4      4
                            a      b      a      b
            2018-01-01  101.0  105.0  102.0  110.0
            2018-01-02  102.0  104.0  104.0  108.0
            2018-01-03  103.0  103.0  106.0  106.0
            2018-01-04  104.0  102.0  108.0  104.0
            2018-01-05  105.0  101.0  110.0  102.0
            &gt;&gt;&gt; print(myInd.o2)
            custom_p1       1      1      2      2
            custom_p2       3      3      4      4
                            a      b      a      b
            2018-01-01  106.0  130.0  108.0  140.0
            2018-01-02  112.0  124.0  116.0  132.0
            2018-01-03  118.0  118.0  124.0  124.0
            2018-01-04  124.0  112.0  132.0  116.0
            2018-01-05  130.0  106.0  140.0  108.0
            ```
        &#34;&#34;&#34;

        CustomIndicator = type(&#39;CustomIndicator&#39;, (), {})
        ts_names = self.ts_names
        param_names = self.param_names
        output_names = self.output_names
        name = self.name
        custom_properties = self.custom_properties

        # For name and each input and output, create read-only properties
        prop = property(lambda self: self._name)
        prop.__doc__ = f&#34;&#34;&#34;Name of the indicator (read-only).&#34;&#34;&#34;
        setattr(CustomIndicator, &#39;name&#39;, prop)

        for ts_name in ts_names:
            prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))
            prop.__doc__ = f&#34;&#34;&#34;Input time series (read-only).&#34;&#34;&#34;
            setattr(CustomIndicator, ts_name, prop)

        for output_name in output_names:
            prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))
            prop.__doc__ = f&#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
            setattr(CustomIndicator, output_name, prop)

        for prop in custom_properties.values():
            if prop.__doc__ is None:
                prop.__doc__ = f&#34;&#34;&#34;Custom property.&#34;&#34;&#34;

        # Add __init__ method
        def __init__(self, ts_list, output_list, param_list, mapper_list, name):
            &#34;&#34;&#34;Performs checks on pipeline artifacts and stores them as instance attributes.&#34;&#34;&#34;
            perform_init_checks(ts_list, output_list, param_list, mapper_list, name)

            for i, ts_name in enumerate(ts_names):
                setattr(self, f&#39;_{ts_name}&#39;, ts_list[i])
            for i, output_name in enumerate(output_names):
                setattr(self, f&#39;_{output_name}&#39;, output_list[i])
            for i, param_name in enumerate(param_names):
                setattr(self, f&#39;_{param_name}_array&#39;, param_list[i])
                setattr(self, f&#39;_{param_name}_mapper&#39;, mapper_list[i])
            if len(param_names) &gt; 1:
                setattr(self, &#39;_tuple_mapper&#39;, mapper_list[-1])
            setattr(self, &#39;_name&#39;, name)

        setattr(CustomIndicator, &#39;__init__&#39;, __init__)

        # Add from_params method
        @classmethod
        def from_params(cls, *args, name=name.lower(), return_raw=False, **kwargs):
            &#34;&#34;&#34;Runs the pipeline and initializes the class.&#34;&#34;&#34;
            level_names = tuple([name + &#39;_&#39; + param_name for param_name in param_names])
            args = list(args)
            ts_list = args[:len(ts_names)]
            param_list = args[len(ts_names):len(ts_names)+len(param_names)]
            new_args = args[len(ts_names)+len(param_names):]
            results = from_params_pipeline(
                ts_list, param_list, level_names, len(output_names),
                custom_func, *new_args, pass_lists=pass_lists, return_raw=return_raw, **kwargs)
            if return_raw or kwargs.get(&#39;return_cache&#39;, False):
                return results
            new_ts_list, output_list, new_param_list, mapper_list, other_list = results
            obj = cls(new_ts_list, output_list, new_param_list, mapper_list, name)
            if len(other_list) &gt; 0:
                return (obj,) + other_list
            return obj

        setattr(CustomIndicator, &#39;from_params&#39;, from_params)

        # Add indexing methods
        def indexing_func(obj, loc_pandas_func):
            ts_list = []
            for ts_name in ts_names:
                ts_list.append(loc_pandas_func(getattr(obj, ts_name)))
            output_list = []
            for output_name in output_names:
                output_list.append(loc_pandas_func(getattr(obj, output_name)))
            param_list = []
            for param_name in param_names:
                # TODO: adapt params array according to the indexing operation
                param_list.append(getattr(obj, f&#39;_{param_name}_array&#39;))
            mapper_list = []
            for param_name in param_names:
                mapper_list.append(loc_mapper(
                    getattr(obj, f&#39;_{param_name}_mapper&#39;),
                    getattr(obj, ts_names[0]), loc_pandas_func))
            if len(param_names) &gt; 1:
                mapper_list.append(loc_mapper(obj._tuple_mapper, getattr(obj, ts_names[0]), loc_pandas_func))

            return obj.__class__(ts_list, output_list, param_list, mapper_list, obj.name)

        CustomIndicator = add_indexing(indexing_func)(CustomIndicator)
        for i, param_name in enumerate(param_names):
            CustomIndicator = add_param_indexing(param_name, indexing_func)(CustomIndicator)
        if len(param_names) &gt; 1:
            CustomIndicator = add_param_indexing(&#39;tuple&#39;, indexing_func)(CustomIndicator)

        # Add user-defined properties
        for prop_name, prop_func in custom_properties.items():
            if not isinstance(prop_func, property):
                prop_func = cached_property(prop_func)
            setattr(CustomIndicator, prop_name, prop_func)

        # Add comparison methods for all inputs, outputs, and user-defined properties
        comparison_attrs = set(ts_names + output_names + list(custom_properties.keys()))
        for attr in comparison_attrs:
            def assign_comparison_method(func_name, comparison_func, attr=attr):
                def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
                    if isinstance(other, self.__class__):
                        other = getattr(other, attr)
                    if name is None:
                        if attr == self.name:
                            name = f&#39;{self.name}_{func_name}&#39;
                        else:
                            name = f&#39;{self.name}_{attr}_{func_name}&#39;
                    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
                    if crossover:
                        return result.vbt.signals.nst(wait+1, after_false=True)
                    return result
                comparison_method.__doc__ = f&#34;&#34;&#34;Returns True when `{attr}` is {func_name} `other`. 

                Set `crossover` to True to return the first True after crossover. Specify `wait` to return 
                True only when `{attr}` is {func_name} for a number of time steps in a row after crossover.
                
                Both will be broadcasted together. Set `multiple` to True to combine with multiple arguments. 
                For more keyword arguments, see `vectorbt.utils.Base_Accessor.combine_with`.&#34;&#34;&#34;
                setattr(CustomIndicator, f&#39;{attr}_{func_name}&#39;, comparison_method)

            assign_comparison_method(&#39;above&#39;, is_above)
            assign_comparison_method(&#39;below&#39;, is_below)
            assign_comparison_method(&#39;equal&#39;, is_equal)

        return CustomIndicator

    def from_apply_func(self, apply_func, caching_func=None):
        &#34;&#34;&#34;Build indicator class around a custom apply function.

        In contrast to `IndicatorFactory.from_custom_func`, this method handles a lot of things for you,
        such as caching, parameter selection, and concatenation. All you have to do is to write `apply_func`
        that accepts a selection of parameters (single values as opposed to multiple values in 
        `IndicatorFactory.from_custom_func`) and does the calculation. It then automatically concatenates
        the results into a single array per output.

        While this approach is much more simpler, it is also less flexible, since you can only work with 
        one parameter selection at a time, and can&#39;t view all parameters.

        !!! note
            If `apply_func` is a Numba-compiled function: 

            * All inputs are automatically converted to NumPy arrays
            * Each argument in `*args` must be of a Numba-compatible type
            * You cannot pass keyword arguments
            * Your outputs must be arrays of the same shape, data type and data order

        Args:
            apply_func (function): A function (can be Numba-compiled) that takes broadcasted time 
                series arrays corresponding to `ts_names`, single parameter selection corresponding 
                to `param_names`, and other arguments and keyword arguments, and returns outputs 
                corresponding to `output_names`.
            caching_func (function): A caching function to preprocess data beforehand.
                All returned objects will be passed as additional arguments to `apply_func`.
        Returns:
            `CustomIndicator`
        Examples:
            ```python-repl
            &gt;&gt;&gt; @njit
            ... def apply_func_nb(ts1, ts2, p1, p2, arg1):
            ...     return ts1 * p1 + arg1, ts2 * p2 + arg1

            &gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
            ...     ts_names=[&#39;ts1&#39;, &#39;ts2&#39;],
            ...     param_names=[&#39;p1&#39;, &#39;p2&#39;],
            ...     output_names=[&#39;o1&#39;, &#39;o2&#39;]
            ... ).from_apply_func(apply_func_nb)

            &gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm * 2, [1, 2], [3, 4], 100)
            &gt;&gt;&gt; print(myInd.o1)
            custom_p1       1      1      2      2
            custom_p2       3      3      4      4
                            a      b      a      b
            2018-01-01  101.0  105.0  102.0  110.0
            2018-01-02  102.0  104.0  104.0  108.0
            2018-01-03  103.0  103.0  106.0  106.0
            2018-01-04  104.0  102.0  108.0  104.0
            2018-01-05  105.0  101.0  110.0  102.0
            &gt;&gt;&gt; print(myInd.o2)
            custom_p1       1      1      2      2
            custom_p2       3      3      4      4
                            a      b      a      b
            2018-01-01  106.0  130.0  108.0  140.0
            2018-01-02  112.0  124.0  116.0  132.0
            2018-01-03  118.0  118.0  124.0  124.0
            2018-01-04  124.0  112.0  132.0  116.0
            2018-01-05  130.0  106.0  140.0  108.0
            ```
        &#34;&#34;&#34;
        output_names = self.output_names

        num_outputs = len(output_names)

        if is_numba_func(apply_func):
            apply_and_concat_func = apply_and_concat_multiple_nb if num_outputs &gt; 1 else apply_and_concat_one_nb

            @njit
            def select_params_func_nb(i, apply_func, ts_list, param_tuples, *args):
                # Select the next tuple of parameters
                return apply_func(*ts_list, *param_tuples[i], *args)

            def custom_func(ts_list, param_list, *args, return_cache=False, cache=None):
                # avoid deprecation warnings
                typed_ts_list = tuple(map(lambda x: x.vbt.to_2d_array(), ts_list))
                typed_param_tuples = List()
                for param_tuple in list(zip(*param_list)):
                    typed_param_tuples.append(param_tuple)

                # Caching
                if cache is None and caching_func is not None:
                    cache = caching_func(*typed_ts_list, *param_list, *args)
                if return_cache:
                    return cache
                if cache is None:
                    cache = ()
                if not isinstance(cache, (tuple, list, List)):
                    cache = (cache,)

                return apply_and_concat_func(
                    param_list[0].shape[0],
                    select_params_func_nb,
                    apply_func,
                    typed_ts_list,
                    typed_param_tuples,
                    *args,
                    *cache)
        else:
            apply_and_concat_func = apply_and_concat_multiple if num_outputs &gt; 1 else apply_and_concat_one

            def select_params_func(i, apply_func, ts_list, param_list, *args, **kwargs):
                    # Select the next tuple of parameters
                param_is = list(map(lambda x: x[i], param_list))
                return apply_func(*ts_list, *param_is, *args, **kwargs)

            def custom_func(ts_list, param_list, *args, return_cache=False, **kwargs):
                # Caching
                if cache is None and caching_func is not None:
                    cache = caching_func(*typed_ts_list, *param_list, *args, **kwargs)
                if return_cache:
                    return cache
                if cache is None:
                    cache = ()
                if not isinstance(cache, (tuple, list, List)):
                    cache = (cache,)

                return apply_and_concat_func(
                    param_list[0].shape[0],
                    select_params_func,
                    apply_func,
                    ts_list,
                    param_list,
                    *args,
                    *cache,
                    **kwargs)

        return self.from_custom_func(custom_func, pass_lists=True)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.IndicatorFactory.from_apply_func"><code class="name flex">
<span>def <span class="ident">from_apply_func</span></span>(<span>self, apply_func, caching_func=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Build indicator class around a custom apply function.</p>
<p>In contrast to <code><a title="vectorbt.indicators.IndicatorFactory.from_custom_func" href="#vectorbt.indicators.IndicatorFactory.from_custom_func">IndicatorFactory.from_custom_func()</a></code>, this method handles a lot of things for you,
such as caching, parameter selection, and concatenation. All you have to do is to write <code>apply_func</code>
that accepts a selection of parameters (single values as opposed to multiple values in
<code><a title="vectorbt.indicators.IndicatorFactory.from_custom_func" href="#vectorbt.indicators.IndicatorFactory.from_custom_func">IndicatorFactory.from_custom_func()</a></code>) and does the calculation. It then automatically concatenates
the results into a single array per output.</p>
<p>While this approach is much more simpler, it is also less flexible, since you can only work with
one parameter selection at a time, and can't view all parameters.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code>apply_func</code> is a Numba-compiled function: </p>
<ul>
<li>All inputs are automatically converted to NumPy arrays</li>
<li>Each argument in <code>*args</code> must be of a Numba-compatible type</li>
<li>You cannot pass keyword arguments</li>
<li>Your outputs must be arrays of the same shape, data type and data order</li>
</ul>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>apply_func</code></strong> :&ensp;<code>function</code></dt>
<dd>A function (can be Numba-compiled) that takes broadcasted time
series arrays corresponding to <code>ts_names</code>, single parameter selection corresponding
to <code>param_names</code>, and other arguments and keyword arguments, and returns outputs
corresponding to <code>output_names</code>.</dd>
<dt><strong><code>caching_func</code></strong> :&ensp;<code>function</code></dt>
<dd>A caching function to preprocess data beforehand.
All returned objects will be passed as additional arguments to <code>apply_func</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>CustomIndicator</code></p>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, p1, p2, arg1):
...     return ts1 * p1 + arg1, ts2 * p2 + arg1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     ts_names=['ts1', 'ts2'],
...     param_names=['p1', 'p2'],
...     output_names=['o1', 'o2']
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm * 2, [1, 2], [3, 4], 100)
&gt;&gt;&gt; print(myInd.o1)
custom_p1       1      1      2      2
custom_p2       3      3      4      4
                a      b      a      b
2018-01-01  101.0  105.0  102.0  110.0
2018-01-02  102.0  104.0  104.0  108.0
2018-01-03  103.0  103.0  106.0  106.0
2018-01-04  104.0  102.0  108.0  104.0
2018-01-05  105.0  101.0  110.0  102.0
&gt;&gt;&gt; print(myInd.o2)
custom_p1       1      1      2      2
custom_p2       3      3      4      4
                a      b      a      b
2018-01-01  106.0  130.0  108.0  140.0
2018-01-02  112.0  124.0  116.0  132.0
2018-01-03  118.0  118.0  124.0  124.0
2018-01-04  124.0  112.0  132.0  116.0
2018-01-05  130.0  106.0  140.0  108.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_apply_func(self, apply_func, caching_func=None):
    &#34;&#34;&#34;Build indicator class around a custom apply function.

    In contrast to `IndicatorFactory.from_custom_func`, this method handles a lot of things for you,
    such as caching, parameter selection, and concatenation. All you have to do is to write `apply_func`
    that accepts a selection of parameters (single values as opposed to multiple values in 
    `IndicatorFactory.from_custom_func`) and does the calculation. It then automatically concatenates
    the results into a single array per output.

    While this approach is much more simpler, it is also less flexible, since you can only work with 
    one parameter selection at a time, and can&#39;t view all parameters.

    !!! note
        If `apply_func` is a Numba-compiled function: 

        * All inputs are automatically converted to NumPy arrays
        * Each argument in `*args` must be of a Numba-compatible type
        * You cannot pass keyword arguments
        * Your outputs must be arrays of the same shape, data type and data order

    Args:
        apply_func (function): A function (can be Numba-compiled) that takes broadcasted time 
            series arrays corresponding to `ts_names`, single parameter selection corresponding 
            to `param_names`, and other arguments and keyword arguments, and returns outputs 
            corresponding to `output_names`.
        caching_func (function): A caching function to preprocess data beforehand.
            All returned objects will be passed as additional arguments to `apply_func`.
    Returns:
        `CustomIndicator`
    Examples:
        ```python-repl
        &gt;&gt;&gt; @njit
        ... def apply_func_nb(ts1, ts2, p1, p2, arg1):
        ...     return ts1 * p1 + arg1, ts2 * p2 + arg1

        &gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
        ...     ts_names=[&#39;ts1&#39;, &#39;ts2&#39;],
        ...     param_names=[&#39;p1&#39;, &#39;p2&#39;],
        ...     output_names=[&#39;o1&#39;, &#39;o2&#39;]
        ... ).from_apply_func(apply_func_nb)

        &gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm * 2, [1, 2], [3, 4], 100)
        &gt;&gt;&gt; print(myInd.o1)
        custom_p1       1      1      2      2
        custom_p2       3      3      4      4
                        a      b      a      b
        2018-01-01  101.0  105.0  102.0  110.0
        2018-01-02  102.0  104.0  104.0  108.0
        2018-01-03  103.0  103.0  106.0  106.0
        2018-01-04  104.0  102.0  108.0  104.0
        2018-01-05  105.0  101.0  110.0  102.0
        &gt;&gt;&gt; print(myInd.o2)
        custom_p1       1      1      2      2
        custom_p2       3      3      4      4
                        a      b      a      b
        2018-01-01  106.0  130.0  108.0  140.0
        2018-01-02  112.0  124.0  116.0  132.0
        2018-01-03  118.0  118.0  124.0  124.0
        2018-01-04  124.0  112.0  132.0  116.0
        2018-01-05  130.0  106.0  140.0  108.0
        ```
    &#34;&#34;&#34;
    output_names = self.output_names

    num_outputs = len(output_names)

    if is_numba_func(apply_func):
        apply_and_concat_func = apply_and_concat_multiple_nb if num_outputs &gt; 1 else apply_and_concat_one_nb

        @njit
        def select_params_func_nb(i, apply_func, ts_list, param_tuples, *args):
            # Select the next tuple of parameters
            return apply_func(*ts_list, *param_tuples[i], *args)

        def custom_func(ts_list, param_list, *args, return_cache=False, cache=None):
            # avoid deprecation warnings
            typed_ts_list = tuple(map(lambda x: x.vbt.to_2d_array(), ts_list))
            typed_param_tuples = List()
            for param_tuple in list(zip(*param_list)):
                typed_param_tuples.append(param_tuple)

            # Caching
            if cache is None and caching_func is not None:
                cache = caching_func(*typed_ts_list, *param_list, *args)
            if return_cache:
                return cache
            if cache is None:
                cache = ()
            if not isinstance(cache, (tuple, list, List)):
                cache = (cache,)

            return apply_and_concat_func(
                param_list[0].shape[0],
                select_params_func_nb,
                apply_func,
                typed_ts_list,
                typed_param_tuples,
                *args,
                *cache)
    else:
        apply_and_concat_func = apply_and_concat_multiple if num_outputs &gt; 1 else apply_and_concat_one

        def select_params_func(i, apply_func, ts_list, param_list, *args, **kwargs):
                # Select the next tuple of parameters
            param_is = list(map(lambda x: x[i], param_list))
            return apply_func(*ts_list, *param_is, *args, **kwargs)

        def custom_func(ts_list, param_list, *args, return_cache=False, **kwargs):
            # Caching
            if cache is None and caching_func is not None:
                cache = caching_func(*typed_ts_list, *param_list, *args, **kwargs)
            if return_cache:
                return cache
            if cache is None:
                cache = ()
            if not isinstance(cache, (tuple, list, List)):
                cache = (cache,)

            return apply_and_concat_func(
                param_list[0].shape[0],
                select_params_func,
                apply_func,
                ts_list,
                param_list,
                *args,
                *cache,
                **kwargs)

    return self.from_custom_func(custom_func, pass_lists=True)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.IndicatorFactory.from_custom_func"><code class="name flex">
<span>def <span class="ident">from_custom_func</span></span>(<span>self, custom_func, pass_lists=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Build indicator class around a custom calculation function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>custom_func</code> shouldn't be Numba-compiled, since passed time series are all pandas objects.
Instead, define your <code>custom_func</code> as a regular Python function where you should
convert all inputs into NumPy arrays, and then pass them to your Numba-compiled function.</p>
<p>Also, in contrast to <code><a title="vectorbt.indicators.IndicatorFactory.from_apply_func" href="#vectorbt.indicators.IndicatorFactory.from_apply_func">IndicatorFactory.from_apply_func()</a></code>, it's up to you to handle caching
and concatenate columns for each parameter (for example, by using <code><a title="vectorbt.utils.apply_and_concat_one" href="utils.html#vectorbt.utils.apply_and_concat_one">apply_and_concat_one()</a></code>).
Also, you must ensure that each output array has an appropriate number of columns, which
is the number of columns in input time series multiplied by the number of parameter values.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>custom_func</code></strong> :&ensp;<code>function</code></dt>
<dd>A function that takes broadcasted time series corresponding
to <code>ts_names</code>, broadcasted parameter arrays corresponding to <code>param_names</code>, and other
arguments and keyword arguments, and returns outputs corresponding to <code>output_names</code>
and other objects that are then returned with the indicator class instance.</dd>
<dt><strong><code>pass_lists</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, passes arguments as lists. Otherwise, passes them using
starred expression. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>CustomIndicator</code>, and optionally other objects that are returned by <code>custom_func</code>
and exceed <code>output_names</code>.</p>
<h2 id="examples">Examples</h2>
<p>The following example does the same as the example in <code><a title="vectorbt.indicators.IndicatorFactory.from_apply_func" href="#vectorbt.indicators.IndicatorFactory.from_apply_func">IndicatorFactory.from_apply_func()</a></code>.</p>
<pre><code class="python-repl">&gt;&gt;&gt; @njit
&gt;&gt;&gt; def apply_func_nb(i, ts1, ts2, p1, p2, arg1):
...     return ts1 * p1[i] + arg1, ts2 * p2[i] + arg1

&gt;&gt;&gt; def custom_func(ts1, ts2, p1, p2, *args):
...     return vbt.utils.apply_and_concat_multiple_nb(len(p1), apply_func_nb, 
...         ts1.vbt.to_2d_array(), ts2.vbt.to_2d_array(), p1, p2, *args)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     ts_names=['ts1', 'ts2'],
...     param_names=['p1', 'p2'],
...     output_names=['o1', 'o2']
... ).from_custom_func(custom_func)

&gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm * 2, [1, 2], [3, 4], 100)
&gt;&gt;&gt; print(myInd.o1)
custom_p1       1      1      2      2
custom_p2       3      3      4      4
                a      b      a      b
2018-01-01  101.0  105.0  102.0  110.0
2018-01-02  102.0  104.0  104.0  108.0
2018-01-03  103.0  103.0  106.0  106.0
2018-01-04  104.0  102.0  108.0  104.0
2018-01-05  105.0  101.0  110.0  102.0
&gt;&gt;&gt; print(myInd.o2)
custom_p1       1      1      2      2
custom_p2       3      3      4      4
                a      b      a      b
2018-01-01  106.0  130.0  108.0  140.0
2018-01-02  112.0  124.0  116.0  132.0
2018-01-03  118.0  118.0  124.0  124.0
2018-01-04  124.0  112.0  132.0  116.0
2018-01-05  130.0  106.0  140.0  108.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_custom_func(self, custom_func, pass_lists=False):
    &#34;&#34;&#34;Build indicator class around a custom calculation function.

    !!! note
        `custom_func` shouldn&#39;t be Numba-compiled, since passed time series are all pandas objects.
        Instead, define your `custom_func` as a regular Python function where you should
        convert all inputs into NumPy arrays, and then pass them to your Numba-compiled function.

        Also, in contrast to `IndicatorFactory.from_apply_func`, it&#39;s up to you to handle caching
        and concatenate columns for each parameter (for example, by using `vectorbt.utils.apply_and_concat_one`).
        Also, you must ensure that each output array has an appropriate number of columns, which
        is the number of columns in input time series multiplied by the number of parameter values.

    Args:
        custom_func (function): A function that takes broadcasted time series corresponding 
            to `ts_names`, broadcasted parameter arrays corresponding to `param_names`, and other 
            arguments and keyword arguments, and returns outputs corresponding to `output_names` 
            and other objects that are then returned with the indicator class instance.
        pass_lists (bool): If True, passes arguments as lists. Otherwise, passes them using 
            starred expression. Defaults to False.
    Returns:
        `CustomIndicator`, and optionally other objects that are returned by `custom_func`
        and exceed `output_names`.
    Examples:
        The following example does the same as the example in `IndicatorFactory.from_apply_func`.

        ```python-repl
        &gt;&gt;&gt; @njit
        &gt;&gt;&gt; def apply_func_nb(i, ts1, ts2, p1, p2, arg1):
        ...     return ts1 * p1[i] + arg1, ts2 * p2[i] + arg1

        &gt;&gt;&gt; def custom_func(ts1, ts2, p1, p2, *args):
        ...     return vbt.utils.apply_and_concat_multiple_nb(len(p1), apply_func_nb, 
        ...         ts1.vbt.to_2d_array(), ts2.vbt.to_2d_array(), p1, p2, *args)

        &gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
        ...     ts_names=[&#39;ts1&#39;, &#39;ts2&#39;],
        ...     param_names=[&#39;p1&#39;, &#39;p2&#39;],
        ...     output_names=[&#39;o1&#39;, &#39;o2&#39;]
        ... ).from_custom_func(custom_func)

        &gt;&gt;&gt; myInd = MyInd.from_params(price_sm, price_sm * 2, [1, 2], [3, 4], 100)
        &gt;&gt;&gt; print(myInd.o1)
        custom_p1       1      1      2      2
        custom_p2       3      3      4      4
                        a      b      a      b
        2018-01-01  101.0  105.0  102.0  110.0
        2018-01-02  102.0  104.0  104.0  108.0
        2018-01-03  103.0  103.0  106.0  106.0
        2018-01-04  104.0  102.0  108.0  104.0
        2018-01-05  105.0  101.0  110.0  102.0
        &gt;&gt;&gt; print(myInd.o2)
        custom_p1       1      1      2      2
        custom_p2       3      3      4      4
                        a      b      a      b
        2018-01-01  106.0  130.0  108.0  140.0
        2018-01-02  112.0  124.0  116.0  132.0
        2018-01-03  118.0  118.0  124.0  124.0
        2018-01-04  124.0  112.0  132.0  116.0
        2018-01-05  130.0  106.0  140.0  108.0
        ```
    &#34;&#34;&#34;

    CustomIndicator = type(&#39;CustomIndicator&#39;, (), {})
    ts_names = self.ts_names
    param_names = self.param_names
    output_names = self.output_names
    name = self.name
    custom_properties = self.custom_properties

    # For name and each input and output, create read-only properties
    prop = property(lambda self: self._name)
    prop.__doc__ = f&#34;&#34;&#34;Name of the indicator (read-only).&#34;&#34;&#34;
    setattr(CustomIndicator, &#39;name&#39;, prop)

    for ts_name in ts_names:
        prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))
        prop.__doc__ = f&#34;&#34;&#34;Input time series (read-only).&#34;&#34;&#34;
        setattr(CustomIndicator, ts_name, prop)

    for output_name in output_names:
        prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))
        prop.__doc__ = f&#34;&#34;&#34;Output time series (read-only).&#34;&#34;&#34;
        setattr(CustomIndicator, output_name, prop)

    for prop in custom_properties.values():
        if prop.__doc__ is None:
            prop.__doc__ = f&#34;&#34;&#34;Custom property.&#34;&#34;&#34;

    # Add __init__ method
    def __init__(self, ts_list, output_list, param_list, mapper_list, name):
        &#34;&#34;&#34;Performs checks on pipeline artifacts and stores them as instance attributes.&#34;&#34;&#34;
        perform_init_checks(ts_list, output_list, param_list, mapper_list, name)

        for i, ts_name in enumerate(ts_names):
            setattr(self, f&#39;_{ts_name}&#39;, ts_list[i])
        for i, output_name in enumerate(output_names):
            setattr(self, f&#39;_{output_name}&#39;, output_list[i])
        for i, param_name in enumerate(param_names):
            setattr(self, f&#39;_{param_name}_array&#39;, param_list[i])
            setattr(self, f&#39;_{param_name}_mapper&#39;, mapper_list[i])
        if len(param_names) &gt; 1:
            setattr(self, &#39;_tuple_mapper&#39;, mapper_list[-1])
        setattr(self, &#39;_name&#39;, name)

    setattr(CustomIndicator, &#39;__init__&#39;, __init__)

    # Add from_params method
    @classmethod
    def from_params(cls, *args, name=name.lower(), return_raw=False, **kwargs):
        &#34;&#34;&#34;Runs the pipeline and initializes the class.&#34;&#34;&#34;
        level_names = tuple([name + &#39;_&#39; + param_name for param_name in param_names])
        args = list(args)
        ts_list = args[:len(ts_names)]
        param_list = args[len(ts_names):len(ts_names)+len(param_names)]
        new_args = args[len(ts_names)+len(param_names):]
        results = from_params_pipeline(
            ts_list, param_list, level_names, len(output_names),
            custom_func, *new_args, pass_lists=pass_lists, return_raw=return_raw, **kwargs)
        if return_raw or kwargs.get(&#39;return_cache&#39;, False):
            return results
        new_ts_list, output_list, new_param_list, mapper_list, other_list = results
        obj = cls(new_ts_list, output_list, new_param_list, mapper_list, name)
        if len(other_list) &gt; 0:
            return (obj,) + other_list
        return obj

    setattr(CustomIndicator, &#39;from_params&#39;, from_params)

    # Add indexing methods
    def indexing_func(obj, loc_pandas_func):
        ts_list = []
        for ts_name in ts_names:
            ts_list.append(loc_pandas_func(getattr(obj, ts_name)))
        output_list = []
        for output_name in output_names:
            output_list.append(loc_pandas_func(getattr(obj, output_name)))
        param_list = []
        for param_name in param_names:
            # TODO: adapt params array according to the indexing operation
            param_list.append(getattr(obj, f&#39;_{param_name}_array&#39;))
        mapper_list = []
        for param_name in param_names:
            mapper_list.append(loc_mapper(
                getattr(obj, f&#39;_{param_name}_mapper&#39;),
                getattr(obj, ts_names[0]), loc_pandas_func))
        if len(param_names) &gt; 1:
            mapper_list.append(loc_mapper(obj._tuple_mapper, getattr(obj, ts_names[0]), loc_pandas_func))

        return obj.__class__(ts_list, output_list, param_list, mapper_list, obj.name)

    CustomIndicator = add_indexing(indexing_func)(CustomIndicator)
    for i, param_name in enumerate(param_names):
        CustomIndicator = add_param_indexing(param_name, indexing_func)(CustomIndicator)
    if len(param_names) &gt; 1:
        CustomIndicator = add_param_indexing(&#39;tuple&#39;, indexing_func)(CustomIndicator)

    # Add user-defined properties
    for prop_name, prop_func in custom_properties.items():
        if not isinstance(prop_func, property):
            prop_func = cached_property(prop_func)
        setattr(CustomIndicator, prop_name, prop_func)

    # Add comparison methods for all inputs, outputs, and user-defined properties
    comparison_attrs = set(ts_names + output_names + list(custom_properties.keys()))
    for attr in comparison_attrs:
        def assign_comparison_method(func_name, comparison_func, attr=attr):
            def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
                if isinstance(other, self.__class__):
                    other = getattr(other, attr)
                if name is None:
                    if attr == self.name:
                        name = f&#39;{self.name}_{func_name}&#39;
                    else:
                        name = f&#39;{self.name}_{attr}_{func_name}&#39;
                result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
                if crossover:
                    return result.vbt.signals.nst(wait+1, after_false=True)
                return result
            comparison_method.__doc__ = f&#34;&#34;&#34;Returns True when `{attr}` is {func_name} `other`. 

            Set `crossover` to True to return the first True after crossover. Specify `wait` to return 
            True only when `{attr}` is {func_name} for a number of time steps in a row after crossover.
            
            Both will be broadcasted together. Set `multiple` to True to combine with multiple arguments. 
            For more keyword arguments, see `vectorbt.utils.Base_Accessor.combine_with`.&#34;&#34;&#34;
            setattr(CustomIndicator, f&#39;{attr}_{func_name}&#39;, comparison_method)

        assign_comparison_method(&#39;above&#39;, is_above)
        assign_comparison_method(&#39;below&#39;, is_below)
        assign_comparison_method(&#39;equal&#39;, is_equal)

    return CustomIndicator</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.MA"><code class="flex name class">
<span>class <span class="ident">MA</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A moving average (MA) is a widely used indicator in technical analysis that helps smooth out
price action by filtering out the “noise” from random short-term price fluctuations. </p>
<p>See <a href="https://www.investopedia.com/terms/m/movingaverage.asp">Moving Average (MA)</a>.</p>
<p>Use <code><a title="vectorbt.indicators.MA.from_params" href="#vectorbt.indicators.MA.from_params">MA.from_params()</a></code> or <code><a title="vectorbt.indicators.MA.from_combinations" href="#vectorbt.indicators.MA.from_combinations">MA.from_combinations()</a></code> methods to run the indicator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MA(MA):
    &#34;&#34;&#34;A moving average (MA) is a widely used indicator in technical analysis that helps smooth out 
    price action by filtering out the “noise” from random short-term price fluctuations. 

    See [Moving Average (MA)](https://www.investopedia.com/terms/m/movingaverage.asp).

    Use `MA.from_params` or `MA.from_combinations` methods to run the indicator.&#34;&#34;&#34;

    @classmethod
    def from_params(cls, ts, window, ewm=False, **kwargs):
        &#34;&#34;&#34;Calculate moving average `MA.ma` from time series `ts` and parameters `window` and `ewm`.

        Args:
            ts (pandas_like): Time series (such as price).
            window (int or array_like of int): Size of the moving window. Can be one or more values.
            ewm (bool or array_like of bool): If True, uses exponential moving average, otherwise 
                simple moving average. Can be one or more values. Defaults to False.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.from_params_pipeline.`
        Examples:
            ```python-repl
            &gt;&gt;&gt; ma = vbt.MA.from_params(price, [10, 20], ewm=[False, True])

            &gt;&gt;&gt; print(ma.ma)
            ma_window         10        20
            ma_ewm         False      True 
            2018-01-01       NaN       NaN
            2018-01-02       NaN       NaN
            2018-01-03       NaN       NaN
            ...              ...       ...
            2018-04-08  5.999866  6.141290
            2018-04-09  6.040747  6.117779
            2018-04-10  5.915199  6.021119

            [100 rows x 2 columns]
            ```
        &#34;&#34;&#34;
        return super().from_params(ts, window, ewm, **kwargs)

    @classmethod
    def from_combinations(cls, ts, windows, r, ewm=False, names=None, **kwargs):
        &#34;&#34;&#34;Calculate multiple moving averages according to `itertools.combinations`.

        Args:
            ts (pandas_like): Time series (such as price).
            windows (array_like of int): Size of the moving window. Must be multiple.
            r (int): The number of `vectorbt.indicators.MA` instances to combine.
            ewm (bool or array_like of bool): If True, uses exponential moving average, otherwise 
                simple moving average. Can be one or more values. Defaults to False.
            names (list of str, optional): A list of names for each `vectorbt.indicators.MA` instance.
            **kwargs: Keyword arguments passed to `vectorbt.indicators.from_params_pipeline.`
        Examples:
            ```python-repl
            &gt;&gt;&gt; fast_ma, slow_ma = vbt.MA.from_combinations(price, 
            ...     [10, 20, 30], 2, ewm=[False, False, True], names=[&#39;fast&#39;, &#39;slow&#39;])

            &gt;&gt;&gt; print(fast_ma.ma)

            fast_window        10        10        20
            fast_ewm        False     False     False
            2018-01-01        NaN       NaN       NaN
            2018-01-02        NaN       NaN       NaN
            2018-01-03        NaN       NaN       NaN
            ...               ...       ...       ...
            2018-04-08   5.999866  5.999866  5.983928
            2018-04-09   6.040747  6.040747  5.931313
            2018-04-10   5.915199  5.915199  5.868436

            [100 rows x 3 columns]

            &gt;&gt;&gt; print(slow_ma.ma)
            slow_window        20        30        30
            slow_ewm        False      True      True 
            2018-01-01        NaN       NaN       NaN
            2018-01-02        NaN       NaN       NaN
            2018-01-03        NaN       NaN       NaN
            ...               ...       ...       ...
            2018-04-08   5.983928  6.356696  6.356696
            2018-04-09   5.931313  6.326833  6.326833
            2018-04-10   5.868436  6.247768  6.247768

            [100 rows x 3 columns]
            ```

            The naive way without caching is the follows:
            ```py
            window_combs = itertools.combinations([10, 20, 30], 2)
            ewm_combs = itertools.combinations([False, False, True], 2)
            fast_windows, slow_windows = np.asarray(list(window_combs)).transpose()
            fast_ewms, slow_ewms = np.asarray(list(ewm_combs)).transpose()

            fast_ma = vbt.MA.from_params(price, fast_windows, fast_ewms, name=&#39;fast&#39;)
            slow_ma = vbt.MA.from_params(price, slow_windows, slow_ewms, name=&#39;slow&#39;)
            ```

            Having this, you can then compare those `vectorbt.indicators.MA` instances together:
            ```python-repl
            &gt;&gt;&gt; entry_signals = fast_ma.ma_above(slow_ma, crossover=True)
            &gt;&gt;&gt; exit_signals = fast_ma.ma_below(slow_ma, crossover=True)

            &gt;&gt;&gt; print(fast_signals)
            fast_window     10     10     20
            fast_ewm     False  False  False
            slow_window     20     30     30
            slow_ewm     False  True   True 
            2018-01-01   False  False  False
            2018-01-02   False  False  False
            2018-01-03   False  False  False
            ...            ...    ...    ...
            2018-04-08   False  False  False
            2018-04-09   False  False  False
            2018-04-10   False  False  False

            [100 rows x 3 columns]
            ```

            Notice the new column hierarchy the `MA.ma_above` method created for you. You can use
            it for indexing as follows:

            ```py
            fig = entry_signals[(10, False, 20, False)].vbt.signals.plot(name=&#39;Entries&#39;)
            exit_signals[(10, False, 20, False)].vbt.signals.plot(name=&#39;Exits&#39;, fig=fig)
            ```
            ![](img/MA_from_combinations.png)
        &#34;&#34;&#34;

        if names is None:
            names = [&#39;ma&#39; + str(i+1) for i in range(r)]
        windows, ewm = broadcast(windows, ewm, writeable=True)
        cache_dict = cls.from_params(ts, windows, ewm=ewm, return_cache=True, **kwargs)
        param_lists = zip(*itertools.combinations(zip(windows, ewm), r))
        mas = []
        for i, param_list in enumerate(param_lists):
            i_windows, i_ewm = zip(*param_list)
            mas.append(cls.from_params(ts, i_windows, ewm=i_ewm, cache=cache_dict, name=names[i], **kwargs))
        return tuple(mas)

    def plot(self,
             ts_name=None,
             ma_name=None,
             ts_trace_kwargs={},
             ma_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        &#34;&#34;&#34;Plot moving average `MA.ma` against time series `MA.ts`.

        Args:
            ts_name (str): Name of trace for `MA.ts`.
            ma_name (str): Name of trace for `MA.ma`.
            ts_trace_kwargs (dict, optional): Keyword arguments passed to `pandas.vbt.timeseries` of `MA.ts`.
            ma_trace_kwargs (dict, optional): Keyword arguments passed to `pandas.vbt.timeseries` of `MA.ma`.
            fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.
        Examples:
            ```py
            ma[(10, False)].plot()
            ```

            ![](img/MA.png)&#34;&#34;&#34;
        check_type(self.ts, pd.Series)
        check_type(self.ma, pd.Series)

        if ts_name is None:
            ts_name = f&#39;Price ({self.name})&#39;
        if ma_name is None:
            ma_name = f&#39;MA ({self.name})&#39;

        fig = self.ts.vbt.timeseries.plot(name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.ma.vbt.timeseries.plot(name=ma_name, trace_kwargs=ma_trace_kwargs, fig=fig)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.MA.from_combinations"><code class="name flex">
<span>def <span class="ident">from_combinations</span></span>(<span>ts, windows, r, ewm=False, names=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate multiple moving averages according to <code>itertools.combinations</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Time series (such as price).</dd>
<dt><strong><code>windows</code></strong> :&ensp;<code>array_like</code> of <code>int</code></dt>
<dd>Size of the moving window. Must be multiple.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of <code><a title="vectorbt.indicators.MA" href="#vectorbt.indicators.MA">MA</a></code> instances to combine.</dd>
<dt><strong><code>ewm</code></strong> :&ensp;<code>bool</code> or <code>array_like</code> of <code>bool</code></dt>
<dd>If True, uses exponential moving average, otherwise
simple moving average. Can be one or more values. Defaults to False.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>A list of names for each <code><a title="vectorbt.indicators.MA" href="#vectorbt.indicators.MA">MA</a></code> instance.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.indicators.from_params_pipeline" href="#vectorbt.indicators.from_params_pipeline">from_params_pipeline()</a>.</code></dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; fast_ma, slow_ma = vbt.MA.from_combinations(price, 
...     [10, 20, 30], 2, ewm=[False, False, True], names=['fast', 'slow'])

&gt;&gt;&gt; print(fast_ma.ma)

fast_window        10        10        20
fast_ewm        False     False     False
2018-01-01        NaN       NaN       NaN
2018-01-02        NaN       NaN       NaN
2018-01-03        NaN       NaN       NaN
...               ...       ...       ...
2018-04-08   5.999866  5.999866  5.983928
2018-04-09   6.040747  6.040747  5.931313
2018-04-10   5.915199  5.915199  5.868436

[100 rows x 3 columns]

&gt;&gt;&gt; print(slow_ma.ma)
slow_window        20        30        30
slow_ewm        False      True      True 
2018-01-01        NaN       NaN       NaN
2018-01-02        NaN       NaN       NaN
2018-01-03        NaN       NaN       NaN
...               ...       ...       ...
2018-04-08   5.983928  6.356696  6.356696
2018-04-09   5.931313  6.326833  6.326833
2018-04-10   5.868436  6.247768  6.247768

[100 rows x 3 columns]
</code></pre>
<p>The naive way without caching is the follows:</p>
<pre><code class="py">window_combs = itertools.combinations([10, 20, 30], 2)
ewm_combs = itertools.combinations([False, False, True], 2)
fast_windows, slow_windows = np.asarray(list(window_combs)).transpose()
fast_ewms, slow_ewms = np.asarray(list(ewm_combs)).transpose()

fast_ma = vbt.MA.from_params(price, fast_windows, fast_ewms, name='fast')
slow_ma = vbt.MA.from_params(price, slow_windows, slow_ewms, name='slow')
</code></pre>
<p>Having this, you can then compare those <code><a title="vectorbt.indicators.MA" href="#vectorbt.indicators.MA">MA</a></code> instances together:</p>
<pre><code class="python-repl">&gt;&gt;&gt; entry_signals = fast_ma.ma_above(slow_ma, crossover=True)
&gt;&gt;&gt; exit_signals = fast_ma.ma_below(slow_ma, crossover=True)

&gt;&gt;&gt; print(fast_signals)
fast_window     10     10     20
fast_ewm     False  False  False
slow_window     20     30     30
slow_ewm     False  True   True 
2018-01-01   False  False  False
2018-01-02   False  False  False
2018-01-03   False  False  False
...            ...    ...    ...
2018-04-08   False  False  False
2018-04-09   False  False  False
2018-04-10   False  False  False

[100 rows x 3 columns]
</code></pre>
<p>Notice the new column hierarchy the <code><a title="vectorbt.indicators.MA.ma_above" href="#vectorbt.indicators.MA.ma_above">IndicatorFactory.from_custom_func.<locals>.assign_comparison_method.<locals>.comparison_method()</a></code> method created for you. You can use
it for indexing as follows:</p>
<pre><code class="py">fig = entry_signals[(10, False, 20, False)].vbt.signals.plot(name='Entries')
exit_signals[(10, False, 20, False)].vbt.signals.plot(name='Exits', fig=fig)
</code></pre>
<p><img alt="" src="img/MA_from_combinations.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_combinations(cls, ts, windows, r, ewm=False, names=None, **kwargs):
    &#34;&#34;&#34;Calculate multiple moving averages according to `itertools.combinations`.

    Args:
        ts (pandas_like): Time series (such as price).
        windows (array_like of int): Size of the moving window. Must be multiple.
        r (int): The number of `vectorbt.indicators.MA` instances to combine.
        ewm (bool or array_like of bool): If True, uses exponential moving average, otherwise 
            simple moving average. Can be one or more values. Defaults to False.
        names (list of str, optional): A list of names for each `vectorbt.indicators.MA` instance.
        **kwargs: Keyword arguments passed to `vectorbt.indicators.from_params_pipeline.`
    Examples:
        ```python-repl
        &gt;&gt;&gt; fast_ma, slow_ma = vbt.MA.from_combinations(price, 
        ...     [10, 20, 30], 2, ewm=[False, False, True], names=[&#39;fast&#39;, &#39;slow&#39;])

        &gt;&gt;&gt; print(fast_ma.ma)

        fast_window        10        10        20
        fast_ewm        False     False     False
        2018-01-01        NaN       NaN       NaN
        2018-01-02        NaN       NaN       NaN
        2018-01-03        NaN       NaN       NaN
        ...               ...       ...       ...
        2018-04-08   5.999866  5.999866  5.983928
        2018-04-09   6.040747  6.040747  5.931313
        2018-04-10   5.915199  5.915199  5.868436

        [100 rows x 3 columns]

        &gt;&gt;&gt; print(slow_ma.ma)
        slow_window        20        30        30
        slow_ewm        False      True      True 
        2018-01-01        NaN       NaN       NaN
        2018-01-02        NaN       NaN       NaN
        2018-01-03        NaN       NaN       NaN
        ...               ...       ...       ...
        2018-04-08   5.983928  6.356696  6.356696
        2018-04-09   5.931313  6.326833  6.326833
        2018-04-10   5.868436  6.247768  6.247768

        [100 rows x 3 columns]
        ```

        The naive way without caching is the follows:
        ```py
        window_combs = itertools.combinations([10, 20, 30], 2)
        ewm_combs = itertools.combinations([False, False, True], 2)
        fast_windows, slow_windows = np.asarray(list(window_combs)).transpose()
        fast_ewms, slow_ewms = np.asarray(list(ewm_combs)).transpose()

        fast_ma = vbt.MA.from_params(price, fast_windows, fast_ewms, name=&#39;fast&#39;)
        slow_ma = vbt.MA.from_params(price, slow_windows, slow_ewms, name=&#39;slow&#39;)
        ```

        Having this, you can then compare those `vectorbt.indicators.MA` instances together:
        ```python-repl
        &gt;&gt;&gt; entry_signals = fast_ma.ma_above(slow_ma, crossover=True)
        &gt;&gt;&gt; exit_signals = fast_ma.ma_below(slow_ma, crossover=True)

        &gt;&gt;&gt; print(fast_signals)
        fast_window     10     10     20
        fast_ewm     False  False  False
        slow_window     20     30     30
        slow_ewm     False  True   True 
        2018-01-01   False  False  False
        2018-01-02   False  False  False
        2018-01-03   False  False  False
        ...            ...    ...    ...
        2018-04-08   False  False  False
        2018-04-09   False  False  False
        2018-04-10   False  False  False

        [100 rows x 3 columns]
        ```

        Notice the new column hierarchy the `MA.ma_above` method created for you. You can use
        it for indexing as follows:

        ```py
        fig = entry_signals[(10, False, 20, False)].vbt.signals.plot(name=&#39;Entries&#39;)
        exit_signals[(10, False, 20, False)].vbt.signals.plot(name=&#39;Exits&#39;, fig=fig)
        ```
        ![](img/MA_from_combinations.png)
    &#34;&#34;&#34;

    if names is None:
        names = [&#39;ma&#39; + str(i+1) for i in range(r)]
    windows, ewm = broadcast(windows, ewm, writeable=True)
    cache_dict = cls.from_params(ts, windows, ewm=ewm, return_cache=True, **kwargs)
    param_lists = zip(*itertools.combinations(zip(windows, ewm), r))
    mas = []
    for i, param_list in enumerate(param_lists):
        i_windows, i_ewm = zip(*param_list)
        mas.append(cls.from_params(ts, i_windows, ewm=i_ewm, cache=cache_dict, name=names[i], **kwargs))
    return tuple(mas)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, window, ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate moving average <code><a title="vectorbt.indicators.MA.ma" href="#vectorbt.indicators.MA.ma">MA.ma</a></code> from time series <code>ts</code> and parameters <code>window</code> and <code>ewm</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pandas_like</code></dt>
<dd>Time series (such as price).</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>int</code> or <code>array_like</code> of <code>int</code></dt>
<dd>Size of the moving window. Can be one or more values.</dd>
<dt><strong><code>ewm</code></strong> :&ensp;<code>bool</code> or <code>array_like</code> of <code>bool</code></dt>
<dd>If True, uses exponential moving average, otherwise
simple moving average. Can be one or more values. Defaults to False.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code><a title="vectorbt.indicators.from_params_pipeline" href="#vectorbt.indicators.from_params_pipeline">from_params_pipeline()</a>.</code></dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; ma = vbt.MA.from_params(price, [10, 20], ewm=[False, True])

&gt;&gt;&gt; print(ma.ma)
ma_window         10        20
ma_ewm         False      True 
2018-01-01       NaN       NaN
2018-01-02       NaN       NaN
2018-01-03       NaN       NaN
...              ...       ...
2018-04-08  5.999866  6.141290
2018-04-09  6.040747  6.117779
2018-04-10  5.915199  6.021119

[100 rows x 2 columns]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, window, ewm=False, **kwargs):
    &#34;&#34;&#34;Calculate moving average `MA.ma` from time series `ts` and parameters `window` and `ewm`.

    Args:
        ts (pandas_like): Time series (such as price).
        window (int or array_like of int): Size of the moving window. Can be one or more values.
        ewm (bool or array_like of bool): If True, uses exponential moving average, otherwise 
            simple moving average. Can be one or more values. Defaults to False.
        **kwargs: Keyword arguments passed to `vectorbt.indicators.from_params_pipeline.`
    Examples:
        ```python-repl
        &gt;&gt;&gt; ma = vbt.MA.from_params(price, [10, 20], ewm=[False, True])

        &gt;&gt;&gt; print(ma.ma)
        ma_window         10        20
        ma_ewm         False      True 
        2018-01-01       NaN       NaN
        2018-01-02       NaN       NaN
        2018-01-03       NaN       NaN
        ...              ...       ...
        2018-04-08  5.999866  6.141290
        2018-04-09  6.040747  6.117779
        2018-04-10  5.915199  6.021119

        [100 rows x 2 columns]
        ```
    &#34;&#34;&#34;
    return super().from_params(ts, window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.MA.ewm_loc"><code class="name">var <span class="ident">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.ma"><code class="name">var <span class="ident">ma</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.ts"><code class="name">var <span class="ident">ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.tuple_loc"><code class="name">var <span class="ident">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter tuple using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.window_loc"><code class="name">var <span class="ident">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.MA.ma_above"><code class="name flex">
<span>def <span class="ident">ma_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ma</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.ma_below"><code class="name flex">
<span>def <span class="ident">ma_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ma</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.ma_equal"><code class="name flex">
<span>def <span class="ident">ma_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ma</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ma</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, ts_name=None, ma_name=None, ts_trace_kwargs={}, ma_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot moving average <code><a title="vectorbt.indicators.MA.ma" href="#vectorbt.indicators.MA.ma">MA.ma</a></code> against time series <code><a title="vectorbt.indicators.MA.ts" href="#vectorbt.indicators.MA.ts">MA.ts</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of trace for <code><a title="vectorbt.indicators.MA.ts" href="#vectorbt.indicators.MA.ts">MA.ts</a></code>.</dd>
<dt><strong><code>ma_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of trace for <code><a title="vectorbt.indicators.MA.ma" href="#vectorbt.indicators.MA.ma">MA.ma</a></code>.</dd>
<dt><strong><code>ts_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <code>pandas.vbt.timeseries</code> of <code><a title="vectorbt.indicators.MA.ts" href="#vectorbt.indicators.MA.ts">MA.ts</a></code>.</dd>
<dt><strong><code>ma_trace_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments passed to <code>pandas.vbt.timeseries</code> of <code><a title="vectorbt.indicators.MA.ma" href="#vectorbt.indicators.MA.ma">MA.ma</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>plotly.graph_objects.Figure</code>, optional</dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="py">ma[(10, False)].plot()
</code></pre>
<p><img alt="" src="img/MA.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         ts_name=None,
         ma_name=None,
         ts_trace_kwargs={},
         ma_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    &#34;&#34;&#34;Plot moving average `MA.ma` against time series `MA.ts`.

    Args:
        ts_name (str): Name of trace for `MA.ts`.
        ma_name (str): Name of trace for `MA.ma`.
        ts_trace_kwargs (dict, optional): Keyword arguments passed to `pandas.vbt.timeseries` of `MA.ts`.
        ma_trace_kwargs (dict, optional): Keyword arguments passed to `pandas.vbt.timeseries` of `MA.ma`.
        fig (plotly.graph_objects.Figure, optional): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.
    Examples:
        ```py
        ma[(10, False)].plot()
        ```

        ![](img/MA.png)&#34;&#34;&#34;
    check_type(self.ts, pd.Series)
    check_type(self.ma, pd.Series)

    if ts_name is None:
        ts_name = f&#39;Price ({self.name})&#39;
    if ma_name is None:
        ma_name = f&#39;MA ({self.name})&#39;

    fig = self.ts.vbt.timeseries.plot(name=ts_name, trace_kwargs=ts_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.ma.vbt.timeseries.plot(name=ma_name, trace_kwargs=ma_trace_kwargs, fig=fig)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.ts_above"><code class="name flex">
<span>def <span class="ident">ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.ts_below"><code class="name flex">
<span>def <span class="ident">ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.ts_equal"><code class="name flex">
<span>def <span class="ident">ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MA.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.MACD"><code class="flex name class">
<span>class <span class="ident">MACD</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MACD(MACD):
    @classmethod
    def from_params(cls, ts, fast_window=26, slow_window=12, signal_window=9, ewm=True, **kwargs):
        return super().from_params(ts, fast_window, slow_window, signal_window, ewm, **kwargs)

    def crossover(self, **kwargs):
        above_signals = self.macd_above(self.signal, crossover=True, **kwargs)
        below_signals = self.macd_below(self.signal, crossover=True, **kwargs)
        return above_signals, below_signals

    def plot(self,
             macd_name=None,
             signal_name=None,
             macd_trace_kwargs={},
             signal_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.macd, pd.Series)
        check_type(self.signal, pd.Series)

        if macd_name is None:
            macd_name = f&#39;MACD ({self.name})&#39;
        if signal_name is None:
            signal_name = f&#39;Signal ({self.name})&#39;

        fig = self.macd.vbt.timeseries.plot(
            name=macd_name, trace_kwargs=macd_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.signal.vbt.timeseries.plot(
            name=signal_name, trace_kwargs=signal_trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.MACD.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, fast_window=26, slow_window=12, signal_window=9, ewm=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the pipeline and initializes the class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, fast_window=26, slow_window=12, signal_window=9, ewm=True, **kwargs):
    return super().from_params(ts, fast_window, slow_window, signal_window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.MACD.ewm_loc"><code class="name">var <span class="ident">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.fast_ma"><code class="name">var <span class="ident">fast_ma</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.fast_window_loc"><code class="name">var <span class="ident">fast_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter fast_window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.histogram"><code class="name">var <span class="ident">histogram</span></code></dt>
<dd>
<div class="desc"><p>Custom property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">histogram=lambda self: self.macd - self.signal,</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.macd"><code class="name">var <span class="ident">macd</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.signal"><code class="name">var <span class="ident">signal</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.signal_window_loc"><code class="name">var <span class="ident">signal_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter signal_window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.slow_ma"><code class="name">var <span class="ident">slow_ma</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.slow_window_loc"><code class="name">var <span class="ident">slow_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter slow_window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.ts"><code class="name">var <span class="ident">ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.tuple_loc"><code class="name">var <span class="ident">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter tuple using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.MACD.crossover"><code class="name flex">
<span>def <span class="ident">crossover</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crossover(self, **kwargs):
    above_signals = self.macd_above(self.signal, crossover=True, **kwargs)
    below_signals = self.macd_below(self.signal, crossover=True, **kwargs)
    return above_signals, below_signals</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.fast_ma_above"><code class="name flex">
<span>def <span class="ident">fast_ma_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>fast_ma</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>fast_ma</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.fast_ma_below"><code class="name flex">
<span>def <span class="ident">fast_ma_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>fast_ma</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>fast_ma</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.fast_ma_equal"><code class="name flex">
<span>def <span class="ident">fast_ma_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>fast_ma</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>fast_ma</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.histogram_above"><code class="name flex">
<span>def <span class="ident">histogram_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>histogram</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>histogram</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.histogram_below"><code class="name flex">
<span>def <span class="ident">histogram_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>histogram</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>histogram</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.histogram_equal"><code class="name flex">
<span>def <span class="ident">histogram_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>histogram</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>histogram</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.macd_above"><code class="name flex">
<span>def <span class="ident">macd_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>macd</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>macd</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.macd_below"><code class="name flex">
<span>def <span class="ident">macd_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>macd</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>macd</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.macd_equal"><code class="name flex">
<span>def <span class="ident">macd_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>macd</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>macd</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, macd_name=None, signal_name=None, macd_trace_kwargs={}, signal_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         macd_name=None,
         signal_name=None,
         macd_trace_kwargs={},
         signal_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    check_type(self.macd, pd.Series)
    check_type(self.signal, pd.Series)

    if macd_name is None:
        macd_name = f&#39;MACD ({self.name})&#39;
    if signal_name is None:
        signal_name = f&#39;Signal ({self.name})&#39;

    fig = self.macd.vbt.timeseries.plot(
        name=macd_name, trace_kwargs=macd_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.signal.vbt.timeseries.plot(
        name=signal_name, trace_kwargs=signal_trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.signal_above"><code class="name flex">
<span>def <span class="ident">signal_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>signal</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>signal</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.signal_below"><code class="name flex">
<span>def <span class="ident">signal_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>signal</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>signal</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.signal_equal"><code class="name flex">
<span>def <span class="ident">signal_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>signal</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>signal</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.slow_ma_above"><code class="name flex">
<span>def <span class="ident">slow_ma_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>slow_ma</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>slow_ma</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.slow_ma_below"><code class="name flex">
<span>def <span class="ident">slow_ma_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>slow_ma</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>slow_ma</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.slow_ma_equal"><code class="name flex">
<span>def <span class="ident">slow_ma_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>slow_ma</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>slow_ma</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.ts_above"><code class="name flex">
<span>def <span class="ident">ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.ts_below"><code class="name flex">
<span>def <span class="ident">ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.ts_equal"><code class="name flex">
<span>def <span class="ident">ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MACD.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.MSTD"><code class="flex name class">
<span>class <span class="ident">MSTD</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MSTD(MSTD):
    @classmethod
    def from_params(cls, ts, window, ewm=False, **kwargs):
        return super().from_params(ts, window, ewm, **kwargs)

    def plot(self,
             name=None,
             trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.mstd, pd.Series)

        if name is None:
            name = f&#39;MSTD ({self.name})&#39;

        fig = self.mstd.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.MSTD.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, window, ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the pipeline and initializes the class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, window, ewm=False, **kwargs):
    return super().from_params(ts, window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.MSTD.ewm_loc"><code class="name">var <span class="ident">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MSTD.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MSTD.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MSTD.mstd"><code class="name">var <span class="ident">mstd</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MSTD.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MSTD.ts"><code class="name">var <span class="ident">ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MSTD.tuple_loc"><code class="name">var <span class="ident">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter tuple using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MSTD.window_loc"><code class="name">var <span class="ident">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.MSTD.mstd_above"><code class="name flex">
<span>def <span class="ident">mstd_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>mstd</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>mstd</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MSTD.mstd_below"><code class="name flex">
<span>def <span class="ident">mstd_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>mstd</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>mstd</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MSTD.mstd_equal"><code class="name flex">
<span>def <span class="ident">mstd_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>mstd</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>mstd</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MSTD.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, name=None, trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         name=None,
         trace_kwargs={},
         fig=None,
         **layout_kwargs):
    check_type(self.mstd, pd.Series)

    if name is None:
        name = f&#39;MSTD ({self.name})&#39;

    fig = self.mstd.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MSTD.ts_above"><code class="name flex">
<span>def <span class="ident">ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MSTD.ts_below"><code class="name flex">
<span>def <span class="ident">ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MSTD.ts_equal"><code class="name flex">
<span>def <span class="ident">ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.MSTD.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.OBV"><code class="flex name class">
<span>class <span class="ident">OBV</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OBV(OBV):
    @classmethod
    def from_params(cls, close_ts, volume_ts):
        return super().from_params(close_ts, volume_ts)

    def plot(self,
             name=None,
             trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.obv, pd.Series)

        if name is None:
            name = f&#39;OBV ({self.name})&#39;

        fig = self.obv.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.OBV.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>close_ts, volume_ts)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the pipeline and initializes the class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, close_ts, volume_ts):
    return super().from_params(close_ts, volume_ts)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.OBV.close_ts"><code class="name">var <span class="ident">close_ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.obv"><code class="name">var <span class="ident">obv</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.volume_ts"><code class="name">var <span class="ident">volume_ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.OBV.close_ts_above"><code class="name flex">
<span>def <span class="ident">close_ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.close_ts_below"><code class="name flex">
<span>def <span class="ident">close_ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.close_ts_equal"><code class="name flex">
<span>def <span class="ident">close_ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.obv_above"><code class="name flex">
<span>def <span class="ident">obv_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>obv</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>obv</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.obv_below"><code class="name flex">
<span>def <span class="ident">obv_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>obv</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>obv</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.obv_equal"><code class="name flex">
<span>def <span class="ident">obv_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>obv</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>obv</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, name=None, trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         name=None,
         trace_kwargs={},
         fig=None,
         **layout_kwargs):
    check_type(self.obv, pd.Series)

    if name is None:
        name = f&#39;OBV ({self.name})&#39;

    fig = self.obv.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.volume_ts_above"><code class="name flex">
<span>def <span class="ident">volume_ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>volume_ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>volume_ts</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.volume_ts_below"><code class="name flex">
<span>def <span class="ident">volume_ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>volume_ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>volume_ts</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.volume_ts_equal"><code class="name flex">
<span>def <span class="ident">volume_ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>volume_ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>volume_ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.OBV.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.RSI"><code class="flex name class">
<span>class <span class="ident">RSI</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RSI(RSI):
    @classmethod
    def from_params(cls, ts, window=14, ewm=False, **kwargs):
        return super().from_params(ts, window, ewm, **kwargs)

    def plot(self,
             name=None,
             trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.rsi, pd.Series)

        if name is None:
            name = f&#39;RSI ({self.name})&#39;

        fig = self.rsi.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.RSI.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>ts, window=14, ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the pipeline and initializes the class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, ts, window=14, ewm=False, **kwargs):
    return super().from_params(ts, window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.RSI.ewm_loc"><code class="name">var <span class="ident">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.RSI.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.RSI.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.RSI.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.RSI.rsi"><code class="name">var <span class="ident">rsi</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.RSI.ts"><code class="name">var <span class="ident">ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.RSI.tuple_loc"><code class="name">var <span class="ident">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter tuple using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.RSI.window_loc"><code class="name">var <span class="ident">window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.RSI.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, name=None, trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         name=None,
         trace_kwargs={},
         fig=None,
         **layout_kwargs):
    check_type(self.rsi, pd.Series)

    if name is None:
        name = f&#39;RSI ({self.name})&#39;

    fig = self.rsi.vbt.timeseries.plot(name=name, trace_kwargs=trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.RSI.rsi_above"><code class="name flex">
<span>def <span class="ident">rsi_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>rsi</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>rsi</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.RSI.rsi_below"><code class="name flex">
<span>def <span class="ident">rsi_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>rsi</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>rsi</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.RSI.rsi_equal"><code class="name flex">
<span>def <span class="ident">rsi_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>rsi</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>rsi</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.RSI.ts_above"><code class="name flex">
<span>def <span class="ident">ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.RSI.ts_below"><code class="name flex">
<span>def <span class="ident">ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.RSI.ts_equal"><code class="name flex">
<span>def <span class="ident">ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.RSI.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.indicators.Stochastic"><code class="flex name class">
<span>class <span class="ident">Stochastic</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stochastic(Stochastic):
    @classmethod
    def from_params(cls, close_ts, high_ts=None, low_ts=None, k_window=14, d_window=3, ewm=False, **kwargs):
        if high_ts is None:
            high_ts = close_ts
        if low_ts is None:
            low_ts = close_ts
        return super().from_params(close_ts, high_ts, low_ts, k_window, d_window, ewm, **kwargs)

    def crossover(self, **kwargs):
        above_signals = self.percent_k_above(self.percent_d, crossover=True, **kwargs)
        below_signals = self.percent_k_below(self.percent_d, crossover=True, **kwargs)
        return above_signals, below_signals

    def plot(self,
             percent_k_name=None,
             percent_d_name=None,
             percent_k_trace_kwargs={},
             percent_d_trace_kwargs={},
             fig=None,
             **layout_kwargs):
        check_type(self.percent_k, pd.Series)
        check_type(self.percent_d, pd.Series)

        if percent_k_name is None:
            percent_k_name = f&#39;%K ({self.name})&#39;
        if percent_d_name is None:
            percent_d_name = f&#39;%D ({self.name})&#39;

        fig = self.percent_k.vbt.timeseries.plot(
            name=percent_k_name, trace_kwargs=percent_k_trace_kwargs, fig=fig, **layout_kwargs)
        fig = self.percent_d.vbt.timeseries.plot(
            name=percent_d_name, trace_kwargs=percent_d_trace_kwargs, fig=fig, **layout_kwargs)

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>vectorbt.indicators.CustomIndicator</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vectorbt.indicators.Stochastic.from_params"><code class="name flex">
<span>def <span class="ident">from_params</span></span>(<span>close_ts, high_ts=None, low_ts=None, k_window=14, d_window=3, ewm=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the pipeline and initializes the class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_params(cls, close_ts, high_ts=None, low_ts=None, k_window=14, d_window=3, ewm=False, **kwargs):
    if high_ts is None:
        high_ts = close_ts
    if low_ts is None:
        low_ts = close_ts
    return super().from_params(close_ts, high_ts, low_ts, k_window, d_window, ewm, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vectorbt.indicators.Stochastic.close_ts"><code class="name">var <span class="ident">close_ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.d_window_loc"><code class="name">var <span class="ident">d_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter d_window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.ewm_loc"><code class="name">var <span class="ident">ewm_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter ewm using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.high_ts"><code class="name">var <span class="ident">high_ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.iloc"><code class="name">var <span class="ident">iloc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html"><code>pandas.Series.iloc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"><code>pandas.DataFrame.iloc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iloc(self):
    return self._iloc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.k_window_loc"><code class="name">var <span class="ident">k_window_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter k_window using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html"><code>pandas.DataFrame.loc</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loc(self):
    &#34;&#34;&#34;Purely label-location based indexer for selection by label.&#34;&#34;&#34;
    return self._loc</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.low_ts"><code class="name">var <span class="ident">low_ts</span></code></dt>
<dd>
<div class="desc"><p>Input time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, ts_name=ts_name: getattr(self, &#39;_&#39; + ts_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the indicator (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self: self._name)</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.percent_d"><code class="name">var <span class="ident">percent_d</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.percent_k"><code class="name">var <span class="ident">percent_k</span></code></dt>
<dd>
<div class="desc"><p>Output time series (read-only).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">prop = property(lambda self, output_name=output_name: getattr(self, &#39;_&#39; + output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.tuple_loc"><code class="name">var <span class="ident">tuple_loc</span></code></dt>
<dd>
<div class="desc"><p>Access a group of columns by parameter tuple using
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.loc.html"><code>pandas.Series.loc</code></a>.</p>
<p>Forwards this operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_loc(self):
    return getattr(self, f&#39;_{param_name}_loc&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vectorbt.indicators.Stochastic.close_ts_above"><code class="name flex">
<span>def <span class="ident">close_ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.close_ts_below"><code class="name flex">
<span>def <span class="ident">close_ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.close_ts_equal"><code class="name flex">
<span>def <span class="ident">close_ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>close_ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>close_ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.crossover"><code class="name flex">
<span>def <span class="ident">crossover</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crossover(self, **kwargs):
    above_signals = self.percent_k_above(self.percent_d, crossover=True, **kwargs)
    below_signals = self.percent_k_below(self.percent_d, crossover=True, **kwargs)
    return above_signals, below_signals</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.high_ts_above"><code class="name flex">
<span>def <span class="ident">high_ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>high_ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high_ts</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.high_ts_below"><code class="name flex">
<span>def <span class="ident">high_ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>high_ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high_ts</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.high_ts_equal"><code class="name flex">
<span>def <span class="ident">high_ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>high_ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>high_ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.low_ts_above"><code class="name flex">
<span>def <span class="ident">low_ts_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>low_ts</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low_ts</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.low_ts_below"><code class="name flex">
<span>def <span class="ident">low_ts_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>low_ts</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low_ts</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.low_ts_equal"><code class="name flex">
<span>def <span class="ident">low_ts_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>low_ts</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>low_ts</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.percent_d_above"><code class="name flex">
<span>def <span class="ident">percent_d_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_d</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_d</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.percent_d_below"><code class="name flex">
<span>def <span class="ident">percent_d_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_d</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_d</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.percent_d_equal"><code class="name flex">
<span>def <span class="ident">percent_d_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_d</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_d</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.percent_k_above"><code class="name flex">
<span>def <span class="ident">percent_k_above</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_k</code> is above <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_k</code> is above for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.percent_k_below"><code class="name flex">
<span>def <span class="ident">percent_k_below</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_k</code> is below <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_k</code> is below for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.percent_k_equal"><code class="name flex">
<span>def <span class="ident">percent_k_equal</span></span>(<span>self, other, crossover=False, wait=0, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True when <code>percent_k</code> is equal <code>other</code>. </p>
<p>Set <code>crossover</code> to True to return the first True after crossover. Specify <code>wait</code> to return
True only when <code>percent_k</code> is equal for a number of time steps in a row after crossover.</p>
<p>Both will be broadcasted together. Set <code>multiple</code> to True to combine with multiple arguments.
For more keyword arguments, see <code><a title="vectorbt.utils.Base_Accessor.combine_with" href="utils.html#vectorbt.utils.Base_Accessor.combine_with">Base_Accessor.combine_with()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison_method(self, other, crossover=False, wait=0, name=None, **kwargs):
    if isinstance(other, self.__class__):
        other = getattr(other, attr)
    if name is None:
        if attr == self.name:
            name = f&#39;{self.name}_{func_name}&#39;
        else:
            name = f&#39;{self.name}_{attr}_{func_name}&#39;
    result = comparison_func(getattr(self, attr), other, name=name, **kwargs)
    if crossover:
        return result.vbt.signals.nst(wait+1, after_false=True)
    return result</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, percent_k_name=None, percent_d_name=None, percent_k_trace_kwargs={}, percent_d_trace_kwargs={}, fig=None, **layout_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         percent_k_name=None,
         percent_d_name=None,
         percent_k_trace_kwargs={},
         percent_d_trace_kwargs={},
         fig=None,
         **layout_kwargs):
    check_type(self.percent_k, pd.Series)
    check_type(self.percent_d, pd.Series)

    if percent_k_name is None:
        percent_k_name = f&#39;%K ({self.name})&#39;
    if percent_d_name is None:
        percent_d_name = f&#39;%D ({self.name})&#39;

    fig = self.percent_k.vbt.timeseries.plot(
        name=percent_k_name, trace_kwargs=percent_k_trace_kwargs, fig=fig, **layout_kwargs)
    fig = self.percent_d.vbt.timeseries.plot(
        name=percent_d_name, trace_kwargs=percent_d_trace_kwargs, fig=fig, **layout_kwargs)

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.indicators.Stochastic.xs"><code class="name flex">
<span>def <span class="ident">xs</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Forwards <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.xs.html"><code>pandas.Series.xs</code></a>/
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.xs.html"><code>pandas.DataFrame.xs</code></a>
operation to each Series/DataFrame and returns a new instance of <code>CustomIndicator</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xs(self, *args, **kwargs):
    &#34;&#34;&#34;Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.&#34;&#34;&#34;
    return indexing_func(self, lambda x: x.xs(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt" href="index.html">vectorbt</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.indicators.from_params_pipeline" href="#vectorbt.indicators.from_params_pipeline">from_params_pipeline</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.indicators.BollingerBands" href="#vectorbt.indicators.BollingerBands">BollingerBands</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.BollingerBands.alpha_loc" href="#vectorbt.indicators.BollingerBands.alpha_loc">alpha_loc</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.bandwidth" href="#vectorbt.indicators.BollingerBands.bandwidth">bandwidth</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.bandwidth_above" href="#vectorbt.indicators.BollingerBands.bandwidth_above">bandwidth_above</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.bandwidth_below" href="#vectorbt.indicators.BollingerBands.bandwidth_below">bandwidth_below</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.bandwidth_equal" href="#vectorbt.indicators.BollingerBands.bandwidth_equal">bandwidth_equal</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.ewm_loc" href="#vectorbt.indicators.BollingerBands.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.from_params" href="#vectorbt.indicators.BollingerBands.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.iloc" href="#vectorbt.indicators.BollingerBands.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.loc" href="#vectorbt.indicators.BollingerBands.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.lower_band" href="#vectorbt.indicators.BollingerBands.lower_band">lower_band</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.lower_band_above" href="#vectorbt.indicators.BollingerBands.lower_band_above">lower_band_above</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.lower_band_below" href="#vectorbt.indicators.BollingerBands.lower_band_below">lower_band_below</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.lower_band_equal" href="#vectorbt.indicators.BollingerBands.lower_band_equal">lower_band_equal</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.middle_band" href="#vectorbt.indicators.BollingerBands.middle_band">middle_band</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.middle_band_above" href="#vectorbt.indicators.BollingerBands.middle_band_above">middle_band_above</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.middle_band_below" href="#vectorbt.indicators.BollingerBands.middle_band_below">middle_band_below</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.middle_band_equal" href="#vectorbt.indicators.BollingerBands.middle_band_equal">middle_band_equal</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.name" href="#vectorbt.indicators.BollingerBands.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.percent_b" href="#vectorbt.indicators.BollingerBands.percent_b">percent_b</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.percent_b_above" href="#vectorbt.indicators.BollingerBands.percent_b_above">percent_b_above</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.percent_b_below" href="#vectorbt.indicators.BollingerBands.percent_b_below">percent_b_below</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.percent_b_equal" href="#vectorbt.indicators.BollingerBands.percent_b_equal">percent_b_equal</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.plot" href="#vectorbt.indicators.BollingerBands.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.ts" href="#vectorbt.indicators.BollingerBands.ts">ts</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.ts_above" href="#vectorbt.indicators.BollingerBands.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.ts_below" href="#vectorbt.indicators.BollingerBands.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.ts_equal" href="#vectorbt.indicators.BollingerBands.ts_equal">ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.tuple_loc" href="#vectorbt.indicators.BollingerBands.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.upper_band" href="#vectorbt.indicators.BollingerBands.upper_band">upper_band</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.upper_band_above" href="#vectorbt.indicators.BollingerBands.upper_band_above">upper_band_above</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.upper_band_below" href="#vectorbt.indicators.BollingerBands.upper_band_below">upper_band_below</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.upper_band_equal" href="#vectorbt.indicators.BollingerBands.upper_band_equal">upper_band_equal</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.window_loc" href="#vectorbt.indicators.BollingerBands.window_loc">window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.BollingerBands.xs" href="#vectorbt.indicators.BollingerBands.xs">xs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.IndicatorFactory" href="#vectorbt.indicators.IndicatorFactory">IndicatorFactory</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.indicators.IndicatorFactory.from_apply_func" href="#vectorbt.indicators.IndicatorFactory.from_apply_func">from_apply_func</a></code></li>
<li><code><a title="vectorbt.indicators.IndicatorFactory.from_custom_func" href="#vectorbt.indicators.IndicatorFactory.from_custom_func">from_custom_func</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.MA" href="#vectorbt.indicators.MA">MA</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.MA.ewm_loc" href="#vectorbt.indicators.MA.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.MA.from_combinations" href="#vectorbt.indicators.MA.from_combinations">from_combinations</a></code></li>
<li><code><a title="vectorbt.indicators.MA.from_params" href="#vectorbt.indicators.MA.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.MA.iloc" href="#vectorbt.indicators.MA.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.MA.loc" href="#vectorbt.indicators.MA.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.MA.ma" href="#vectorbt.indicators.MA.ma">ma</a></code></li>
<li><code><a title="vectorbt.indicators.MA.ma_above" href="#vectorbt.indicators.MA.ma_above">ma_above</a></code></li>
<li><code><a title="vectorbt.indicators.MA.ma_below" href="#vectorbt.indicators.MA.ma_below">ma_below</a></code></li>
<li><code><a title="vectorbt.indicators.MA.ma_equal" href="#vectorbt.indicators.MA.ma_equal">ma_equal</a></code></li>
<li><code><a title="vectorbt.indicators.MA.name" href="#vectorbt.indicators.MA.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.MA.plot" href="#vectorbt.indicators.MA.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.MA.ts" href="#vectorbt.indicators.MA.ts">ts</a></code></li>
<li><code><a title="vectorbt.indicators.MA.ts_above" href="#vectorbt.indicators.MA.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.MA.ts_below" href="#vectorbt.indicators.MA.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.MA.ts_equal" href="#vectorbt.indicators.MA.ts_equal">ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.MA.tuple_loc" href="#vectorbt.indicators.MA.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.MA.window_loc" href="#vectorbt.indicators.MA.window_loc">window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.MA.xs" href="#vectorbt.indicators.MA.xs">xs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.MACD" href="#vectorbt.indicators.MACD">MACD</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.MACD.crossover" href="#vectorbt.indicators.MACD.crossover">crossover</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.ewm_loc" href="#vectorbt.indicators.MACD.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.fast_ma" href="#vectorbt.indicators.MACD.fast_ma">fast_ma</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.fast_ma_above" href="#vectorbt.indicators.MACD.fast_ma_above">fast_ma_above</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.fast_ma_below" href="#vectorbt.indicators.MACD.fast_ma_below">fast_ma_below</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.fast_ma_equal" href="#vectorbt.indicators.MACD.fast_ma_equal">fast_ma_equal</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.fast_window_loc" href="#vectorbt.indicators.MACD.fast_window_loc">fast_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.from_params" href="#vectorbt.indicators.MACD.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.histogram" href="#vectorbt.indicators.MACD.histogram">histogram</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.histogram_above" href="#vectorbt.indicators.MACD.histogram_above">histogram_above</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.histogram_below" href="#vectorbt.indicators.MACD.histogram_below">histogram_below</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.histogram_equal" href="#vectorbt.indicators.MACD.histogram_equal">histogram_equal</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.iloc" href="#vectorbt.indicators.MACD.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.loc" href="#vectorbt.indicators.MACD.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.macd" href="#vectorbt.indicators.MACD.macd">macd</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.macd_above" href="#vectorbt.indicators.MACD.macd_above">macd_above</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.macd_below" href="#vectorbt.indicators.MACD.macd_below">macd_below</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.macd_equal" href="#vectorbt.indicators.MACD.macd_equal">macd_equal</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.name" href="#vectorbt.indicators.MACD.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.plot" href="#vectorbt.indicators.MACD.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.signal" href="#vectorbt.indicators.MACD.signal">signal</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.signal_above" href="#vectorbt.indicators.MACD.signal_above">signal_above</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.signal_below" href="#vectorbt.indicators.MACD.signal_below">signal_below</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.signal_equal" href="#vectorbt.indicators.MACD.signal_equal">signal_equal</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.signal_window_loc" href="#vectorbt.indicators.MACD.signal_window_loc">signal_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.slow_ma" href="#vectorbt.indicators.MACD.slow_ma">slow_ma</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.slow_ma_above" href="#vectorbt.indicators.MACD.slow_ma_above">slow_ma_above</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.slow_ma_below" href="#vectorbt.indicators.MACD.slow_ma_below">slow_ma_below</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.slow_ma_equal" href="#vectorbt.indicators.MACD.slow_ma_equal">slow_ma_equal</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.slow_window_loc" href="#vectorbt.indicators.MACD.slow_window_loc">slow_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.ts" href="#vectorbt.indicators.MACD.ts">ts</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.ts_above" href="#vectorbt.indicators.MACD.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.ts_below" href="#vectorbt.indicators.MACD.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.ts_equal" href="#vectorbt.indicators.MACD.ts_equal">ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.tuple_loc" href="#vectorbt.indicators.MACD.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.MACD.xs" href="#vectorbt.indicators.MACD.xs">xs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.MSTD" href="#vectorbt.indicators.MSTD">MSTD</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.MSTD.ewm_loc" href="#vectorbt.indicators.MSTD.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.from_params" href="#vectorbt.indicators.MSTD.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.iloc" href="#vectorbt.indicators.MSTD.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.loc" href="#vectorbt.indicators.MSTD.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.mstd" href="#vectorbt.indicators.MSTD.mstd">mstd</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.mstd_above" href="#vectorbt.indicators.MSTD.mstd_above">mstd_above</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.mstd_below" href="#vectorbt.indicators.MSTD.mstd_below">mstd_below</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.mstd_equal" href="#vectorbt.indicators.MSTD.mstd_equal">mstd_equal</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.name" href="#vectorbt.indicators.MSTD.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.plot" href="#vectorbt.indicators.MSTD.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.ts" href="#vectorbt.indicators.MSTD.ts">ts</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.ts_above" href="#vectorbt.indicators.MSTD.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.ts_below" href="#vectorbt.indicators.MSTD.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.ts_equal" href="#vectorbt.indicators.MSTD.ts_equal">ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.tuple_loc" href="#vectorbt.indicators.MSTD.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.window_loc" href="#vectorbt.indicators.MSTD.window_loc">window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.MSTD.xs" href="#vectorbt.indicators.MSTD.xs">xs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.OBV" href="#vectorbt.indicators.OBV">OBV</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.OBV.close_ts" href="#vectorbt.indicators.OBV.close_ts">close_ts</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.close_ts_above" href="#vectorbt.indicators.OBV.close_ts_above">close_ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.close_ts_below" href="#vectorbt.indicators.OBV.close_ts_below">close_ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.close_ts_equal" href="#vectorbt.indicators.OBV.close_ts_equal">close_ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.from_params" href="#vectorbt.indicators.OBV.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.iloc" href="#vectorbt.indicators.OBV.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.loc" href="#vectorbt.indicators.OBV.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.name" href="#vectorbt.indicators.OBV.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.obv" href="#vectorbt.indicators.OBV.obv">obv</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.obv_above" href="#vectorbt.indicators.OBV.obv_above">obv_above</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.obv_below" href="#vectorbt.indicators.OBV.obv_below">obv_below</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.obv_equal" href="#vectorbt.indicators.OBV.obv_equal">obv_equal</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.plot" href="#vectorbt.indicators.OBV.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.volume_ts" href="#vectorbt.indicators.OBV.volume_ts">volume_ts</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.volume_ts_above" href="#vectorbt.indicators.OBV.volume_ts_above">volume_ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.volume_ts_below" href="#vectorbt.indicators.OBV.volume_ts_below">volume_ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.volume_ts_equal" href="#vectorbt.indicators.OBV.volume_ts_equal">volume_ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.OBV.xs" href="#vectorbt.indicators.OBV.xs">xs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.RSI" href="#vectorbt.indicators.RSI">RSI</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.RSI.ewm_loc" href="#vectorbt.indicators.RSI.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.from_params" href="#vectorbt.indicators.RSI.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.iloc" href="#vectorbt.indicators.RSI.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.loc" href="#vectorbt.indicators.RSI.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.name" href="#vectorbt.indicators.RSI.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.plot" href="#vectorbt.indicators.RSI.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.rsi" href="#vectorbt.indicators.RSI.rsi">rsi</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.rsi_above" href="#vectorbt.indicators.RSI.rsi_above">rsi_above</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.rsi_below" href="#vectorbt.indicators.RSI.rsi_below">rsi_below</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.rsi_equal" href="#vectorbt.indicators.RSI.rsi_equal">rsi_equal</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.ts" href="#vectorbt.indicators.RSI.ts">ts</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.ts_above" href="#vectorbt.indicators.RSI.ts_above">ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.ts_below" href="#vectorbt.indicators.RSI.ts_below">ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.ts_equal" href="#vectorbt.indicators.RSI.ts_equal">ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.tuple_loc" href="#vectorbt.indicators.RSI.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.window_loc" href="#vectorbt.indicators.RSI.window_loc">window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.RSI.xs" href="#vectorbt.indicators.RSI.xs">xs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.indicators.Stochastic" href="#vectorbt.indicators.Stochastic">Stochastic</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.indicators.Stochastic.close_ts" href="#vectorbt.indicators.Stochastic.close_ts">close_ts</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.close_ts_above" href="#vectorbt.indicators.Stochastic.close_ts_above">close_ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.close_ts_below" href="#vectorbt.indicators.Stochastic.close_ts_below">close_ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.close_ts_equal" href="#vectorbt.indicators.Stochastic.close_ts_equal">close_ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.crossover" href="#vectorbt.indicators.Stochastic.crossover">crossover</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.d_window_loc" href="#vectorbt.indicators.Stochastic.d_window_loc">d_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.ewm_loc" href="#vectorbt.indicators.Stochastic.ewm_loc">ewm_loc</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.from_params" href="#vectorbt.indicators.Stochastic.from_params">from_params</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.high_ts" href="#vectorbt.indicators.Stochastic.high_ts">high_ts</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.high_ts_above" href="#vectorbt.indicators.Stochastic.high_ts_above">high_ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.high_ts_below" href="#vectorbt.indicators.Stochastic.high_ts_below">high_ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.high_ts_equal" href="#vectorbt.indicators.Stochastic.high_ts_equal">high_ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.iloc" href="#vectorbt.indicators.Stochastic.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.k_window_loc" href="#vectorbt.indicators.Stochastic.k_window_loc">k_window_loc</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.loc" href="#vectorbt.indicators.Stochastic.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.low_ts" href="#vectorbt.indicators.Stochastic.low_ts">low_ts</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.low_ts_above" href="#vectorbt.indicators.Stochastic.low_ts_above">low_ts_above</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.low_ts_below" href="#vectorbt.indicators.Stochastic.low_ts_below">low_ts_below</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.low_ts_equal" href="#vectorbt.indicators.Stochastic.low_ts_equal">low_ts_equal</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.name" href="#vectorbt.indicators.Stochastic.name">name</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.percent_d" href="#vectorbt.indicators.Stochastic.percent_d">percent_d</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.percent_d_above" href="#vectorbt.indicators.Stochastic.percent_d_above">percent_d_above</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.percent_d_below" href="#vectorbt.indicators.Stochastic.percent_d_below">percent_d_below</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.percent_d_equal" href="#vectorbt.indicators.Stochastic.percent_d_equal">percent_d_equal</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.percent_k" href="#vectorbt.indicators.Stochastic.percent_k">percent_k</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.percent_k_above" href="#vectorbt.indicators.Stochastic.percent_k_above">percent_k_above</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.percent_k_below" href="#vectorbt.indicators.Stochastic.percent_k_below">percent_k_below</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.percent_k_equal" href="#vectorbt.indicators.Stochastic.percent_k_equal">percent_k_equal</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.plot" href="#vectorbt.indicators.Stochastic.plot">plot</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.tuple_loc" href="#vectorbt.indicators.Stochastic.tuple_loc">tuple_loc</a></code></li>
<li><code><a title="vectorbt.indicators.Stochastic.xs" href="#vectorbt.indicators.Stochastic.xs">xs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>